Project Path: arc_0xeb_windbg-copilot_ih8p7w9m

Source Tree:

```txt
arc_0xeb_windbg-copilot_ih8p7w9m
├── CMakeLists.txt
├── CMakePresets.json
├── README.md
├── assets
│   ├── ask_threads.jpg
│   ├── crash_analysis.jpg
│   ├── decompile.jpg
│   ├── handoff_ask.jpg
│   ├── handoff_claude_code.jpg
│   ├── handoff_exec.jpg
│   ├── handoff_interactive.jpg
│   ├── handoff_start.jpg
│   └── loading.jpg
├── build.bat
├── cli
│   └── main.cpp
├── dml_output.cpp
├── dml_output.hpp
├── external
│   └── libagents
├── http_server.cpp
├── http_server.hpp
├── main.cpp
├── mcp_server.cpp
├── mcp_server.hpp
├── output_capture.cpp
├── output_capture.hpp
├── session_store.cpp
├── session_store.hpp
├── settings.cpp
├── settings.hpp
├── system_prompt.hpp
├── version.h.in
├── windbg_agent.def
├── windbg_client.cpp
└── windbg_client.hpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(windbg_agent VERSION 1.0.4 LANGUAGES CXX)

# Generate version.h from template — single source of truth for version numbers
configure_file(version.h.in "${CMAKE_CURRENT_BINARY_DIR}/version.h" @ONLY)

# C++ Standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Static runtime for Release builds (no MSVC DLL dependencies)
# Debug and other configs use default dynamic runtime
set(CMAKE_MSVC_RUNTIME_LIBRARY "$<IF:$<CONFIG:Release>,MultiThreaded,$<IF:$<CONFIG:Debug>,MultiThreadedDebugDLL,MultiThreadedDLL>>")

# Windows-specific settings
if(NOT WIN32)
    message(STATUS "windbg_agent only builds on Windows - skipping")
    return()
endif()

# Add libagents if building standalone (not part of monorepo)
if(NOT TARGET libagents)
    add_subdirectory(external/libagents)
endif()

# Fetch cpp-httplib for HTTP server and CLI
include(FetchContent)
FetchContent_Declare(
    cpp_httplib
    GIT_REPOSITORY https://github.com/yhirose/cpp-httplib.git
    GIT_TAG v0.15.3
)
FetchContent_MakeAvailable(cpp_httplib)

# windbg_agent DLL
add_library(windbg_agent SHARED
    main.cpp
    output_capture.cpp
    settings.cpp
    session_store.cpp
    dml_output.cpp
    windbg_client.cpp
    http_server.cpp
    mcp_server.cpp
)

# Module definition file: forces undecorated export names on Win32 (x86)
target_sources(windbg_agent PRIVATE windbg_agent.def)

# Link with libagents and Windows debugging libraries
target_link_libraries(windbg_agent
    PRIVATE
        libagents         # Unified provider library
        fastmcpp_core     # MCP server library (via libagents/claude-agent-sdk-cpp)
        dbgeng            # Debugging Engine API
        dbghelp           # Debug Help Library
        ws2_32            # Winsock for HTTP server
)

# Include httplib headers (no OpenSSL needed for localhost) and generated version.h
target_include_directories(windbg_agent PRIVATE ${cpp_httplib_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})

# Export symbols for WinDbg extension callbacks
target_compile_definitions(windbg_agent PRIVATE
    _WINDOWS
    UNICODE
    _UNICODE
)

# Set output name without lib prefix
set_target_properties(windbg_agent PROPERTIES
    PREFIX ""
    OUTPUT_NAME "windbg_agent"
)

# Standalone tests may live under this repo or the top-level tests/windbg directory.
set(WINDBG_TESTS_DIR "${CMAKE_CURRENT_SOURCE_DIR}/tests")
if(NOT EXISTS "${WINDBG_TESTS_DIR}/session_restore_test.cpp")
    set(WINDBG_TESTS_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../tests/windbg")
endif()

# Session restore test (standalone SDK test)
if(EXISTS "${WINDBG_TESTS_DIR}/session_restore_test.cpp")
    add_executable(session_restore_test
        ${WINDBG_TESTS_DIR}/session_restore_test.cpp
    )
    target_link_libraries(session_restore_test PRIVATE libagents)
endif()

# MCP tool test (verify MCP tools work)
if(EXISTS "${WINDBG_TESTS_DIR}/test_mcp_tool.cpp")
    add_executable(test_mcp_tool
        ${WINDBG_TESTS_DIR}/test_mcp_tool.cpp
    )
    target_link_libraries(test_mcp_tool PRIVATE libagents)
endif()

# Repro test for MCP tool visibility issue
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/repro/CMakeLists.txt")
    add_subdirectory(repro)
endif()

# ============================================================================
# HTTP server CLI executable (disabled — source stays in cli/ for future use)
# ============================================================================
# add_executable(windbg_agent_cli
#     cli/main.cpp
#     settings.cpp
# )
#
# target_include_directories(windbg_agent_cli PRIVATE
#     ${cpp_httplib_SOURCE_DIR}
#     ${CMAKE_CURRENT_SOURCE_DIR}
#     ${CMAKE_CURRENT_BINARY_DIR}
# )
#
# target_link_libraries(windbg_agent_cli PRIVATE
#     libagents
#     nlohmann_json::nlohmann_json
#     ws2_32
# )
#
# set_target_properties(windbg_agent_cli PROPERTIES
#     OUTPUT_NAME "windbg_agent"
# )
#
# set_target_properties(windbg_agent_cli PROPERTIES
#     MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>"
# )


```

`CMakePresets.json`:

```json
{
  "version": 6,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 21,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "base",
      "hidden": true,
      "generator": "Visual Studio 17 2022",
      "binaryDir": "${sourceDir}/build-${presetName}",
      "cacheVariables": {
        "CMAKE_INSTALL_PREFIX": "${sourceDir}/install-${presetName}"
      }
    },
    {
      "name": "x86",
      "displayName": "x86 (Win32) Release",
      "inherits": "base",
      "architecture": {
        "value": "Win32",
        "strategy": "set"
      }
    },
    {
      "name": "x64",
      "displayName": "x64 Release",
      "inherits": "base",
      "architecture": {
        "value": "x64",
        "strategy": "set"
      }
    },
    {
      "name": "x64-debug",
      "displayName": "x64 Debug",
      "inherits": "x64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug"
      }
    },
    {
      "name": "arm64",
      "displayName": "ARM64 Release",
      "inherits": "base",
      "architecture": {
        "value": "ARM64",
        "strategy": "set"
      }
    },
    {
      "name": "arm64-debug",
      "displayName": "ARM64 Debug",
      "inherits": "arm64",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug"
      }
    },
    {
      "name": "arm64-cross",
      "displayName": "ARM64 Cross-compile (from x64)",
      "inherits": "base",
      "architecture": {
        "value": "ARM64",
        "strategy": "set"
      },
      "toolset": {
        "value": "host=x64",
        "strategy": "set"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "x86",
      "configurePreset": "x86",
      "configuration": "Release"
    },
    {
      "name": "x64",
      "configurePreset": "x64",
      "configuration": "Release"
    },
    {
      "name": "x64-debug",
      "configurePreset": "x64-debug",
      "configuration": "Debug"
    },
    {
      "name": "arm64",
      "configurePreset": "arm64",
      "configuration": "Release"
    },
    {
      "name": "arm64-debug",
      "configurePreset": "arm64-debug",
      "configuration": "Debug"
    },
    {
      "name": "arm64-cross",
      "configurePreset": "arm64-cross",
      "configuration": "Release"
    }
  ],
  "testPresets": [
    {
      "name": "x64",
      "configurePreset": "x64",
      "configuration": "Release",
      "output": {
        "outputOnFailure": true
      }
    }
  ]
}

```

`README.md`:

```md
# WinDbg Agent

AI-powered debugging assistant for WinDbg. Ask questions about your debug session and get intelligent answers with automatic debugger command execution.

Supports multiple AI providers:
- **GitHub Copilot** - via [copilot-sdk-cpp](https://github.com/0xeb/copilot-sdk-cpp)
- **Claude** (Anthropic) - via [claude-agent-sdk-cpp](https://github.com/0xeb/claude-agent-sdk-cpp)

## Building

### Prerequisites
- Windows 10/11
- Visual Studio 2022 with C++ workload (2019 also works — [see below](#alternative-no-visual-studio-2022))
- CMake 3.20+
- Windows SDK (for dbgeng.h)

### Build Steps

```bash
# Clone with submodules
git clone --recursive https://github.com/0xeb/windbg-agent.git
cd windbg-agent

# Build for x64 (most common)
cmake --preset x64
cmake --build --preset x64

# Build for x86 (32-bit targets)
cmake --preset x86
cmake --build --preset x86
```

Output:
- **x64**: `build-x64/Release/windbg_agent.dll`
- **x86**: `build-x86/Release/windbg_agent.dll`

### Alternative: No Visual Studio 2022

If you have a different Visual Studio version or just the Build Tools, skip the presets and specify the generator manually:

```bash
# Visual Studio 2019 — x64
cmake -B build-x64 -G "Visual Studio 16 2019" -A x64
cmake --build build-x64 --config Release

# Visual Studio 2019 — x86 (32-bit targets)
cmake -B build-x86 -G "Visual Studio 16 2019" -A Win32
cmake --build build-x86 --config Release

# Ninja (works with any MSVC version — run from Developer Command Prompt)
cmake -B build-x64 -G Ninja -DCMAKE_BUILD_TYPE=Release
cmake --build build-x64
```

> **Ninja x86 note**: For 32-bit Ninja builds, open the **x86 Native Tools Command Prompt** (instead of x64) so `cl.exe` targets Win32.

## Usage

### Loading the Extension

1. Open WinDbg and load a dump file or attach to a process
2. Load the extension:

```
.load C:\path\to\windbg_agent.dll
```

> **Note:** The extension DLL architecture must match the target. Use the x86 build when debugging 32-bit processes, and the x64 build for 64-bit processes.

### Commands

| Command | Description |
|---------|-------------|
| `!agent help` | Show help |
| `!agent version` | Show version and current provider |
| `!agent provider` | Show current provider |
| `!agent provider <name>` | Switch provider (claude, copilot) |
| `!agent ask <question>` | Ask the AI a question |
| `!agent clear` | Clear conversation history |
| `!agent prompt` | Show current custom prompt |
| `!agent prompt <text>` | Set custom prompt (appended to system prompt) |
| `!agent prompt clear` | Clear custom prompt |
| `!agent http [bind_addr]` | Start HTTP server for external tools (port auto-assigned) |
| `!agent mcp [bind_addr]` | Start MCP server for MCP-compatible clients |
| `!agent version prompt` | Show injected system prompt |
| `!ai <question>` | Shorthand for `!agent ask` |

### Examples

```
# Ask about the current state
!ai what is the call stack?
!ai what is rax + rbx?

# Run commands directly - AI executes and explains
!ai db @rip L20
!ai !peb

# Decompilation
!ai decompile ntdll!RtlAllocateHeap

# Follow-up questions (uses conversation history)
!ai what about the registers?

# Ask for analysis
!ai explain this crash

# Switch to Claude provider
!agent provider claude

# Set a custom prompt for your debugging session
!agent prompt Focus on memory corruption and heap issues

# Clear history and start fresh
!agent clear
```

### HTTP Server (External Tool Integration)

Let external AI agents control the debugger via HTTP:

```bash
# In WinDbg - start the HTTP server
!agent http                  # localhost only (default)
!agent http 0.0.0.0          # all interfaces (no auth warning)

# From another terminal - use the CLI tool (use the URL printed by !agent http)
windbg_agent.exe --url=http://127.0.0.1:<port> ask "what caused this crash?"
windbg_agent.exe --url=http://127.0.0.1:<port> exec "kb"
windbg_agent.exe --url=http://127.0.0.1:<port> interactive
windbg_agent.exe --url=http://127.0.0.1:<port> status
windbg_agent.exe --url=http://127.0.0.1:<port> shutdown
```

Settings are saved in `%USERPROFILE%\.windbg_agent\settings.json`.

## Features

- **Direct command execution**: Pass debugger commands directly (`!ai db @rsp L10`) - AI runs and explains
- **Expression evaluation**: Uses `?`, `??`, `dx` for calculations instead of guessing
- **Decompilation**: Ask to decompile functions - AI uses `uf`, `dv`, `dt` to generate pseudocode
- **Automatic tool execution**: AI runs debugger commands to gather information
- **Conversation continuity**: Follow-up questions remember context
- **Session persistence**: Claude restores sessions across debugger restarts
- **Multiple providers**: Switch between Claude and Copilot
- **HTTP Server**: Let external AI agents (like Copilot or Claude Code) control the debugger

## Screenshots

### Debugging a Double-Free Bug

AI analyzes a heap corruption crash, identifies the root cause, and offers next steps:

![Crash analysis](assets/crash_analysis.jpg)

User asks for decompilation — AI generates readable pseudocode from assembly:

![Decompilation](assets/decompile.jpg)

### HTTP Server: External Tool Integration

Start `!agent http` to let external tools control WinDbg. The CLI executes commands remotely:

![Handoff with CLI exec](assets/handoff_exec.jpg)

Claude Code (Opus 4.5) controlling WinDbg via HTTP server — analyzing a double-free crash:

![Claude Code controlling WinDbg](assets/handoff_claude_code.jpg)

## Author

Elias Bachaalany ([@0xeb](https://github.com/0xeb))

Pair-programmed with Claude Code and Codex.

## License

MIT

```

`build.bat`:

```bat
@echo off
call "C:\Program Files\Microsoft Visual Studio\2022\Professional\VC\Auxiliary\Build\vcvars64.bat"
cd /d C:\Users\elias\Projects\github\cc_windbg\dbgagent
if not exist build mkdir build
cd build
cmake .. -G "Visual Studio 17 2022" -A x64
cmake --build . --config Release

```

`cli/main.cpp`:

```cpp
#include <iostream>
#include <string>
#include <cstdlib>

#include <httplib.h>
#include <nlohmann/json.hpp>

#include "../settings.hpp"

// TODO: Evolve windbg_agent.exe into a standalone headless debugger.
//
// Currently this is an HTTP client that talks to a running !agent http server
// inside WinDbg/CDB. The goal is to make it a self-contained tool that:
//
//   1. Host dbgeng directly — call DebugCreate() to get IDebugClient, attach
//      to processes (CreateProcess/AttachProcess) or open dumps (OpenDumpFile),
//      and run a debugger event loop. Essentially a programmable cdb.exe.
//
//   2. Serve HTTP/MCP — reuse the existing HttpServer and MCPServer to expose
//      /exec, /ask, /status, /shutdown endpoints. External AI agents (Claude
//      Code, Copilot, etc.) connect here to drive the debugger.
//
//   3. Keep the current HTTP client mode — when --url is given or no target is
//      specified, behave as today: forward commands to a remote server.
//
// This turns a single binary into both the debugger and its integration layer:
//   windbg_agent.exe -z crash.dmp --serve        # open dump + start server
//   windbg_agent.exe -p 1234 --serve              # attach to PID + serve
//   windbg_agent.exe --url=http://... exec "kb"   # client mode (current)
//
// Key pieces needed:
//   - Debugger init: DebugCreate(), IDebugClient, IDebugControl
//   - Target management: -z (dump), -p (attach), spawn process
//   - Event loop: WaitForEvent / DispatchCallbacks
//   - Console output: replace DML with plain-text for headless use
//   - HttpServer/MCPServer already work standalone (no WinDbg dependency)

void print_usage() {
    std::cerr << "Usage: windbg_agent.exe [--url=URL] <command> [args]\n\n";
    std::cerr << "Commands:\n";
    std::cerr << "  exec <cmd>       Run debugger command, return raw output\n";
    std::cerr << "  ask <question>   AI-assisted query with reasoning\n";
    std::cerr << "  interactive      Start interactive chat session\n";
    std::cerr << "  status           Check server status\n";
    std::cerr << "  shutdown         Stop HTTP server\n\n";
    std::cerr << "Config commands (no server required):\n";
    std::cerr << "  config show              Show all settings\n";
    std::cerr << "  config provider <name>   Set default provider (claude, copilot)\n";
    std::cerr << "  config byok              Show BYOK status for current provider\n";
    std::cerr << "  config byok key <val>    Set BYOK API key\n";
    std::cerr << "  config byok endpoint <url>  Set BYOK endpoint\n";
    std::cerr << "  config byok model <name>    Set BYOK model\n";
    std::cerr << "  config byok type <type>     Set BYOK type (openai, anthropic, azure)\n";
    std::cerr << "  config byok enable       Enable BYOK\n";
    std::cerr << "  config byok disable      Disable BYOK\n\n";
    std::cerr << "Environment:\n";
    std::cerr << "  WINDBG_AGENT_URL     HTTP server URL (default: http://127.0.0.1:9999)\n";
}

std::string get_url(int argc, char* argv[]) {
    // Priority: --url=X flag > WINDBG_AGENT_URL env > default
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        if (arg.rfind("--url=", 0) == 0) {
            return arg.substr(6);
        }
    }
    if (const char* env = std::getenv("WINDBG_AGENT_URL")) {
        return env;
    }
    return "http://127.0.0.1:9999";
}

class HttpClient {
public:
    explicit HttpClient(const std::string& url) : url_(url) {
        // Parse host and port from URL
        // Format: http://host:port
        std::string host_port = url;
        if (host_port.rfind("http://", 0) == 0) {
            host_port = host_port.substr(7);
        }
        client_ = std::make_unique<httplib::Client>(url);
        client_->set_read_timeout(120, 0);  // 120 seconds for AI queries
        client_->set_connection_timeout(5, 0);
    }

    std::string exec(const std::string& cmd) {
        nlohmann::json body = {{"command", cmd}};
        auto res = client_->Post("/exec", body.dump(), "application/json");

        if (!res) {
            throw std::runtime_error("Connection failed - is HTTP server running?");
        }
        if (res->status != 200) {
            auto json = nlohmann::json::parse(res->body);
            throw std::runtime_error(json.value("error", "Request failed"));
        }

        auto json = nlohmann::json::parse(res->body);
        return json.value("output", "");
    }

    std::string ask(const std::string& query) {
        nlohmann::json body = {{"query", query}};
        auto res = client_->Post("/ask", body.dump(), "application/json");

        if (!res) {
            throw std::runtime_error("Connection failed - is HTTP server running?");
        }
        if (res->status != 200) {
            auto json = nlohmann::json::parse(res->body);
            throw std::runtime_error(json.value("error", "Request failed"));
        }

        auto json = nlohmann::json::parse(res->body);
        return json.value("response", "");
    }

    std::string status() {
        auto res = client_->Get("/status");
        if (!res) {
            throw std::runtime_error("Connection failed - is HTTP server running?");
        }
        return res->body;
    }

    void shutdown() {
        auto res = client_->Post("/shutdown", "", "application/json");
        if (!res) {
            throw std::runtime_error("Connection failed - is HTTP server running?");
        }
    }

private:
    std::string url_;
    std::unique_ptr<httplib::Client> client_;
};

// ─────────────────────────────────────────────────────────────────────────────
// Config commands (no server required)
// ─────────────────────────────────────────────────────────────────────────────

int run_config(int argc, char* argv[], int cmd_idx) {
    using namespace windbg_agent;

    // Collect remaining args
    std::vector<std::string> args;
    for (int i = cmd_idx + 1; i < argc; i++) {
        args.push_back(argv[i]);
    }

    if (args.empty() || args[0] == "show") {
        // Show all settings
        auto settings = LoadSettings();
        std::cout << "Settings file: " << GetSettingsPath() << "\n\n";
        std::cout << "Provider: " << libagents::provider_type_name(settings.default_provider) << "\n";
        std::cout << "Response timeout: " << settings.response_timeout_ms << " ms\n";
        if (!settings.custom_prompt.empty()) {
            std::cout << "Custom prompt: " << settings.custom_prompt << "\n";
        }
        std::cout << "\nBYOK configurations:\n";
        if (settings.byok.empty()) {
            std::cout << "  (none configured)\n";
        } else {
            for (const auto& [provider, byok] : settings.byok) {
                std::cout << "  " << provider << ":\n";
                std::cout << "    Enabled:  " << (byok.enabled ? "yes" : "no") << "\n";
                std::cout << "    API Key:  " << (byok.api_key.empty() ? "(not set)" : "********") << "\n";
                std::cout << "    Endpoint: " << (byok.base_url.empty() ? "(default)" : byok.base_url) << "\n";
                std::cout << "    Model:    " << (byok.model.empty() ? "(default)" : byok.model) << "\n";
                std::cout << "    Type:     " << (byok.provider_type.empty() ? "(default)" : byok.provider_type) << "\n";
            }
        }
        return 0;
    }

    if (args[0] == "provider") {
        if (args.size() < 2) {
            auto settings = LoadSettings();
            std::cout << "Current provider: " << libagents::provider_type_name(settings.default_provider) << "\n";
            return 0;
        }
        auto settings = LoadSettings();
        settings.default_provider = ParseProviderType(args[1]);
        SaveSettings(settings);
        std::cout << "Provider set to: " << libagents::provider_type_name(settings.default_provider) << "\n";
        return 0;
    }

    if (args[0] == "byok") {
        auto settings = LoadSettings();
        std::string provider_name = libagents::provider_type_name(settings.default_provider);

        if (args.size() < 2) {
            // Show BYOK status for current provider
            const auto* byok = settings.get_byok();
            std::cout << "BYOK status for provider '" << provider_name << "':\n";
            if (byok) {
                std::cout << "  Enabled:  " << (byok->enabled ? "yes" : "no") << "\n";
                std::cout << "  API Key:  " << (byok->api_key.empty() ? "(not set)" : "********") << "\n";
                std::cout << "  Endpoint: " << (byok->base_url.empty() ? "(default)" : byok->base_url) << "\n";
                std::cout << "  Model:    " << (byok->model.empty() ? "(default)" : byok->model) << "\n";
                std::cout << "  Type:     " << (byok->provider_type.empty() ? "(default)" : byok->provider_type) << "\n";
                std::cout << "  Usable:   " << (byok->is_usable() ? "yes" : "no") << "\n";
            } else {
                std::cout << "  (not configured)\n";
            }
            return 0;
        }

        std::string subcmd = args[1];
        std::string value = args.size() > 2 ? args[2] : "";

        if (subcmd == "enable") {
            settings.get_or_create_byok().enabled = true;
            SaveSettings(settings);
            std::cout << "BYOK enabled for provider '" << provider_name << "'.\n";
        }
        else if (subcmd == "disable") {
            settings.get_or_create_byok().enabled = false;
            SaveSettings(settings);
            std::cout << "BYOK disabled for provider '" << provider_name << "'.\n";
        }
        else if (subcmd == "key") {
            if (value.empty()) {
                std::cerr << "Error: API key value required.\n";
                return 1;
            }
            settings.get_or_create_byok().api_key = value;
            SaveSettings(settings);
            std::cout << "BYOK API key set for provider '" << provider_name << "'.\n";
        }
        else if (subcmd == "endpoint") {
            settings.get_or_create_byok().base_url = value;
            SaveSettings(settings);
            if (value.empty())
                std::cout << "BYOK endpoint cleared (using default).\n";
            else
                std::cout << "BYOK endpoint set to: " << value << "\n";
        }
        else if (subcmd == "model") {
            settings.get_or_create_byok().model = value;
            SaveSettings(settings);
            if (value.empty())
                std::cout << "BYOK model cleared (using default).\n";
            else
                std::cout << "BYOK model set to: " << value << "\n";
        }
        else if (subcmd == "type") {
            settings.get_or_create_byok().provider_type = value;
            SaveSettings(settings);
            if (value.empty())
                std::cout << "BYOK type cleared (using default).\n";
            else
                std::cout << "BYOK type set to: " << value << "\n";
        }
        else {
            std::cerr << "Unknown byok subcommand: " << subcmd << "\n";
            return 1;
        }
        return 0;
    }

    std::cerr << "Unknown config subcommand: " << args[0] << "\n";
    return 1;
}

void run_interactive(HttpClient& client) {
    std::cout << "Connected to HTTP server. Type 'exit' to quit.\n\n";
    std::string input;

    while (true) {
        std::cout << "> ";
        std::cout.flush();

        if (!std::getline(std::cin, input)) {
            break;
        }
        if (input == "exit" || input == "quit") {
            break;
        }
        if (input.empty()) {
            continue;
        }

        try {
            std::cout << client.ask(input) << "\n\n";
        }
        catch (const std::exception& e) {
            std::cerr << "Error: " << e.what() << "\n";
        }
    }
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        print_usage();
        return 1;
    }

    std::string url = get_url(argc, argv);

    // Find command index (skip --url if present)
    int cmd_idx = 1;
    if (std::string(argv[1]).rfind("--url=", 0) == 0) {
        cmd_idx = 2;
    }

    if (cmd_idx >= argc) {
        print_usage();
        return 1;
    }

    std::string command = argv[cmd_idx];

    // Collect remaining args as the command/query
    std::string args;
    for (int i = cmd_idx + 1; i < argc; i++) {
        if (!args.empty()) args += " ";
        args += argv[i];
    }

    // Config commands don't need server connection
    if (command == "config") {
        return run_config(argc, argv, cmd_idx);
    }

    try {
        HttpClient client(url);

        if (command == "exec") {
            if (args.empty()) {
                std::cerr << "Error: exec requires a command\n";
                return 1;
            }
            std::cout << client.exec(args);
            return 0;
        }
        else if (command == "ask") {
            if (args.empty()) {
                std::cerr << "Error: ask requires a question\n";
                return 1;
            }
            std::cout << client.ask(args) << "\n";
            return 0;
        }
        else if (command == "interactive") {
            run_interactive(client);
            return 0;
        }
        else if (command == "status") {
            std::cout << client.status() << "\n";
            return 0;
        }
        else if (command == "shutdown") {
            client.shutdown();
            std::cout << "HTTP server stopped.\n";
            return 0;
        }
        else {
            std::cerr << "Unknown command: " << command << "\n";
            print_usage();
            return 1;
        }
    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        std::cerr << "URL: " << url << "\n";
        return 1;
    }

    return 0;
}

```

`dml_output.cpp`:

```cpp
#include "dml_output.hpp"
#include <cstdarg>
#include <vector>

namespace windbg_agent
{

DmlOutput::DmlOutput(IDebugControl* control) : control_(control)
{
    if (!control_)
        return;

    // Check if DML is preferred via engine options
    ULONG options = 0;
    if (SUCCEEDED(control_->GetEngineOptions(&options)))
    {
        // DEBUG_ENGOPT_PREFER_DML = 0x00040000
        dml_supported_ = (options & 0x00040000) != 0;
    }
}

std::string DmlOutput::EscapeDml(const std::string& text)
{
    std::string result;
    result.reserve(text.size() * 1.1);

    for (char c : text)
    {
        switch (c)
        {
        case '&':
            result += "&amp;";
            break;
        case '<':
            result += "&lt;";
            break;
        case '>':
            result += "&gt;";
            break;
        case '"':
            result += "&quot;";
            break;
        default:
            result += c;
            break;
        }
    }
    return result;
}

void DmlOutput::Output(const char* format, ...)
{
    if (!control_)
        return;

    va_list args;
    va_start(args, format);

    char buffer[4096];
    vsnprintf(buffer, sizeof(buffer), format, args);
    control_->Output(DEBUG_OUTPUT_NORMAL, "%s", buffer);

    va_end(args);
}

void DmlOutput::OutputColored(const char* color, const char* format, ...)
{
    if (!control_)
        return;

    va_list args;
    va_start(args, format);

    char buffer[4096];
    vsnprintf(buffer, sizeof(buffer), format, args);

    if (dml_supported_)
    {
        std::string escaped = EscapeDml(buffer);
        control_->ControlledOutput(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                                   "<col fg=\"%s\">%s</col>", color, escaped.c_str());
    }
    else
    {
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s", buffer);
    }

    va_end(args);
}

void DmlOutput::OutputCommand(const char* cmd)
{
    if (!control_)
        return;

    if (dml_supported_)
    {
        std::string escaped = EscapeDml(cmd);
        control_->ControlledOutput(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                                   "<col fg=\"subfg\">$ %s</col>\n", escaped.c_str());
    }
    else
    {
        control_->Output(DEBUG_OUTPUT_NORMAL, "$ %s\n", cmd);
    }
}

void DmlOutput::OutputCommandResult(const char* result)
{
    if (!control_)
        return;

    if (dml_supported_)
    {
        std::string escaped = EscapeDml(result);
        control_->ControlledOutput(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                                   "<col fg=\"subfg\">%s</col>\n", escaped.c_str());
    }
    else
    {
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s\n", result);
    }
}

void DmlOutput::OutputAgentThinking(const char* msg)
{
    if (!control_)
        return;

    if (dml_supported_)
    {
        std::string escaped = EscapeDml(msg);
        control_->ControlledOutput(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                                   "<col fg=\"empfg\"><i>%s</i></col>\n", escaped.c_str());
    }
    else
    {
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s\n", msg);
    }
}

void DmlOutput::OutputAgentResponse(const char* msg)
{
    if (!control_)
        return;

    // Agent response is normal text, no special coloring needed
    control_->Output(DEBUG_OUTPUT_NORMAL, "%s\n", msg);
}

void DmlOutput::OutputError(const char* msg)
{
    if (!control_)
        return;

    if (dml_supported_)
    {
        std::string escaped = EscapeDml(msg);
        control_->ControlledOutput(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_ERROR,
                                   "<col fg=\"errfg\">%s</col>\n", escaped.c_str());
    }
    else
    {
        control_->Output(DEBUG_OUTPUT_ERROR, "%s\n", msg);
    }
}

void DmlOutput::OutputWarning(const char* msg)
{
    if (!control_)
        return;

    if (dml_supported_)
    {
        std::string escaped = EscapeDml(msg);
        control_->ControlledOutput(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_WARNING,
                                   "<col fg=\"warnfg\">%s</col>\n", escaped.c_str());
    }
    else
    {
        control_->Output(DEBUG_OUTPUT_WARNING, "%s\n", msg);
    }
}

} // namespace windbg_agent

```

`dml_output.hpp`:

```hpp
#pragma once

#include <dbgeng.h>
#include <string>
#include <windows.h>

namespace windbg_agent
{

// DML (Debugger Markup Language) output helper
// Provides colored output that works in WinDbg and degrades gracefully in CDB
class DmlOutput
{
  public:
    explicit DmlOutput(IDebugControl* control);

    // Check if DML is preferred/supported
    bool IsDmlSupported() const { return dml_supported_; }

    // Output with specific colors (uses DML fg color names)
    // Colors: empfg (emphasis/blue), errfg (error/red), warnfg (warning),
    //         subfg (subdued/gray), changed (red for changes)
    void OutputColored(const char* color, const char* format, ...);

    // Convenience methods for common message types
    void OutputCommand(const char* cmd);          // Command being run (subdued)
    void OutputCommandResult(const char* result); // Command output (normal)
    void OutputAgentThinking(const char* msg);    // Agent status (emphasis)
    void OutputAgentResponse(const char* msg);    // Agent response (normal)
    void OutputError(const char* msg);            // Error messages (red)
    void OutputWarning(const char* msg);          // Warning messages (yellow)

    // Raw output (no DML)
    void Output(const char* format, ...);

  private:
    IDebugControl* control_;
    bool dml_supported_ = false;

    // Escape special characters for DML
    static std::string EscapeDml(const std::string& text);
};

} // namespace windbg_agent

```

`http_server.cpp`:

```cpp
#include "http_server.hpp"

#include <httplib.h>
#include <nlohmann/json.hpp>

#include <WinSock2.h>
#include <WS2tcpip.h>
#include <Windows.h>
#include <chrono>
#include <sstream>

#pragma comment(lib, "ws2_32.lib")

namespace windbg_agent {

class HttpServer::Impl {
public:
    httplib::Server server;
};

HttpServer::HttpServer() = default;

HttpServer::~HttpServer() {
    stop();
}

QueueResult HttpServer::queue_and_wait(PendingCommand::Type type, const std::string& input) {
    if (!running_.load()) {
        return {false, "Error: HTTP server is not running"};
    }

    PendingCommand cmd;
    cmd.type = type;
    cmd.input = input;
    cmd.completed = false;

    std::mutex done_mutex;
    std::condition_variable done_cv;
    cmd.done_mutex = &done_mutex;
    cmd.done_cv = &done_cv;

    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        pending_commands_.push(&cmd);
    }
    queue_cv_.notify_one();

    {
        std::unique_lock<std::mutex> lock(done_mutex);
        done_cv.wait(lock, [&]() { return cmd.completed || !running_.load(); });
    }

    if (!cmd.completed) {
        return {false, "Error: HTTP server stopped"};
    }

    return {true, cmd.result};
}

int HttpServer::start(ExecCallback exec_cb, AskCallback ask_cb,
                      const std::string& bind_addr) {
    if (running_.load()) {
        return port_;
    }

    exec_cb_ = exec_cb;
    ask_cb_ = ask_cb;
    bind_addr_ = bind_addr;

    impl_ = std::make_unique<Impl>();

    // Let the OS assign a free port
    int assigned_port = impl_->server.bind_to_any_port(bind_addr.c_str());
    if (assigned_port < 0) {
        impl_.reset();
        return -1;
    }

    impl_->server.Post("/exec", [this](const httplib::Request& req, httplib::Response& res) {
        try {
            auto json = nlohmann::json::parse(req.body);
            std::string command = json.value("command", "");

            if (command.empty()) {
                res.status = 400;
                res.set_content(R"({"error":"missing command","success":false})", "application/json");
                return;
            }

            auto result = queue_and_wait(PendingCommand::Type::Exec, command);
            nlohmann::json response = {{"output", result.payload}, {"success", result.success}};
            if (!result.success) {
                res.status = 503;
            }
            res.set_content(response.dump(), "application/json");
        } catch (const std::exception& e) {
            res.status = 500;
            nlohmann::json response = {{"error", e.what()}, {"success", false}};
            res.set_content(response.dump(), "application/json");
        }
    });

    impl_->server.Post("/ask", [this](const httplib::Request& req, httplib::Response& res) {
        try {
            auto json = nlohmann::json::parse(req.body);
            std::string query = json.value("query", "");

            if (query.empty()) {
                res.status = 400;
                res.set_content(R"({"error":"missing query","success":false})", "application/json");
                return;
            }

            auto result = queue_and_wait(PendingCommand::Type::Ask, query);
            nlohmann::json response = {{"response", result.payload}, {"success", result.success}};
            if (!result.success) {
                res.status = 503;
            }
            res.set_content(response.dump(), "application/json");
        } catch (const std::exception& e) {
            res.status = 500;
            nlohmann::json response = {{"error", e.what()}, {"success", false}};
            res.set_content(response.dump(), "application/json");
        }
    });

    impl_->server.Get("/status", [](const httplib::Request&, httplib::Response& res) {
        nlohmann::json response = {{"status", "ready"}, {"success", true}};
        res.set_content(response.dump(), "application/json");
    });

    impl_->server.Post("/shutdown", [this](const httplib::Request&, httplib::Response& res) {
        nlohmann::json response = {{"status", "stopping"}, {"success", true}};
        res.set_content(response.dump(), "application/json");

        std::thread([this]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            stop();
        }).detach();
    });

    port_ = assigned_port;
    running_.store(true);

    server_thread_ = std::thread([this]() {
        impl_->server.listen_after_bind();
        running_.store(false);
        queue_cv_.notify_all();
        complete_pending_commands("Error: HTTP server stopped");
    });

    return port_;
}

void HttpServer::set_interrupt_check(std::function<bool()> check) {
    interrupt_check_ = check;
}

void HttpServer::wait() {
    while (running_.load()) {
        if (interrupt_check_ && interrupt_check_()) {
            stop();
            break;
        }

        PendingCommand* cmd = nullptr;

        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (queue_cv_.wait_for(lock, std::chrono::milliseconds(100),
                                   [this]() { return !pending_commands_.empty() || !running_.load(); })) {
                if (!pending_commands_.empty()) {
                    cmd = pending_commands_.front();
                    pending_commands_.pop();
                }
            }
        }

        if (cmd) {
            try {
                if (cmd->type == PendingCommand::Type::Exec && exec_cb_) {
                    cmd->result = exec_cb_(cmd->input);
                } else if (cmd->type == PendingCommand::Type::Ask && ask_cb_) {
                    cmd->result = ask_cb_(cmd->input);
                } else {
                    cmd->result = "Error: No handler for command type";
                }
            } catch (const std::exception& e) {
                cmd->result = std::string("Error: ") + e.what();
            }

            if (cmd->done_mutex && cmd->done_cv) {
                {
                    std::lock_guard<std::mutex> lock(*cmd->done_mutex);
                    cmd->completed = true;
                }
                cmd->done_cv->notify_one();
            }
        }
    }

    if (server_thread_.joinable()) {
        server_thread_.join();
    }
}

void HttpServer::stop() {
    if (impl_) {
        impl_->server.stop();
    }
    running_.store(false);
    queue_cv_.notify_all();
    complete_pending_commands("Error: HTTP server stopped");
    if (server_thread_.joinable()) {
        server_thread_.join();
    }
}

void HttpServer::complete_pending_commands(const std::string& result) {
    std::queue<PendingCommand*> pending;
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        std::swap(pending, pending_commands_);
    }

    while (!pending.empty()) {
        PendingCommand* cmd = pending.front();
        pending.pop();
        if (!cmd || !cmd->done_mutex || !cmd->done_cv) {
            continue;
        }

        {
            std::lock_guard<std::mutex> lock(*cmd->done_mutex);
            if (!cmd->completed) {
                cmd->result = result;
                cmd->completed = true;
            }
        }
        cmd->done_cv->notify_one();
    }
}

bool copy_to_clipboard(const std::string& text) {
    if (!OpenClipboard(nullptr)) {
        return false;
    }

    EmptyClipboard();

    HGLOBAL hg = GlobalAlloc(GMEM_MOVEABLE, text.size() + 1);
    if (!hg) {
        CloseClipboard();
        return false;
    }

    memcpy(GlobalLock(hg), text.c_str(), text.size() + 1);
    GlobalUnlock(hg);

    SetClipboardData(CF_TEXT, hg);
    CloseClipboard();

    return true;
}

std::string format_http_info(
    const std::string& target_name,
    unsigned long pid,
    const std::string& state,
    const std::string& url
) {
    std::ostringstream ss;
    ss << "HTTP SERVER ACTIVE\n";
    ss << "Target: " << target_name << " (PID " << pid << ")\n";
    ss << "State: " << state << "\n";
    ss << "URL: " << url << "\n\n";

    ss << "HTTP API ENDPOINTS:\n";
    ss << "  POST " << url << "/exec   - Execute raw debugger command\n";
    ss << "  POST " << url << "/ask    - AI-assisted query (natural language)\n";
    ss << "  GET  " << url << "/status - Server status\n";
    ss << "  POST " << url << "/shutdown - Stop server\n\n";

    ss << "CURL EXAMPLES:\n";
    ss << "  # Execute debugger command (returns raw output)\n";
    ss << "  curl -X POST " << url << "/exec \\\n";
    ss << "    -H \"Content-Type: application/json\" \\\n";
    ss << "    -d '{\"command\": \"kb\"}'\n\n";

    ss << "  # AI query (natural language, returns explanation)\n";
    ss << "  curl -X POST " << url << "/ask \\\n";
    ss << "    -H \"Content-Type: application/json\" \\\n";
    ss << "    -d '{\"query\": \"what is the value of RAX?\"}'\n\n";

    ss << "  # More examples\n";
    ss << "  curl -X POST " << url << "/exec -H \"Content-Type: application/json\" -d '{\"command\": \"r rax\"}'\n";
    ss << "  curl -X POST " << url << "/exec -H \"Content-Type: application/json\" -d '{\"command\": \"!analyze -v\"}'\n";
    ss << "  curl -X POST " << url << "/ask -H \"Content-Type: application/json\" -d '{\"query\": \"explain this crash\"}'\n\n";

    ss << "PYTHON:\n";
    ss << "  import requests\n";
    ss << "  # Execute command\n";
    ss << "  r = requests.post('" << url << "/exec', json={'command': 'kb'})\n";
    ss << "  print(r.json()['output'])\n\n";

    ss << "  # AI query\n";
    ss << "  r = requests.post('" << url << "/ask', json={'query': 'what caused this crash?'})\n";
    ss << "  print(r.json()['response'])\n\n";

    ss << "RESPONSE FORMAT:\n";
    ss << "  /exec returns: {\"output\": \"...\", \"success\": true}\n";
    ss << "  /ask returns:  {\"response\": \"...\", \"success\": true}\n\n";

    ss << "CLI TOOL:\n";
    ss << "  windbg_agent.exe --url=" << url << " exec \"kb\"\n";
    ss << "  windbg_agent.exe --url=" << url << " ask \"what caused this crash?\"\n";
    ss << "  windbg_agent.exe --url=" << url << " interactive\n";

    return ss.str();
}

} // namespace windbg_agent

```

`http_server.hpp`:

```hpp
#pragma once

#include <string>
#include <functional>
#include <thread>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <optional>

namespace windbg_agent {

// Callbacks for handling requests
using ExecCallback = std::function<std::string(const std::string& command)>;
using AskCallback = std::function<std::string(const std::string& query)>;

// Internal command structure for cross-thread execution
struct PendingCommand {
    enum class Type { Exec, Ask };
    Type type;
    std::string input;
    std::string result;
    bool completed = false;
    std::mutex* done_mutex = nullptr;
    std::condition_variable* done_cv = nullptr;
};

struct QueueResult {
    bool success;
    std::string payload;
};

class HttpServer {
public:
    HttpServer();
    ~HttpServer();

    // Non-copyable
    HttpServer(const HttpServer&) = delete;
    HttpServer& operator=(const HttpServer&) = delete;

    // Start server with OS-assigned port
    // Returns actual port used
    // Callbacks will be called on the main thread (in wait())
    // bind_addr: "127.0.0.1" for localhost only, "0.0.0.0" for all interfaces
    int start(ExecCallback exec_cb, AskCallback ask_cb,
              const std::string& bind_addr = "127.0.0.1");

    // Block until server stops, processing commands on the calling thread
    // This is where exec_cb and ask_cb get called
    void wait();

    // Stop the server
    void stop();

    // Check if running
    bool is_running() const { return running_.load(); }

    // Get the port the server is listening on
    int port() const { return port_; }

    // Get the bind address
    const std::string& bind_addr() const { return bind_addr_; }

    // Queue a command for execution on the main thread (called by HTTP handlers)
    QueueResult queue_and_wait(PendingCommand::Type type, const std::string& input);

    // Set interrupt check function (called during wait loop)
    void set_interrupt_check(std::function<bool()> check);

private:
    std::function<bool()> interrupt_check_;
    std::thread server_thread_;
    std::atomic<bool> running_{false};
    int port_{0};
    std::string bind_addr_{"127.0.0.1"};

    // Command queue for cross-thread execution
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    std::queue<PendingCommand*> pending_commands_;

    // Callbacks stored for main thread execution
    ExecCallback exec_cb_;
    AskCallback ask_cb_;

    // Forward declaration - impl hides httplib
    class Impl;
    std::unique_ptr<Impl> impl_;

    void complete_pending_commands(const std::string& result);
};

// Copy text to Windows clipboard
bool copy_to_clipboard(const std::string& text);

// Format HTTP server info for display and clipboard
std::string format_http_info(
    const std::string& target_name,
    unsigned long pid,
    const std::string& state,
    const std::string& url
);

} // namespace windbg_agent

```

`main.cpp`:

```cpp
#include <atomic>
#include <chrono>
#include <cstdio>
#include <ctime>
#include <dbgeng.h>
#include <memory>
#include <string>
#include <windows.h>

#include "http_server.hpp"
#include "mcp_server.hpp"
#include "session_store.hpp"
#include "settings.hpp"
#include "system_prompt.hpp"
#include "version.h"
#include "windbg_client.hpp"

#include <libagents/agent.hpp>
#include <libagents/tool_builder.hpp>

// Set to 1 to disable session management (for debugging MCP tool visibility issues)
#define WINDBG_AGENT_DISABLE_SESSIONS 0

namespace
{

// Format milliseconds as human-readable duration
static std::string FormatDuration(int ms)
{
    if (ms < 1000)
        return std::to_string(ms) + " ms";

    int total_seconds = ms / 1000;
    int hours = total_seconds / 3600;
    int minutes = (total_seconds % 3600) / 60;
    int seconds = total_seconds % 60;

    std::string result;

    if (hours > 0)
    {
        result += std::to_string(hours) + " hour" + (hours != 1 ? "s" : "");
        if (minutes > 0)
            result += " " + std::to_string(minutes) + " minute" + (minutes != 1 ? "s" : "");
    }
    else if (minutes > 0)
    {
        result += std::to_string(minutes) + " minute" + (minutes != 1 ? "s" : "");
        if (seconds > 0)
            result += " " + std::to_string(seconds) + " second" + (seconds != 1 ? "s" : "");
    }
    else
    {
        result = std::to_string(seconds) + " second" + (seconds != 1 ? "s" : "");
    }

    return result;
}

// Gather runtime context from the debugger session
static windbg_agent::RuntimeContext GatherRuntimeContext(windbg_agent::WinDbgClient& dbg_client)
{
    windbg_agent::RuntimeContext ctx;

    // Target info
    ctx.target_name = dbg_client.GetTargetName();
    ctx.target_arch = dbg_client.GetTargetArchitecture();
    ctx.debugger_type = dbg_client.GetDebuggerType();

    // Working directory
    char cwd[MAX_PATH] = {0};
    if (GetCurrentDirectoryA(MAX_PATH, cwd))
        ctx.cwd = cwd;

    // Timestamp (ISO 8601 local time)
    auto now = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(now);
    char time_buf[32];
    struct tm local_tm;
    localtime_s(&local_tm, &t);
    std::strftime(time_buf, sizeof(time_buf), "%Y-%m-%dT%H:%M:%S", &local_tm);
    ctx.timestamp = time_buf;

    // Platform
    ctx.platform = "Windows";

    return ctx;
}

struct AgentSession
{
    std::unique_ptr<libagents::IAgent> agent;
    libagents::ProviderType provider = libagents::ProviderType::Copilot;
    std::string provider_name;
    std::string target;
    std::string session_id;
    std::string system_prompt;
    bool primed = false;
    bool initialized = false;
    bool host_ready = false;
    std::atomic<bool> aborted{false};
    windbg_agent::WinDbgClient* dbg = nullptr;
    libagents::HostContext host;
};

// Helper to get IDebugControl for output
static IDebugControl* GetControl(PDEBUG_CLIENT Client)
{
    IDebugControl* control = nullptr;
    Client->QueryInterface(__uuidof(IDebugControl), (void**)&control);
    return control;
}

static AgentSession& GetAgentSession()
{
    static AgentSession session;
    return session;
}

static void ResetAgentSession(AgentSession& session)
{
    if (session.agent)
    {
        session.agent->shutdown();
        session.agent.reset();
    }
    session.initialized = false;
    session.host_ready = false;
    session.provider_name.clear();
    session.session_id.clear();
    session.system_prompt.clear();
    session.target.clear();
    session.primed = false;
}

static libagents::Tool BuildDebuggerTool(AgentSession& session)
{
    return libagents::make_tool(
        "dbg_exec",
        "Execute a WinDbg/CDB debugger command and return its output. "
        "Use this to inspect the target process, memory, threads, exceptions, etc.",
        [&session](std::string command) -> std::string
        {
            if (session.aborted.load())
                return "(Aborted)";

            if (!session.dbg)
                return "Error: No debugger client available";

            return session.dbg->ExecuteCommand(command);
        },
        {"command"});
}

static void ConfigureHost(AgentSession& session)
{
    if (session.host_ready)
        return;

    session.host.should_abort = [&session]()
    {
        if (session.dbg && session.dbg->IsInterrupted())
            session.aborted = true;
        return session.aborted.load();
    };

    session.host.on_event = [&session](const libagents::Event& event)
    {
        if (!session.dbg)
            return;

        switch (event.type)
        {
        case libagents::EventType::ContentDelta:
            session.dbg->OutputThinking(event.content);
            break;
        case libagents::EventType::ContentComplete:
            session.dbg->Output("\n");
            session.dbg->OutputResponse(event.content.empty() ? "(No output)" : event.content);
            break;
        case libagents::EventType::Error:
            if (!event.error_message.empty())
                session.dbg->OutputError(event.error_message);
            else if (!event.content.empty())
                session.dbg->OutputError(event.content);
            else
                session.dbg->OutputError("Error");
            break;
        default:
            break;
        }
    };

    session.host_ready = true;
}

static bool EnsureAgent(AgentSession& session, windbg_agent::WinDbgClient& dbg_client,
                        const windbg_agent::Settings& settings, const std::string& target,
                        const windbg_agent::RuntimeContext& runtime_ctx, std::string* error,
                        bool* created)
{
    if (created)
        *created = false;

    session.dbg = &dbg_client;

    if (session.agent && session.provider != settings.default_provider)
        ResetAgentSession(session);

    if (!session.agent)
    {
        session.provider = settings.default_provider;
        session.provider_name = libagents::provider_type_name(session.provider);
        session.agent = libagents::create_agent(session.provider);
        if (!session.agent)
        {
            if (error)
                *error = "Failed to create agent";

            return false;
        }

        session.agent->register_tool(BuildDebuggerTool(session));

        session.system_prompt =
            windbg_agent::GetFullSystemPrompt(settings.custom_prompt, runtime_ctx);
        session.primed = false; // will prepend on first user query instead of system_prompt

        // Apply BYOK settings if enabled
        const auto* byok = settings.get_byok();
        if (byok && byok->is_usable())
            session.agent->set_byok(byok->to_config());

        // Apply response timeout setting
        if (settings.response_timeout_ms > 0)
            session.agent->set_response_timeout(
                std::chrono::milliseconds(settings.response_timeout_ms));

#if !WINDBG_AGENT_DISABLE_SESSIONS
        // Skip session resume when BYOK is enabled (not supported by BYOK providers)
        if (!(byok && byok->is_usable()))
        {
            session.session_id =
                windbg_agent::GetSessionStore().GetSessionId(target, session.provider_name);
            if (!session.session_id.empty())
                session.agent->set_session_id(session.session_id);
        }
#endif

        if (!session.agent->initialize())
        {
            if (error)
            {
                *error = "Failed to initialize: " + session.agent->provider_name();
                std::string last_error = session.agent->get_last_error();
                if (!last_error.empty())
                    *error += " - " + last_error;
            }

            ResetAgentSession(session);
            return false;
        }

        ConfigureHost(session);
        session.initialized = true;

        if (created)
            *created = true;
    }

    std::string updated_prompt =
        windbg_agent::GetFullSystemPrompt(settings.custom_prompt, runtime_ctx);
    if (updated_prompt != session.system_prompt)
    {
        session.system_prompt = updated_prompt;
        session.primed = false; // re-prime next turn with new prompt
    }

    if (session.target != target)
    {
        session.target = target;
#if !WINDBG_AGENT_DISABLE_SESSIONS
        // Skip session resume when BYOK is enabled (not supported by BYOK providers)
        const auto* byok_check = settings.get_byok();
        if (!(byok_check && byok_check->is_usable()))
        {
            std::string new_session_id =
                windbg_agent::GetSessionStore().GetSessionId(target, session.provider_name);
            if (new_session_id != session.session_id)
            {
                if (session.agent)
                {
                    session.agent->clear_session();
                    session.session_id = new_session_id;
                    if (!session.session_id.empty())
                        session.agent->set_session_id(session.session_id);
                }
            }
        }
#endif
        session.primed = false; // new target -> re-prime on next ask
    }

    session.aborted = false;
    return true;
}
} // namespace

// Extension entry point
extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(WINDBG_AGENT_VERSION_MAJOR, WINDBG_AGENT_VERSION_MINOR);
    *Flags = 0;
    return S_OK;
}

// Extension cleanup
extern "C" void CALLBACK DebugExtensionUninitialize()
{
    ResetAgentSession(GetAgentSession());
}

// Extension notification
extern "C" void CALLBACK DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    // Could handle session changes here if needed
}

// Implementation
HRESULT CALLBACK agent_impl(PDEBUG_CLIENT Client, PCSTR Args)
{
    IDebugControl* control = GetControl(Client);
    if (!control)
        return E_FAIL;

    // Parse subcommand
    std::string args_str = Args ? Args : "";

    // Trim leading whitespace
    size_t start = args_str.find_first_not_of(" \t");
    if (start != std::string::npos)
        args_str = args_str.substr(start);

    // Extract subcommand
    std::string subcmd;
    std::string rest;
    size_t space = args_str.find(' ');
    if (space != std::string::npos)
    {
        subcmd = args_str.substr(0, space);
        rest = args_str.substr(space + 1);
        // Trim leading whitespace from rest
        size_t rest_start = rest.find_first_not_of(" \t");
        if (rest_start != std::string::npos)
            rest = rest.substr(rest_start);
    }
    else
    {
        subcmd = args_str;
    }

    // Handle subcommands
    if (subcmd.empty() || subcmd == "help")
    {
        auto settings = windbg_agent::LoadSettings();
        const auto* byok = settings.get_byok();
        control->Output(
            DEBUG_OUTPUT_NORMAL,
            "WinDbg Agent - AI-powered debugger assistant\n"
            "\n"
            "Usage: !agent <command> [args]\n"
            "       !ai <question>          (shorthand for !agent ask)\n"
            "\n"
            "Commands:\n"
            "  help                  Show this help\n"
            "  version               Show version information\n"
            "  version prompt        Show injected system prompt\n"
            "  ask <question>        Ask the AI agent a question\n"
            "  clear                 Clear conversation history\n"
            "  provider              Show current provider\n"
            "  provider <name>       Switch provider (claude, copilot)\n"
            "  prompt                Show custom prompt\n"
            "  prompt <text>         Set custom prompt (additive)\n"
            "  prompt clear          Clear custom prompt\n"
            "  timeout               Show response timeout\n"
            "  timeout <ms>          Set response timeout (e.g., 120000 = 2 min)\n"
            "  http [bind_addr]      Start HTTP server for external tools (port auto-assigned)\n"
            "  mcp [bind_addr]       Start MCP server for MCP-compatible clients\n"
            "  byok                  Show BYOK (Bring Your Own Key) status\n"
            "  byok enable|disable   Enable or disable BYOK for current provider\n"
            "  byok key <value>      Set BYOK API key\n"
            "  byok endpoint <url>   Set BYOK API endpoint\n"
            "  byok type <type>      Set BYOK provider type (openai, anthropic, azure)\n"
            "  byok model <model>    Set BYOK model name\n"
            "\n"
            "Current provider: %s%s\n"
            "\n"
            "Examples:\n"
            "  !ai what is the call stack?           (quick query)\n"
            "  !ai and what about the registers?     (follow-up)\n"
            "  !agent provider claude                (switch to Claude)\n"
            "  !agent byok key sk-xxx                (set your API key)\n"
            "  !agent byok enable                    (use custom API key)\n",
            libagents::provider_type_name(settings.default_provider),
            (byok && byok->is_usable()) ? " (BYOK enabled)" : "");

        // Show current session context
        windbg_agent::WinDbgClient dbg_client(Client);
        auto ctx = GatherRuntimeContext(dbg_client);
        control->Output(DEBUG_OUTPUT_NORMAL, "Session context:\n");
        if (!ctx.target_name.empty())
            control->Output(DEBUG_OUTPUT_NORMAL, "  Target:       %s\n", ctx.target_name.c_str());
        if (!ctx.target_arch.empty())
            control->Output(DEBUG_OUTPUT_NORMAL, "  Architecture: %s\n", ctx.target_arch.c_str());
        if (!ctx.debugger_type.empty())
            control->Output(DEBUG_OUTPUT_NORMAL, "  Debugger:     %s\n", ctx.debugger_type.c_str());
        if (!ctx.cwd.empty())
            control->Output(DEBUG_OUTPUT_NORMAL, "  Working dir:  %s\n", ctx.cwd.c_str());
        if (!ctx.timestamp.empty())
            control->Output(DEBUG_OUTPUT_NORMAL, "  Timestamp:    %s\n", ctx.timestamp.c_str());
        control->Output(DEBUG_OUTPUT_NORMAL, "  Platform:     %s\n", ctx.platform.c_str());
    }
    else if (subcmd == "version")
    {
        auto settings = windbg_agent::LoadSettings();

        if (rest == "prompt")
        {
            // Show the system prompt
            control->Output(DEBUG_OUTPUT_NORMAL, "=== WinDbg Agent System Prompt ===\n\n");
            control->Output(DEBUG_OUTPUT_NORMAL, "%s\n", windbg_agent::kSystemPrompt);
            if (!settings.custom_prompt.empty())
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "\n=== Custom Prompt (additive) ===\n\n");
                control->Output(DEBUG_OUTPUT_NORMAL, "%s\n", settings.custom_prompt.c_str());
            }
        }
        else
        {
            control->Output(DEBUG_OUTPUT_NORMAL, "WinDbg Agent v%d.%d.%d\n",
                            WINDBG_AGENT_VERSION_MAJOR, WINDBG_AGENT_VERSION_MINOR,
                            WINDBG_AGENT_VERSION_PATCH);
            control->Output(DEBUG_OUTPUT_NORMAL, "Current provider: %s\n",
                            libagents::provider_type_name(settings.default_provider));
            control->Output(DEBUG_OUTPUT_NORMAL, "\nUse '!agent version prompt' to see the injected system prompt.\n");
        }
    }
    else if (subcmd == "provider")
    {
        auto settings = windbg_agent::LoadSettings();

        if (rest.empty())
        {
            // Show current provider
            control->Output(DEBUG_OUTPUT_NORMAL, "Current provider: %s\n",
                            libagents::provider_type_name(settings.default_provider));
            control->Output(DEBUG_OUTPUT_NORMAL, "\nAvailable providers:\n");
            control->Output(DEBUG_OUTPUT_NORMAL, "  claude   - Claude Code (Anthropic)\n");
            control->Output(DEBUG_OUTPUT_NORMAL, "  copilot  - GitHub Copilot\n");
        }
        else
        {
            // Switch provider
            try
            {
                auto type = windbg_agent::ParseProviderType(rest);
                if (type != settings.default_provider)
                {
                    settings.default_provider = type;
                    windbg_agent::SaveSettings(settings);
                    ResetAgentSession(GetAgentSession());
                }
                control->Output(DEBUG_OUTPUT_NORMAL, "Provider set to: %s (saved to settings)\n",
                                libagents::provider_type_name(type));
            }
            catch (const std::exception& e)
            {
                control->Output(DEBUG_OUTPUT_ERROR, "Error: %s\n", e.what());
                control->Output(DEBUG_OUTPUT_NORMAL, "Available providers: claude, copilot\n");
            }
        }
    }
    else if (subcmd == "clear")
    {
        auto settings = windbg_agent::LoadSettings();
        windbg_agent::WinDbgClient dbg_client(Client);
        std::string target = dbg_client.GetTargetName();
        std::string provider_name = libagents::provider_type_name(settings.default_provider);

        auto& session = GetAgentSession();
        if (session.agent)
        {
            session.agent->clear_session();
            session.session_id.clear();
        }
        windbg_agent::GetSessionStore().ClearSession(target, provider_name);
        control->Output(DEBUG_OUTPUT_NORMAL,
                        "Conversation history cleared (new session for this target).\n");
    }
    else if (subcmd == "prompt")
    {
        auto settings = windbg_agent::LoadSettings();

        if (rest.empty())
        {
            if (settings.custom_prompt.empty())
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "No custom prompt set.\n");
            }
            else
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "Custom prompt:\n%s\n",
                                settings.custom_prompt.c_str());
            }
        }
        else if (rest == "clear")
        {
            settings.custom_prompt.clear();
            windbg_agent::SaveSettings(settings);
            auto& session = GetAgentSession();
            if (session.agent)
            {
                session.system_prompt = windbg_agent::GetFullSystemPrompt(settings.custom_prompt);
                session.primed = false; // re-prime next turn
            }
            control->Output(DEBUG_OUTPUT_NORMAL, "Custom prompt cleared.\n");
        }
        else
        {
            settings.custom_prompt = rest;
            windbg_agent::SaveSettings(settings);
            auto& session = GetAgentSession();
            if (session.agent)
            {
                session.system_prompt = windbg_agent::GetFullSystemPrompt(settings.custom_prompt);
                session.primed = false; // re-prime next turn
            }
            control->Output(DEBUG_OUTPUT_NORMAL, "Custom prompt set (saved to settings).\n");
        }
    }
    else if (subcmd == "timeout")
    {
        auto settings = windbg_agent::LoadSettings();

        if (rest.empty())
        {
            control->Output(DEBUG_OUTPUT_NORMAL, "Response timeout: %s\n",
                            FormatDuration(settings.response_timeout_ms).c_str());
        }
        else
        {
            try
            {
                int ms = std::stoi(rest);
                if (ms < 1000)
                {
                    control->Output(DEBUG_OUTPUT_ERROR,
                                    "Timeout must be at least 1000 ms (1 second).\n");
                }
                else
                {
                    settings.response_timeout_ms = ms;
                    windbg_agent::SaveSettings(settings);
                    auto& session = GetAgentSession();
                    if (session.agent)
                        session.agent->set_response_timeout(std::chrono::milliseconds(ms));
                    control->Output(DEBUG_OUTPUT_NORMAL, "Timeout set to %s.\n",
                                    FormatDuration(ms).c_str());
                }
            }
            catch (...)
            {
                control->Output(DEBUG_OUTPUT_ERROR, "Invalid timeout value. Use milliseconds.\n");
            }
        }
    }
    else if (subcmd == "byok")
    {
        auto settings = windbg_agent::LoadSettings();
        std::string provider_name = libagents::provider_type_name(settings.default_provider);

        // Parse BYOK subcommand
        std::string byok_subcmd;
        std::string byok_value;
        size_t byok_space = rest.find(' ');
        if (byok_space != std::string::npos)
        {
            byok_subcmd = rest.substr(0, byok_space);
            byok_value = rest.substr(byok_space + 1);
            // Trim leading whitespace
            size_t val_start = byok_value.find_first_not_of(" \t");
            if (val_start != std::string::npos)
                byok_value = byok_value.substr(val_start);
        }
        else
        {
            byok_subcmd = rest;
        }

        if (byok_subcmd.empty())
        {
            // Show BYOK status for current provider
            const auto* byok = settings.get_byok();
            control->Output(DEBUG_OUTPUT_NORMAL, "BYOK status for provider '%s':\n",
                            provider_name.c_str());
            if (byok)
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "  Enabled:  %s\n",
                                byok->enabled ? "yes" : "no");
                control->Output(DEBUG_OUTPUT_NORMAL, "  API Key:  %s\n",
                                byok->api_key.empty() ? "(not set)" : "********");
                control->Output(DEBUG_OUTPUT_NORMAL, "  Endpoint: %s\n",
                                byok->base_url.empty() ? "(default)" : byok->base_url.c_str());
                control->Output(DEBUG_OUTPUT_NORMAL, "  Model:    %s\n",
                                byok->model.empty() ? "(default)" : byok->model.c_str());
                control->Output(DEBUG_OUTPUT_NORMAL, "  Type:     %s\n",
                                byok->provider_type.empty() ? "(default)"
                                                            : byok->provider_type.c_str());
                control->Output(DEBUG_OUTPUT_NORMAL, "  Usable:   %s\n",
                                byok->is_usable() ? "yes" : "no");
            }
            else
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "  (not configured)\n");
            }
            control->Output(DEBUG_OUTPUT_NORMAL,
                            "\nUse '!agent byok <cmd>' where cmd is:\n"
                            "  enable|disable  - Enable or disable BYOK\n"
                            "  key <value>     - Set API key\n"
                            "  endpoint <url>  - Set API endpoint\n"
                            "  model <name>    - Set model name\n"
                            "  type <type>     - Set provider type (openai, anthropic, azure)\n");
        }
        else if (byok_subcmd == "enable")
        {
            auto& byok = settings.get_or_create_byok();
            byok.enabled = true;
            windbg_agent::SaveSettings(settings);
            ResetAgentSession(GetAgentSession());
            control->Output(DEBUG_OUTPUT_NORMAL, "BYOK enabled for provider '%s'.\n",
                            provider_name.c_str());
            if (byok.api_key.empty())
            {
                control->Output(
                    DEBUG_OUTPUT_WARNING,
                    "Warning: API key not set. Use '!agent byok key <value>' to set it.\n");
            }
        }
        else if (byok_subcmd == "disable")
        {
            auto& byok = settings.get_or_create_byok();
            byok.enabled = false;
            windbg_agent::SaveSettings(settings);
            ResetAgentSession(GetAgentSession());
            control->Output(DEBUG_OUTPUT_NORMAL, "BYOK disabled for provider '%s'.\n",
                            provider_name.c_str());
        }
        else if (byok_subcmd == "key")
        {
            if (byok_value.empty())
            {
                control->Output(DEBUG_OUTPUT_ERROR, "Error: API key value required.\n");
                control->Output(DEBUG_OUTPUT_NORMAL, "Usage: !agent byok key <value>\n");
            }
            else
            {
                auto& byok = settings.get_or_create_byok();
                byok.api_key = byok_value;
                windbg_agent::SaveSettings(settings);
                ResetAgentSession(GetAgentSession());
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK API key set for provider '%s'.\n",
                                provider_name.c_str());
            }
        }
        else if (byok_subcmd == "endpoint")
        {
            auto& byok = settings.get_or_create_byok();
            byok.base_url = byok_value; // Empty clears it
            windbg_agent::SaveSettings(settings);
            ResetAgentSession(GetAgentSession());
            if (byok_value.empty())
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK endpoint cleared (using default).\n");
            }
            else
            {
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK endpoint set to: %s\n",
                                byok_value.c_str());
            }
        }
        else if (byok_subcmd == "model")
        {
            auto& byok = settings.get_or_create_byok();
            byok.model = byok_value; // Empty clears it
            windbg_agent::SaveSettings(settings);
            ResetAgentSession(GetAgentSession());
            if (byok_value.empty())
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK model cleared (using default).\n");
            else
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK model set to: %s\n", byok_value.c_str());
        }
        else if (byok_subcmd == "type")
        {
            auto& byok = settings.get_or_create_byok();
            byok.provider_type = byok_value; // Empty clears it
            windbg_agent::SaveSettings(settings);
            ResetAgentSession(GetAgentSession());
            if (byok_value.empty())
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK type cleared (using default).\n");
            else
                control->Output(DEBUG_OUTPUT_NORMAL, "BYOK type set to: %s\n", byok_value.c_str());
        }
        else
        {
            control->Output(DEBUG_OUTPUT_ERROR, "Unknown byok subcommand: %s\n",
                            byok_subcmd.c_str());
            control->Output(DEBUG_OUTPUT_NORMAL, "Use '!agent byok' to see available commands.\n");
        }
    }
    else if (subcmd == "http")
    {
        // Start HTTP server for external tool integration
        // Usage: !agent http [bind_addr]
        // bind_addr: "127.0.0.1" (default, localhost only) or "0.0.0.0" (all interfaces)
        windbg_agent::WinDbgClient dbg_client(Client);
        auto settings = windbg_agent::LoadSettings();
        auto& session = GetAgentSession();
        std::string target = dbg_client.GetTargetName();

        // Parse optional bind address
        std::string bind_addr = "127.0.0.1";
        if (!rest.empty())
        {
            bind_addr = rest;
            // Trim whitespace
            size_t start = bind_addr.find_first_not_of(" \t");
            size_t end = bind_addr.find_last_not_of(" \t");
            if (start != std::string::npos)
                bind_addr = bind_addr.substr(start, end - start + 1);
        }

        if (bind_addr != "127.0.0.1")
        {
            control->Output(DEBUG_OUTPUT_WARNING,
                "WARNING: Binding to non-loopback address '%s'. "
                "The server has no authentication.\n", bind_addr.c_str());
        }

        // Get target state
        std::string state = dbg_client.GetTargetState();
        ULONG pid = dbg_client.GetProcessId();

        // Create exec callback - executes debugger commands
        windbg_agent::ExecCallback exec_cb = [&dbg_client](const std::string& command) -> std::string
        {
            return dbg_client.ExecuteCommand(command);
        };

        // Create ask callback - routes through same AI path as !agent ask
        windbg_agent::AskCallback ask_cb = [Client, &settings, &session, &dbg_client,
                                              &target](const std::string& query) -> std::string
        {
            auto runtime_ctx = GatherRuntimeContext(dbg_client);
            std::string error;
            bool created = false;
            if (!EnsureAgent(session, dbg_client, settings, target, runtime_ctx, &error, &created))
            {
                return error.empty() ? "Failed to initialize agent" : error;
            }

            try
            {
                std::string message =
                    session.primed || session.system_prompt.empty()
                        ? query
                        : (session.system_prompt + "\n\n---\n\n" + query);

                std::string response = session.agent->query_hosted(message, session.host);
                session.primed = true;

#if !WINDBG_AGENT_DISABLE_SESSIONS
                const auto* byok_save = settings.get_byok();
                if (!(byok_save && byok_save->is_usable()))
                {
                    std::string new_session_id = session.agent->get_session_id();
                    std::string provider_name =
                        libagents::provider_type_name(settings.default_provider);
                    if (!new_session_id.empty() && new_session_id != session.session_id)
                    {
                        windbg_agent::GetSessionStore().SetSessionId(target, provider_name,
                                                                       new_session_id);
                        session.session_id = new_session_id;
                    }
                }
#endif
                return response;
            }
            catch (const std::exception& e)
            {
                return std::string("Error: ") + e.what();
            }
        };

        // Start the HTTP server (OS assigns port)
        static windbg_agent::HttpServer http_server;
        if (http_server.is_running())
        {
            control->Output(DEBUG_OUTPUT_ERROR,
                            "HTTP server already running. Stop it before starting a new one.\n");
            control->Release();
            return E_FAIL;
        }
        int actual_port = http_server.start(exec_cb, ask_cb, bind_addr);
        if (actual_port <= 0)
        {
            control->Output(DEBUG_OUTPUT_ERROR,
                            "Failed to start HTTP server.\n");
            control->Release();
            return E_FAIL;
        }
        std::string url = "http://" + http_server.bind_addr() + ":" + std::to_string(http_server.port());

        // Format and output HTTP server info
        std::string http_info =
            windbg_agent::format_http_info(target, pid, state, url);
        control->Output(DEBUG_OUTPUT_NORMAL, "%s\n", http_info.c_str());

        // Copy to clipboard
        if (windbg_agent::copy_to_clipboard(http_info))
        {
            control->Output(DEBUG_OUTPUT_NORMAL, "[Copied to clipboard]\n");
        }

        control->Output(DEBUG_OUTPUT_NORMAL, "Press Ctrl+C to stop HTTP server.\n");

        // Set up interrupt check - stop server when user presses Ctrl+C
        http_server.set_interrupt_check([&dbg_client]() {
            return dbg_client.IsInterrupted();
        });

        // Block until server stops (user presses Ctrl+C or sends /shutdown)
        http_server.wait();
        control->Output(DEBUG_OUTPUT_NORMAL, "HTTP server stopped.\n");
    }
    else if (subcmd == "mcp")
    {
        // Start MCP server for MCP-compatible clients
        // Usage: !agent mcp [bind_addr]
        // bind_addr: "127.0.0.1" (default, localhost only) or "0.0.0.0" (all interfaces)
        windbg_agent::WinDbgClient dbg_client(Client);
        auto settings = windbg_agent::LoadSettings();
        auto& session = GetAgentSession();
        std::string target = dbg_client.GetTargetName();

        // Parse optional bind address
        std::string bind_addr = "127.0.0.1";
        if (!rest.empty())
        {
            bind_addr = rest;
            size_t start = bind_addr.find_first_not_of(" \t");
            size_t end = bind_addr.find_last_not_of(" \t");
            if (start != std::string::npos)
                bind_addr = bind_addr.substr(start, end - start + 1);
        }

        if (bind_addr != "127.0.0.1")
        {
            control->Output(DEBUG_OUTPUT_WARNING,
                "WARNING: Binding to non-loopback address '%s'. "
                "The server has no authentication.\n", bind_addr.c_str());
        }

        // Port 0 lets the MCP server pick a free port
        int port = 0;
        std::string url;

        // Get target state
        std::string state = dbg_client.GetTargetState();
        ULONG pid = dbg_client.GetProcessId();

        // Create exec callback - executes debugger commands
        windbg_agent::ExecCallback exec_cb = [&dbg_client](const std::string& command) -> std::string
        {
            return dbg_client.ExecuteCommand(command);
        };

        // Create ask callback - routes through same AI path as !agent ask
        windbg_agent::AskCallback ask_cb = [Client, &settings, &session, &dbg_client,
                                              &target](const std::string& query) -> std::string
        {
            auto runtime_ctx = GatherRuntimeContext(dbg_client);
            std::string error;
            bool created = false;
            if (!EnsureAgent(session, dbg_client, settings, target, runtime_ctx, &error, &created))
            {
                return error.empty() ? "Failed to initialize agent" : error;
            }

            try
            {
                std::string message =
                    session.primed || session.system_prompt.empty()
                        ? query
                        : (session.system_prompt + "\n\n---\n\n" + query);

                std::string response = session.agent->query_hosted(message, session.host);
                session.primed = true;

#if !WINDBG_AGENT_DISABLE_SESSIONS
                const auto* byok_save = settings.get_byok();
                if (!(byok_save && byok_save->is_usable()))
                {
                    std::string new_session_id = session.agent->get_session_id();
                    std::string provider_name =
                        libagents::provider_type_name(settings.default_provider);
                    if (!new_session_id.empty() && new_session_id != session.session_id)
                    {
                        windbg_agent::GetSessionStore().SetSessionId(target, provider_name,
                                                                       new_session_id);
                        session.session_id = new_session_id;
                    }
                }
#endif
                return response;
            }
            catch (const std::exception& e)
            {
                return std::string("Error: ") + e.what();
            }
        };

        // Start the MCP server
        static windbg_agent::MCPServer mcp_server;
        if (mcp_server.is_running())
        {
            control->Output(DEBUG_OUTPUT_ERROR,
                            "MCP server already running. Stop it before starting a new one.\n");
            control->Release();
            return E_FAIL;
        }
        int actual_port = mcp_server.start(port, exec_cb, ask_cb, bind_addr);
        if (actual_port <= 0)
        {
            control->Output(DEBUG_OUTPUT_ERROR,
                            "Failed to start MCP server.\n");
            control->Release();
            return E_FAIL;
        }
        url = "http://" + bind_addr + ":" + std::to_string(actual_port);

        // Format and output MCP server info
        std::string mcp_info =
            windbg_agent::format_mcp_info(target, pid, state, url);
        control->Output(DEBUG_OUTPUT_NORMAL, "%s\n", mcp_info.c_str());

        // Copy to clipboard
        if (windbg_agent::copy_to_clipboard(mcp_info))
        {
            control->Output(DEBUG_OUTPUT_NORMAL, "[Copied to clipboard]\n");
        }

        control->Output(DEBUG_OUTPUT_NORMAL, "Press Ctrl+C to stop MCP server.\n");

        // Set up interrupt check - stop MCP server when user presses Ctrl+C
        mcp_server.set_interrupt_check([&dbg_client]() {
            return dbg_client.IsInterrupted();
        });

        // Block until server stops (user presses Ctrl+C)
        mcp_server.wait();
        control->Output(DEBUG_OUTPUT_NORMAL, "MCP server stopped.\n");
    }
    else if (subcmd == "ask")
    {
        if (rest.empty())
        {
            control->Output(DEBUG_OUTPUT_ERROR, "Error: No question provided\n");
            control->Output(DEBUG_OUTPUT_NORMAL, "Usage: !agent ask <question>\n");
        }
        else
        {
            windbg_agent::WinDbgClient dbg_client(Client);
            auto settings = windbg_agent::LoadSettings();
            auto& session = GetAgentSession();
            std::string target = dbg_client.GetTargetName();
            auto runtime_ctx = GatherRuntimeContext(dbg_client);

            std::string error;
            bool created = false;
            if (!EnsureAgent(session, dbg_client, settings, target, runtime_ctx, &error, &created))
            {
                dbg_client.OutputError(error.empty() ? "Failed to initialize agent" : error);
                control->Release();
                return E_FAIL;
            }

            std::string provider_name = libagents::provider_type_name(settings.default_provider);
            dbg_client.OutputThinking("[" + provider_name + "] Asking: " + rest);
            if (created)
                dbg_client.OutputThinking("Initializing " + provider_name + " provider...");

            try
            {
                std::string message =
                    session.primed || session.system_prompt.empty()
                        ? rest
                        : (session.system_prompt + "\n\n---\n\n" + rest);

                std::string response = session.agent->query_hosted(message, session.host);
                session.primed = true;
                if (response == "(Aborted)")
                    dbg_client.OutputWarning("Aborted.");

#if !WINDBG_AGENT_DISABLE_SESSIONS
                // Skip session persistence when BYOK is enabled (not supported by BYOK providers)
                const auto* byok_save = settings.get_byok();
                if (!(byok_save && byok_save->is_usable()))
                {
                    std::string new_session_id = session.agent->get_session_id();
                    if (!new_session_id.empty() && new_session_id != session.session_id)
                    {
                        windbg_agent::GetSessionStore().SetSessionId(target, provider_name,
                                                                       new_session_id);
                        session.session_id = new_session_id;
                    }
                }
#endif
            }
            catch (const std::exception& e)
            {
                dbg_client.OutputError(e.what());
            }
        }
    }
    else
    {
        control->Output(DEBUG_OUTPUT_ERROR, "Unknown subcommand: %s\n", subcmd.c_str());
        control->Output(DEBUG_OUTPUT_NORMAL, "Use '!agent help' for usage information.\n");
    }

    control->Release();
    return S_OK;
}

// !agent command - main entry point
extern "C" HRESULT CALLBACK agent(PDEBUG_CLIENT Client, PCSTR Args)
{
    return agent_impl(Client, Args);
}

// !ai command - shorthand for "!agent ask"
extern "C" HRESULT CALLBACK ai(PDEBUG_CLIENT Client, PCSTR Args)
{
    // Prepend "ask " to make it equivalent to "!agent ask <args>"
    std::string full_args = "ask ";
    if (Args && *Args)
        full_args += Args;
    return agent_impl(Client, full_args.c_str());
}

```

`mcp_server.cpp`:

```cpp
#include "mcp_server.hpp"

#include <fastmcpp/mcp/handler.hpp>
#include <fastmcpp/server/sse_server.hpp>
#include <fastmcpp/tools/manager.hpp>
#include <fastmcpp/tools/tool.hpp>
#include <nlohmann/json.hpp>

#include <chrono>
#include <sstream>

namespace windbg_agent {

using Json = nlohmann::json;

class MCPServer::Impl {
public:
    fastmcpp::tools::ToolManager tool_manager;
    std::unique_ptr<fastmcpp::server::SseServerWrapper> server;
};

MCPServer::MCPServer() = default;

MCPServer::~MCPServer() {
    stop();
}

MCPQueueResult MCPServer::queue_and_wait(MCPPendingCommand::Type type, const std::string& input) {
    if (!running_.load()) {
        return {false, "Error: MCP server is not running"};
    }

    MCPPendingCommand cmd;
    cmd.type = type;
    cmd.input = input;
    cmd.completed = false;

    std::mutex done_mutex;
    std::condition_variable done_cv;
    cmd.done_mutex = &done_mutex;
    cmd.done_cv = &done_cv;

    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        pending_commands_.push(&cmd);
    }
    queue_cv_.notify_one();

    {
        std::unique_lock<std::mutex> lock(done_mutex);
        done_cv.wait(lock, [&]() { return cmd.completed || !running_.load(); });
    }

    if (!cmd.completed) {
        return {false, "Error: MCP server stopped"};
    }

    return {true, cmd.result};
}

int MCPServer::start(int port, ExecCallback exec_cb, AskCallback ask_cb,
                     const std::string& bind_addr) {
    if (running_.load()) {
        return port_;
    }

    exec_cb_ = exec_cb;
    ask_cb_ = ask_cb;
    bind_addr_ = bind_addr;

    impl_ = std::make_unique<Impl>();

    // Register dbg_exec tool
    Json exec_input_schema = {
        {"type", "object"},
        {"properties", {
            {"command", {
                {"type", "string"},
                {"description", "WinDbg/CDB debugger command to execute (e.g., 'kb', '!analyze -v', 'dt')"}
            }}
        }},
        {"required", Json::array({"command"})}
    };

    Json exec_output_schema = {
        {"type", "object"},
        {"properties", {
            {"output", {{"type", "string"}}},
            {"success", {{"type", "boolean"}}}
        }}
    };

    fastmcpp::tools::Tool dbg_exec_tool{
        "dbg_exec",
        exec_input_schema,
        exec_output_schema,
        [this](const Json& args) -> Json {
            std::string command = args.value("command", "");
            if (command.empty()) {
                return Json{
                    {"content", Json::array({
                        Json{{"type", "text"}, {"text", "Error: missing command"}}
                    })},
                    {"isError", true}
                };
            }

            auto result = queue_and_wait(MCPPendingCommand::Type::Exec, command);

            // MCP tools/call expects content array format
            return Json{
                {"content", Json::array({
                    Json{{"type", "text"}, {"text", result.payload}}
                })},
                {"isError", !result.success}
            };
        }
    };
    dbg_exec_tool.set_description("Execute a WinDbg/CDB debugger command and return its output");
    impl_->tool_manager.register_tool(dbg_exec_tool);

    // Register dbg_ask tool
    Json ask_input_schema = {
        {"type", "object"},
        {"properties", {
            {"query", {
                {"type", "string"},
                {"description", "Question to ask the AI debugging assistant"}
            }}
        }},
        {"required", Json::array({"query"})}
    };

    Json ask_output_schema = {
        {"type", "object"},
        {"properties", {
            {"response", {{"type", "string"}}},
            {"success", {{"type", "boolean"}}}
        }}
    };

    fastmcpp::tools::Tool dbg_ask_tool{
        "dbg_ask",
        ask_input_schema,
        ask_output_schema,
        [this](const Json& args) -> Json {
            std::string query = args.value("query", "");
            if (query.empty()) {
                return Json{
                    {"content", Json::array({
                        Json{{"type", "text"}, {"text", "Error: missing query"}}
                    })},
                    {"isError", true}
                };
            }

            auto result = queue_and_wait(MCPPendingCommand::Type::Ask, query);

            return Json{
                {"content", Json::array({
                    Json{{"type", "text"}, {"text", result.payload}}
                })},
                {"isError", !result.success}
            };
        }
    };
    dbg_ask_tool.set_description("Ask the AI debugging assistant a question about the current debug session");
    impl_->tool_manager.register_tool(dbg_ask_tool);

    // Create MCP handler
    std::unordered_map<std::string, std::string> descriptions = {
        {"dbg_exec", "Execute a WinDbg/CDB debugger command and return its output"},
        {"dbg_ask", "Ask the AI debugging assistant a question about the current debug session"}
    };

    auto handler = fastmcpp::mcp::make_mcp_handler(
        "windbg-agent",
        "1.0.0",
        impl_->tool_manager,
        descriptions
    );

    // Create and start SSE server
    impl_->server = std::make_unique<fastmcpp::server::SseServerWrapper>(
        handler,
        bind_addr_,
        port,
        "/sse",
        "/messages"
    );

    if (!impl_->server->start()) {
        impl_.reset();
        return -1;
    }

    port_ = port;
    running_.store(true);

    return port_;
}

void MCPServer::set_interrupt_check(std::function<bool()> check) {
    interrupt_check_ = check;
}

void MCPServer::wait() {
    while (running_.load()) {
        if (interrupt_check_ && interrupt_check_()) {
            stop();
            break;
        }

        MCPPendingCommand* cmd = nullptr;

        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (queue_cv_.wait_for(lock, std::chrono::milliseconds(100),
                                   [this]() { return !pending_commands_.empty() || !running_.load(); })) {
                if (!pending_commands_.empty()) {
                    cmd = pending_commands_.front();
                    pending_commands_.pop();
                }
            }
        }

        if (cmd) {
            try {
                if (cmd->type == MCPPendingCommand::Type::Exec && exec_cb_) {
                    cmd->result = exec_cb_(cmd->input);
                } else if (cmd->type == MCPPendingCommand::Type::Ask && ask_cb_) {
                    cmd->result = ask_cb_(cmd->input);
                } else {
                    cmd->result = "Error: No handler for command type";
                }
            } catch (const std::exception& e) {
                cmd->result = std::string("Error: ") + e.what();
            }

            if (cmd->done_mutex && cmd->done_cv) {
                {
                    std::lock_guard<std::mutex> lock(*cmd->done_mutex);
                    cmd->completed = true;
                }
                cmd->done_cv->notify_one();
            }
        }
    }
}

void MCPServer::stop() {
    running_.store(false);
    queue_cv_.notify_all();
    complete_pending_commands("Error: MCP server stopped");

    if (impl_ && impl_->server) {
        impl_->server->stop();
    }
}

void MCPServer::complete_pending_commands(const std::string& result) {
    std::queue<MCPPendingCommand*> pending;
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        std::swap(pending, pending_commands_);
    }

    while (!pending.empty()) {
        MCPPendingCommand* cmd = pending.front();
        pending.pop();
        if (!cmd || !cmd->done_mutex || !cmd->done_cv) {
            continue;
        }

        {
            std::lock_guard<std::mutex> lock(*cmd->done_mutex);
            if (!cmd->completed) {
                cmd->result = result;
                cmd->completed = true;
            }
        }
        cmd->done_cv->notify_one();
    }
}

std::string format_mcp_info(
    const std::string& target_name,
    unsigned long pid,
    const std::string& state,
    const std::string& url
) {
    std::ostringstream ss;
    ss << "MCP SERVER ACTIVE\n";
    ss << "Target: " << target_name << " (PID " << pid << ")\n";
    ss << "State: " << state << "\n";
    ss << "SSE Endpoint: " << url << "/sse\n";
    ss << "Message Endpoint: " << url << "/messages\n\n";

    ss << "AVAILABLE TOOLS:\n";
    ss << "  dbg_exec  - Execute a debugger command\n";
    ss << "  dbg_ask   - Ask the AI assistant a question\n\n";

    ss << "MCP CLIENT CONFIGURATION:\n";
    ss << "Add to your MCP client (e.g., Claude Desktop):\n";
    ss << "{\n";
    ss << "  \"mcpServers\": {\n";
    ss << "    \"windbg-agent\": {\n";
    ss << "      \"url\": \"" << url << "/sse\"\n";
    ss << "    }\n";
    ss << "  }\n";
    ss << "}\n\n";

    ss << "EXAMPLE CURL COMMANDS:\n";
    ss << "  # List available tools\n";
    ss << "  curl -X POST " << url << "/messages \\\n";
    ss << "    -H \"Content-Type: application/json\" \\\n";
    ss << "    -d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/list\",\"params\":{}}'\n\n";

    ss << "  # Execute a debugger command\n";
    ss << "  curl -X POST " << url << "/messages \\\n";
    ss << "    -H \"Content-Type: application/json\" \\\n";
    ss << "    -d '{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"dbg_exec\",\"arguments\":{\"command\":\"kb\"}}}'\n";

    return ss.str();
}

} // namespace windbg_agent

```

`mcp_server.hpp`:

```hpp
#pragma once

#include <string>
#include <functional>
#include <thread>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <memory>

namespace windbg_agent {

// Callbacks for handling requests (same as http_server)
using ExecCallback = std::function<std::string(const std::string& command)>;
using AskCallback = std::function<std::string(const std::string& query)>;

// Internal command structure for cross-thread execution
struct MCPPendingCommand {
    enum class Type { Exec, Ask };
    Type type;
    std::string input;
    std::string result;
    bool completed = false;
    std::mutex* done_mutex = nullptr;
    std::condition_variable* done_cv = nullptr;
};

struct MCPQueueResult {
    bool success;
    std::string payload;
};

class MCPServer {
public:
    MCPServer();
    ~MCPServer();

    // Non-copyable
    MCPServer(const MCPServer&) = delete;
    MCPServer& operator=(const MCPServer&) = delete;

    // Start MCP server on given port with callbacks
    // Returns actual port used (may differ if auto-assigned)
    // Callbacks will be called on the main thread (in wait())
    // bind_addr: "127.0.0.1" for localhost only, "0.0.0.0" for all interfaces
    int start(int port, ExecCallback exec_cb, AskCallback ask_cb,
              const std::string& bind_addr = "127.0.0.1");

    // Block until server stops, processing commands on the calling thread
    // This is where exec_cb and ask_cb get called
    void wait();

    // Stop the server
    void stop();

    // Check if running
    bool is_running() const { return running_.load(); }

    // Get the port the server is listening on
    int port() const { return port_; }

    // Set interrupt check function (called during wait loop)
    void set_interrupt_check(std::function<bool()> check);

    // Queue a command for execution on the main thread (called by MCP tool handlers)
    MCPQueueResult queue_and_wait(MCPPendingCommand::Type type, const std::string& input);

private:
    std::function<bool()> interrupt_check_;
    std::atomic<bool> running_{false};
    std::string bind_addr_{"127.0.0.1"};
    int port_{0};

    // Command queue for cross-thread execution
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    std::queue<MCPPendingCommand*> pending_commands_;

    // Callbacks stored for main thread execution
    ExecCallback exec_cb_;
    AskCallback ask_cb_;

    // Forward declaration - impl hides fastmcpp
    class Impl;
    std::unique_ptr<Impl> impl_;

    void complete_pending_commands(const std::string& result);
};

// Format MCP server info for display
std::string format_mcp_info(
    const std::string& target_name,
    unsigned long pid,
    const std::string& state,
    const std::string& url
);

} // namespace windbg_agent

```

`output_capture.cpp`:

```cpp
#include "output_capture.hpp"

namespace windbg_agent
{

OutputCapture::OutputCapture() : ref_count_(1), client_(nullptr), original_callbacks_(nullptr) {}

OutputCapture::~OutputCapture()
{
    if (client_)
        Uninstall();
}

HRESULT OutputCapture::Install(IDebugClient* client)
{
    if (client_)
        return E_FAIL; // Already installed

    client_ = client;
    client_->AddRef();

    // Save original callbacks
    client_->GetOutputCallbacks(&original_callbacks_);

    // Install ourselves
    return client_->SetOutputCallbacks(this);
}

HRESULT OutputCapture::Uninstall()
{
    if (!client_)
        return E_FAIL;

    // Restore original callbacks
    HRESULT hr = client_->SetOutputCallbacks(original_callbacks_);

    if (original_callbacks_)
    {
        original_callbacks_->Release();
        original_callbacks_ = nullptr;
    }

    client_->Release();
    client_ = nullptr;

    return hr;
}

std::string OutputCapture::GetAndClear()
{
    std::string result = std::move(captured_output_);
    captured_output_.clear();
    return result;
}

// IUnknown implementation
STDMETHODIMP OutputCapture::QueryInterface(REFIID InterfaceId, PVOID* Interface)
{
    if (InterfaceId == __uuidof(IUnknown) || InterfaceId == __uuidof(IDebugOutputCallbacks))
    {
        *Interface = static_cast<IDebugOutputCallbacks*>(this);
        AddRef();
        return S_OK;
    }
    *Interface = nullptr;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) OutputCapture::AddRef()
{
    return InterlockedIncrement(&ref_count_);
}

STDMETHODIMP_(ULONG) OutputCapture::Release()
{
    ULONG count = InterlockedDecrement(&ref_count_);
    if (count == 0)
        delete this;
    return count;
}

// IDebugOutputCallbacks implementation
STDMETHODIMP OutputCapture::Output(ULONG Mask, PCSTR Text)
{
    // Stack-friendly capture: accumulate nested output and flush once at the outermost call.
    struct StackState
    {
        int depth = 0;
        std::string buffer;
        bool mask_set = false;
        ULONG mask = 0;
    };
    thread_local StackState state;
    state.depth++;

    // Capture the output
    if (Text)
    {
        captured_output_ += Text;
        state.buffer += Text;
    }
    if (!state.mask_set)
    {
        state.mask = Mask;
        state.mask_set = true;
    }

    // Nested call: just accumulate and return.
    if (state.depth > 1)
    {
        state.depth--;
        return S_OK;
    }

    // Outermost call: flush accumulated buffer to original callbacks.
    HRESULT hr = S_OK;
    if (original_callbacks_)
        hr = original_callbacks_->Output(state.mask_set ? state.mask : Mask, state.buffer.c_str());

    state.buffer.clear();
    state.mask_set = false;
    state.depth--;

    return hr;
}

} // namespace windbg_agent

```

`output_capture.hpp`:

```hpp
#pragma once

#include <dbgeng.h>
#include <string>
#include <windows.h>

namespace windbg_agent
{

// Captures debugger output while optionally forwarding to original callbacks
class OutputCapture : public IDebugOutputCallbacks
{
  public:
    OutputCapture();
    ~OutputCapture();

    // Install this capture on the given client, saving the original callbacks
    HRESULT Install(IDebugClient* client);

    // Uninstall and restore original callbacks
    HRESULT Uninstall();

    // Get the captured output and clear the buffer
    std::string GetAndClear();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID InterfaceId, PVOID* Interface) override;
    STDMETHOD_(ULONG, AddRef)() override;
    STDMETHOD_(ULONG, Release)() override;

    // IDebugOutputCallbacks
    STDMETHOD(Output)(ULONG Mask, PCSTR Text) override;

  private:
    LONG ref_count_;
    IDebugClient* client_;
    IDebugOutputCallbacks* original_callbacks_;
    std::string captured_output_;
};

} // namespace windbg_agent

```

`session_store.cpp`:

```cpp
#include "session_store.hpp"
#include "settings.hpp"

#include <chrono>
#include <iomanip>
#include <sstream>

namespace windbg_agent
{

static std::unique_ptr<SessionStore> g_session_store;

SessionStore& GetSessionStore()
{
    if (!g_session_store)
    {
        g_session_store = std::make_unique<SessionStore>();
        g_session_store->Load();
    }
    return *g_session_store;
}

std::string SessionStore::MakeKey(const std::string& target_name, const std::string& provider)
{
    // Use actual path with provider for human-readable keys
    // Format: "path|provider" (pipe separator unlikely in paths)
    return target_name + "|" + provider;
}

std::string SessionStore::GenerateSessionId()
{
    auto now = std::chrono::system_clock::now();
    auto epoch = now.time_since_epoch();
    auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(epoch).count();

    std::stringstream ss;
    ss << "session_" << std::hex << millis;
    return ss.str();
}

std::string SessionStore::GetSessionId(const std::string& target_name,
                                       const std::string& provider) const
{
    if (target_name.empty() || provider.empty())
        return "";

    std::string key = MakeKey(target_name, provider);
    auto it = sessions_.find(key);
    if (it != sessions_.end())
        return it->second;
    return "";
}

void SessionStore::SetSessionId(const std::string& target_name, const std::string& provider,
                                const std::string& session_id)
{
    if (target_name.empty() || provider.empty())
        return;

    std::string key = MakeKey(target_name, provider);
    sessions_[key] = session_id;
    Save();
}

void SessionStore::ClearSession(const std::string& target_name, const std::string& provider)
{
    if (target_name.empty() || provider.empty())
        return;

    std::string key = MakeKey(target_name, provider);
    sessions_.erase(key);
    Save();
}

void SessionStore::Load()
{
    // Load from settings
    Settings settings = LoadSettings();
    sessions_ = settings.sessions;
}

void SessionStore::Save() const
{
    // Load current settings, update sessions, save back
    Settings settings = LoadSettings();
    settings.sessions = sessions_;
    SaveSettings(settings);
}

} // namespace windbg_agent

```

`session_store.hpp`:

```hpp
#pragma once

#include <string>
#include <unordered_map>

namespace windbg_agent
{

// Stores session IDs mapped to target files and providers
// Persisted in ~/.windbg_agent/settings.json
// Key format: target_path|provider -> session_id (human-readable)
class SessionStore
{
  public:
    // Get session ID for a target+provider (returns empty if not found)
    std::string GetSessionId(const std::string& target_name, const std::string& provider) const;

    // Set session ID for a target+provider (saves to disk)
    void SetSessionId(const std::string& target_name, const std::string& provider,
                      const std::string& session_id);

    // Clear session for a target+provider (removes mapping, saves to disk)
    void ClearSession(const std::string& target_name, const std::string& provider);

    // Load from disk
    void Load();

    // Save to disk
    void Save() const;

    // Generate a new unique session ID
    static std::string GenerateSessionId();

  private:
    // Create composite key from target name and provider
    static std::string MakeKey(const std::string& target_name, const std::string& provider);

    // target_path|provider -> session_id
    std::unordered_map<std::string, std::string> sessions_;
};

// Global session store
SessionStore& GetSessionStore();

} // namespace windbg_agent

```

`settings.cpp`:

```cpp
#include "settings.hpp"

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <nlohmann/json.hpp>
#include <stdexcept>

namespace windbg_agent
{

namespace fs = std::filesystem;
using json = nlohmann::json;

std::string GetSettingsDir()
{
    // Get user home directory
    const char* home = std::getenv("USERPROFILE");
    if (!home)
        home = std::getenv("HOME");
    if (!home)
        return ".windbg_agent";
    return std::string(home) + "\\.windbg_agent";
}

std::string GetSettingsPath()
{
    return GetSettingsDir() + "\\settings.json";
}

libagents::ProviderType ParseProviderType(const std::string& name)
{
    std::string lower = name;
    std::transform(lower.begin(), lower.end(), lower.begin(),
                   [](unsigned char c) { return std::tolower(c); });

    if (lower == "claude" || lower == "claude-code")
        return libagents::ProviderType::Claude;
    if (lower == "copilot" || lower == "github-copilot")
        return libagents::ProviderType::Copilot;

    throw std::runtime_error("Unknown provider: " + name);
}

Settings LoadSettings()
{
    Settings settings;
    std::string path = GetSettingsPath();

    // Create directory if it doesn't exist
    std::string dir = GetSettingsDir();
    if (!fs::exists(dir))
        fs::create_directories(dir);

    // Load if file exists
    if (fs::exists(path))
    {
        try
        {
            std::ifstream file(path);
            if (file.is_open())
            {
                json j;
                file >> j;

                if (j.contains("default_provider"))
                {
                    std::string provider = j["default_provider"].get<std::string>();
                    try
                    {
                        settings.default_provider = ParseProviderType(provider);
                    }
                    catch (...)
                    {
                        // Keep default if invalid
                    }
                }

                if (j.contains("custom_prompt"))
                    settings.custom_prompt = j["custom_prompt"].get<std::string>();

                if (j.contains("response_timeout_ms"))
                    settings.response_timeout_ms = j["response_timeout_ms"].get<int>();

                if (j.contains("sessions"))
                    for (auto& [key, value] : j["sessions"].items())
                        settings.sessions[key] = value.get<std::string>();

                if (j.contains("byok"))
                {
                    // BYOK is a map of provider_name -> BYOKSettings
                    for (auto& [provider_name, byok_json] : j["byok"].items())
                    {
                        BYOKSettings byok_settings;
                        if (byok_json.contains("enabled"))
                            byok_settings.enabled = byok_json["enabled"].get<bool>();
                        if (byok_json.contains("api_key"))
                            byok_settings.api_key = byok_json["api_key"].get<std::string>();
                        if (byok_json.contains("base_url"))
                            byok_settings.base_url = byok_json["base_url"].get<std::string>();
                        if (byok_json.contains("model"))
                            byok_settings.model = byok_json["model"].get<std::string>();
                        if (byok_json.contains("provider_type"))
                            byok_settings.provider_type =
                                byok_json["provider_type"].get<std::string>();
                        if (byok_json.contains("timeout_ms"))
                            byok_settings.timeout_ms = byok_json["timeout_ms"].get<int>();
                        settings.byok[provider_name] = byok_settings;
                    }
                }
            }
        }
        catch (...)
        {
            // Keep defaults on parse error
        }
    }
    else
    {
        // Create default settings file
        SaveSettings(settings);
    }

    return settings;
}

void SaveSettings(const Settings& settings)
{
    std::string dir = GetSettingsDir();
    if (!fs::exists(dir))
        fs::create_directories(dir);

    json j;
    j["default_provider"] = libagents::provider_type_name(settings.default_provider);
    if (!settings.custom_prompt.empty())
        j["custom_prompt"] = settings.custom_prompt;
    if (settings.response_timeout_ms > 0)
        j["response_timeout_ms"] = settings.response_timeout_ms;
    if (!settings.sessions.empty())
    {
        json sessions_json;
        for (const auto& [key, value] : settings.sessions)
            sessions_json[key] = value;
        j["sessions"] = sessions_json;
    }

    // Save BYOK settings per provider
    if (!settings.byok.empty())
    {
        json byok_map;
        for (const auto& [provider_name, byok_settings] : settings.byok)
        {
            json byok_json;
            byok_json["enabled"] = byok_settings.enabled;
            if (!byok_settings.api_key.empty())
                byok_json["api_key"] = byok_settings.api_key;
            if (!byok_settings.base_url.empty())
                byok_json["base_url"] = byok_settings.base_url;
            if (!byok_settings.model.empty())
                byok_json["model"] = byok_settings.model;
            if (!byok_settings.provider_type.empty())
                byok_json["provider_type"] = byok_settings.provider_type;
            if (byok_settings.timeout_ms > 0)
                byok_json["timeout_ms"] = byok_settings.timeout_ms;
            byok_map[provider_name] = byok_json;
        }
        j["byok"] = byok_map;
    }

    std::ofstream file(GetSettingsPath());
    if (file.is_open())
        file << j.dump(2);
}

} // namespace windbg_agent

```

`settings.hpp`:

```hpp
#pragma once

#include <libagents/config.hpp>
#include <libagents/provider.hpp>
#include <string>
#include <unordered_map>

namespace windbg_agent
{

// BYOK settings for a single provider
struct BYOKSettings
{
    bool enabled = false;
    std::string api_key;
    std::string base_url;
    std::string model;
    std::string provider_type; // "openai", "anthropic", "azure"
    int timeout_ms = 0;

    // Convert to libagents BYOKConfig
    libagents::BYOKConfig to_config() const
    {
        libagents::BYOKConfig config;
        config.api_key = api_key;
        config.base_url = base_url;
        config.model = model;
        config.provider_type = provider_type;
        config.timeout_ms = timeout_ms;
        return config;
    }

    // Check if BYOK is usable (enabled and has API key)
    bool is_usable() const { return enabled && !api_key.empty(); }
};

// Settings stored in ~/.windbg_agent/settings.json
struct Settings
{
    // Default provider (claude, copilot)
    libagents::ProviderType default_provider = libagents::ProviderType::Copilot;

    // User's custom prompt (additive to system prompt)
    std::string custom_prompt;

    // Response timeout in milliseconds (0 = use default 60s)
    int response_timeout_ms = 120000; // 2 minutes default

    // Session ID mappings (target_path|provider -> session_id)
    std::unordered_map<std::string, std::string> sessions;

    // BYOK (Bring Your Own Key) configuration per provider
    // Key: provider name ("copilot", "claude")
    std::unordered_map<std::string, BYOKSettings> byok;

    // Get BYOK settings for the current provider
    const BYOKSettings* get_byok() const
    {
        std::string provider_name = libagents::provider_type_name(default_provider);
        auto it = byok.find(provider_name);
        if (it != byok.end())
            return &it->second;
        return nullptr;
    }

    // Get or create BYOK settings for the current provider
    BYOKSettings& get_or_create_byok()
    {
        std::string provider_name = libagents::provider_type_name(default_provider);
        return byok[provider_name];
    }
};

// Get the settings directory path (~/.windbg_agent)
std::string GetSettingsDir();

// Get the settings file path (~/.windbg_agent/settings.json)
std::string GetSettingsPath();

// Load settings from disk (creates default if not exists)
Settings LoadSettings();

// Save settings to disk
void SaveSettings(const Settings& settings);

// Parse provider type from string (e.g., "claude", "copilot")
libagents::ProviderType ParseProviderType(const std::string& name);

} // namespace windbg_agent

```

`system_prompt.hpp`:

```hpp
#pragma once

#include <string>

namespace windbg_agent
{

constexpr const char* kSystemPrompt =
    R"(You are WinDbg Copilot, an expert debugging assistant operating inside an active WinDbg/CDB debugging session.

You are already connected to a debug target (live or crash dump) - this could be a running process, a crash dump, or a kernel debug session. Your primary tool is dbg_exec, which sends commands directly to the Windows Debugger Engine exactly as if the user typed them in the debugger console.

IMPORTANT: Always use dbg_exec to investigate. Never guess or speculate - run debugger commands to get actual state. Based on the user's question, determine what information you need and query the debugger accordingly.

## Expression Evaluation
Use the debugger's built-in evaluators for calculations - don't compute manually:
- ? <expr> - MASM expression evaluator (default). Example: ? @rax + @rbx
- ?? <expr> - C++ expression evaluator. Example: ?? sizeof(ntdll!_PEB)
- .formats <value> - Show value in multiple formats (hex, decimal, binary, chars)

Prefix registers with @ for unambiguous evaluation: ? @rax + 0x100

## Debugger Data Model (dx)
The `dx` command queries the extensible Debugger Data Model using expressions and LINQ.

Syntax: dx [-g|-gc #][-c #][-n|-v]-r[#] Expression[,<FormatSpecifier>]

Flags:
- -r[#] - Recurse subtypes up to # levels (default=1)
- -g - Display as data grid (rows=elements, columns=properties)
- -gc # - Grid with cell width limited to # characters
- -v - Verbose: show methods and non-typical objects
- -n - Native C/C++ structures only (no NatVis)
- -c # - Skip first # elements (container continuation)

Format specifiers (append with comma):
- ,x ,d ,o ,b - Hex, decimal, octal, binary
- ,s ,su ,s8 - ASCII, UTF-16, UTF-8 string
- ,! - Raw mode (no NatVis)
- ,# - Limit display length to # elements

Key pseudo-registers:
- @$cursession, @$curprocess, @$curthread, @$curframe, @$curstack
- @$ip (instruction pointer), @$csp (stack pointer), @$ra (return address), @$retreg (return value)

Object hierarchy:
- Debugger.Sessions / Settings / State / Utility / LastEvent
- @$cursession.Processes / Attributes / TTD
- @$curprocess.Threads / Modules / Environment / Io.Handles (kernel)
- @$curthread.Stack / Registers / Environment

Common dx patterns:
  dx -r2 @$cursession                              # Session, 2 levels deep
  dx -g @$curprocess.Modules                       # Modules as table
  dx @$curthread.Id,x                              # Thread ID in hex
  dx @$myVar = @$curprocess.Modules.First()        # Store in variable
  dx -r2 @$curthread.Environment.EnvironmentBlock  # TEB access
  dx (ntdll!_PEB *)@$peb                           # Cast to type

### LINQ Queries
LINQ methods work on any iterable. Chain them for complex queries.

Filtering:
  .Where(x => predicate)              # Filter by condition
  dx @$curprocess.Modules.Where(m => m.Name.Contains("ntdll"))

Projection:
  .Select(x => expression)            # Transform elements
  dx @$curprocess.Threads.Select(t => new { Id = t.Id, Frames = t.Stack.Frames.Count() })

Ordering:
  .OrderBy(x => key)                  # Sort ascending
  .OrderByDescending(x => key)        # Sort descending
  dx @$curprocess.Modules.OrderBy(m => m.Size)

Aggregation:
  .Count(), .Sum(x => val), .Min(x => val), .Max(x => val)
  .First(), .First(x => cond), .Last()
  dx @$curprocess.Modules.Max(m => m.Size)

Grouping & Sets:
  .GroupBy(x => key)                  # Group by key
  .Distinct()                         # Remove duplicates
  dx @$curprocess.Threads.GroupBy(t => t.Stack.Frames.Count())

Limiting:
  .Take(n), .Skip(n), .TakeWhile(x => cond), .SkipWhile(x => cond)
  dx @$curprocess.Modules.Skip(5).Take(5)

Boolean checks:
  .Any(x => cond), .All(x => cond), .Contains(value)
  dx @$curprocess.Threads.Any(t => t.Id == 0x1234)

Flattening:
  .SelectMany(x => collection)        # Project and flatten
  .Flatten(x => children)             # Flatten tree structures
  dx @$cursession.Processes.SelectMany(p => p.Threads)

Combined example - Top 5 largest modules:
  dx @$curprocess.Modules.Where(m => m.Size > 0x100000).OrderByDescending(m => m.Size).Take(5).Select(m => new { Name = m.Name, Size = m.Size })

TTD queries (when trace loaded):
  dx @$cursession.TTD.Calls("kernel32!CreateFileW").Where(c => c.ReturnValue == 0xffffffffffffffff)
  dx @$cursession.TTD.Memory(0x7ff00000, 0x7ff10000, "w").OrderBy(m => m.TimeStart)

## Disassembly
- u <addr> - Unassemble at address (default 8 instructions)
- u <addr> L<count> - Unassemble specific number of instructions
- uf <addr> - Unassemble entire function (finds boundaries automatically)
- uf /c <addr> - Unassemble function showing only call instructions
- ub <addr> - Unassemble backwards from address

To find function boundaries: use `uf` which automatically detects function start/end, or use `x module!name` to get the function address, then `ln <addr>` to find symbol and extent.

## Stack Frames & Local Variables
- .frame <n> - Switch to stack frame number n
- .frame /c <n> - Switch frame and show source context
- dv - Display local variables in current frame
- dv /t - Display locals with their types
- dv /v - Display locals with storage location (register/stack offset)
- dv /i - Display locals with classification (parameter, local, this)
- dv <pattern> - Filter variables by name pattern

Workflow for examining a specific frame:
1. Use `k` to see the stack
2. Use `.frame <n>` to select the frame of interest
3. Use `dv /t /v` to see locals with types and locations
4. Use `dt` on specific variables to examine structures

## Symbol Lookup
- x <module>!<pattern> - Find symbols. Example: x kernel32!*Alloc*, x ntdll!Nt*
- ln <addr> - List nearest symbol to address (shows function + offset)
- .sympath - Show/set symbol path
- .reload /f <module> - Force reload symbols

## Memory Examination
- db/dw/dd/dq <addr> - Display bytes/words/dwords/qwords
- da/du <addr> - Display ASCII/Unicode string
- dps/dqs <addr> - Display pointers with symbol resolution
- dds <addr> L<count> - Dump dwords as symbols (great for stack reconstruction)

## Type Display
- dt <type> - Show type layout. Example: dt ntdll!_PEB
- dt <type> <addr> - Display type at address. Example: dt ntdll!_TEB @$teb
- dt -r <type> <addr> - Recursive display (expand nested structures)
- dt -r1 <type> <addr> - Recursive to depth 1 only

## Common Commands
- !analyze -v - Automatic crash/exception analysis (start here for crashes)
- k, kp, kn - Call stack (with params, with frame numbers)
- r - Registers
- lm - Loaded modules
- .exr -1 - Exception record
- !peb - Process environment block
- !teb - Thread environment block
- !threads - Thread list
- ~*k - All thread stacks
- !heap -s - Heap summary

## Pseudo-Registers
Classic: @$teb, @$peb, @$ip, @$csp, @$ra, @$retreg
Data Model: @$cursession, @$curprocess, @$curthread, @$curframe, @$curstack (see dx section)

## Decompilation / Reverse Engineering
When asked to "decompile" or "reverse engineer" a function:
1. Use `uf <function>` to get the full disassembly
2. Use `.frame` + `dv /t` to gather parameter and local variable types if at a breakpoint
3. Use `dt` on relevant structures to understand data layouts
4. Use `x <module>!*` patterns to find related symbols
5. Analyze the assembly and produce best-effort C/C++ pseudocode

For decompilation, identify:
- Function prologue/epilogue patterns
- Calling convention (parameters in rcx, rdx, r8, r9 on x64; stack on x86)
- Local variable stack allocations (sub rsp, ...)
- Control flow (jumps, loops, conditionals)
- API calls and their parameters

Provide pseudocode that captures the logic, using descriptive variable names inferred from usage patterns.

## Direct Command Execution
Users may pass debugger commands directly as their query:
- "db @rip L20" - Execute `db @rip L20` and explain the output
- "!peb" - Execute `!peb` and explain the output
- "k" - Execute `k` and explain the output

Recognition patterns:
- Query starts with a known command (k, r, u, uf, db, dd, dq, dt, dx, lm, x, etc.)
- Query starts with `!` (extension command like !peb, !heap, !analyze)
- Query starts with `.` (meta-command like .frame, .formats, .exr)

When you recognize a command:
1. Execute it via dbg_exec
2. Present the output
3. Explain what it shows

The user may also use an explicit `!` prefix to force execution:
- "!db @rsp L10" - The leading `!` before `db` explicitly means "run this command"

Strip the leading `!` when executing (e.g., "!db @rsp" becomes "db @rsp").

If ambiguous, prefer executing as a command. Users asking questions typically use natural language.

## Shellcode / Suspicious Memory Detection
When asked to find shellcode, injected code, or suspicious memory (e.g., "!copilot any shellcode?"):

1. Enumerate memory regions:
   - !address -summary - Overview of memory usage
   - !address -f:PAGE_EXECUTE_READWRITE - Find RWX regions (highly suspicious)
   - !address -f:PAGE_EXECUTE_READ - Find RX regions

2. Identify suspicious regions:
   - Executable memory NOT backed by an image (Type: Private or Mapped, not Image)
   - PAGE_EXECUTE_READWRITE (RWX) - legitimate code rarely needs this
   - Small executable regions outside module boundaries
   - Compare with `lm` to exclude legitimate modules

3. Examine suspicious regions:
   - u <addr> L20 - Disassemble to check for valid code
   - db <addr> - Look for shellcode patterns
   - !address <addr> - Get region details

4. Common shellcode indicators:
   - Starts with FC (cld), E8 (call $+5), 60 (pushad)
   - PEB access: 64 A1 30 00 00 00 (mov eax, fs:[0x30]) or 65 48 8B (gs:[0x60] on x64)
   - API hashing loops, GetProcAddress resolution stubs

Workflow: !address -f:PAGE_EXECUTE_READWRITE → cross-ref with lm → u <suspicious_addr> → report findings.

## Approach
1. Run commands to understand the current state (start with !analyze -v for crashes)
2. Use expression evaluators for calculations, not manual math
3. Examine relevant registers, memory, and variables
4. Follow the evidence - run more commands as needed
5. Explain your findings clearly

Be concise. Show your reasoning.)";

// Runtime context for the current debugging session
struct RuntimeContext
{
    std::string target_name;   // Dump file or process name
    std::string target_arch;   // x86, x64, ARM64
    std::string debugger_type; // WinDbg, CDB, etc.
    std::string cwd;           // Current working directory
    std::string timestamp;     // Session start time (ISO 8601)
    std::string platform;      // OS info

    bool has_content() const
    {
        return !target_name.empty() || !target_arch.empty() || !debugger_type.empty() ||
               !cwd.empty() || !timestamp.empty() || !platform.empty();
    }
};

// Format runtime context as a prompt section
inline std::string FormatRuntimeContext(const RuntimeContext& ctx)
{
    std::string result = "\n\n## Session Context\n";

    if (!ctx.target_name.empty())
        result += "- Target: " + ctx.target_name + "\n";
    if (!ctx.target_arch.empty())
        result += "- Architecture: " + ctx.target_arch + "\n";
    if (!ctx.debugger_type.empty())
        result += "- Debugger: " + ctx.debugger_type + "\n";
    if (!ctx.cwd.empty())
        result += "- Working Directory: " + ctx.cwd + "\n";
    if (!ctx.timestamp.empty())
        result += "- Session Started: " + ctx.timestamp + "\n";
    if (!ctx.platform.empty())
        result += "- Platform: " + ctx.platform + "\n";

    return result;
}

// Combine system prompt with runtime context and user's custom prompt
inline std::string GetFullSystemPrompt(const std::string& custom_prompt,
                                       const RuntimeContext& ctx = {})
{
    std::string result = kSystemPrompt;

    if (ctx.has_content())
        result += FormatRuntimeContext(ctx);

    if (!custom_prompt.empty())
        result += "\n\n" + custom_prompt;

    return result;
}

} // namespace windbg_agent

```

`version.h.in`:

```in
#pragma once
#define WINDBG_AGENT_VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define WINDBG_AGENT_VERSION_MINOR @PROJECT_VERSION_MINOR@
#define WINDBG_AGENT_VERSION_PATCH @PROJECT_VERSION_PATCH@
#define WINDBG_AGENT_VERSION "@PROJECT_VERSION@"

```

`windbg_agent.def`:

```def
LIBRARY windbg_agent
EXPORTS
    DebugExtensionInitialize
    DebugExtensionUninitialize
    DebugExtensionNotify
    agent
    ai

```

`windbg_client.cpp`:

```cpp
#include "windbg_client.hpp"
#include "output_capture.hpp"
#include <cctype>
#include <wrl/client.h>

namespace windbg_agent
{

WinDbgClient::WinDbgClient(IDebugClient* client) : client_(client), control_(nullptr)
{
    if (client_)
    {
        client_->QueryInterface(__uuidof(IDebugControl), (void**)&control_);
        if (control_)
            dml_ = std::make_unique<DmlOutput>(control_);
    }
}

WinDbgClient::~WinDbgClient()
{
    if (control_)
    {
        control_->Release();
        control_ = nullptr;
    }
}

std::string WinDbgClient::ExecuteCommand(const std::string& command)
{
    if (!control_ || !client_)
        return "Error: No debugger control available";

    // Show user what command is being executed
    OutputCommand(command);

    // Install output capture
    OutputCapture capture;
    capture.Install(client_);

    // Execute the command
    HRESULT hr =
        control_->Execute(DEBUG_OUTCTL_THIS_CLIENT, command.c_str(), DEBUG_EXECUTE_DEFAULT);

    // Get captured output
    std::string result = capture.GetAndClear();
    capture.Uninstall();

    if (FAILED(hr))
    {
        result = "Error executing command: hr=" + std::to_string(hr);
        OutputError(result);
    }
    else if (result.empty())
    {
        result = "(No output)";
    }
    else
    {
        // Show the command output to the user
        OutputCommandResult(result);
    }

    return result;
}

void WinDbgClient::Output(const std::string& message)
{
    if (control_)
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s", message.c_str());
}

void WinDbgClient::OutputError(const std::string& message)
{
    if (dml_)
        dml_->OutputError(message.c_str());
    else if (control_)
        control_->Output(DEBUG_OUTPUT_ERROR, "%s\n", message.c_str());
}

void WinDbgClient::OutputWarning(const std::string& message)
{
    if (dml_)
        dml_->OutputWarning(message.c_str());
    else if (control_)
        control_->Output(DEBUG_OUTPUT_WARNING, "%s\n", message.c_str());
}

void WinDbgClient::OutputCommand(const std::string& command)
{
    if (dml_)
        dml_->OutputCommand(command.c_str());
    else if (control_)
        control_->Output(DEBUG_OUTPUT_NORMAL, "$ %s\n", command.c_str());
}

void WinDbgClient::OutputCommandResult(const std::string& result)
{
    if (dml_)
        dml_->OutputCommandResult(result.c_str());
    else if (control_)
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s\n", result.c_str());
}

void WinDbgClient::OutputThinking(const std::string& message)
{
    if (dml_)
        dml_->OutputAgentThinking(message.c_str());
    else if (control_)
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s\n", message.c_str());
}

void WinDbgClient::OutputResponse(const std::string& response)
{
    if (dml_)
        dml_->OutputAgentResponse(response.c_str());
    else if (control_)
        control_->Output(DEBUG_OUTPUT_NORMAL, "%s\n", response.c_str());
}

bool WinDbgClient::SupportsColor() const
{
    return dml_ && dml_->IsDmlSupported();
}

std::string WinDbgClient::GetTargetName() const
{
    if (!client_)
        return "";

    // Try to get dump file name first
    char dump_file[MAX_PATH] = {0};
    ULONG dump_file_size = 0;

    Microsoft::WRL::ComPtr<IDebugClient4> client4;
    if (SUCCEEDED(client_->QueryInterface(__uuidof(IDebugClient4),
                                          reinterpret_cast<void**>(client4.GetAddressOf()))))
    {
        // GetDumpFile returns the dump file name if debugging a dump
        // Note: Handle and Type must not be nullptr - the API writes to them
        ULONG64 handle = 0;
        ULONG type = 0;
        HRESULT hr =
            client4->GetDumpFile(0, dump_file, sizeof(dump_file), &dump_file_size, &handle, &type);

        if (SUCCEEDED(hr) && dump_file[0] != '\0')
            return dump_file;
    }

    // Fall back to getting process name via system objects
    Microsoft::WRL::ComPtr<IDebugSystemObjects> sys;
    if (SUCCEEDED(client_->QueryInterface(__uuidof(IDebugSystemObjects),
                                          reinterpret_cast<void**>(sys.GetAddressOf()))))
    {
        char exe_name[MAX_PATH] = {0};
        ULONG exe_size = 0;
        HRESULT hr = sys->GetCurrentProcessExecutableName(exe_name, sizeof(exe_name), &exe_size);
        if (SUCCEEDED(hr) && exe_name[0] != '\0')
            return exe_name;
    }

    return "";
}

std::string WinDbgClient::GetTargetArchitecture() const
{
    if (!control_)
        return "";

    ULONG proc_type = 0;
    if (SUCCEEDED(control_->GetActualProcessorType(&proc_type)))
    {
        switch (proc_type)
        {
        case IMAGE_FILE_MACHINE_I386:
            return "x86";
        case IMAGE_FILE_MACHINE_AMD64:
            return "x64";
        case IMAGE_FILE_MACHINE_ARM64:
            return "ARM64";
        case IMAGE_FILE_MACHINE_ARM:
        case IMAGE_FILE_MACHINE_ARMNT:
            return "ARM";
        default:
            return "Unknown (" + std::to_string(proc_type) + ")";
        }
    }
    return "";
}

std::string WinDbgClient::GetDebuggerType() const
{
    // Detect debugger by examining host process name
    char module_path[MAX_PATH] = {0};
    if (GetModuleFileNameA(nullptr, module_path, MAX_PATH))
    {
        std::string path = module_path;
        // Convert to lowercase for comparison
        for (auto& c : path)
            c = static_cast<char>(tolower(static_cast<unsigned char>(c)));

        if (path.find("dbgx") != std::string::npos || path.find("windbg") != std::string::npos)
            return "WinDbg";
        if (path.find("cdb") != std::string::npos)
            return "CDB";
        if (path.find("ntsd") != std::string::npos)
            return "NTSD";
        if (path.find("kd") != std::string::npos)
            return "KD";
    }
    return "Windows Debugger";
}

bool WinDbgClient::IsInterrupted() const
{
    if (!control_)
        return false;

    // Check if user pressed Ctrl+C or Ctrl+Break
    HRESULT hr = control_->GetInterrupt();
    return hr == S_OK;
}

std::string WinDbgClient::GetTargetState() const
{
    if (!control_)
        return "Unknown";

    ULONG status = 0;
    HRESULT hr = control_->GetExecutionStatus(&status);
    if (FAILED(hr))
        return "Unknown";

    switch (status)
    {
    case DEBUG_STATUS_NO_DEBUGGEE:
        return "No target";
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
    case DEBUG_STATUS_STEP_BRANCH:
        return "Stepping";
    case DEBUG_STATUS_GO:
    case DEBUG_STATUS_GO_HANDLED:
    case DEBUG_STATUS_GO_NOT_HANDLED:
        return "Running";
    case DEBUG_STATUS_BREAK:
        return "Break";
    case DEBUG_STATUS_OUT_OF_SYNC:
        return "Out of sync";
    case DEBUG_STATUS_WAIT_INPUT:
        return "Waiting for input";
    case DEBUG_STATUS_TIMEOUT:
        return "Timeout";
    default:
        return "Unknown";
    }
}

ULONG WinDbgClient::GetProcessId() const
{
    if (!client_)
        return 0;

    Microsoft::WRL::ComPtr<IDebugSystemObjects> sys;
    if (SUCCEEDED(client_->QueryInterface(__uuidof(IDebugSystemObjects),
                                          reinterpret_cast<void**>(sys.GetAddressOf()))))
    {
        ULONG pid = 0;
        if (SUCCEEDED(sys->GetCurrentProcessSystemId(&pid)))
            return pid;
    }
    return 0;
}

} // namespace windbg_agent

```

`windbg_client.hpp`:

```hpp
#pragma once

#include "dml_output.hpp"
#include <dbgeng.h>
#include <memory>
#include <string>
#include <windows.h>

namespace windbg_agent
{

// WinDbg/CDB debugger client using dbgeng interfaces and DML for colored output
class WinDbgClient
{
  public:
    // Construct with an IDebugClient (typically from extension callback)
    explicit WinDbgClient(IDebugClient* client);
    ~WinDbgClient();

    // Execute a debugger command and return its output
    std::string ExecuteCommand(const std::string& command);

    // Output methods for displaying messages to the user
    void Output(const std::string& message);
    void OutputError(const std::string& message);
    void OutputWarning(const std::string& message);

    // Styled output for agent interactions
    void OutputCommand(const std::string& command);
    void OutputCommandResult(const std::string& result);
    void OutputThinking(const std::string& message);
    void OutputResponse(const std::string& response);

    // Query capabilities
    bool SupportsColor() const;

    // Get target info (dump file path or process name)
    std::string GetTargetName() const;

    // Get target architecture (x86, x64, ARM64, etc.)
    std::string GetTargetArchitecture() const;

    // Get debugger type (WinDbg, CDB, etc.)
    std::string GetDebuggerType() const;

    // Get debugger execution state as a human-readable string
    std::string GetTargetState() const;

    // Get the current process ID (0 if not available)
    ULONG GetProcessId() const;

    // Check if user requested interrupt (e.g., Ctrl+C)
    bool IsInterrupted() const;

  private:
    IDebugClient* client_;
    IDebugControl* control_;
    std::unique_ptr<DmlOutput> dml_;
};

} // namespace windbg_agent

```