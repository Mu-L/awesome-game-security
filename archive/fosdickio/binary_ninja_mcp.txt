Project Path: arc_fosdickio_binary_ninja_mcp_dg9yvtjp

Source Tree:

```txt
arc_fosdickio_binary_ninja_mcp_dg9yvtjp
├── LICENSE
├── README.md
├── __init__.py
├── bridge
│   ├── binja_mcp_bridge.py
│   └── requirements.txt
├── docs_for_llms
│   ├── bn_docs_index.html
│   └── bn_docs_plugins.html
├── example
│   ├── chal
│   └── chal.c
├── images
│   ├── binja.png
│   ├── claude-desktop-integration.png
│   ├── logo-small.png
│   ├── logo.png
│   ├── mcp-demo-rename.gif
│   ├── mcp-demo-report.png
│   └── plugin-manager-listing.png
├── plugin
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   └── endpoints.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── binary_operations.py
│   │   └── config.py
│   ├── server
│   │   ├── __init__.py
│   │   └── http_server.py
│   └── utils
│       ├── __init__.py
│       ├── auto_setup.py
│       ├── number_utils.py
│       ├── python_detection.py
│       └── string_utils.py
├── plugin.json
├── ruff.toml
└── scripts
    ├── mcp_client_installer.py
    └── setup_claude_desktop.py

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`README.md`:

```md
# Binary Ninja MCP

This repository contains a Binary Ninja plugin, MCP server, and bridge that enables seamless integration of Binary Ninja's capabilities with your favorite LLM client.

![Binary Ninja MCP Logo](images/logo-small.png)

## Features

- Seamless, real-time integration between Binary Ninja and MCP clients
- Enhanced reverse engineering workflow with AI assistance
- Support for every MCP client (Cline, Claude desktop, Roo Code, etc.)
- Open multiple binaries and switch the active target automatically

## Examples

### Solving a CTF Challenge

Check out [this demo video on YouTube](https://www.youtube.com/watch?v=0ffMHH39L_M) that uses the extension to solve a CTF challenge.

## Components

This repository contains two separate components:

1. A Binary Ninja plugin that provides an MCP server that exposes Binary Ninja's capabilities through HTTP endpoints. This can be used with any client that implements the MCP protocol.
2. A separate MCP bridge component that connects your favorite MCP client to the Binary Ninja MCP server.

## Prerequisites

- [Binary Ninja](https://binary.ninja/)
- Python 3.12+
- MCP client (those with auto-setup support are listed below)

## Installation

### MCP Client

Please install the MCP client before you install Binary Ninja MCP so that the MCP clients can be auto-setup. We currently support auto-setup for these MCP clients:

    1. Cline (recommended)
    2. Roo Code
    3. Claude Desktop (recommended)
    4. Cursor
    5. Windsurf
    6. Claude Code
    7. LM Studio

### Extension Installation

After the MCP client is installed, you can install the MCP server using the Binary Ninja Plugin Manager or manually. Both methods support auto-setup of MCP clients.

If your MCP client is not set, you should install it first then try to reinstall the extension.

#### Binary Ninja Plugin Manager

You may install the extension through Binary Ninja's Plugin Manager (`Plugins > Manage Plugins`).

![Plugin Manager](images/plugin-manager-listing.png)

#### Manual Install

To manually install the extension, this repository can be copied into the [Binary Ninja plugins folder](https://docs.binary.ninja/guide/plugins.html).

### [Optional] Manual Setup of the MCP Client

*You do NOT need to set this up manually if you use a supported MCP client and follow the installation steps before.*

You can also manage MCP client entries from the command line:

```bash
python scripts/mcp_client_installer.py --install    # auto setup supported MCP clients
python scripts/mcp_client_installer.py --uninstall  # remove entries and delete `.mcp_auto_setup_done`
python scripts/mcp_client_installer.py --config     # print a generic JSON config snippet
```

For other MCP clients, this is an example config:

```json
{
    "mcpServers": {
        "binary_ninja_mcp": {
            "command": "/ABSOLUTE/PATH/TO/Binary Ninja/plugins/repositories/community/plugins/fosdickio_binary_ninja_mcp/.venv/bin/python",
            "args": [
                "/ABSOLUTE/PATH/TO/Binary Ninja/plugins/repositories/community/plugins/fosdickio_binary_ninja_mcp/bridge/binja_mcp_bridge.py"
            ]
        }
    }
}
```

Note: Replace `/ABSOLUTE/PATH/TO` with the actual absolute path to your project directory. The virtual environment's Python interpreter must be used to access the installed dependencies.

## Usage

1. Open Binary Ninja and load a binary
2. Click the button shown at left bottom corner
3. Start using it through your MCP client

You may now start prompting LLMs about the currently open binary (or binaries). Example prompts:

### CTF Challenges

```txt
You're the best CTF player in the world. Please solve this reversing CTF challenge in the <folder_name> folder using Binary Ninja. Rename ALL the function and the variables during your analyzation process (except for main function) so I can better read the code. Write a python solve script if you need. Also, if you need to create struct or anything, please go ahead. Reverse the code like a human reverser so that I can read the decompiled code that analyzed by you.
```

### Malware Analysis

```txt
Your task is to analyze an unknown file which is currently open in Binary Ninja. You can use the existing MCP server called "binary_ninja_mcp" to interact with the Binary Ninja instance and retrieve information, using the tools made available by this server. In general use the following strategy:

- Start from the entry point of the code
- If this function call others, make sure to follow through the calls and analyze these functions as well to understand their context
- If more details are necessary, disassemble or decompile the function and add comments with your findings
- Inspect the decompilation and add comments with your findings to important areas of code
- Add a comment to each function with a brief summary of what it does
- Rename variables and function parameters to more sensible names
- Change the variable and argument types if necessary (especially pointer and array types)
- Change function names to be more descriptive, using mcp_ as prefix.
- NEVER convert number bases yourself. Use the convert_number MCP tool if needed!
- When you finish your analysis, report how long the analysis took
- At the end, create a report with your findings.
- Based only on these findings, make an assessment on whether the file is malicious or not.
```

## Supported Capabilities

The following table lists the available MCP functions for use:

| Function                                                             | Description                                                                                                  |
| -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| `decompile_function`                                                 | Decompile a specific function by name and return HLIL-like code with addresses.                              |
| `get_il(name_or_address, view, ssa)`                                 | Get IL for a function in `hlil`, `mlil`, or `llil` (SSA supported for MLIL/LLIL).                            |
| `define_types`                                                       | Add type definitions from a C string type definition.                                                        |
| `delete_comment`                                                     | Delete the comment at a specific address.                                                                    |
| `delete_function_comment`                                            | Delete the comment for a function.                                                                           |
| `declare_c_type(c_declaration)`                                      | Create/update a local type from a single C declaration.                                                      |
| `format_value(address, text, size)`                                  | Convert a value and annotate it at an address in BN (adds a comment).                                        |
| `function_at`                                                        | Retrieve the name of the function the address belongs to.                                                    |
| `get_assembly_function`                                              | Get the assembly representation of a function by name or address.                                            |
| `get_entry_points()`                                                 | List entry point(s) of the loaded binary.                                                                    |
| `get_binary_status`                                                  | Get the current status of the loaded binary.                                                                 |
| `get_comment`                                                        | Get the comment at a specific address.                                                                       |
| `get_function_comment`                                               | Get the comment for a function.                                                                              |
| `get_user_defined_type`                                              | Retrieve definition of a user-defined type (struct, enumeration, typedef, union).                            |
| `get_xrefs_to(address)`                                              | Get all cross references (code and data) to an address.                                                      |
| `get_data_decl(name_or_address, length)`                             | Return a C-like declaration and a hexdump for a data symbol or address.                                      |
| `hexdump_address(address, length)`                                   | Text hexdump at address. `length < 0` reads exact defined size if available.                                 |
| `hexdump_data(name_or_address, length)`                              | Hexdump by data symbol name or address. `length < 0` reads exact defined size if available.                  |
| `get_xrefs_to_enum(enum_name)`                                       | Get usages related to an enum (matches member constants in code).                                            |
| `get_xrefs_to_field(struct_name, field_name)`                        | Get all cross references to a named struct field.                                                            |
| `get_xrefs_to_struct(struct_name)`                                   | Get xrefs/usages related to a struct (members, globals, code refs).                                          |
| `get_xrefs_to_type(type_name)`                                       | Get xrefs/usages related to a struct/type (globals, refs, HLIL matches).                                     |
| `get_xrefs_to_union(union_name)`                                     | Get xrefs/usages related to a union (members, globals, code refs).                                           |
| `get_stack_frame_vars(function_identifier)`                          | Get stack frame variable information for a function (names, offsets, sizes, types).                           |
| `get_type_info(type_name)`                                           | Resolve a type and return declaration, kind, and members.                                                    |
| `make_function_at(address, platform)`                                | Create a function at an address. `platform` optional; use `default` to pick the BinaryView/platform default. |
| `list_platforms()`                                                   | List all available platform names.                                                                           |
| `list_binaries()`                                                    | List managed/open binaries with ids and active flag.                                                         |
| `select_binary(view)`                                                | Select active binary by id or filename.                                                                      |
| `list_all_strings()`                                                 | List all strings (no pagination; aggregates all pages).                                                      |
| `list_classes`                                                       | List all namespace/class names in the program.                                                               |
| `list_data_items`                                                    | List defined data labels and their values.                                                                   |
| `list_exports`                                                       | List exported functions/symbols.                                                                             |
| `list_imports`                                                       | List imported symbols in the program.                                                                        |
| `list_local_types(offset, count)`                                    | List local Types in the current database (name/kind/decl).                                                   |
| `list_methods`                                                       | List all function names in the program.                                                                      |
| `list_namespaces`                                                    | List all non-global namespaces in the program.                                                               |
| `list_segments`                                                      | List all memory segments in the program.                                                                     |
| `list_strings(offset, count)`                                        | List all strings in the database (paginated).                                                                |
| `list_strings_filter(offset, count, filter)`                         | List matching strings (paginated, filtered by substring).                                                    |
| `rename_data`                                                        | Rename a data label at the specified address.                                                                |
| `rename_function`                                                    | Rename a function by its current name to a new user-defined name.                                            |
| `rename_single_variable`                                             | Rename a single local variable inside a function.                                                            |
| `rename_multi_variables`                                             | Batch rename multiple local variables in a function (mapping or pairs).                                      |
| `set_local_variable_type(function_address, variable_name, new_type)` | Set a local variable's type.                                                                                 |
| `retype_variable`                                                    | Retype variable inside a given function.                                                                     |
| `search_functions_by_name`                                           | Search for functions whose name contains the given substring.                                                |
| `search_types(query, offset, count)`                                 | Search local Types by substring (name/decl).                                                                 |
| `set_comment`                                                        | Set a comment at a specific address.                                                                         |
| `set_function_comment`                                               | Set a comment for a function.                                                                                |
| `set_function_prototype(name_or_address, prototype)`                 | Set a function's prototype by name or address.                                                               |
| `patch_bytes(address, data, save_to_file)`                           | Patch raw bytes at an address (byte-level, not assembly). Can patch entire instructions by providing their bytecode. Address: hex (e.g., "0x401000") or decimal. Data: hex string (e.g., "90 90"). `save_to_file` (default True) saves to disk and re-signs on macOS. |

These are the list of HTTP endpoints that can be called:

- `/allStrings`: All strings in one response.
- `/formatValue?address=<addr>&text=<value>&size=<n>`: Convert and set a comment at an address.
- `/getXrefsTo?address=<addr>`: Xrefs to address (code+data).
- `/getDataDecl?name=<symbol>|address=<addr>&length=<n>`: JSON with declaration-style string and a hexdump for a data symbol or address. Keys: `address`, `name`, `size`, `type`, `decl`, `hexdump`. `length < 0` reads exact defined size if available.
- `/hexdump?address=<addr>&length=<n>`: Text hexdump aligned at address; `length < 0` reads exact defined size if available.
- `/hexdumpByName?name=<symbol>&length=<n>`: Text hexdump by symbol name. Recognizes BN auto-labels like `data_<hex>`, `byte_<hex>`, `word_<hex>`, `dword_<hex>`, `qword_<hex>`, `off_<hex>`, `unk_<hex>`, and plain hex addresses.
- `/makeFunctionAt?address=<addr>&platform=<name|default>`: Create a function at an address (idempotent if already exists). `platform=default` uses the BinaryView/platform default.
- `/platforms`: List all available platform names.
- `/binaries` or `/views`: List managed/open binaries with ids and active flag.
- `/selectBinary?view=<id|filename>`: Select active binary for subsequent operations.
- `/data?offset=<n>&limit=<m>&length=<n>`: Defined data items with previews. `length` controls bytes read per item (capped at defined size). Default behavior reads exact defined size when available; `length=-1` forces exact-size.
- `/getXrefsToEnum?name=<enum>`: Enum usages by matching member constants.
- `/getXrefsToField?struct=<name>&field=<name>`: Xrefs to struct field.
- `/getXrefsToType?name=<type>`: Xrefs/usages related to a struct/type name.
- `/getTypeInfo?name=<type>`: Resolve a type and return declaration and details.
- `/getXrefsToUnion?name=<union>`: Union xrefs/usages (members, globals, refs).
- `/getStackFrameVars?name=<function>|address=<addr>`: Get stack frame variable information for a function.
- `/localTypes?offset=<n>&limit=<m>`: List local types.
- `/strings?offset=<n>&limit=<m>`: Paginated strings.
- `/strings/filter?offset=<n>&limit=<m>&filter=<substr>`: Filtered strings.
- `/searchTypes?query=<substr>&offset=<n>&limit=<m>`: Search local types by substring.
- `/patch` or `/patchBytes?address=<addr>&data=<hex>&save_to_file=<bool>`: Patch raw bytes at an address (byte-level, not assembly). Can patch entire instructions by providing their bytecode. Address: hex (e.g., "0x401000") or decimal. Data: hex string (e.g., "90 90"). `save_to_file` (default True) saves to disk and re-signs on macOS.
- `/renameVariables`: Batch rename locals in a function. Parameters:
  - Function: one of `functionAddress`, `address`, `function`, `functionName`, or `name`.
  - Provide renames via one of:
    - `renames`: JSON array of `{old, new}` objects
    - `mapping`: JSON object of `old->new`
    - `pairs`: compact string `old1:new1,old2:new2`
          Returns per-item results plus totals. Order is respected; later pairs can refer to earlier new names.

## Development

### Code Quality

This project uses [Ruff](https://docs.astral.sh/ruff/) for linting and formatting. Configuration is in `ruff.toml`.

#### Running Ruff Manually

Check for issues:
```bash
ruff check .
```

Auto-fix issues:
```bash
ruff check --fix .
```

Check formatting issues:
```bash
ruff format --check .
```

Format code:
```bash
ruff format .
```

#### GitHub Actions

A GitHub Action workflow (`.github/workflows/lint-format.yml`) automatically runs Ruff on:

- Every push to the `main` branch
- Every pull request targeting the `main` branch

The workflow will fail if there are linting errors or formatting issues, ensuring code quality in CI.

## Contributing

Contributions are welcome. Please feel free to submit a pull request.

```

`__init__.py`:

```py
from .plugin import BinaryNinjaMCP

__all__ = ["BinaryNinjaMCP"]

```

`bridge/binja_mcp_bridge.py`:

```py
import sys as _sys
import traceback as _tb


# Install a very-early excepthook so any ImportError at module import time is captured.
def _bridge_excepthook(exc_type, exc, tb):
    # Print to stderr for interactive runs
    _tb.print_exception(exc_type, exc, tb, file=_sys.stderr)


_sys.excepthook = _bridge_excepthook

import requests
from mcp.server.fastmcp import FastMCP

binja_server_url = "http://localhost:9009"
mcp = FastMCP("binja-mcp")


def _active_filename() -> str:
    """Return the currently active filename as known by the server."""
    try:
        st = get_json("status")
        if isinstance(st, dict) and st.get("filename"):
            return str(st.get("filename"))
    except Exception:
        pass
    return "(none)"


def safe_get(endpoint: str, params: dict | None = None, timeout: float | None = 5) -> list:
    """
    Perform a GET request. If 'params' is given, we convert it to a query string.
    """
    if params is None:
        params = {}
    qs = [f"{k}={v}" for k, v in params.items()]
    query_string = "&".join(qs)
    url = f"{binja_server_url}/{endpoint}"
    if query_string:
        url += "?" + query_string

    try:
        if timeout is None:
            response = requests.get(url)
        else:
            response = requests.get(url, timeout=timeout)
        response.encoding = "utf-8"
        if response.ok:
            return response.text.splitlines()
        else:
            return [f"Error {response.status_code}: {response.text.strip()}"]
    except Exception as e:
        return [f"Request failed: {e!s}"]


def get_json(endpoint: str, params: dict | None = None, timeout: float | None = 5):
    """
    Perform a GET and return parsed JSON.
    - On 2xx: returns parsed JSON.
    - On 4xx/5xx: attempts to parse JSON body and return it; if not JSON, returns {'error': 'Error <code>: <text>'}.
    Returns None only on transport errors.
    """
    if params is None:
        params = {}
    qs = [f"{k}={v}" for k, v in params.items()]
    query_string = "&".join(qs)
    url = f"{binja_server_url}/{endpoint}"
    if query_string:
        url += "?" + query_string
    try:
        if timeout is None:
            response = requests.get(url)
        else:
            response = requests.get(url, timeout=timeout)
        response.encoding = "utf-8"
        # Try to parse JSON regardless of status
        try:
            data = response.json()
        except Exception:
            data = None
        if response.ok:
            return data
        # Non-OK: return parsed error object if available; otherwise synthesize one
        if isinstance(data, dict):
            # Ensure at least an error field for LLMs
            if "error" not in data:
                data = {"error": str(data)}
            data.setdefault("status", response.status_code)
            return data
        text = (response.text or "").strip()
        return {"error": f"Error {response.status_code}: {text}"}
    except Exception as e:
        return {"error": f"Request failed: {e!s}"}


def get_text(endpoint: str, params: dict | None = None, timeout: float | None = 5) -> str:
    """Perform a GET and return raw text (or an error string)."""
    if params is None:
        params = {}
    qs = [f"{k}={v}" for k, v in params.items()]
    query_string = "&".join(qs)
    url = f"{binja_server_url}/{endpoint}"
    if query_string:
        url += "?" + query_string
    try:
        if timeout is None:
            response = requests.get(url)
        else:
            response = requests.get(url, timeout=timeout)
        response.encoding = "utf-8"
        if response.ok:
            return response.text
        else:
            return f"Error {response.status_code}: {response.text.strip()}"
    except Exception as e:
        return f"Request failed: {e!s}"


def safe_post(endpoint: str, data: dict | str) -> str:
    try:
        if isinstance(data, dict):
            response = requests.post(f"{binja_server_url}/{endpoint}", data=data, timeout=5)
        else:
            response = requests.post(
                f"{binja_server_url}/{endpoint}", data=data.encode("utf-8"), timeout=5
            )
        response.encoding = "utf-8"
        if response.ok:
            return response.text.strip()
        else:
            return f"Error {response.status_code}: {response.text.strip()}"
    except Exception as e:
        return f"Request failed: {e!s}"


@mcp.tool()
def list_methods(offset: int = 0, limit: int = 100) -> list:
    """
    List all function names in the program with pagination.
    """
    header = f"File: {_active_filename()}"
    body = safe_get("methods", {"offset": offset, "limit": limit})
    return [header] + (body or [])


@mcp.tool()
def get_entry_points() -> list:
    """
    List entry point(s) of the loaded binary.
    """
    data = get_json("entryPoints")
    if not data or "entry_points" not in data:
        return ["Error: no response"]
    out: list[str] = []
    for ep in data.get("entry_points", []) or []:
        addr = ep.get("address")
        name = ep.get("name") or "(unknown)"
        out.append(f"{addr}\t{name}")
    return out


@mcp.tool()
def retype_variable(function_name: str, variable_name: str, type_str: str) -> str:
    """
    Retype a variable in a function.
    """
    data = get_json(
        "retypeVariable",
        {
            "functionName": function_name,
            "variableName": variable_name,
            "type": type_str,
        },
    )
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and "status" in data:
        return data["status"]
    if isinstance(data, dict) and "error" in data:
        return f"Error: {data['error']}"
    return str(data)


@mcp.tool()
def rename_single_variable(function_name: str, variable_name: str, new_name: str) -> str:
    """
    Rename a variable in a function.
    """
    data = get_json(
        "renameVariable",
        {
            "functionName": function_name,
            "variableName": variable_name,
            "newName": new_name,
        },
    )
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and "status" in data:
        return data["status"]
    if isinstance(data, dict) and "error" in data:
        return f"Error: {data['error']}"
    return str(data)


@mcp.tool()
def rename_multi_variables(
    function_identifier: str,
    mapping_json: str = "",
    pairs: str = "",
    renames_json: str = "",
) -> str:
    """
    Rename multiple local variables in one call.
    - function_identifier: function name or address (hex)
    - Provide either mapping_json (JSON object old->new), renames_json (JSON array of {old,new}), or pairs ("old1:new1,old2:new2").
    Returns per-item results and totals.
    """
    params: dict[str, object] = {}
    ident = (function_identifier or "").strip()
    if ident.lower().startswith("0x") or ident.isdigit():
        params["address"] = ident
    else:
        params["functionName"] = ident

    payload = None
    import json as _json

    if renames_json:
        try:
            payload = _json.loads(renames_json)
        except Exception:
            return "Error: renames_json is not valid JSON"
        params["renames"] = payload
    elif mapping_json:
        try:
            payload = _json.loads(mapping_json)
        except Exception:
            return "Error: mapping_json is not valid JSON"
        params["mapping"] = payload
    elif pairs:
        params["pairs"] = pairs
    else:
        return "Error: provide mapping_json, renames_json, or pairs"

    data = get_json("renameVariables", params)
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("error"):
        return f"Error: {data['error']}"
    try:
        total = data.get("total")
        renamed = data.get("renamed")
        return f"Batch rename: {renamed}/{total} applied"
    except Exception:
        return str(data)


@mcp.tool()
def define_types(c_code: str) -> str:
    """
    Define types from a C code string.
    """
    data = get_json("defineTypes", {"cCode": c_code})
    if not data:
        return "Error: no response"
    # Expect a list of defined type names or a dict; normalize to string
    if isinstance(data, dict) and "error" in data:
        return f"Error: {data['error']}"
    if isinstance(data, (list, tuple)):
        return "Defined types: " + ", ".join(map(str, data))
    return str(data)


@mcp.tool()
def list_classes(offset: int = 0, limit: int = 100) -> list:
    """
    List all namespace/class names in the program with pagination.
    """
    return safe_get("classes", {"offset": offset, "limit": limit})


@mcp.tool()
def hexdump_address(address: str, length: int = -1) -> str:
    """
    Hexdump data starting at an address. When length < 0, reads the exact defined size if available.
    """
    params = {"address": address}
    if length is not None:
        params["length"] = length
    return get_text("hexdump", params, timeout=None)


@mcp.tool()
def hexdump_data(name_or_address: str, length: int = -1) -> str:
    """
    Hexdump a data symbol by name or address. When length < 0, reads the exact defined size if available.
    """
    ident = (name_or_address or "").strip()
    if ident.startswith("0x"):
        return hexdump_address(ident, length)
    return get_text("hexdumpByName", {"name": ident, "length": length}, timeout=None)


@mcp.tool()
def get_data_decl(name_or_address: str, length: int = -1) -> str:
    """
    Return a declaration-like string and a hexdump for a data symbol by name or address.
    LLM-friendly: includes both a C-like declaration (when possible) and text hexdump.
    """
    ident = (name_or_address or "").strip()
    params = {"name": ident} if not ident.startswith("0x") else {"address": ident}
    if length is not None:
        params["length"] = length
    data = get_json("getDataDecl", params, timeout=None)
    if not data:
        return "Error: no response"
    if "error" in data:
        return f"Error: {data.get('error')}"
    decl = data.get("decl") or "(no declaration)"
    hexdump = data.get("hexdump") or ""
    addr = data.get("address", "")
    name = data.get("name", ident)
    return f"Declaration ({addr} {name}):\n{decl}\n\nHexdump:\n{hexdump}"


@mcp.tool()
def decompile_function(name: str) -> str:
    """
    Decompile a specific function by name and return the decompiled C code.
    """
    file_line = f"File: {_active_filename()}\n\n"
    data = get_json("decompile", {"name": name}, timeout=None)
    if not data:
        return file_line + "Error: no response"
    if "decompiled" in data:
        return file_line + data["decompiled"]
    if "error" in data:
        return file_line + f"Error: {data.get('error')}"
    return file_line + str(data)


@mcp.tool()
def get_il(name_or_address: str, view: str = "hlil", ssa: bool = False) -> str:
    """
    Get IL for a function in the selected view.
    - view: one of hlil, mlil, llil
    - ssa: set True to request SSA form (MLIL/LLIL only)
    """
    file_line = f"File: {_active_filename()}\n\n"
    ident = (name_or_address or "").strip()
    params = {"view": view, "ssa": int(bool(ssa))}
    if ident.lower().startswith("0x") or ident.isdigit():
        params["address"] = ident
    else:
        params["name"] = ident
    data = get_json("il", params, timeout=None)
    if not data:
        return file_line + "Error: no response"
    if "il" in data:
        return file_line + data["il"]
    if "error" in data:
        import json as _json

        return file_line + _json.dumps(data, indent=2, ensure_ascii=False)
    return file_line + str(data)


@mcp.tool()
def fetch_disassembly(name: str) -> str:
    """
    Retrive the disassembled code of a function with a given name as assemby mnemonic instructions.
    """
    file_line = f"File: {_active_filename()}\n\n"
    data = get_json("assembly", {"name": name}, timeout=None)
    if not data:
        return file_line + "Error: no response"
    if "assembly" in data:
        return file_line + data["assembly"]
    if "error" in data:
        return file_line + f"Error: {data.get('error')}"
    return file_line + str(data)


@mcp.tool()
def rename_function(old_name: str, new_name: str) -> str:
    """
    Rename a function by its current name to a new user-defined name.
    The configured prefix (default "mcp_") will be automatically prepended if not present.
    """
    return safe_post("renameFunction", {"oldName": old_name, "newName": new_name})


@mcp.tool()
def rename_data(address: str, new_name: str) -> str:
    """
    Rename a data label at the specified address.
    """
    return safe_post("renameData", {"address": address, "newName": new_name})


@mcp.tool()
def set_comment(address: str, comment: str) -> str:
    """
    Set a comment at a specific address.
    """
    return safe_post("comment", {"address": address, "comment": comment})


@mcp.tool()
def set_function_comment(function_name: str, comment: str) -> str:
    """
    Set a comment for a function.
    """
    return safe_post("comment/function", {"name": function_name, "comment": comment})


@mcp.tool()
def get_comment(address: str) -> str:
    """
    Get the comment at a specific address.
    """
    return safe_get("comment", {"address": address})[0]


@mcp.tool()
def get_function_comment(function_name: str) -> str:
    """
    Get the comment for a function.
    """
    return safe_get("comment/function", {"name": function_name})[0]


@mcp.tool()
def list_segments(offset: int = 0, limit: int = 100) -> list:
    """
    List all memory segments in the program with pagination.
    """
    return safe_get("segments", {"offset": offset, "limit": limit})


@mcp.tool()
def list_sections(offset: int = 0, limit: int = 100) -> list:
    """
    List sections in the program with pagination.

    Returns one line per section with: start-end, size, name, and any semantics/type if available.
    """
    data = get_json("sections", {"offset": offset, "limit": limit})
    if not data or not isinstance(data, dict):
        return ["Error: no response"]
    if data.get("error"):
        return [f"Error: {data.get('error')}"]
    sections = data.get("sections", []) or []
    out: list[str] = [f"File: {_active_filename()}"]
    for s in sections:
        try:
            start = s.get("start") or ""
            end = s.get("end") or ""
            size = s.get("size")
            name = s.get("name") or "(unnamed)"
            sem = s.get("semantics") or s.get("type") or ""
            tail = f"\t{sem}" if sem else ""
            out.append(f"{start}-{end}\t{size}\t{name}{tail}")
        except Exception:
            continue
    return out


@mcp.tool()
def list_imports(offset: int = 0, limit: int = 100) -> list:
    """
    List imported symbols in the program with pagination.
    """
    return safe_get("imports", {"offset": offset, "limit": limit})


@mcp.tool()
def list_strings(offset: int = 0, count: int = 100) -> list:
    """
    List all strings in the database (paginated).
    """
    return safe_get("strings", {"offset": offset, "limit": count}, timeout=None)


@mcp.tool()
def list_strings_filter(offset: int = 0, count: int = 100, filter: str = "") -> list:
    """
    List matching strings in the database (paginated, filtered).
    """
    return safe_get(
        "strings/filter",
        {"offset": offset, "limit": count, "filter": filter},
        timeout=None,
    )


@mcp.tool()
def list_local_types(offset: int = 0, count: int = 200, include_libraries: bool = False) -> list:
    """
    List all local types in the database (paginated).
    """
    return safe_get(
        "localTypes",
        {
            "offset": offset,
            "limit": count,
            "includeLibraries": int(bool(include_libraries)),
        },
        timeout=None,
    )


@mcp.tool()
def search_types(
    query: str, offset: int = 0, count: int = 200, include_libraries: bool = False
) -> list:
    """
    Search local types whose name or declaration contains the substring.
    """
    return safe_get(
        "searchTypes",
        {
            "query": query,
            "offset": offset,
            "limit": count,
            "includeLibraries": int(bool(include_libraries)),
        },
        timeout=None,
    )


@mcp.tool()
def list_all_strings(batch_size: int = 500) -> list:
    """
    List all strings in the database (aggregated across pages).
    """
    results: list[str] = []
    offset = 0
    while True:
        data = get_json("strings", {"offset": offset, "limit": batch_size}, timeout=None)
        if not data or "strings" not in data:
            break
        items = data.get("strings", [])
        if not items:
            break
        for s in items:
            addr = s.get("address")
            length = s.get("length")
            stype = s.get("type")
            value = s.get("value")
            results.append(f"{addr}\t{length}\t{stype}\t{value}")
        if len(items) < batch_size:
            break
        offset += batch_size
    return results


@mcp.tool()
def list_exports(offset: int = 0, limit: int = 100) -> list:
    """
    List exported functions/symbols with pagination.
    """
    return safe_get("exports", {"offset": offset, "limit": limit})


@mcp.tool()
def list_namespaces(offset: int = 0, limit: int = 100) -> list:
    """
    List all non-global namespaces in the program with pagination.
    """
    return safe_get("namespaces", {"offset": offset, "limit": limit})


@mcp.tool()
def list_data_items(offset: int = 0, limit: int = 100) -> list:
    """
    List defined data labels and their values with pagination.
    """
    return safe_get("data", {"offset": offset, "limit": limit})


@mcp.tool()
def search_functions_by_name(query: str, offset: int = 0, limit: int = 100) -> list:
    """
    Search for functions whose name contains the given substring.
    """
    if not query:
        return ["Error: query string is required"]
    return safe_get("searchFunctions", {"query": query, "offset": offset, "limit": limit})


@mcp.tool()
def get_binary_status() -> str:
    """
    Get the current status of the loaded binary.
    """
    return safe_get("status")[0]


@mcp.tool()
def list_binaries() -> list:
    """
    List managed/open binaries known to the server with ids and active flag.
    """
    data = get_json("binaries")
    if not data:
        return ["Error: no response"]
    if isinstance(data, dict) and data.get("error"):
        return [data.get("error")]
    items = data.get("binaries", [])
    out = []
    for it in items:
        vid = it.get("id")
        view_id = it.get("view_id")
        fn = it.get("filename")
        basename = it.get("basename") or ""
        selectors = it.get("selectors") or []
        active = it.get("active")
        label = basename or fn or "(unknown)"
        full = fn or "(no filename)"
        selector_text = ", ".join(str(s) for s in selectors if s)
        mark = " *active*" if active else ""
        view_part = f" view={view_id}" if view_id else ""
        out.append(
            f"{vid}. {label}{view_part}{mark}\n    path: {full}\n    selectors: {selector_text}"
        )
    return out


@mcp.tool()
def select_binary(view: str) -> str:
    """
    Select which binary to analyze by ordinal, internal view id, full path, or basename.
    Call this after listing binaries whenever you need to switch analysis targets.
    """
    data = get_json("selectBinary", {"view": view})
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("error"):
        import json as _json

        return _json.dumps(data, indent=2, ensure_ascii=False)
    sel = data.get("selected") if isinstance(data, dict) else None
    if sel:
        ordinal = sel.get("id") or "?"
        view_id = sel.get("view_id") or ""
        fn = sel.get("filename") or ""
        basename = sel.get("basename") or ""
        selectors = sel.get("selectors") or []
        selector_text = ", ".join(str(s) for s in selectors if s)
        display_name = basename or fn or "(unknown)"
        view_part = f" (view {view_id})" if view_id else ""
        path_part = f"\nFull path: {fn}" if fn else ""
        return (
            f"Selected {ordinal}: {display_name}{view_part}{path_part}\nSelectors: {selector_text}"
        )
    return str(data)


@mcp.tool()
def delete_comment(address: str) -> str:
    """
    Delete the comment at a specific address.
    """
    return safe_post("comment", {"address": address, "_method": "DELETE"})


@mcp.tool()
def delete_function_comment(function_name: str) -> str:
    """
    Delete the comment for a function.
    """
    return safe_post("comment/function", {"name": function_name, "_method": "DELETE"})


@mcp.tool()
def function_at(address: str) -> str:
    """
    Retrive the name of the function the address belongs to. Address must be in hexadecimal format 0x00001
    """
    return safe_get("functionAt", {"address": address})


@mcp.tool()
def get_user_defined_type(type_name: str) -> str:
    """
    Retrive definition of a user defined type (struct, enumeration, typedef, union)
    """
    return safe_get("getUserDefinedType", {"name": type_name})


@mcp.tool()
def get_xrefs_to(address: str) -> list:
    """
    Get all cross references (code and data) to the given address.
    Address can be hex (e.g., 0x401000) or decimal.
    """
    return safe_get("getXrefsTo", {"address": address})


@mcp.tool()
def get_xrefs_to_field(struct_name: str, field_name: str) -> list:
    """
    Get all cross references to a named struct field (member).
    """
    return safe_get("getXrefsToField", {"struct": struct_name, "field": field_name})


@mcp.tool()
def get_xrefs_to_struct(struct_name: str) -> list:
    """
    Get cross references/usages related to a struct name.
    """
    return safe_get("getXrefsToStruct", {"name": struct_name})


@mcp.tool()
def get_xrefs_to_type(type_name: str) -> list:
    """
    Get xrefs/usages related to a struct or type name.
    Includes global instances, code refs to those, HLIL matches, and functions whose signature mentions the type.
    """
    return safe_get("getXrefsToType", {"name": type_name})


@mcp.tool()
def get_xrefs_to_enum(enum_name: str) -> list:
    """
    Get usages/xrefs of an enum by scanning for member values and matches.
    """
    return safe_get("getXrefsToEnum", {"name": enum_name})


@mcp.tool()
def get_xrefs_to_union(union_name: str) -> list:
    """
    Get cross references/usages related to a union type by name.
    """
    return safe_get("getXrefsToUnion", {"name": union_name})


@mcp.tool()
def get_stack_frame_vars(function_identifier: str) -> list:
    """
    Get stack frame variable information for a function by name or address.
    Returns names, offsets, sizes, and types of local variables.
    """
    ident = (function_identifier or "").strip()
    params = {}
    # Choose param name based on identifier format
    if ident.lower().startswith("0x") or ident.isdigit():
        params["address"] = ident
    else:
        params["name"] = ident
    data = get_json("getStackFrameVars", params)
    if not data:
        return []
    if isinstance(data, dict) and data.get("error"):
        return []
    if isinstance(data, dict) and data.get("stack_frame_vars"):
        return data["stack_frame_vars"]
    return []


@mcp.tool()
def format_value(address: str, text: str, size: int = 0) -> list:
    """
    Convert and annotate a value at an address in Binary Ninja.
    Adds a comment with hex/dec and C literal/string so you can see the change.
    """
    return safe_get("formatValue", {"address": address, "text": text, "size": size}, timeout=None)


@mcp.tool()
def convert_number(text: str, size: int = 0) -> str:
    """
    Convert a number or string to multiple representations (hex/dec/bin, LE/BE, C char/string literals).
    Accepts decimal (e.g., 123), hex (0x7b or 7Bh), binary (0b1111011), octal (0o173),
    char ('A'), or string ("ABC" with escapes like \x41).
    """
    data = get_json("convertNumber", {"text": text, "size": size}, timeout=None)
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("error"):
        return f"Error: {data['error']}"
    import json as _json

    return _json.dumps(data, indent=2, ensure_ascii=False)


@mcp.tool()
def get_type_info(type_name: str) -> str:
    """
    Resolve a type name and return its declaration and details (kind, members, enum values).
    """
    data = get_json("getTypeInfo", {"name": type_name}, timeout=None)
    if not data:
        return "Error: no response"
    if "error" in data:
        return f"Error: {data.get('error')}"
    import json as _json

    return _json.dumps(data, indent=2, ensure_ascii=False)


@mcp.tool()
def set_function_prototype(name_or_address: str, prototype: str) -> str:
    """
    Set a function's prototype by name or address.
    """
    # Use GET like other endpoints (server accepts complex prototypes)
    ident = (name_or_address or "").strip()
    params = {"prototype": prototype}
    # Choose param name based on identifier format
    if ident.lower().startswith("0x") or ident.isdigit():
        params["address"] = ident
    else:
        params["name"] = ident
    data = get_json("setFunctionPrototype", params)
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and "status" in data:
        return f"Applied prototype at {data.get('address')}: {data.get('applied_type')}"
    if isinstance(data, dict) and "error" in data:
        return f"Error: {data['error']}"
    return str(data)


@mcp.tool()
def make_function_at(address: str, platform: str = "") -> str:
    """
    Create a function at the given address. Platform is optional (e.g., "linux-x86_64").
    Use "default" to explicitly select the BinaryView/platform default.
    Returns status and function info; no-op if the function already exists.
    """
    params = {"address": address}
    if platform:
        params["platform"] = platform
    data = get_json("makeFunctionAt", params)
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("error"):
        import json as _json

        return _json.dumps(data, indent=2, ensure_ascii=False)
    if isinstance(data, dict) and data.get("status") == "exists":
        return f"Function already exists at {data.get('address')}: {data.get('name')}"
    if isinstance(data, dict) and data.get("status") == "ok":
        return f"Created function at {data.get('address')}: {data.get('name')}"
    return str(data)


@mcp.tool()
def list_platforms() -> str:
    """
    List all available platform names from Binary Ninja.
    """
    data = get_json("platforms")
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("error"):
        import json as _json

        return _json.dumps(data, indent=2, ensure_ascii=False)
    plats = data.get("platforms") if isinstance(data, dict) else None
    if not plats:
        return "(no platforms)"
    return "\n".join(plats)


@mcp.tool()
def declare_c_type(c_declaration: str) -> str:
    """
    Create or update a local type from a C declaration.
    """
    data = get_json("declareCType", {"declaration": c_declaration})
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("defined_types"):
        names = ", ".join(data["defined_types"].keys())
        return f"Declared types ({data.get('count', 0)}): {names}"
    if isinstance(data, dict) and "error" in data:
        return f"Error: {data['error']}"
    return str(data)


@mcp.tool()
def set_local_variable_type(function_address: str, variable_name: str, new_type: str) -> str:
    """
    Set a local variable's type.
    """
    data = get_json(
        "setLocalVariableType",
        {
            "functionAddress": function_address,
            "variableName": variable_name,
            "newType": new_type,
        },
    )
    if not data:
        return "Error: no response"
    if isinstance(data, dict) and data.get("status") == "ok":
        return f"Retyped {data.get('variable')} in {data.get('function')} to {data.get('applied_type')}"
    if isinstance(data, dict) and "error" in data:
        return f"Error: {data['error']}"
    return str(data)


@mcp.tool()
def patch_bytes(address: str, data: str, save_to_file: bool = True) -> str:
    """
    Patch bytes at a given address in the binary.
    - address: Address to patch (hex string like "0x401000" or decimal)
    - data: Hex string of bytes to write (e.g., "90 90" or "9090" or "0x90 0x90")
    - save_to_file: If True (default), save patched binary to disk and re-sign on macOS.
                    If False, only modify in memory without affecting the original file.

    Returns status with original and patched bytes.
    On macOS, automatically re-signs the binary after patching to avoid execution errors.
    """
    # Handle boolean type conversion (MCP may pass as string)
    if isinstance(save_to_file, str):
        save_to_file = save_to_file.lower() not in ("false", "0", "no")

    params = {"address": address, "data": data, "save_to_file": save_to_file}
    result = get_json("patch", params)
    if not result:
        return "Error: no response"

    status = result.get("status") if isinstance(result, dict) else None
    if status in ("ok", "partial"):
        orig = result.get("original_bytes", "")
        patched = result.get("patched_bytes", "")
        written = result.get("bytes_written", 0)
        requested = result.get("bytes_requested", 0)
        addr = result.get("address", address)
        saved = result.get("saved_to_file", False)
        saved_path = result.get("saved_path", "")
        save_error = result.get("save_error", "")
        codesign = result.get("codesign", {})
        warning = result.get("warning", "")

        msg = f"Patched {written}/{requested} bytes at {addr}"
        if status == "partial":
            msg += " (PARTIAL WRITE)"
        if warning:
            msg += f"\nWarning: {warning}"
        if orig:
            msg += f"\nOriginal: {orig}"
        if patched:
            msg += f"\nPatched:  {patched}"
        if saved:
            msg += f"\nSaved to file: {saved_path}"
        elif save_error:
            msg += f"\nWarning: File not saved - {save_error}"

        # Show codesign status for macOS
        if codesign:
            if codesign.get("success"):
                msg += f"\nCode signing: {codesign.get('message', 'Re-signed successfully')}"
            elif codesign.get("attempted"):
                msg += f"\nCode signing: Failed - {codesign.get('error', 'Unknown error')}"

        return msg
    if isinstance(result, dict) and "error" in result:
        return f"Error: {result['error']}"
    return str(result)


if __name__ == "__main__":
    # Important: write any logs to stderr to avoid corrupting MCP stdio JSON-RPC
    print("Starting MCP bridge service...", file=_sys.stderr)
    try:
        mcp.run()
    except Exception as _e:
        # Ensure any runtime exception is captured in the log file
        _bridge_excepthook(type(_e), _e, _e.__traceback__)
        raise

```

`bridge/requirements.txt`:

```txt
anthropic>=0.49.0
mcp[cli]>=1.6.0
requests>=2.32.3

```

`docs_for_llms/bn_docs_index.html`:

```html

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentation for the Binary Ninja reverse engineering platform">
      
      
        <meta name="author" content="Vector 35 Inc">
      
      
        <link rel="canonical" href="https://docs.binary.ninja/dev/index.html">
      
      
        <link rel="prev" href="../guide/types/cpp.html">
      
      
        <link rel="next" href="cookbook.html">
      
      
      <link rel="icon" href="../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.17">
    
    
      
        <title>Using the Binary Ninja API - Binary Ninja User Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.bcfcd587.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
        <script src="../assets/external/unpkg.com/iframe-worker/shim.js"></script>
      
    
    
      
    
    
      <link rel="stylesheet" href="../docs.css">
    
      <link rel="stylesheet" href="../github.min.css">
    
      <link rel="stylesheet" href="../juxtapose.min.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: none; }
    .glightbox-clean .gslide-media {
        -webkit-box-shadow: none;
        box-shadow: none;
    }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="binja" data-md-color-primary="red" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#using-the-binary-ninja-api" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Binary Ninja User Documentation" class="md-header__button md-logo" aria-label="Binary Ninja User Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Binary Ninja User Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Using the Binary Ninja API
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="binja" data-md-color-primary="red" data-md-color-accent="red"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="red"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://binary.ninja/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    binary.ninja
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../getting-started.html" class="md-tabs__link">
          
  
    
  
  User Documentation

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="index.html" class="md-tabs__link">
          
  
    
  
  Developer Documentation

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../about/index.html" class="md-tabs__link">
          
  
    
  
  About

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Binary Ninja User Documentation" class="md-nav__button md-logo" aria-label="Binary Ninja User Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Binary Ninja User Documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://binary.ninja/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    binary.ninja
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    User Documentation
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            User Documentation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting-started.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting Started
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_2" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    User Guide
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_2" id="__nav_1_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_2">
            <span class="md-nav__icon md-icon"></span>
            User Guide
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/plugins.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Using Plugins
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/settings.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Settings
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/projects.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Projects
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/enterprise/index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Enterprise
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/troubleshooting.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Troubleshooting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/objectivec.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Objective-C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/firmwareninja.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Firmware Ninja
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/sharedcache.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Shared Cache
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/kernelcache.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Kernel Cache
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/efiresolver.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    EFI Resolver
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/warp.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    WARP
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/binexport.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BinExport / BinDiff
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/guided_analysis.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Guided Analysis
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/debugger/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Debugger
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_3" id="__nav_1_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_3">
            <span class="md-nav__icon md-icon"></span>
            Debugger
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/remote-debugging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Remote Debugging
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/dbgeng-ttd.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Time Travel Debugging (Windows)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/gdbrsp-ttd.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Time Travel Debugging (Linux)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/windows-kd.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Kernel Debugging (Windows)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/corellium-remote-debugging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Corellium Remote Debugging
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/migration/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Migration Guide
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_4" id="__nav_1_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_4">
            <span class="md-nav__icon md-icon"></span>
            Migration Guide
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/migration/migrationguideida.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Migrating from IDA
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/migration/migrationguideghidra.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Migrating from Ghidra
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/types/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Types
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_5" id="__nav_1_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_5">
            <span class="md-nav__icon md-icon"></span>
            Types
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/basictypes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Basic Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/type.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Working With Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/attributes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Attributes and Annotations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/typeimportexport.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Importing/Exporting Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/typearchives.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Archives
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/typelibraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Libraries
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/debuginfo.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Info
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/platformtypes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Platform Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/cpp.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++ Types
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="index.html" class="md-nav__link md-nav__link--active">
              
  
  <span class="md-ellipsis">
    Developer Documentation
  </span>
  

            </a>
            
              
              <label class="md-nav__link md-nav__link--active" for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Developer Documentation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="cookbook.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Cookbook
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="plugins.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Writing Plugins
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="batch.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Automation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    BNIL / Architectures
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            BNIL / Architectures
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-overview.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-llil.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; LLIL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-mlil.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; MLIL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-hlil.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; HLIL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="flags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Flag Guide
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-modifying.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Modifying ILs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Types
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            Types
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="annotation.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Applying Annotations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="typelibraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Libraries
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Important Concepts
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_7">
            <span class="md-nav__icon md-icon"></span>
            Important Concepts
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="concepts.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Important Concepts
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="uidf.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    User Informed Data Flow
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="workflows.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Workflows
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="themes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Creating Themes
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="documentation.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing Documentation
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../about/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    About
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            About
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/license.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    License
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/open-source.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Open Source
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/icons.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Icons
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#language-specific-bindings" class="md-nav__link">
    <span class="md-ellipsis">
      Language Specific Bindings
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Language Specific Bindings">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#python-api" class="md-nav__link">
    <span class="md-ellipsis">
      Python API
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core-api" class="md-nav__link">
    <span class="md-ellipsis">
      Core API
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-api" class="md-nav__link">
    <span class="md-ellipsis">
      C++ API
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rust-api" class="md-nav__link">
    <span class="md-ellipsis">
      Rust API
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="using-the-binary-ninja-api">Using the Binary Ninja API<a class="headerlink" href="#using-the-binary-ninja-api" title="Permanent link">&para;</a></h1>
<p>Welcome to the Binary Ninja API documentation. Much like the <a href="../guide/index.html">User Guide</a>, some larger sections have been split off into their own sections on the left, while the table of contents for this documentation is on the right.</p>
<h2 id="language-specific-bindings">Language Specific Bindings<a class="headerlink" href="#language-specific-bindings" title="Permanent link">&para;</a></h2>
<p>The Binary Ninja API is available through a <a href="#core-api">Core API</a>, through the <a href="#c-api">C++ API</a>, through a <a href="#python-api">Python API</a>, and a <a href="#rust-api">Rust API</a>.</p>
<h3 id="python-api">Python API<a class="headerlink" href="#python-api" title="Permanent link">&para;</a></h3>
<p>The Python API is the most common third-party API and is used in many <a href="https://github.com/vector35/community-plugins">public plugins</a>. Here's a list of the most important Python API documentation resources:</p>
<ul>
<li><a href="plugins.html">Writing Python Plugins</a></li>
<li><a href="annotation.html">Applying Annotations</a></li>
<li><a href="cookbook.html">Script Cookbook</a> with common examples and concepts explained</li>
<li><a href="https://api.binary.ninja/">Python API Reference</a> (available offline via the Help menu)</li>
<li><a href="https://github.com/Vector35/binaryninja-api/tree/dev/python">API Source</a></li>
</ul>
<h3 id="core-api">Core API<a class="headerlink" href="#core-api" title="Permanent link">&para;</a></h3>
<p>The Core API is designed to only be used as a shim from other languages and is not currently intended to be used to build C plugins directly.</p>
<ul>
<li><a href="https://github.com/Vector35/binaryninja-api/blob/dev/binaryninjacore.h">Header</a> (used by all other bindings)</li>
</ul>
<h3 id="c-api">C++ API<a class="headerlink" href="#c-api" title="Permanent link">&para;</a></h3>
<p>The C++ API is what the Binary Ninja UI itself is built using so it's a robust and fully feature-complete interface to the core, however, it does not have the same level of detail in the documentation.</p>
<ul>
<li><a href="https://github.com/Vector35/binaryninja-api/blob/dev/binaryninjaapi.h">C++ Header</a> (along with the rest of the <a href="https://github.com/Vector35/binaryninja-api">repository</a>)</li>
<li><a href="https://github.com/Vector35/binaryninja-api#building">Build Instructions</a></li>
<li><a href="https://api.binary.ninja/cpp/">C++ / UI API Documentation</a></li>
</ul>
<h3 id="rust-api">Rust API<a class="headerlink" href="#rust-api" title="Permanent link">&para;</a></h3>
<p>The Rust API is still experimental and lacks complete coverage for all core APIs. Documentation is available at:</p>
<ul>
<li><a href="https://dev-rust.binary.ninja/">Rust API</a></li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.expand", "navigation.indexes", "navigation.top", "content.code.copy", "search.highlight", "toc.follow"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.1e8ae164.min.js"></script>
      
        <script src="../highlight.min.js"></script>
      
        <script src="../cpp.min.js"></script>
      
        <script src="../python.min.js"></script>
      
        <script src="../juxtapose.min.js"></script>
      
    
  <script>document$.subscribe(() => {document.querySelectorAll('.glightbox').forEach(function(element) {
    var imgSrc = element.querySelector('img').src;
    element.setAttribute('href', imgSrc);
});
const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>
```

`docs_for_llms/bn_docs_plugins.html`:

```html

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentation for the Binary Ninja reverse engineering platform">
      
      
        <meta name="author" content="Vector 35 Inc">
      
      
        <link rel="canonical" href="https://docs.binary.ninja/dev/plugins.html">
      
      
        <link rel="prev" href="cookbook.html">
      
      
        <link rel="next" href="batch.html">
      
      
      <link rel="icon" href="../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.17">
    
    
      
        <title>Writing Plugins - Binary Ninja User Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.bcfcd587.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
        <script src="../assets/external/unpkg.com/iframe-worker/shim.js"></script>
      
    
    
      
    
    
      <link rel="stylesheet" href="../docs.css">
    
      <link rel="stylesheet" href="../github.min.css">
    
      <link rel="stylesheet" href="../juxtapose.min.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: none; }
    .glightbox-clean .gslide-media {
        -webkit-box-shadow: none;
        box-shadow: none;
    }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="binja" data-md-color-primary="red" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#writing-plugins" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Binary Ninja User Documentation" class="md-header__button md-logo" aria-label="Binary Ninja User Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Binary Ninja User Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Writing Plugins
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="binja" data-md-color-primary="red" data-md-color-accent="red"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="red" data-md-color-accent="red"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://binary.ninja/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    binary.ninja
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../getting-started.html" class="md-tabs__link">
          
  
    
  
  User Documentation

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="index.html" class="md-tabs__link">
          
  
    
  
  Developer Documentation

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../about/index.html" class="md-tabs__link">
          
  
    
  
  About

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Binary Ninja User Documentation" class="md-nav__button md-logo" aria-label="Binary Ninja User Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Binary Ninja User Documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://binary.ninja/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    binary.ninja
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    User Documentation
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            User Documentation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting-started.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting Started
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_2" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    User Guide
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_2" id="__nav_1_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_2">
            <span class="md-nav__icon md-icon"></span>
            User Guide
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/plugins.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Using Plugins
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/settings.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Settings
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/projects.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Projects
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/enterprise/index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Enterprise
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/troubleshooting.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Troubleshooting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/objectivec.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Objective-C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/firmwareninja.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Firmware Ninja
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/sharedcache.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Shared Cache
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/kernelcache.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Kernel Cache
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/efiresolver.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    EFI Resolver
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/warp.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    WARP
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/binexport.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BinExport / BinDiff
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/guided_analysis.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Guided Analysis
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/debugger/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Debugger
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_3" id="__nav_1_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_3">
            <span class="md-nav__icon md-icon"></span>
            Debugger
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/remote-debugging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Remote Debugging
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/dbgeng-ttd.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Time Travel Debugging (Windows)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/gdbrsp-ttd.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Time Travel Debugging (Linux)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/windows-kd.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Kernel Debugging (Windows)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/debugger/corellium-remote-debugging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Corellium Remote Debugging
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/migration/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Migration Guide
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_4" id="__nav_1_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_4">
            <span class="md-nav__icon md-icon"></span>
            Migration Guide
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/migration/migrationguideida.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Migrating from IDA
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/migration/migrationguideghidra.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Migrating from Ghidra
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../guide/types/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Types
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1_5" id="__nav_1_5_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_1_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1_5">
            <span class="md-nav__icon md-icon"></span>
            Types
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/basictypes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Basic Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/type.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Working With Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/attributes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Attributes and Annotations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/typeimportexport.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Importing/Exporting Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/typearchives.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Archives
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/typelibraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Libraries
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/debuginfo.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Info
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/platformtypes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Platform Types
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide/types/cpp.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++ Types
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Developer Documentation
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Developer Documentation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="cookbook.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Cookbook
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Writing Plugins
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="plugins.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Writing Plugins
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#writing-python-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      Writing Python Plugins
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Writing Python Plugins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#creating-the-plugin" class="md-nav__link">
    <span class="md-ellipsis">
      Creating the Plugin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#submitting-to-the-plugin-manager" class="md-nav__link">
    <span class="md-ellipsis">
      Submitting to the Plugin Manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-your-own-plugin-repository" class="md-nav__link">
    <span class="md-ellipsis">
      Using Your Own Plugin Repository
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testing" class="md-nav__link">
    <span class="md-ellipsis">
      Testing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#writing-plugins-using-other-ides-tab-completion" class="md-nav__link">
    <span class="md-ellipsis">
      Writing plugins using other IDEs (tab completion)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#debugging-using-other-ides" class="md-nav__link">
    <span class="md-ellipsis">
      Debugging using other IDEs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Debugging using other IDEs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#remote-debugging-with-vscode" class="md-nav__link">
    <span class="md-ellipsis">
      Remote debugging with VSCode:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remote-debugging-with-intellij-pycharm" class="md-nav__link">
    <span class="md-ellipsis">
      Remote debugging with IntelliJ PyCharm
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ui-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      UI Plugins
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#writing-native-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      Writing Native Plugins
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Writing Native Plugins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#supported-toolchains" class="md-nav__link">
    <span class="md-ellipsis">
      Supported Toolchains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cmake-setup" class="md-nav__link">
    <span class="md-ellipsis">
      CMake Setup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#project-setup" class="md-nav__link">
    <span class="md-ellipsis">
      Project Setup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#automated-github-ci" class="md-nav__link">
    <span class="md-ellipsis">
      Automated GitHub CI
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ui-plugins_1" class="md-nav__link">
    <span class="md-ellipsis">
      UI Plugins
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python-integration" class="md-nav__link">
    <span class="md-ellipsis">
      Python Integration
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ide-setup" class="md-nav__link">
    <span class="md-ellipsis">
      IDE Setup
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IDE Setup">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#clion" class="md-nav__link">
    <span class="md-ellipsis">
      CLion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#visual-studio-code" class="md-nav__link">
    <span class="md-ellipsis">
      Visual Studio Code
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#submitting-to-the-plugin-manager_1" class="md-nav__link">
    <span class="md-ellipsis">
      Submitting to the plugin manager
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#contributing-to-official-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      Contributing to Official Plugins
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="batch.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Automation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    BNIL / Architectures
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            BNIL / Architectures
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-overview.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-llil.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; LLIL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-mlil.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; MLIL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-hlil.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BNIL Guide&#58; HLIL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="flags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Flag Guide
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="bnil-modifying.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Modifying ILs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Types
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            Types
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="annotation.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Applying Annotations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="typelibraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Type Libraries
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Important Concepts
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_7">
            <span class="md-nav__icon md-icon"></span>
            Important Concepts
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="concepts.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Important Concepts
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="uidf.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    User Informed Data Flow
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="workflows.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Workflows
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="themes.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Creating Themes
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="documentation.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contributing Documentation
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../about/index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    About
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            About
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/license.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    License
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/open-source.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Open Source
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../about/icons.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Icons
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#writing-python-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      Writing Python Plugins
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Writing Python Plugins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#creating-the-plugin" class="md-nav__link">
    <span class="md-ellipsis">
      Creating the Plugin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#submitting-to-the-plugin-manager" class="md-nav__link">
    <span class="md-ellipsis">
      Submitting to the Plugin Manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-your-own-plugin-repository" class="md-nav__link">
    <span class="md-ellipsis">
      Using Your Own Plugin Repository
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testing" class="md-nav__link">
    <span class="md-ellipsis">
      Testing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#writing-plugins-using-other-ides-tab-completion" class="md-nav__link">
    <span class="md-ellipsis">
      Writing plugins using other IDEs (tab completion)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#debugging-using-other-ides" class="md-nav__link">
    <span class="md-ellipsis">
      Debugging using other IDEs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Debugging using other IDEs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#remote-debugging-with-vscode" class="md-nav__link">
    <span class="md-ellipsis">
      Remote debugging with VSCode:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remote-debugging-with-intellij-pycharm" class="md-nav__link">
    <span class="md-ellipsis">
      Remote debugging with IntelliJ PyCharm
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ui-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      UI Plugins
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#writing-native-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      Writing Native Plugins
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Writing Native Plugins">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#supported-toolchains" class="md-nav__link">
    <span class="md-ellipsis">
      Supported Toolchains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cmake-setup" class="md-nav__link">
    <span class="md-ellipsis">
      CMake Setup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#project-setup" class="md-nav__link">
    <span class="md-ellipsis">
      Project Setup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#automated-github-ci" class="md-nav__link">
    <span class="md-ellipsis">
      Automated GitHub CI
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ui-plugins_1" class="md-nav__link">
    <span class="md-ellipsis">
      UI Plugins
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python-integration" class="md-nav__link">
    <span class="md-ellipsis">
      Python Integration
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ide-setup" class="md-nav__link">
    <span class="md-ellipsis">
      IDE Setup
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IDE Setup">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#clion" class="md-nav__link">
    <span class="md-ellipsis">
      CLion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#visual-studio-code" class="md-nav__link">
    <span class="md-ellipsis">
      Visual Studio Code
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#submitting-to-the-plugin-manager_1" class="md-nav__link">
    <span class="md-ellipsis">
      Submitting to the plugin manager
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#contributing-to-official-plugins" class="md-nav__link">
    <span class="md-ellipsis">
      Contributing to Official Plugins
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="writing-plugins">Writing Plugins<a class="headerlink" href="#writing-plugins" title="Permanent link">&para;</a></h1>
<h2 id="writing-python-plugins">Writing Python Plugins<a class="headerlink" href="#writing-python-plugins" title="Permanent link">&para;</a></h2>
<h3 id="creating-the-plugin">Creating the Plugin<a class="headerlink" href="#creating-the-plugin" title="Permanent link">&para;</a></h3>
<p>First, take a look at some of the <a href="https://github.com/Vector35/binaryninja-api/tree/dev/python/examples">example</a> plugins, or some of the <a href="https://github.com/Vector35/community-plugins">community</a> plugins to get a feel for different APIs you might be interested in. Of course, the full <a href="https://api.binary.ninja/">API</a> docs are online and available offline via the <code>Help</code>/<code>Open Python API Reference...</code>.</p>
<p>To start, we suggest you download the <a href="https://github.com/Vector35/sample_plugin">sample plugin</a> as a template since it contains all of the elements you're likely to need.</p>
<ul>
<li>Begin by editing the <code>plugin.json</code> file</li>
<li>Next, update the <code>LICENSE</code></li>
<li>For small scripts, you can include all the code inside of <code>__init__.py</code>, though we recommend for most larger scripts that init just act as an initializer and call into functions organized appropriately in other files.</li>
<li>If you have python dependencies, create a <a href="https://pip.pypa.io/en/latest/cli/pip_freeze/">requirements.txt</a> listing any python dependencies.</li>
</ul>
<h3 id="submitting-to-the-plugin-manager">Submitting to the Plugin Manager<a class="headerlink" href="#submitting-to-the-plugin-manager" title="Permanent link">&para;</a></h3>
<p>If your plugin was created as described above, there's only two steps to get it submitted to the plugin manager!</p>
<ol>
<li>First, create a release either <a href="https://binary.ninja/2019/07/04/plugin-manager-2.0.html#5-create-a-release">manually</a> or using our <a href="https://github.com/Vector35/release_helper">release helper</a>.</li>
<li>Next, just <a href="https://github.com/Vector35/community-plugins/issues/new/choose">file an issue</a> letting us know about your plugin.</li>
</ol>
<p>For future releases all you need to do is increment the version and create a new release.</p>
<h3 id="using-your-own-plugin-repository">Using Your Own Plugin Repository<a class="headerlink" href="#using-your-own-plugin-repository" title="Permanent link">&para;</a></h3>
<p>The simplest way to run your own plugin repository is to duplicate the structure of <a href="https://github.com/vector35/community-plugins">https://github.com/vector35/community-plugins</a>. Specifically, the <a href="https://github.com/Vector35/community-plugins/blob/master/plugins.json">plugins.json</a>, as <a href="https://github.com/Vector35/community-plugins/blob/master/listing.json">listing.json</a> is used along with <a href="https://github.com/Vector35/community-plugins/blob/master/generate_index.py">generate_index.py</a> to create that file.</p>
<p>Once you've created your test repository, use the <code>pluginManager.unofficialName</code> and <code>pluginManager.unofficialUrl</code> settings to add your third-party repository.</p>
<p>The <a href="https://api.binary.ninja/binaryninja.pluginmanager-module.html#binaryninja.pluginmanager.RepositoryManager.add_repository"><code>add_repository</code></a> API can also be used to add the repository, though it <a href="https://github.com/Vector35/binaryninja-api/issues/2987">may require manual creation of the repository folder</a>.</p>
<h3 id="testing">Testing<a class="headerlink" href="#testing" title="Permanent link">&para;</a></h3>
<p>It's useful to be able to reload your plugin during testing. On the Commercial or Ultimate editions of Binary Ninja, this is easily accomplished with a stand-alone headless install using <code>import binaryninja</code> after <a href="https://github.com/Vector35/binaryninja-api/blob/dev/scripts/install_api.py">installing the API</a>.  (install_api.py is included in each platforms respective <a href="../guide/index.html#binary-path">installation folder</a>)</p>
<p>Additionally, some plugin types like Architectures or BinaryViews are only loaded at launch and cannot be reloaded during a running session.</p>
<p>For other plugins, we recommend the following workflow from the scripting console which enables easy iteration and testing:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">pluginname</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">pluginname</span><span class="p">);</span><span class="n">pluginname</span><span class="o">.</span><span class="n">callbackmethod</span><span class="p">(</span><span class="n">bv</span><span class="p">)</span>
</code></pre></div>
<p>Then just <code>[UP] [ENTER]</code> to trigger the reload when the plugin has changed.</p>
<h2 id="writing-plugins-using-other-ides-tab-completion">Writing plugins using other IDEs (tab completion)<a class="headerlink" href="#writing-plugins-using-other-ides-tab-completion" title="Permanent link">&para;</a></h2>
<p>Even though non-commercial licenses don't have headless automation, the <a href="https://github.com/Vector35/binaryninja-api/blob/dev/scripts/install_api.py">install API</a> script (which is included in the installation directory) allows you to add the binaryninja module to your python environment. Once you do that, you should get automatic completion in any editor that supports it even on non-commercial! Of course, on Commercial and Ultimate installations, the script is even more useful, allowing for headless scripts with your existing python interpreter.</p>
<h2 id="debugging-using-other-ides">Debugging using other IDEs<a class="headerlink" href="#debugging-using-other-ides" title="Permanent link">&para;</a></h2>
<p>If you wish to debug your python scripts, there are a few methods specific to different IDEs:</p>
<h3 id="remote-debugging-with-vscode">Remote debugging with VSCode:<a class="headerlink" href="#remote-debugging-with-vscode" title="Permanent link">&para;</a></h3>
<ol>
<li>Run <code>pip install --user debugpy</code> in the Python interpreter you have selected in Binary Ninja Settings.</li>
<li>In VSCode, open the Run and Debug sidebar.</li>
<li>Create a <code>launch.json</code> file if one does not already exist, or open <code>launch.json</code> if one does.</li>
<li>In <code>launch.json</code>, select Add Configuration &gt; Python &gt; Remote Attach</li>
<li>Enter a host of <code>localhost</code> and any port</li>
<li>Set the path mapping to be from <code>/</code> to <code>/</code> (Windows: <code>C:\\</code> to <code>C:\\</code>)</li>
<li>Open Binary Ninja</li>
<li>Use <code>connect_vscode_debugger(port=12345)</code> in the Python Console, using whichever port you selected in <code>launch.json</code>.</li>
<li>In VSCode, start debugging. You should see the bottom toolbar change color, and the debugger should be attached.</li>
</ol>
<h3 id="remote-debugging-with-intellij-pycharm">Remote debugging with IntelliJ PyCharm<a class="headerlink" href="#remote-debugging-with-intellij-pycharm" title="Permanent link">&para;</a></h3>
<p><strong>WARNING</strong>: Does not work on PyCharm Community, requires PyCharm Professional</p>
<ol>
<li>In PyCharm, add a Run Configuration for Python Debug Server. Give it a name and choose a port and host.</li>
<li>Run the <code>pip install</code> script displayed in the Run Configuration using whichever python interpreter you have selected for Binary Ninja.</li>
<li>In PyCharm, start debugging. You should see "Waiting for process connection..." in the Debugger panel.</li>
<li>Open Binary Ninja</li>
<li>Use <code>connect_pycharm_debugger(port=12345)</code> in the Python Console, using whichever port you selected in the Run Configuration. You should now see "Connected" in the PyCharm Debugger panel.</li>
</ol>
<h2 id="ui-plugins">UI Plugins<a class="headerlink" href="#ui-plugins" title="Permanent link">&para;</a></h2>
<p>Binary Ninja UI plugins should always <code>import binaryninjaui</code> before an <code>import PySide6</code>. Not only does this make sure the correct PySide6 is loaded (running the wrong version of PySide6 can result in crashing), but this <a href="https://github.com/Vector35/binaryninja-api/commit/55cb3e76f536bc8d4a6533bd7ea5202d464c5f81">prevents plugins</a> from running headlessly.</p>
<p>UI plugins can take many forms. Some, like <a href="https://github.com/vector35/snippets">Snippets</a> create their own UI elements and interact via UIActions. Others extend the UI via existing UI elements such as <a href="https://github.com/Vector35/binaryninja-api/tree/dev/python/examples/triage">Triage</a>, <a href="https://github.com/Vector35/kaitai">Kaitai</a>, <a href="https://github.com/Vector35/binaryninja-api/blob/dev/python/examples/hellosidebar.py">hellosidebar</a>, or <a href="https://github.com/Vector35/binaryninja-api/blob/dev/python/examples/helloglobalarea.py">helloglobalarea</a>.</p>
<p>Many other <a href="https://github.com/vector35/community-plugins/">third-party</a> plugins also implement UI based examples, such as <a href="https://github.com/withzombies/bnil-graph">BNIL Graph</a> using the FlowGraph APIs. </p>
<p>Unfortunately, due to a PySide documentation generation issue, the best and most reliable documentation on the UI system is not in the regular <a href="https://api.binary.ninja/">python</a> API docs, but in the <a href="https://api.binary.ninja/cpp/">C++ documentation</a> which translates fairly cleanly to their python equivalent.</p>
<h2 id="writing-native-plugins">Writing Native Plugins<a class="headerlink" href="#writing-native-plugins" title="Permanent link">&para;</a></h2>
<p>Writing native plugins allows for higher performance code and lower level access to the Binary Ninja API, but comes with a couple more hurdles than Python. 
Notably, native plugins are built against a specific version of the API, cannot be hot-reloaded, and require more sophisticated build setups.</p>
<h3 id="supported-toolchains">Supported Toolchains<a class="headerlink" href="#supported-toolchains" title="Permanent link">&para;</a></h3>
<p>When building native plugins for Binary Ninja, the following toolchains and dependencies are required, based on host OS.
Older versions may work but are not supported.</p>
<ul>
<li>macOS: Xcode 15 or Command Line Tools for macOS 14 (Apple Clang 15.0.0)</li>
<li>Windows: VS 2022 Professional with C/C++ Native Tools package, v143 (14.34)</li>
<li>Linux: GCC 11.4+</li>
</ul>
<p>Additionally, Binary Ninja uses C++20 features, and requires a C++20 compatible compiler.</p>
<h3 id="cmake-setup">CMake Setup<a class="headerlink" href="#cmake-setup" title="Permanent link">&para;</a></h3>
<p>Binary Ninja uses the <a href="https://cmake.org/">CMake</a> build system generator to compile native code, and provides
convenient helper scripts for those making plugins. As of writing, CMake 3.13 or greater is required,
although it is recommended to use the latest version.</p>
<h3 id="project-setup">Project Setup<a class="headerlink" href="#project-setup" title="Permanent link">&para;</a></h3>
<p>The first things to specify in your CMake file are a couple boilerplate options for building C++:  </p>
<div class="codehilite"><pre><span></span><code><span class="c"># Pick whatever version you have</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.24</span><span class="p">)</span>

<span class="c"># Name your plugin</span>
<span class="nb">project</span><span class="p">(</span><span class="s">TestPlugin</span><span class="w"> </span><span class="s">CXX</span><span class="p">)</span>

<span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span><span class="w"> </span><span class="s">20</span><span class="p">)</span>

<span class="c"># Unless you are writing a plugin that needs Qt&#39;s UI, specify this</span>
<span class="nb">set</span><span class="p">(</span><span class="s">HEADLESS</span><span class="w"> </span><span class="s">1</span><span class="p">)</span>
</code></pre></div>

<p>Then you want to get the matching API repository for the version of Binary Ninja you have.
This information is contained in a file named <code>api_REVISION.txt</code> that exists in the root install folder for Linux,
the <code>Contents/Resources</code> sub-folder on macOS, and the root installation folder on Windows.</p>
<p>Once you know which revision to use, you can clone a copy of the binaryninja-api repository
and reference it directly in your plugin. If you're using git, this can be accomplished easily using a submodule:</p>
<div class="codehilite"><pre><span></span><code>git submodule add https://github.com/Vector35/binaryninja-api.git binaryninjaapi
cd binaryninjaapi
<span class="gh">#</span> Pick the revision from api_REVISION.txt
git checkout 6466fba3341b2ea7dbfceeeebbc6c0322a5d8514
</code></pre></div>

<p>If you're not using git, you can clone the repository elsewhere:</p>
<div class="codehilite"><pre><span></span><code>git clone https://github.com/Vector35/binaryninja-api.git binaryninjaapi
cd binaryninjaapi 
<span class="gh">#</span> Pick the revision from api_REVISION.txt
git checkout 6466fba3341b2ea7dbfceeeebbc6c0322a5d8514
</code></pre></div>

<p>Now that you have the correct copy of the api, you need to point CMake at it and include it for use.
Include something like the following in your CMake script and either add the path of your clone
to the HINTS list or set the BN_API_PATH environment variable to the location of your clone</p>
<div class="codehilite"><pre><span></span><code>find_path(
<span class="w">    </span>BN_API_PATH
<span class="w">    </span>NAMES<span class="w"> </span>binaryninjaapi.h
<span class="w">    </span>#<span class="w"> </span>List<span class="w"> </span>of<span class="w"> </span>paths<span class="w"> </span>to<span class="w"> </span>search<span class="w"> </span>for<span class="w"> </span>the<span class="w"> </span>clone<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>api
<span class="w">    </span>HINTS<span class="w"> </span>../..<span class="w"> </span>binaryninjaapi<span class="w"> </span><span class="nv">$ENV</span>{BN_API_PATH}
<span class="w">    </span>REQUIRED
)
add_subdirectory(<span class="cp">${</span><span class="n">BN_API_PATH</span><span class="cp">}</span><span class="w"> </span>api)
</code></pre></div>

<p>Be sure to create a shared library and link against the Binary Ninja api. Also, you can use the
<code>bn_install_plugin</code> helper to automatically set up your plugin to install to the Binary Ninja plugins directory
when you use <code>cmake install</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Use</span><span class="w"> </span><span class="nx">whichever</span><span class="w"> </span><span class="nx">sources</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">plugin</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">you</span><span class="w"> </span><span class="nx">want</span>
<span class="nx">add_library</span><span class="p">(</span><span class="nx">TestPlugin</span><span class="w"> </span><span class="nx">SHARED</span><span class="w"> </span><span class="nx">TestPlugin</span><span class="p">.</span><span class="nx">cpp</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Link</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">Binary</span><span class="w"> </span><span class="nx">Ninja</span>
<span class="nx">target_link_libraries</span><span class="p">(</span><span class="nx">TestPlugin</span><span class="w"> </span><span class="nx">PUBLIC</span><span class="w"> </span><span class="nx">binaryninjaapi</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Tell</span><span class="w"> </span><span class="err">`</span><span class="nx">cmake</span><span class="w"> </span><span class="o">--</span><span class="nx">install</span><span class="err">`</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">copy</span><span class="w"> </span><span class="nx">your</span><span class="w"> </span><span class="nx">plugin</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">plugins</span><span class="w"> </span><span class="nx">directory</span>
<span class="nx">bn_install_plugin</span><span class="p">(</span><span class="nx">TestPlugin</span><span class="p">)</span>
</code></pre></div>

<p>From there you can write the rest of your plugin's CMake configuration, including any other dependencies or
options that you want. When you want to run your plugin, you can use <code>cmake --build</code> and <code>cmake --install</code>
to compile and copy your plugin to your Binary Ninja plugins directory, or set up an IDE to do that for you.
You could also copy the plugin manually if you are using a different plugins directory location. </p>
<p>In the source code of your plugin, you will need to export some functions that Binary Ninja uses to load your plugin
at runtime:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">#include &quot;binaryninjaapi.h&quot;</span>
<span class="n">extern</span><span class="w"> </span><span class="s2">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Tells</span><span class="w"> </span><span class="n">Binary</span><span class="w"> </span><span class="n">Ninja</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">API</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="n">against</span>
<span class="w">    </span><span class="n">BN_DECLARE_CORE_ABI_VERSION</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="n">startup</span><span class="p">,</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">simple</span><span class="w"> </span><span class="n">initialization</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">(</span><span class="n">Settings</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryViewTypes</span><span class="p">,</span><span class="w"> </span><span class="n">etc</span><span class="p">)</span>
<span class="w">    </span><span class="n">BINARYNINJAPLUGIN</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">CorePluginInit</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="bp">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="n">Optional</span><span class="p">)</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="n">dependencies</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">case</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="n">them</span>
<span class="w">    </span><span class="n">BINARYNINJAPLUGIN</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">CorePluginDependencies</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">require</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">x86</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">loaded</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">plugin</span>
<span class="w">        </span><span class="n">AddRequiredPluginDependency</span><span class="p">(</span><span class="s2">&quot;arch_x86&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>From there, you can implement your plugin functionality as you desire. I highly recommend looking at other plugins for
API usage since the C++ API is less well-documented than the Python API. Usually the functions and classes are named
identically, but you may find some outliers. Also, C++ has a way more difficult task of managing memory, since there is
no garbage collector to handle it for you. Generally speaking, most API objects are reference-counted via the <code>Ref&lt;T&gt;</code>
class, and you should only ever handle Refs or bare pointers. When in doubt, feel free to ask on
<a href="https://binaryninja.slack.com/">our Slack</a> and both our team and helpful community can assist.</p>
<h3 id="automated-github-ci">Automated GitHub CI<a class="headerlink" href="#automated-github-ci" title="Permanent link">&para;</a></h3>
<p>Managing build infrastructure to build cross-platform native plugins can be a headache even for stables, let alone 
trying to track all dev releases. To help with that, we've published an <a href="https://github.com/Vector35/sample_plugin_cpp">example plugin</a> that includes GitHub
actions to build on MacOS, Linux, and Windows. Combining this with something like a <a href="https://github.com/rikodot/binja_native_sigscan_loader">plugin loader</a> can simplify
both publishing and using native plugins.</p>
<h3 id="ui-plugins_1">UI Plugins<a class="headerlink" href="#ui-plugins_1" title="Permanent link">&para;</a></h3>
<p>If you want to include a UI in your plugin, you can integrate with Binary Ninja's Qt-based UI by linking with Qt and <code>binaryninjaui</code>.
You will need to use the same version of Qt as Binary Ninja. We provide steps for building it <a href="../about/open-source.html#building-qt">here</a>,
or you can attempt to use a system-provided copy if you use Linux and like to live dangerously.
Building it is a bit of a process, but should provide you with a working installation. Once you have a Qt build,
you can amend your CMake file to make a UI plugin. You will need the following CMake:</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Remove</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nx">set</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">0</span>
<span class="err">#</span><span class="w"> </span><span class="nx">set</span><span class="p">(</span><span class="nx">HEADLESS</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">If</span><span class="w"> </span><span class="nx">you</span><span class="w"> </span><span class="nx">are</span><span class="w"> </span><span class="nx">using</span><span class="w"> </span><span class="nx">Qt</span><span class="w"> </span><span class="nx">MOC</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">Q_OBJECT</span><span class="o">/</span><span class="nx">Q_SIGNALS</span><span class="o">/</span><span class="nx">Q_SLOTS</span><span class="p">)</span>
<span class="nx">set</span><span class="p">(</span><span class="nx">CMAKE_AUTOMOC</span><span class="w"> </span><span class="nx">ON</span><span class="p">)</span>
<span class="nx">set</span><span class="p">(</span><span class="nx">CMAKE_AUTORCC</span><span class="w"> </span><span class="nx">ON</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Locate</span><span class="w"> </span><span class="nx">Qt</span><span class="w"> </span><span class="nx">installation</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">linking</span>
<span class="nx">find_package</span><span class="p">(</span><span class="nx">Qt6</span><span class="w"> </span><span class="nx">COMPONENTS</span><span class="w"> </span><span class="nx">Core</span><span class="w"> </span><span class="nx">Gui</span><span class="w"> </span><span class="nx">Widgets</span><span class="w"> </span><span class="nx">REQUIRED</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Add</span><span class="w"> </span><span class="nx">MOCS</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">your</span><span class="w"> </span><span class="nx">build</span>
<span class="nx">add_library</span><span class="p">(</span><span class="nx">TestPlugin</span><span class="w"> </span><span class="nx">SHARED</span><span class="w"> </span><span class="kn">library</span><span class="p">.</span><span class="nx">cpp</span><span class="w"> </span><span class="err">$</span><span class="p">{</span><span class="nx">MOCS</span><span class="p">})</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Link</span><span class="w"> </span><span class="nx">against</span><span class="w"> </span><span class="nx">both</span><span class="w"> </span><span class="nx">binaryninjaapi</span><span class="o">/</span><span class="nx">binaryninjaui</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">Qt6</span>
<span class="nx">target_link_libraries</span><span class="p">(</span><span class="nx">TestPlugin</span><span class="w"> </span><span class="nx">PUBLIC</span><span class="w"> </span><span class="nx">binaryninjaapi</span><span class="w"> </span><span class="nx">binaryninjaui</span><span class="w"> </span><span class="nx">Qt6</span><span class="o">::</span><span class="nx">Core</span><span class="w"> </span><span class="nx">Qt6</span><span class="o">::</span><span class="nx">Gui</span><span class="w"> </span><span class="nx">Qt6</span><span class="o">::</span><span class="nx">Widgets</span><span class="p">)</span>
</code></pre></div>

<p>Then, in your plugin code, instead of using the exported functions for a core plugin, use the ones for a UI plugin:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">#include &quot;binaryninjaapi.h&quot;</span>
<span class="c1">#include &quot;uitypes.h&quot;</span>
<span class="c1">#include &quot;uicontext.h&quot;</span>

<span class="n">extern</span><span class="w"> </span><span class="s2">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Tells</span><span class="w"> </span><span class="n">Binary</span><span class="w"> </span><span class="n">Ninja</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">API</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="n">against</span>
<span class="w">    </span><span class="n">BN_DECLARE_UI_ABI_VERSION</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="n">startup</span><span class="p">,</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">simple</span><span class="w"> </span><span class="n">initialization</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">(</span><span class="n">ViewTypes</span><span class="p">,</span><span class="w"> </span><span class="n">SidebarWidgetTypes</span><span class="p">,</span><span class="w"> </span><span class="n">etc</span><span class="p">)</span>
<span class="w">    </span><span class="n">BINARYNINJAPLUGIN</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">UIPluginInit</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="bp">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="n">Optional</span><span class="p">)</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="n">dependencies</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">case</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">plugin</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="n">them</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Historically</span><span class="p">,</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">never</span><span class="w"> </span><span class="n">actually</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">used</span><span class="w"> </span>
<span class="w">    </span><span class="n">BINARYNINJAPLUGIN</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">UIPluginDependencies</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">require</span><span class="w"> </span><span class="n">triage</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">loaded</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">plugin</span>
<span class="w">        </span><span class="n">AddRequiredUIPluginDependency</span><span class="p">(</span><span class="s2">&quot;triage&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>From there, you can implement whatever wacky Qt user interfaces you dream up. Be warned that the Binary Ninja UI API is
rather poorly documented and often missing helper functions for use by plugins. Feel free to ask for assistance and
suggestions, but know that it's very easy to run into memory bugs when working with Qt. I would recommend looking at
the source to <a href="https://github.com/vector35/debugger">the debugger</a>, as an example of the largest, best-maintained UI
plugin for Binary Ninja.</p>
<h3 id="python-integration">Python Integration<a class="headerlink" href="#python-integration" title="Permanent link">&para;</a></h3>
<p>If you want your C++ plugin to also support a Python API, you will have a lot of work to do. Generally speaking, there
are no cookie-cutter solutions to this problem, but there is a general strategy:</p>
<ol>
<li>Expose a C API from your plugin</li>
<li>Provide a set of Python bindings to that C API</li>
<li>Load those Python bindings as a Python plugin in Binary Ninja</li>
</ol>
<p>Again, I'm going to point out <a href="https://github.com/vector35/debugger">the debugger</a> as a fantastic example of how to
implement this. Generally speaking, you will either need to write both sides of the FFI in a similar way, or you may
be able to find a library that does that for you. Possibly <a href="https://sourceware.org/libffi/">libffi</a>, although there 
aren't any examples of using it for Binary Ninja specifically. If you manage to get something working, let us know!
We would love to see more complex plugins with extensible behavior! </p>
<h2 id="ide-setup">IDE Setup<a class="headerlink" href="#ide-setup" title="Permanent link">&para;</a></h2>
<h3 id="clion">CLion<a class="headerlink" href="#clion" title="Permanent link">&para;</a></h3>
<p>CLion is generally pretty good at handling CMake projects. Given the above CMake configuration, it can
automatically detect the plugin target and will compile and install correctly. Here are a a few steps to finish
setup for building and live debugging your plugin:</p>
<ol>
<li>If you installed Binary Ninja somewhere other than the default, add an environment variable in your CMake Profile pointing at the installation, e.g.: <code>BN_INSTALL_DIR=/Applications/Binary Ninja.app</code></li>
<li>If you are writing a UI plugin, you will need to include the directory containing <code>qmake</code> to the <code>PATH</code> Environment Variable in your CMake Profile, e.g.: <code>PATH=/usr/bin:/bin:/usr/sbin:/sbin:/Users/user/Qt/6.8.2/clang_64/bin</code></li>
<li>In your Run Configuration's Before Launch steps, add an Install step. This will copy the updated version of your plugin before starting, so you don't have to run Install manually.</li>
<li>Set the Executable of your Run Configuration to point to the Binary Ninja executable. This allows you to compile your plugin and start Binary Ninja automatically.
   i. On macOS, you will need the full path to /Applications/Binary Ninja.app/Contents/MacOS/binaryninja</li>
<li>(Optionally) Add the <code>-e</code> flag to the Program Arguments to get error logs printed to your console </li>
<li>(Optionally) Add the <code>-e -d</code> flags to the Program Arguments to get debug logs printed to your console. This may slow down Binary Ninja (and CLion) due to the large volume of logs produced.</li>
<li>(Optionally) Add the <code>-l /tmp/bn_out.txt</code> flags to the Program Arguments so your logs also get printed to a text file when you inevitably fill up the Console buffer in CLion and want to see what happened.</li>
<li>(Optionally on macOS) Add the Environment Variables <code>MallocScribble=1</code> and <code>MallocPreScribble=1</code> to make memory errors easier to spot.</li>
</ol>
<h3 id="visual-studio-code">Visual Studio Code<a class="headerlink" href="#visual-studio-code" title="Permanent link">&para;</a></h3>
<p>VSCode takes a bit of configuration to set up, but can build and debug plugins efficiently once ready.
You can install the C/C++ extension, the CMake extension, and the CMake Tools extension.
You need to set up a task in <code>.vscode/tasks.json</code> to build and install your plugin. Something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// tasks.json</span>
<span class="p">{</span>
<span class="w">    </span><span class="s">&quot;version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;2.0.0&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;tasks&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="s">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;cmake&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;label&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;CMake: install&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;command&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;install&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;problemMatcher&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">            </span><span class="s">&quot;detail&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;CMake template install task&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;options&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="s">&quot;environment&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// You will need this if your Binary Ninja installation is not in the default location   </span>
<span class="w">                    </span><span class="s">&quot;BN_INSTALL_DIR&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;C:\\Users\\User\\AppData\\Local\\Vector35\\BinaryNinja&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="c1">// You will need this if you are writing a UI plugin</span>
<span class="w">                    </span><span class="s">&quot;PATH&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;C:\\Users\\User\\Qt\\6.8.2\\msvc2019_64\\bin&quot;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<p>You will also want to set up a launch task in <code>.vscode/launch.json</code> to launch Binary Ninja in a debugger,
so you can debug your plugin.
Be sure to set <code>"preLaunchTask"</code> to use the <code>CMake: install</code> task created above, so your code updates will be
built and installed automatically before you start debugging.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// launch.json</span>
<span class="p">{</span>
<span class="w">    </span><span class="s">&quot;version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;0.2.0&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;configurations&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="s">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;(Windows) Launch&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;cppvsdbg&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;request&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;launch&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;program&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;C:\\Users\\User\\AppData\\Local\\Vector35\\BinaryNinja\\binaryninja.exe&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;args&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">            </span><span class="s">&quot;stopAtEntry&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;cwd&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;C:\\Users\\User\\AppData\\Local\\Vector35\\BinaryNinja&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;environment&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">            </span><span class="s">&quot;console&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;externalTerminal&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;preLaunchTask&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;CMake: install&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<p>There are a few other options you can use to assist in debugging:</p>
<ol>
<li>(Optionally) Add the <code>"-e"</code> flag to the launch configuration's <code>args</code> to get error logs printed to your console</li>
<li>(Optionally) Add the <code>"-e", "-d"</code> flags to the launch configuration's <code>args</code> to get debug logs printed to your console. This may slow down Binary Ninja (and VSCode) due to the large volume of logs produced.</li>
<li>(Optionally) Add the <code>"-l", "/tmp/bn_out.txt"</code> flags to the launch configuration's <code>args</code> so your logs also get printed to a text file when you inevitably fill up the Console buffer and want to see what happened.</li>
<li>(Optionally on macOS) Add the environment variables <code>{ "name": "MallocScribble", "value": "1" }</code> and <code>{ "name": "MallocPreScribble", "value": "1" }</code> to make memory errors easier to spot.</li>
</ol>
<p>As a footnote, it should be noted that most of the team at Vector 35 use VSCode as a bare text editor
and use command-line lldb or gdb to debug their code. Shout-outs to people trying to get this working in Vim.</p>
<h2 id="submitting-to-the-plugin-manager_1">Submitting to the plugin manager<a class="headerlink" href="#submitting-to-the-plugin-manager_1" title="Permanent link">&para;</a></h2>
<p>While native plugins are not fully supported in the plugin manager at this time, it's possible to work around this limitation by pre-building a native plugin for all three platforms and using a python plugin that acts as a loader for the native plugin. Additionally, you can submit a plugin as "view_only" which helps with discoverability.</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<p>Several native plugin examples exist:</p>
<ul>
<li><a href="https://github.com/Vector35/binaryninja-api/tree/dev/examples/triage">Triage</a></li>
<li><a href="https://github.com/Vector35/debugger">Debugger</a></li>
<li><a href="https://github.com/jonpalmisc/ObjectiveNinja">ObjectiveNinja</a></li>
<li><a href="https://github.com/vector35/binexport#binary-ninja">BinExport</a> (Used with BinDiff)</li>
<li><a href="https://github.com/holmesmr/binliner">Binliner</a></li>
</ul>
<h2 id="contributing-to-official-plugins">Contributing to Official Plugins<a class="headerlink" href="#contributing-to-official-plugins" title="Permanent link">&para;</a></h2>
<p>There are many many official plugins released as open source. Python ones are included in the <a href="https://github.com/vector35/official-plugins">official plugin repository</a>, <a href="https://github.com/vector35/?q=arch-&amp;type=all&amp;language=&amp;sort=">native architectures</a> are available on GitHub along with several others that are included with the default product such as the <a href="https://github.com/Vector35/debugger">debugger</a>, the <a href="https://github.com/vector35/?q=view-&amp;type=public&amp;language=&amp;sort=">views</a>, <a href="https://github.com/vector35/?q=platform&amp;type=public&amp;language=&amp;sort=">platforms</a>, and some <a href="https://github.com/Vector35/binaryninja-api/tree/dev/rust/examples">rust plugins</a>.</p>
<p>The first time you contribute, you'll be asked to sign a <a href="https://gist.github.com/psifertex/a207c2e070f4e342554dc011e920b341">CLA</a> automatically by <a href="https://cla-assistant.io/">cla-assistant</a>. Further commits after the first should not require any changes.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.expand", "navigation.indexes", "navigation.top", "content.code.copy", "search.highlight", "toc.follow"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.1e8ae164.min.js"></script>
      
        <script src="../highlight.min.js"></script>
      
        <script src="../cpp.min.js"></script>
      
        <script src="../python.min.js"></script>
      
        <script src="../juxtapose.min.js"></script>
      
    
  <script>document$.subscribe(() => {document.querySelectorAll('.glightbox').forEach(function(element) {
    var imgSrc = element.querySelector('img').src;
    element.setAttribute('href', imgSrc);
});
const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>
```

`example/chal.c`:

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

static inline uint8_t rol8(uint8_t x, unsigned r) {
    r &= 7;
    return (uint8_t)(((x << r) | (x >> (8 - r))) & 0xFF);
}

// 對輸入做位移 + 滾動 XOR 的目標結果（作者預先計算好）
// Shift + rolling XOR applied to the input with the target result
static const uint8_t EXPECTED[32] = {
    0x1c, 0x2e, 0x74, 0xd0, 0x52, 0xe2, 0xd4, 0x86,
    0x0e, 0xa6, 0xec, 0x39, 0x75, 0x21, 0x17, 0x8d,
    0x13, 0x68, 0x88, 0xe2, 0x00, 0xa0, 0x11, 0x17,
    0x3f, 0x60, 0x90, 0x51, 0xb3, 0x68, 0x00, 0x02
};

int main(void) {
    char buf[256];
    puts("Enter flag:");
    if (!fgets(buf, sizeof(buf), stdin)) {
        puts("Read error");
        return 1;
    }

    // 去除換行
    size_t n = strcspn(buf, "\r\n");
    buf[n] = '\0';

    // 簡單長度與格式檢查（避免垃圾輸入）
    if (n != 32 || strncmp(buf, "FLAG{", 5) != 0 || buf[n-1] != '}') {
        puts("Nope");
        return 1;
    }

    // 轉換並比對
    uint8_t acc[32];
    for (size_t i = 0; i < n; i++) {
        uint8_t b = (uint8_t)buf[i];
        b ^= (uint8_t)(0x5A + i);
        b = rol8(b, (unsigned)(i & 7));
        acc[i] = b;
    }

    if (memcmp(acc, EXPECTED, 32) == 0) {
        puts("Correct! 🎉");
        return 0;
    } else {
        puts("Nope");
        return 1;
    }
}


```

`plugin.json`:

```json
{
    "pluginmetadataversion": 2,
    "name": "Binary Ninja MCP",
    "author": "fosdickio, CX330Blake",
    "type": ["core", "binaryview", "architecture", "helper"],
    "api": ["python3"],
    "description": "A Binary Ninja extension that provides a MCP (Model Context Protocol) server with HTTP endpoints for LLM integration.",
    "longdescription": "",
    "license": {
        "name": "GPL-3.0",
        "text": "Copyright 2025 fosdickio, CX330Blake\n\nThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>."
    },
    "platforms": ["Darwin", "Windows", "Linux"],
    "installinstructions": {
        "Darwin": "See https://github.com/fosdickio/binary_ninja_mcp",
        "Windows": "See https://github.com/fosdickio/binary_ninja_mcp",
        "Linux": "See https://github.com/fosdickio/binary_ninja_mcp"
    },
    "version": "1.1.0",
    "minimumbinaryninjaversion": 4000
}

```

`plugin/__init__.py`:

```py
import binaryninja as bn
from binaryninja import Settings

from .core.config import Config
from .server.http_server import MCPServer

# When true, suppress auto-start while a BinaryView is open until the user
# explicitly starts the server again. This prevents immediate re-start after stop.
_mcp_user_stopped = False


class BinaryNinjaMCP:
    def __init__(self):
        self.config = Config()
        self.server = MCPServer(self.config)

    def start_server(self, bv):
        try:
            # Require an active BinaryView (match menu behavior)
            if bv is None:
                bn.log_debug("MCP Max start requested but no BinaryView is active; deferring")
                _show_no_bv_popup()
                return
            # Avoid duplicate starts
            if self.server and self.server.server:
                bn.log_info("MCP Max server already running; skip new start")
                # Ensure BV is set if not already
                if self.server.binary_ops.current_view is None:
                    self.server.binary_ops.current_view = bv
                else:
                    # Register any newly seen view even if server is already running
                    try:
                        self.server.binary_ops.register_view(bv)
                    except Exception:
                        pass
                _show_popup("MCP Server", "Server is already running.")
                return
            self.server.binary_ops.current_view = bv
            try:
                self.server.binary_ops.register_view(bv)
            except Exception:
                pass
            self.server.start()
            global _mcp_user_stopped
            _mcp_user_stopped = False
            bn.log_info(
                f"MCP server started successfully on http://{self.config.server.host}:{self.config.server.port}"
            )
            _set_status_indicator(True)
            _show_popup(
                "MCP Server Started",
                f"Running at http://{self.config.server.host}:{self.config.server.port}",
            )
        except Exception as e:
            bn.log_error(f"Failed to start MCP server: {e!s}")
            _show_popup("MCP Server Error", f"Failed to start: {e}")

    def stop_server(self, bv):
        try:
            # If not running, inform the user
            if not (self.server and self.server.server):
                bn.log_info("MCP Max server stop requested but server is not running")
                _show_popup("MCP Server", "Server is not running.")
                return
            global _mcp_user_stopped
            _mcp_user_stopped = True
            self.server.binary_ops.current_view = None
            self.server.stop()
            bn.log_info("Binary Ninja MCP Max plugin stopped successfully")
            _set_status_indicator(False)
            _show_popup("MCP Server Stopped", "Server has been stopped.")
        except Exception as e:
            bn.log_error(f"Failed to stop server: {e!s}")
            _show_popup("MCP Server Error", f"Failed to stop: {e}")


plugin = BinaryNinjaMCP()


def _register_settings():
    settings = Settings()
    settings.register_group("mcp", "MCP Server")
    settings.register_setting(
        "mcp.renamePrefix",
        '{ "title": "Rename Prefix", "type": "string", "default": "mcp_", "description": "Prefix to prepend to renamed functions and variables (e.g. mcp_, mw_). Leave empty for no prefix." }',
    )
    settings.register_setting(
        "mcp.showStatusButton",
        '{ "title": "Show Status Button", "type": "boolean", "default": true, "description": "Show MCP server status button in the status bar." }',
    )


_register_settings()


def _apply_settings_to_config():
    return


def _try_autostart_for_bv(bv):
    try:
        # Respect manual stop; do not auto-start until user starts explicitly
        global _mcp_user_stopped
        if _mcp_user_stopped:
            bn.log_debug("MCP Max autostart suppressed due to manual stop")
            return
        plugin.start_server(bv)
    except Exception as e:
        bn.log_error(f"MCP Max autostart failed: {e}")


def _show_popup(title: str, text: str, info: bool = True):
    """Disable UI popups; log message instead.

    This keeps the UX unobtrusive while preserving visibility in the log.
    """
    try:
        # Prefer informational logs; error cases are already logged elsewhere
        # at error level in their respective handlers.
        bn.log_info(f"{title}: {text}")
    except Exception:
        # As a last resort, swallow to avoid any UI disruption
        pass


def _show_no_bv_popup():
    """Show a focused popup for the 'no BinaryView' case only."""
    msg = "No BinaryView is active, please open a binary first"
    try:
        from binaryninja.interaction import (
            MessageBoxButtonSet,
            MessageBoxIcon,
            show_message_box,
        )

        show_message_box(
            "Binary Ninja MCP Max",
            msg,
            MessageBoxButtonSet.OKButtonSet,
            MessageBoxIcon.WarningIcon,
        )
    except Exception:
        # Fall back to log if UI interaction is unavailable
        try:
            bn.log_warn(msg)
        except Exception:
            pass


# ------- Status bar indicator -------
_status_button = None
_status_container = None
_indicator_timer = None
_bv_monitor_timer = None


def _sidebar_icon_margin_default() -> int:
    """Return a reasonable UI icon size to use as horizontal margin.

    Tries to query the Qt style's toolbar icon size (commonly 24). Falls back to 24 on failure.
    """
    try:
        import binaryninjaui as ui
        from PySide6.QtWidgets import QStyle

        ctx = ui.UIContext.activeContext()
        mw = getattr(ctx, "mainWindow", None)
        mw = mw() if callable(mw) else mw
        if mw and hasattr(mw, "style"):
            st = mw.style()
            if st:
                val = int(st.pixelMetric(QStyle.PM_ToolBarIconSize))
                if val > 0:
                    return val
    except Exception:
        pass
    return 24


def _ensure_status_indicator():
    global _status_button
    try:
        import binaryninjaui as ui
        from PySide6.QtCore import Qt
        from PySide6.QtWidgets import QHBoxLayout, QPushButton, QWidget

        # Check if status button is disabled in settings
        settings = Settings()
        if not settings.get_bool("mcp.showStatusButton"):
            return

        def _create():
            global _status_button
            if _status_button is not None:
                return
            ctx = ui.UIContext.activeContext()
            if not ctx:
                return
            mw = getattr(ctx, "mainWindow", None)
            mw = mw() if callable(mw) else mw
            if mw is None or not hasattr(mw, "statusBar"):
                return
            sb = mw.statusBar()
            if sb is None:
                return
            # Tighten status bar spacing
            try:
                sb.setContentsMargins(0, 0, 0, 0)
                if sb.layout():
                    sb.layout().setContentsMargins(0, 0, 0, 0)
                    sb.layout().setSpacing(0)
                sb.setStyleSheet(
                    "QStatusBar{padding:0;margin:0;} QStatusBar::item{margin:0;padding:0;border:0;}"
                )
            except Exception:
                pass

            # Create a flat button as the indicator and control
            _status_button = QPushButton()
            _status_button.setObjectName("mcpStatusButton")
            _status_button.setFlat(True)
            _status_button.setCursor(Qt.PointingHandCursor)
            _status_button.setToolTip("Click to start/stop MCP server")
            _status_button.setContentsMargins(0, 0, 0, 0)
            _status_button.setStyleSheet("margin:0; padding:0 6px; border:0; border-radius:1px;")

            # Wrap the button in a container with side margins so the margin area is unclickable
            m = _sidebar_icon_margin_default()
            container = QWidget()
            container.setObjectName("mcpStatusContainer")
            lay = QHBoxLayout(container)
            lay.setContentsMargins(m, 0, 3, 0)  # left margin = icon size + 1; right margin = 3px
            lay.setSpacing(0)
            lay.addWidget(_status_button)
            global _status_container
            _status_container = container

            # Set initial visible state so the indicator shows up immediately
            try:
                running_now = bool(plugin.server and plugin.server.server)
            except Exception:
                running_now = False
            if running_now:
                _status_button.setText("🟢 MCP: Running")
                _status_button.setStyleSheet(
                    "margin:0; padding:0 6px; border:0; border-radius:2px;"
                )
            else:
                _status_button.setText("🔴 MCP: Stopped")
                _status_button.setStyleSheet(
                    "margin:0; padding:0 6px; border:0; border-radius:2px;"
                )

            # Click handler to toggle server state
            def _on_click():
                try:
                    running = bool(plugin.server and plugin.server.server)
                    if running:
                        plugin.stop_server(None)
                    else:
                        # Acquire active BinaryView for start
                        try:
                            from binaryninjaui import UIContext

                            ctx = UIContext.activeContext()
                            bv = None
                            if ctx:
                                vf = ctx.getCurrentViewFrame()
                                if vf and hasattr(vf, "getCurrentBinaryView"):
                                    bv = vf.getCurrentBinaryView()
                        except Exception:
                            bv = None
                        if not bv:
                            _show_no_bv_popup()
                            return
                        plugin.start_server(bv)
                finally:
                    _set_status_indicator(bool(plugin.server and plugin.server.server))

            _status_button.clicked.connect(_on_click)

            # Place slightly to the right (not the far-right): index 1
            try:
                sb.insertWidget(1, container, 0)
            except Exception:
                try:
                    sb.addWidget(container)
                except Exception:
                    sb.addPermanentWidget(container)

        # Ensure we run on UI thread if available
        try:
            ui.execute_on_main_thread(_create)
        except Exception:
            _create()
    except Exception:
        pass


def _set_status_indicator(running: bool):
    try:
        import binaryninjaui as ui

        # Check if status button is disabled in settings
        settings = Settings()
        if not settings.get_bool("mcp.showStatusButton"):
            return

        def _update():
            _ensure_status_indicator()
            if _status_button is None:
                return
            if running:
                _status_button.setText("🟢 MCP: Running")
                _status_button.setStyleSheet(
                    "margin:0; padding:0 6px; border:0; border-radius:1px;"
                )
            else:
                _status_button.setText("🔴 MCP: Stopped")
                _status_button.setStyleSheet(
                    "margin:0; padding:0 6px; border:0; border-radius:1px;"
                )

        try:
            ui.execute_on_main_thread(_update)
        except Exception:
            _update()
    except Exception:
        pass


def _start_indicator_watcher():
    """Periodically ensure the indicator exists after UI becomes ready.

    Some environments initialize UI context late; this watcher is a light
    safety net that creates and updates the indicator shortly after load.
    It stops itself once the indicator exists.
    """
    global _indicator_timer
    try:
        import binaryninjaui as ui
        from PySide6.QtCore import QTimer

        if _indicator_timer is not None:
            return

        def _tick():
            try:
                _ensure_status_indicator()
                _set_status_indicator(bool(plugin.server and plugin.server.server))
                if _status_button is not None and hasattr(_indicator_timer, "stop"):
                    _indicator_timer.stop()
            except Exception:
                pass

        _indicator_timer = QTimer()
        _indicator_timer.setInterval(500)
        _indicator_timer.timeout.connect(_tick)

        def _start():
            try:
                _tick()
                _indicator_timer.start()
            except Exception:
                pass

        try:
            ui.execute_on_main_thread(_start)
        except Exception:
            _start()
    except Exception:
        pass


def _schedule_status_init():
    """Ensure the status control appears ASAP on app load."""
    try:
        import binaryninjaui as ui
        from PySide6.QtCore import QTimer

        def _init_once():
            try:
                _ensure_status_indicator()
                _set_status_indicator(bool(plugin.server and plugin.server.server))
            except Exception:
                pass

        # Attempt immediately and then with several short delays
        try:
            ui.execute_on_main_thread(_init_once)
        except Exception:
            _init_once()

        for delay in (200, 500, 1000, 1500, 2000):
            try:
                ui.execute_on_main_thread(lambda d=delay: QTimer.singleShot(d, _init_once))
            except Exception:
                pass
    except Exception:
        pass


def _start_bv_monitor():
    """Start a lightweight UI timer that keeps the server's BinaryView list in sync in near real-time.

    - Registers any newly opened views discovered via UI contexts
    - Prunes closed views so /binaries reflects current state without user interaction
    """
    global _bv_monitor_timer
    try:
        import binaryninjaui as ui
        from PySide6.QtCore import QTimer

        if _bv_monitor_timer is not None:
            return

        def _discover_all_open_bvs(ops):
            """Heuristically discover all open BinaryViews from UI and sync registry.

            Attempts multiple UI paths defensively; safe if some APIs are unavailable.
            """
            try:
                from binaryninjaui import UIContext
            except Exception:
                UIContext = None

            found_fns: set[str] = set()
            found_bvs: list = []
            contexts = []
            try:
                if UIContext and hasattr(UIContext, "allContexts"):
                    contexts = list(UIContext.allContexts())
            except Exception:
                contexts = []
            if not contexts and UIContext:
                try:
                    ctx = UIContext.activeContext()
                    if ctx:
                        contexts = [ctx]
                except Exception:
                    contexts = []

            def _collect_from_frame(vf):
                try:
                    if vf and hasattr(vf, "getCurrentBinaryView"):
                        bv = vf.getCurrentBinaryView()
                        if bv:
                            found_bvs.append(bv)
                except Exception:
                    pass
                # Try alternative accessors
                try:
                    if vf and hasattr(vf, "getBinaryView"):
                        bv2 = vf.getBinaryView()
                        if bv2:
                            found_bvs.append(bv2)
                except Exception:
                    pass

            for ctx in contexts:
                # Current frame
                try:
                    vf = ctx.getCurrentViewFrame()
                    _collect_from_frame(vf)
                except Exception:
                    pass
                # Any additional frames if available
                for attr in ("getViewFrames", "viewFrames", "allViewFrames", "frames"):
                    try:
                        getter = getattr(ctx, attr, None)
                        frames = None
                        if callable(getter):
                            frames = getter()
                        elif getter is not None:
                            frames = getter
                        if frames:
                            for vf2 in list(frames):
                                _collect_from_frame(vf2)
                    except Exception:
                        continue

            # Register discovered BVs and build set of filenames
            for bv in found_bvs:
                try:
                    ops.register_view(bv)
                    fn = None
                    try:
                        if getattr(bv, "file", None):
                            fn = getattr(bv.file, "filename", None)
                    except Exception:
                        fn = None
                    if fn:
                        found_fns.add(str(fn))
                except Exception:
                    continue
            return found_fns

        def _tick():
            try:
                ops = (
                    plugin.server.binary_ops
                    if (plugin.server and plugin.server.binary_ops)
                    else None
                )
                if not ops:
                    return

                # First, prune internal weakrefs and get a snapshot of tracked views
                try:
                    ops.list_open_binaries()
                except Exception:
                    pass

                # Discover all open BVs from UI and sync registry (returns filenames)
                try:
                    _discover_all_open_bvs(ops) or set()
                except Exception:
                    pass

                # Do not prune solely based on UI heuristics; UI enumeration may miss open tabs.
                # Rely on explicit close notifications and weakref pruning in ops.

                # Keep MCP-selected active view independent of UI focus.
                # Only adopt a UI-active view if there is no current selection
                # (e.g., after the previously selected view was actually closed
                # and pruned by weakrefs).
                try:
                    if ops.current_view is None:
                        try:
                            from binaryninjaui import UIContext

                            act_ctx = UIContext.activeContext()
                            act_bv = None
                            if act_ctx:
                                vf = act_ctx.getCurrentViewFrame()
                                if vf and hasattr(vf, "getCurrentBinaryView"):
                                    act_bv = vf.getCurrentBinaryView()
                            ops.current_view = act_bv
                            if act_bv:
                                ops.register_view(act_bv)
                        except Exception:
                            # If UI is unavailable or no active view, leave as None
                            pass
                except Exception:
                    pass
            except Exception:
                # Never raise out of the timer
                pass

        _bv_monitor_timer = QTimer()
        _bv_monitor_timer.setInterval(1000)  # 1s; light periodic sync
        _bv_monitor_timer.timeout.connect(_tick)

        def _start():
            try:
                _tick()
                _bv_monitor_timer.start()
            except Exception:
                pass

        try:
            ui.execute_on_main_thread(_start)
        except Exception:
            _start()
    except Exception:
        pass


# Install UI notifications (when UI is available)
try:
    import binaryninjaui as ui

    class _MCPMaxUINotification(ui.UIContextNotification):
        def _get_active_bv(self):
            try:
                ctx = ui.UIContext.activeContext()
                if ctx:
                    vf = ctx.getCurrentViewFrame()
                    if vf and hasattr(vf, "getCurrentBinaryView"):
                        return vf.getCurrentBinaryView()
            except Exception:
                pass
            return None

        def OnViewChange(self, *args):  # signature varies across versions
            try:
                bv = self._get_active_bv()
                # Ensure the status indicator exists and reflects current state
                _ensure_status_indicator()
                _set_status_indicator(bool(plugin.server and plugin.server.server))
                _start_indicator_watcher()
                _start_bv_monitor()
                if bv:
                    # Track the BinaryView for multi-binary support
                    try:
                        plugin.server.binary_ops.register_view(bv)
                    except Exception:
                        pass
                    _try_autostart_for_bv(bv)
            except Exception as e:
                bn.log_error(f"MCP Max UI notification error: {e}")

        # Some versions provide OnAfterOpenFile; handle if present
        def OnAfterOpenFile(self, *args):  # type: ignore[override]
            try:
                bv = self._get_active_bv()
                # Ensure the status indicator is present as soon as a file opens
                _ensure_status_indicator()
                _set_status_indicator(bool(plugin.server and plugin.server.server))
                _start_indicator_watcher()
                _start_bv_monitor()
                if bv:
                    try:
                        plugin.server.binary_ops.register_view(bv)
                    except Exception:
                        pass
                    _try_autostart_for_bv(bv)
            except Exception as e:
                bn.log_error(f"MCP Max OnAfterOpenFile error: {e}")

        # Best-effort close notifications (may not be called on all versions)
        def OnBeforeCloseFile(self, *args):  # type: ignore[override]
            try:
                bv = self._get_active_bv()
                if bv and plugin.server and plugin.server.binary_ops:
                    try:
                        fn = getattr(bv.file, "filename", None)
                    except Exception:
                        fn = None
                    if fn:
                        plugin.server.binary_ops.unregister_by_filename(fn)
            except Exception:
                pass

        def OnAfterCloseFile(self, *args):  # type: ignore[override]
            try:
                # Force a prune after close
                if plugin.server and plugin.server.binary_ops:
                    _ = plugin.server.binary_ops.list_open_binaries()
            except Exception:
                pass

        # Ensure status indicator exists when a UI context opens
        def OnContextOpen(self, *args):  # type: ignore[override]
            try:
                _ensure_status_indicator()
                _set_status_indicator(bool(plugin.server and plugin.server.server))
                _start_indicator_watcher()
            except Exception:
                pass

    ui.UIContext.registerNotification(_MCPMaxUINotification())
    bn.log_info("MCP Max UI notifications installed")
    # Ensure status control is present at startup with retries
    _schedule_status_init()
    _start_indicator_watcher()
    _start_bv_monitor()
except Exception as e:
    # UI not available (headless) or API mismatch; ignore
    bn.log_debug(f"MCP Max UI notifications not installed: {e}")

# Attempt an immediate autostart if a BV is already open (e.g., .bndb loaded)
try:
    from binaryninjaui import UIContext

    ctx = UIContext.activeContext()
    if ctx:
        vf = ctx.getCurrentViewFrame()
        if vf and hasattr(vf, "getCurrentBinaryView"):
            bv = vf.getCurrentBinaryView()
            if bv:
                _try_autostart_for_bv(bv)
    # Schedule a few retries on the UI thread to catch late BV availability
    try:
        import binaryninjaui as ui
        from PySide6.QtCore import QTimer

        def _kick_autostart():
            try:
                ctx2 = UIContext.activeContext()
                if ctx2:
                    vf2 = ctx2.getCurrentViewFrame()
                    if vf2 and hasattr(vf2, "getCurrentBinaryView"):
                        bv2 = vf2.getCurrentBinaryView()
                        if bv2:
                            _try_autostart_for_bv(bv2)
                # also ensure status control exists after UI is fully ready
                _schedule_status_init()
            except Exception as _e:
                bn.log_debug(f"MCP Max auto-start retry error: {_e}")

        for delay in (200, 500, 1000, 1500, 2000):
            ui.execute_on_main_thread(lambda d=delay: QTimer.singleShot(d, _kick_autostart))
    except Exception:
        pass
except Exception:
    pass


def _is_server_running() -> bool:
    try:
        return bool(plugin.server and plugin.server.server)
    except Exception:
        return False


def _can_start(bv) -> bool:  # bv required by BN predicate signature
    return (bv is not None) and (not _is_server_running())


def _can_stop(bv) -> bool:
    return _is_server_running()


# Register menu actions (always visible)
bn.PluginCommand.register(
    "MCP Server\\Start MCP Server",
    "Start the Binary Ninja MCP server",
    plugin.start_server,
)
bn.PluginCommand.register(
    "MCP Server\\Stop MCP Server",
    "Stop the Binary Ninja MCP server",
    plugin.stop_server,
)

bn.log_info("Binary Ninja MCP plugin loaded successfully")

# Auto-start and settings UI removed

# One-time MCP client auto-setup: install bridge entry into popular MCP clients
try:
    from .utils.auto_setup import install_mcp_clients

    _ = install_mcp_clients(quiet=True)
except Exception:
    # Best-effort; ignore failures to avoid disrupting plugin load
    pass

# Register global handler to discover and track all opened BinaryViews
try:
    from binaryninja.binaryview import BinaryViewType

    def _on_bv_initial_analysis(bv):
        try:
            # Ensure server exists; even if not running, register the view for listing later
            if plugin.server and plugin.server.binary_ops:
                plugin.server.binary_ops.register_view(bv)
        except Exception:
            pass

    try:
        BinaryViewType.add_binaryview_initial_analysis_completion_event(_on_bv_initial_analysis)
        bn.log_info("Registered BinaryView initial analysis completion event for MCP Max")
    except Exception as e:
        bn.log_debug(f"Unable to register BV analysis completion event: {e}")
    # Also register finalized event to catch newly created/opened views early
    try:
        BinaryViewType.add_binaryview_finalized_event(_on_bv_initial_analysis)
        bn.log_info("Registered BinaryView finalized event for MCP Max")
    except Exception as e:
        bn.log_debug(f"Unable to register BV finalized event: {e}")
except Exception:
    pass

```

`plugin/api/endpoints.py`:

```py
import os
from typing import Any

import binaryninja as bn

from ..core.binary_operations import BinaryOperations


class BinaryNinjaEndpoints:
    def __init__(self, binary_ops: BinaryOperations):
        self.binary_ops = binary_ops

    def get_status(self) -> dict[str, Any]:
        """Get the current status of the binary view"""
        return {
            "loaded": self.binary_ops.current_view is not None,
            "filename": self.binary_ops.current_view.file.filename
            if self.binary_ops.current_view
            else None,
        }

    def get_entry_points(self) -> list[dict[str, Any]]:
        """Get entry point(s) for the current binary"""
        return self.binary_ops.get_entry_points()

    # -------- Multi-binary helpers --------
    def _format_binary_listing(self, raw: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Normalize binary listing entries with ordinal, view id, basename, and selectors."""
        formatted: list[dict[str, Any]] = []
        for ordinal, item in enumerate(raw, start=1):
            filename = item.get("filename")
            view_id = str(item.get("id") or "")
            basename = os.path.basename(filename) if filename else None
            entry: dict[str, Any] = {
                "id": str(ordinal),
                "view_id": view_id,
                "filename": filename,
                "basename": basename,
                "active": bool(item.get("active")),
            }
            selectors: list[str] = []
            for candidate in (
                entry["id"],
                view_id,
                filename,
                basename,
            ):
                if candidate and candidate not in selectors:
                    selectors.append(candidate)
            entry["selectors"] = selectors
            formatted.append(entry)
        return formatted

    def list_binaries(self) -> dict[str, Any]:
        """List managed/open binaries with sequential ids (1..N) and active flag.

        The server maintains internal keys for views; this endpoint presents
        a user-friendly, 1-based index stable under sorting by filename.
        """
        raw = self.binary_ops.list_open_binaries()
        return {"binaries": self._format_binary_listing(raw)}

    def select_binary(self, ident: str) -> dict[str, Any]:
        """Select active binary by id or filename/basename."""
        info = self.binary_ops.select_view(ident)
        if not info:
            return {
                "error": f"Binary not found: {ident}",
                "available": self.list_binaries().get("binaries", []),
            }
        filename = info.get("filename")
        view_id = info.get("id")
        formatted = self._format_binary_listing(self.binary_ops.list_open_binaries())
        selected_entry: dict[str, Any] | None = None
        for entry in formatted:
            if (filename and entry.get("filename") == filename) or (
                view_id and entry.get("view_id") == view_id
            ):
                selected_entry = entry
                break
        if not selected_entry:
            basename = os.path.basename(filename) if filename else None
            selectors: list[str] = []
            for candidate in (view_id, filename, basename):
                if candidate and candidate not in selectors:
                    selectors.append(candidate)
            selected_entry = {
                "id": None,
                "view_id": view_id,
                "filename": filename,
                "basename": basename,
                "active": True,
                "selectors": selectors,
            }
        else:
            selected_entry["active"] = True
        return {"status": "ok", "selected": selected_entry}

    def get_function_info(self, identifier: str) -> dict[str, Any] | None:
        """Get detailed information about a function"""
        try:
            return self.binary_ops.get_function_info(identifier)
        except Exception as e:
            bn.log_error(f"Error getting function info: {e}")
            return None

    def get_imports(self, offset: int = 0, limit: int = 100) -> list[dict[str, Any]]:
        """Get list of imported functions"""
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        imports = []
        for sym in self.binary_ops.current_view.get_symbols_of_type(
            bn.SymbolType.ImportedFunctionSymbol
        ):
            imports.append(
                {
                    "name": sym.name,
                    "address": hex(sym.address),
                    "raw_name": sym.raw_name if hasattr(sym, "raw_name") else sym.name,
                    "full_name": sym.full_name if hasattr(sym, "full_name") else sym.name,
                }
            )
        return imports[offset : offset + limit]

    def get_exports(self, offset: int = 0, limit: int = 100) -> list[dict[str, Any]]:
        """Get list of exported symbols"""
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        exports = []
        for sym in self.binary_ops.current_view.get_symbols():
            if sym.type not in [
                bn.SymbolType.ImportedFunctionSymbol,
                bn.SymbolType.ExternalSymbol,
            ]:
                exports.append(
                    {
                        "name": sym.name,
                        "address": hex(sym.address),
                        "raw_name": sym.raw_name if hasattr(sym, "raw_name") else sym.name,
                        "full_name": sym.full_name if hasattr(sym, "full_name") else sym.name,
                        "type": str(sym.type),
                    }
                )
        return exports[offset : offset + limit]

    def get_namespaces(self, offset: int = 0, limit: int = 100) -> list[str]:
        """Get list of C++ namespaces"""
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        namespaces = set()
        for sym in self.binary_ops.current_view.get_symbols():
            if "::" in sym.name:
                parts = sym.name.split("::")
                if len(parts) > 1:
                    namespace = "::".join(parts[:-1])
                    namespaces.add(namespace)

        sorted_namespaces = sorted(list(namespaces))
        return sorted_namespaces[offset : offset + limit]

    def get_defined_data(self, offset: int = 0, limit: int = 100) -> list[dict[str, Any]]:
        """Get list of defined data variables"""
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        data_items = []
        for var in self.binary_ops.current_view.data_vars:
            data_type = self.binary_ops.current_view.get_type_at(var)
            value = None

            try:
                if data_type and data_type.width <= 8:
                    value = str(self.binary_ops.current_view.read_int(var, data_type.width))
                else:
                    value = "(complex data)"
            except (ValueError, TypeError):
                value = "(unreadable)"

            sym = self.binary_ops.current_view.get_symbol_at(var)
            data_items.append(
                {
                    "address": hex(var),
                    "name": sym.name if sym else "(unnamed)",
                    "raw_name": sym.raw_name if sym and hasattr(sym, "raw_name") else None,
                    "value": value,
                    "type": str(data_type) if data_type else None,
                }
            )

        return data_items[offset : offset + limit]

    def search_functions(
        self, search_term: str, offset: int = 0, limit: int = 100
    ) -> list[dict[str, Any]]:
        """Search functions by name"""
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        if not search_term:
            return []

        matches = []
        for func in self.binary_ops.current_view.functions:
            if search_term.lower() in func.name.lower():
                matches.append(
                    {
                        "name": func.name,
                        "address": hex(func.start),
                        "raw_name": func.raw_name if hasattr(func, "raw_name") else func.name,
                        "symbol": {
                            "type": str(func.symbol.type) if func.symbol else None,
                            "full_name": func.symbol.full_name if func.symbol else None,
                        }
                        if func.symbol
                        else None,
                    }
                )

        matches.sort(key=lambda x: x["name"])
        return matches[offset : offset + limit]

    def decompile_function(self, identifier: str) -> str | None:
        """Decompile a function by name or address"""
        try:
            return self.binary_ops.decompile_function(identifier)
        except Exception as e:
            bn.log_error(f"Error decompiling function: {e}")
            return None

    def get_assembly_function(self, identifier: str) -> str | None:
        """Get the assembly representation of a function by name or address"""
        try:
            return self.binary_ops.get_assembly_function(identifier)
        except Exception as e:
            bn.log_error(f"Error getting assembly for function: {e}")
            return None

    def make_function_at(
        self, address: str | int, architecture: str | None = None
    ) -> dict[str, Any]:
        """Create a function at an address (no-op if already exists).

        On invalid/unknown platform (non-default arch parameter), returns an error object with
        an exhaustive list of available platforms so clients/LLMs can choose properly.
        """
        try:
            return self.binary_ops.make_function_at(address, architecture)
        except ValueError as e:
            # Enumerate all available platforms dynamically
            platforms: list[str] = []
            try:
                plats_obj = getattr(bn, "Platform", None)
                if plats_obj is not None:
                    try:
                        platforms = [str(getattr(p, "name", str(p))) for p in list(plats_obj)]
                    except Exception:
                        platforms = []
            except Exception:
                platforms = []
            # Fallback list if BN enumeration fails
            if not platforms:
                platforms = [
                    "decree-x86",
                    "efi-x86",
                    "efi-windows-x86",
                    "efi-x86_64",
                    "efi-windows-x86_64",
                    "efi-aarch64",
                    "efi-windows-aarch64",
                    "efi-armv7",
                    "efi-thumb2",
                    "freebsd-x86",
                    "freebsd-x86_64",
                    "freebsd-aarch64",
                    "freebsd-armv7",
                    "freebsd-thumb2",
                    "ios-aarch64",
                    "ios-armv7",
                    "ios-thumb2",
                    "ios-kernel-aarch64",
                    "ios-kernel-armv7",
                    "ios-kernel-thumb2",
                    "linux-ppc32",
                    "linux-ppcvle32",
                    "linux-ppc64",
                    "linux-ppc32_le",
                    "linux-ppc64_le",
                    "linux-rv32gc",
                    "linux-rv64gc",
                    "linux-x86",
                    "linux-x86_64",
                    "linux-x32",
                    "linux-aarch64",
                    "linux-armv7",
                    "linux-thumb2",
                    "linux-armv7eb",
                    "linux-thumb2eb",
                    "linux-mipsel",
                    "linux-mips",
                    "linux-mips3",
                    "linux-mipsel3",
                    "linux-mips64",
                    "linux-cnmips64",
                    "linux-mipsel64",
                    "mac-x86",
                    "mac-x86_64",
                    "mac-aarch64",
                    "mac-armv7",
                    "mac-thumb2",
                    "mac-kernel-x86",
                    "mac-kernel-x86_64",
                    "mac-kernel-aarch64",
                    "mac-kernel-armv7",
                    "mac-kernel-thumb2",
                    "windows-x86",
                    "windows-x86_64",
                    "windows-aarch64",
                    "windows-armv7",
                    "windows-thumb2",
                    "windows-kernel-x86",
                    "windows-kernel-x86_64",
                    "windows-kernel-windows-aarch64",
                ]
            return {"error": str(e), "available_platforms": platforms}

    def define_types(self, c_code: str) -> dict[str, str]:
        """Define types from C code string

        Args:
            c_code: C code string containing type definitions

        Returns:
            Dictionary mapping type names to their string representations

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If parsing the types fails
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        try:
            # Parse the C code string to get type objects
            parse_result = self.binary_ops.current_view.parse_types_from_string(c_code)

            # Define each type in the binary view
            defined_types = {}
            for name, type_obj in parse_result.types.items():
                self.binary_ops.current_view.define_user_type(name, type_obj)
                defined_types[str(name)] = str(type_obj)

            return defined_types
        except Exception as e:
            raise ValueError(f"Failed to define types: {e!s}")

    def rename_variable(self, function_name: str, old_name: str, new_name: str) -> dict[str, str]:
        """Rename a variable inside a function

        Args:
            function_name: Name of the function containing the variable
            old_name: Current name of the variable
            new_name: New name for the variable

        Returns:
            Dictionary with status message

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If the function is not found or variable cannot be renamed
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        # Find the function by name
        function = self.binary_ops.get_function_by_name_or_address(function_name)
        if not function:
            raise ValueError(f"Function '{function_name}' not found")

        # Try to rename the variable
        try:
            # Get the variable by name and rename it
            variable = function.get_variable_by_name(old_name)
            if not variable:
                raise ValueError(f"Variable '{old_name}' not found in function '{function_name}'")

            variable.name = new_name
            return {
                "status": f"Successfully renamed variable '{old_name}' to '{new_name}' in function '{function_name}'"
            }
        except Exception as e:
            raise ValueError(f"Failed to rename variable: {e!s}")

    def rename_variables(
        self,
        function_identifier: str | int,
        renames: list[dict[str, str]] | dict[str, str],
    ) -> dict[str, Any]:
        """Rename multiple local variables in a function.

        Args:
            function_identifier: Function name or address
            renames: Either a list of {"old": str, "new": str} pairs or a dict mapping old->new

        Returns:
            Dictionary with overall status and per-item results.

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If the function is not found or inputs are invalid
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        # Resolve function first
        func = self.binary_ops.get_function_by_name_or_address(function_identifier)
        if not func:
            raise ValueError(f"Function '{function_identifier}' not found")

        # Normalize renames into ordered list of {old, new}
        pairs: list[dict[str, str]] = []
        if isinstance(renames, dict):
            for k, v in renames.items():
                if k is None or v is None:
                    continue
                pairs.append({"old": str(k), "new": str(v)})
        elif isinstance(renames, list):
            for entry in renames:
                try:
                    old = (
                        entry.get("old")
                        or entry.get("from")
                        or entry.get("src")
                        or entry.get("before")
                    )
                    new = (
                        entry.get("new")
                        or entry.get("to")
                        or entry.get("dst")
                        or entry.get("after")
                    )
                except Exception:
                    old = None
                    new = None
                if old is None or new is None:
                    continue
                pairs.append({"old": str(old), "new": str(new)})
        else:
            raise ValueError(
                "Invalid 'renames' format; expected list of {old,new} or mapping old->new"
            )

        if not pairs:
            raise ValueError("No valid rename pairs provided")

        results: list[dict[str, Any]] = []
        success_count = 0

        # Apply in order; later entries can refer to names produced by earlier renames
        for idx, item in enumerate(pairs, start=1):
            old_name = item.get("old")
            new_name = item.get("new")
            if not old_name or not new_name:
                results.append(
                    {
                        "index": idx,
                        "old": old_name,
                        "new": new_name,
                        "success": False,
                        "error": "Missing old or new name",
                    }
                )
                continue

            try:
                var = None
                try:
                    if hasattr(func, "get_variable_by_name"):
                        var = func.get_variable_by_name(old_name)
                except Exception:
                    var = None
                if not var:
                    results.append(
                        {
                            "index": idx,
                            "old": old_name,
                            "new": new_name,
                            "success": False,
                            "error": f"Variable '{old_name}' not found",
                        }
                    )
                    continue

                # Primary method: direct property set
                try:
                    var.name = new_name
                except Exception:
                    # Fallback: attempt create_user_var with same storage/type but new name
                    try:
                        if hasattr(func, "create_user_var") and hasattr(var, "storage"):
                            vtype = getattr(var, "type", None)
                            if vtype is None:
                                # attempt to infer type if possible
                                vtype = getattr(bn, "Type", None)
                            func.create_user_var(var, vtype, new_name)
                        else:
                            raise
                    except Exception as e:
                        results.append(
                            {
                                "index": idx,
                                "old": old_name,
                                "new": new_name,
                                "success": False,
                                "error": f"Failed to rename: {e}",
                            }
                        )
                        continue

                success_count += 1
                results.append(
                    {
                        "index": idx,
                        "old": old_name,
                        "new": new_name,
                        "success": True,
                    }
                )
            except Exception as e:
                results.append(
                    {
                        "index": idx,
                        "old": old_name,
                        "new": new_name,
                        "success": False,
                        "error": str(e),
                    }
                )

        # Best-effort reanalysis for consistency
        try:
            func.reanalyze(bn.FunctionUpdateType.UserFunctionUpdate)
        except Exception:
            pass

        return {
            "status": "ok",
            "function": func.name,
            "address": hex(func.start),
            "total": len(pairs),
            "renamed": success_count,
            "results": results,
        }

    def retype_variable(self, function_name: str, name: str, type_str: str) -> dict[str, str]:
        """Retype a variable inside a function

        Args:
            function_name: Name of the function containing the variable
            name: Current name of the variable
            type: C type for the variable

        Returns:
            Dictionary with status message

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If the function is not found or variable cannot be retyped
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        # Find the function by name
        function = self.binary_ops.get_function_by_name_or_address(function_name)
        if not function:
            raise ValueError(f"Function '{function_name}' not found")

        # Try to rename the variable
        try:
            # Get the variable by name and rename it
            variable = function.get_variable_by_name(name)
            if not variable:
                raise ValueError(f"Variable '{name}' not found in function '{function_name}'")

            variable.type = type_str
            return {
                "status": f"Successfully retyped variable '{name}' to '{type_str}' in function '{function_name}'"
            }
        except Exception as e:
            raise ValueError(f"Failed to rename variable: {e!s}")

    def set_function_prototype(self, function_address: str | int, prototype: str) -> dict[str, str]:
        """Set a function's prototype by address.

        Args:
            function_address: Function address (hex string like 0x401000 or integer)
            prototype: C-style function prototype/type string (e.g., "int __cdecl f(int a)", or "int(int)" )

        Returns:
            Dictionary with status message.

        Raises:
            RuntimeError: If no binary is loaded.
            ValueError: If the function or prototype is invalid.
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        # Resolve function by name or address; do not auto-create if missing
        func = self.binary_ops.get_function_by_name_or_address(function_address)
        if not func:
            raise ValueError(f"Function not found for identifier '{function_address}'")

        # Normalize prototype (strip stray trailing semicolon)
        proto = (prototype or "").strip()
        if proto.endswith(";"):
            proto = proto[:-1].strip()

        # Best-effort parsing with fallbacks
        t = None
        last_error = None
        try:
            t, _ = self.binary_ops.current_view.parse_type_string(proto)
        except Exception as e:
            last_error = e
            t = None

        # Fallback 1: parse a declaration block and grab any function type
        if t is None:
            try:
                pr = self.binary_ops.current_view.parse_types_from_string(proto)
                if pr and getattr(pr, "types", None):
                    # Prefer an entry matching the current function name
                    chosen = None
                    if func.name in pr.types:
                        chosen = pr.types[func.name]
                    else:
                        # Otherwise pick the first type that looks like a function
                        for name, tobj in pr.types.items():
                            try:
                                if hasattr(tobj, "type_class") and int(
                                    getattr(bn.enums, "TypeClass", object).FunctionTypeClass
                                ) == int(getattr(tobj, "type_class")):
                                    chosen = tobj
                                    break
                            except Exception:
                                # Fallback: accept the first one
                                chosen = tobj
                                break
                    if chosen is not None:
                        t = chosen
            except Exception as e:
                last_error = e

        # Fallback 2: if the prototype looks like a bare "ret(args)" without a name,
        # synthesize a declaration by inserting the function's name.
        if t is None:
            import re as _re

            m = _re.match(r"^\s*([^()]+?)\s*\((.*)\)\s*$", proto)
            if m and func and func.name and func.name not in proto:
                ret = m.group(1).strip()
                args = m.group(2).strip()
                candidate = f"{ret} {func.name}({args})"
                try:
                    t, _ = self.binary_ops.current_view.parse_type_string(candidate)
                except Exception as e:
                    last_error = e

        if t is None:
            raise ValueError(f"Failed to parse prototype: {proto} ({last_error})")

        # Apply and reanalyze
        try:
            func.type = t
            func.reanalyze(bn.FunctionUpdateType.UserFunctionUpdate)
        except Exception as e:
            raise ValueError(f"Failed applying type: {e!s}")

        return {
            "status": "ok",
            "function": func.name,
            "address": hex(func.start),
            "applied_type": str(t),
        }

    def declare_c_type(self, c_declaration: str) -> dict[str, Any]:
        """Create or update a local type from a single C declaration.

        Accepts any C type declaration (struct/union/enum/typedef/function type) and defines
        the resulting named types in the current BinaryView's user types. If multiple types
        are declared, all are applied.

        Args:
            c_declaration: C declaration string (e.g., "typedef struct { int a; } Foo;")

        Returns:
            Dictionary with keys:
              - defined_types: map of type name -> declaration string
              - count: number of types defined/updated

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If parsing fails or no types are found
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        decl = (c_declaration or "").strip()
        if not decl:
            raise ValueError("Empty C declaration")

        try:
            result = self.binary_ops.current_view.parse_types_from_string(decl)
        except Exception as e:
            raise ValueError(f"Failed to parse declaration: {e!s}")

        if not result or not getattr(result, "types", {}):
            raise ValueError("No named types found in declaration")

        defined: dict[str, str] = {}
        for name, type_obj in result.types.items():
            try:
                self.binary_ops.current_view.define_user_type(name, type_obj)
                defined[str(name)] = str(type_obj)
            except Exception as e:
                raise ValueError(f"Failed to define type '{name}': {e!s}")

        return {"defined_types": defined, "count": len(defined)}

    def set_local_variable_type(
        self, function_address: str | int, variable_name: str, new_type: str
    ) -> dict[str, str]:
        """Set a local variable's type in a function.

        Args:
            function_address: Function identifier (address in hex or int, or name)
            variable_name: Local variable name to retype
            new_type: C type string (e.g., "int *", "const char*", "struct Foo*")

        Returns:
            Dictionary with status message.

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If function/variable/type are invalid
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        func = self.binary_ops.get_function_by_name_or_address(function_address)
        if not func:
            raise ValueError(f"Function '{function_address}' not found")

        if not variable_name:
            raise ValueError("Missing variable name")

        # Resolve the variable by name
        var = None
        try:
            if hasattr(func, "get_variable_by_name"):
                var = func.get_variable_by_name(variable_name)
        except Exception:
            var = None

        if not var:
            raise ValueError(f"Variable '{variable_name}' not found in function '{func.name}'")

        # Parse type string
        try:
            t, _ = self.binary_ops.current_view.parse_type_string((new_type or "").strip())
        except Exception:
            t = None
        if t is None:
            # Fall back to assigning the string if BN API supports it; otherwise fail
            try:
                var.type = new_type
                applied = str(new_type)
            except Exception:
                raise ValueError(f"Failed to parse type: '{new_type}'")
        else:
            # Apply via variable object or function API
            applied = str(t)
            try:
                var.type = t
            except Exception:
                # Try create_user_var if direct assignment fails
                try:
                    if hasattr(func, "create_user_var") and hasattr(var, "storage"):
                        func.create_user_var(var, t, variable_name)
                    else:
                        raise ValueError("Retyping not supported by this Binary Ninja API version")
                except Exception as e:
                    raise ValueError(f"Failed to set variable type: {e!s}")

        # Trigger reanalysis for consistency
        try:
            func.reanalyze(bn.FunctionUpdateType.UserFunctionUpdate)
        except Exception:
            pass

        return {
            "status": "ok",
            "function": func.name,
            "address": hex(func.start),
            "variable": variable_name,
            "applied_type": applied,
        }

    def get_stack_frame_vars(self, function_identifier: str | int) -> list[dict[str, Any]]:
        """Get stack frame variable information for a function.

        Returns information about local variables in the function's stack frame,
        including their names, offsets, sizes, and types.

        Args:
            function_identifier: Function name or address

        Returns:
            List of dictionaries with stack frame information:
            [
                {
                    "addr": "0x401000",
                    "vars": [
                        {
                            "name": "buf",
                            "offset": "-0x10",
                            "size": "0x10",
                            "type": "char[16]"
                        },
                        {
                            "name": "len",
                            "offset": "-0x4",
                            "size": "0x4",
                            "type": "int"
                        }
                    ]
                }
            ]

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If the function is not found
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        func = self.binary_ops.get_function_by_name_or_address(function_identifier)
        if not func:
            raise ValueError(f"Function '{function_identifier}' not found")

        result = []

        # Get stack layout information
        stack_layout = []
        if hasattr(func, "stack_layout"):
            stack_layout = func.stack_layout
        elif hasattr(func, "vars"):
            stack_layout = func.vars
        else:
            raise RuntimeError(
                f"Function '{function_identifier}' has no stack information available"
            )

        # Process each variable in the stack layout
        vars_list = []
        for var in stack_layout:
            try:
                var_info = {
                    "name": getattr(var, "name", ""),
                    "offset": "0x0",
                    "size": "0x0",
                    "type": "",
                }

                # Get offset information
                if hasattr(var, "storage"):
                    storage = var.storage
                    if storage is not None:
                        # For stack variables, storage is typically the stack offset
                        if isinstance(storage, int):
                            var_info["offset"] = f"{storage:#x}"
                        else:
                            var_info["offset"] = str(storage)

                # Get size information
                if hasattr(var, "type") and var.type is not None:
                    var_info["type"] = str(var.type)
                    try:
                        if hasattr(var.type, "width"):
                            var_info["size"] = f"{var.type.width:#x}"
                    except Exception:
                        var_info["size"] = "0x0"

                # If we couldn't get size from type, try other methods
                if var_info["size"] == "0x0" and hasattr(var, "width"):
                    var_info["size"] = f"{var.width:#x}"

                vars_list.append(var_info)

            except Exception as e:
                bn.log_error(f"Error processing variable {getattr(var, 'name', '<unknown>')}: {e}")
                continue

        result.append({"addr": hex(func.start), "vars": vars_list})

        return result

    # display_as removed per request

    def patch_bytes(
        self, address: str | int, data: str | bytes | list[int], save_to_file: bool = True
    ) -> dict[str, Any]:
        """Patch bytes at a given address in the binary.

        Args:
            address: Address to patch (hex string like "0x401000" or integer)
            data: Bytes to write. Can be:
                - Hex string: "90 90" or "9090" or "0x90 0x90"
                - List of integers: [0x90, 0x90]
                - Bytes object: b"\x90\x90"
            save_to_file: If True (default), save the patched binary to disk and re-sign on macOS.
                If False, only modify the BinaryView in memory without affecting the original file.

        Returns:
            Dictionary with status, address, original bytes, and patched bytes

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If address or data format is invalid
        """
        if not self.binary_ops.current_view:
            raise RuntimeError("No binary loaded")

        try:
            return self.binary_ops.patch_bytes(address, data, save_to_file)
        except Exception as e:
            bn.log_error(f"Error patching bytes: {e}")
            raise ValueError(f"Failed to patch bytes: {e!s}")

```

`plugin/core/binary_operations.py`:

```py
import platform
import re
import subprocess
import weakref
from typing import Any

import binaryninja as bn
from binaryninja.enums import StructureVariant, TypeClass

from ..utils.string_utils import escape_non_ascii
from .config import BinaryNinjaConfig


class BinaryOperations:
    def __init__(self, config: BinaryNinjaConfig):
        self.config = config
        self._current_view: bn.BinaryView | None = None
        # Multi-binary support
        # Store weak references so closed views are auto-pruned
        self._views_by_id: dict[str, weakref.ReferenceType] = {}
        self._next_view_id: int = 1
        self._id_by_filename: dict[str, str] = {}

    @property
    def current_view(self) -> bn.BinaryView | None:
        return self._current_view

    @current_view.setter
    def current_view(self, bv: bn.BinaryView | None):
        self._current_view = bv
        if bv:
            bn.log_info(f"Set current binary view: {bv.file.filename}")
            try:
                self._register_view(bv)
            except Exception:
                pass
        else:
            bn.log_info("Cleared current binary view")

    def load_binary(self, filepath: str) -> bn.BinaryView:
        """Load a binary file using the appropriate method based on the Binary Ninja API version"""
        try:
            if hasattr(bn, "open_view"):
                bn.log_info("Using bn.open_view method")
                self._current_view = bn.open_view(filepath)
            elif hasattr(bn, "BinaryViewType") and hasattr(bn.BinaryViewType, "get_view_of_file"):
                bn.log_info("Using BinaryViewType.get_view_of_file method")
                file_metadata = bn.FileMetadata()
                try:
                    if hasattr(bn.BinaryViewType, "get_default_options"):
                        options = bn.BinaryViewType.get_default_options()
                        self._current_view = bn.BinaryViewType.get_view_of_file(
                            filepath, file_metadata, options
                        )
                    else:
                        self._current_view = bn.BinaryViewType.get_view_of_file(
                            filepath, file_metadata
                        )
                except TypeError:
                    self._current_view = bn.BinaryViewType.get_view_of_file(filepath)
            else:
                bn.log_info("Using legacy method")
                file_metadata = bn.FileMetadata()
                binary_view_type = bn.BinaryViewType.get_view_of_file_with_options(
                    filepath, file_metadata
                )
                if binary_view_type:
                    self._current_view = binary_view_type.open()
                else:
                    raise Exception("No view type available for this file")

            try:
                if self._current_view is not None:
                    self._register_view(self._current_view)
            except Exception:
                pass
            return self._current_view
        except Exception as e:
            bn.log_error(f"Failed to load binary: {e}")
            raise

    # ---------------- Multi-binary helpers ----------------
    def _prune_views(self) -> None:
        """Remove entries for BinaryViews that no longer exist and rebuild filename map."""
        alive: dict[str, weakref.ReferenceType] = {}
        new_fn_map: dict[str, str] = {}
        alive_objs: list[object] = []
        for vid, w in list(self._views_by_id.items()):
            try:
                vb = w()
            except Exception:
                vb = None
            if vb is None:
                continue
            alive[vid] = w
            alive_objs.append(vb)
            try:
                fn = str(getattr(vb.file, "filename", None)) if getattr(vb, "file", None) else None
            except Exception:
                fn = None
            if fn and fn not in new_fn_map:
                new_fn_map[fn] = vid
        self._views_by_id = alive
        self._id_by_filename = new_fn_map
        # If current_view no longer exists among alive views, clear it
        try:
            if self._current_view is not None and all(
                obj is not self._current_view for obj in alive_objs
            ):
                self._current_view = None
        except Exception:
            self._current_view = None

    def _register_view(self, bv: bn.BinaryView) -> str:
        """Add a view to the managed list if not present, return its id."""
        self._prune_views()
        # Reuse existing id if the exact object is already tracked
        for vid, w in list(self._views_by_id.items()):
            try:
                vb = w()
            except Exception:
                vb = None
            if vb is bv:
                return vid
        # Prefer deduplication by canonical filename
        fn = None
        try:
            fn = str(getattr(bv.file, "filename", None)) if getattr(bv, "file", None) else None
        except Exception:
            fn = None
        if fn:
            # If a view for this filename already exists, reuse its id and update the view
            existing_id = self._id_by_filename.get(fn)
            if existing_id and existing_id in self._views_by_id:
                # Always store weak references so closed views can be pruned
                self._views_by_id[existing_id] = weakref.ref(bv)
                return existing_id
        # Assign a new id
        vid = str(self._next_view_id)
        self._next_view_id += 1
        self._views_by_id[vid] = weakref.ref(bv)
        if fn:
            self._id_by_filename[fn] = vid
        return vid

    def register_view(self, bv: bn.BinaryView) -> str:
        """Public wrapper to register a BinaryView and return its id."""
        return self._register_view(bv)

    def unregister_by_filename(self, filename: str) -> int:
        """Remove all tracked views that match the given absolute filename.

        Returns number of entries removed.
        """
        if not filename:
            return 0
        self._prune_views()
        to_delete: list[str] = []
        for vid, w in list(self._views_by_id.items()):
            try:
                vb = w()
            except Exception:
                vb = None
            if vb is None:
                continue
            try:
                fn = getattr(vb.file, "filename", None)
            except Exception:
                fn = None
            if fn == filename:
                to_delete.append(vid)
        for vid in to_delete:
            self._views_by_id.pop(vid, None)
        # Rebuild filename map and clear current_view if it matched
        try:
            cur_fn = None
            if self._current_view and getattr(self._current_view, "file", None):
                cur_fn = getattr(self._current_view.file, "filename", None)
            if cur_fn == filename:
                self._current_view = None
        except Exception:
            self._current_view = None
        self._prune_views()
        return len(to_delete)

    def list_open_binaries(self) -> list[dict[str, str]]:
        """Return a list of managed/open binaries with ids.

        Note: Tracks binaries opened via this plugin or explicitly registered as current_view.
        """
        items: list[dict[str, str]] = []
        # Cleanup first
        self._prune_views()
        # Do NOT auto-register current_view here; UI monitor handles discovery.
        # This avoids re-introducing closed views via a stale strong reference.
        # Deduplicate by canonical filename; prefer the id mapped in _id_by_filename
        entries: list[tuple[str, str, bool]] = []  # (id, filename, active)
        seen: set[str] = set()
        for vid, w in self._views_by_id.items():
            try:
                vb = w()
            except Exception:
                vb = None
            if vb is None:
                continue
            try:
                fn = vb.file.filename
            except Exception:
                fn = "(unknown)"
            key = fn
            if key in seen:
                continue
            seen.add(key)
            # Resolve canonical id for this filename when available
            canonical_id = self._id_by_filename.get(fn, vid)
            try:
                vb_canon_ref = self._views_by_id.get(canonical_id)
                vb_canon = vb_canon_ref() if vb_canon_ref else vb
            except Exception:
                vb_canon = vb
            entries.append((canonical_id, fn, bool(vb_canon is self._current_view)))
        # Sort by filename for stable ordering
        entries.sort(key=lambda t: (t[1] or ""))
        for cid, fn, active in entries:
            items.append({"id": cid, "filename": fn, "active": active})
        return items

    def select_view(self, ident: str) -> dict[str, str] | None:
        """Select active BinaryView by id or filename/basename.

        Returns selection info on success, None on failure.
        """
        s = (ident or "").strip()
        if not s:
            return None
        self._prune_views()
        # Try id
        w = self._views_by_id.get(s)
        vb = None
        if w is not None:
            try:
                vb = w()
            except Exception:
                vb = None
        # If user passed a 1-based ordinal (from /binaries), map it to filename
        if vb is None and s.isdigit():
            try:
                idx = int(s)
                if idx >= 1:
                    lst = self.list_open_binaries()  # sorted order
                    if 1 <= idx <= len(lst):
                        fname = lst[idx - 1].get("filename")
                        if fname:
                            map_id = self._id_by_filename.get(fname)
                            if map_id:
                                wmap = self._views_by_id.get(map_id)
                                vb = wmap() if wmap else None
            except Exception:
                vb = None
        # Try direct filename mapping
        if vb is None:
            try:
                # Exact filename
                map_id = self._id_by_filename.get(s)
                if map_id:
                    wmap = self._views_by_id.get(map_id)
                    vb = wmap() if wmap else None
            except Exception:
                vb = None
        if vb is None:
            # Try match by full filename or basename
            for vid, w2 in self._views_by_id.items():
                try:
                    v = w2()
                except Exception:
                    v = None
                if v is None:
                    continue
                try:
                    fn = v.file.filename
                except Exception:
                    fn = None
                if not fn:
                    continue
                import os as _os

                if s == fn or s == _os.path.basename(fn):
                    vb = v
                    break
        if vb is None:
            return None
        self.current_view = vb
        vid = None
        for k, wv in self._views_by_id.items():
            try:
                vv = wv()
            except Exception:
                vv = None
            if vv is vb:
                vid = k
                break
        return {"id": vid or "", "filename": getattr(vb.file, "filename", "(unknown)")}

    def get_function_by_name_or_address(self, identifier: str | int) -> bn.Function | None:
        """Get a function by either its name or address.

        Args:
            identifier: Function name or address (can be int, hex string, or decimal string)

        Returns:
            Function object if found, None otherwise
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        # Handle address-based lookup
        try:
            if isinstance(identifier, str) and identifier.startswith("0x"):
                addr = int(identifier, 16)
            elif isinstance(identifier, (int, str)):
                addr = int(identifier) if isinstance(identifier, str) else identifier

            func = self._current_view.get_function_at(addr)
            if func:
                bn.log_info(f"Found function at address {hex(addr)}: {func.name}")
                return func
        except ValueError:
            pass

        # Handle name-based lookup with case sensitivity
        for func in self._current_view.functions:
            if func.name == identifier:
                bn.log_info(f"Found function by name: {func.name}")
                return func

        # Try case-insensitive match as fallback
        for func in self._current_view.functions:
            if func.name.lower() == str(identifier).lower():
                bn.log_info(f"Found function by case-insensitive name: {func.name}")
                return func

        # Try symbol table lookup as last resort
        symbol = self._current_view.get_symbol_by_raw_name(str(identifier))
        if symbol and symbol.address:
            func = self._current_view.get_function_at(symbol.address)
            if func:
                bn.log_info(f"Found function through symbol lookup: {func.name}")
                return func

        bn.log_error(f"Could not find function: {identifier}")
        return None

    def get_function_names(self, offset: int = 0, limit: int = 100) -> list[dict[str, str]]:
        """Get list of function names with addresses"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        functions = []
        for func in self._current_view.functions:
            functions.append(
                {
                    "name": func.name,
                    "address": hex(func.start),
                    "raw_name": func.raw_name if hasattr(func, "raw_name") else func.name,
                }
            )

        return functions[offset : offset + limit]

    def get_class_names(self, offset: int = 0, limit: int = 100) -> list[str]:
        """Get list of class names with pagination"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        class_names = set()

        try:
            # Try different methods to identify classes
            for type_obj in self._current_view.types.values():
                try:
                    # Skip None or invalid types
                    if not type_obj or not hasattr(type_obj, "name"):
                        continue

                    # Method 1: Check type_class attribute
                    if hasattr(type_obj, "type_class"):
                        class_names.add(type_obj.name)
                        continue

                    # Method 2: Check structure attribute
                    if hasattr(type_obj, "structure") and type_obj.structure:
                        structure = type_obj.structure

                        # Check various attributes that indicate a class
                        if any(
                            hasattr(structure, attr)
                            for attr in [
                                "vtable",
                                "base_structures",
                                "members",
                                "functions",
                            ]
                        ):
                            class_names.add(type_obj.name)
                            continue

                        # Check type attribute if available
                        if hasattr(structure, "type"):
                            type_str = str(structure.type).lower()
                            if "class" in type_str or "struct" in type_str:
                                class_names.add(type_obj.name)
                                continue

                except Exception as e:
                    bn.log_debug(
                        f"Error processing type {getattr(type_obj, 'name', '<unknown>')}: {e}"
                    )
                    continue

            bn.log_info(f"Found {len(class_names)} classes")
            sorted_names = sorted(list(class_names))
            return sorted_names[offset : offset + limit]

        except Exception as e:
            bn.log_error(f"Error getting class names: {e}")
            return []

    def get_segments(self, offset: int = 0, limit: int = 100) -> list[dict[str, Any]]:
        """Get list of segments with pagination"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        segments = []
        for segment in self._current_view.segments:
            segment_info = {
                "start": hex(segment.start),
                "end": hex(segment.end),
                "name": "",
                "flags": [],
            }

            # Try to get segment name if available
            if hasattr(segment, "name"):
                segment_info["name"] = segment.name
            elif hasattr(segment, "data_name"):
                segment_info["name"] = segment.data_name

            # Try to get segment flags safely
            if hasattr(segment, "flags"):
                try:
                    if isinstance(segment.flags, (list, tuple)):
                        segment_info["flags"] = list(segment.flags)
                    else:
                        segment_info["flags"] = [str(segment.flags)]
                except (AttributeError, TypeError, ValueError):
                    pass

            # Add segment permissions if available
            if hasattr(segment, "readable"):
                segment_info["readable"] = bool(segment.readable)
            if hasattr(segment, "writable"):
                segment_info["writable"] = bool(segment.writable)
            if hasattr(segment, "executable"):
                segment_info["executable"] = bool(segment.executable)

            segments.append(segment_info)

        return segments[offset : offset + limit]

    def get_sections(self, offset: int = 0, limit: int = 100) -> list[dict[str, Any]]:
        """Get list of sections with pagination.

        Returns per-section fields when available:
        - name: section name
        - start/end: hex strings
        - size: integer number of bytes (end - start)
        - type: stringified section type (if exposed by BN)
        - semantics: stringified semantics (if exposed by BN)
        - linked_section: related/paired section name if exposed
        - alignment: alignment in bytes if exposed
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        results: list[dict[str, Any]] = []

        # Binary Ninja has exposed sections across versions either as an
        # iterable of Section objects or a dict-like object. Handle both.
        try:
            sec_container = getattr(self._current_view, "sections", None)
        except Exception:
            sec_container = None
        if not sec_container:
            return []

        def _iter_sections(container):
            try:
                # If it's a dict-like {name: Section}
                if hasattr(container, "items"):
                    for _name, _sec in list(container.items()):
                        yield _sec
                    return
            except Exception:
                pass
            # Otherwise assume it's iterable of Section objects
            try:
                for _sec in list(container):
                    yield _sec
            except Exception:
                return

        for sec in _iter_sections(sec_container):
            try:
                start = getattr(sec, "start", None)
                end = getattr(sec, "end", None)
                if start is None or end is None:
                    continue
                name = None
                try:
                    name = getattr(sec, "name", None)
                except Exception:
                    name = None
                try:
                    size = int(end) - int(start)
                except Exception:
                    size = None

                entry: dict[str, Any] = {
                    "name": name or "",
                    "start": hex(int(start)),
                    "end": hex(int(end)),
                    "size": size,
                }

                # Optional attributes: type, semantics, linked_section, alignment
                for attr, key in (
                    ("type", "type"),
                    ("semantics", "semantics"),
                    ("linked_section", "linked_section"),
                    ("align", "alignment"),
                    ("alignment", "alignment"),
                ):
                    try:
                        val = getattr(sec, attr, None)
                        if val is not None:
                            entry[key] = str(val)
                    except Exception:
                        pass

                results.append(entry)
            except Exception:
                continue

        return results[offset : offset + limit]

    def rename_function(self, old_name: str, new_name: str) -> bool:
        """Rename a function using multiple fallback methods.

        Args:
            old_name: Current function name or address
            new_name: New name for the function

        Returns:
            True if rename succeeded, False otherwise
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            func = self.get_function_by_name_or_address(old_name)
            if not func:
                bn.log_error(f"Function not found: {old_name}")
                return False

            bn.log_info(f"Found function to rename: {func.name} at {hex(func.start)}")

            if not new_name or not isinstance(new_name, str):
                bn.log_error(f"Invalid new name: {new_name}")
                return False

            if not hasattr(func, "name") or not hasattr(func, "__setattr__"):
                bn.log_error(f"Function {func.name} cannot be renamed (read-only)")
                return False

            try:
                # Try direct name assignment first
                old_name = func.name
                func.name = new_name

                if func.name == new_name:
                    bn.log_info(f"Successfully renamed function from {old_name} to {new_name}")
                    return True

                # Try symbol-based renaming if direct assignment fails
                if hasattr(func, "symbol") and func.symbol:
                    try:
                        new_symbol = bn.Symbol(
                            func.symbol.type,
                            func.start,
                            new_name,
                            namespace=func.symbol.namespace
                            if hasattr(func.symbol, "namespace")
                            else None,
                        )
                        self._current_view.define_user_symbol(new_symbol)
                        bn.log_info("Successfully renamed function using symbol table")
                        return True
                    except Exception as e:
                        bn.log_error(f"Symbol-based rename failed: {e}")

                # Try function update method as last resort
                if hasattr(self._current_view, "update_function"):
                    try:
                        func_copy = func
                        func_copy.name = new_name
                        self._current_view.update_function(func)
                        bn.log_info("Successfully renamed function using update method")
                        return True
                    except Exception as e:
                        bn.log_error(f"Function update rename failed: {e}")

                bn.log_error(f"All rename methods failed - function name unchanged: {func.name}")
                return False

            except Exception as e:
                bn.log_error(f"Error during rename operation: {e}")
                return False

        except Exception as e:
            bn.log_error(f"Error in rename_function: {e}")
            return False

    def get_function_info(self, identifier: str | int) -> dict[str, Any] | None:
        """Get detailed information about a function"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        func = self.get_function_by_name_or_address(identifier)
        if not func:
            return None

        bn.log_info(f"Found function: {func.name} at {hex(func.start)}")

        info = {
            "name": func.name,
            "raw_name": func.raw_name if hasattr(func, "raw_name") else func.name,
            "address": hex(func.start),
            "symbol": None,
        }

        if func.symbol:
            info["symbol"] = {
                "type": str(func.symbol.type),
                "full_name": func.symbol.full_name
                if hasattr(func.symbol, "full_name")
                else func.symbol.name,
            }

        return info

    def decompile_function(self, identifier: str | int) -> str | None:
        """Decompile a function and include addresses per statement.

        Args:
            identifier: Function name or address

        Returns:
            Decompiled HLIL-like code with address prefixes per line
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        func = self.get_function_by_name_or_address(identifier)
        if not func:
            return None

        # analyze func in case it was skipped
        func.analysis_skipped = False
        self._current_view.update_analysis_and_wait()

        try:
            il = getattr(func, "hlil", None)
            if il and hasattr(il, "instructions"):
                lines: list[str] = []
                last_addr: int | None = None
                for ins in il.instructions:
                    try:
                        addr = getattr(ins, "address", None)
                    except Exception:
                        addr = None
                    if addr is None:
                        addr = last_addr if last_addr is not None else func.start
                    last_addr = addr
                    addr_str = f"{int(addr):08x}"
                    text = str(ins)
                    lines.append(f"{addr_str}        {text}")
                return "\n".join(lines)
            # Fall back to MLIL with addresses
            mil = getattr(func, "mlil", None)
            if mil and hasattr(mil, "instructions"):
                lines: list[str] = []
                last_addr: int | None = None
                for ins in mil.instructions:
                    try:
                        addr = getattr(ins, "address", None)
                    except Exception:
                        addr = None
                    if addr is None:
                        addr = last_addr if last_addr is not None else func.start
                    last_addr = addr
                    addr_str = f"{int(addr):08x}"
                    text = str(ins)
                    lines.append(f"{addr_str}        {text}")
                return "\n".join(lines)
            # Last resort
            return str(func)
        except Exception as e:
            bn.log_error(f"Error decompiling function: {e!s}")
            return None

    def get_function_il(
        self, identifier: str | int, view: str = "hlil", ssa: bool = False
    ) -> str | None:
        """Return IL for a function with selectable view and optional SSA form.

        Args:
            identifier: Function name or address
            view: One of 'hlil', 'mlil', 'llil' (case-insensitive). Aliases: 'il' -> 'llil'.
            ssa: When True, use SSA form if available (MLIL/LLIL only)

        Returns:
            Concatenated string with one instruction per line prefixed by address.
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        func = self.get_function_by_name_or_address(identifier)
        if not func:
            return None

        # Ensure analysis has run for this function
        try:
            func.analysis_skipped = False
            self._current_view.update_analysis_and_wait()
        except Exception:
            pass

        v = (view or "").strip().lower()
        if v in ("il", "llil", "low", "lowlevel", "low-level", "low_level"):
            prop = "llil"
        elif v in ("mlil", "medium", "mediumlevel", "medium-level", "medium_level"):
            prop = "mlil"
        else:
            # Default to HLIL when unknown
            prop = "hlil"

        try:
            il_func = getattr(func, prop, None)
            if il_func is None:
                return None

            # Only MLIL/LLIL support SSA form in practice
            if ssa and hasattr(il_func, "ssa_form") and il_func.ssa_form is not None:
                il_func = il_func.ssa_form

            if not hasattr(il_func, "instructions"):
                # As a last resort, stringify the object
                return str(il_func)

            lines: list[str] = []
            last_addr: int | None = None
            for ins in il_func.instructions:
                try:
                    addr = getattr(ins, "address", None)
                except Exception:
                    addr = None
                if addr is None:
                    addr = last_addr if last_addr is not None else func.start
                last_addr = addr
                addr_str = f"{int(addr):08x}"
                text = str(ins)
                lines.append(f"{addr_str}        {text}")
            return "\n".join(lines)
        except Exception as e:
            bn.log_error(
                f"Error getting {prop}{' SSA' if ssa else ''} for function {identifier}: {e!s}"
            )
            return None

    def rename_data(self, address: int, new_name: str) -> bool:
        """Rename data at a specific address"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            if self._current_view.is_valid_offset(address):
                self._current_view.define_user_symbol(
                    bn.Symbol(bn.SymbolType.DataSymbol, address, new_name)
                )
                return True
        except Exception as e:
            bn.log_error(f"Failed to rename data: {e}")
        return False

    def make_function_at(
        self, address: str | int, architecture: str | None = None
    ) -> dict[str, Any]:
        """Create a function at the given address (no-op if it already exists).

        Args:
            address: Hex string (e.g., 0x401000) or integer address.
            architecture: Optional architecture name (e.g., "x86_64", "x86", "armv7").

        Returns:
            Dict with keys: status (ok|exists), address, name (if found), architecture (if resolved).

        Raises:
            RuntimeError if no binary is loaded.
            ValueError on invalid address or creation failure.
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        # Parse address
        try:
            if isinstance(address, str) and address.lower().startswith("0x"):
                addr = int(address, 16)
            else:
                addr = int(address)
        except Exception:
            raise ValueError(f"Invalid address: {address}")

        bv = self._current_view

        # If a function already exists, return info
        try:
            existing = bv.get_function_at(addr)
            if existing:
                return {
                    "status": "exists",
                    "address": hex(addr),
                    "name": existing.name,
                    "architecture": str(getattr(existing, "arch", getattr(bv, "arch", ""))) or None,
                }
        except Exception:
            pass

        # Resolve platform if provided; otherwise use view/platform default.
        # Note: BinaryView.create_user_function expects a Platform, not an Architecture.
        plat_obj = None
        arch_token = None
        if isinstance(architecture, str):
            arch_token = architecture.strip().lower()
        if architecture and arch_token not in (None, "", "default", "auto", "platform"):
            try:
                P = getattr(__import__("binaryninja", fromlist=["Platform"]), "Platform", None)
            except Exception:
                P = None
            if P is not None:
                try:
                    plat_obj = P[architecture]
                except Exception:
                    try:
                        getp = getattr(P, "get_by_name", None)
                        if callable(getp):
                            plat_obj = getp(architecture)
                    except Exception:
                        plat_obj = None
            # If user explicitly provided an architecture/platform name and we couldn't resolve it,
            # return an error with suggestions instead of silently using the default.
            if plat_obj is None:
                import re as _re
                from difflib import get_close_matches as _gcm

                names: list[str] = []
                # Prefer dynamic enumeration via binaryninja.Platform
                try:
                    import binaryninja as _bn  # type: ignore

                    try:
                        names = [
                            str(getattr(p, "name", str(p))) for p in list(getattr(_bn, "Platform"))
                        ]
                    except Exception:
                        names = []
                except Exception:
                    names = []
                # Fallback: try iterating via imported P if available
                if not names and P is not None:
                    try:
                        names = [str(getattr(p, "name", str(p))) for p in list(P)]
                    except Exception:
                        names = []
                # Last resort: static catalog (kept up-to-date best-effort)
                if not names:
                    names = [
                        "decree-x86",
                        "efi-x86",
                        "efi-windows-x86",
                        "efi-x86_64",
                        "efi-windows-x86_64",
                        "efi-aarch64",
                        "efi-windows-aarch64",
                        "efi-armv7",
                        "efi-thumb2",
                        "freebsd-x86",
                        "freebsd-x86_64",
                        "freebsd-aarch64",
                        "freebsd-armv7",
                        "freebsd-thumb2",
                        "ios-aarch64",
                        "ios-armv7",
                        "ios-thumb2",
                        "ios-kernel-aarch64",
                        "ios-kernel-armv7",
                        "ios-kernel-thumb2",
                        "linux-ppc32",
                        "linux-ppcvle32",
                        "linux-ppc64",
                        "linux-ppc32_le",
                        "linux-ppc64_le",
                        "linux-rv32gc",
                        "linux-rv64gc",
                        "linux-x86",
                        "linux-x86_64",
                        "linux-x32",
                        "linux-aarch64",
                        "linux-armv7",
                        "linux-thumb2",
                        "linux-armv7eb",
                        "linux-thumb2eb",
                        "linux-mipsel",
                        "linux-mips",
                        "linux-mips3",
                        "linux-mipsel3",
                        "linux-mips64",
                        "linux-cnmips64",
                        "linux-mipsel64",
                        "mac-x86",
                        "mac-x86_64",
                        "mac-aarch64",
                        "mac-armv7",
                        "mac-thumb2",
                        "mac-kernel-x86",
                        "mac-kernel-x86_64",
                        "mac-kernel-aarch64",
                        "mac-kernel-armv7",
                        "mac-kernel-thumb2",
                        "windows-x86",
                        "windows-x86_64",
                        "windows-aarch64",
                        "windows-armv7",
                        "windows-thumb2",
                        "windows-kernel-x86",
                        "windows-kernel-x86_64",
                        "windows-kernel-windows-aarch64",
                    ]
                # Build ranked suggestions
                tl = (arch_token or "").lower()

                def _score(n: str) -> float:
                    nl = n.lower()
                    s = 0.0
                    if tl and tl in nl:
                        s += 2.0
                    # remove non-alnum for loose matching
                    tlr = _re.sub(r"[^a-z0-9]", "", tl)
                    nlr = _re.sub(r"[^a-z0-9]", "", nl)
                    if tlr and tlr in nlr:
                        s += 1.0
                    return s

                base = sorted(names)
                # Start with substring matches, then extend with close matches
                substr = [n for n in base if tl in n.lower()]
                # Use difflib for additional candidates if needed
                extra = _gcm(tl, base, n=10, cutoff=0.3) if tl else []
                cand = []
                seen = set()
                for n in substr + extra:
                    if n not in seen:
                        seen.add(n)
                        cand.append(n)
                cand.sort(key=_score, reverse=True)
                cand[:10]
                raise ValueError(f"Unknown platform/architecture '{architecture}'")
        # Default/platform fallback when no explicit architecture provided
        if plat_obj is None:
            try:
                plat_obj = getattr(bv, "platform", None)
            except Exception:
                plat_obj = None

        # Create the function
        try:
            if hasattr(bv, "create_user_function"):
                if plat_obj is not None:
                    bv.create_user_function(addr, plat_obj)
                else:
                    bv.create_user_function(addr)
            elif hasattr(bv, "add_function"):
                if plat_obj is not None:
                    bv.add_function(addr, plat_obj)
                else:
                    bv.add_function(addr)
            else:
                raise ValueError("BinaryView does not support function creation")
        except Exception as e:
            raise ValueError(f"Failed to create function: {e!s}")

        # Fetch created function info
        try:
            fn = bv.get_function_at(addr)
        except Exception:
            fn = None
        return {
            "status": "ok",
            "address": hex(addr),
            "name": fn.name if fn else None,
            "platform": str(plat_obj) if plat_obj is not None else None,
            "architecture": str(getattr(plat_obj, "arch", None))
            if plat_obj is not None
            else (
                str(getattr(bv, "arch", None)) if getattr(bv, "arch", None) is not None else None
            ),
        }

    def get_defined_data(
        self, offset: int = 0, limit: int = 100, read_len: int = 32
    ) -> list[dict[str, Any]]:
        """Get list of defined data variables with lightweight previews and sizes.

        Returns per-item fields:
        - address: hex string
        - name/raw_name: label info if available
        - type: string if available
        - size: exact defined size in bytes if known (from BN type)
        - width: alias of size for backward compatibility
        - value: small integer value when width<=8 and readable; otherwise None
        - bytes_hex: hex string of up to preview_len bytes
        - ascii_preview: printable ASCII representation for the same bytes
        - repr: concise, human-friendly summary for LLMs (value/ASCII/hex)
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        data_items = []
        for var in self._current_view.data_vars:
            data_type = None  # may be a BN Type or a DataVariable
            value = None
            width = None
            bytes_hex = None
            ascii_preview = None
            typ_obj = None

            try:
                # Prefer DataVariable (carries underlying Type)
                dv = None
                if hasattr(self._current_view, "get_data_var_at"):
                    try:
                        dv = self._current_view.get_data_var_at(var)
                    except Exception:
                        dv = None
                if dv is not None and hasattr(dv, "type") and dv.type is not None:
                    typ_obj = dv.type
                    data_type = dv  # keep for fallback string formatting
                else:
                    # Fall back to direct type lookup
                    if hasattr(self._current_view, "get_type_at"):
                        try:
                            typ_obj = self._current_view.get_type_at(var)
                            data_type = typ_obj
                        except Exception:
                            typ_obj = None

                # Exact defined size if available
                if typ_obj is not None and hasattr(typ_obj, "width"):
                    try:
                        width = int(typ_obj.width)
                    except Exception:
                        width = None

                # Best-effort numeric read for small integers (<= 8 bytes)
                if width is not None and width <= 8:
                    try:
                        value = str(self._current_view.read_int(var, width))
                    except (ValueError, RuntimeError):
                        value = None

                # Provide bytes + ASCII preview for all cases
                # Determine effective read length
                try:
                    requested = int(read_len)
                except Exception:
                    requested = 32
                # If requested < 0 and width known, treat as "read exact size"
                if requested < 0 and width is not None:
                    eff_len = max(0, int(width))
                else:
                    eff_len = max(0, requested if requested >= 0 else 32)
                if width is not None:
                    eff_len = min(eff_len, int(width))

                try:
                    raw = self._current_view.read(var, eff_len)
                    if raw is not None:
                        try:
                            bytes_hex = raw.hex()
                        except Exception:
                            bytes_hex = None
                        try:
                            ascii_preview = "".join(chr(b) if 32 <= b <= 126 else "." for b in raw)
                        except Exception:
                            ascii_preview = None
                except (ValueError, RuntimeError, TypeError):
                    pass
            except (AttributeError, TypeError, ValueError, RuntimeError):
                value = None
                data_type = None
                typ_obj = None

            # If BN doesn't expose a width, try to infer size from call sites
            if width is None:
                try:
                    inferred = self.infer_data_size(int(var))
                    if isinstance(inferred, int) and inferred > 0:
                        width = inferred
                except Exception:
                    pass

            # Get symbol information
            sym = self._current_view.get_symbol_at(var)
            # Choose a concise repr for LLMs
            if value is not None:
                short_repr = f"int:{value}"
            elif ascii_preview:
                short_repr = f'ascii:"{ascii_preview}"'
            elif bytes_hex:
                short_repr = f"hex:{bytes_hex}"
            else:
                short_repr = None

            data_items.append(
                {
                    "address": hex(var),
                    "name": sym.name if sym else "(unnamed)",
                    "raw_name": sym.raw_name if sym and hasattr(sym, "raw_name") else None,
                    # Prefer clean type string (avoid "<var ...>" envelope when possible)
                    "type": (
                        str(typ_obj)
                        if typ_obj is not None
                        else (str(data_type) if data_type else None)
                    ),
                    "size": width,
                    "width": width,
                    "value": value,
                    "bytes_hex": bytes_hex,
                    "ascii_preview": ascii_preview,
                    "bytes_read": len(bytes_hex) // 2 if bytes_hex else 0,
                    "repr": short_repr,
                }
            )

        return data_items[offset : offset + limit]

    def infer_data_size(self, address: int) -> int | None:
        """Infer size for data at address when BN hasn't defined a type width.

        Strategy:
        - Prefer BN's DataVariable.type.width or get_type_at().width if available.
        - Otherwise scan HLIL for calls like memcmp/strncmp/memcpy/strncpy where
          an argument equals this address and extract the last numeric argument
          as a best-effort length. Returns the maximum constant seen.
        """
        if not self._current_view:
            return None

        # 1) BN-provided width if available
        try:
            dv = None
            if hasattr(self._current_view, "get_data_var_at"):
                dv = self._current_view.get_data_var_at(address)
            t = None
            if dv is not None and hasattr(dv, "type"):
                t = dv.type
            elif hasattr(self._current_view, "get_type_at"):
                t = self._current_view.get_type_at(address)
            if t is not None and hasattr(t, "width") and t.width:
                return int(t.width)
        except Exception:
            pass

        # 2) HLIL heuristic
        try:
            addr_hex = hex(address)
            candidates: list[int] = []
            names = ("memcmp", "strncmp", "memcpy", "strncpy")
            for func in list(self._current_view.functions):
                try:
                    il = getattr(func, "hlil", None)
                    if not il:
                        continue
                    for ins in il.instructions:
                        try:
                            text = str(ins)
                            if addr_hex not in text:
                                continue
                            if not any(n in text for n in names):
                                continue
                            # Extract all numeric constants
                            nums = re.findall(r"0x[0-9a-fA-F]+|\b\d+\b", text)
                            vals: list[int] = []
                            for n in nums:
                                try:
                                    v = int(n, 16) if n.startswith("0x") else int(n)
                                    vals.append(v)
                                except Exception:
                                    continue
                            if vals:
                                # Heuristic: last constant in call string is likely the size
                                candidates.append(vals[-1])
                        except Exception:
                            continue
                except Exception:
                    continue
            if candidates:
                # Use the maximum plausible size
                best = max(c for c in candidates if c > 0)
                if best > 0:
                    return best
        except Exception:
            pass
        return None

    def list_local_types(
        self, offset: int = 0, limit: int = 100, include_libraries: bool = False
    ) -> list[dict[str, Any]]:
        """List local types (Types view) in the current database.

        Returns a list of dictionaries with:
        - name: type name
        - kind: struct/union/class/enum/typedef/unknown
        - decl: string form of the type (when available)
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        results: list[dict[str, Any]] = []
        seen_keys = set()
        try:

            def add_type_entry(name, tobj):
                # Normalize name to string to avoid BN QualifiedName in JSON
                try:
                    name_str = str(name) if name is not None else None
                except Exception:
                    name_str = None
                if not name_str:
                    return
                # Fallback: try to resolve missing type object by querying BV / libraries
                if tobj is None:
                    try:
                        if hasattr(self._current_view, "get_type_by_name"):
                            t2 = self._current_view.get_type_by_name(name_str)
                            if t2 is not None:
                                tobj = t2
                    except Exception:
                        pass
                    if tobj is None:
                        try:
                            plat = getattr(self._current_view, "platform", None)
                            libs = list(getattr(plat, "type_libraries", []) or []) if plat else []
                            for lib in libs:
                                get_t = getattr(lib, "get_type_by_name", None)
                                if not callable(get_t):
                                    continue
                                t3 = None
                                try:
                                    # Try QualifiedName if available
                                    try:
                                        t3 = get_t(bn.QualifiedName(name_str))
                                    except Exception:
                                        t3 = get_t(name_str)
                                except Exception:
                                    t3 = None
                                if t3 is not None:
                                    tobj = t3
                                    break
                        except Exception:
                            pass

                tc = getattr(tobj, "type_class", None)
                kind = "unknown"
                if tc == TypeClass.VoidTypeClass:
                    kind = "void"
                elif tc == TypeClass.BoolTypeClass:
                    kind = "bool"
                elif tc == TypeClass.IntegerTypeClass:
                    kind = "int"
                elif tc == TypeClass.FloatTypeClass:
                    kind = "float"
                elif tc == TypeClass.StructureTypeClass:
                    try:
                        if getattr(tobj, "type", None) == StructureVariant.StructStructureType:
                            kind = "struct"
                        elif getattr(tobj, "type", None) == StructureVariant.UnionStructureType:
                            kind = "union"
                        elif getattr(tobj, "type", None) == StructureVariant.ClassStructureType:
                            kind = "class"
                        else:
                            kind = "struct"
                    except Exception:
                        kind = "struct"
                elif tc == TypeClass.EnumerationTypeClass:
                    kind = "enum"
                elif tc == TypeClass.NamedTypeReferenceClass:
                    kind = "typedef"
                elif tc == TypeClass.FunctionTypeClass:
                    kind = "function"
                elif tc == TypeClass.WideCharTypeClass:
                    kind = "wchar"
                elif tc == TypeClass.PointerTypeClass:
                    kind = "pointer"
                elif tc == TypeClass.ArrayTypeClass:
                    kind = "array"

                decl = None
                try:
                    decl = str(tobj)
                except Exception:
                    try:
                        decl = str(getattr(tobj, "type", None))
                    except Exception:
                        decl = None

                # If kind is unknown or a named typedef, try to infer underlying from declaration text
                try:
                    dlow = (decl or "").strip().lower()
                    if dlow:
                        if dlow.startswith("struct ") or " struct " in dlow:
                            kind = "struct"
                        elif dlow.startswith("union ") or " union " in dlow:
                            kind = "union"
                        elif dlow.startswith("enum ") or " enum " in dlow:
                            kind = "enum"
                except Exception:
                    pass

                key = (name_str, decl or "")
                if key in seen_keys:
                    return
                results.append(
                    {
                        "name": name_str,
                        "kind": kind,
                        "type_class": str(tc) if tc is not None else None,
                        "decl": decl,
                    }
                )
                seen_keys.add(key)

            # Source 1: user_type_container (explicit local/user types)
            try:
                utc = getattr(self._current_view, "user_type_container", None)
                if utc and getattr(utc, "types", None):
                    for type_id in list(utc.types.keys()):
                        try:
                            entry = utc.types[type_id]
                            name = (
                                entry[0]
                                if isinstance(entry, (tuple, list))
                                else getattr(entry, "name", None)
                            )
                            tobj = (
                                entry[1]
                                if isinstance(entry, (tuple, list))
                                else getattr(entry, "type", entry)
                            )
                            add_type_entry(name, tobj)
                        except Exception:
                            continue
            except Exception:
                pass

            # Source 2: view.types (BN view-local types)
            for k, v in self._current_view.types.items():
                try:
                    if isinstance(v, (tuple, list)) and len(v) >= 2:
                        name = str(v[0])
                        tobj = v[1]
                    else:
                        tobj = v
                        name = getattr(v, "name", None)
                        if not name:
                            name = str(k)
                    add_type_entry(name, tobj)
                except Exception:
                    continue

            # Source 3: platform type libraries (optional; can be heavy)
            if include_libraries:
                try:
                    plat = getattr(self._current_view, "platform", None)
                    libs = []
                    try:
                        libs = list(getattr(plat, "type_libraries", []) or [])
                    except Exception:
                        libs = []
                    for lib in libs:
                        # Try multiple ways to enumerate names in this library
                        names = []
                        try:
                            nt = getattr(lib, "named_types", None)
                            if isinstance(nt, dict):
                                names = list(nt.keys())
                        except Exception:
                            pass
                        if not names:
                            try:
                                tmap = getattr(lib, "types", None)
                                if isinstance(tmap, dict):
                                    names = list(tmap.keys())
                            except Exception:
                                pass
                        if not names:
                            try:
                                get_names = getattr(lib, "get_type_names", None)
                                if callable(get_names):
                                    names = list(get_names())
                            except Exception:
                                pass
                        # Fetch each type object if possible
                        for nm in names:
                            try:
                                tobj = None
                                try:
                                    g = getattr(lib, "get_type_by_name", None)
                                    if callable(g):
                                        tobj = g(nm)
                                except Exception:
                                    tobj = None
                                add_type_entry(nm, tobj)
                            except Exception:
                                continue
                except Exception:
                    pass
        except Exception as e:
            bn.log_error(f"Error listing local types: {e}")
        return results[offset : offset + limit]

    def search_local_types(
        self, query: str, offset: int = 0, limit: int = 100, include_libraries: bool = False
    ) -> list[dict[str, Any]]:
        """Search local/view types whose name or declaration contains the substring.

        Returns entries with {name, kind, type_class, decl}.
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")
        if not query:
            return []
        ql = str(query).lower()
        # Only local types by default (fast). Optionally include libraries.
        all_types = self.list_local_types(0, 1_000_000, include_libraries=include_libraries)
        matches: list[dict[str, Any]] = []
        for t in all_types:
            try:
                name = t.get("name") or ""
                decl = t.get("decl") or ""
                if (ql in str(name).lower()) or (ql in str(decl).lower()):
                    matches.append(t)
            except Exception:
                continue
        if isinstance(limit, int) and limit < 0:
            return matches[offset:]
        return matches[offset : offset + limit]

    def get_type_info(self, name: str) -> dict[str, Any]:
        """Resolve a type by name and return detailed information.

        Returns a dictionary with:
        - name: type name
        - kind: struct/union/class/enum/typedef/... (best-effort)
        - decl: declaration string
        - members: for struct/union [{name, type, offset}]
        - enum_members: for enums [{name, value}]
        - underlying: for typedefs, best-effort underlying declaration
        - source: local | library | unknown
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        type_name = str(name)
        tobj = None
        source = "unknown"

        # 1) Try view local resolution first
        try:
            if hasattr(self._current_view, "get_type_by_name"):
                t = self._current_view.get_type_by_name(type_name)
                if t is not None:
                    tobj = t
                    source = "local"
        except Exception:
            pass

        # 2) Fall back to platform type libraries
        if tobj is None:
            try:
                plat = getattr(self._current_view, "platform", None)
                libs = list(getattr(plat, "type_libraries", []) or []) if plat else []
                for lib in libs:
                    get_t = getattr(lib, "get_type_by_name", None)
                    if not callable(get_t):
                        continue
                    try:
                        # Try with QualifiedName if available
                        try:
                            t = get_t(bn.QualifiedName(type_name))
                        except Exception:
                            t = get_t(type_name)
                    except Exception:
                        t = None
                    if t is not None:
                        tobj = t
                        source = "library"
                        break
            except Exception:
                pass

        # Prepare defaults
        kind = "unknown"
        decl = None
        members: list[dict[str, Any]] = []
        enum_members: list[dict[str, Any]] = []
        underlying = None

        # Extract details from type object
        if tobj is not None:
            try:
                decl = str(tobj)
            except Exception:
                try:
                    decl = str(getattr(tobj, "type", None))
                except Exception:
                    decl = None

            tc = getattr(tobj, "type_class", None)
            if tc == TypeClass.StructureTypeClass:
                # structure variant
                try:
                    v = getattr(tobj, "type", None)
                    if v == StructureVariant.UnionStructureType:
                        kind = "union"
                    elif v == StructureVariant.ClassStructureType:
                        kind = "class"
                    else:
                        kind = "struct"
                except Exception:
                    kind = "struct"

                # collect members
                try:
                    for m in getattr(
                        tobj, "members", getattr(getattr(tobj, "structure", None), "members", [])
                    ):
                        try:
                            members.append(
                                {
                                    "name": getattr(m, "name", None),
                                    "type": str(getattr(m, "type", ""))
                                    if hasattr(m, "type")
                                    else None,
                                    "offset": int(getattr(m, "offset", 0))
                                    if hasattr(m, "offset")
                                    else None,
                                }
                            )
                        except Exception:
                            continue
                except Exception:
                    pass

            elif tc == TypeClass.EnumerationTypeClass:
                kind = "enum"
                try:
                    for em in getattr(tobj, "members", []):
                        try:
                            enum_members.append(
                                {
                                    "name": getattr(em, "name", None),
                                    "value": getattr(em, "value", None),
                                }
                            )
                        except Exception:
                            continue
                except Exception:
                    pass

            elif tc == TypeClass.NamedTypeReferenceClass:
                kind = "typedef"
                # best-effort underlying from decl text
                try:
                    dlow = (decl or "").lower()
                    if dlow:
                        if dlow.startswith("struct ") or " struct " in dlow:
                            underlying = "struct"
                        elif dlow.startswith("union ") or " union " in dlow:
                            underlying = "union"
                        elif dlow.startswith("enum ") or " enum " in dlow:
                            underlying = "enum"
                except Exception:
                    pass

            elif tc == TypeClass.IntegerTypeClass:
                kind = "int"
            elif tc == TypeClass.FloatTypeClass:
                kind = "float"
            elif tc == TypeClass.BoolTypeClass:
                kind = "bool"
            elif tc == TypeClass.VoidTypeClass:
                kind = "void"
            elif tc == TypeClass.PointerTypeClass:
                kind = "pointer"
            elif tc == TypeClass.ArrayTypeClass:
                kind = "array"
            elif tc == TypeClass.FunctionTypeClass:
                kind = "function"

            # Infer kind from decl if still unknown
            if kind == "unknown" and decl:
                try:
                    dl = decl.lower()
                    if dl.startswith("struct ") or " struct " in dl:
                        kind = "struct"
                    elif dl.startswith("union ") or " union " in dl:
                        kind = "union"
                    elif dl.startswith("enum ") or " enum " in dl:
                        kind = "enum"
                except Exception:
                    pass

        return {
            "name": type_name,
            "kind": kind,
            "decl": decl,
            "members": members if members else None,
            "enum_members": enum_members if enum_members else None,
            "underlying": underlying,
            "source": source,
        }

    def get_strings(self, offset: int = 0, limit: int = 100) -> list[dict[str, Any]]:
        """Get list of strings in the current binary view with pagination.

        Returns a list of dictionaries containing:
        - address: start address of the string (hex)
        - length: length in bytes (int if available)
        - type: Binary Ninja string type (str if available)
        - value: best-effort decoded and escaped string value
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        results: list[dict[str, Any]] = []

        try:
            # Prefer modern API if available
            strings_iter = None
            if hasattr(self._current_view, "get_strings"):
                try:
                    strings_iter = self._current_view.get_strings()
                except TypeError:
                    strings_iter = None

            if strings_iter is None and hasattr(self._current_view, "strings"):
                try:
                    strings_iter = list(self._current_view.strings)
                except Exception:
                    strings_iter = []

            if strings_iter is None:
                strings_iter = []

            for s in strings_iter:
                try:
                    addr = None
                    length = None
                    stype = None
                    value = None

                    # Common attributes on StringReference
                    addr = getattr(s, "start", getattr(s, "address", None))
                    length = getattr(s, "length", None)
                    stype = getattr(s, "type", None)
                    if stype is not None:
                        try:
                            stype = str(stype)
                        except Exception:
                            stype = str(stype)

                    value = getattr(s, "value", None)

                    # Best-effort read/decode if value is not present
                    if value is None and addr is not None and length is not None:
                        try:
                            raw = self._current_view.read(addr, length)
                            # Stop at first null byte if present
                            nul = raw.find(b"\x00")
                            if nul != -1:
                                raw = raw[:nul]
                            try:
                                value = raw.decode("utf-8", errors="ignore")
                            except Exception:
                                value = raw.decode("latin-1", errors="ignore")
                        except Exception:
                            value = None

                    # Ensure value is a string and escape non-ASCII
                    if value is None:
                        value = ""
                    value = escape_non_ascii(str(value))

                    results.append(
                        {
                            "address": hex(addr)
                            if isinstance(addr, int)
                            else (str(addr) if addr is not None else None),
                            "length": int(length)
                            if isinstance(length, (int,))
                            else (None if length is None else int(length)),
                            "type": stype,
                            "value": value,
                        }
                    )
                except Exception as e:
                    # Keep collecting even if one entry fails
                    bn.log_debug(f"Error processing string entry: {e}")
                    continue

            return results[offset : offset + limit]
        except Exception as e:
            bn.log_error(f"Error getting strings: {e}")
            return []

    def set_comment(self, address: int, comment: str) -> bool:
        """Set a comment at a specific address.

        Args:
            address: The address to set the comment at
            comment: The comment text to set

        Returns:
            True if the comment was set successfully, False otherwise
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            if not self._current_view.is_valid_offset(address):
                bn.log_error(f"Invalid address for comment: {hex(address)}")
                return False

            self._current_view.set_comment_at(address, comment)
            bn.log_info(f"Set comment at {hex(address)}: {comment}")
            return True
        except Exception as e:
            bn.log_error(f"Failed to set comment: {e}")
            return False

    def set_function_comment(self, identifier: str | int, comment: str) -> bool:
        """Set a comment for a function.

        Args:
            identifier: Function name or address
            comment: The comment text to set

        Returns:
            True if the comment was set successfully, False otherwise
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            func = self.get_function_by_name_or_address(identifier)
            if not func:
                bn.log_error(f"Function not found: {identifier}")
                return False

            self._current_view.set_comment_at(func.start, comment)
            bn.log_info(f"Set comment for function {func.name} at {hex(func.start)}: {comment}")
            return True
        except Exception as e:
            bn.log_error(f"Failed to set function comment: {e}")
            return False

    def get_comment(self, address: int) -> str | None:
        """Get the comment at a specific address.

        Args:
            address: The address to get the comment from

        Returns:
            The comment text if found, None otherwise
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            if not self._current_view.is_valid_offset(address):
                bn.log_error(f"Invalid address for comment: {hex(address)}")
                return None

            comment = self._current_view.get_comment_at(address)
            return comment if comment else None
        except Exception as e:
            bn.log_error(f"Failed to get comment: {e}")
            return None

    def get_function_comment(self, identifier: str | int) -> str | None:
        """Get the comment for a function.

        Args:
            identifier: Function name or address

        Returns:
            The comment text if found, None otherwise
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            func = self.get_function_by_name_or_address(identifier)
            if not func:
                bn.log_error(f"Function not found: {identifier}")
                return None

            comment = self._current_view.get_comment_at(func.start)
            return comment if comment else None
        except Exception as e:
            bn.log_error(f"Failed to get function comment: {e}")
            return None

    def delete_comment(self, address: int) -> bool:
        """Delete a comment at a specific address"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            if self._current_view.is_valid_offset(address):
                self._current_view.set_comment_at(address, None)
                return True
        except Exception as e:
            bn.log_error(f"Failed to delete comment: {e}")
        return False

    def delete_function_comment(self, identifier: str | int) -> bool:
        """Delete a comment for a function"""
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            func = self.get_function_by_name_or_address(identifier)
            if not func:
                return False

            func.comment = None
            return True
        except Exception as e:
            bn.log_error(f"Failed to delete function comment: {e}")
        return False

    # set_integer_display removed per request

    def get_assembly_function(self, identifier: str | int) -> str | None:
        """Get the assembly representation of a function with practical annotations.

        Args:
            identifier: Function name or address

        Returns:
            Assembly code as string, or None if the function cannot be found
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            func = self.get_function_by_name_or_address(identifier)
            if not func:
                bn.log_error(f"Function not found: {identifier}")
                return None

            bn.log_info(f"Found function: {func.name} at {hex(func.start)}")

            var_map = {}  # TODO: Implement this functionality (issues with var.storage not returning the correst sp offset)
            assembly_blocks = {}

            if not hasattr(func, "basic_blocks") or not func.basic_blocks:
                bn.log_error(f"Function {func.name} has no basic blocks")
                # Try alternate approach with linear disassembly
                start_addr = func.start
                try:
                    func_length = func.total_bytes
                    if func_length <= 0:
                        func_length = 1024  # Use a reasonable default if length not available
                except Exception:
                    func_length = 1024  # Use a reasonable default if error

                try:
                    # Create one big block for the entire function
                    block_lines = []
                    current_addr = start_addr
                    end_addr = start_addr + func_length

                    while current_addr < end_addr:
                        try:
                            # Get instruction length
                            instr_len = self._current_view.get_instruction_length(current_addr)
                            if instr_len <= 0:
                                instr_len = 4  # Default to a reasonable instruction length

                            # Get disassembly for this instruction
                            line = self._get_instruction_with_annotations(
                                current_addr, instr_len, var_map
                            )
                            if line:
                                block_lines.append(line)

                            current_addr += instr_len
                        except Exception as e:
                            bn.log_error(f"Error processing address {hex(current_addr)}: {e!s}")
                            block_lines.append(f"# Error at {hex(current_addr)}: {e!s}")
                            current_addr += 1  # Skip to next byte

                    assembly_blocks[start_addr] = [
                        f"# Block at {hex(start_addr)}",
                        *block_lines,
                        "",
                    ]

                except Exception as e:
                    bn.log_error(f"Linear disassembly failed: {e!s}")
                    return None
            else:
                for i, block in enumerate(func.basic_blocks):
                    try:
                        block_lines = []

                        # Process each address in the block
                        addr = block.start
                        while addr < block.end:
                            try:
                                instr_len = self._current_view.get_instruction_length(addr)
                                if instr_len <= 0:
                                    instr_len = 4  # Default to a reasonable instruction length

                                # Get disassembly for this instruction
                                line = self._get_instruction_with_annotations(
                                    addr, instr_len, var_map
                                )
                                if line:
                                    block_lines.append(line)

                                addr += instr_len
                            except Exception as e:
                                bn.log_error(f"Error processing address {hex(addr)}: {e!s}")
                                block_lines.append(f"# Error at {hex(addr)}: {e!s}")
                                addr += 1  # Skip to next byte

                        # Store block with its starting address as key
                        assembly_blocks[block.start] = [
                            f"# Block {i + 1} at {hex(block.start)}",
                            *block_lines,
                            "",
                        ]

                    except Exception as e:
                        bn.log_error(f"Error processing block {i + 1} at {hex(block.start)}: {e!s}")
                        assembly_blocks[block.start] = [
                            f"# Error processing block {i + 1} at {hex(block.start)}: {e!s}",
                            "",
                        ]

            # Sort blocks by address and concatenate them
            sorted_blocks = []
            for addr in sorted(assembly_blocks.keys()):
                sorted_blocks.extend(assembly_blocks[addr])

            return "\n".join(sorted_blocks)
        except Exception as e:
            bn.log_error(f"Error getting assembly for function {identifier}: {e!s}")
            import traceback

            bn.log_error(traceback.format_exc())
            return None

    def _get_instruction_with_annotations(
        self, addr: int, instr_len: int, var_map: dict[int, str]
    ) -> str | None:
        """Get a single instruction with practical annotations.

        Args:
            addr: Address of the instruction
            instr_len: Length of the instruction
            var_map: Dictionary mapping offsets to variable names

        Returns:
            Formatted instruction string with annotations
        """
        if not self._current_view:
            return None

        try:
            # Get raw bytes for fallback
            try:
                raw_bytes = self._current_view.read(addr, instr_len)
                hex_bytes = " ".join(f"{b:02x}" for b in raw_bytes)
            except Exception:
                hex_bytes = "??"

            # Get basic disassembly
            disasm_text = ""
            try:
                if hasattr(self._current_view, "get_disassembly"):
                    disasm = self._current_view.get_disassembly(addr)
                    if disasm:
                        disasm_text = disasm
            except Exception:
                disasm_text = hex_bytes + " ; [Raw bytes]"

            if not disasm_text:
                disasm_text = hex_bytes + " ; [Raw bytes]"

            # Check if this is a call instruction and try to get target function name
            if "call" in disasm_text.lower():
                try:
                    # Extract the address from the call instruction
                    import re

                    addr_pattern = r"0x[0-9a-fA-F]+"
                    match = re.search(addr_pattern, disasm_text)
                    if match:
                        call_addr_str = match.group(0)
                        call_addr = int(call_addr_str, 16)

                        # Look up the target function name
                        sym = self._current_view.get_symbol_at(call_addr)
                        if sym and hasattr(sym, "name"):
                            # Replace the address with the function name
                            disasm_text = disasm_text.replace(call_addr_str, sym.name)
                except Exception:
                    pass

            # Try to annotate memory references with variable names
            try:
                # Look for memory references like [reg+offset]
                import re

                mem_ref_pattern = r"\[([^\]]+)\]"
                mem_refs = re.findall(mem_ref_pattern, disasm_text)

                # For each memory reference, check if it's a known variable
                for mem_ref in mem_refs:
                    # Parse for ebp relative references
                    offset_pattern = r"(ebp|rbp)(([+-]0x[0-9a-fA-F]+)|([+-]\d+))"
                    offset_match = re.search(offset_pattern, mem_ref)
                    if offset_match:
                        # Extract base register and offset
                        offset_match.group(1)
                        offset_str = offset_match.group(2)

                        # Convert offset to integer
                        try:
                            offset = (
                                int(offset_str, 16)
                                if offset_str.startswith("0x") or offset_str.startswith("-0x")
                                else int(offset_str)
                            )

                            # Try to find variable name
                            var_name = var_map.get(offset)

                            # If found, add it to the memory reference
                            if var_name:
                                old_ref = f"[{mem_ref}]"
                                new_ref = f"[{mem_ref} {{{var_name}}}]"
                                disasm_text = disasm_text.replace(old_ref, new_ref)
                        except Exception:
                            pass
            except Exception:
                pass

            # Get comment if any
            comment = None
            try:
                comment = self._current_view.get_comment_at(addr)
            except Exception:
                pass

            # Format the final line
            addr_str = f"{addr:08x}"
            # Include hex bytes column padded for readability
            bytes_col = f"{hex_bytes}".ljust(16)
            line = f"{addr_str}  {bytes_col} {disasm_text}"

            # Add comment at the end if any
            if comment:
                line += f"  ; {comment}"

            return line
        except Exception as e:
            bn.log_error(f"Error annotating instruction at {hex(addr)}: {e!s}")
            return f"{addr:08x}  {hex_bytes} ; [Error: {e!s}]"

    def get_functions_containing_address(self, address: int) -> list:
        """Get functions containing a specific address.

        Args:
            address: The instruction address to find containing functions for

        Returns:
            List of function names containing the address
        """
        if not self.current_view:
            raise RuntimeError("No binary loaded")

        try:
            functions = list(self.current_view.get_functions_containing(address))
            return [func.name for func in functions]
        except Exception as e:
            bn.log_error(f"Error getting functions containing address {hex(address)}: {e}")
            return []

    def get_entry_points(self) -> list[dict[str, Any]]:
        """Return entry point(s) for the current binary view.

        Primarily uses `bv.entry_point`. Also includes common startup symbols like
        `_start` when resolvable.
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        bv = self._current_view
        results: list[dict[str, Any]] = []

        def _append(addr: int):
            try:
                if addr is None:
                    return
                name = None
                try:
                    sym = bv.get_symbol_at(addr)
                    if sym and getattr(sym, "name", None):
                        name = sym.name
                except Exception:
                    pass
                if name is None:
                    try:
                        func = bv.get_function_at(addr)
                        if func and getattr(func, "name", None):
                            name = func.name
                    except Exception:
                        pass
                results.append(
                    {
                        "address": hex(int(addr)),
                        "name": name,
                    }
                )
            except Exception:
                pass

        # Primary entry point
        try:
            ep = getattr(bv, "entry_point", None)
            if isinstance(ep, int) and ep >= 0:
                _append(ep)
        except Exception:
            pass

        # Common startup symbol fallback
        for sname in ("_start", "entry", "start", "WinMain", "mainCRTStartup"):
            try:
                sym = bv.get_symbol_by_name(sname) if hasattr(bv, "get_symbol_by_name") else None
                if sym and hasattr(sym, "address"):
                    addr = int(sym.address)
                    if not any(r.get("address") == hex(addr) for r in results):
                        _append(addr)
            except Exception:
                continue

        return results

    # Removed: get_function_code_references() in favor of address-based get_xrefs_to_* helpers

    def get_user_defined_type(self, type_name: str) -> dict[str, Any] | None:
        """Get the definition of a user-defined type (struct, enum, etc.)

        Args:
            type_name: Name of the user-defined type to retrieve

        Returns:
            Dictionary with type information and definition, or None if not found
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        try:
            # Check if we have a user type container
            if (
                not hasattr(self._current_view, "user_type_container")
                or not self._current_view.user_type_container
            ):
                bn.log_info("No user type container available")
                return None

            # Search for the requested type by name
            found_type = None
            found_type_id = None

            for type_id in self._current_view.user_type_container.types.keys():
                current_type = self._current_view.user_type_container.types[type_id]
                type_name_from_container = current_type[0]

                if type_name_from_container == type_name:
                    found_type = current_type
                    found_type_id = type_id
                    break

            if not found_type or not found_type_id:
                bn.log_info(f"Type not found: {type_name}")
                return None

            # Determine the type category (struct, enum, etc.)
            type_category = "unknown"
            type_object = found_type[1]
            bn.log_info("Stage1")
            bn.log_info(f"Stage1.5 {type_object.type_class} {StructureVariant.StructStructureType}")
            if type_object.type_class == TypeClass.EnumerationTypeClass:
                type_category = "enum"
            elif type_object.type_class == TypeClass.StructureTypeClass:
                if type_object.type == StructureVariant.StructStructureType:
                    type_category = "struct"
                elif type_object.type == StructureVariant.UnionStructureType:
                    type_category = "union"
                elif type_object.type == StructureVariant.ClassStructureType:
                    type_category = "class"
            elif type_object.type_class == TypeClass.NamedTypeReferenceClass:
                type_category = "typedef"

            # Generate the C++ style definition
            definition_lines = []

            try:
                if (
                    type_category == "struct"
                    or type_category == "class"
                    or type_category == "union"
                ):
                    definition_lines.append(f"{type_category} {type_name} {{")
                    for member in type_object.members:
                        if hasattr(member, "name") and hasattr(member, "type"):
                            definition_lines.append(f"    {member.type} {member.name};")
                    definition_lines.append("};")
                elif type_category == "enum":
                    definition_lines.append(f"enum {type_name} {{")
                    for member in type_object.members:
                        if hasattr(member, "name") and hasattr(member, "value"):
                            definition_lines.append(f"    {member.name} = {member.value},")
                    definition_lines.append("};")
                elif type_category == "typedef":
                    str_type_object = str(type_object)
                    definition_lines.append(f"typedef {str_type_object};")
            except Exception as e:
                bn.log_error(f"Error getting type lines: {e}")

            # Construct the final definition string
            definition = "\n".join(definition_lines)

            return {"name": type_name, "type": type_category, "definition": definition}
        except Exception as e:
            bn.log_error(f"Error getting user-defined type {type_name}: {e}")
            return None

    def get_xrefs_to_address(self, address: int | str) -> dict[str, Any]:
        """Get all cross references (code and data) to a given address.

        Args:
            address: Address as int, hex string (e.g., "0x401000"), or decimal string

        Returns:
            Dictionary with address, code_references, and data_references lists
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        # Normalize address to int
        try:
            if isinstance(address, str):
                addr = int(address, 16) if address.startswith("0x") else int(address)
            else:
                addr = int(address)
        except (TypeError, ValueError):
            raise ValueError("Invalid address format; use hex (0x...) or decimal")

        result: dict[str, Any] = {
            "address": hex(addr),
            "code_references": [],
            "data_references": [],
        }

        # Code references
        try:
            if hasattr(self._current_view, "get_code_refs"):
                for ref in list(self._current_view.get_code_refs(addr)):
                    try:
                        fn_name = ref.function.name if getattr(ref, "function", None) else None
                        entry = {"function": fn_name, "address": hex(ref.address)}

                        # Heuristic: only attach a following call if the referenced data
                        # is carried in a parameter register up to that call (likely passed as an arg)
                        try:
                            func = (
                                ref.function
                                if getattr(ref, "function", None)
                                else self._current_view.get_function_at(ref.address)
                            )
                            if func is not None:
                                import re as _re

                                # identify destination register at xref instruction
                                def _canon_reg(r: str) -> str:
                                    r = (r or "").strip().lower()
                                    mp = {
                                        "rcx": "rcx",
                                        "ecx": "rcx",
                                        "cx": "rcx",
                                        "cl": "rcx",
                                        "ch": "rcx",
                                        "rdx": "rdx",
                                        "edx": "rdx",
                                        "dx": "rdx",
                                        "dl": "rdx",
                                        "dh": "rdx",
                                        "r8": "r8",
                                        "r8d": "r8",
                                        "r8w": "r8",
                                        "r8b": "r8",
                                        "r9": "r9",
                                        "r9d": "r9",
                                        "r9w": "r9",
                                        "r9b": "r9",
                                        "rdi": "rdi",
                                        "edi": "rdi",
                                        "di": "rdi",
                                        "dil": "rdi",
                                        "rsi": "rsi",
                                        "esi": "rsi",
                                        "si": "rsi",
                                        "sil": "rsi",
                                    }
                                    return mp.get(r, r)

                                def _first_op_reg(d: str) -> str:
                                    try:
                                        parts = d.strip().split(None, 1)
                                        if len(parts) < 2:
                                            return ""
                                        ops = parts[1].split(";", 1)[0]
                                        first = ops.split(",", 1)[0].strip()
                                        if "[" in first:
                                            return ""
                                        for kw in ("byte", "word", "dword", "qword", "ptr"):
                                            if first.startswith(kw):
                                                first = first[len(kw) :].strip()
                                        return first.split()[0]
                                    except Exception:
                                        return ""

                                try:
                                    xdis = self._current_view.get_disassembly(ref.address) or ""
                                except Exception:
                                    xdis = ""
                                dest = _canon_reg(_first_op_reg(xdis))
                                arg_regs = {"rcx", "rdx", "r8", "r9", "rdi", "rsi"}
                                if dest in arg_regs:
                                    steps = 16
                                    curr = ref.address
                                    overwritten = False
                                    while steps > 0 and curr < getattr(
                                        func, "highest_address", curr + 1024
                                    ):
                                        ilen = self._current_view.get_instruction_length(curr) or 1
                                        try:
                                            dis = self._current_view.get_disassembly(curr) or ""
                                        except Exception:
                                            dis = ""
                                        # detect clobber of the arg register
                                        if (
                                            curr != ref.address
                                            and _canon_reg(_first_op_reg(dis)) == dest
                                        ):
                                            overwritten = True
                                        if ("call" in dis.lower()) and not overwritten:
                                            entry["following_call_address"] = hex(curr)
                                            m = _re.search(r"0x[0-9a-fA-F]+", dis)
                                            tgt = None
                                            if m:
                                                try:
                                                    tgt = int(m.group(0), 16)
                                                except Exception:
                                                    tgt = None
                                            if tgt is not None:
                                                sym = self._current_view.get_symbol_at(tgt)
                                                if sym and hasattr(sym, "name"):
                                                    entry["following_call_target"] = sym.name
                                                else:
                                                    tfn = self._current_view.get_function_at(tgt)
                                                    entry["following_call_target"] = (
                                                        tfn.name
                                                        if (tfn and hasattr(tfn, "name"))
                                                        else hex(tgt)
                                                    )
                                            break
                                        curr += max(1, ilen)
                                        steps -= 1
                        except Exception:
                            pass

                        result["code_references"].append(entry)
                    except Exception:
                        continue
        except Exception as e:
            bn.log_error(f"Error getting code references to {hex(addr)}: {e}")

        # Data references
        try:
            if hasattr(self._current_view, "get_data_refs"):
                for ref_addr in list(self._current_view.get_data_refs(addr)):
                    try:
                        fn = self._current_view.get_function_at(ref_addr)
                        fn_name = fn.name if fn else None
                        result["data_references"].append(
                            {"function": fn_name, "address": hex(ref_addr)}
                        )
                    except Exception:
                        continue
        except Exception as e:
            bn.log_error(f"Error getting data references to {hex(addr)}: {e}")

        return result

    def get_xrefs_to_field(self, struct_name: str, field_name: str) -> list[dict[str, Any]]:
        """Get all cross references to a named struct field (member).

        This uses a best-effort heuristic:
        - Scans HLIL for occurrences of the field name (e.g., ".field" or "->field")
        - If a global instance of the struct is found, computes the field's absolute
          address (base + offset) and includes code refs to that address
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        struct_name = str(struct_name).strip()
        field_name = str(field_name).strip()
        results: list[dict[str, Any]] = []

        # Try to resolve struct member offset
        member_offset = None
        try:
            if hasattr(self._current_view, "types") and self._current_view.types:
                for t in self._current_view.types.values():
                    try:
                        if (
                            getattr(t, "name", None) == struct_name
                            and hasattr(t, "structure")
                            and t.structure
                        ):
                            for m in getattr(t, "members", getattr(t.structure, "members", [])):
                                if getattr(m, "name", None) == field_name and hasattr(m, "offset"):
                                    member_offset = int(m.offset)
                                    break
                            if member_offset is not None:
                                break
                    except Exception:
                        continue
        except Exception:
            pass

        # HLIL scan for textual member access
        import re

        pattern = re.compile(rf"(\.|->)\s*{re.escape(field_name)}(\b|\W)")
        for func in list(self._current_view.functions):
            try:
                if not hasattr(func, "hlil") or not func.hlil:
                    continue
                for ins in func.hlil.instructions:
                    try:
                        text = str(ins)
                        if pattern.search(text):
                            results.append(
                                {
                                    "kind": "hlil-match",
                                    "function": func.name,
                                    "address": hex(getattr(ins, "address", func.start)),
                                    "text": text,
                                }
                            )
                    except Exception:
                        continue
            except Exception:
                continue

        # If we know the member offset, try to find global instances and code-refs
        if member_offset is not None:
            try:
                for var_addr in list(self._current_view.data_vars):
                    try:
                        t = None
                        if hasattr(self._current_view, "get_type_at"):
                            t = self._current_view.get_type_at(var_addr)
                        t_str = str(t) if t is not None else ""
                        # crude match for exact or pointer to struct
                        if (
                            t_str == struct_name
                            or t_str.endswith(f"* {struct_name}")
                            or struct_name in t_str
                        ):
                            field_addr = var_addr + member_offset
                            # code refs to this absolute address
                            try:
                                for ref in list(self._current_view.get_code_refs(field_addr)):
                                    fn_name = (
                                        ref.function.name
                                        if getattr(ref, "function", None)
                                        else None
                                    )
                                    results.append(
                                        {
                                            "kind": "global-field-ref",
                                            "function": fn_name,
                                            "address": hex(ref.address),
                                            "field_address": hex(field_addr),
                                        }
                                    )
                            except Exception:
                                pass
                    except Exception:
                        continue
            except Exception:
                pass

        return results

    def get_xrefs_to_type(self, type_name: str) -> dict[str, Any]:
        """Get cross references/usages related to a struct/type name.

        Best-effort heuristics:
        - Finds global data variables whose type string mentions the type name; includes code refs to those globals
        - Scans HLIL text for instructions mentioning the type (casts/annotations)
        - Marks functions whose signature mentions the type
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        type_name = str(type_name).strip()
        tnl = type_name.lower()

        result: dict[str, Any] = {
            "type": type_name,
            "data_instances": [],  # [{address, type, name?}]
            "data_code_references": [],  # [{function, address, target}]
            "code_references": [],  # HLIL matches [{function, address, text}]
            "functions_with_type": [],  # function names
        }

        # 1) Global data variables whose type matches the type name
        try:
            for var_addr in list(self._current_view.data_vars):
                try:
                    t = None
                    if hasattr(self._current_view, "get_type_at"):
                        t = self._current_view.get_type_at(var_addr)
                    t_str = str(t) if t is not None else ""
                    if t_str and tnl in t_str.lower():
                        sym = self._current_view.get_symbol_at(var_addr)
                        result["data_instances"].append(
                            {
                                "address": hex(var_addr),
                                "type": t_str,
                                "name": sym.name if sym else None,
                            }
                        )
                        # Also add code refs to this global
                        try:
                            if hasattr(self._current_view, "get_code_refs"):
                                for ref in list(self._current_view.get_code_refs(var_addr)):
                                    fn_name = (
                                        ref.function.name
                                        if getattr(ref, "function", None)
                                        else None
                                    )
                                    result["data_code_references"].append(
                                        {
                                            "function": fn_name,
                                            "address": hex(ref.address),
                                            "target": hex(var_addr),
                                        }
                                    )
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

        # 2) HLIL textual matches for the type (casts/annotations)
        try:
            import re

            # Look for the type name as a word or part of a cast/annotation
            pat = re.compile(re.escape(type_name), re.IGNORECASE)
            for func in list(self._current_view.functions):
                try:
                    if hasattr(func, "hlil") and func.hlil:
                        for ins in func.hlil.instructions:
                            try:
                                text = str(ins)
                                if pat.search(text):
                                    result["code_references"].append(
                                        {
                                            "function": func.name,
                                            "address": hex(getattr(ins, "address", func.start)),
                                            "text": text,
                                        }
                                    )
                            except Exception:
                                continue
                    # 3) Functions whose signature mentions the type
                    try:
                        sig_text = str(func.type)
                        if sig_text and tnl in sig_text.lower():
                            result["functions_with_type"].append(func.name)
                    except Exception:
                        pass
                except Exception:
                    continue
        except Exception:
            pass

        # Deduplicate function list
        try:
            result["functions_with_type"] = sorted(list(set(result["functions_with_type"])))
        except Exception:
            pass

        return result

    def get_xrefs_to_enum(self, enum_name: str) -> dict[str, Any]:
        """Find usages of an enum by matching its member values in code and variables.

        Notes:
        - Enums are values, not addresses; there are no traditional "data references" to enums.
        - This scans for immediate constants equal to enum members and common bitmask checks.
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        enum_name_str = str(enum_name).strip()
        en_lower = enum_name_str.lower()

        result: dict[str, Any] = {
            "enum": enum_name_str,
            "members": [],  # [{name, value}]
            "usages": [],  # [{function, address, text, member, value}]
        }

        # Locate the enum type and collect members
        enum_type = None
        try:
            for t in self._current_view.types.values():
                try:
                    # Match by exact name or case-insensitive
                    if getattr(t, "type_class", None) == TypeClass.EnumerationTypeClass:
                        tname = getattr(t, "name", None)
                        if tname and tname.lower() == en_lower:
                            enum_type = t
                            break
                except Exception:
                    continue
        except Exception:
            pass

        # If not found by exact name, try substring match
        if enum_type is None:
            try:
                for t in self._current_view.types.values():
                    try:
                        if getattr(t, "type_class", None) == TypeClass.EnumerationTypeClass:
                            tname = getattr(t, "name", "")
                            if tname and en_lower in tname.lower():
                                enum_type = t
                                break
                    except Exception:
                        continue
            except Exception:
                pass

        members: list[dict[str, Any]] = []
        values: list[int] = []
        if enum_type is not None:
            try:
                for m in getattr(enum_type, "members", []):
                    try:
                        name = getattr(m, "name", None)
                        val = getattr(m, "value", None)
                        if name is not None and isinstance(val, int):
                            members.append({"name": name, "value": val})
                            values.append(val)
                    except Exception:
                        continue
            except Exception:
                pass

        result["members"] = members

        # Build simple patterns for HLIL text matching of constants (hex)
        import re

        hex_patterns = []
        for v in values:
            hex_patterns.append(re.compile(rf"0x{v:x}\b", re.IGNORECASE))
        # Also a single combined pattern to speed up
        combined_hex = None
        if values:
            combined_hex = re.compile(
                r"(" + "|".join([rf"0x{v:x}\b" for v in values]) + ")", re.IGNORECASE
            )

        # Scan functions for matches
        for func in list(self._current_view.functions):
            try:
                if hasattr(func, "hlil") and func.hlil:
                    for ins in func.hlil.instructions:
                        try:
                            text = str(ins)
                            matched_val = None
                            if combined_hex is not None:
                                m = combined_hex.search(text)
                                if m:
                                    # parse the matched hex back to int to map member name
                                    try:
                                        matched_val = int(m.group(0), 16)
                                    except Exception:
                                        matched_val = None
                            if matched_val is not None:
                                member_name = None
                                for mem in members:
                                    if mem["value"] == matched_val:
                                        member_name = mem["name"]
                                        break
                                result["usages"].append(
                                    {
                                        "function": func.name,
                                        "address": hex(getattr(ins, "address", func.start)),
                                        "text": text,
                                        "member": member_name,
                                        "value": matched_val,
                                    }
                                )
                        except Exception:
                            continue
            except Exception:
                continue

        return result

    def get_xrefs_to_struct(self, struct_name: str) -> dict[str, Any]:
        """Get cross references/usages related specifically to a struct name.

        Includes:
        - members: list of struct members with offsets and types
        - data_instances: globals whose type mentions the struct
        - data_code_references: code refs to those globals
        - field_code_references: code refs to addresses of global_instance + member offset
        - code_references: HLIL lines with member access (".field"/"->field")
        - functions_with_type: functions whose signatures mention the struct
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        name = str(struct_name).strip()
        name_l = name.lower()
        # Build candidate names to handle common PE struct aliases
        candidate_names = {name}
        # Remove leading underscore variant
        if name.startswith("_"):
            candidate_names.add(name[1:])
        else:
            candidate_names.add("_" + name)
        # PE-specific heuristics
        nl = name_l
        if "coff" in nl and "header" in nl:
            candidate_names.update({"IMAGE_FILE_HEADER", "_IMAGE_FILE_HEADER"})
        if ("pe64" in nl or "optional_header64" in nl or "optional" in nl) and "header" in nl:
            candidate_names.update({"IMAGE_OPTIONAL_HEADER64", "_IMAGE_OPTIONAL_HEADER64"})
        if (
            "pe32" in nl or "optional_header32" in nl or ("optional" in nl and "64" not in nl)
        ) and "header" in nl:
            candidate_names.update({"IMAGE_OPTIONAL_HEADER32", "_IMAGE_OPTIONAL_HEADER32"})
        if "dos" in nl and "header" in nl:
            candidate_names.update({"IMAGE_DOS_HEADER", "_IMAGE_DOS_HEADER"})
        candidate_names_l = {c.lower() for c in candidate_names}

        out: dict[str, Any] = {
            "struct": name,
            "members": [],
            "data_instances": [],
            "data_code_references": [],
            "field_code_references": [],
            "code_references": [],
            "functions_with_type": [],
            "vars_with_type": [],
            "code_references_by_cast": [],
        }

        # Resolve the struct type and members
        members = []
        try:
            for t in self._current_view.types.values():
                try:
                    if getattr(t, "type_class", None) == TypeClass.StructureTypeClass:
                        tname = getattr(t, "name", None)
                        if not tname:
                            continue
                        tl = tname.lower()
                        if tl == name_l or name_l in tl or tl in candidate_names_l:
                            for m in getattr(
                                t, "members", getattr(getattr(t, "structure", None), "members", [])
                            ):
                                try:
                                    members.append(
                                        {
                                            "name": getattr(m, "name", None),
                                            "offset": int(getattr(m, "offset", 0))
                                            if hasattr(m, "offset")
                                            else None,
                                            "type": str(getattr(m, "type", ""))
                                            if hasattr(m, "type")
                                            else None,
                                        }
                                    )
                                except Exception:
                                    continue
                            break
                except Exception:
                    continue
        except Exception:
            pass
        out["members"] = members

        # Gather globals with this struct in their type string
        global_instances: list[int] = []
        try:
            for var_addr in list(self._current_view.data_vars):
                try:
                    t = None
                    if hasattr(self._current_view, "get_type_at"):
                        t = self._current_view.get_type_at(var_addr)
                    t_str = str(t) if t is not None else ""
                    if t_str:
                        tl = t_str.lower()
                        if name_l in tl or any(cn in tl for cn in candidate_names_l):
                            sym = self._current_view.get_symbol_at(var_addr)
                            out["data_instances"].append(
                                {
                                    "address": hex(var_addr),
                                    "type": t_str,
                                    "name": sym.name if sym else None,
                                }
                            )
                            global_instances.append(var_addr)
                            # Code refs to the variable itself
                        try:
                            if hasattr(self._current_view, "get_code_refs"):
                                for ref in list(self._current_view.get_code_refs(var_addr)):
                                    fn_name = (
                                        ref.function.name
                                        if getattr(ref, "function", None)
                                        else None
                                    )
                                    out["data_code_references"].append(
                                        {
                                            "function": fn_name,
                                            "address": hex(ref.address),
                                            "target": hex(var_addr),
                                        }
                                    )
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

        # Also gather symbol-based instances whose name mentions the struct alias
        symbol_instances: list[int] = []
        try:
            for sym in list(self._current_view.get_symbols()):
                try:
                    sname = getattr(sym, "name", "") or ""
                    sfull = getattr(sym, "full_name", "") or ""
                    sl = (sname + " " + sfull).lower()
                    if any(cn in sl for cn in candidate_names_l):
                        addr = getattr(sym, "address", None)
                        if isinstance(addr, int):
                            # capture as data instance if not already present
                            out["data_instances"].append(
                                {
                                    "address": hex(addr),
                                    "type": None,
                                    "name": sname,
                                }
                            )
                            symbol_instances.append(addr)
                            # code refs to this symbol
                            try:
                                if hasattr(self._current_view, "get_code_refs"):
                                    for ref in list(self._current_view.get_code_refs(addr)):
                                        fn_name = (
                                            ref.function.name
                                            if getattr(ref, "function", None)
                                            else None
                                        )
                                        out["data_code_references"].append(
                                            {
                                                "function": fn_name,
                                                "address": hex(ref.address),
                                                "target": hex(addr),
                                            }
                                        )
                            except Exception:
                                pass
                except Exception:
                    continue
        except Exception:
            pass

        # Code refs to computed field addresses for each global instance
        if members and (global_instances or symbol_instances):
            try:
                for base in list(set(global_instances + symbol_instances)):
                    for m in members:
                        try:
                            off = m.get("offset")
                            if off is None:
                                continue
                            field_addr = base + int(off)
                            if hasattr(self._current_view, "get_code_refs"):
                                for ref in list(self._current_view.get_code_refs(field_addr)):
                                    fn_name = (
                                        ref.function.name
                                        if getattr(ref, "function", None)
                                        else None
                                    )
                                    out["field_code_references"].append(
                                        {
                                            "function": fn_name,
                                            "address": hex(ref.address),
                                            "field_address": hex(field_addr),
                                            "member": m.get("name"),
                                        }
                                    )
                        except Exception:
                            continue
            except Exception:
                pass

        # If the struct is contained as a field of another struct, try deriving field addresses from parent instances
        try:
            parent_offsets: list[dict[str, Any]] = []
            for t in self._current_view.types.values():
                try:
                    if getattr(t, "type_class", None) == TypeClass.StructureTypeClass:
                        tname = getattr(t, "name", None)
                        if not tname:
                            continue
                        tl = tname.lower()
                        # scan members for types that mention our struct aliases
                        for mem in getattr(
                            t, "members", getattr(getattr(t, "structure", None), "members", [])
                        ):
                            try:
                                mtype = getattr(mem, "type", None)
                                mtype_str = str(mtype) if mtype is not None else ""
                                ml = mtype_str.lower()
                                if ml and (
                                    name_l in ml or any(cn in ml for cn in candidate_names_l)
                                ):
                                    parent_offsets.append(
                                        {
                                            "parent": tname,
                                            "offset": int(getattr(mem, "offset", 0))
                                            if hasattr(mem, "offset")
                                            else None,
                                            "member": getattr(mem, "name", None),
                                        }
                                    )
                            except Exception:
                                continue
                except Exception:
                    continue

            # For each parent type, find instances and compute field address
            for po in parent_offsets:
                poff = po.get("offset")
                if poff is None:
                    continue
                parent_name = po.get("parent")
                try:
                    # scan data variables
                    for var_addr in list(self._current_view.data_vars):
                        try:
                            t = None
                            if hasattr(self._current_view, "get_type_at"):
                                t = self._current_view.get_type_at(var_addr)
                            t_str = str(t) if t is not None else ""
                            if t_str and parent_name and parent_name.lower() in t_str.lower():
                                field_addr = var_addr + poff
                                if hasattr(self._current_view, "get_code_refs"):
                                    for ref in list(self._current_view.get_code_refs(field_addr)):
                                        fn_name = (
                                            ref.function.name
                                            if getattr(ref, "function", None)
                                            else None
                                        )
                                        out["field_code_references"].append(
                                            {
                                                "function": fn_name,
                                                "address": hex(ref.address),
                                                "field_address": hex(field_addr),
                                                "member": po.get("member"),
                                            }
                                        )
                        except Exception:
                            continue
                    # scan symbols with parent type in name
                    for sym in list(self._current_view.get_symbols()):
                        try:
                            sname = getattr(sym, "name", "") or ""
                            sfull = getattr(sym, "full_name", "") or ""
                            sl = (sname + " " + sfull).lower()
                            if parent_name and parent_name.lower() in sl:
                                addr = getattr(sym, "address", None)
                                if isinstance(addr, int):
                                    field_addr = addr + poff
                                    if hasattr(self._current_view, "get_code_refs"):
                                        for ref in list(
                                            self._current_view.get_code_refs(field_addr)
                                        ):
                                            fn_name = (
                                                ref.function.name
                                                if getattr(ref, "function", None)
                                                else None
                                            )
                                            out["field_code_references"].append(
                                                {
                                                    "function": fn_name,
                                                    "address": hex(ref.address),
                                                    "field_address": hex(field_addr),
                                                    "member": po.get("member"),
                                                }
                                            )
                        except Exception:
                            continue
                except Exception:
                    continue
        except Exception:
            pass

        # HLIL matches for member access text

        try:
            import re

            patterns = []
            for m in members:
                nm = m.get("name")
                if not nm:
                    continue
                patterns.append(
                    re.compile(rf"(\.|->)\s*{re.escape(str(nm))}(\b|\W)", re.IGNORECASE)
                )

            for func in list(self._current_view.functions):
                try:
                    # Capture variables whose type mentions the struct
                    try:
                        for v in getattr(func, "vars", []):
                            try:
                                vtype = getattr(v, "type", None)
                                vname = getattr(v, "name", None)
                                vtype_str = str(vtype) if vtype is not None else ""
                                if vtype_str and name_l in vtype_str.lower():
                                    out["vars_with_type"].append(
                                        {
                                            "function": func.name,
                                            "var": vname,
                                            "type": vtype_str,
                                        }
                                    )
                            except Exception:
                                continue
                    except Exception:
                        pass

                    if hasattr(func, "hlil") and func.hlil:
                        for ins in func.hlil.instructions:
                            try:
                                text = str(ins)
                                if any(p.search(text) for p in patterns):
                                    out["code_references"].append(
                                        {
                                            "function": func.name,
                                            "address": hex(getattr(ins, "address", func.start)),
                                            "text": text,
                                        }
                                    )
                                # Also capture casts/annotations explicitly mentioning the struct name
                                tl = text.lower()
                                if name_l in tl or any(cn in tl for cn in candidate_names_l):
                                    # Heuristic: detect patterns like '(COFF_Header*)' or '(struct COFF_Header*)'
                                    cast_pat = (
                                        r"\(.*("
                                        + "|".join(re.escape(c) for c in candidate_names)
                                        + r").*\)"
                                    )
                                    if re.search(cast_pat, text, re.IGNORECASE):
                                        out["code_references_by_cast"].append(
                                            {
                                                "function": func.name,
                                                "address": hex(getattr(ins, "address", func.start)),
                                                "text": text,
                                            }
                                        )
                            except Exception:
                                continue
                    # Functions whose signature mentions the struct
                    try:
                        sig_text = str(func.type)
                        if sig_text:
                            sl = sig_text.lower()
                            if name_l in sl or any(cn in sl for cn in candidate_names_l):
                                out["functions_with_type"].append(func.name)
                    except Exception:
                        pass
                except Exception:
                    continue
        except Exception:
            pass

        # Dedup functions list
        try:
            out["functions_with_type"] = sorted(list(set(out["functions_with_type"])))
        except Exception:
            pass

        return out

    def get_xrefs_to_union(self, union_name: str) -> dict[str, Any]:
        """Get cross references/usages related to a union type by name.

        Includes:
        - members: list of union members with offsets/types (offsets may be 0/overlapping)
        - data_instances: globals whose type mentions the union
        - data_code_references: code refs to those globals
        - code_references: HLIL lines with member access (".field"/"->field")
        - functions_with_type: functions whose signatures mention the union
        - vars_with_type: function-local variables typed as the union
        - code_references_by_cast: HLIL lines with explicit casts mentioning the union
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        name = str(union_name).strip()
        name_l = name.lower()

        out: dict[str, Any] = {
            "union": name,
            "members": [],
            "data_instances": [],
            "data_code_references": [],
            "code_references": [],
            "functions_with_type": [],
            "vars_with_type": [],
            "code_references_by_cast": [],
        }

        # Resolve union members
        members: list[dict[str, Any]] = []
        try:
            for t in self._current_view.types.values():
                try:
                    # Union types are presented via StructureTypeClass with UnionStructureType variant
                    if getattr(t, "type_class", None) == TypeClass.StructureTypeClass:
                        tname = getattr(t, "name", None)
                        if not tname:
                            continue
                        tl = tname.lower()
                        if tl == name_l or name_l in tl:
                            # If the BN type exposes a variant, prefer checking for union
                            try:
                                if getattr(t, "type", None) == StructureVariant.UnionStructureType:
                                    pass
                            except Exception:
                                pass
                            for m in getattr(
                                t, "members", getattr(getattr(t, "structure", None), "members", [])
                            ):
                                try:
                                    members.append(
                                        {
                                            "name": getattr(m, "name", None),
                                            "offset": int(getattr(m, "offset", 0))
                                            if hasattr(m, "offset")
                                            else None,
                                            "type": str(getattr(m, "type", ""))
                                            if hasattr(m, "type")
                                            else None,
                                        }
                                    )
                                except Exception:
                                    continue
                            break
                except Exception:
                    continue
        except Exception:
            pass
        out["members"] = members

        # Gather globals with this union in their type string
        try:
            for var_addr in list(self._current_view.data_vars):
                try:
                    t = None
                    if hasattr(self._current_view, "get_type_at"):
                        t = self._current_view.get_type_at(var_addr)
                    t_str = str(t) if t is not None else ""
                    if t_str and name_l in t_str.lower():
                        sym = self._current_view.get_symbol_at(var_addr)
                        out["data_instances"].append(
                            {
                                "address": hex(var_addr),
                                "type": t_str,
                                "name": sym.name if sym else None,
                            }
                        )
                        # Code refs to that variable
                        try:
                            if hasattr(self._current_view, "get_code_refs"):
                                for ref in list(self._current_view.get_code_refs(var_addr)):
                                    fn_name = (
                                        ref.function.name
                                        if getattr(ref, "function", None)
                                        else None
                                    )
                                    out["data_code_references"].append(
                                        {
                                            "function": fn_name,
                                            "address": hex(ref.address),
                                            "target": hex(var_addr),
                                        }
                                    )
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            pass

        # HLIL member access and casts; function variables/signatures
        try:
            import re

            patterns = []
            for m in members:
                nm = m.get("name")
                if not nm:
                    continue
                patterns.append(
                    re.compile(rf"(\.|->)\s*{re.escape(str(nm))}(\b|\W)", re.IGNORECASE)
                )

            for func in list(self._current_view.functions):
                try:
                    # variables typed as this union
                    try:
                        for v in getattr(func, "vars", []):
                            try:
                                vtype = getattr(v, "type", None)
                                vname = getattr(v, "name", None)
                                vtype_str = str(vtype) if vtype is not None else ""
                                if vtype_str and name_l in vtype_str.lower():
                                    out["vars_with_type"].append(
                                        {
                                            "function": func.name,
                                            "var": vname,
                                            "type": vtype_str,
                                        }
                                    )
                            except Exception:
                                continue
                    except Exception:
                        pass

                    if hasattr(func, "hlil") and func.hlil:
                        for ins in func.hlil.instructions:
                            try:
                                text = str(ins)
                                tl = text.lower()
                                matched_member = (
                                    any(p.search(text) for p in patterns) if patterns else False
                                )
                                if matched_member:
                                    out["code_references"].append(
                                        {
                                            "function": func.name,
                                            "address": hex(getattr(ins, "address", func.start)),
                                            "text": text,
                                        }
                                    )
                                # Capture casts mentioning the union
                                cast_matched = False
                                if name_l in tl:
                                    if re.search(
                                        rf"\(.*{re.escape(name)}.*\)", text, re.IGNORECASE
                                    ):
                                        out["code_references_by_cast"].append(
                                            {
                                                "function": func.name,
                                                "address": hex(getattr(ins, "address", func.start)),
                                                "text": text,
                                            }
                                        )
                                        cast_matched = True
                                # Fallback: any HLIL mention of the union name counts as a code reference
                                if (not matched_member) and (not cast_matched) and (name_l in tl):
                                    out["code_references"].append(
                                        {
                                            "function": func.name,
                                            "address": hex(getattr(ins, "address", func.start)),
                                            "text": text,
                                        }
                                    )
                            except Exception:
                                continue
                    # function signature mentions
                    try:
                        sig_text = str(func.type)
                        if sig_text and name_l in sig_text.lower():
                            out["functions_with_type"].append(func.name)
                    except Exception:
                        pass
                except Exception:
                    continue
        except Exception:
            pass

        # Dedup functions list
        try:
            out["functions_with_type"] = sorted(list(set(out["functions_with_type"])))
        except Exception:
            pass

        return out

    def patch_bytes(
        self, address: str | int, data: str | bytes | list[int], save_to_file: bool = True
    ) -> dict[str, Any]:
        """Patch bytes at a given address in the binary.

        Args:
            address: Address to patch (hex string like "0x401000" or integer)
            data: Bytes to write. Can be:
                - Hex string: "90 90" or "9090" or "0x90 0x90"
                - List of integers: [0x90, 0x90]
                - Bytes object: b"\x90\x90"
            save_to_file: If True (default), save the patched binary to disk

        Returns:
            Dictionary with status, address, original bytes, and patched bytes

        Raises:
            RuntimeError: If no binary is loaded
            ValueError: If address or data format is invalid
        """
        if not self._current_view:
            raise RuntimeError("No binary loaded")

        # Parse address
        # Only treat as hex if it has "0x" prefix or contains a-f/A-F characters
        # This avoids ambiguity where "123" would be treated as hex instead of decimal
        if isinstance(address, str):
            address = address.strip()
            if address.startswith("0x") or address.startswith("0X"):
                addr = int(address, 16)
            elif any(c in "abcdefABCDEF" for c in address):
                # Contains hex letters, treat as hex
                addr = int(address, 16)
            else:
                # Pure digits, treat as decimal
                addr = int(address, 10)
        else:
            addr = int(address)

        # Parse data into bytes
        patch_bytes = None
        if isinstance(data, bytes):
            patch_bytes = data
        elif isinstance(data, str):
            # Try to parse as hex string
            data_str = data.strip()
            # Remove "0x" prefix if present
            if data_str.startswith("0x"):
                data_str = data_str[2:]
            # Remove spaces
            data_str = data_str.replace(" ", "").replace("\n", "").replace("\t", "")
            # Convert hex string to bytes
            try:
                patch_bytes = bytes.fromhex(data_str)
            except ValueError as e:
                raise ValueError(f"Invalid hex string: {e}")
        elif isinstance(data, list):
            # List of integers
            try:
                patch_bytes = bytes(data)
            except (ValueError, TypeError) as e:
                raise ValueError(f"Invalid byte list: {e}")
        else:
            raise ValueError(f"Unsupported data type: {type(data)}")

        if not patch_bytes:
            raise ValueError("Empty patch data")

        # Read original bytes for comparison
        try:
            original_bytes = self._current_view.read(addr, len(patch_bytes))
            if original_bytes is None:
                original_bytes = b""
        except Exception as e:
            bn.log_warn(f"Could not read original bytes at {hex(addr)}: {e}")
            original_bytes = b""

        # Write the patch
        try:
            written = self._current_view.write(addr, patch_bytes)

            # Determine status based on whether all bytes were written
            if written != len(patch_bytes):
                bn.log_warn(f"Only wrote {written} of {len(patch_bytes)} bytes at {hex(addr)}")
                status = "partial"
            else:
                status = "ok"

            result = {
                "status": status,
                "address": hex(addr),
                "original_bytes": original_bytes.hex() if original_bytes else "",
                "patched_bytes": patch_bytes.hex(),
                "bytes_written": written,
                "bytes_requested": len(patch_bytes),
                "saved_to_file": False,
            }

            # Add warning message if partial write
            if status == "partial":
                result["warning"] = f"Only wrote {written} of {len(patch_bytes)} bytes"

            # Save to file if requested
            if save_to_file:
                try:
                    # Get the original file path
                    original_file = self._current_view.file.filename
                    if original_file:
                        # Save the patched binary back to the original file
                        if self._current_view.save(original_file):
                            result["saved_to_file"] = True
                            result["saved_path"] = original_file
                            bn.log_info(f"Patched binary saved to: {original_file}")

                            # On macOS, re-sign the binary to avoid "killed" error
                            if platform.system() == "Darwin":
                                result["codesign"] = self._codesign_binary(original_file)
                        else:
                            bn.log_warn(f"Failed to save patched binary to: {original_file}")
                            result["save_error"] = "save() returned False"
                    else:
                        bn.log_warn("No original file path available for saving")
                        result["save_error"] = "No original file path"
                except Exception as save_e:
                    bn.log_warn(f"Failed to save patched binary: {save_e}")
                    result["save_error"] = str(save_e)

            return result
        except Exception as e:
            raise ValueError(f"Failed to patch bytes at {hex(addr)}: {e!s}")

    def _codesign_binary(self, file_path: str) -> dict[str, Any]:
        """Re-sign a binary on macOS after patching.

        On macOS, modifying a binary invalidates its code signature, causing the
        system to kill the process when executed. This method removes the old
        signature and applies an ad-hoc signature to make the binary executable.

        Args:
            file_path: Path to the binary file to sign

        Returns:
            Dictionary with codesign status and any error messages
        """
        result = {
            "attempted": True,
            "success": False,
            "platform": "macOS",
        }

        try:
            # Step 1: Remove existing signature (optional, codesign -f will overwrite anyway)
            remove_result = subprocess.run(
                ["codesign", "--remove-signature", file_path],
                capture_output=True,
                text=True,
                timeout=30,
            )

            if remove_result.returncode != 0:
                # It's okay if removal fails (binary might not have been signed)
                bn.log_info(
                    f"codesign --remove-signature returned {remove_result.returncode}: {remove_result.stderr}"
                )

            # Step 2: Apply ad-hoc signature with force flag
            sign_result = subprocess.run(
                ["codesign", "-f", "-s", "-", file_path], capture_output=True, text=True, timeout=30
            )

            if sign_result.returncode == 0:
                result["success"] = True
                result["message"] = "Binary re-signed with ad-hoc signature"
                bn.log_info(f"Successfully re-signed binary: {file_path}")
            else:
                result["error"] = (
                    sign_result.stderr or f"codesign failed with code {sign_result.returncode}"
                )
                bn.log_warn(f"Failed to re-sign binary: {result['error']}")

        except FileNotFoundError:
            result["error"] = "codesign command not found"
            bn.log_warn("codesign command not found - is Xcode Command Line Tools installed?")
        except subprocess.TimeoutExpired:
            result["error"] = "codesign command timed out"
            bn.log_warn("codesign command timed out")
        except Exception as e:
            result["error"] = str(e)
            bn.log_warn(f"Error during codesign: {e}")

        return result

```

`plugin/core/config.py`:

```py
from dataclasses import dataclass


@dataclass
class ServerConfig:
    host: str = "localhost"
    port: int = 9009
    debug: bool = False


@dataclass
class BinaryNinjaConfig:
    api_version: str | None = None
    log_level: str = "INFO"


class Config:
    def __init__(self):
        self.server = ServerConfig()
        self.binary_ninja = BinaryNinjaConfig()

```

`plugin/server/http_server.py`:

```py
import json
import threading
import urllib.parse
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any

import binaryninja as bn
from binaryninja.settings import Settings

from ..api.endpoints import BinaryNinjaEndpoints
from ..core.binary_operations import BinaryOperations
from ..core.config import Config
from ..utils.number_utils import convert_number as util_convert_number
from ..utils.string_utils import parse_int_or_default


class MCPRequestHandler(BaseHTTPRequestHandler):
    binary_ops = None  # Will be set by the server

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @property
    def endpoints(self):
        # Create endpoints on demand to ensure binary_ops is set
        if not hasattr(self, "_endpoints"):
            if not self.binary_ops:
                raise RuntimeError("binary_ops not initialized")
            self._endpoints = BinaryNinjaEndpoints(self.binary_ops)
        return self._endpoints

    def log_message(self, format, *args):
        bn.log_info(format % args)

    def _set_headers(self, content_type="application/json", status_code=200):
        try:
            self.send_response(status_code)
            self.send_header("Content-Type", content_type)
            self.send_header("Access-Control-Allow-Origin", "*")
            # Encourage clients to close promptly; reduces BrokenPipe on abrupt disconnects
            self.send_header("Connection", "close")
            self.end_headers()
        except (BrokenPipeError, OSError):
            try:
                import binaryninja as _bn

                _bn.log_warn("Client disconnected while sending headers")
            except Exception:
                pass

    def _send_json_response(self, data: dict[str, Any], status_code: int = 200):
        try:
            self._set_headers(status_code=status_code)
            # If headers failed due to disconnect, avoid writing body
            try:
                body = json.dumps(data).encode("utf-8")
            except Exception:
                body = b"{}"
            try:
                self.wfile.write(body)
            except (BrokenPipeError, OSError):
                try:
                    import binaryninja as _bn

                    _bn.log_warn("Client disconnected while sending body")
                except Exception:
                    pass
        except Exception:
            # Last-resort swallow to avoid cascading errors on disconnects
            try:
                import binaryninja as _bn

                _bn.log_debug("Suppressed exception during response write")
            except Exception:
                pass

    def _parse_query_params(self) -> dict[str, str]:
        parsed_path = urllib.parse.urlparse(self.path)
        return dict(urllib.parse.parse_qsl(parsed_path.query))

    def _parse_post_params(self) -> dict[str, Any]:
        """Parse POST request parameters from various formats.

        Supports:
        - JSON data (application/json)
        - Form data (application/x-www-form-urlencoded)
        - Raw text (text/plain)

        Returns:
            Dictionary containing the parsed parameters
        """
        content_length = int(self.headers.get("Content-Length", 0))
        if content_length == 0:
            return {}

        content_type = self.headers.get("Content-Type", "")
        post_data = self.rfile.read(content_length).decode("utf-8")

        bn.log_info(f"Received POST data: {post_data}")
        bn.log_info(f"Content-Type: {content_type}")

        # Handle JSON data
        if "application/json" in content_type.lower():
            try:
                return json.loads(post_data)
            except json.JSONDecodeError as e:
                bn.log_error(f"Failed to parse JSON: {e}")
                return {"error": "Invalid JSON format"}

        # Handle form data
        if "application/x-www-form-urlencoded" in content_type.lower():
            try:
                return dict(urllib.parse.parse_qsl(post_data))
            except Exception as e:
                bn.log_error(f"Failed to parse form data: {e}")
                return {"error": "Invalid form data format"}

        # Handle raw text
        if "text/plain" in content_type.lower() or not content_type:
            return {"name": post_data.strip()}

    # ---------- Helpers ----------
    def _resolve_name_to_address(self, ident: str):
        """Resolve a symbol name or hex address string to (address:int, label:str).

        Tries, in order:
        - Parse hex address (with or without 0x)
        - get_symbol_by_raw_name
        - get_symbol_by_name
        - scan data_vars for matching symbol name/raw_name
        """
        bv = getattr(self.binary_ops, "current_view", None)
        if not bv:
            return None, None
        s = (ident or "").strip()
        # Hex address
        try:
            if s.lower().startswith("0x"):
                return int(s, 16), s
            # bare hex
            if all(c in "0123456789abcdefABCDEF" for c in s):
                return int(s, 16), s
        except Exception:
            pass
        # Raw name
        try:
            get_raw = getattr(bv, "get_symbol_by_raw_name", None)
            sym = get_raw(s) if callable(get_raw) else None
            if sym and hasattr(sym, "address"):
                return int(sym.address), getattr(sym, "name", s)
        except Exception:
            pass
        # Pretty name
        try:
            get_by_name = getattr(bv, "get_symbol_by_name", None)
            sym = get_by_name(s) if callable(get_by_name) else None
            if sym and hasattr(sym, "address"):
                return int(sym.address), getattr(sym, "name", s)
        except Exception:
            pass
        # Heuristic: BN auto-generated data labels like data_100003f66, byte_..., word_..., dword_..., qword_..., off_..., unk_...
        try:
            import re as _re

            m = _re.match(r"^(?i)(?:data|byte|word|dword|qword|off|unk)_(?:0x)?([0-9a-fA-F]+)$", s)
            if m:
                a = int(m.group(1), 16)
                return a, s
        except Exception:
            pass
        # Scan data vars
        try:
            for var in list(bv.data_vars):
                try:
                    sy = bv.get_symbol_at(var)
                    if not sy:
                        continue
                    if getattr(sy, "name", None) == s or getattr(sy, "raw_name", None) == s:
                        return int(var), getattr(sy, "name", s)
                except Exception:
                    continue
        except Exception:
            pass
        return None, None

    def _c_escape(self, raw: bytes, limit: int | None = None) -> str:
        """Escape bytes as a C string literal."""
        try:
            b = raw if limit is None else raw[:limit]
            out = []
            for ch in b:
                if ch == 0x22:  # '"'
                    out.append('\\"')
                elif ch == 0x5C:  # '\\'
                    out.append("\\\\")
                elif 32 <= ch <= 126:
                    out.append(chr(ch))
                elif ch == 0x0A:
                    out.append("\\n")
                elif ch == 0x0D:
                    out.append("\\r")
                elif ch == 0x09:
                    out.append("\\t")
                else:
                    out.append(f"\\x{ch:02x}")
            return '"' + "".join(out) + '"'
        except Exception:
            return '""'

    def _check_binary_loaded(self):
        """Check if a binary is loaded and return appropriate error response if not"""
        if not self.binary_ops or not self.binary_ops.current_view:
            self._send_json_response({"error": "No binary loaded"}, 400)
            return False
        return True

    def do_GET(self):
        try:
            # For all endpoints except /status, /convertNumber, /platforms, /binaries, /views, /selectBinary, check loaded
            if (
                not (
                    self.path.startswith("/status")
                    or self.path.startswith("/convertNumber")
                    or self.path.startswith("/platforms")
                    or self.path.startswith("/binaries")
                    or self.path.startswith("/views")
                    or self.path.startswith("/selectBinary")
                )
                and not self._check_binary_loaded()
            ):
                return

            params = self._parse_query_params()
            path = urllib.parse.urlparse(self.path).path
            offset = parse_int_or_default(params.get("offset"), 0)
            # Support both `limit` and `count` (alias) for pagination
            if params.get("count") is not None:
                limit = parse_int_or_default(params.get("count"), 100)
            else:
                limit = parse_int_or_default(params.get("limit"), 100)

            if path == "/status":
                status = {
                    "loaded": self.binary_ops and self.binary_ops.current_view is not None,
                    "filename": self.binary_ops.current_view.file.filename
                    if self.binary_ops and self.binary_ops.current_view
                    else None,
                }
                self._send_json_response(status)

            elif path == "/functions" or path == "/methods":
                functions = self.binary_ops.get_function_names(offset, limit)
                bn.log_info(f"Found {len(functions)} functions")
                self._send_json_response({"functions": functions})

            elif path == "/classes":
                classes = self.binary_ops.get_class_names(offset, limit)
                self._send_json_response({"classes": classes})

            elif path == "/segments":
                segments = self.binary_ops.get_segments(offset, limit)
                self._send_json_response({"segments": segments})

            elif path == "/imports":
                imports = self.endpoints.get_imports(offset, limit)
                self._send_json_response({"imports": imports})

            elif path == "/binaries" or path == "/views":
                # List managed/open binaries
                self._send_json_response(self.endpoints.list_binaries())

            elif path == "/selectBinary":
                ident = (
                    params.get("view")
                    or params.get("binary")
                    or params.get("id")
                    or params.get("file")
                )
                if not ident:
                    self._send_json_response(
                        {
                            "error": "Missing parameter",
                            "help": "Use ?view=<id|filename>",
                        },
                        400,
                    )
                else:
                    self._send_json_response(self.endpoints.select_binary(ident))

            elif path == "/exports":
                exports = self.endpoints.get_exports(offset, limit)
                self._send_json_response({"exports": exports})
            elif path == "/sections":
                try:
                    sections = self.binary_ops.get_sections(offset, limit)
                    self._send_json_response({"sections": sections})
                except Exception as e:
                    bn.log_error(f"Error getting sections: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            elif path == "/entryPoints":
                try:
                    eps = self.endpoints.get_entry_points()
                    self._send_json_response({"entry_points": eps})
                except Exception as e:
                    bn.log_error(f"Error handling entryPoints: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/namespaces":
                namespaces = self.endpoints.get_namespaces(offset, limit)
                self._send_json_response({"namespaces": namespaces})

            elif path == "/data":
                try:
                    # length: desired byte count to read for preview; negative means "read exact defined size"
                    length_param = params.get("length")
                    preview_param = params.get("previewLen")
                    if length_param is not None:
                        read_len = parse_int_or_default(length_param, 32)
                    elif preview_param is not None:
                        read_len = parse_int_or_default(preview_param, 32)
                    else:
                        # Default: read exact defined size when available
                        read_len = -1
                    data_items = self.binary_ops.get_defined_data(offset, limit, read_len)
                    self._send_json_response({"data": data_items})
                except Exception as e:
                    bn.log_error(f"Error getting data items: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/localTypes":
                try:
                    include_libs = params.get("includeLibraries") in (
                        "1",
                        "true",
                        "True",
                    )
                    types = self.binary_ops.list_local_types(
                        offset, limit, include_libraries=include_libs
                    )
                    bn.log_info(
                        f"/localTypes returned {len(types)} entries (offset={offset}, limit={limit})"
                    )
                    self._send_json_response({"types": types})
                except Exception as e:
                    bn.log_error(f"Error listing local types: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/searchTypes":
                try:
                    term = params.get("query") or params.get("q")
                    if not term:
                        self._send_json_response(
                            {
                                "error": "Missing query parameter",
                                "help": "Required: query or q",
                            },
                            400,
                        )
                        return
                    # support count=-1 to return all
                    eff_limit = (
                        -1
                        if (params.get("count") == "-1" or params.get("limit") == "-1")
                        else limit
                    )
                    include_libs = params.get("includeLibraries") in (
                        "1",
                        "true",
                        "True",
                    )
                    # First compute total
                    all_matches = self.binary_ops.search_local_types(
                        term, 0, -1, include_libraries=include_libs
                    )
                    page = (
                        all_matches[offset:]
                        if eff_limit < 0
                        else all_matches[offset : offset + eff_limit]
                    )
                    self._send_json_response(
                        {
                            "types": page,
                            "query": term,
                            "total": len(all_matches),
                            "offset": offset,
                            "limit": eff_limit,
                            "includeLibraries": include_libs,
                        }
                    )
                except Exception as e:
                    bn.log_error(f"Error searching local types: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/strings":
                try:
                    bn.log_info(
                        f"/strings request: offset={offset}, limit={limit}, raw_params={params}"
                    )
                    strings = self.binary_ops.get_strings(offset, limit)
                    self._send_json_response({"strings": strings})
                except Exception as e:
                    bn.log_error(f"Error getting strings: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/allStrings":
                try:
                    # Return all strings without pagination
                    bn.log_info("/allStrings request received")
                    strings = self.binary_ops.get_strings(0, 2147483647)
                    self._send_json_response({"strings": strings})
                except Exception as e:
                    bn.log_error(f"Error getting all strings: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/hexdump":
                try:
                    address_str = params.get("address")
                    if not address_str:
                        self._set_headers(content_type="text/plain", status_code=400)
                        self.wfile.write(b"Missing address parameter\n")
                        return
                    # Parse address
                    try:
                        addr = (
                            int(address_str, 16)
                            if address_str.startswith("0x")
                            else int(
                                address_str,
                                16
                                if all(c in "0123456789abcdefABCDEF" for c in address_str)
                                else 10,
                            )
                        )
                    except Exception:
                        self._set_headers(content_type="text/plain", status_code=400)
                        self.wfile.write(b"Invalid address format; use hex like 0x401000\n")
                        return

                    # Determine length
                    length_param = params.get("length")
                    read_len = None
                    if length_param is not None:
                        try:
                            read_len = int(length_param)
                        except Exception:
                            read_len = None
                    # Default to exact defined size when available
                    if read_len is None:
                        read_len = -1

                    # If negative, try to use exact defined size at this address
                    if read_len < 0:
                        try:
                            inferred = self.binary_ops.infer_data_size(addr)
                            if inferred is not None and inferred > 0:
                                read_len = int(inferred)
                        except Exception:
                            pass
                    # Fallback default length
                    if read_len is None or read_len < 0:
                        read_len = 64

                    # Read bytes
                    try:
                        data = self.binary_ops.current_view.read(addr, read_len)
                        if data is None:
                            data = b""
                    except Exception:
                        data = b""

                    # Resolve symbol name for header label
                    label = None
                    try:
                        sym = self.binary_ops.current_view.get_symbol_at(addr)
                        if sym and hasattr(sym, "name"):
                            label = sym.name
                    except Exception:
                        label = None

                    # Build hexdump
                    def _printable(b: int) -> str:
                        try:
                            return chr(b) if 32 <= b <= 126 else "."
                        except Exception:
                            return "."

                    lines = []
                    addr_hex = format(addr, "x")
                    if label:
                        lines.append(f"{addr_hex}  {label}:")
                    else:
                        lines.append(f"{addr_hex}:")

                    total = len(data)
                    offset = 0
                    # First line may be unaligned
                    first_pad = addr % 16
                    if first_pad != 0 and total > 0:
                        take = min(16 - first_pad, total)
                        chunk = data[0:take]
                        hex_area = ("   " * first_pad) + "".join(f"{b:02x} " for b in chunk)
                        hex_area += "   " * (16 - first_pad - take)
                        ascii_area = (" " * first_pad) + "".join(_printable(b) for b in chunk)
                        ascii_area += " " * (16 - first_pad - take)
                        lines.append(f"{addr_hex}  {hex_area} {ascii_area}")
                        offset += take
                    # Full lines
                    while offset < total:
                        line_addr = addr + offset
                        take = min(16, total - offset)
                        chunk = data[offset : offset + take]
                        hex_area = "".join(f"{b:02x} " for b in chunk) + ("   " * (16 - take))
                        ascii_area = "".join(_printable(b) for b in chunk) + (" " * (16 - take))
                        lines.append(f"{format(line_addr, 'x')}  {hex_area} {ascii_area}")
                        offset += take

                    text = "\n".join(lines) + "\n"
                    self._set_headers(content_type="text/plain", status_code=200)
                    self.wfile.write(text.encode("utf-8", errors="replace"))
                except Exception as e:
                    bn.log_error(f"Error handling hexdump: {e}")
                    self._set_headers(content_type="text/plain", status_code=500)
                    self.wfile.write(f"Error: {e}\n".encode())

            elif path == "/hexdumpByName":
                try:
                    name = params.get("name") or params.get("symbol") or params.get("raw_name")
                    if not name:
                        self._set_headers(content_type="text/plain", status_code=400)
                        self.wfile.write(b"Missing name parameter\n")
                        return

                    addr, label = self._resolve_name_to_address(name)
                    if addr is None:
                        self._set_headers(content_type="text/plain", status_code=404)
                        self.wfile.write(b"Symbol not found\n")
                        return

                    # Determine length
                    length_param = params.get("length")
                    try:
                        read_len = int(length_param) if length_param is not None else -1
                    except Exception:
                        read_len = -1
                    if read_len < 0:
                        try:
                            inferred = self.binary_ops.infer_data_size(addr)
                            if inferred is not None and inferred > 0:
                                read_len = int(inferred)
                        except Exception:
                            pass
                    if read_len is None or read_len < 0:
                        read_len = 64

                    # Read and format
                    try:
                        data = self.binary_ops.current_view.read(addr, read_len) or b""
                    except Exception:
                        data = b""

                    def _printable(b: int) -> str:
                        try:
                            return chr(b) if 32 <= b <= 126 else "."
                        except Exception:
                            return "."

                    lines = []
                    addr_hex = format(addr, "x")
                    lines.append(f"{addr_hex}  {label}:")

                    total = len(data)
                    offset = 0
                    first_pad = addr % 16
                    if first_pad != 0 and total > 0:
                        take = min(16 - first_pad, total)
                        chunk = data[0:take]
                        hex_area = ("   " * first_pad) + "".join(f"{b:02x} " for b in chunk)
                        hex_area += "   " * (16 - first_pad - take)
                        ascii_area = (" " * first_pad) + "".join(_printable(b) for b in chunk)
                        ascii_area += " " * (16 - first_pad - take)
                        lines.append(f"{addr_hex}  {hex_area} {ascii_area}")
                        offset += take
                    while offset < total:
                        line_addr = addr + offset
                        take = min(16, total - offset)
                        chunk = data[offset : offset + take]
                        hex_area = "".join(f"{b:02x} " for b in chunk) + ("   " * (16 - take))
                        ascii_area = "".join(_printable(b) for b in chunk) + (" " * (16 - take))
                        lines.append(f"{format(line_addr, 'x')}  {hex_area} {ascii_area}")
                        offset += take

                    text = "\n".join(lines) + "\n"
                    self._set_headers(content_type="text/plain", status_code=200)
                    self.wfile.write(text.encode("utf-8", errors="replace"))
                except Exception as e:
                    bn.log_error(f"Error handling hexdumpByName: {e}")
                    self._set_headers(content_type="text/plain", status_code=500)
                    self.wfile.write(f"Error: {e}\n".encode())

            elif path == "/getDataDecl":
                try:
                    ident = (
                        params.get("name")
                        or params.get("symbol")
                        or params.get("raw_name")
                        or params.get("address")
                    )
                    if not ident:
                        self._send_json_response(
                            {
                                "error": "Missing name/address parameter",
                                "help": "Provide name, symbol, raw_name, or address",
                            },
                            400,
                        )
                        return
                    addr, label = self._resolve_name_to_address(ident)
                    if addr is None:
                        self._send_json_response({"error": "Symbol not found", "ident": ident}, 404)
                        return

                    # Determine exact size and type
                    size = None
                    type_text = None
                    try:
                        bv = self.binary_ops.current_view
                        dv = bv.get_data_var_at(addr) if hasattr(bv, "get_data_var_at") else None
                        typ_obj = (
                            dv.type
                            if (dv is not None and hasattr(dv, "type"))
                            else (bv.get_type_at(addr) if hasattr(bv, "get_type_at") else None)
                        )
                        if typ_obj is not None:
                            type_text = str(typ_obj)
                            if hasattr(typ_obj, "width") and typ_obj.width:
                                size = int(typ_obj.width)
                    except Exception:
                        pass
                    if size is None:
                        try:
                            inferred = self.binary_ops.infer_data_size(addr)
                            if inferred and inferred > 0:
                                size = int(inferred)
                        except Exception:
                            pass
                    if size is None:
                        size = 64

                    # Read bytes
                    try:
                        raw = self.binary_ops.current_view.read(addr, size) or b""
                    except Exception:
                        raw = b""

                    # Build a declaration string (best-effort)
                    decl = None
                    try:
                        # Prefer explicit char[] initialization when printable
                        is_char_array = (type_text or "").lower().startswith(
                            "char"
                        ) or "char [" in (type_text or "").lower()
                        if is_char_array and raw:
                            esc = self._c_escape(raw.rstrip(b"\x00"))
                            decl = f"{type_text} {label} = {esc};"
                        else:
                            if type_text:
                                decl = f"{type_text} {label};"
                            else:
                                decl = f"/* size={size} */ {label};"
                    except Exception:
                        decl = f"/* size={size} */ {label};"

                    # Also include a hexdump for convenience
                    # Reuse the hexdump generation above
                    def _printable(b: int) -> str:
                        try:
                            return chr(b) if 32 <= b <= 126 else "."
                        except Exception:
                            return "."

                    lines = []
                    addr_hex = format(addr, "x")
                    lines.append(f"{addr_hex}  {label}:")
                    total = len(raw)
                    offset = 0
                    first_pad = addr % 16
                    if first_pad != 0 and total > 0:
                        take = min(16 - first_pad, total)
                        chunk = raw[0:take]
                        hex_area = ("   " * first_pad) + "".join(f"{b:02x} " for b in chunk)
                        hex_area += "   " * (16 - first_pad - take)
                        ascii_area = (" " * first_pad) + "".join(_printable(b) for b in chunk)
                        ascii_area += " " * (16 - first_pad - take)
                        lines.append(f"{addr_hex}  {hex_area} {ascii_area}")
                        offset += take
                    while offset < total:
                        line_addr = addr + offset
                        take = min(16, total - offset)
                        chunk = raw[offset : offset + take]
                        hex_area = "".join(f"{b:02x} " for b in chunk) + ("   " * (16 - take))
                        ascii_area = "".join(_printable(b) for b in chunk) + (" " * (16 - take))
                        lines.append(f"{format(line_addr, 'x')}  {hex_area} {ascii_area}")
                        offset += take
                    hexdump_text = "\n".join(lines) + "\n"

                    self._send_json_response(
                        {
                            "address": hex(addr),
                            "name": label,
                            "size": size,
                            "type": type_text,
                            "decl": decl,
                            "hexdump": hexdump_text,
                        }
                    )
                except Exception as e:
                    bn.log_error(f"Error handling getDataDecl: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/strings/filter":
                try:
                    pattern = params.get("filter", "")
                    bn.log_info(
                        f"/strings/filter request: offset={offset}, limit={limit}, pattern={pattern}"
                    )
                    # Get all strings first, then filter and paginate
                    all_strings = self.binary_ops.get_strings(0, 2147483647)
                    if pattern:
                        pl = pattern.lower()
                        filtered = [
                            s
                            for s in all_strings
                            if isinstance(s.get("value"), str) and pl in s.get("value", "").lower()
                        ]
                    else:
                        filtered = all_strings
                    page = filtered[offset : offset + limit]
                    self._send_json_response({"strings": page, "total": len(filtered)})
                except Exception as e:
                    bn.log_error(f"Error filtering strings: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/searchFunctions":
                search_term = params.get("query", "")
                matches = self.endpoints.search_functions(search_term, offset, limit)
                self._send_json_response({"matches": matches})

            elif path == "/decompile":
                function_name = params.get("name") or params.get("functionName")
                if not function_name:
                    self._send_json_response(
                        {
                            "error": "Missing function name parameter. Use ?name=function_name or ?functionName=function_name"
                        },
                        400,
                    )
                    return

                self._handle_decompile(function_name)

            elif path == "/assembly":
                function_name = params.get("name") or params.get("functionName")
                if not function_name:
                    self._send_json_response(
                        {
                            "error": "Missing function name parameter. Use ?name=function_name or ?functionName=function_name"
                        },
                        400,
                    )
                    return

                try:
                    func_info = self.binary_ops.get_function_info(function_name)
                    if not func_info:
                        bn.log_error(f"Function not found: {function_name}")
                        self._send_json_response(
                            {
                                "error": "Function not found",
                                "requested_name": function_name,
                                "available_functions": self.binary_ops.get_function_names(0, 10),
                            },
                            404,
                        )
                        return

                    bn.log_info(f"Found function for assembly: {func_info}")
                    assembly = self.binary_ops.get_assembly_function(function_name)

                    if assembly is None:
                        self._send_json_response(
                            {
                                "error": "Assembly retrieval failed",
                                "function": func_info,
                                "reason": "Function assembly could not be retrieved. Check the Binary Ninja log for detailed error information.",
                            },
                            500,
                        )
                    else:
                        self._send_json_response({"assembly": assembly, "function": func_info})
                except Exception as e:
                    bn.log_error(f"Error handling assembly request: {e!s}")
                    import traceback

                    bn.log_error(traceback.format_exc())
                    self._send_json_response(
                        {
                            "error": "Assembly retrieval failed",
                            "requested_name": function_name,
                            "exception": str(e),
                        },
                        500,
                    )

            elif path == "/il":
                # Return IL by view (hlil/mlil/llil) and optional SSA form
                ident = params.get("name") or params.get("functionName") or params.get("address")
                if not ident:
                    self._send_json_response(
                        {
                            "error": "Missing function identifier",
                            "help": "Use ?name=<func> or ?address=<hex> with optional &view=hlil|mlil|llil&ssa=0|1",
                            "received": params,
                        },
                        400,
                    )
                    return

                view = (params.get("view") or params.get("il") or "hlil").strip()
                ssa_param = (params.get("ssa") or params.get("isSSA") or "0").strip().lower()
                ssa = ssa_param in ("1", "true", "yes", "on")

                try:
                    func_info = self.binary_ops.get_function_info(ident)
                    if not func_info:
                        self._send_json_response(
                            {
                                "error": "Function not found",
                                "requested": ident,
                                "available_functions": self.binary_ops.get_function_names(0, 10),
                            },
                            404,
                        )
                        return

                    il_text = self.binary_ops.get_function_il(ident, view=view, ssa=ssa)
                    if il_text is None:
                        self._send_json_response(
                            {
                                "error": "Failed to get IL",
                                "function": func_info,
                                "view": view,
                                "ssa": ssa,
                                "reason": "Unsupported IL view or unavailable instructions",
                            },
                            500,
                        )
                        return

                    self._send_json_response(
                        {"il": il_text, "function": func_info, "view": view, "ssa": ssa}
                    )
                except Exception as e:
                    bn.log_error(f"Error handling IL request: {e!s}")
                    self._send_json_response(
                        {
                            "error": "IL retrieval failed",
                            "requested": ident,
                            "view": view,
                            "ssa": ssa,
                            "exception": str(e),
                        },
                        500,
                    )

            elif path == "/functionAt":
                address_str = params.get("address")
                if not address_str:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required parameter: address (in hex format, e.g., 0x41d100) the address of an insruction",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    # Convert hex string to integer
                    if isinstance(address_str, str) and address_str.startswith("0x"):
                        offset = int(address_str, 16)
                    else:
                        offset = int(address_str)

                    # Add function to binary_operations.py
                    function_names = self.binary_ops.get_functions_containing_address(offset)

                    self._send_json_response({"address": hex(offset), "functions": function_names})
                except ValueError:
                    self._send_json_response(
                        {
                            "error": "Invalid address format",
                            "help": "Address must be a valid hexadecimal (0x...) or decimal number",
                            "received": address_str,
                        },
                        400,
                    )
                except Exception as e:
                    bn.log_error(f"Error handling function_at request: {e}")
                    self._send_json_response(
                        {
                            "error": str(e),
                            "address": address_str,
                        },
                        500,
                    )

            elif path == "/getUserDefinedType":
                type_name = params.get("name")
                if not type_name:
                    self._send_json_response(
                        {
                            "error": "Missing name parameter",
                            "help": "Required parameter: name (name of the user-defined type to retrieve)",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    # Get the user-defined type definition
                    type_info = self.binary_ops.get_user_defined_type(type_name)

                    if type_info:
                        self._send_json_response(type_info)
                    else:
                        # If type not found, list available types for reference
                        available_types = {}

                        try:
                            if (
                                hasattr(self.binary_ops._current_view, "user_type_container")
                                and self.binary_ops._current_view.user_type_container
                            ):
                                for (
                                    type_id
                                ) in self.binary_ops._current_view.user_type_container.types.keys():
                                    current_type = (
                                        self.binary_ops._current_view.user_type_container.types[
                                            type_id
                                        ]
                                    )
                                    available_types[current_type[0]] = (
                                        str(current_type[1].type)
                                        if hasattr(current_type[1], "type")
                                        else "unknown"
                                    )
                        except Exception as e:
                            bn.log_error(f"Error listing available types: {e}")

                        self._send_json_response(
                            {
                                "error": "Type not found",
                                "requested_type": type_name,
                                "available_types": available_types,
                            },
                            404,
                        )
                except Exception as e:
                    bn.log_error(f"Error handling getUserDefinedType request: {e}")
                    self._send_json_response(
                        {
                            "error": str(e),
                            "type_name": type_name,
                        },
                        500,
                    )

            elif path == "/comment":
                if self.command == "GET":
                    address = params.get("address")
                    if not address:
                        self._send_json_response(
                            {
                                "error": "Missing address parameter",
                                "help": "Required parameter: address",
                                "received": params,
                            },
                            400,
                        )
                        return

                    try:
                        address_int = int(address, 16) if isinstance(address, str) else int(address)
                        comment = self.binary_ops.get_comment(address_int)
                        if comment is not None:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "address": hex(address_int),
                                    "comment": comment,
                                }
                            )
                        else:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "address": hex(address_int),
                                    "comment": None,
                                    "message": "No comment found at this address",
                                }
                            )
                    except ValueError:
                        self._send_json_response({"error": "Invalid address format"}, 400)
                elif self.command == "DELETE":
                    address = params.get("address")
                    if not address:
                        self._send_json_response(
                            {
                                "error": "Missing address parameter",
                                "help": "Required parameter: address",
                                "received": params,
                            },
                            400,
                        )
                        return

                    try:
                        address_int = int(address, 16) if isinstance(address, str) else int(address)
                        success = self.binary_ops.delete_comment(address_int)
                        if success:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "message": f"Successfully deleted comment at {hex(address_int)}",
                                }
                            )
                        else:
                            self._send_json_response(
                                {
                                    "error": "Failed to delete comment",
                                    "message": "The comment could not be deleted at the specified address.",
                                },
                                500,
                            )
                    except ValueError:
                        self._send_json_response({"error": "Invalid address format"}, 400)
                else:  # POST
                    address = params.get("address")
                    comment = params.get("comment")
                    if not address or comment is None:
                        self._send_json_response(
                            {
                                "error": "Missing parameters",
                                "help": "Required parameters: address and comment",
                                "received": params,
                            },
                            400,
                        )
                        return

                    try:
                        address_int = int(address, 16) if isinstance(address, str) else int(address)
                        success = self.binary_ops.set_comment(address_int, comment)
                        if success:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "message": f"Successfully set comment at {hex(address_int)}",
                                    "comment": comment,
                                }
                            )
                        else:
                            self._send_json_response(
                                {
                                    "error": "Failed to set comment",
                                    "message": "The comment could not be set at the specified address.",
                                },
                                500,
                            )
                    except ValueError:
                        self._send_json_response({"error": "Invalid address format"}, 400)

            elif path == "/comment/function":
                if self.command == "GET":
                    function_name = params.get("name") or params.get("functionName")
                    if not function_name:
                        self._send_json_response(
                            {
                                "error": "Missing function name parameter",
                                "help": "Required parameter: name (or functionName)",
                                "received": params,
                            },
                            400,
                        )
                        return

                    comment = self.binary_ops.get_function_comment(function_name)
                    if comment is not None:
                        self._send_json_response(
                            {
                                "success": True,
                                "function": function_name,
                                "comment": comment,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "success": True,
                                "function": function_name,
                                "comment": None,
                                "message": "No comment found for this function",
                            }
                        )
                elif self.command == "DELETE":
                    function_name = params.get("name") or params.get("functionName")
                    if not function_name:
                        self._send_json_response(
                            {
                                "error": "Missing function name parameter",
                                "help": "Required parameter: name (or functionName)",
                                "received": params,
                            },
                            400,
                        )
                        return

                    success = self.binary_ops.delete_function_comment(function_name)
                    if success:
                        self._send_json_response(
                            {
                                "success": True,
                                "message": f"Successfully deleted comment for function {function_name}",
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "error": "Failed to delete function comment",
                                "message": "The comment could not be deleted for the specified function.",
                            },
                            500,
                        )
                else:  # POST
                    function_name = params.get("name") or params.get("functionName")
                    comment = params.get("comment")
                    if not function_name or comment is None:
                        self._send_json_response(
                            {
                                "error": "Missing parameters",
                                "help": "Required parameters: name (or functionName) and comment",
                                "received": params,
                            },
                            400,
                        )
                        return

                    success = self.binary_ops.set_function_comment(function_name, comment)
                    if success:
                        self._send_json_response(
                            {
                                "success": True,
                                "message": f"Successfully set comment for function {function_name}",
                                "comment": comment,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "error": "Failed to set function comment",
                                "message": "The comment could not be set for the specified function.",
                            },
                            500,
                        )

            elif path == "/getComment":
                address = params.get("address")
                if not address:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required parameter: address",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    address_int = int(address, 16) if isinstance(address, str) else int(address)
                    comment = self.binary_ops.get_comment(address_int)
                    if comment is not None:
                        self._send_json_response(
                            {
                                "success": True,
                                "address": hex(address_int),
                                "comment": comment,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "success": True,
                                "address": hex(address_int),
                                "comment": None,
                                "message": "No comment found at this address",
                            }
                        )
                except ValueError:
                    self._send_json_response({"error": "Invalid address format"}, 400)

            elif path == "/getFunctionComment":
                function_name = params.get("name") or params.get("functionName")
                if not function_name:
                    self._send_json_response(
                        {
                            "error": "Missing function name parameter",
                            "help": "Required parameter: name (or functionName)",
                            "received": params,
                        },
                        400,
                    )
                    return

                comment = self.binary_ops.get_function_comment(function_name)
                if comment is not None:
                    self._send_json_response(
                        {
                            "success": True,
                            "function": function_name,
                            "comment": comment,
                        }
                    )
                else:
                    self._send_json_response(
                        {
                            "success": True,
                            "function": function_name,
                            "comment": None,
                            "message": "No comment found for this function",
                        }
                    )
            elif path == "/setFunctionPrototype":
                # Accept both GET and POST to support long prototypes via POST body
                address_str = (
                    params.get("address")
                    or params.get("functionAddress")
                    or params.get("addr")
                    or params.get("name")
                )
                proto = params.get("prototype") or params.get("signature") or params.get("type")
                if not address_str or proto is None:
                    self._send_json_response(
                        {
                            "error": "Missing parameters",
                            "help": "Required: address (or functionAddress/addr) and prototype (or signature/type)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    # Do minimal validation here; the endpoint will resolve name or address
                    result = self.endpoints.set_function_prototype(address_str, proto)
                    self._send_json_response(result)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling setFunctionPrototype request: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            elif path == "/makeFunctionAt":
                # Create a function at an address (idempotent if already exists)
                address_str = params.get("address") or params.get("addr")
                arch = params.get("platform") or params.get("arch") or params.get("architecture")
                if not address_str:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required: address (hex like 0x401000 or decimal). Optional: platform (e.g., linux-x86_64; use 'default' for view default)",
                        },
                        400,
                    )
                    return
                try:
                    res = self.endpoints.make_function_at(address_str, arch)
                    # If the endpoint signals an error, forward with 400 so clients can react properly
                    if isinstance(res, dict) and res.get("error"):
                        self._send_json_response(res, 400)
                    else:
                        self._send_json_response(res)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling makeFunctionAt: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            elif path == "/platforms":
                try:
                    self._send_json_response(self.endpoints.list_platforms())
                except Exception as e:
                    bn.log_error(f"Error listing platforms: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            elif path == "/setLocalVariableType":
                fn_ident = (
                    params.get("functionAddress")
                    or params.get("address")
                    or params.get("function")
                    or params.get("functionName")
                    or params.get("name")
                )
                var_name = (
                    params.get("variableName") or params.get("variable") or params.get("nameOrVar")
                )
                new_type = params.get("newType") or params.get("type") or params.get("signature")
                if not fn_ident or not var_name or new_type is None:
                    self._send_json_response(
                        {
                            "error": "Missing parameters",
                            "help": "Required: functionAddress (or address/name), variableName, newType (or type/signature)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    res = self.endpoints.set_local_variable_type(fn_ident, var_name, new_type)
                    self._send_json_response(res)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling setLocalVariableType request: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            elif path == "/retypeVariable":
                function_name = params.get("functionName")
                if not function_name:
                    self._send_json_response({"error": "Missing function name parameter"}, 400)
                    return

                variable_name = params.get("variableName")
                if not variable_name:
                    self._send_json_response({"error": "Missing variable name parameter"}, 400)
                    return

                type_str = params.get("type")
                if not type_str:
                    self._send_json_response({"error": "Missing type parameter"}, 400)
                    return

                try:
                    self._send_json_response(
                        self.endpoints.retype_variable(function_name, variable_name, type_str)
                    )
                except Exception as e:
                    bn.log_error(f"Error handling retypeVariable request: {e}")
                    self._send_json_response(
                        {"error": str(e)},
                        500,
                    )
            elif path == "/renameVariable":
                function_name = params.get("functionName")
                if not function_name:
                    self._send_json_response({"error": "Missing function name parameter"}, 400)
                    return

                variable_name = params.get("variableName")
                if not variable_name:
                    self._send_json_response({"error": "Missing variable name parameter"}, 400)
                    return

                new_name = params.get("newName")
                if not new_name:
                    self._send_json_response({"error": "Missing new name parameter"}, 400)
                    return

                try:
                    self._send_json_response(
                        self.endpoints.rename_variable(function_name, variable_name, new_name)
                    )
                except Exception as e:
                    bn.log_error(f"Error handling renameVariable request: {e}")
                    self._send_json_response(
                        {"error": str(e)},
                        500,
                    )

            elif path == "/renameVariables":
                # Batch rename local variables in a function
                # Accept flexible identifiers and payload formats (GET/POST)
                fn_ident = (
                    params.get("functionAddress")
                    or params.get("address")
                    or params.get("function")
                    or params.get("functionName")
                    or params.get("name")
                )
                if not fn_ident:
                    self._send_json_response(
                        {
                            "error": "Missing function identifier",
                            "help": "Provide functionAddress/address or functionName/name",
                            "received": params,
                        },
                        400,
                    )
                    return

                raw_renames = None
                # Prefer explicit 'renames' in JSON when POSTed
                if isinstance(params, dict) and "renames" in params:
                    raw_renames = params.get("renames")
                # Or a JSON mapping under 'mapping'
                if raw_renames is None and "mapping" in params:
                    try:
                        m = params.get("mapping")
                        if isinstance(m, str):
                            raw_renames = json.loads(m)
                        else:
                            raw_renames = m
                    except Exception:
                        raw_renames = None
                # Or a compact 'pairs' string: old1:new1,old2:new2
                if raw_renames is None and "pairs" in params:
                    pairs_str = params.get("pairs") or ""
                    mapping = {}
                    try:
                        for item in pairs_str.split(","):
                            if not item.strip():
                                continue
                            if ":" in item:
                                o, n = item.split(":", 1)
                                mapping[o.strip()] = n.strip()
                    except Exception:
                        mapping = {}
                    raw_renames = mapping

                if raw_renames is None:
                    self._send_json_response(
                        {
                            "error": "Missing renames payload",
                            "help": "Provide 'renames' (array of {old,new}) or 'mapping' (JSON object old->new) or 'pairs' (old:new,...)",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    result = self.endpoints.rename_variables(fn_ident, raw_renames)
                    self._send_json_response(result)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling renameVariables request: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getXrefsTo":
                address_str = params.get("address")
                if not address_str:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required parameter: address (hex like 0x401000 or decimal)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    result = self.binary_ops.get_xrefs_to_address(address_str)
                    self._send_json_response(result)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling getXrefsTo request: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getXrefsToField":
                struct_name = params.get("struct") or params.get("structName")
                field_name = params.get("field") or params.get("fieldName")
                if not struct_name or not field_name:
                    self._send_json_response(
                        {
                            "error": "Missing parameters",
                            "help": "Required: struct (or structName), field (or fieldName)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    refs = self.binary_ops.get_xrefs_to_field(struct_name, field_name)
                    self._send_json_response(
                        {"struct": struct_name, "field": field_name, "references": refs}
                    )
                except Exception as e:
                    bn.log_error(f"Error handling getXrefsToField: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getXrefsToStruct":
                struct_name = params.get("name") or params.get("struct") or params.get("structName")
                if not struct_name:
                    self._send_json_response(
                        {
                            "error": "Missing struct name parameter",
                            "help": "Required: name (or struct/structName)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    refs = self.binary_ops.get_xrefs_to_struct(struct_name)
                    self._send_json_response(refs)
                except Exception as e:
                    bn.log_error(f"Error handling getXrefsToStruct: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getXrefsToType":
                type_name = params.get("name") or params.get("type") or params.get("typeName")
                if not type_name:
                    self._send_json_response(
                        {
                            "error": "Missing type name parameter",
                            "help": "Required: name (or type/typeName)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    refs = self.binary_ops.get_xrefs_to_type(type_name)
                    self._send_json_response(refs)
                except Exception as e:
                    bn.log_error(f"Error handling getXrefsToType: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getTypeInfo":
                type_name = params.get("name") or params.get("type") or params.get("typeName")
                if not type_name:
                    self._send_json_response(
                        {
                            "error": "Missing type name parameter",
                            "help": "Required: name (or type/typeName)",
                        },
                        400,
                    )
                    return
                try:
                    info = self.binary_ops.get_type_info(type_name)
                    self._send_json_response(info)
                except Exception as e:
                    bn.log_error(f"Error handling getTypeInfo: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getXrefsToEnum":
                enum_name = params.get("name") or params.get("enum") or params.get("enumName")
                if not enum_name:
                    self._send_json_response(
                        {
                            "error": "Missing enum name parameter",
                            "help": "Required: name (or enum/enumName)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    refs = self.binary_ops.get_xrefs_to_enum(enum_name)
                    self._send_json_response(refs)
                except Exception as e:
                    bn.log_error(f"Error handling getXrefsToEnum: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            # '/displayAs' endpoint removed per request

            elif path == "/formatValue":
                # Compute representations and annotate BN at an address
                text = params.get("text")
                size_param = params.get("size")
                address_str = params.get("address")
                if not text or not address_str:
                    self._send_json_response(
                        {
                            "error": "Missing parameters",
                            "help": "Required: address, text. Optional: size",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    # Parse address
                    if isinstance(address_str, str) and address_str.startswith("0x"):
                        addr = int(address_str, 16)
                    else:
                        addr = int(address_str)
                except Exception:
                    self._send_json_response({"error": "Invalid address format"}, 400)
                    return

                try:
                    conv = util_convert_number(text, size_param)
                    # Create a concise annotation
                    bases = conv.get("bases", {})
                    c_lit = conv.get("c_literal")
                    c_str = conv.get("c_string")
                    parts = []
                    if "hex" in bases:
                        parts.append(f"hex={bases['hex']}")
                    if "dec" in bases:
                        parts.append(f"dec={bases['dec']}")
                    if c_lit:
                        parts.append(f"char={c_lit}")
                    if c_str:
                        # Trim long strings for comments
                        s = c_str
                        if len(s) > 64:
                            s = s[:61] + '"…'
                        parts.append(f"str={s}")
                    annot = "Converted: " + ", ".join(parts) if parts else f"Converted: {conv}"

                    applied = self.binary_ops.set_comment(addr, annot)
                    self._send_json_response(
                        {
                            "address": hex(addr),
                            "converted": conv,
                            "applied_comment": bool(applied),
                            "comment": annot,
                        }
                    )
                except Exception as e:
                    bn.log_error(f"Error handling formatValue: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/convertNumber":
                # Compute number/string representations (bases, LE/BE, C literals)
                try:
                    text = params.get("text")
                    size_param = params.get("size")
                    if text is None:
                        self._send_json_response(
                            {
                                "error": "Missing text parameter",
                                "help": "Required: text. Optional: size (1,2,4,8 or 0 for auto)",
                                "received": params,
                            },
                            400,
                        )
                        return
                    conv = util_convert_number(text, size_param)
                    self._send_json_response(conv)
                except Exception as e:
                    bn.log_error(f"Error handling convertNumber: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getXrefsToUnion":
                union_name = params.get("name") or params.get("union") or params.get("unionName")
                if not union_name:
                    self._send_json_response(
                        {
                            "error": "Missing union name parameter",
                            "help": "Required: name (or union/unionName)",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    refs = self.binary_ops.get_xrefs_to_union(union_name)
                    self._send_json_response(refs)
                except Exception as e:
                    bn.log_error(f"Error handling getXrefsToUnion: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/getStackFrameVars":
                function_identifier = params.get("name") or params.get("address")
                if not function_identifier:
                    self._send_json_response(
                        {
                            "error": "Missing required parameter: name or address",
                            "received": params,
                        },
                        400,
                    )
                    return
                try:
                    result = self.endpoints.get_stack_frame_vars(function_identifier)
                    self._send_json_response({"stack_frame_vars": result})
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling getStackFrameVars request: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/defineTypes":
                c_code = params.get("cCode")
                if not c_code:
                    self._send_json_response({"error": "Missing cCode parameter"}, 400)
                    return

                try:
                    self._send_json_response(self.endpoints.define_types(c_code))
                except Exception as e:
                    bn.log_error(f"Error handling defineTypes request: {e}")
                    self._send_json_response(
                        {"error": str(e)},
                        500,
                    )
            elif path == "/declareCType":
                c_decl = (
                    params.get("declaration")
                    or params.get("cDecl")
                    or params.get("cDeclaration")
                    or params.get("decl")
                )
                if not c_decl:
                    self._send_json_response(
                        {
                            "error": "Missing declaration parameter",
                            "help": "Use 'declaration' with a single C type declaration",
                        },
                        400,
                    )
                    return
                try:
                    self._send_json_response(self.endpoints.declare_c_type(c_decl))
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling declareCType request: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            elif path == "/patch" or path == "/patchBytes":
                address = params.get("address") or params.get("addr")
                data = params.get("data") or params.get("bytes")
                # Parse save_to_file parameter (default True for backwards compatibility)
                save_to_file_param = params.get("save_to_file", True)
                if isinstance(save_to_file_param, bool):
                    save_to_file = save_to_file_param
                else:
                    save_to_file = str(save_to_file_param).lower() not in (
                        "false",
                        "0",
                        "no",
                    )

                if not address:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required: address (hex like 0x401000 or decimal). Optional: data (hex string like '90 90' or '9090'), save_to_file (bool, default true)",
                            "received": params,
                        },
                        400,
                    )
                    return

                if not data:
                    self._send_json_response(
                        {
                            "error": "Missing data parameter",
                            "help": "Required: data (hex string like '90 90' or '9090', or list of integers)",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    # Parse data if it's a JSON string (for list format)
                    if isinstance(data, str):
                        try:
                            # Try to parse as JSON array
                            parsed = json.loads(data)
                            if isinstance(parsed, list):
                                data = parsed
                        except (json.JSONDecodeError, ValueError):
                            # Not JSON, treat as hex string
                            pass

                    result = self.endpoints.patch_bytes(address, data, save_to_file)
                    self._send_json_response(result)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling patch request: {e}")
                    self._send_json_response({"error": str(e)}, 500)
            else:
                self._send_json_response({"error": "Not found"}, 404)

        except Exception as e:
            bn.log_error(f"Error handling GET request: {e}")
            self._send_json_response({"error": str(e)}, 500)

    def _handle_decompile(self, function_name: str):
        """Handle function decompilation requests.

        Args:
            function_name: Name or address of the function to decompile

        Sends JSON response with either:
        - Decompiled function code and metadata
        - Error message with available functions list
        """
        try:
            func_info = self.binary_ops.get_function_info(function_name)
            if not func_info:
                bn.log_error(f"Function not found: {function_name}")
                self._send_json_response(
                    {
                        "error": "Function not found",
                        "requested_name": function_name,
                        "available_functions": self.binary_ops.get_function_names(0, 10),
                    },
                    404,
                )
                return

            bn.log_info(f"Found function for decompilation: {func_info}")
            decompiled = self.binary_ops.decompile_function(function_name)

            if decompiled is None:
                self._send_json_response(
                    {
                        "error": "Decompilation failed",
                        "function": func_info,
                        "reason": "Function could not be decompiled. This might be due to missing debug information or unsupported function type.",
                    },
                    500,
                )
            else:
                self._send_json_response({"decompiled": decompiled, "function": func_info})
        except Exception as e:
            bn.log_error(f"Error during decompilation: {e}")
            self._send_json_response(
                {
                    "error": f"Decompilation error: {e!s}",
                    "requested_name": function_name,
                },
                500,
            )

    def do_POST(self):
        try:
            if not self._check_binary_loaded():
                return

            params = self._parse_post_params()
            path = urllib.parse.urlparse(self.path).path

            bn.log_info(f"POST {path} with params: {params}")

            if path == "/load":
                filepath = params.get("filepath")
                if not filepath:
                    self._send_json_response({"error": "Missing filepath parameter"}, 400)
                    return

                try:
                    self.binary_ops.load_binary(filepath)
                    self._send_json_response(
                        {"success": True, "message": f"Binary loaded: {filepath}"}
                    )
                except Exception as e:
                    self._send_json_response({"error": str(e)}, 500)

            elif path == "/rename/function" or path == "/renameFunction":
                old_name = params.get("oldName") or params.get("old_name")
                new_name = params.get("newName") or params.get("new_name")

                bn.log_info(
                    f"Rename request - old_name: {old_name}, new_name: {new_name}, params: {params}"
                )

                if not old_name or not new_name:
                    self._send_json_response(
                        {
                            "error": "Missing parameters",
                            "help": "Required parameters: oldName (or old_name) and newName (or new_name)",
                            "received": params,
                        },
                        400,
                    )
                    return

                # Handle address format (both 0x... and plain number)
                if isinstance(old_name, str):
                    if old_name.startswith("0x"):
                        try:
                            old_name = int(old_name, 16)
                        except ValueError:
                            pass
                    elif old_name.isdigit():
                        old_name = int(old_name)

                bn.log_info(f"Attempting to rename function: {old_name} -> {new_name}")

                # Apply prefix from settings
                settings = Settings()
                prefix = settings.get_string("mcp.renamePrefix")
                if prefix and not new_name.startswith(prefix):
                    new_name = prefix + new_name
                    bn.log_info(f"Applied prefix '{prefix}': {new_name}")

                # Get function info for validation
                func_info = self.binary_ops.get_function_info(old_name)
                if func_info:
                    bn.log_info(f"Found function: {func_info}")
                    success = self.binary_ops.rename_function(old_name, new_name)
                    if success:
                        self._send_json_response(
                            {
                                "success": True,
                                "message": f"Successfully renamed function from {old_name} to {new_name}",
                                "function": func_info,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "error": "Failed to rename function",
                                "message": "The function was found but could not be renamed. This might be due to permissions or binary restrictions.",
                                "function": func_info,
                            },
                            500,
                        )
                else:
                    available_funcs = self.binary_ops.get_function_names(0, 10)
                    bn.log_error(f"Function not found: {old_name}")
                    self._send_json_response(
                        {
                            "error": "Function not found",
                            "requested": old_name,
                            "help": "Make sure the function exists. You can use either the function name or its address.",
                            "available_functions": available_funcs,
                        },
                        404,
                    )

            elif path == "/rename/data" or path == "/renameData":
                address = params.get("address")
                new_name = params.get("newName") or params.get("new_name")
                if not address or not new_name:
                    self._send_json_response({"error": "Missing parameters"}, 400)
                    return

                try:
                    address_int = int(address, 16) if isinstance(address, str) else int(address)
                    success = self.binary_ops.rename_data(address_int, new_name)
                    self._send_json_response({"success": success})
                except ValueError:
                    self._send_json_response({"error": "Invalid address format"}, 400)

            elif path == "/comment":
                if self.command == "GET":
                    address = params.get("address")
                    if not address:
                        self._send_json_response(
                            {
                                "error": "Missing address parameter",
                                "help": "Required parameter: address",
                                "received": params,
                            },
                            400,
                        )
                        return

                    try:
                        address_int = int(address, 16) if isinstance(address, str) else int(address)
                        comment = self.binary_ops.get_comment(address_int)
                        if comment is not None:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "address": hex(address_int),
                                    "comment": comment,
                                }
                            )
                        else:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "address": hex(address_int),
                                    "comment": None,
                                    "message": "No comment found at this address",
                                }
                            )
                    except ValueError:
                        self._send_json_response({"error": "Invalid address format"}, 400)
                elif self.command == "DELETE":
                    address = params.get("address")
                    if not address:
                        self._send_json_response(
                            {
                                "error": "Missing address parameter",
                                "help": "Required parameter: address",
                                "received": params,
                            },
                            400,
                        )
                        return

                    try:
                        address_int = int(address, 16) if isinstance(address, str) else int(address)
                        success = self.binary_ops.delete_comment(address_int)
                        if success:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "message": f"Successfully deleted comment at {hex(address_int)}",
                                }
                            )
                        else:
                            self._send_json_response(
                                {
                                    "error": "Failed to delete comment",
                                    "message": "The comment could not be deleted at the specified address.",
                                },
                                500,
                            )
                    except ValueError:
                        self._send_json_response({"error": "Invalid address format"}, 400)
                else:  # POST
                    address = params.get("address")
                    comment = params.get("comment")
                    if not address or comment is None:
                        self._send_json_response(
                            {
                                "error": "Missing parameters",
                                "help": "Required parameters: address and comment",
                                "received": params,
                            },
                            400,
                        )
                        return

                    try:
                        address_int = int(address, 16) if isinstance(address, str) else int(address)
                        success = self.binary_ops.set_comment(address_int, comment)
                        if success:
                            self._send_json_response(
                                {
                                    "success": True,
                                    "message": f"Successfully set comment at {hex(address_int)}",
                                    "comment": comment,
                                }
                            )
                        else:
                            self._send_json_response(
                                {
                                    "error": "Failed to set comment",
                                    "message": "The comment could not be set at the specified address.",
                                },
                                500,
                            )
                    except ValueError:
                        self._send_json_response({"error": "Invalid address format"}, 400)

            elif path == "/comment/function":
                if self.command == "GET":
                    function_name = params.get("name") or params.get("functionName")
                    if not function_name:
                        self._send_json_response(
                            {
                                "error": "Missing function name parameter",
                                "help": "Required parameter: name (or functionName)",
                                "received": params,
                            },
                            400,
                        )
                        return

                    comment = self.binary_ops.get_function_comment(function_name)
                    if comment is not None:
                        self._send_json_response(
                            {
                                "success": True,
                                "function": function_name,
                                "comment": comment,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "success": True,
                                "function": function_name,
                                "comment": None,
                                "message": "No comment found for this function",
                            }
                        )
                elif self.command == "DELETE":
                    function_name = params.get("name") or params.get("functionName")
                    if not function_name:
                        self._send_json_response(
                            {
                                "error": "Missing function name parameter",
                                "help": "Required parameter: name (or functionName)",
                                "received": params,
                            },
                            400,
                        )
                        return

                    success = self.binary_ops.delete_function_comment(function_name)
                    if success:
                        self._send_json_response(
                            {
                                "success": True,
                                "message": f"Successfully deleted comment for function {function_name}",
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "error": "Failed to delete function comment",
                                "message": "The comment could not be deleted for the specified function.",
                            },
                            500,
                        )
                else:  # POST
                    function_name = params.get("name") or params.get("functionName")
                    comment = params.get("comment")
                    if not function_name or comment is None:
                        self._send_json_response(
                            {
                                "error": "Missing parameters",
                                "help": "Required parameters: name (or functionName) and comment",
                                "received": params,
                            },
                            400,
                        )
                        return

                    success = self.binary_ops.set_function_comment(function_name, comment)
                    if success:
                        self._send_json_response(
                            {
                                "success": True,
                                "message": f"Successfully set comment for function {function_name}",
                                "comment": comment,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "error": "Failed to set function comment",
                                "message": "The comment could not be set for the specified function.",
                            },
                            500,
                        )

            elif path == "/getComment":
                address = params.get("address")
                if not address:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required parameter: address",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    address_int = int(address, 16) if isinstance(address, str) else int(address)
                    comment = self.binary_ops.get_comment(address_int)
                    if comment is not None:
                        self._send_json_response(
                            {
                                "success": True,
                                "address": hex(address_int),
                                "comment": comment,
                            }
                        )
                    else:
                        self._send_json_response(
                            {
                                "success": True,
                                "address": hex(address_int),
                                "comment": None,
                                "message": "No comment found at this address",
                            }
                        )
                except ValueError:
                    self._send_json_response({"error": "Invalid address format"}, 400)

            elif path == "/getFunctionComment":
                function_name = params.get("functionName") or params.get("name")
                if not function_name:
                    self._send_json_response(
                        {
                            "error": "Missing function name parameter",
                            "help": "Required parameter: name (or functionName)",
                            "received": params,
                        },
                        400,
                    )
                    return

                comment = self.binary_ops.get_function_comment(function_name)
                if comment is not None:
                    self._send_json_response(
                        {
                            "success": True,
                            "function": function_name,
                            "comment": comment,
                        }
                    )
                else:
                    self._send_json_response(
                        {
                            "success": True,
                            "function": function_name,
                            "comment": None,
                            "message": "No comment found for this function",
                        }
                    )

            elif path == "/patch" or path == "/patchBytes":
                address = params.get("address") or params.get("addr")
                data = params.get("data") or params.get("bytes")
                # Parse save_to_file parameter (default True for backwards compatibility)
                save_to_file_param = params.get("save_to_file", True)
                if isinstance(save_to_file_param, bool):
                    save_to_file = save_to_file_param
                else:
                    save_to_file = str(save_to_file_param).lower() not in (
                        "false",
                        "0",
                        "no",
                    )

                if not address:
                    self._send_json_response(
                        {
                            "error": "Missing address parameter",
                            "help": "Required: address (hex like 0x401000 or decimal). Optional: data (hex string like '90 90' or '9090'), save_to_file (bool, default true)",
                            "received": params,
                        },
                        400,
                    )
                    return

                if not data:
                    self._send_json_response(
                        {
                            "error": "Missing data parameter",
                            "help": "Required: data (hex string like '90 90' or '9090', or list of integers)",
                            "received": params,
                        },
                        400,
                    )
                    return

                try:
                    # Parse data if it's a JSON string (for list format)
                    if isinstance(data, str):
                        try:
                            # Try to parse as JSON array
                            parsed = json.loads(data)
                            if isinstance(parsed, list):
                                data = parsed
                        except (json.JSONDecodeError, ValueError):
                            # Not JSON, treat as hex string
                            pass

                    result = self.endpoints.patch_bytes(address, data, save_to_file)
                    self._send_json_response(result)
                except ValueError as ve:
                    self._send_json_response({"error": str(ve)}, 400)
                except Exception as e:
                    bn.log_error(f"Error handling patch request: {e}")
                    self._send_json_response({"error": str(e)}, 500)

            else:
                self._send_json_response({"error": "Not found"}, 404)
        except Exception as e:
            bn.log_error(f"Error handling POST request: {e}")
            self._send_json_response({"error": str(e)}, 500)


class MCPServer:
    """HTTP server for Binary Ninja MCP plugin.

    Provides REST API endpoints for:
    - Binary analysis and manipulation
    - Function decompilation
    - Symbol renaming
    - Data inspection
    """

    def __init__(self, config: Config):
        self.config = config
        self.server = None
        self.thread = None
        self.binary_ops = BinaryOperations(config.binary_ninja)

    def start(self):
        """Start the HTTP server in a background thread."""
        server_address = (self.config.server.host, self.config.server.port)

        # Create handler with access to binary operations
        handler_class = type(
            "MCPRequestHandlerWithOps",
            (MCPRequestHandler,),
            {"binary_ops": self.binary_ops},
        )

        self.server = HTTPServer(server_address, handler_class)
        self.thread = threading.Thread(target=self.server.serve_forever)
        self.thread.daemon = True
        self.thread.start()
        bn.log_info(f"Server started on {self.config.server.host}:{self.config.server.port}")

    def stop(self):
        """Stop the HTTP server and clean up resources."""
        if self.server:
            self.server.shutdown()
            self.server.server_close()
            if self.thread:
                self.thread.join()
            # Clear references so callers can reliably detect stopped state
            self.thread = None
            self.server = None
            bn.log_info("Server stopped")

```

`plugin/utils/auto_setup.py`:

```py
import json
import os
import sys

from .python_detection import copy_python_env, create_venv_with_system_python, get_python_executable


def _repo_root() -> str:
    # plugin/utils/auto_setup.py -> plugin/utils -> plugin -> repo_root
    return os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))


def _bridge_entrypoint() -> str:
    return os.path.join(_repo_root(), "bridge", "binja_mcp_bridge.py")


def _sentinel_path() -> str:
    return os.path.join(_repo_root(), ".mcp_auto_setup_done")


def _venv_dir() -> str:
    return os.path.join(_repo_root(), ".venv")


def _venv_python() -> str:
    d = _venv_dir()
    if sys.platform == "win32":
        # Always prefer a real Python interpreter (python.exe) for MCP stdio servers.
        # Returning binaryninja.exe here causes the MCP client to fail on Windows.
        py = os.path.join(d, "Scripts", "python.exe")
        return py
    return os.path.join(d, "bin", "python3")


def _ensure_local_venv() -> str:
    """Create a local venv under the plugin root if missing.

    Returns path to the venv's python executable; falls back to get_python_executable
    on failure.
    """
    vdir = _venv_dir()
    req = os.path.join(_repo_root(), "bridge", "requirements.txt")

    try:
        py = create_venv_with_system_python(vdir, req if os.path.exists(req) else None)
        return py if os.path.exists(py) else get_python_executable()
    except Exception:
        return get_python_executable()


def _targets() -> dict:
    home = os.path.expanduser("~")
    if sys.platform == "win32":
        appdata = os.getenv("APPDATA") or os.path.join(home, "AppData", "Roaming")
        return {
            "Cline": (
                os.path.join(
                    appdata, "Code", "User", "globalStorage", "saoudrizwan.claude-dev", "settings"
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    appdata,
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Claude": (os.path.join(appdata, "Claude"), "claude_desktop_config.json"),
            "Cursor": (os.path.join(home, ".cursor"), "mcp.json"),
            "Windsurf": (os.path.join(home, ".codeium", "windsurf"), "mcp_config.json"),
            "Claude Code": (home, ".claude.json"),
            "LM Studio": (os.path.join(home, ".lmstudio"), "mcp.json"),
        }
    elif sys.platform == "darwin":
        return {
            "Cline": (
                os.path.join(
                    home,
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    home,
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Claude": (
                os.path.join(home, "Library", "Application Support", "Claude"),
                "claude_desktop_config.json",
            ),
            "Cursor": (os.path.join(home, ".cursor"), "mcp.json"),
            "Windsurf": (os.path.join(home, ".codeium", "windsurf"), "mcp_config.json"),
            "Claude Code": (home, ".claude.json"),
            "LM Studio": (os.path.join(home, ".lmstudio"), "mcp.json"),
        }
    elif sys.platform == "linux":
        return {
            "Cline": (
                os.path.join(
                    home,
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    home,
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            # Claude not supported on Linux
            "Cursor": (os.path.join(home, ".cursor"), "mcp.json"),
            "Windsurf": (os.path.join(home, ".codeium", "windsurf"), "mcp_config.json"),
            "Claude Code": (home, ".claude.json"),
            "LM Studio": (os.path.join(home, ".lmstudio"), "mcp.json"),
        }
    else:
        return {}


def install_mcp_clients(quiet: bool = True) -> int:
    """Install MCP server entries for supported clients.

    Returns the number of configs modified. Creates a sentinel to avoid
    re-running on every Binary Ninja start.
    """
    sentinel = _sentinel_path()
    server_key = "binary_ninja_mcp"
    if os.path.exists(sentinel):
        # If sentinel exists but no client has our key yet, proceed anyway
        try:
            targets = _targets()
            for _name, (config_dir, config_file) in targets.items():
                config_path = os.path.join(config_dir, config_file)
                if not os.path.exists(config_path):
                    continue
                with open(config_path, encoding="utf-8") as f:
                    data = f.read().strip()
                    if not data:
                        continue
                    cfg = json.loads(data)
                if isinstance(cfg, dict) and server_key in cfg.get("mcpServers", {}):
                    return 0
            # No installs found; ignore the sentinel and continue
        except Exception:
            # On any error, fall through and attempt install
            pass

    targets = _targets()
    if not targets:
        return 0

    env: dict[str, str] = {}
    copy_python_env(env)
    bridge = _bridge_entrypoint()
    # Prefer local venv python for bridge execution
    command = _ensure_local_venv()

    modified = 0
    for _name, (config_dir, config_file) in targets.items():
        if not os.path.exists(config_dir):
            continue
        config_path = os.path.join(config_dir, config_file)
        if not os.path.exists(config_path):
            config = {}
        else:
            try:
                with open(config_path, encoding="utf-8") as f:
                    data = f.read().strip()
                    config = json.loads(data) if data else {}
            except Exception:
                continue

        config.setdefault("mcpServers", {})
        servers = config["mcpServers"]

        # If a legacy key exists, copy into new key without removing legacy
        legacy_key = "binary_ninja_mcp_max"
        if legacy_key in servers and server_key not in servers:
            try:
                legacy_cfg = dict(servers[legacy_key])
                # merge env
                if env:
                    merged_env = dict(legacy_cfg.get("env", {}))
                    merged_env.update(env)
                    legacy_cfg["env"] = merged_env
                servers[server_key] = legacy_cfg
            except Exception:
                pass
        else:
            servers[server_key] = {
                "command": command,
                "args": [bridge],
                "timeout": 1800,
                "disabled": False,
                **({"env": env} if env else {}),
            }

        try:
            with open(config_path, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2)
            modified += 1
        except Exception:
            # Best-effort; skip failures silently in plugin context
            pass

    # Only write sentinel if we successfully modified at least one config
    if modified > 0:
        try:
            with open(sentinel, "w", encoding="utf-8") as f:
                f.write("ok")
        except Exception:
            pass

    return modified

```

`plugin/utils/number_utils.py`:

```py
import re


def _decode_escaped_string(s: str) -> bytes:
    r"""Decode a C/JSON-like escaped string into raw bytes.

    Supports: \n, \r, \t, \\ and \xNN hex escapes.
    """
    # Replace common escapes first
    replacements = {
        r"\\n": "\n",
        r"\\r": "\r",
        r"\\t": "\t",
        r"\\\\": "\\",
        r"\"": '"',
        r"\'": "'",
    }
    for k, v in replacements.items():
        s = s.replace(k, v)

    # Handle \xNN
    def repl_hex(m):
        try:
            return bytes([int(m.group(1), 16)]).decode("latin1")
        except Exception:
            return m.group(0)

    s = re.sub(r"\\x([0-9a-fA-F]{2})", repl_hex, s)
    return s.encode("latin1", errors="ignore")


def _fits_unsigned(value: int, size: int) -> bool:
    if size <= 0:
        return False
    return 0 <= value < (1 << (size * 8))


def _fits_signed(value: int, size: int) -> bool:
    if size <= 0:
        return False
    minv = -(1 << (size * 8 - 1))
    maxv = (1 << (size * 8 - 1)) - 1
    return minv <= value <= maxv


def _auto_size_for_value(value: int, signed: bool) -> int:
    # Choose 1,2,4,8 to fit
    for size in (1, 2, 4, 8):
        if signed:
            if _fits_signed(value, size):
                return size
        else:
            if _fits_unsigned(value, size):
                return size
    return 8


def convert_number(text: str, size_param) -> dict:
    """Convert a number-like text into multiple representations.

    text: decimal ("123"), hex ("0x7b" or "7Bh"), binary ("0b1111011"), octal ("0o173"),
          char ('A'), or ASCII string ("ABC" or with escapes like "A\x42\n").
    size: desired byte size (1,2,4,8). 0/None auto-fits (numbers) or uses string length (strings).
    """
    original_text = text
    text = (text or "").strip()

    # Parse size
    try:
        size = int(size_param) if size_param is not None else 0
    except Exception:
        size = 0

    result = {
        "input": {"text": original_text, "size": size},
        "kind": None,
        "bases": {},
        "bytes": {},
        "little_endian": {},
        "big_endian": {},
        "c_literal": None,
        "c_string": None,
        "warnings": [],
    }

    if not text:
        result["warnings"].append("empty input")
        return result

    # Char literal: 'A' or '\x41'
    if len(text) >= 3 and text[0] == "'" and text[-1] == "'":
        inner = text[1:-1]
        b = _decode_escaped_string(inner)
        if not b:
            val = 0
        else:
            val = b[0]
        result["kind"] = "char"
        # auto size for char is 1 if unspecified
        if size <= 0:
            size = 1

        formatted = _format_numeric_value(val, size)
        # Add C char literal for single-byte
        b = val & 0xFF
        formatted["c_literal"] = _to_c_char(b)
        result.update(formatted)
        return result

    # String literal: "ABC" or with escapes
    if len(text) >= 2 and text[0] == '"' and text[-1] == '"':
        inner = text[1:-1]
        raw = _decode_escaped_string(inner)
        result["kind"] = "string"
        # choose size if not specified: use length (cap at 8)
        if size <= 0:
            size = min(len(raw), 8) if raw else 1

        le_bytes = (raw + b"\x00" * size)[:size]
        be_bytes = (b"\x00" * size + raw)[-size:]

        result["bytes"] = {
            "length": len(raw),
            "hex": raw.hex(),
        }
        result["c_string"] = _to_c_string(raw)
        result["little_endian"] = {
            "hex": le_bytes.hex(),
            "uint": int.from_bytes(le_bytes, "little", signed=False),
            "int": int.from_bytes(le_bytes, "little", signed=True),
        }
        result["big_endian"] = {
            "hex": be_bytes.hex(),
            "uint": int.from_bytes(be_bytes, "big", signed=False),
            "int": int.from_bytes(be_bytes, "big", signed=True),
        }

        # Bases from little-endian unsigned
        u = result["little_endian"]["uint"]
        result["bases"] = {
            "dec": str(u),
            "hex": hex(u),
            "oct": oct(u),
            "bin": bin(u),
        }
        return result

    # Numeric forms
    signed = False
    try:
        if text.lower().startswith("0x") or re.match(r"^[0-9a-fA-F_]+h$", text):
            # Hex (allow trailing h)
            if text.lower().startswith("0x"):
                val = int(text.replace("_", ""), 16)
            else:
                val = int(text[:-1].replace("_", ""), 16)
        elif text.lower().startswith("0b"):
            val = int(text.replace("_", ""), 2)
        elif text.lower().startswith("0o"):
            val = int(text.replace("_", ""), 8)
        else:
            # Decimal (may be negative)
            val = int(text.replace("_", ""), 10)
            signed = val < 0
    except Exception:
        # Fallback: treat as raw string
        raw = text.encode("latin1", errors="ignore")
        result["kind"] = "string"
        if size <= 0:
            size = min(len(raw), 8) if raw else 1
        le_bytes = (raw + b"\x00" * size)[:size]
        be_bytes = (b"\x00" * size + raw)[-size:]
        result["bytes"] = {"length": len(raw), "hex": raw.hex()}
        result["c_string"] = _to_c_string(raw)
        result["little_endian"] = {
            "hex": le_bytes.hex(),
            "uint": int.from_bytes(le_bytes, "little", signed=False),
            "int": int.from_bytes(le_bytes, "little", signed=True),
        }
        result["big_endian"] = {
            "hex": be_bytes.hex(),
            "uint": int.from_bytes(be_bytes, "big", signed=False),
            "int": int.from_bytes(be_bytes, "big", signed=True),
        }
        u = result["little_endian"]["uint"]
        result["bases"] = {"dec": str(u), "hex": hex(u), "oct": oct(u), "bin": bin(u)}
        result["warnings"].append("parsed as string; numeric parse failed")
        return result

    result["kind"] = "int"
    # Determine size
    if size <= 0:
        size = _auto_size_for_value(val, signed)

    formatted = _format_numeric_value(val, size)
    # If single byte, include char literal
    if size == 1:
        formatted["c_literal"] = _to_c_char(val & 0xFF)
    return formatted


def _format_numeric_value(val: int, size: int) -> dict:
    # Normalize to unsigned within size
    mask = (1 << (size * 8)) - 1
    uval = val & mask
    le = uval.to_bytes(size, "little", signed=False)
    be = uval.to_bytes(size, "big", signed=False)

    res = {
        "kind": "int",
        "input": {"value": val, "size": size},
        "bytes": {"length": size, "hex": le.hex()},
        "little_endian": {
            "hex": le.hex(),
            "uint": int.from_bytes(le, "little", signed=False),
            "int": int.from_bytes(le, "little", signed=True),
        },
        "big_endian": {
            "hex": be.hex(),
            "uint": int.from_bytes(be, "big", signed=False),
            "int": int.from_bytes(be, "big", signed=True),
        },
        "bases": {
            "dec": str(uval),
            "hex": hex(uval),
            "oct": oct(uval),
            "bin": bin(uval),
        },
        "warnings": [],
    }
    return res


def _to_c_char(b: int) -> str:
    """Return a C character literal for a byte value."""
    escapes = {
        0x07: r"\a",
        0x08: r"\b",
        0x09: r"\t",
        0x0A: r"\n",
        0x0B: r"\v",
        0x0C: r"\f",
        0x0D: r"\r",
        0x22: r"\"",  # double quote
        0x27: r"\'",  # single quote
        0x5C: r"\\",  # backslash
    }
    if b in escapes:
        body = escapes[b]
    elif 0x20 <= b <= 0x7E:
        body = chr(b)
    else:
        body = f"\\x{b:02x}"
    # Wrap in single quotes for C char literal
    return f"'{body}'"


def _to_c_string(raw: bytes) -> str:
    r"""Return a C string literal representing the raw bytes (may be truncated by caller)."""
    out = ""
    for ch in raw:
        if ch == 0x22:  # '"'
            out += r"\""
        elif ch == 0x5C:  # '\\'
            out += r"\\"
        elif ch == 0x0A:
            out += r"\n"
        elif ch == 0x0D:
            out += r"\r"
        elif ch == 0x09:
            out += r"\t"
        elif 0x20 <= ch <= 0x7E:
            out += chr(ch)
        else:
            out += f"\\x{ch:02x}"
    return '"' + out + '"'

```

`plugin/utils/python_detection.py`:

```py
"""
Shared utilities for Python interpreter detection and virtual environment management.
"""

import os
import subprocess
import sys
import venv


def get_system_python_candidates() -> list[str]:
    """Get a list of candidate system Python paths for the current platform.

    Returns:
        List of potential Python interpreter paths to try.
    """
    if sys.platform == "win32":
        return ["py", "python.exe", "python3.exe"]
    elif sys.platform == "darwin":
        return ["/opt/homebrew/bin/python3", "/usr/local/bin/python3", "/usr/bin/python3"]
    else:  # Linux and other Unix-like systems
        return ["/usr/bin/python3", "/usr/local/bin/python3"]


def is_binary_ninja_python(python_path: str) -> bool:
    """Check if a Python path appears to be Binary Ninja's embedded Python.

    Args:
        python_path: Path to Python interpreter to check.

    Returns:
        True if this appears to be Binary Ninja's embedded Python.
    """
    return "Binary Ninja" in python_path or "binaryninja" in python_path.lower()


def get_python_executable() -> str:
    """Best-effort detection of a Python interpreter for running the bridge.

    Priority:
    1) VIRTUAL_ENV (if active)
    2) System Python (on macOS/Linux when running from Binary Ninja)
    3) Inferred from sys.path zip/embedded layout
    4) Fallback to current interpreter

    Returns:
        Path to the best available Python interpreter.
    """
    # Check for active virtual environment first
    venv_path = os.environ.get("VIRTUAL_ENV")
    if venv_path:
        if sys.platform == "win32":
            python = os.path.join(venv_path, "Scripts", "python.exe")
        else:
            python = os.path.join(venv_path, "bin", "python3")
        if os.path.exists(python):
            return python

    # On macOS/Linux, if we're running from Binary Ninja, try to find system Python first
    if sys.platform in ("darwin", "linux"):
        if is_binary_ninja_python(sys.executable):
            candidates = get_system_python_candidates()
            for python_path in candidates:
                if os.path.exists(python_path):
                    return python_path

    # Try to infer from sys.path zip/embedded layout
    for path in sys.path:
        if sys.platform == "win32":
            path = path.replace("/", "\\")

        parts = path.split(os.sep)
        if parts and parts[-1].endswith(".zip"):
            base = os.path.dirname(path)
            if sys.platform == "win32":
                candidate = os.path.join(base, "python.exe")
            else:
                candidate = os.path.abspath(os.path.join(base, "..", "bin", "python3"))
            if os.path.exists(candidate):
                return candidate

    # Final fallback
    return sys.executable


def create_venv_with_system_python(venv_dir: str, requirements_file: str | None = None) -> str:
    """Create a virtual environment using system Python when possible.

    Args:
        venv_dir: Directory where the virtual environment should be created.
        requirements_file: Optional path to requirements.txt to install.

    Returns:
        Path to the Python interpreter in the created virtual environment.

    Raises:
        Exception: If virtual environment creation fails.
    """
    # Determine expected Python path in venv
    if sys.platform == "win32":
        venv_python = os.path.join(venv_dir, "Scripts", "python.exe")
    else:
        venv_python = os.path.join(venv_dir, "bin", "python3")

    # Check if we need to recreate the venv
    should_recreate = not os.path.exists(venv_python)

    # On Windows, check for Binary Ninja launcher
    if sys.platform == "win32":
        bn_launcher = os.path.join(venv_dir, "Scripts", "binaryninja.exe")
        if os.path.exists(bn_launcher):
            should_recreate = True

    # On macOS/Linux, check if existing venv uses Binary Ninja's Python
    if sys.platform in ("darwin", "linux") and os.path.exists(venv_python):
        try:
            result = subprocess.run(
                [venv_python, "-c", "import sys; print(sys.executable)"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0 and is_binary_ninja_python(result.stdout.strip()):
                should_recreate = True
        except Exception:
            pass

    if should_recreate:
        os.makedirs(venv_dir, exist_ok=True)
        created = False

        # Try to use system Python for venv creation
        if sys.platform == "win32":
            # Use Python launcher on Windows
            try:
                subprocess.run(
                    ["py", "-3", "-m", "venv", venv_dir],
                    check=False,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
                created = True
            except Exception:
                pass
        else:
            # On macOS/Linux, try system Python interpreters
            candidates = get_system_python_candidates()
            for python_path in candidates:
                if os.path.exists(python_path):
                    try:
                        subprocess.run(
                            [python_path, "-m", "venv", venv_dir],
                            check=True,
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            timeout=30,
                        )
                        created = True
                        break
                    except Exception:
                        continue

        # Fallback to venv.EnvBuilder if system Python methods failed
        if not created:
            builder = venv.EnvBuilder(with_pip=True, upgrade=False)
            builder.create(venv_dir)

        # Install requirements if provided
        if requirements_file and os.path.exists(requirements_file):
            try:
                subprocess.run(
                    [venv_python, "-m", "pip", "install", "-r", requirements_file],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    check=False,
                )
            except Exception:
                pass

    return venv_python


def copy_python_env(env: dict) -> bool:
    """Copy Python-related environment variables that affect imports.

    Args:
        env: Dictionary to copy environment variables into.

    Returns:
        True if any variables were copied, False otherwise.
    """
    python_vars = [
        "PYTHONHOME",
        "PYTHONPATH",
        "PYTHONSAFEPATH",
        "PYTHONPLATLIBDIR",
        "PYTHONPYCACHEPREFIX",
        "PYTHONNOUSERSITE",
        "PYTHONUSERBASE",
    ]

    copied = False
    for var in python_vars:
        value = os.environ.get(var)
        if value:
            copied = True
            env[var] = value

    return copied

```

`plugin/utils/string_utils.py`:

```py
def escape_non_ascii(input_str: str) -> str:
    """Escape non-ASCII characters in a string"""
    if input_str is None:
        return ""
    result = ""
    for c in input_str:
        if 32 <= ord(c) < 127:
            result += c
        else:
            result += f"\\x{ord(c):02x}"
    return result


def parse_int_or_default(val: str, default: int) -> int:
    """Parse an integer from a string or return a default value"""
    if val is None:
        return default
    try:
        return int(val)
    except (ValueError, TypeError):
        return default

```

`ruff.toml`:

```toml
target-version = "py312"
line-length = 100

[lint]
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "UP",  # pyupgrade
    "RUF", # Ruff-specific rules
]
ignore = [
    "E501",  # Line too long (handled by formatter)
]

[lint.isort]
known-first-party = ["plugin", "bridge"]

[lint.per-file-ignores]
"__init__.py" = ["F401"]  # Allow unused imports in __init__.py files
"scripts/*" = ["T201"]    # Allow print statements in scripts
"bridge/binja_mcp_bridge.py" = ["E402"]  # Imports after exception hook setup (intentional)

```

`scripts/mcp_client_installer.py`:

```py
import argparse
import json
import os
import sys

# Import shared utilities
try:
    # Try relative import first (when run as module)
    from ..plugin.utils.python_detection import (
        copy_python_env,
        create_venv_with_system_python,
        get_python_executable,
    )
except ImportError:
    # Fallback for direct script execution
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "plugin"))
    from utils.python_detection import (
        copy_python_env,
        create_venv_with_system_python,
        get_python_executable,
    )


# Unique key used in MCP client configs
MCP_SERVER_KEY = "binary_ninja_mcp"


def _repo_root() -> str:
    """Return the repository root (one level above this scripts directory)."""
    return os.path.dirname(os.path.dirname(os.path.realpath(__file__)))


def _bridge_entrypoint() -> str:
    return os.path.join(_repo_root(), "bridge", "binja_mcp_bridge.py")


def _venv_dir() -> str:
    return os.path.join(_repo_root(), ".venv")


def _venv_python() -> str:
    d = _venv_dir()
    if sys.platform == "win32":
        # Always prefer a real Python interpreter for MCP stdio servers.
        # "binaryninja.exe" is an embedded interpreter launcher and does not
        # behave like a normal Python on stdio, causing MCP clients to fail.
        py = os.path.join(d, "Scripts", "python.exe")
        return py
    return os.path.join(d, "bin", "python3")


def ensure_local_venv() -> str:
    """Create a local venv under the plugin root if missing and return its python."""
    vdir = _venv_dir()
    req = os.path.join(_repo_root(), "bridge", "requirements.txt")

    try:
        py = create_venv_with_system_python(vdir, req if os.path.exists(req) else None)
        return py if os.path.exists(py) else get_python_executable()
    except Exception:
        return get_python_executable()


# Note: get_python_executable and copy_python_env are now imported from utils.python_detection


def print_mcp_config():
    """Print a generic MCP config snippet users can copy to unsupported clients."""
    mcp_config = {
        "command": ensure_local_venv(),
        "args": [
            _bridge_entrypoint(),
        ],
        "timeout": 1800,
        "disabled": False,
    }
    env = {}
    if copy_python_env(env):
        mcp_config["env"] = env
    print(json.dumps({"mcpServers": {MCP_SERVER_KEY: mcp_config}}, indent=2))


def _config_targets() -> dict[str, tuple[str, str]]:
    """Return supported MCP client config locations per platform.

    Value is (config_dir, filename).
    """
    home = os.path.expanduser("~")
    if sys.platform == "win32":
        appdata = os.getenv("APPDATA") or os.path.join(home, "AppData", "Roaming")
        return {
            "Cline": (
                os.path.join(
                    appdata, "Code", "User", "globalStorage", "saoudrizwan.claude-dev", "settings"
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    appdata,
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Claude": (os.path.join(appdata, "Claude"), "claude_desktop_config.json"),
            "Cursor": (os.path.join(home, ".cursor"), "mcp.json"),
            "Windsurf": (os.path.join(home, ".codeium", "windsurf"), "mcp_config.json"),
            "Claude Code": (home, ".claude.json"),
            "LM Studio": (os.path.join(home, ".lmstudio"), "mcp.json"),
        }
    elif sys.platform == "darwin":
        return {
            "Cline": (
                os.path.join(
                    home,
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    home,
                    "Library",
                    "Application Support",
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            "Claude": (
                os.path.join(home, "Library", "Application Support", "Claude"),
                "claude_desktop_config.json",
            ),
            "Cursor": (os.path.join(home, ".cursor"), "mcp.json"),
            "Windsurf": (os.path.join(home, ".codeium", "windsurf"), "mcp_config.json"),
            "Claude Code": (home, ".claude.json"),
            "LM Studio": (os.path.join(home, ".lmstudio"), "mcp.json"),
        }
    elif sys.platform == "linux":
        return {
            "Cline": (
                os.path.join(
                    home,
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "saoudrizwan.claude-dev",
                    "settings",
                ),
                "cline_mcp_settings.json",
            ),
            "Roo Code": (
                os.path.join(
                    home,
                    ".config",
                    "Code",
                    "User",
                    "globalStorage",
                    "rooveterinaryinc.roo-cline",
                    "settings",
                ),
                "mcp_settings.json",
            ),
            # Claude not supported on Linux
            "Cursor": (os.path.join(home, ".cursor"), "mcp.json"),
            "Windsurf": (os.path.join(home, ".codeium", "windsurf"), "mcp_config.json"),
            "Claude Code": (home, ".claude.json"),
            "LM Studio": (os.path.join(home, ".lmstudio"), "mcp.json"),
        }
    else:
        return {}


def install_mcp_servers(
    *, uninstall: bool = False, quiet: bool = False, env: dict[str, str] | None = None
) -> int:
    """Install or remove MCP server entries for supported clients.

    Returns the number of configs modified.
    """
    env = {} if env is None else dict(env)
    targets = _config_targets()
    if not targets:
        if not quiet:
            print(f"Unsupported platform: {sys.platform}")
        return 0

    installed = 0
    for name, (config_dir, config_file) in targets.items():
        config_path = os.path.join(config_dir, config_file)
        action_word = "uninstall" if uninstall else "installation"

        if not os.path.exists(config_dir):
            if not quiet:
                print(f"Skipping {name} {action_word}\n  Config: {config_path} (not found)")
            continue

        if not os.path.exists(config_path):
            config: dict = {}
        else:
            try:
                with open(config_path, encoding="utf-8") as f:
                    data = f.read().strip()
                    config = json.loads(data) if data else {}
            except json.decoder.JSONDecodeError:
                if not quiet:
                    print(f"Skipping {name} uninstall\n  Config: {config_path} (invalid JSON)")
                continue

        config.setdefault("mcpServers", {})
        mcp_servers = config["mcpServers"]

        if uninstall:
            if MCP_SERVER_KEY not in mcp_servers:
                if not quiet:
                    print(f"Skipping {name} uninstall\n  Config: {config_path} (not installed)")
                continue
            del mcp_servers[MCP_SERVER_KEY]
        else:
            # Preserve any existing env overrides for this server
            if MCP_SERVER_KEY in mcp_servers:
                for key, value in mcp_servers[MCP_SERVER_KEY].get("env", {}).items():
                    env[key] = value

            bridge = _bridge_entrypoint()
            if copy_python_env(env) and not quiet:
                print("[WARNING] Custom Python environment variables detected")

            server_cfg = {
                "command": ensure_local_venv(),
                "args": [bridge],
                "timeout": 1800,
                "disabled": False,
            }
            if env:
                server_cfg["env"] = env
            mcp_servers[MCP_SERVER_KEY] = server_cfg

        # Write back
        os.makedirs(config_dir, exist_ok=True)
        with open(config_path, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2)

        if not quiet:
            print(
                ("Uninstalled" if uninstall else "Installed")
                + f" {name} MCP server (restart required)\n  Config: {config_path}"
            )
        installed += 1

    if not uninstall and installed == 0 and not quiet:
        print("No MCP servers installed. For unsupported MCP clients, use the following config:\n")
        print_mcp_config()

    return installed


def main():
    parser = argparse.ArgumentParser(
        description="Binary Ninja MCP Max - MCP Client Installer (CLI)"
    )
    parser.add_argument(
        "--install", action="store_true", help="Install MCP server entries for supported clients"
    )
    parser.add_argument(
        "--uninstall", action="store_true", help="Remove MCP server entries from supported clients"
    )
    parser.add_argument("--config", action="store_true", help="Print generic MCP config JSON")
    parser.add_argument("--quiet", action="store_true", help="Reduce output noise")
    args = parser.parse_args()

    if args.install and args.uninstall:
        print("Cannot install and uninstall at the same time")
        return

    if args.config:
        print_mcp_config()
        return

    if args.uninstall:
        install_mcp_servers(uninstall=True, quiet=args.quiet)
        # Also remove auto-setup sentinel so the plugin can re-run setup later
        sentinel = os.path.join(_repo_root(), ".mcp_auto_setup_done")
        try:
            os.remove(sentinel)
            if not args.quiet:
                print(f"Removed auto-setup marker: {sentinel}")
        except FileNotFoundError:
            pass
        except Exception as e:
            if not args.quiet:
                print(f"Warning: failed to remove auto-setup marker: {e}")
        return

    # Default action is install if no flag is provided
    if args.install or (not args.uninstall and not args.config):
        install_mcp_servers(quiet=args.quiet)


if __name__ == "__main__":
    main()

```

`scripts/setup_claude_desktop.py`:

```py
#!/usr/bin/env python3

import json
import os
import platform
import subprocess
import sys
import venv
from pathlib import Path


def check_os():
    """Check if the operating system is Mac OS."""
    if platform.system() != "Darwin":
        print("Error: This setup script is only supported on Mac OS.")
        print(f"Current operating system: {platform.system()}")
        sys.exit(1)


def get_config_path():
    """Get the path to the Claude Desktop config file."""
    home = Path.home()
    return home / "Library" / "Application Support" / "Claude" / "claude_desktop_config.json"


def _looks_like_binja_embedded(py_path: Path) -> bool:
    try:
        bin_dir = py_path.parent
        bn = bin_dir / "binaryninja"
        if bn.exists() and py_path.exists():
            sp = py_path.stat()
            sb = bn.stat()
            if sp.st_size == sb.st_size:
                return True
        base = py_path.name.lower()
        if base.startswith("binaryninja") or "Binary Ninja.app" in str(py_path):
            return True
    except Exception:
        pass
    return False


def _select_system_python() -> str | None:
    def ok(p: str) -> bool:
        try:
            r = subprocess.run(
                [p, "-c", "import sys;print(f'{sys.version_info[0]}.{sys.version_info[1]}')"],
                capture_output=True,
                text=True,
                check=False,
            )
            if r.returncode == 0:
                s = (r.stdout or "").strip()
                parts = s.split(".")
                if len(parts) >= 2:
                    maj, minor = int(parts[0]), int(parts[1])
                    return (maj > 3) or (maj == 3 and minor >= 10)
        except Exception:
            pass
        return False

    env_p = os.environ.get("BINJA_MCP_PYTHON")
    if env_p and ok(env_p):
        return env_p
    if ok(sys.executable):
        return sys.executable
    cands = [
        "/opt/homebrew/bin/python3",
        "/usr/local/bin/python3",
        "python3",
        "python3.12",
        "python3.11",
        "python3.10",
        "/usr/bin/python3",
    ]
    for c in cands:
        if ok(c):
            return c
    return None


def _ensure_plugin_venv(plugin_root: Path) -> str:
    vdir = plugin_root / ".venv"
    py = vdir / ("Scripts/python.exe" if sys.platform == "win32" else "bin/python3")
    try:
        needs_build = not py.exists() or (
            sys.platform == "darwin" and _looks_like_binja_embedded(py)
        )
        if needs_build:
            vdir.mkdir(parents=True, exist_ok=True)
            created = False
            if sys.platform == "win32":
                try:
                    subprocess.run(
                        ["py", "-3", "-m", "venv", str(vdir)],
                        check=False,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                    )
                    created = True
                except Exception:
                    created = False
            if sys.platform == "darwin" and not created:
                cand = _select_system_python()
                if cand:
                    try:
                        subprocess.run(
                            [cand, "-m", "venv", str(vdir)],
                            check=False,
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                        )
                        created = True
                    except Exception:
                        created = False
            if not created:
                venv.EnvBuilder(with_pip=True).create(str(vdir))
            py = vdir / ("Scripts/python.exe" if sys.platform == "win32" else "bin/python3")
            if sys.platform == "darwin" and _looks_like_binja_embedded(py):
                return sys.executable
            # Best-effort deps
            req = plugin_root / "bridge" / "requirements.txt"
            if req.exists():
                try:
                    subprocess.run(
                        [str(py), "-m", "pip", "install", "-r", str(req)],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                    )
                except Exception:
                    pass
    except Exception:
        return sys.executable
    return str(py) if py.exists() else sys.executable


def setup_claude_desktop():
    """Set up Claude Desktop configuration for the current project."""
    check_os()

    config_path = get_config_path()

    if not config_path.exists():
        print(f"Error: Claude Desktop config not found at {config_path}")
        print("Please make sure Claude Desktop is installed and configured.")
        sys.exit(1)

    try:
        with open(config_path) as f:
            config = json.load(f)

        # Use the installed plugin path (works for Plugin Manager installs):
        # <BinaryNinja>/repositories/community/plugins/CX330Blake_binary_ninja_mcp
        plugin_root = Path(__file__).resolve().parent.parent
        src_dir = plugin_root / "bridge"

        if "mcpServers" not in config:
            config["mcpServers"] = {}

        config["mcpServers"]["binary_ninja_mcp"] = {
            "command": _ensure_plugin_venv(plugin_root),
            "args": [str(src_dir / "binja_mcp_bridge.py")],
        }

        with open(config_path, "w") as f:
            json.dump(config, f, indent=2)

        print("Successfully updated Claude Desktop configuration.")

    except Exception as e:
        print(f"Error updating configuration: {e}")
        sys.exit(1)


if __name__ == "__main__":
    setup_claude_desktop()

```