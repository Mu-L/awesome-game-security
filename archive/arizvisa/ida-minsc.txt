Project Path: arc_arizvisa_ida-minsc_k1a8uk6y

Source Tree:

```txt
arc_arizvisa_ida-minsc_k1a8uk6y
├── AUTHORS.md
├── CONTRIBUTING.md
├── LICENSE
├── README.md
├── __root__.py
├── application
│   ├── __quicktime.py
│   ├── delphi.py
│   ├── quicktime.py
│   └── windbg.py
├── base
│   ├── _comment.py
│   ├── _declaration.py
│   ├── _exceptions.py
│   ├── _interface.py
│   ├── _netnode.py
│   ├── _utils.py
│   ├── database.py
│   ├── enumeration.py
│   ├── function.py
│   ├── instruction.py
│   ├── segment.py
│   └── structure.py
├── ida-plugin.json
├── idapythonrc.py
├── misc
│   ├── hooks.py
│   └── ui.py
├── plugins
│   └── minsc.py
├── requirements.txt
└── tools
    ├── general.py
    ├── tagfix.py
    └── tags.py

```

`AUTHORS.md`:

```md
Ali Rizvi-Santiago <arizvisa@gmail.com>

```

`CONTRIBUTING.md`:

```md
# Contributing to IDA-minsc

Contribution to the IDA-minsc plugin is pretty much exclusively done with
GitHub's interface. Hence, there are numerous places in which one can to
contribute to the IDA-minsc plugin. Some of these places can be the
documentation, the plugin itself, writing tutorials, blogposts, adding to
the project wiki, helping with user issues, or even idling on the irc
channel.

## Issues

If you're unsure of how to do something or the documentation isn't clear,
feel free to create an issue and someone will try and help you figure it
out, or the documentation can be updated with your concern.

If you find yourself constantly typing something and discovering it not
being there, or if you desire a shorter alias for some common namespace
that you use, feel free to create an issue requesting an alias be made.
This can then be discussed and possibly merged if it doesn't conflict
with something in the future and it's (of course) reasonable.

### Reporting an issue

Before reporting an issue, search the current issue tracker to see if
someone else has already reported your issue. If it is related to
another issue, feel free to reference that in your new issue's details.
Any duplicate issues will be re-referenced and closed so that related
discussion can occur in the original issue that was reported.

When creating your issue be sure to include the version of IDA you're using,
the platform it's running on (32-bit or 64-bit), the architecture of your
database, and whatever code you're running that doesn't appear to work.

## Pull requests

When submitting a pull request, please rebase it against `master` before
submitting. If you are creating a fix for a particular issue, please name
the branch according to the issue number as `GH-#`. This causes GitHub
to automatically create a reference which allows for simple correlation
of PRs to the issues that they are for.

When submitting a pull request, keep in mind about what version of IDA
your PR doesn't work on. This plugin aims to be backwards compatible
with IDA all the way back to 6.9. This is right before the `idaapi`
module was split up into its current state. If your addition does not
support one of these versions, please make sure you mention it in
the details of the PR you're trying to get merged upstream so a
committer can come up with a solution or workaround if possible.

Another thing to pay attention to is which module (or context) your
addition is for. If your addition warrants the creation of a new base
module, please create a separate PR with details about why you feel
that a new module is necessary along with a reference to the PR that
includes your addition. This way the creation of new modules can be
discussed or possibly staged inside a different path before your new
functionality gets added to them.

The last thing to note is keep in mind how multicase functions work.
If you're not sure of what these are, please refer to the documentation.
When you are adding a new function, try and consider what other types
your function might be able to take, and the different ways the plugin
can automatically determine those types using IDA.

### Pull requests in progress

If you're still working on a pull request, you can prefix the title of
your pull request with "[WIP]". This will notify any user with commit
access that your PR is still in development. When you're ready for it
to be merged, remove the prefix or mention it in the discussion so
that way it can be reviewed before it gets merged.

### Titling pull requests

When titling the pull request, prefix it with the path that the user
needs to type at the IDAPython prompt in order to navigate to the
module that contains your addition. If the addition is within a file
in the root directory, include the full filename.

As an example, the `base/database.py` module might have a title of:

    database: added blah blah function
    
Another example, say for `idapythonrc.py` could be:

    idapythonrc.py: added support for external plugins

This way it is immediately apparent to the committer what component
of IDA the addition is for.

### Pull requests for documentation

The `docs` branch contains the current state of documentation for this
plugin. Each module's documentation is actually generated by the
`docs/docparse.py` file based on some magic decorators that are used
to communicate semantics to the document parser.

This means other than the static documentation in `docs/static`, the
documentation for each function and its parameters will need to be
modified within the module that actually contains it.

If something on there is poorly documented or is missing for some
reason, please prefix your PR title with "docs/" and follow the same
method as described in "Titling pull requests". If you've updated the
documentation for "matching.rst", then title it like:

    docs/matching: fixed some really bad english

Or if it's some documentation in a particular module such as
`base/instruction.py` one can use:

    docs/instruction: fixed the spacing for the module autodocs

The reason being is that any modifications to the documentation's
autodocs will need to be backported into the `master` branch. This
"docs/" prefix will notify the primary committer that this needs to
happen.

## Requested work

The following pull requests are desired:

* Pull requests that introduce support for new architectures (registers
  or operands)
* Pull requests involving the decompiler (I don't really use it, thus
  I haven't found a reason to write wrappers around its functionality)
* Bug fixes (A lot of refactoring was done to get this plugin to a
  release state. Some stuff might be broken, but who knows)
* Documentation issues or especially translation to other languages
* Fixes for any of the issues that are listed in GitHub's issue tracker

## Conclusion

Thanks for your interest in contributing to this plugin!

```

`LICENSE`:

```
Copyright (c) 2010-2022 Ali Rizvi-Santiago. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


```

`README.md`:

```md
# IDA-minsc

<table>
    <tr>
        <td width="10%">
            <img src="http://arizvisa.github.io/ida-minsc/_images/hamster.svg" height="10%" />
        </td>
        <td>
            <ul>
                <li>Website: https://github.com/arizvisa/ida-minsc</li>
                <li>Documentation: https://arizvisa.github.io/ida-minsc</li>
                <li>Mantras: https://github.com/arizvisa/ida-minsc/wiki/Mantras</li>
                <li>Wiki: https://github.com/arizvisa/ida-minsc/wiki</li>
                <li>Changelog: https://github.com/arizvisa/ida-minsc/wiki/Changelog</li>
                <li>IRC: <code>#eof</code> on <a href="http://chat.efnet.org:9090/?nick=user-.&channels=eof&prompt=1">EFnet</a></li>
            </ul>
        </td>
    </tr>
</table>

## General

IDA-minsc is a plugin for IDA Pro that assists a user with scripting the
IDAPython plugin that is bundled with the disassembler. This plugin groups the
different aspects of the IDAPython API into a simpler format which allows a
reverse engineer to script different aspects of their work with very little
investment.

A number of concepts are introduced such as a tagging system, support for
multicased functions, and filtering with the intention that most search
and annotation issues can be performed with just a few lines of code. This
should enable a user to write quick, hacky, temporary code that can be used
to augment their reversing endeavors without distraction.

## Installation

Installation should be pretty simple and requires simply cloning the repository
directly into the user's IDA user directory. On the Windows platform, this is
typically located at `%APPDATA%/Hex-Rays/IDA Pro`. Whereas on the Linux
platform this can be found at `$HOME/.idapro`. This contents of this repository
should actually replace that directory. If you have any files that presently
reside there, simply move them into the repository's directory. After
installation, IDA Pro should load its IDAPython plugin which should result in
the `idapythonrc.py` belonging to IDA-minsc being executed which will then
replace IDAPython's default namespace with the one belonging to the plugin's.

To clone the repository in a directory `$TARGET`, one can simply do:

    $ git clone https://github.com/arizvisa/ida-minsc "$TARGET"

After cloning the repository, the user will need to install its required Python
dependencies into their site-packages. This can be done using `pip` which is a
tool that is bundled with Python. The file that contains the user's requirements
is in the root of the repository as `requirements.txt`.

To install the required Python dependencies, one can run `pip` as so:

    $ pip install -r "requirements.txt"

At this point when the user starts IDA Pro, IDA-minsc will replace IDAPython's
namespace with its own at which point can be used immediately. To verify that
IDA-minsc was installed properly, one can simply type in the following at the
IDAPython prompt:

    > database.config.version()

This should then return the number `0` since no database has been loaded.

## Quick Start

After installing the python dependencies, you can do something like the
following to list all the functions in your database:

    > database.functions.list()

Or to iterate through all the functions in the database, you can try:

    > for ea in database.functions():
          print(hex(ea))

Please refer to the documentation for more details on what this plugin makes
available to you.

## Documentation

Comprehensive documentation is available at the project page on
[github.io](https://arizvisa.github.io/ida-minsc), or can be built locally via
the "[docs](https://github.com/arizvisa/ida-minsc/tree/docs)" branch.

If the user wishes to build documentation for local use, they will first need
to install the [Sphinx](http://www.sphinx-doc.org/en/master/usage/installation.html)
package. Afterwards, the entirety of the documentation resides within in the
"[docs](https://github.com/arizvisa/ida-minsc/tree/docs)" branch. Simply
checkout the branch, change the directory to "docs", and then run GNU make as:

    $ make html

This will result in the build system parsing the available modules and then
rendering all of the documentation into the `_build` directory relative to the
`docs/Makefile`. Documentation can be generated for a number of different
formats. To list all of the available formats, type in `make help` at the
command prompt.

## Contributing

See [CONTRIBUTING.md](https://github.com/arizvisa/ida-minsc/blob/master/CONTRIBUTING.md)
for best practices on reporting issues or for adding functionality to this
project.

## Thanks

Thanks to a number of anonymous and non-anonymous people whom have helped with
the development of this plugin over all of these years.

[logo]: http://arizvisa.github.io/ida-minsc/_images/hamster.svg

```

`__root__.py`:

```py
"""
Root module

This module contains the root namespace that IDA starts up with. Any
thing defined within this module is used to replace the globals that
IDA starts up with.

This module also is responsible for assigning the default hooks in
order to trap what the user is doing to perform any extra maintenance
that needs to occur.
"""

### ida-python specific modules
import idaapi, ida

### Pre-populate the root namespace with a bunch of things that IDA requires

## IDA 6.9 requires the _idaapi module exists in the global namespace
if idaapi.__version__ <= 6.9:
    import _idaapi

## IDA 6.95 requires these couple modules to exist in the global namespace
if idaapi.__version__ >= 6.95:
    import ida_idaapi, ida_kernwin, ida_diskio

## IDA 7.4 requires that this module exists in the global namespace
if idaapi.__version__ >= 7.4:
    import sys

### customize the root namespace
import segment, database, function, instruction
import structure, enumeration, ui

## some aliases for the base modules
import database as db
import function as func
import instruction as ins
import structure as struc
import enumeration as enum
import segment as seg

## default log setting for notifying the user
# FIXME: actually use the logging module properly instead of assuming
#        control of the root logger.
#__import__('logging').root.setLevel(__import__('logging').INFO)

## shortcuts
h, top, go, goof = database.h, func.top, database.go, database.go_offset

def hex():
    import sys, builtins, operator
    version = sys.version_info.major
    F = operator.methodcaller('encode', 'hex') if version < 3 else operator.methodcaller('hex')
    integer_t = int, getattr(builtins, 'long', int)
    def render(item):
        return "{:x}".format(item) if isinstance(item, integer_t) else F(bytes(bytearray(item)))
    return render
hex = hex()

## other useful things that we can grab from other modules

# stuff for printing (of course)
p = __import__('six').print_
pp, pf = pprint, pformat = [getattr(__import__('pprint'), _) for _ in ['pprint', 'pformat']]

# snag the custom exceptions that we use while excluding any modules
exceptions = __import__('internal').exceptions

# snag the fake utilities module to share some things with the user...
utils = __import__('internal').utils

# construct some pattern matching types
AnyRegister = utils.PatternAnyType(__import__('internal').interface.register_t)
AnyInteger = utils.PatternAnyType(__import__('six').integer_types)
AnyString = utils.PatternAnyType(__import__('six').string_types)
AnyBytes = utils.PatternAnyType(bytes)
Any = utils.PatternAny()

# some types that the user might want to compare with
architecture_t, register_t, symbol_t, bounds_t, location_t = (getattr(__import__('internal').interface, item) for item in ['architecture_t', 'register_t', 'symbol_t', 'bounds_t', 'location_t'])
ref_t, opref_t = (getattr(__import__('internal').interface, item) for item in ['ref_t', 'opref_t'])

```

`application/__quicktime.py`:

```py
qt_fv_list={
0x20001: "EnterMovies",
0x20002: "ExitMovies",
0x20003: "GetMoviesError",
0x20004: "GetMoviesStickyError",
0x20005: "MoviesTask",
0x20006: "PrerollMovie",
0x20007: "LoadMovieIntoRam",
0x20008: "LoadMediaIntoRam",
0x20009: "SetMovieActive",
0x2000a: "GetMovieActive",
0x2000b: "StartMovie",
0x2000c: "StopMovie",
0x2000d: "GoToBeginningOfMovie",
0x2000e: "GoToEndOfMovie",
0x2000f: "GetMoviePreviewMode",
0x20010: "SetMoviePreviewMode",
0x20011: "ShowMoviePoster",
0x20012: "GetMovieTimeBase",
0x20015: "GetMovieGWorld",
0x20016: "SetMovieGWorld",
0x2001d: "GetMoviePict",
0x2001e: "GetTrackPict",
0x2001f: "UpdateMovie",
0x20022: "PutMovieIntoHandle",
0x20023: "DisposeMovie",
0x20026: "GetMovieCreationTime",
0x20027: "GetMovieModificationTime",
0x20029: "GetMovieTimeScale",
0x2002a: "SetMovieTimeScale",
0x2002b: "GetMovieDuration",
0x2002c: "GetMovieRate",
0x2002d: "SetMovieRate",
0x2002e: "GetMovieVolume",
0x2002f: "SetMovieVolume",
0x20031: "GetMovieMatrix",
0x20032: "SetMovieMatrix",
0x20033: "GetMoviePreviewTime",
0x20034: "SetMoviePreviewTime",
0x20035: "GetMoviePosterTime",
0x20036: "SetMoviePosterTime",
0x20037: "GetMovieSelection",
0x20038: "SetMovieSelection",
0x20039: "GetMovieTime",
0x2003c: "SetMovieTime",
0x2003d: "SetMovieTimeValue",
0x2003e: "GetMovieUserData",
0x2003f: "GetMovieTrackCount",
0x20040: "GetMovieTrack",
0x20042: "DisposeMovieTrack",
0x20043: "GetTrackCreationTime",
0x20044: "GetTrackModificationTime",
0x20045: "GetTrackEnabled",
0x20046: "SetTrackEnabled",
0x20047: "GetTrackUsage",
0x20048: "SetTrackUsage",
0x2004b: "GetTrackDuration",
0x2004c: "GetTrackOffset",
0x2004d: "SetTrackOffset",
0x20050: "GetTrackLayer",
0x20051: "SetTrackLayer",
0x20052: "GetTrackAlternate",
0x20053: "SetTrackAlternate",
0x20054: "GetTrackVolume",
0x20055: "SetTrackVolume",
0x20056: "GetTrackMatrix",
0x20057: "SetTrackMatrix",
0x2005d: "GetTrackDimensions",
0x2005e: "SetTrackDimensions",
0x2005f: "GetTrackUserData",
0x20061: "DisposeTrackMedia",
0x20062: "GetTrackMedia",
0x20066: "GetMediaCreationTime",
0x20067: "GetMediaModificationTime",
0x20068: "GetMediaTimeScale",
0x20069: "SetMediaTimeScale",
0x2006a: "GetMediaDuration",
0x2006b: "GetMediaLanguage",
0x2006c: "SetMediaLanguage",
0x2006d: "GetMediaQuality",
0x2006e: "SetMediaQuality",
0x2006f: "GetMediaHandlerDescription",
0x20070: "GetMediaUserData",
0x20071: "GetMediaHandler",
0x20072: "BeginMediaEdits",
0x20073: "EndMediaEdits",
0x20074: "AddEmptyTrackToMovie",
0x20077: "GetMediaSampleDescriptionCount",
0x20078: "GetMediaSampleDescription",
0x20079: "GetMediaSampleCount",
0x2007a: "SampleNumToMediaTime",
0x2007b: "MediaTimeToSampleNum",
0x2007c: "AddMediaSample",
0x2007d: "AddMediaSampleReference",
0x2007e: "GetMediaSample",
0x2007f: "GetMediaSampleReference",
0x20084: "CloneRgn",
0x20085: "InsertTrackSegment",
0x20086: "InsertMovieSegment",
0x20087: "InsertEmptyTrackSegment",
0x20088: "InsertEmptyMovieSegment",
0x20089: "DeleteTrackSegment",
0x2008a: "DeleteMovieSegment",
0x2008b: "ScaleTrackSegment",
0x2008c: "ScaleMovieSegment",
0x2008d: "CutMovieSelection",
0x2008e: "CopyMovieSelection",
0x2008f: "PasteMovieSelection",
0x20096: "TrackTimeToMediaTime",
0x20098: "GetMovieDataSize",
0x20099: "GetMediaDataSize",
0x2009a: "PtInMovie",
0x2009b: "PtInTrack",
0x2009c: "SetMovieLanguage",
0x2009d: "SetTrackGWorld",
0x2009e: "GetUserData",
0x2009f: "AddUserData",
0x200a0: "RemoveUserData",
0x200a5: "NewTimeBase",
0x200a6: "GetTimeBaseTime",
0x200a7: "SetTimeBaseTime",
0x200a8: "SetTimeBaseValue",
0x200a9: "GetTimeBaseRate",
0x200aa: "SetTimeBaseRate",
0x200ab: "GetTimeBaseStartTime",
0x200ac: "SetTimeBaseStartTime",
0x200ad: "GetTimeBaseStopTime",
0x200ae: "SetTimeBaseStopTime",
0x200af: "GetTimeBaseMasterTimeBase",
0x200b0: "GetTimeBaseMasterClock",
0x200b1: "GetTimeBaseFlags",
0x200b2: "SetTimeBaseFlags",
0x200b3: "SetTimeBaseMasterClock",
0x200b4: "SetTimeBaseMasterTimeBase",
0x200b5: "ConvertTime",
0x200b6: "DisposeTimeBase",
0x200b7: "ConvertTimeScale",
0x200b8: "CallMeWhen",
0x200b9: "CancelCallBack",
0x200c5: "GetMediaTrack",
0x200cb: "PasteHandleIntoMovie",
0x200cc: "IsScrapMovie",
0x200d0: "GetTrackMovie",
0x200d5: "CloseMovieFile",
0x200d7: "AddMovieResource",
0x200d8: "UpdateMovieResource",
0x200d9: "HasMovieChanged",
0x200dd: "IsMovieDone",
0x200de: "ClearMoviesStickyError",
0x200e1: "ClearMovieSelection",
0x200e2: "GetTrackNextInterestingTime",
0x200eb: "NewCallBack",
0x200ec: "DisposeCallBack",
0x200ed: "GetCallBackType",
0x200ee: "GetCallBackTimeBase",
0x200ef: "SetMoviesErrorProc",
0x200f0: "NewMovieFromFile",
0x200f1: "NewMovieFromHandle",
0x200f2: "PlayMoviePreview",
0x200f3: "GetMoviePreferredRate",
0x200f4: "SetMoviePreferredRate",
0x200f5: "GetMoviePreferredVolume",
0x200f6: "SetMoviePreferredVolume",
0x200f7: "GetMoviePosterPict",
0x200f9: "GetMovieBox",
0x200fa: "SetMovieBox",
0x200fb: "GetMovieDisplayBoundsRgn",
0x200fc: "GetMovieDisplayClipRgn",
0x200fd: "SetMovieDisplayClipRgn",
0x200fe: "GetMovieBoundsRgn",
0x200ff: "GetTrackMovieBoundsRgn",
0x20100: "GetMovieClipRgn",
0x20101: "SetMovieClipRgn",
0x20102: "GetTrackClipRgn",
0x20103: "SetTrackClipRgn",
0x20104: "NewMovieEditState",
0x20105: "UseMovieEditState",
0x20106: "DisposeMovieEditState",
0x20107: "NewTrackEditState",
0x20108: "UseTrackEditState",
0x20109: "DisposeTrackEditState",
0x2010b: "GetTimeBaseStatus",
0x2010c: "AddTime",
0x2010d: "SubtractTime",
0x2010e: "GetMovieNextInterestingTime",
0x20111: "GetTrackBoundsRgn",
0x20112: "GetTrackDisplayBoundsRgn",
0x20113: "ClearMovieChanged",
0x20115: "GetTrackMatte",
0x20116: "SetTrackMatte",
0x20117: "GetMovieIndTrack",
0x20121: "SetMediaShadowSync",
0x20122: "GetMediaShadowSync",
0x20123: "GetTrackEditRate",
0x20124: "GetTimeBaseEffectiveRate",
0x20126: "GetUserDataItem",
0x20127: "GetTrackID",
0x20128: "SetTimeBaseZero",
0x20129: "AddCallBackToTimeBase",
0x2012a: "RemoveCallBackFromTimeBase",
0x2012b: "GetFirstCallBack",
0x2012c: "GetNextCallBack",
0x2012d: "ExecuteCallBack",
0x2012e: "SetUserDataItem",
0x2012f: "NewUserData",
0x20130: "DisposeUserData",
0x20131: "NewUserDataFromHandle",
0x20132: "PutUserDataIntoHandle",
0x20149: "GetTrackDataSize",
0x2014a: "DisposeMatte",
0x2014b: "CountUserDataType",
0x2014c: "AddUserDataText",
0x2014d: "GetUserDataText",
0x2014e: "RemoveUserDataText",
0x20152: "AddMovieSelection",
0x20153: "CopyTrackSettings",
0x20154: "CopyMovieSettings",
0x2015c: "SetMovieActiveSegment",
0x2015d: "GetMovieActiveSegment",
0x2015e: "SetAutoTrackAlternatesEnabled",
0x2015f: "SelectMovieAlternates",
0x20167: "SetMovieMasterTimeBase",
0x20168: "SetMovieMasterClock",
0x2016b: "GetTrackSegmentDisplayBoundsRgn",
0x2016c: "GetMovieSegmentDisplayBoundsRgn",
0x2016d: "GetMediaNextInterestingTime",
0x2016e: "LoadTrackIntoRam",
0x2016f: "GetPosterBox",
0x20170: "SetPosterBox",
0x20172: "GetTrackStatus",
0x20173: "GetMovieStatus",
0x20175: "DeleteMovieFile",
0x20176: "RemoveMovieResource",
0x20179: "SetMovieCoverProcs",
0x20183: "InsertMediaIntoTrack",
0x20187: "NewMovie",
0x20188: "NewMovieTrack",
0x2018a: "NewMovieController",
0x2018b: "DisposeMovieController",
0x2018c: "PutMovieOnScrap",
0x2018d: "NewMovieFromScrap",
0x2018e: "NewTrackMedia",
0x20190: "SetMediaHandler",
0x20191: "CreateMovieFile",
0x20192: "OpenMovieFile",
0x20197: "GetMediaDataRef",
0x20198: "AddMediaDataRef",
0x20199: "GetMediaDataRefCount",
0x2019a: "SetMovieProgressProc",
0x2019b: "FlattenMovie",
0x2019c: "FlattenMovieData",
0x2019e: "GetMediaDataHandlerDescription",
0x2019f: "GetMediaDataHandler",
0x201a0: "SetMediaDataHandler",
0x201a1: "SetMoviePlayHints",
0x201a2: "SetMediaPlayHints",
0x201a5: "GetNextUserDataType",
0x201b3: "NewMovieFromDataFork",
0x201b4: "PutMovieIntoDataFork",
0x201c1: "SetMovieDefaultDataRef",
0x201c9: "SetMediaDataRef",
0x201ca: "SetMediaDataRefAttributes",
0x201cb: "ConvertFileToMovieFile",
0x201cc: "ConvertMovieToFile",
0x201cd: "PutMovieIntoTypedHandle",
0x201d0: "SetMediaSampleDescription",
0x201d2: "GetMovieDefaultDataRef",
0x201dd: "GetMovieCoverProcs",
0x201de: "SetMovieDrawingCompleteProc",
0x201e0: "SetMediaDefaultDataRefIndex",
0x201e3: "SetTrackLoadSettings",
0x201e4: "GetTrackLoadSettings",
0x201ec: "NewMovieFromUserProc",
0x201ed: "GetDataHandler",
0x201f0: "AddTrackReference",
0x201f1: "DeleteTrackReference",
0x201f2: "SetTrackReference",
0x201f3: "GetTrackReference",
0x201f4: "GetNextTrackReferenceType",
0x201f5: "GetTrackReferenceCount",
0x201f7: "AddMediaSampleReferences",
0x201f8: "SetMediaPreferredChunkSize",
0x201f9: "GetMediaPreferredChunkSize",
0x201fa: "GetNextTrackForCompositing",
0x201fb: "GetPrevTrackForCompositing",
0x201ff: "QTSwapAtoms",
0x20200: "QTNextChildAnyType",
0x20201: "QTNewAlias",
0x20205: "SetMovieColorTable",
0x20206: "GetMovieColorTable",
0x20207: "MovieSearchText",
0x20208: "GetMovieIndTrackType",
0x20209: "ShowMovieInformation",
0x2020c: "QTNewAtomContainer",
0x2020d: "QTDisposeAtomContainer",
0x2020e: "QTGetNextChildType",
0x2020f: "QTCountChildrenOfType",
0x20210: "QTFindChildByIndex",
0x20211: "QTSetAtomData",
0x20212: "QTCopyAtomDataToHandle",
0x20213: "QTCopyAtomDataToPtr",
0x20214: "QTCopyAtom",
0x20215: "QTLockContainer",
0x20216: "QTGetAtomDataPtr",
0x20217: "QTUnlockContainer",
0x20218: "QTInsertChild",
0x20219: "QTInsertChildren",
0x2021a: "QTRemoveAtom",
0x2021b: "QTRemoveChildren",
0x2021c: "QTReplaceAtom",
0x2021d: "QTFindChildByID",
0x20220: "NewMovieFromDataRef",
0x2022a: "InvalidateMovieRegion",
0x2022b: "TaskMovie",
0x2022c: "GetMovieNaturalBoundsRect",
0x2022e: "SetMediaPropertyAtom",
0x2022f: "GetMediaPropertyAtom",
0x20231: "QTSetAtomID",
0x20232: "QTGetAtomTypeAndID",
0x20233: "BeginFullScreen",
0x20234: "EndFullScreen",
0x20235: "GetMediaSampleReferences",
0x20239: "NewSpriteWorld",
0x2023a: "DisposeSpriteWorld",
0x2023b: "SetSpriteWorldClip",
0x2023c: "SetSpriteWorldMatrix",
0x2023d: "SpriteWorldIdle",
0x2023e: "InvalidateSpriteWorld",
0x2023f: "DisposeAllSprites",
0x20240: "NewSprite",
0x20241: "DisposeSprite",
0x20242: "InvalidateSprite",
0x20243: "SetSpriteProperty",
0x20244: "GetSpriteProperty",
0x20246: "SpriteWorldHitTest",
0x20247: "SpriteHitTest",
0x20249: "GetMediaInputMap",
0x2024a: "SetMediaInputMap",
0x20263: "GetTrackDisplayMatrix",
0x2027a: "ITextAddString",
0x2027b: "ITextRemoveString",
0x2027c: "ITextGetString",
0x20282: "GetTrackSoundLocalizationSettings",
0x20283: "SetTrackSoundLocalizationSettings",
0x20284: "SetMoviePropertyAtom",
0x20285: "GetMoviePropertyAtom",
0x2029d: "QTNewTween",
0x2029e: "QTDoTween",
0x2029f: "QTDisposeTween",
0x202b2: "GetMediaSyncSampleCount",
0x202b3: "QTGetAccessKeys",
0x202b4: "QTRegisterAccessKey",
0x202b5: "QTUnregisterAccessKey",
0x202be: "MakeTrackTimeTable",
0x202bf: "MakeMediaTimeTable",
0x202c0: "GetMaxLoadedTimeInMovie",
0x202c2: "SetSpriteWorldFlags",
0x202c3: "QTMovieNeedsTimeTable",
0x202c6: "QTGetDataRefMaxFileOffset",
0x202c7: "GetMovieImporterForDataRef",
0x202c9: "QTGetEffectsList",
0x202ca: "QTCreateStandardParameterDialog",
0x202cb: "QTIsStandardParameterDialogEvent",
0x202cc: "QTDismissStandardParameterDialog",
0x202cd: "QTStandardParameterDialogDoAction",
0x202ce: "GetMediaPlayHints",
0x202cf: "AddSoundDescriptionExtension",
0x202d0: "GetSoundDescriptionExtension",
0x202d1: "RemoveSoundDescriptionExtension",
0x202d2: "QTGetEffectSpeed",
0x202d3: "QuickTimeExtensionLoaded",
0x202d4: "GetQuickTimePreference",
0x202d5: "SetQuickTimePreference",
0x202d9: "SetSpriteWorldGraphicsMode",
0x202da: "CheckQuickTimeRegistration",
0x202db: "QTTextToNativeText",
0x202e8: "AddMediaSampleReferences64",
0x202e9: "GetMediaSampleReferences64",
0x202ea: "PutMovieIntoDataFork64",
0x202eb: "GetMovieDataSize64",
0x202ec: "GetTrackDataSize64",
0x202ed: "GetMediaDataSize64",
0x202ee: "NewMovieFromDataFork64",
0x202ef: "QTGetAtomParent",
0x202f1: "QTReportMissingSoftware",
0x202f4: "InstallQuickTimeExtensionRequest",
0x202f5: "QTBandwidthRequest",
0x202f6: "QTBandwidthRelease",
0x202f7: "PrePrerollMovie",
0x202f8: "AbortPrePrerollMovie",
0x202f9: "QTTempNewHandle",
0x202fa: "CreateShortcutMovieFile",
0x202fe: "QTAltGetComputerSpeed",
0x20300: "GetMovieProgressProc",
0x20302: "AddMovieExecuteWiredActionsProc",
0x20303: "RemoveMovieExecuteWiredActionsProc",
0x20304: "MovieExecuteWiredActions",
0x20310: "QTScheduledBandwidthRequest",
0x20311: "QTScheduledBandwidthRelease",
0x20314: "GetMovieLoadState",
0x20315: "SetMovieAnchorDataRef",
0x20316: "GetMovieAnchorDataRef",
0x20318: "QTBandwidthRequestForTimeBase",
0x20319: "QTParseTextHREF",
0x2031b: "QTDoCallBacks",
0x2031c: "OpenADataHandler",
0x2031d: "QTListNew",
0x2031e: "QTListDispose",
0x2031f: "QTListElementRefNew",
0x20320: "QTListElementRefDispose",
0x20321: "QTListElementRefGetList",
0x20322: "QTListElementRefClone",
0x20323: "QTListInsertNewElement",
0x20324: "QTListSetElementDataAs",
0x20325: "QTListSetElementName",
0x20326: "QTListDeleteElement",
0x20327: "QTListCutSublist",
0x20328: "QTListCopySublist",
0x20329: "QTListPasteSublist",
0x2032a: "QTListDeleteSublist",
0x2032b: "QTListSetMatchingElementData",
0x2032c: "QTListCountChildElements",
0x2032d: "QTListFindRootElement",
0x2032e: "QTListFindParentElement",
0x2032f: "QTListFindElementByName",
0x20330: "QTListFindElementByIndex",
0x20331: "QTListFindChildElementByPathName",
0x20332: "QTListGetElementName",
0x20333: "QTListGetElementPathName",
0x20334: "QTListGetElementTypeAndSize",
0x20335: "QTListGetElementIndex",
0x20336: "QTListInsertNewAttribute",
0x20337: "QTListCopyElementDataToPtr",
0x20338: "QTListValidateDataType",
0x20339: "QTListWriteToXML",
0x2033a: "QTListReadFromXML",
0x2033e: "CanQuickTimeOpenFile",
0x2033f: "CanQuickTimeOpenDataRef",
0x20340: "SetMovieVideoOutput",
0x20344: "AddClonedTrackToMovie",
0x20347: "QTGetWallClockTimeBase",
0x2034f: "QTListDeleteAttribute",
0x20350: "QTListCountAttributes",
0x20351: "QTListFindAttributeByIndex",
0x20352: "QTListFindAttributeByName",
0x20353: "QTListFindAttributeParentElement",
0x20354: "QTListSetAttributeDataAs",
0x20355: "QTListSetAttributeName",
0x20356: "QTListGetAttributeName",
0x20357: "QTListAttributeRefNew",
0x20358: "QTListAttributeRefDispose",
0x20359: "QTListAttributeRefClone",
0x2035a: "QTListGetAttributeTypeAndSize",
0x2035b: "QTListGetAttributeIndex",
0x2035c: "QTListCopyAttributeDataToPtr",
0x190002: "NewPalette",
0x190003: "GetNewPalette",
0x190004: "DisposePalette",
0x190005: "ActivatePalette",
0x190006: "SetPalette",
0x190007: "NSetPalette",
0x190008: "GetPalette",
0x190009: "CopyPalette",
0x19000a: "PmForeColor",
0x19000b: "PmBackColor",
0x19000e: "GetEntryColor",
0x19000f: "SetEntryColor",
0x190010: "GetEntryUsage",
0x190011: "SetEntryUsage",
0x190012: "CTab2Palette",
0x190013: "Palette2CTab",
0x190014: "Entry2Index",
0x190016: "MacResizePalette",
0x190017: "SaveFore",
0x190018: "SaveBack",
0x190019: "RestoreFore",
0x19001a: "RestoreBack",
0x19001d: "PMgrVersion",
0x19001e: "SetPaletteUpdates",
0x19001f: "GetPaletteUpdates",
0x190020: "GetGray",
0x1e0002: "OpenPort",
0x1e0003: "InitPort",
0x1e0004: "ClosePort",
0x1e0005: "MacSetPort",
0x1e0006: "GetPort",
0x1e0008: "SetPortBits",
0x1e0009: "PortSize",
0x1e000a: "MovePortTo",
0x1e000b: "SetOrigin",
0x1e000c: "SetClip",
0x1e000d: "GetClip",
0x1e000e: "ClipRect",
0x1e000f: "BackPat",
0x1e0010: "InitCursor",
0x1e0011: "MacSetCursor",
0x1e0012: "HideCursor",
0x1e0013: "MacShowCursor",
0x1e0014: "ObscureCursor",
0x1e0015: "HidePen",
0x1e0016: "ShowPen",
0x1e0017: "GetPen",
0x1e0018: "GetPenState",
0x1e0019: "SetPenState",
0x1e001a: "PenSize",
0x1e001b: "PenMode",
0x1e001c: "PenPat",
0x1e001d: "PenNormal",
0x1e001e: "MoveTo",
0x1e001f: "Move",
0x1e0020: "MacLineTo",
0x1e0021: "Line",
0x1e0022: "ForeColor",
0x1e0023: "BackColor",
0x1e0024: "ColorBit",
0x1e0025: "MacSetRect",
0x1e0026: "MacOffsetRect",
0x1e0027: "MacInsetRect",
0x1e0028: "SectRect",
0x1e0029: "MacUnionRect",
0x1e002a: "MacEqualRect",
0x1e002b: "EmptyRect",
0x1e002c: "MacFrameRect",
0x1e002d: "PaintRect",
0x1e002e: "EraseRect",
0x1e002f: "MacInvertRect",
0x1e0030: "MacFillRect",
0x1e0031: "FrameOval",
0x1e0032: "PaintOval",
0x1e0033: "EraseOval",
0x1e0034: "InvertOval",
0x1e0035: "FillOval",
0x1e0036: "FrameRoundRect",
0x1e0037: "PaintRoundRect",
0x1e0038: "EraseRoundRect",
0x1e0039: "InvertRoundRect",
0x1e003a: "FillRoundRect",
0x1e003b: "FrameArc",
0x1e003c: "PaintArc",
0x1e003d: "EraseArc",
0x1e003e: "InvertArc",
0x1e003f: "FillArc",
0x1e0040: "NewRgn",
0x1e0041: "OpenRgn",
0x1e0042: "CloseRgn",
0x1e0043: "BitMapToRegion",
0x1e0044: "DisposeRgn",
0x1e0045: "MacCopyRgn",
0x1e0046: "SetEmptyRgn",
0x1e0047: "MacSetRectRgn",
0x1e0048: "RectRgn",
0x1e0049: "MacOffsetRgn",
0x1e004a: "InsetRgn",
0x1e004b: "SectRgn",
0x1e004c: "MacUnionRgn",
0x1e004d: "DiffRgn",
0x1e004e: "MacXorRgn",
0x1e004f: "RectInRgn",
0x1e0050: "MacEqualRgn",
0x1e0051: "EmptyRgn",
0x1e0052: "MacFrameRgn",
0x1e0053: "MacPaintRgn",
0x1e0054: "EraseRgn",
0x1e0055: "MacInvertRgn",
0x1e0056: "MacFillRgn",
0x1e0057: "ScrollRect",
0x1e0058: "CopyBits",
0x1e0059: "SeedFill",
0x1e005a: "CalcMask",
0x1e005b: "CopyMask",
0x1e005c: "OpenPicture",
0x1e005d: "PicComment",
0x1e005e: "ClosePicture",
0x1e005f: "DrawPicture",
0x1e0060: "KillPicture",
0x1e0061: "OpenPoly",
0x1e0062: "ClosePoly",
0x1e0063: "KillPoly",
0x1e0064: "OffsetPoly",
0x1e0065: "FramePoly",
0x1e0066: "PaintPoly",
0x1e0067: "ErasePoly",
0x1e0068: "InvertPoly",
0x1e0069: "FillPoly",
0x1e006a: "SetPt",
0x1e006b: "LocalToGlobal",
0x1e006c: "GlobalToLocal",
0x1e006d: "Random",
0x1e006e: "StuffHex",
0x1e006f: "MacGetPixel",
0x1e0070: "ScalePt",
0x1e0071: "MapPt",
0x1e0072: "MapRect",
0x1e0073: "MapRgn",
0x1e0074: "MapPoly",
0x1e0075: "SetStdProcs",
0x1e0076: "StdRect",
0x1e0077: "StdRRect",
0x1e0078: "StdOval",
0x1e0079: "StdArc",
0x1e007a: "StdPoly",
0x1e007b: "StdRgn",
0x1e007c: "StdBits",
0x1e007d: "StdComment",
0x1e007e: "StdGetPic",
0x1e007f: "StdPutPic",
0x1e0080: "AddPt",
0x1e0081: "EqualPt",
0x1e0082: "MacPtInRect",
0x1e0083: "Pt2Rect",
0x1e0084: "PtToAngle",
0x1e0085: "SubPt",
0x1e0086: "PtInRgn",
0x1e0087: "StdLine",
0x1e0088: "OpenCPort",
0x1e0089: "InitCPort",
0x1e008a: "CloseCPort",
0x1e008b: "NewPixMap",
0x1e008c: "DisposePixMap",
0x1e008d: "CopyPixMap",
0x1e008e: "NewPixPat",
0x1e008f: "DisposePixPat",
0x1e0090: "CopyPixPat",
0x1e0091: "PenPixPat",
0x1e0092: "BackPixPat",
0x1e0093: "GetPixPat",
0x1e0094: "MakeRGBPat",
0x1e0095: "FillCRect",
0x1e0096: "FillCOval",
0x1e0097: "FillCRoundRect",
0x1e0098: "FillCArc",
0x1e0099: "FillCRgn",
0x1e009a: "FillCPoly",
0x1e009b: "RGBForeColor",
0x1e009c: "RGBBackColor",
0x1e009d: "SetCPixel",
0x1e009e: "SetPortPix",
0x1e009f: "GetCPixel",
0x1e00a0: "GetForeColor",
0x1e00a1: "GetBackColor",
0x1e00a2: "SeedCFill",
0x1e00a3: "CalcCMask",
0x1e00a4: "OpenCPicture",
0x1e00a5: "OpColor",
0x1e00a6: "HiliteColor",
0x1e00a7: "DisposeCTable",
0x1e00a8: "GetCTable",
0x1e00a9: "GetCCursor",
0x1e00aa: "SetCCursor",
0x1e00ac: "DisposeCCursor",
0x1e00b0: "SetStdCProcs",
0x1e00b1: "GetMaxDevice",
0x1e00b2: "GetCTSeed",
0x1e00b3: "GetDeviceList",
0x1e00b4: "GetMainDevice",
0x1e00b5: "GetNextDevice",
0x1e00b6: "TestDeviceAttribute",
0x1e00b7: "SetDeviceAttribute",
0x1e00b8: "InitGDevice",
0x1e00b9: "NewGDevice",
0x1e00ba: "DisposeGDevice",
0x1e00bb: "SetGDevice",
0x1e00bc: "GetGDevice",
0x1e00bd: "Color2Index",
0x1e00be: "Index2Color",
0x1e00bf: "InvertColor",
0x1e00c0: "RealColor",
0x1e00c1: "GetSubTable",
0x1e00c2: "MakeITable",
0x1e00c3: "AddSearch",
0x1e00c4: "AddComp",
0x1e00c5: "DelSearch",
0x1e00c6: "DelComp",
0x1e00c7: "SetClientID",
0x1e00c8: "ProtectEntry",
0x1e00c9: "ReserveEntry",
0x1e00ca: "SetEntries",
0x1e00cb: "SaveEntries",
0x1e00cc: "RestoreEntries",
0x1e00cd: "QDError",
0x1e00ce: "CopyDeepMask",
0x1e00cf: "DeviceLoop",
0x1e00d3: "MacGetCursor",
0x1e00d4: "GetPicture",
0x1e00d6: "ShieldCursor",
0x1e00d9: "PackBits",
0x1e00da: "UnpackBits",
0x1e00db: "SlopeFromAngle",
0x1e00dc: "AngleFromSlope",
0x1e00dd: "LockPortBits",
0x1e00de: "UnlockPortBits",
0x1e00e1: "UpdatePort",
0x1e00e4: "CopyBitsGDI",
0x30000: "CodecManagerVersion",
0x30001: "GetCodecNameList",
0x30003: "GetCodecInfo",
0x30004: "GetMaxCompressionSize",
0x30005: "GetCompressionTime",
0x30006: "CompressImage",
0x30007: "FCompressImage",
0x30008: "DecompressImage",
0x30009: "FDecompressImage",
0x3000a: "CompressSequenceBegin",
0x3000b: "CompressSequenceFrame",
0x3000c: "StdPix",
0x3000d: "DecompressSequenceBegin",
0x3000e: "DecompressSequenceFrame",
0x3000f: "DisposeCodecNameList",
0x30010: "SetDSequenceMatrix",
0x30011: "SetDSequenceMatte",
0x30012: "SetDSequenceMask",
0x30013: "SetDSequenceTransferMode",
0x30014: "SetDSequenceDataProc",
0x30015: "GetDSequenceImageBuffer",
0x30016: "GetDSequenceScreenBuffer",
0x30017: "SetCSequenceQuality",
0x30018: "SetCSequencePrev",
0x30019: "GetCSequencePrevBuffer",
0x3001a: "CDSequenceBusy",
0x3001b: "CDSequenceEnd",
0x3001c: "GetCompressedImageSize",
0x3001d: "GetSimilarity",
0x3001e: "GetImageDescriptionCTable",
0x3001f: "SetImageDescriptionCTable",
0x30020: "GetImageDescriptionExtension",
0x30021: "AddImageDescriptionExtension",
0x30023: "FindCodec",
0x30024: "CompressPicture",
0x30025: "FCompressPicture",
0x30026: "CompressPictureFile",
0x30027: "FCompressPictureFile",
0x30028: "GetPictureFileHeader",
0x30029: "DrawPictureFile",
0x3002a: "MakeThumbnailFromPicture",
0x3002b: "MakeThumbnailFromPictureFile",
0x3002c: "MakeThumbnailFromPixMap",
0x3002d: "TrimImage",
0x3002e: "DrawTrimmedPicture",
0x3002f: "DrawTrimmedPictureFile",
0x30030: "ConvertImage",
0x30033: "SetCSequenceFlushProc",
0x30034: "SetDSequenceAccuracy",
0x30035: "SetDSequenceSrcRect",
0x30036: "SetCSequenceKeyFrameRate",
0x30037: "GetCompressedPixMapInfo",
0x30038: "SetCompressedPixMapInfo",
0x30039: "TransformRgn",
0x3003a: "RemoveImageDescriptionExtension",
0x3003b: "CountImageDescriptionExtensionType",
0x3003c: "GetNextImageDescriptionExtensionType",
0x30041: "SFGetFilePreview",
0x30042: "SFPGetFilePreview",
0x30043: "StandardGetFilePreview",
0x30044: "CustomGetFilePreview",
0x30045: "MakeFilePreview",
0x30046: "AddFilePreview",
0x30047: "DecompressSequenceFrameS",
0x3004b: "GetCSequenceKeyFrameRate",
0x3004c: "AlignScreenRect",
0x3004d: "AlignWindow",
0x3004e: "DragAlignedWindow",
0x3004f: "DragAlignedGrayRgn",
0x30050: "SetCSequenceDataRateParams",
0x30051: "SetCSequenceFrameNumber",
0x30052: "NewImageGWorld",
0x30053: "GetCSequenceDataRateParams",
0x30054: "GetCSequenceFrameNumber",
0x30055: "GetBestDeviceRect",
0x30056: "SetSequenceProgressProc",
0x30057: "SetDSequenceFlags",
0x3005a: "GDHasScale",
0x3005b: "GDGetScale",
0x3005c: "GDSetScale",
0x3005d: "DecompressSequenceBeginS",
0x3005e: "DecompressSequenceFrameWhen",
0x3005f: "CDSequenceFlush",
0x30061: "QTGetFileNameExtension",
0x30062: "ICMShieldSequenceCursor",
0x30063: "ICMDecompressComplete",
0x30064: "SetDSequenceTimeCode",
0x30065: "CDSequenceEquivalentImageDescription",
0x30066: "CDSequenceNewMemory",
0x30067: "CDSequenceDisposeMemory",
0x30068: "CDSequenceNewDataSource",
0x30069: "CDSequenceDisposeDataSource",
0x3006a: "CDSequenceSetSourceData",
0x3006b: "CDSequenceChangedSourceData",
0x3006c: "PtInDSequenceData",
0x3006d: "ImageFieldSequenceBegin",
0x3006e: "GetGraphicsImporterForFile",
0x3006f: "ImageTranscodeSequenceBegin",
0x30070: "ImageTranscodeSequenceEnd",
0x30071: "ImageTranscodeFrame",
0x30072: "ImageTranscodeDisposeFrameData",
0x30073: "CDSequenceInvalidate",
0x30074: "GetCSequenceMaxCompressionSize",
0x30075: "ImageFieldSequenceExtractCombine",
0x30076: "ImageFieldSequenceEnd",
0x30077: "GetGraphicsImporterForDataRef",
0x30078: "SetCSequencePreferredPacketSize",
0x30079: "CDSequenceSetTimeBase",
0x3007a: "MakeImageDescriptionForPixMap",
0x3007b: "CDSequenceSetSourceDataQueue",
0x3007c: "ICMSequenceLockBits",
0x3007d: "ICMSequenceUnlockBits",
0x3007e: "ICMSequenceGetChainMember",
0x3007f: "CDSequenceGetDataSource",
0x30080: "QTNewGWorld",
0x30081: "QTUpdateGWorld",
0x30082: "ICMDecompressCompleteS",
0x30083: "ICMGetPixelFormatInfo",
0x30084: "GetGraphicsImporterForFileWithFlags",
0x30085: "GetGraphicsImporterForDataRefWithFlags",
0x30086: "QTGetPixelSize",
0x30087: "HitTestDSequenceData",
0x30089: "ICMSequenceGetInfo",
0x3008a: "ICMSetPixelFormatInfo",
0x3008b: "QTNewGWorldFromPtr",
0x3008d: "QTGetPixMapPtrRowBytes",
0x3008e: "QTGetPixMapHandleRowBytes",
0x3008f: "QTSetPixMapHandleRowBytes",
0x30090: "QTSetPixMapPtrRowBytes",
0x30091: "GetDSequenceMatrix",
0x30092: "MakeImageDescriptionForEffect",
0x30093: "QTGetPixMapPtrGammaLevel",
0x30094: "QTSetPixMapPtrGammaLevel",
0x30095: "QuadToQuadMatrix",
0x30096: "QTGetPixMapHandleGammaLevel",
0x30097: "QTSetPixMapHandleGammaLevel",
0x30098: "QTGetPixMapPtrRequestedGammaLevel",
0x30099: "QTSetPixMapPtrRequestedGammaLevel",
0x3009a: "QTGetPixMapHandleRequestedGammaLevel",
0x3009b: "QTSetPixMapHandleRequestedGammaLevel",
0x3009c: "OpenPreviewComponentForFile",
0x3009d: "ICMSequenceSetInfo",
0x3009f: "CDSequenceEquivalentImageDescriptionS",
0x300a0: "ReplaceDSequenceImageDescription",
0x200003: "CloseResFile",
0x200004: "ResError",
0x200005: "CurResFile",
0x200006: "HomeResFile",
0x200009: "UseResFile",
0x20000a: "CountTypes",
0x20000b: "Count1Types",
0x20000c: "GetIndType",
0x20000d: "Get1IndType",
0x20000e: "SetResLoad",
0x20000f: "CountResources",
0x200010: "Count1Resources",
0x200011: "GetIndResource",
0x200012: "Get1IndResource",
0x200013: "GetResource",
0x200014: "Get1Resource",
0x200015: "GetNamedResource",
0x200016: "Get1NamedResource",
0x200017: "MacLoadResource",
0x200018: "ReleaseResource",
0x200019: "DetachResource",
0x20001a: "UniqueID",
0x20001b: "Unique1ID",
0x20001c: "GetResAttrs",
0x20001d: "GetResInfo",
0x20001e: "SetResInfo",
0x20001f: "AddResource",
0x200020: "GetResourceSizeOnDisk",
0x200023: "SetResAttrs",
0x200024: "ChangedResource",
0x200025: "RemoveResource",
0x200026: "UpdateResFile",
0x200027: "WriteResource",
0x200028: "SetResPurge",
0x200029: "GetResFileAttrs",
0x20002a: "SetResFileAttrs",
0x20002f: "FSpOpenResFile",
0x200030: "FSpCreateResFile",
0x200033: "SetResourceSize",
0x200036: "RegisterResourceEndianFilter",
0x200037: "GetIndString",
0x0c0003: "NewDialog",
0x0c0004: "GetNewDialog",
0x0c0006: "CloseDialog",
0x0c0007: "DisposeDialog",
0x0c0008: "ModalDialog",
0x0c0009: "IsDialogEvent",
0x0c000a: "DialogSelect",
0x0c000b: "DrawDialog",
0x0c000c: "UpdateDialog",
0x0c000d: "HideDialogItem",
0x0c000e: "ShowDialogItem",
0x0c000f: "FindDialogItem",
0x0c0014: "Alert",
0x0c0015: "StopAlert",
0x0c0016: "NoteAlert",
0x0c0017: "CautionAlert",
0x0c0018: "GetDialogItem",
0x0c0019: "SetDialogItem",
0x0c001a: "ParamText",
0x0c001b: "SelectDialogItemText",
0x0c001c: "GetDialogItemText",
0x0c001d: "SetDialogItemText",
0x0c0021: "AppendDITL",
0x0c0022: "CountDITL",
0x0c0023: "ShortenDITL",
0x0c0024: "StdFilterProc",
0x0c0025: "GetStdFilterProc",
0x0c0026: "SetDialogDefaultItem",
0x0c0027: "SetDialogCancelItem",
0x0c0028: "SetDialogTracksCursor",
0x0c002d: "NewColorDialog",
0x0c002e: "SetModelessDialogCallbackProc",
0x0c002f: "GetDialogItemAsControl",
0x0c0030: "SetDialogMovableModal",
0x0c0031: "MoveDialogItem",
0x0c0032: "SizeDialogItem",
0x1c0001: "NewGWorld",
0x1c0002: "LockPixels",
0x1c0003: "UnlockPixels",
0x1c0004: "UpdateGWorld",
0x1c0005: "DisposeGWorld",
0x1c0006: "GetGWorld",
0x1c0007: "SetGWorld",
0x1c0008: "CTabChanged",
0x1c0009: "PixPatChanged",
0x1c000a: "PortChanged",
0x1c000b: "GDeviceChanged",
0x1c000c: "AllowPurgePixels",
0x1c000d: "NoPurgePixels",
0x1c000e: "GetPixelsState",
0x1c000f: "SetPixelsState",
0x1c0010: "GetPixBaseAddr",
0x1c0011: "NewScreenBuffer",
0x1c0012: "DisposeScreenBuffer",
0x1c0013: "GetGWorldDevice",
0x1c0014: "QDDone",
0x1c0015: "OffscreenVersion",
0x1c0016: "NewTempScreenBuffer",
0x1c0017: "PixMap32Bit",
0x1c0018: "GetGWorldPixMap",
0x1c0019: "NewGWorldFromPtr",
0x160001: "GetMBarHeight",
0x160002: "NewMenu",
0x160003: "MacGetMenu",
0x160004: "MacAppendMenu",
0x160005: "MacInsertMenu",
0x160006: "MacDeleteMenu",
0x160007: "AppendResMenu",
0x160008: "MacInsertMenuItem",
0x160009: "SetMenuItemText",
0x16000a: "GetMenuItemText",
0x16000b: "SetItemMark",
0x16000c: "GetItemMark",
0x16000d: "SetItemCmd",
0x16000e: "GetItemCmd",
0x16000f: "SetItemIcon",
0x160010: "GetItemIcon",
0x160011: "SetItemStyle",
0x160012: "GetItemStyle",
0x160013: "GetMenuHandle",
0x160014: "CalcMenuSize",
0x160015: "DisableItem",
0x160016: "EnableItem",
0x160017: "FlashMenuBar",
0x160018: "PopUpMenuSelect",
0x16001f: "MacDrawMenuBar",
0x160020: "InvalMenuBar",
0x160021: "InitProcMenu",
0x160022: "GetMenuBar",
0x160023: "SetMenuBar",
0x160024: "SystemEdit",
0x160025: "SystemMenu",
0x160026: "GetNewMBar",
0x160027: "ClearMenuBar",
0x160028: "CheckItem",
0x160029: "CountMItems",
0x16002a: "SetMenuFlash",
0x16002b: "InitMenus",
0x16002c: "MenuKey",
0x16002d: "MenuSelect",
0x16002e: "MenuChoice",
0x16002f: "DisposeMenu",
0x160030: "DeleteMenuItem",
0x160031: "HiliteMenu",
0x160032: "InsertResMenu",
0x160033: "InsertFontResMenu",
0x160034: "InsertIntlResMenu",

0x1d0001: "CreatePortAssociation",
0x1d0002: "DestroyPortAssociation",
0x1d0003: "GetNativeWindowPort",
0x1d0004: "GetPortNativeWindow",
0x1d0008: "QTMLInitInternals",
0x1d0009: "QTMLTermInternals",
0x1d000a: "NativeEventToMacEvent",
0x1d000e: "RegisterAbortAction",
0x1d000f: "UnregisterAbortAction",
0x1d0010: "InitializeQHdr",
0x1d0011: "TerminateQHdr",
0x1d0012: "QTMLYieldCPU",
0x1d0013: "QTMLRegisterInterruptSafeThread",
0x1d0014: "QTMLUnregisterInterruptSafeThread",
0x1d0017: "Endian64_Swap",
0x1d0019: "GetColor",
0x1d001a: "FindFolderEx",
0x1d001d: "ldtox80",
0x1d001e: "x80told",
0x1d0021: "Debugger",
0x1d0022: "DebugStr",
0x1d0024: "QTMLYieldCPUTime",
0x1d0027: "QTMLGetCanonicalPathName",
0x1d0028: "QTMLGetVolumeRootPath",
0x1d0029: "QTMLAcquireWindowList",
0x1d002a: "QTMLReleaseWindowList",
0x1d002b: "NativeRegionToMacRegion",
0x1d002c: "MacRegionToNativeRegion",
0x1d002d: "FSSpecToNativePathName",
0x1d002e: "NativePathNameToFSSpec",

0x1d0033: "QTMLCreateMutex",
0x1d0034: "QTMLDestroyMutex",
0x1d0035: "QTMLGrabMutex",
0x1d0036: "QTMLReturnMutex",

0x1d0037: "QTMLCreateSyncVar",
0x1d0038: "QTMLDestroySyncVar",
0x1d0039: "QTMLTestAndSetSyncVar",
0x1d003a: "QTMLWaitAndSetSyncVar",
0x1d003b: "QTMLResetSyncVar",

0x1d003d: "QTMLTryGrabMutex",

0x1d004e: "QTMLGetDirectXObject",
0x1d004f: "QTMLSetDirectXObject",
0x1d0052: "QTGetAliasInfo",

0x170001: "NewGWorldFromHBITMAP",
0x170003: "QTSetDDPrimarySurface",
0x170004: "QTGetDDObject",
0x170005: "QTMLSetWindowWndProc",
0x170006: "QTMLGetWindowWndProc",
0x170007: "GetPortHDC",
0x170008: "GetPortHBITMAP",
0x170009: "GetPortHPALETTE",
0x17000a: "GetPortHFONT",
0x17000b: "ShowHideTaskBar",
0x17000c: "IsTaskBarVisible",
0x17000e: "QTSetDDObject",
0x17000f: "GetDIBFromPICT",
0x170010: "GetPICTFromDIB",
0x170011: "GetGDeviceSurface",
0x170012: "GetGDeviceAttributes",
0x150002: "SystemZone",
0x150003: "ApplicationZone",
0x150006: "MemError",
0x150007: "GetZone",
0x150008: "NewHandle",
0x150009: "NewHandleSys",
0x15000a: "NewHandleClear",
0x15000b: "NewHandleSysClear",
0x15000c: "HandleZone",
0x15000d: "RecoverHandle",
0x15000f: "NewPtr",
0x150010: "NewPtrSys",
0x150011: "NewPtrClear",
0x150012: "NewPtrSysClear",
0x150013: "PtrZone",
0x150014: "MaxBlock",
0x150015: "MaxBlockSys",
0x150017: "NewEmptyHandle",
0x150018: "NewEmptyHandleSys",
0x150019: "HLock",
0x15001a: "HUnlock",
0x15001b: "HPurge",
0x15001c: "HNoPurge",
0x15001d: "HLockHi",
0x15001e: "TempNewHandle",
0x15001f: "TempMaxMem",
0x150020: "TempFreeMem",
0x150022: "SetZone",
0x150023: "CompactMem",
0x150024: "CompactMemSys",
0x150025: "PurgeMem",
0x150026: "PurgeMemSys",
0x150027: "FreeMem",
0x150028: "FreeMemSys",
0x150029: "ReserveMem",
0x15002a: "ReserveMemSys",
0x15002b: "MaxMem",
0x15002c: "MaxMemSys",
0x15002e: "MoveHHi",
0x15002f: "DisposePtr",
0x150030: "GetPtrSize",
0x150031: "SetPtrSize",
0x150032: "DisposeHandle",
0x150033: "SetHandleSize",
0x150034: "GetHandleSize",
0x150036: "ReallocateHandle",
0x150038: "EmptyHandle",
0x15003b: "HGetState",
0x15003c: "HSetState",
0x15003d: "PurgeSpace",
0x15003e: "BlockMove",
0x15003f: "BlockMoveData",
0x150045: "TempHLock",
0x150046: "TempHUnlock",
0x150047: "TempDisposeHandle",
0x15005b: "HandToHand",
0x15005c: "PtrToXHand",
0x15005d: "PtrToHand",
0x15005e: "HandAndHand",
0x15005f: "PtrAndHand",
0x2a0002: "NewWindow",
0x2a0003: "GetNewWindow",
0x2a0004: "NewCWindow",
0x2a0005: "DisposeWindow",
0x2a0006: "MacCloseWindow",
0x2a0007: "InvalRect",
0x2a0008: "InvalRgn",
0x2a0009: "ValidRect",
0x2a000a: "ValidRgn",
0x2a0015: "GetNewCWindow",
0x2a0016: "SetWTitle",
0x2a0017: "GetWTitle",
0x2a0018: "GetWMgrPort",
0x2a0019: "GetCWMgrPort",
0x2a001a: "SetWRefCon",
0x2a001b: "GetWRefCon",
0x2a001c: "SelectWindow",
0x2a001d: "HideWindow",
0x2a001e: "MacShowWindow",
0x2a001f: "ShowHide",
0x2a0021: "BringToFront",
0x2a0022: "SendBehind",
0x2a0023: "FrontWindow",
0x2a0025: "MacMoveWindow",
0x2a0026: "SizeWindow",
0x2a0027: "ZoomWindow",
0x2a0028: "BeginUpdate",
0x2a0029: "EndUpdate",
0x2a002d: "MacFindWindow",
0x2a002e: "PinRect",
0x2a0034: "GetWVariant",
0x2a0036: "GetGrayRgn",
0x290001: "BitTst",
0x290002: "BitSet",
0x290003: "BitClr",
0x290004: "BitAnd",
0x290005: "BitOr",
0x290006: "BitXor",
0x290007: "BitNot",
0x290008: "BitShift",
0x29000a: "HiWord",
0x29000b: "LoWord",
0x0e0001: "GetMouse",
0x0e0002: "Button",
0x0e0003: "StillDown",
0x0e0005: "TickCount",
0x0e0007: "GetCaretTime",
0x0e0008: "GetEvQHdr",
0x0e0009: "GetDblTime",
0x0e000a: "SetEventMask",
0x0e000b: "PPostEvent",
0x0e000c: "GetNextEvent",
0x0e000d: "WaitNextEvent",
0x0e000e: "EventAvail",
0x0e000f: "PostEvent",
0x0e0010: "OSEventAvail",
0x0e0011: "GetOSEvent",
0x0e0012: "FlushEvents",
0x0e0014: "SystemTask",
0x0e0016: "GetKeys",
0x0e0017: "MacGetDoubleClickTime",
0x10000: "CallComponent",
0x10001: "RegisterComponent",
0x10002: "UnregisterComponent",
0x10003: "CountComponents",
0x10004: "FindNextComponent",
0x10005: "GetComponentInfo",
0x10006: "GetComponentListModSeed",
0x10007: "OpenComponent",
0x10008: "CloseComponent",
0x10009: "DestroyComponent",
0x1000a: "GetComponentInstanceError",
0x1000b: "SetComponentInstanceError",
0x1000c: "GetComponentInstanceStorage",
0x1000d: "SetComponentInstanceStorage",
0x1000e: "GetComponentInstanceA5",
0x1000f: "SetComponentInstanceA5",
0x10010: "GetComponentRefcon",
0x10011: "SetComponentRefcon",
0x10012: "RegisterComponentResource",
0x10013: "CountComponentInstances",
0x10014: "RegisterComponentResourceFile",
0x10015: "OpenComponentResFile",
0x10018: "CloseComponentResFile",
0x1001c: "CaptureComponent",
0x1001d: "UncaptureComponent",
0x1001e: "SetDefaultComponent",
0x10020: "ResolveComponentAlias",
0x10021: "OpenDefaultComponent",
0x10024: "DelegateComponentCall",
0x10029: "GetComponentIconSuite",
0x1002c: "GetComponentTypeModSeed",
0x1002d: "OpenAComponent",
0x1002e: "OpenADefaultComponent",
0x1002f: "OpenAComponentResFile",
0x10035: "GetComponentResource",
0x10036: "GetComponentIndString",
0x10038: "GetComponentPublicResource",
0x10039: "GetComponentPublicResourceList",
0x1003a: "GetComponentPublicIndString",
0x220003: "FontScript",
0x220004: "IntlScript",
0x220006: "IsCmdChar",
0x220007: "FontToScript",
0x220008: "GetScriptManagerVariable",
0x22000a: "GetScriptVariable",
0x22000c: "CharacterByteType",
0x22000d: "CharacterType",
0x220018: "CharByte",
0x220019: "CharType",
0x1f0001: "TextFont",
0x1f0002: "TextFace",
0x1f0003: "TextMode",
0x1f0004: "TextSize",
0x1f0005: "SpaceExtra",
0x1f0006: "DrawChar",
0x1f0007: "DrawString",
0x1f0008: "MacDrawText",
0x1f0009: "CharWidth",
0x1f000a: "StringWidth",
0x1f000b: "TextWidth",
0x1f000c: "MeasureText",
0x1f000d: "GetFontInfo",
0x1f000f: "StdText",
0x1f0010: "StdTxMeas",
0x250003: "SysBeep",
0x250004: "SndDoCommand",
0x250005: "SndDoImmediate",
0x250006: "SndNewChannel",
0x250007: "SndDisposeChannel",
0x250008: "SndPlay",
0x250009: "SndAddModifier",
0x25000a: "SndControl",
0x25000b: "SndSoundManagerVersion",
0x25000f: "SndChannelStatus",
0x250010: "SndManagerStatus",
0x250015: "Comp3to1",
0x250016: "Exp1to3",
0x250017: "Comp6to1",
0x250018: "Exp1to6",
0x25001b: "GetDefaultOutputVolume",
0x25001c: "SetDefaultOutputVolume",
0x25001d: "GetSoundHeaderOffset",
0x25001e: "UnsignedFixedMulDiv",
0x25001f: "GetCompressionInfo",
0x250020: "SetSoundPreference",
0x250021: "GetSoundPreference",
0x250022: "SndGetInfo",
0x250023: "SndSetInfo",
0x250024: "GetSoundOutputInfo",
0x250025: "SetSoundOutputInfo",
0x250026: "GetCompressionName",
0x250027: "SoundConverterOpen",
0x250028: "SoundConverterClose",
0x250029: "SoundConverterGetBufferSizes",
0x25002a: "SoundConverterBeginConversion",
0x25002b: "SoundConverterConvertBuffer",
0x25002c: "SoundConverterEndConversion",
0x25002d: "SoundConverterGetInfo",
0x25002e: "SoundConverterSetInfo",
0x25002f: "OpenMixerSoundComponent",
0x250030: "CloseMixerSoundComponent",
0x25003f: "SoundConverterFillBuffer",
0x250040: "SoundManagerGetInfo",
0x250041: "SoundManagerSetInfo",
0x40001: "CompAdd",
0x40002: "CompSub",
0x40003: "CompNeg",
0x40004: "CompShift",
0x40005: "CompMul",
0x40006: "CompDiv",
0x40007: "CompFixMul",
0x40008: "CompMulDiv",
0x40009: "CompCompare",
0x4000a: "FixMulDiv",
0x4000b: "FracSinCos",
0x4000c: "CompMulDivTrunc",
0x4000d: "UnsignedFixMulDiv",
0x4000e: "FixExp2",
0x4000f: "FixLog2",
0x40010: "FixPow",
0x40011: "CompSquareRoot",
0x40014: "GetMatrixType",
0x40015: "SetIdentityMatrix",
0x40016: "RotateMatrix",
0x40017: "ScaleMatrix",
0x40018: "SkewMatrix",
0x40019: "TranslateMatrix",
0x4001b: "ConcatMatrix",
0x4001c: "InverseMatrix",
0x4001d: "MapMatrix",
0x4001e: "RectMatrix",
0x40020: "CopyMatrix",
0x40021: "EqualMatrix",
0x40022: "TransformFixedPoints",
0x40023: "TransformPoints",
0x40024: "TransformFixedRect",
0x40025: "TransformRect",
0x260001: "SFPutFile",
0x260002: "CustomPutFile",
0x260003: "SFGetFile",
0x260004: "SFPPutFile",
0x260005: "SFPGetFile",
0x260006: "StandardPutFile",
0x260007: "StandardGetFile",
0x260008: "CustomGetFile",
0x180008: "GetDateTime",
0x18000c: "DateToSeconds",
0x18000d: "SecondsToDate",
0x18000e: "DTInstall",
0x180011: "Delay",
0x180013: "Enqueue",
0x180014: "Dequeue",
0x18001f: "ReadLocation",
0x180022: "InsTime",
0x180023: "InsXTime",
0x180024: "Microseconds",
0x180025: "PrimeTime",
0x180026: "RmvTime",
0x180027: "MacGetCurrentProcess",
0x110001: "Gestalt",
0x110004: "NewGestaltValue",
0x110005: "ReplaceGestaltValue",
0x110006: "SetGestaltValue",
0x110007: "DeleteGestaltValue",
0x120001: "GetCIcon",
0x120002: "PlotCIcon",
0x120003: "DisposeCIcon",
0x120004: "GetIcon",
0x120005: "PlotIcon",
0x120006: "PlotIconID",
0x120021: "PlotIconHandle",
0x120022: "PlotSICNHandle",
0x120023: "PlotCIconHandle",
0x0b0001: "NewControl",
0x0b0003: "DisposeControl",
0x0b0004: "KillControls",
0x0b0005: "ShowControl",
0x0b0006: "HideControl",
0x0b0007: "DrawControls",
0x0b0008: "Draw1Control",
0x0b0009: "UpdateControls",
0x0b000a: "HiliteControl",
0x0b000b: "TrackControl",
0x0b000e: "FindControl",
0x0b000f: "MoveControl",
0x0b0010: "SizeControl",
0x0b0011: "SetControlTitle",
0x0b0012: "GetControlTitle",
0x0b0013: "GetControlValue",
0x0b0014: "SetControlValue",
0x0b0015: "GetControlMinimum",
0x0b0016: "SetControlMinimum",
0x0b0017: "GetControlMaximum",
0x0b0018: "SetControlMaximum",
0x0b001a: "SetControlAction",
0x0b001b: "GetControlAction",
0x0b0020: "GetControlComponentInstance",
0x0b0021: "GetDialogControlNotificationProc",
0x0b0022: "GetControlHandleFromCookie",
0x0b0023: "SetControlDefProc",
0x0b0024: "SetControlReference",
0x0b0025: "GetControlReference",
0x280001: "Munger",
0x280002: "NewString",
0x280004: "GetString",
0x280005: "StyledLineBreak",
0x280006: "TruncString",
0x280007: "TruncText",
0x280008: "FindWordBreaks",
0x280017: "c2pstr",
0x280018: "p2cstr",
0x280019: "c2pstrcpy",
0x28001a: "p2cstrcpy",
0x28001c: "IUCompPString",
0x28001d: "IUDateString",
0x28001e: "IUTimeString",
0x28001f: "IUEqualString",
0x280020: "IUMagIDString",
0x280021: "IUMagString",
0x280022: "EqualString",
0x280023: "RelString",
0x280024: "NumToString",
0x280025: "StringToNum",
0x280028: "ExtendedToString",
0x28002a: "IUMagIDPString",
0x230006: "ExitToShell",
0x0f0007: "PBReadSync",
0x0f0008: "PBReadAsync",
0x0f000a: "PBWriteSync",
0x0f000b: "PBWriteAsync",
0x0f000d: "PBGetVInfoSync",
0x0f0021: "PBGetFInfoSync",
0x0f0023: "PBSetFInfoSync",
0x0f002d: "PBGetEOFSync",
0x0f002f: "PBSetEOFSync",
0x0f0035: "PBFlushFileSync",
0x0f003e: "SetVol",
0x0f0041: "FlushVol",
0x0f0046: "FSClose",
0x0f0047: "FSRead",
0x0f0048: "FSWrite",
0x0f004a: "GetFInfo",
0x0f004b: "GetVol",
0x0f004d: "FSDelete",
0x0f004f: "Rename",
0x0f0054: "GetEOF",
0x0f0055: "SetEOF",
0x0f0056: "GetFPos",
0x0f0057: "SetFPos",
0x0f0067: "PBGetFCBInfoSync",
0x0f0069: "PBGetCatInfoSync",
0x0f006d: "PBAllocContigSync",
0x0f0075: "PBHGetVInfoSync",
0x0f0077: "PBHOpenSync",
0x0f0079: "PBHOpenRFSync",
0x0f007b: "PBHOpenDFSync",
0x0f007d: "PBHCreateSync",
0x0f00a2: "PBHGetVolParmsSync",
0x0f00e2: "FSMakeFSSpec",
0x0f00e3: "FSpOpenDF",
0x0f00e4: "FSpOpenRF",
0x0f00e5: "FSpCreate",
0x0f00e7: "FSpDelete",
0x0f00e8: "FSpGetFInfo",
0x0f00ec: "FSpRename",
0x100001: "FixRatio",
0x100002: "FixMul",
0x100003: "FixRound",
0x100004: "Fix2Frac",
0x100005: "Fix2Long",
0x100006: "Long2Fix",
0x100007: "Frac2Fix",
0x100008: "FracMul",
0x100009: "FixDiv",
0x10000a: "FracDiv",
0x10000b: "FracSqrt",
0x10000c: "FracSin",
0x10000d: "FracCos",
0x10000e: "FixATan2",
0x10000f: "RefFrac2X",
0x100010: "RefFix2X",
0x100011: "RefX2Fix",
0x100012: "RefX2Frac",
0x80001: "NewAlias",
0x80002: "NewAliasMinimal",
0x80003: "NewAliasMinimalFromFullPath",
0x80004: "ResolveAlias",
0x80005: "GetAliasInfo",
0x80006: "ResolveAliasFile",
0x80008: "UpdateAlias",
0x80009: "MatchAlias",
0x2b0002: "GetFontName",
0x2b0003: "RealFont",
0x2b0004: "GetFNum",
0x130001: "LNew",
0x130002: "LDispose",
0x130004: "LAddRow",
0x130006: "LDelRow",
0x130007: "LGetSelect",
0x130008: "LLastClick",
0x130009: "LNextCell",
0x13000a: "LSearch",
0x13000c: "LSetDrawingMode",
0x13000d: "LScroll",
0x13000e: "LAutoScroll",
0x13000f: "LUpdate",
0x130010: "LActivate",
0x130012: "LClick",
0x130013: "LAddToCell",
0x130014: "LClrCell",
0x130015: "LGetCell",
0x130016: "LRect",
0x130017: "LSetCell",
0x130018: "LSetSelect",
0x130019: "LDraw",
0x13001a: "LGetCellDataLocation",
0x13001c: "LSetNotificationCallback",
0x13001d: "LSetLDEF",
0x13001e: "GetListVisibleBounds",
0x210001: "InfoScrap",
0x210002: "UnloadScrap",
0x210003: "LoadScrap",
0x210004: "GetScrap",
0x210005: "ZeroScrap",
0x210006: "PutScrap",
0x14000b: "LMGetTheZone",
0x140019: "LMGetTicks",
0x14004b: "LMGetMemErr",
0x14005d: "LMGetSysZone",
0x14006b: "LMGetDoubleTime",
0x14008d: "LMGetScrnBase",
0x14008f: "LMGetMainDevice",
0x140091: "LMGetDeviceList",
0x1400bf: "LMGetWindowList",
0x1400c2: "LMGetPaintWhite",
0x1400c3: "LMSetPaintWhite",
0x1400c6: "LMGetGrayRgn",
0x1400f5: "LMGetResLoad",
0x1400f7: "LMGetResErr",
0x140137: "LMGetTheGDevice",
0x240001: "SPBVersion",
0x240006: "SPBGetIndexedDevice",
0x240007: "SPBOpenDevice",
0x240008: "SPBCloseDevice",
0x240009: "SPBRecord",
0x24000b: "SPBMillisecondsToBytes",
0x24000c: "SPBBytesToMilliseconds",
0x24000d: "SetupSndHeader",
0x24000e: "SetupAIFFHeader",
0x24000f: "ParseAIFFHeader",
0x240010: "ParseSndHeader",
0x240011: "SPBPauseRecording",
0x240012: "SPBStopRecording",
0x240013: "SPBGetDeviceInfo",
0x240014: "SPBSetDeviceInfo",
0x240015: "SPBResumeRecording",
0x240016: "SPBGetRecordingStatus",
0x1b0003: "PrOpen",
0x1b0004: "PrClose",
0x1b0005: "PrintDefault",
0x1b0006: "PrValidate",
0x1b0007: "PrStlDialog",
0x1b0008: "PrJobDialog",
0x1b0009: "PrStlInit",
0x1b000a: "PrJobInit",
0x1b000b: "PrJobMerge",
0x1b000c: "PrDlgMain",
0x1b000d: "PrOpenDoc",
0x1b000e: "PrCloseDoc",
0x1b000f: "PrOpenPage",
0x1b0010: "PrClosePage",
0x1b0011: "PrPicFile",
0x1b0012: "PrError",
0x1b0013: "PrSetError",
0x1b0014: "PrGeneral",
0x270002: "TENew",
0x270003: "TEDispose",
0x270004: "TESetText",
0x270005: "TEGetText",
0x270006: "TEIdle",
0x270007: "TESetSelect",
0x270008: "TEActivate",
0x270009: "TEDeactivate",
0x27000e: "TEDelete",
0x27000f: "TEInsert",
0x270010: "TESetAlignment",
0x270011: "TEUpdate",
0x270012: "TETextBox",
0x270013: "TEScroll",
0x270014: "TESelView",
0x270015: "TEPinScroll",
0x270016: "TEAutoView",
0x270017: "TECalText",
0x270018: "TEGetOffset",
0x270019: "TEGetPoint",
0x27001b: "TEStyleNew",
0x27001c: "TESetStyleHandle",
0x27001d: "TEGetStyleHandle",
0x27001e: "TEGetStyle",
0x27001f: "TEStylePaste",
0x270020: "TESetStyle",
0x270021: "TEReplaceStyle",
0x270022: "TEGetStyleScrapHandle",
0x270023: "TEStyleInsert",
0x270024: "TEGetHeight",
0x270025: "TEContinuousStyle",
0x270026: "TEUseStyleScrap",
0x270028: "TENumStyles",
0x270029: "TEFeatureFlag",
}

```

`application/delphi.py`:

```py
"""
Delphi module

This module exposes some basic tools for working with a database built against
a delphi target. These tools are simple things that can help with automating
the creation of strings or other types of data structures that one may find.
"""

import functools, itertools, types, builtins, operator, six
import database as db, function as func, instruction as ins, structure as struc

import logging, string
from internal import utils

def string(ea):
    '''Convert the string defined by IDA at the address `ea` into a delphi-style string and return its length.'''
    if db.get.i.uint32_t(ea - 8) == 0xffffffff:
        db.set.undefined(ea)
        db.set.integer.dword(ea - 8)
        cb = db.set.string(ea - 4, type=idaapi.STRTYPE_LEN4)
        try:
            al = db.set.align(ea - 4 + cb, alignment=8)
        except TypeError:
            al = db.set.align(ea - 4 + cb, alignment=4)
        return 4 + cb + al
    logging.warning(u"{:s}.string({:#x}): The data at address {:#x} is not a properly prefixed delphi string.".format(__name__, ea, ea - 8))
    return 0

```

`application/quicktime.py`:

```py
'''QuickTime stuff'''

EXPORT = [ 'nameDispatch', 'nameAllDispatches' ]

import idc,idautils
import function,database

from . import __quicktime

def nextMnemonic(ea, mnem, maxaddr=0xc0*0x1000000):
    res = idc.print_insn_mnem(ea)
    if res == "": return idc.BADADDR
    if res == mnem: return ea
    return nextMnemonic( idc.next_head(ea, maxaddr), mnem, maxaddr )

def prevMnemonic(ea, mnem, minaddr=0):
    res = idc.print_insn_mnem(ea)
    #print("%x -> %s"% (ea, res))
    if res == "": return idc.BADADDR
    if res == mnem: return ea
    return prevMnemonic( idc.prev_head(ea, minaddr), mnem, minaddr )

def getMinorDispatchTableAddress(ea):
    """find address of last lea in function"""
    start = idc.get_func_attr(ea, idc.FUNCATTR_START)
    end = idc.prev_head( idc.get_func_attr(ea, idc.FUNCATTR_END), start)
    res = prevMnemonic(end, 'lea', start)
    assert res != idc.BADADDR
    return idc.get_operand_value(res, 1)

def getMajorDispatchTableAddress():
    """find quicktime major dispatch table"""
    res = idc.get_name_ea_simple('theQuickTimeDispatcher')
    res = nextMnemonic(res, 'lea', idc.get_func_attr(res, idc.FUNCATTR_END))
    assert res != idc.BADADDR
    return idc.get_operand_value(res, 1)

def resolveDispatcher(code):
    major = (code & 0x00ff0000) >> 0x10
    minor = code & 0xff00ffff

    res = getMajorDispatchTableAddress() + major*8
    majorFlag = idc.get_wide_dword(res)
    majorAddress = idc.get_wide_dword(res+4)
    if majorFlag != 0:
        return majorAddress + (minor*0x10)

    #print("%x"% getMinorDispatchTableAddress(majorAddress))
    #print("resolved by 0x%x(%x)"% (majorAddress, minor))
    return majorAddress

def getDispatchCode(ea):
    # get dispatch code out of an instruction
    first, second = (idc.print_operand(ea, 0), idc.get_operand_value(ea, 1))
    if first == 'eax':
        return second
    raise ValueError("Search resulted in address %08x, but instruction '%s' does fulfill requested constraints"% (ea, idc.print_insn_mnem(ea)))

def FindLastAssignment(ea, register):
    start,end = database.guessrange(ea)
    while ea > start:
        ea = database.prev(ea)
        m = idc.print_insn_mnem(ea)
        r = idc.print_operand(ea, 0)

        if m == 'mov' and r == register:
            return ea
        continue

    raise ValueError('FindLastAssignment(0x%x, %s) Found no matches'% (ea, register))

def nameDispatch(address):
    '''Name the dispatch function at the specified address in quicktime.qts'''
    try:
        start, end = function.range(address)

    except ValueError:
        print('%x making a function'% address)
        function.make(address)
        start, end = function.range(address)

    try:
        ea = FindLastAssignment(address, 'eax')
        code = getDispatchCode(ea)
    except ValueError:
        print('%08x - Unable to find dispatch code'% address)
        return

    ofs = database.getoffset(start)
    function.setName(start, 'dispatch_%08x_%x'% (code, ofs))
    function.tag(start, 'code', hex(code))
    function.tag(start, 'group', 'dispatch')
    try:
        function.tag(start, 'realname', __quicktime.qt_fv_list[code])
    except KeyError:
        pass

    try:
        function.tag(start, 'address', hex(resolveDispatcher(code)), repeatable=True)
    except:
        pass

def nameAllDispatches(ea):
    '''Using the address of {theQuickTimeDispatcher}, name and tag all discovered dispatch calls in quicktime.qts'''
    for address in idautils.DataRefsTo(ea):
        nameDispatch(address)
    return

```

`application/windbg.py`:

```py
"""
Windbg module

This module exposes some basic tools for assistance when interacting with
windbg. This can be things that help with importing/exporting data from/to
windbg, or tools for generating quotes strings to paste into windbg.

One utility within this module will allow one to escape all the quotes
in a string of a particular depth. This can be used to help generating
string that can be pasted into a conditional breakpoint, or to pass a
properly quoted format-string as an argument to the `.printf` token.
"""

import functools, itertools, types, builtins, operator, six
import database as db, function as func, instruction as ins, structure as struc

import logging, string
from internal import utils

def reference(ea, **module):
    """Return a reference containing the module and offset of the address `ea`.

    If the string `module` is specified, then use it as the module name instead of the database filename.
    """
    module = module.get('module', db.filename())
    return '{:s}+{:x}'.format(module.replace(' ', ''), db.offset(ea))

def label(ea):
    '''Return a label for the given address `ea`.'''
    try: res = '{:s}{{+{:x}}}'.format(func.name(ea), db.offset(ea))
    except: res = '+{:x}'.format(db.offset(ea))
    return '{:s}!{:s}'.format(db.module(), res)

def tokenize(input, escapables={"'", '"', '\\'} | {item for item in string.whitespace} - {' '}):
    """Yield each token belonging to the windbg format in `input` that would need to be escaped using the specified `escapables`.

    If the set `escapables` is defined, then use it as the list of characters to tokenize.
    """
    result, iterable = '', (item for item in input)
    try:
        while True:
            char = builtins.next(iterable)
            if operator.contains(escapables, char):
                if result:
                    yield result
                yield char
                result = ''

            else:
                result += char
            continue

    except StopIteration:
        if result:
            yield result
        return
    return

def escape(input, depth=0, **extra):
    """
    Given the windbg format string in `input`, escape each of its characters as if it was within `depth` level of quoting.

    If any other keyword parameters are provided, then escape those keywords with their value.
    """

    # Define the generator form of ourself as we're just going to aggregate its
    # result into a string anyways.
    def closure(input, depth, extra):
        bs = '\\'
        ws = { six.unichr(i) : item for i, item in enumerate('0123456abtnvfr') }
        escaped = {bs, '"'}

        # Now we can tokenize our input and figure out what it's supposed to yield
        for token in tokenize(input):

            # Check if the token is a windbg quote that needs to be explicitly
            # escaped
            if operator.contains(escaped, token):
                yield bs * depth + token

            # Did the token match one of our whitespace characters?
            elif operator.contains(ws, token):
                yield bs + (bs * depth) + ws[token]

            # If nothing matched, then we can just yield the current character
            # as it was unprocessed.
            else:
                # Add any characters that were explicitly specified in the
                # "extra" dictionary, and replace our current token with it
                if any(operator.contains(token, item) for item in extra):
                    k = builtins.next(item for item in extra if operator.contains(token, item))
                    token = token.replace(k, extra[k] * depth + k)

                # Now we can yield our token
                yield token
            continue
        return
    return str().join(closure(input, depth, extra))

def breakpoints(f=None, **kwargs):
    """Query the function `f` for the "break" tag, and use it to emit a list of breakpoints for windbg.

    If the string `module` is specified, then use it instead of the current filename when emitting the location.
    If the string `tagname` is provided, then use it to query instead of "break".
    """
    tagname = kwargs.get('tagname', 'break')

    # if no function was provided, then recurse into ourself for all of them
    if f is None:
        for f, _ in db.selectcontents(tagname):
            breakpoints(f, **kwargs)
        return

    #entry, exit = func.top(f), func.bottom(f)
    #funcname = func.name(f)
    #[(entry,{tagname:'.printf "Entering {:s} %x,%x\\n",poi(@esp),@esp'.format(funcname)})], [(x,{tagname:'.printf "Exiting {:s} %x,%x\\n",poi(@esp),@esp'.format(funcname)}) for x in exit],

    # query the given function for the requested tagname
    tags, select = {}, itertools.chain(func.select(f, And=(tagname,), Or=('',)))
    for ea, t in select:
        h = tags.setdefault(ea, {})
        for k in t.keys():
            if k == tagname:
                h.setdefault(k, []).extend(t[k] if isinstance(t[k], builtins.list) else t[k].split(';'))

            elif operator.contains(h, k):
                logging.warning(u"{:s}.breakpoints({:#x}{:s}) : The specified key \"{:s}\" already exists in dictionary for address {:#x}.".format(__name__, func.addr(f), u", {:s}".format(utils.strings.kwargs(kwargs)) if kwargs else '', utils.string.escape(k, '"'), ea))

            else:
                h[k] = t[k]
            continue
        continue

    # aggregate all of the discovered tags into a list of breakpoints
    for ea, t in tags.items():
        ofs, commands = db.offset(ea), []

        # create the command that emits the current label
        label_t = string.Template(r'.printf "$label -- $note\n"' if operator.contains(t, '') else r'.printf "$label\n"')
        commands.append(label_t.safe_substitute(label=label(ea), note=t.get('', '')))

        # append the commands to execute when encountering the given breakpoint
        res = t.get(tagname, ['g'])
        if isinstance(res, builtins.list):
            commands.extend(res)
        else:
            commands.append(res)

        # escape all of the commands since we're going to join them together
        commands = (escape(cmd) for cmd in commands)

        parameters = next((kwargs[kw] for kw in ['parameters', 'params', 'param'] if kw in kwargs), '')
        six.print_('bp {:s}{:s} "{:s}"'.format("{:s} ".format(parameters) if parameters else '', reference(ea, **kwargs), escape(';'.join(commands), depth=1)))
    return

```

`base/_comment.py`:

```py
r"""
Comment module (internal)

This module contains the functionality for encoding and decoding
arbitrary python objects into IDA's comments and is thus a major
component of the way the tag system in this plugin works.

These encoded python objects are constrained in that they must also
double as being human readable in IDA's disassembly view. This then
allows one to essentially store a dictionary within each comment that
can be used to read/write primitive python objects.

Each comment stored at an address is a list of key-value pairs
separated by newlines. Each key represents a tag and so as a comment,
it has the following appearance.

    [key1] value1
    [key2] value2
    ...

If a comment does not follow this format, then it assumed that the
comment's value is a simple unencoded tag and can be accessed via
the '' key (empty). This means that if your comment is simply the
string "HeapHandle", then its dictionary will look similar to
`{'' : 'HeapHandle'}`.

Unfortunately IDA has a limitation on the length of comments and so
arbitrarily long data will not be able to be stored. This includes
things such as more complex types or custom objects. If one truly
needs to store a more complex type then it is suggested that the user
marshal or pickle their object, compress it in some way, and then
base64 encode it at a given address with their key. Still this is not
recommended, but who am I to stop a user from wanting to be crazy.

Some of the values are encoded in order to retain any specific
information about the value as well as still allowing the user to read
the tag's immediate contents. By default all integers are always
encoded as hexadecimal. If you can't read hex, then you should save
your database and quit your job. Or you could also practice it I guess.
It's the next power of 2 from decimal and is hence pretty important.
Strings and other types that contain any line-breaking characters also
get encoded whereas both lists and most iterable types are stored as-is.

Some examples of how tag values are encoded are as follows:

    4021 -> 0xfb5
    -100 -> -0x64
    0.5 -> float(0.5)
    'hello world\nhow\'re ya' -> hello world\nhow're ya
    {10,20,30} -> set([10, 20, 30])

With regards to string, only certain characters are escaped because
I don't know if IDA's comments support unicode. So, the characters
that have special meaning are '\n', '\r', and '\t'. Similarly if a
backslash is escaped, it will result in a single '\'. If any other
character is prefixed with a backslash, it will decode into a character
that is prefixed with a backslash.
"""

import functools, operator, itertools, types
import collections, heapq, string
import sys, six, logging

import internal, idaapi
import codecs

### cheap data structure for doing pattern matching with
class pattern(object):
    class star(tuple): pass
    class maybe(tuple): pass

class node(dict):
    id = 0
    def __missing__(self, token):
        cls = self.__class__

        res = cls()
        res.id = self.id + len(self) + 1
        return self.setdefault(token, res)

class trie(node):
    def assign(self, symbols, value):
        res = [item for item in symbols]
        head = res.pop(0)
        symbols = tuple(res)

        head = head if hasattr(head, '__iter__') or len(head) > 1 else (head,)
        if isinstance(head, pattern.star):
            if len(symbols) <= 0:
                raise ValueError('Refusing to register the STAR(*) pattern as the last symbol')

            [ self.__setitem__(item, self) for item in head ]
            self.assign(symbols, value)
            return

        elif isinstance(head, pattern.maybe):
            if len(symbols) <= 0:
                raise ValueError('Refusing to register the MAYBE(?) pattern as the last symbol')
            head, res = tuple(head), trie()
            res.assign(symbols, value)
            [ self.__setitem__(item, res) for item in head ]
            self.assign(symbols, value)
            return

        elif len(symbols) > 0:
            [ self[item].assign(symbols, value) for item in head ]

        else:
            [ self.__setitem__(item, value) for item in head ]
        return

    def descend(self, symbols):
        yield self
        for i, symbol in enumerate(symbols):
            if not isinstance(self, node) or not operator.contains(self, symbol):
                raise KeyError(i, symbol)    # raise KeyError for .get() and .find()
            self = self[symbol]
            yield self
        return

    def get(self, symbols):
        for i, symbol in enumerate(self.descend(symbols)):
            continue
        if isinstance(symbol, node):
            raise KeyError(i, symbol)    # raise KeyError for our caller if we couldn't find anything
        return symbol

    def find(self, symbols):
        for i, symbol in enumerate(self.descend(symbols)):
            if not isinstance(symbol, node):
                return symbol
            continue
        raise KeyError(i, symbol)    # raise KeyError for our caller if we couldn't find anything

    def dump(self):
        cls = self.__class__
        # FIXME: doesn't support recursion
        def stringify(layer, indent=0, tab='  '):
            result = []

            # iterate through data
            for key, value in layer.items():
                if not isinstance(value, node):
                    result.append("{:s}{!r} -> {!r}".format(tab * indent, key, value))
                continue

            # iterate through branches
            for key, value in layer.items():
                if isinstance(value, node):
                    result.append("{:s}{!r}".format(tab * indent, key))
                    branch_data = stringify(value, 1 + indent, tab=tab)
                    result.extend(branch_data)
                continue
            return result
        return '\n'.join(["{!r}({:d})".format(cls, self.id), '\n'.join(stringify(self))])

### cache for looking up encoder/decoder types
class cache(object):
    state, tree = collections.defaultdict(set), trie()

    @classmethod
    def register(cls, type, *characters):
        def result(definition):
            # add definition to constant search by specified type
            cls.state[type].add(definition)

            # add definition to symbolic search
            if characters:
                cls.tree.assign(characters, definition)

            return definition
        return result

    @classmethod
    def by(cls, instance):
        type = instance.__class__
        try:
            if type not in cls.state:
                type = next(t for t in cls.state if issubclass(type, t))
            res = next(enc for enc in cls.state[type] if enc.type(instance))
        except StopIteration:
            raise internal.exceptions.SerializationError(u"{:s}.by({!s}) : Unable to find an encoder for the serialization of the specified type ({!s}).".format('.'.join([__name__, cls.__name__]), type, type))
        return res

    @classmethod
    def match(cls, string):
        return cls.tree.find(string)

class default(object):
    @classmethod
    def type(cls, instance):
        return True
    @classmethod
    def encode(cls, instance):
        return repr(instance)
    @classmethod
    def decode(cls, data):
        return eval(data)

### type encoder/decoder registration

# FIXME: maybe figure out how to parse out an int from a long in Python2 (which ends in 'L')
@cache.register(object, pattern.star(' \t'), pattern.maybe('-+'), '0123456789')
class _int(default):
    @classmethod
    def type(cls, instance):
        return isinstance(instance, six.integer_types)

    @classmethod
    def encode(cls, instance):
        return "{:-#x}".format(instance)

    # Build a table of prefixes and their radix for O(1) lookup.
    radixtable = {}
    for prefix in ['0x', '-0x', '+0x']: radixtable[prefix] = 16
    for prefix in ['0o', '-0o', '+0o']: radixtable[prefix] = 8
    for prefix in ['0b', '-0b', '+0b']: radixtable[prefix] = 2

    # We use a negative radix as a placeholder since Python doesn't know this prefix.
    for prefix in ['0y', '-0y', '+0y']: radixtable[prefix] = -2

    @classmethod
    def decode(cls, data):
        length = 2 if data[0] == '0' else 3
        prefix = data[:length]

        # Grab the radix using our precalculated prefix table. If our radix
        # is positive, then we can just pass it to `int` to get the value.
        radix = cls.radixtable.get(prefix, 0)
        if radix > 0:
            return int(data, radix)

        # If the radix is negative, then we need to explicitly slice off
        # the prefix before passing the radix to our value.
        elif radix < 0:
            return -int(data[length:], abs(radix)) if prefix[:1] == '-' else int(data[length:], abs(radix))

        # Otherwise we couldn't find a radix, and we need to hand it off to
        # `int` to try parsing it as an integer.
        return int(data)

@cache.register(object, pattern.star(' \t'), *'float(')
class _float(default):
    @classmethod
    def type(cls, instance):
        return isinstance(instance, float)
    @classmethod
    def encode(cls, instance):
        return "float({:f})".format(instance)

if sys.version_info.major < 3:
    @cache.register(str)
    class _str(default):
        """
        This encoder/decoder actually supports both ``unicode`` and regular
        ``str`` due to the ``type`` method checking both string types. Also,
        we use this class as a superclass for ``_unicode`` so that any kind
        of string will be encoded into a unicode string which will be
        converted into UTF8 when written into IDA.
        """

        @classmethod
        def type(cls, instance):
            return isinstance(instance, six.string_types)

        @classmethod
        def _unescape(cls, iterable):
            '''Invert the utils.character.unescape coroutine into a generator.'''
            state = internal.interface.collect_t(list, lambda agg, ch: agg + [ch])
            unescape = internal.utils.character.unescape(state); next(unescape)

            # iterate through each character in the string
            for ch in iterable:
                unescape.send(ch)

                # iterate through the results and yield them to the caller
                for ch in state.get():
                    yield ch

                # now we can start over
                state.reset()
            return

        @classmethod
        def _escape(cls, iterable):
            '''Invert the utils.character.escape coroutine into a generator.'''
            state = internal.interface.collect_t(list, lambda agg, ch: agg + [ch])
            escape = internal.utils.character.escape(state); next(escape)

            # iterate through each character in the string
            for ch in iterable:
                escape.send(ch)

                # iterate through the results and yield them to the caller
                for ch in state.get():
                    yield ch

                # empty our state and start over
                state.reset()
            return

        @classmethod
        def decode(cls, data):
            res = data if isinstance(data, unicode) else data.decode('utf8')
            iterable = (ch for ch in res.lstrip())
            return unicode().join(cls._unescape(iterable))

        @classmethod
        def encode(cls, instance):
            iterable = (item for item in instance)
            res = cls._escape(iterable)
            return unicode().join(res)

    @cache.register(unicode, pattern.star(' \t'), 'u', "'\"")
    class _unicode(_str):
        """
        This encoder/decoder really just a wrapper around the ``_str``
        class. Its encoder will simply escape the string in the exact
        same way as ``_str``. We register a pattern for it so that we
        can decode unicode strings encoded in their older format. Due
        to the older format requiring unicode strings to begin with
        the "u'" prefix, we can simply eval it in order to decode
        back to a unicode string.
        """

        @classmethod
        def type(cls, instance):
            return isinstance(instance, unicode)

        @classmethod
        def decode(cls, data):
            logging.warning(u"{:s}.decode({!s}) : Decoding a unicode string that was encoded using the old format.".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(data)))
            return eval(data)

else:
    @cache.register(bytes, pattern.star(' \t'), 'b', "'\"")
    class _bytes(default):
        @classmethod
        def type(cls, instance):
            return isinstance(instance, bytes)

        @classmethod
        def decode(cls, data):
            return eval(data)

        @classmethod
        def encode(cls, instance):
            return repr(instance)

    @cache.register(str)
    class _str(default):
        @classmethod
        def type(cls, instance):
            return isinstance(instance, six.string_types)

        @classmethod
        def _unescape(cls, iterable):
            '''Invert the utils.character.unescape coroutine into a generator.'''
            state = internal.interface.collect_t(list, lambda agg, ch: agg + [ch])
            unescape = internal.utils.character.unescape(state); next(unescape)

            # iterate through each character in the string
            for ch in iterable:
                unescape.send(ch)

                # iterate through the results and yield them to the caller
                for ch in state.get():
                    yield ch

                # now we can start over
                state.reset()
            return

        @classmethod
        def _escape(cls, iterable):
            '''Invert the utils.character.escape coroutine into a generator.'''
            state = internal.interface.collect_t(list, lambda agg, ch: agg + [ch])
            escape = internal.utils.character.escape(state); next(escape)

            # iterate through each character in the string
            for ch in iterable:
                escape.send(ch)

                # iterate through the results and yield them to the caller
                for ch in state.get():
                    yield ch

                # empty our state and start over
                state.reset()
            return

        @classmethod
        def decode(cls, data):
            res = data if isinstance(data, six.string_types) else data.decode('utf8')
            return str().join(cls._unescape(iter(res.lstrip())))

        @classmethod
        def encode(cls, instance):
            res = cls._escape(iter(instance))
            return str().join(res)

@cache.register(dict, pattern.star(' \t'), '{')
class _dict(default):
    @classmethod
    def type(cls, instance):
        return isinstance(instance, dict)
    @classmethod
    def encode(cls, instance):
        f = lambda item: "{:-#x}".format(item) if isinstance(item, six.integer_types) else "{!r}".format(item)
        return '{' + ', '.join("{:s}: {!r}".format(f(key), instance[key]) for key in instance) + '}'

@cache.register(list, pattern.star(' \t'), '[')
class _list(default):
    @classmethod
    def type(cls, instance):
        return isinstance(instance, list)
    @classmethod
    def encode(cls, instance):
        f = lambda item: "{:-#x}".format(item) if isinstance(item, six.integer_types) else "{!r}".format(item)
        return '[' + ', '.join(map(f, instance)) + ']'

@cache.register(tuple, pattern.star(' \t'), '(')
@cache.register(object, pattern.star(' \t'), '(')
class _tuple(default):
    @classmethod
    def type(cls, instance):
        return isinstance(instance, tuple)
    @classmethod
    def encode(cls, instance):
        f = lambda item: "{:-#x}".format(item) if isinstance(item, six.integer_types) else "{!r}".format(item)
        return '(' + ', '.join(map(f, instance)) + (', ' if len(instance) == 1 else '') + ')'

@cache.register(set, pattern.star(' \t'), *'set([')
class _set(default):
    @classmethod
    def type(cls, instance):
        return isinstance(instance, set)
    @classmethod
    def encode(cls, instance):
        f = lambda item: "{:-#x}".format(item) if isinstance(item, six.integer_types) else "{!r}".format(item)
        return 'set([' + ', '.join(map(f, instance)) + '])'

### general tag encoding/decoding
class tag(object):
    """
    Namespace for encoding and decoding a tag and it's value.
    """

    ## Tag name
    class name(object):
        """
        Namespace for encoding and decoding a tag's name.
        """

        prefix, suffix = '[]'
        backslash = '\\'

        mappings = {
            prefix : backslash + prefix,
            suffix : backslash + suffix,
            ' ' : r' ',
            backslash : backslash + backslash,
        }

        @classmethod
        def encode(cls, iterable, result):
            '''Given an `iterable` string, send each character in a printable form to `result`.'''

            # construct a transformer that writes characters to result
            escape = internal.utils.character.escape(result); next(escape)

            # send the key prefix
            result.send(cls.prefix)

            # now we can actually process the string
            for ch in iterable:

                # first check if character has an existing key mapping
                if operator.contains(cls.mappings, ch):
                    for ch in operator.getitem(cls.mappings, ch):
                        result.send(ch)

                # otherwise pass it to the regular escape function
                else:
                    escape.send(ch)

                continue

            # submit the suffix and we're good
            result.send(cls.suffix)
            return

        @classmethod
        def decode(cls, iterable, result):
            '''Given an `iterable`, decode it into a unicode string and send it to `result`.'''

            # first create our aggregate type for decoding into
            agg = internal.interface.collect_t(unicode if sys.version_info.major < 3 else str, operator.add)

            # construct a transformer that unescapes characters to result
            unescape = internal.utils.character.unescape(agg); next(unescape)

            # first we'll skip the initial whitespace
            ch = next(iterable)
            while ch != cls.prefix and internal.utils.character.whitespaceQ(ch):
                ch = next(iterable)

            # check if it matches our prefix (which it should)
            if ch != cls.prefix:
                raise internal.exceptions.InvalidFormatError(u"{:s}.decode({!s}, {!s}) : Input for tag name does not begin with the proper character ('{:s}') and instead starts with '{:s}'.".format('.'.join([__name__, 'tag', cls.__name__]), iterable, result, internal.utils.string.escape(cls.prefix, '\''), internal.utils.string.escape(ch, '\'')))

            # read each character up to the sentinel
            agg.reset()
            ch = next(iterable)

            # loop until we find our suffix
            while ch != cls.suffix:

                # submit our character to the unescape transformer while
                # it's a backslash
                while ch in u'\\':
                    unescape.send(ch)
                    ch = next(iterable)

                # otherwise, continue to unescape it and look for a suffix
                unescape.send(ch)
                ch = next(iterable)

            # the last character read should be our suffix, so fail if otherwise
            if ch != cls.suffix:
                raise internal.exceptions.InvalidFormatError(u"{:s}.decode({!s}, {!s}) : Input for tag name does not terminate with the correct character ('{:s}') and instead is terminated with '{:s}'.".format('.'.join([__name__, 'tag', cls.__name__]), iterable, result, internal.utils.string.escape(cls.suffix, '\''), internal.utils.string.escape(ch, '\'')))

            # at this point, agg should have our unescaped key that we can submit
            result.send(agg.get())

    ## Tag value
    class value(object):
        """
        Namespace for encoding and decoding a tag's value.
        """

        @classmethod
        def encode(cls, iterable, result):
            '''Read a value from `iterable` and encode it into `result`.'''
            value = next(iterable)
            t = cache.by(value)
            for ch in t.encode(value):
                result.send(ch)
            return

        @classmethod
        def decode(cls, iterable, result):
            '''Given an `iterable`, decode it into a unicode string and send it to `result`.'''
            res = []

            # first we'll skip whitespace
            ch = next(iterable, '\n')
            while ch != '\n' and internal.utils.character.whitespaceQ(ch):
                res.append(ch)
                ch = next(iterable, '\n')

            # if we were just whitespace, then decode it as
            # a unicode string to return
            if ch == '\n':
                cons = unicode if sys.version_info.major < 3 else str
                value_s = cons().join(res)
                result.send(_str.decode(value_s))
                return

            # now we'll continue reading until the sentinel character
            value_l = []
            while ch != '\n':
                value_l.append(ch)
                ch = next(iterable, '\n')
            value_s = str().join(value_l)

            # now we'll try to find out what type to decode it as
            try:
                t = cache.match(value_s)

            except KeyError:
                t = _str

            # we have a type and a value. try to decode it
            try:
                value = t.decode(value_s)

            # if we weren't able to, then fall back to a string
            except Exception as E:
                t = _str
                logging.debug(u"{:s}.decode({!s}, {!s}) : Assuming value ({!s}) is of type {!s}.".format('.'.join([__name__, 'tag', cls.__name__]), iterable, result, internal.utils.string.repr(value_s), t))
                value = t.decode(value_s)

            # now we can submit it
            result.send(value)

    @classmethod
    def encode(cls, key, value):
        '''Encode the provided `key` and `value` into a line fit for a comment.'''
        result = internal.interface.collect_t(unicode if sys.version_info.major < 3 else str, operator.add)

        # first encode the beginning of the name
        tag.name.encode(iter(key), result)

        # store some whitespace in between
        result.send(' ')

        # next encode the value component
        tag.value.encode(iter([value]), result)

        # now we can return the resulting string
        return result.get()

    @classmethod
    def decode(cls, iterable):
        '''Read the line in `iterable` and return the key and its value.'''

        # first decode the key
        key = internal.interface.collect_t(object, lambda agg, key: key)
        tag.name.decode(iterable, key)

        # next decode its value
        value = internal.interface.collect_t(object, lambda agg, value: value)
        tag.value.decode(iterable, value)

        # plain and simple...
        return key.get(), value.get()

### Encoding and decoding of a comment
def decode(data, default=u''):
    """Decode all the `(key, value)` pairs from the string `data` delimited by newlines.

    If unable to decode the key and value from a line in `data`, then use `default` as the key name.
    """

    # if data is empty, then return an empty dict
    if not data:
        return {}

    # iterate through each line in the data so that we can collect it
    # into our result dictionary.
    result = {}
    for line in data.split(u'\n'):
        iterable = (ch for ch in line)

        # try and decode the key and the value from the line
        try:
            key, value = tag.decode(iterable)

        # if the key wasn't terminated properly or the line was not
        # formatted correctly, then fall back to using the default key.we
        # first need to grab the value of the default key from our result
        # dictionary because we need to ensure it's a string so that we
        # can actually append our corrupted value to it.
        except (StopIteration, internal.exceptions.InvalidFormatError) as E:
            key, value = default, result.setdefault(default, u'')

            # if our previous value is already a string, then we can use
            # it as-is and append it to the default key separated by a newline.
            if isinstance(value, six.string_types):
                string = value

            # if it's not, however, then we need to demote the value to
            # a string by temporarily encoding it. this is hackish, but
            # its okay because we're warning the user about it anywayz.
            else:
                logging.warning(u"{:s}.decode(..., {!s}) : Coercing the prior value ({!s}) for the decoded tag ({!s}) to a {!s} due to its value being of a non-cumulative type ({!s}).".format('.'.join([__name__]), internal.utils.string.repr(key), internal.utils.string.repr(value), internal.utils.string.repr(key), key.__class__, value.__class__))

                # now we can collect it into a string...
                collected_value = internal.interface.collect_t(unicode if sys.version_info.major < 3 else str, operator.add)
                tag.value.encode(iter([value]), collected_value)
                string = collected_value.get()

            # now we should have a proper string that we can append our
            # incorrectly formatted tag and value to.
            items = filter(None, string.split(u'\n'))
            value = u'\n'.join(itertools.chain(items, [line]))

        # if there was no exception, but the key that we decoded can potentially
        # overwrite an already existing key in our result dictionary, then we will
        # still need to warn the user about it because we're being destructive.
        # NOTE: another option here to avoid being destructive is to demote the
        #       previous dictionary value to a string, and append to it. personally
        #       i believe that warning the user should be enough so that way we don't
        #       interfere with any scripting that they might currently be performing.
        else:
            if operator.contains(result, key):
                logging.warning(u"{:s}.decode(..., {!s}) : Overwriting the value ({!r}) for the decoded tag ({!s}) using a new value ({!r}) of {!s}.".format('.'.join([__name__]), internal.utils.string.repr(default), result[key], internal.utils.string.repr(key), value, value.__class__))

        # add our item to the result dictionary
        result[key] = value

    # return the dictionary we decoded
    return result

def encode(dict):
    '''Encode a dictionary into a multi-line string encoded as a list of tags.'''
    result = []

    # walk each item in the dictionary, so that we can encode
    # each key and value into a single line and aggregate them
    # into our result list.
    for key, value in (dict or {}).items():
        line = tag.encode(key, value)
        result.append(line)

    # now we can join them with newlines and return it to the caller
    return '\n'.join(result)

def check(data):
    '''Check that the string `data` has the correct format by trying to decode it.'''
    res = map(iter, (data or '').split('\n'))
    try:
        [tag.decode(item) for item in res]
    except Exception as E:
        return False
    return True

### Tag reference counting
class tagging(object):
    """
    This namespace is essentially the configuration of the tagging
    database. This configurations specifies how to marshal and
    compress reference counts that are retained by the tagging
    infrastructure.

    The keys for the dictionaries that store the reference count
    are named according to ``tagging.__tags__`` for the tag names
    and ``tagging.__address__`` for the tag addresses. In order
    to access the tagging database, the netnode is returned by
    the ``tagging.node()`` function.

    When a database has been successfully created, a hook is
    responsible for calling the ``tagging.__init_tagcache__()``
    function. This will then create a netnode with the name
    specified in ``tagging.__node__``.
    """
    __node__ = '$ tagcache'
    __tags__, __address__ = 'name', 'address'

    marshaller = __import__('marshal')
    codec = __import__('codecs').lookup('bz2_codec')

    @classmethod
    def __init_tagcache__(cls, idp_modname):
        '''Hook to create a new netnode that will contain our tag-cache.'''
        res = cls.node(cached=False)
        logging.debug(u"{:s}.init_tagcache('{:s}') : Successfully opened up the netnode \"{:s}\" for the tag cache and using the identifier ({:#x}) to reference it.".format('.'.join([__name__, cls.__name__]), internal.utils.string.escape(idp_modname, '\''), internal.utils.string.escape(cls.__node__, '"'), res))

    @classmethod
    def __nw_init_tagcache__(cls, nw_code, is_old_database):
        idp_modname = idaapi.get_idp_name()
        return cls.__init_tagcache__(idp_modname)

    @classmethod
    def node(cls, cached=True):
        '''Fetch the netnode containing the tag-cache which should be named "$ tagcache".

        If `cached` is changed to False, then always update the node's identifier.
        '''
        if cached and hasattr(cls, '__cache_id__'):
            return cls.__cache_id__

        # Explicitly try to fetch the netnode containing the tag-cache. If we were
        # unable to find it, then create it and use that instead.
        node = internal.netnode.get(cls.__node__)
        if node == idaapi.BADADDR:
            node = internal.netnode.new(cls.__node__)

        # Cache the identifier for the netnode inside a class attribute
        cls.__cache_id__ = node
        return node

class contents(tagging):
    '''Tagging for an address within a function (contents)'''
    """
    This namespace is used to update the tag state for any content tags
    associated with a function in the database. The address for the top
    of the function represents a key within the netnode that is used to
    fetch the blob and the supval which contains a marshall'd dictionary
    and a marshall'd set. These are stored within the `tagging.node()`
    netnode withn the tag `contents.btag`.

    The marshall'd dictionary that is stored in the netnode's blob is
    used to retain a dictionary of reference counts for both the tag
    names and the addresses that they reside at. Anytime a tag is
    written or removed, the reference count for both the name and the
    address is adjusted.

    Due to a size limit of a blob, the supval for the tagging node is
    used to store the tag names that are used within a function as a
    marshall'd ``set``. This ``set`` is used to verify that the tag
    names within the contents of the function correspond with the
    reference count that is stored within the marshall'd dictionary
    in the blob.
    """

    ## for each function's content
    # netnode.blob[fn.start_ea, btag] = marshal.dumps({'name', 'address'})
    # netnode.sup[fn.start_ea] = marshal.dumps({tagnames})

    #btag = idaapi.stag         # XXX: apparently 'S' is used for comments
    btag = idaapi.atag

    @classmethod
    def _key(cls, ea):
        '''Converts the address `ea` to a key that's used to store contents data for the specified function.'''

        # First we'll need to verify that we're within a function,
        # then we can try and grab the chunk for the given address.
        res = idaapi.get_func(ea)
        if res is None:
            return None

        # Try and grab the function chunk for the given address.
        ch = idaapi.get_fchunk(ea)
        if ch is None:
            return None
        owner, bounds = map(internal.interface.range.bounds, [res, ch])

        # If we're a function tail, then there's a chance that the
        # owner of the function is owned by multiple functions.
        if ch.flags & idaapi.FUNC_TAIL:
            count, iterator = ch.refqty, idaapi.func_parent_iterator_t(ch)

            # Seek the iterator to its first position so we can grab each owner
            # for the chunk at the requested address. If we can't, then that's
            # okay because we can return the function unless the count is > 1.
            if not iterator.first():
                Flogging = logging.warning if count > 1 else logging.info
                Flogging(u"{:s}._key({:#x}) : Returning {:d} owner{:s}{:s} for the function tail at {!s} instead of {:d} due to being unable to seek with the initialized `{:s}`.".format('.'.join([__name__, cls.__name__]), ea, 1 if count else 0, '' if count else 's', " ({!s})".format(owner) if count else '', bounds, count, iterator.__class__.__name__))

                # Gather the single function into a list of items, and return
                # its starting address if our "refqty" is larger than 0.
                items = [owner] if count else []
                iterable = (ea for ea, _ in items)

            # Now we can grab the first parent address, and continue looping
            # while saving each parent that we get into our result list.
            else:
                items = [iterator.parent()]
                while iterator.next():
                    ea = iterator.parent()
                    items.append(ea)
                iterable = (ea for ea in items)

            # Last thing to do is to figure out whether we return a list,
            # a single address, or None if we didn't find anything.
            result = sorted(iterable)
            return result if len(result) > 1 else result[0] if result else None

        # Otherwise we can unpack our owner and return its start address.
        result, _ = owner
        return result

    @classmethod
    def _read_header(cls, target, ea):
        """Read the contents dictionary out of the supval belonging to the function at `target`.

        If `target` is ``None``, then use the address of the function containing `ea`.
        """
        node, key = tagging.node(), cls._key(ea) if target is None else target
        if key is None:
            raise internal.exceptions.FunctionNotFoundError(u"{:s}._read_header({!r}, {:#x}) : Unable to locate a function for target ({!r}) at {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, key, ea))

        # If our key was a list, then we need to warn the user that
        # we're going to take a guess on which function we'll return.
        elif isinstance(key, list):
            key, _ = key[0], logging.critical(u"{:s}._read_header({!r}, {:#x}) : Choosing to read header from function {:#x} for address {:#x} as it is owned by {:d} function{:s} ({:s}).".format('.'.join([__name__, cls.__name__]), target, ea, key[0], ea, len(key), '' if len(key) == 1 else 's', ', '.join(map("{:#x}".format, key))))

        view = internal.netnode.sup.get(node, key, type=memoryview)
        if view is None:
            return None
        encdata = view.tobytes()

        try:
            data, sz = cls.codec.decode(encdata)
            if len(encdata) != sz:
                raise internal.exceptions.SizeMismatchError(u"{:s}._read_header({!r}, {:#x}) : The number of bytes that was decoded did not match the expected size ({:#x}<>{:#x}).".format('.'.join([__name__, cls.__name__]), target, ea, sz, len(encdata)))
        except Exception as E:
            logging.warning(u"{:s}._read_header({!r}, {:#x}) : An exception {!r} was raised while trying to decode the cache header for address {:#x} from the sup cache associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, E, ea, key), exc_info=True)
            logging.info(u"{:s}._read_header({!r}, {:#x}) : Error occurred while decoding the following data from the sup cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, encdata))
            raise internal.exceptions.SerializationError(u"{:s}._read_header({!r}, {:#x}) : Unable to decode the cache header for address {:#x} from the sup cache associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, ea, key))

        try:
            result = cls.marshaller.loads(data)
        except Exception as E:
            logging.info(u"{:s}._read_header({!r}, {:#x}) : Error occurred while unmarshalling the following data from the sup cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, data))
            raise internal.exceptions.SerializationError(u"{:s}._read_header({!r}, {:#x}) : Unable to unmarshal the cache header for address {:#x} from the sup cache associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, ea, key))
        return result

    @classmethod
    def _write_header(cls, target, ea, value):
        """Write the specified `value` into the contents supval belonging to the supval of the function at `target`.

        If `target` is ``None`` then use `ea` to locate the function.
        If `value` is ``None``, then remove the supval at the specified `target`.
        """
        node, key = tagging.node(), cls._key(ea) if target is None else target
        if key is None:
            raise internal.exceptions.FunctionNotFoundError(u"{:s}._write_header({!r}, {:#x}, {!s}) : Unable to determine the key for target ({!r}) at {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), target, ea))

        # If our key was a list, then we raise an exception because
        # we'd likely overwrite an address with an unrelated header.
        elif isinstance(key, list):
            raise internal.exceptions.FunctionNotFoundError(u"{:s}._write_header({!r}, {:#x}, {!s}) : Unable to determine the owner of the address {:#x} as it is owned by {:d} function{:s} ({:s}).".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, len(key), '' if len(key) == 1 else 's', ', '.join(map("{:#x}".format, key))))

        # If our header is empty, then we just need to remove the supvalue
        if not value:
            return bool(internal.netnode.sup.remove(node, key))

        try:
            data = cls.marshaller.dumps(value)

        except Exception as E:
            logging.info(u"{:s}._write_header({!r}, {:#x}, {!s}) : Error occurred while marshalling the following data for the cache header: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), value))
            raise internal.exceptions.SerializationError(u"{:s}._write_header({!r}, {:#x}, {!s}) : Unable to marshal the cache header at address {:#x} for the sup cache associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, key))

        try:
            encdata, sz = cls.codec.encode(data)
            if sz != len(data):
                raise internal.exceptions.SizeMismatchError(u"{:s}._write_header({!r}, {:#x}, {!s}) : The number of bytes that was encoded did not match the expected size ({:#x}<>{:#x}).".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), sz, len(data)))

        except Exception as E:
            logging.warning(u"{:s}._write_header({!r}, {:#x}, {!s}) : An exception {!r} was raised while trying to encode the cache header at address {:#x} for the sup cache associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), E, ea, key), exc_info=True)
            logging.info(u"{:s}._write_header({!r}, {:#x}, {!s}) : Error encoding the following data for the cache header: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), data))
            raise internal.exceptions.SerializationError(u"{:s}._write_header({!r}, {:#x}, {!s}) : Unable to encode the contents at {:#x} for the sup cache associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, key))

        if len(encdata) > internal.netnode.sup.MAX_SIZE:
            logging.warning(u"{:s}._write_header({!r}, {:#x}, {!s}) : Reached tag limit size ({:#x}>{:#x}) in function with key {:#x}. Possible tag-cache corruption encountered.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), len(encdata), internal.netnode.sup.MAX_SIZE, key))

        ok = internal.netnode.sup.set(node, key, encdata)
        return bool(ok)

    @classmethod
    def _read(cls, target, ea):
        """Reads the value from the contents supval for the specific `target`.

        If `target` is undefined or ``None`` then use `ea` to locate the function.
        """
        node, key = tagging.node(), cls._key(ea) if target is None else target
        if key is None:
            raise internal.exceptions.FunctionNotFoundError(u"{:s}._read({!r}, {:#x}) : Unable to determine the key for the target ({!r}) at {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, target, ea))

        # If we received a list as the key, then we need to warn the
        # user that we have to guess which supval to read from.
        elif isinstance(key, list):
            key, _ = key[0], logging.critical(u"{:s}._read({!r}, {:#x}) : Choosing to read cache from function {:#x} for address {:#x} as it is owned by {:d} function{:s} ({:s}).".format('.'.join([__name__, cls.__name__]), target, ea, key[0], ea, len(key), '' if len(key) == 1 else 's', ', '.join(map("{:#x}".format, key))))

        encdata = internal.netnode.blob.get(key, cls.btag)
        if encdata is None:
            return None

        try:
            data, sz = cls.codec.decode(encdata)
            if len(encdata) != sz:
                raise internal.exceptions.SizeMismatchError(u"{:s}._read({!r}, {:#x}) : The number of bytes that was decoded did not match the expected size ({:#x}<>{:#x}).".format('.'.join([__name__, cls.__name__]), target, ea, sz, len(encdata)))

        except Exception as E:
            logging.warning(u"{:s}._read({!r}, {:#x}) : An exception {!r} was raised while trying to decode the contents for address {:#x} from the blob cache ({!s}) associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, E, ea, cls.btag, key), exc_info=True)
            logging.info(u"{:s}._read({!r}, {:#x}) : Error while decoding the following data from the blob cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, encdata))
            raise internal.exceptions.SerializationError(u"{:s}._read({!r}, {:#x}) : Unable to decode the contents for address {:#x} from the blob cache ({!s}) associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, ea, cls.btag, key))

        try:
            result = cls.marshaller.loads(data)

        except Exception as E:
            logging.info(u"{:s}._read({!r}, {:#x}) : Error while unmarshalling the following data from the blob cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, data))
            raise internal.exceptions.SerializationError(u"{:s}._read({!r}, {:#x}) : Unable to unmarshal the contents for address {:#x} from the blob cache ({!s}) associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, ea, cls.btag, key))
        return result

    @classmethod
    def _write(cls, target, ea, value):
        """Writes a `value` to the contents supval for the specific `target`.

        If `target` is undefined or ``None`` then use `ea` to locate the function.
        If `value` is ``None``, then erase the value from the supval.
        """
        node, key = tagging.node(), cls._key(ea) if target is None else target
        if key is None:
            raise internal.exceptions.FunctionNotFoundError(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to determine the key for target ({!r}) at {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), target, ea))

        # If our key was a list, then we raise an exception instead
        # of just choosing something at random to overwrite.
        elif isinstance(key, list):
            raise internal.exceptions.FunctionNotFoundError(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to determine the owner of the address {:#x} as it is owned by {:d} function{:s} ({:s}).".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, len(key), '' if len(key) == 1 else 's', ', '.join(map("{:#x}".format, key))))

        # erase cache and blob if no data is specified
        if not value:
            try:
                ok = cls._write_header(target, ea, None)
                if not ok:
                    logging.debug(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to remove the address {:#x} from the cache header associated with the key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, key))

            finally:
                count = internal.netnode.blob.remove(key, cls.btag)
                logging.debug(u"{:s}._write({!r}, {:#x}, {!s}) : Removed {:d} blob{:s} ({!s}) associated with the key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), count, '' if count == 1 else 's', cls.btag, key))

            return True

        # update blob for given address
        res = value
        try:
            data = cls.marshaller.dumps(res)

        except Exception as E:
            logging.info(u"{:s}._write({!r}, {:#x}, {!s}) : Error while unmarshalling the following data for the blob cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), res))
            raise internal.exceptions.SerializationError(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to marshal the contents at address {:#x} for the blob cache ({!s}) associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, cls.btag, key))

        try:
            encdata, sz = cls.codec.encode(data)

        except Exception as E:
            logging.info(u"{:s}._write({!r}, {:#x}, {!s}) : Error encoding the following data for the blob cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), data))
            raise internal.exceptions.SerializationError(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to encode the contents at address {:#x} for the blob cache ({!s}) associated with key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, cls.btag, key))

        if sz != len(data):
            raise internal.exceptions.SizeMismatchError(u"{:s}._write({!r}, {:#x}, {!s}) : The number of bytes that was encoded did not match the expected size ({:#x}<>{:#x}).".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), sz, len(data)))

        # write blob
        ok = internal.netnode.blob.set(key, cls.btag, encdata)
        if not ok:
            logging.info(u"{:s}._write({!r}, {:#x}, {!s}) : Error while writing the following data to the blob cache: {!r}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), encdata))
            raise internal.exceptions.DisassemblerError(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to write the contents for address {:#x} to the blob cache ({!s}) associated with the key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, cls.btag, key))

        # update sup cache with keys
        res = {item for item in value.keys()}
        ok = cls._write_header(target, ea, res)
        if not ok:
            raise internal.exceptions.DisassemblerError(u"{:s}._write({!r}, {:#x}, {!s}) : Unable to write the cache header for address {:#x} associated with the key {:#x}.".format('.'.join([__name__, cls.__name__]), target, ea, internal.utils.string.repr(value), ea, key))
        return ok

    @classmethod
    def iterate(cls):
        '''Yield each address and names for all of the contents tags in the database according to what is written into the tagging supval.'''
        node = tagging.node()
        for ea in internal.netnode.sup.fiter(node):
            view = internal.netnode.sup.get(node, ea, type=memoryview)
            encdata = view.tobytes()
            data, sz = cls.codec.decode(encdata)
            if len(encdata) != sz:
                logging.warning(u"{:s}.iterate() : Error while decoding the tag names out of the sup cache for address {:#x} due to the length of encoded data not matching the expected size ({:#x}<>{:#x}).".format('.'.join([__name__, cls.__name__]), ea, len(encdata), sz))
            res = cls.marshaller.loads(data)
            yield ea, res
        return

    @classmethod
    def inc(cls, address, name, **target):
        """Increase the ref count for the given `address` and `name` belonging to the function `target`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        # If we weren't given a target, then we need to figure the key out ourselves.
        if target.get('target', None) is None:
            res = cls._key(address)
            keys = res if isinstance(res, list) else [res]

        # If we were given a valid target, then turn it into a list unless it already is.
        else:
            keys = target['target'] if isinstance(target['target'], list) else [target['target']]

        # Now we just iterate through all of the keys and update the cache.
        result = 0
        for key in keys:
            item = cls._read(key, address) or {}
            state, cache = item.get(cls.__tags__, {}), item.get(cls.__address__, {})

            # Update the reference count for the items we were given.
            state[name] = refs = state.get(name, 0) + 1
            cache[address] = cache.get(address, 0) + 1

            # Figure out whether we're removing the entry for the tags or adding it.
            if state: item[cls.__tags__] = state
            else: del item[cls.__tags__]

            # Now do the exact same thing for the address.
            if cache: item[cls.__address__] = cache
            else: del item[cls.__address__]

            # Now we can write that shit back into the cache.
            _, result = cls._write(key, address, item), result + refs
        return result

    @classmethod
    def dec(cls, address, name, **target):
        """Decreate the ref count for the given `address` and `name` belonging to the function `target`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        # If we were asked to figure the target out ourselves, then do as we're told.
        if target.get('target', None) is None:
            res = cls._key(address)
            keys = res if isinstance(res, list) else [res]

        # Otherwise turn what we were given into a list unless it already was.
        else:
            keys = target['target'] if isinstance(target['target'], list) else [target['target']]

        # Now we can just iterate through all of the keys to update each cache.
        result = 0
        for key in keys:
            item = cls._read(key, address) or {}
            state, cache = item.get(cls.__tags__, {}), item.get(cls.__address__, {})

            # Pop the number of references and the count of addresses and adjust
            # them. We pop them because if the reference count drops below its
            # minimum, then we remove the tag so that we can detect when the
            # index has been decremented past what's available.
            refs, count = state.pop(name, 0) - 1, cache.pop(address, 0) - 1

            # If we still have some references for the names and the addresses,
            # then add our keys back into the state and cache.
            if refs > 0: state[name] = refs
            if count > 0: cache[address] = count

            # Figure out whether we're removing the names or keeping them.
            if state: item[cls.__tags__] = state
            else: item.pop(cls.__tags__, None)

            # We do the exact same thing for the address reference count.
            if cache: item[cls.__address__] = cache
            else: item.pop(cls.__address__, None)

            # We can finally write our reference counts back to the current key.
            _, result = cls._write(key, address, item), result + refs
        return result

    @classmethod
    def name(cls, address, **target):
        """Return all the tag names (``set``) for the contents of the function `target`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        key = target.get('target', None)
        res = cls._read(key, address) or {}
        res = res.get(cls.__tags__, {})
        return {item for item in res.keys()}

    @classmethod
    def counts(cls, address, **target):
        """Yield each tag name and its count for the contents of the function `target`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        key = target.get('target', None)
        items = cls._read(key, address) or {}
        for tag, count in items.get(cls.__tags__, {}).items():
            yield tag, count
        return

    @classmethod
    def address(cls, address, **target):
        """Return all the addresses (``sorted``) with tags in the contents for the function `target`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        key = target.get('target', None)
        res = cls._read(key, address) or {}
        res = res.get(cls.__address__, {})
        return sorted(res.keys())

    @classmethod
    def set_name(cls, address, name, count, **target):
        """Set the contents tag count for the function `target` and `name` to `count`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        key = target.get('target', None)
        state = cls._read(key, address) or {}

        res = state.get(cls.__tags__, {})
        if count > 0:
            res[name] = count
        else:
            res.pop(name, None)

        if res:
            state[cls.__tags__] = res
        else:
            state.pop(cls.__tags__, None)

        try:
            ok = cls._write(key, address, state)
            if ok:
                return state
        except Exception as E:
            logging.warning(u"{:s}.set_name({:#x}, {!r}, {:d}{:s}) : An exception {!r} was raised while trying to update the name cache for address {:#x}.".format('.'.join([__name__, cls.__name__]), address, name, count, ', {:s}'.format(internal.utils.string.kwargs(target)) if target else '', E, address), exc_info=True)
        raise internal.exceptions.ReadOrWriteError(u"{:s}.set_name({:#x}, {!r}, {:d}{:s}) : Unable to update the name cache for address {:#x}.".format('.'.join([__name__, cls.__name__]), address, name, count, ', {:s}'.format(internal.utils.string.kwargs(target)) if target else '', address))

    @classmethod
    def set_address(cls, address, count, **target):
        """Set the contents tag count for the function `target` and `address` to `count`.

        If `target` is undefined or ``None`` then use `address` to locate the function.
        """
        key = target.get('target', None)
        state = cls._read(key, address) or {}

        res = state.get(cls.__address__, {})
        if count > 0:
            res[address] = count
        else:
            res.pop(address, None)

        if res:
            state[cls.__address__] = res
        else:
            state.pop(cls.__address__, None)

        try:
            ok = cls._write(key, address, state)
            if ok:
                return state
        except Exception as E:
            logging.warning(u"{:s}.set_address({:#x}, {:d}{:s}) : An exception {!r} was raised while trying to update the cache for address {:#x}.".format('.'.join([__name__, cls.__name__]), address, count, ', {:s}'.format(internal.utils.string.kwargs(target)) if target else '', E, address), exc_info=True)
        raise internal.exceptions.ReadOrWriteError(u"{:s}.set_address({:#x}, {:d}{:s}) : Unable to write to the cache for address {:#x}.".format('.'.join([__name__, cls.__name__]), address, count, ', {:s}'.format(internal.utils.string.kwargs(target)) if target else '', address))

class globals(tagging):
    """
    This namespace is used to update the tag state for all the globals in
    the database. Each global tag has its target address and its name and
    is managed by keeping track of a reference count.

    The reference count is stored within a netnode as defined by
    `tagging.node()`. The refcount for each address containing a
    tag is stored in an altval keyed by the address. The refcount
    for each tag name is stored in a hashval keyed by the tags
    name.
    """

    ## FIXME: for each global/function
    # netnode.alt[address] = refcount
    # netnode.hash[name] = refcount

    @classmethod
    def inc(cls, address, name):
        '''Increase the global tag count for the given `address` and `name`.'''
        node, eName = tagging.node(), internal.utils.string.to(name)

        cName = (internal.netnode.hash.get(node, eName, type=int) or 0) + 1
        cAddress = (internal.netnode.alt.get(node, address) or 0) + 1

        internal.netnode.hash.set(node, eName, cName)
        internal.netnode.alt.set(node, address, cAddress)

        return cName

    @classmethod
    def dec(cls, address, name):
        '''Decrease the global tag count for the given `address` and `name`.'''
        node, eName = tagging.node(), internal.utils.string.to(name)

        cName = (internal.netnode.hash.get(node, eName, type=int) or 1) - 1
        cAddress = (internal.netnode.alt.get(node, address) or 1) - 1

        if cName < 1:
            internal.netnode.hash.remove(node, eName)
        else:
            internal.netnode.hash.set(node, eName, cName)

        if cAddress < 1:
            internal.netnode.alt.remove(node, address)
        else:
            internal.netnode.alt.set(node, address, cAddress)

        return cName

    @classmethod
    def name(cls):
        '''Return all the tag names (``set``) in the specified database (globals and func-tags)'''
        node = tagging.node()
        return { internal.utils.string.of(name) for name in internal.netnode.hash.fiter(node) }

    @classmethod
    def address(cls):
        '''Return all the tag addresses (``sorted``) in the specified database (globals and func-tags)'''
        return sorted(ea for ea in internal.netnode.alt.fiter(tagging.node()))

    @classmethod
    def set_name(cls, name, count):
        '''Set the global tag count for `name` in the database to `count`.'''
        node, eName = tagging.node(), internal.utils.string.to(name)
        res = internal.netnode.hash.get(node, eName, type=int)
        internal.netnode.hash.set(node, eName, count)
        return res

    @classmethod
    def set_address(cls, address, count):
        '''Set the global tag count for `address` in the database to `count`.'''
        node = tagging.node()
        res = internal.netnode.alt.get(node, address)
        internal.netnode.alt.set(node, address, count)
        return res

    @classmethod
    def iterate(cls):
        '''Yield the address and count for each of the globals in the database according to what is written in the altvals.'''
        node = tagging.node()
        for ea, count in internal.netnode.alt.fitems(node):
            yield ea, count
        return

    @classmethod
    def counts(cls):
        '''Yield the tag name and its count for each of the globals in the database according to what is written in the hashvals.'''
        node = tagging.node()

        for item, count in internal.netnode.hash.fitems(node, int):
            string = internal.utils.string.of(item)
            yield string, count
        return

```

`base/_declaration.py`:

```py
"""
Declaration module (internal)

This module contains some tools used for extracting information out of
function and type declarations.

TODO: Implement parsers for some of the C++ symbol manglers in order to
      query them for specific attributes or type information.
"""

import internal, idaapi
import string as _string

### c declaration stuff
def function(ea):
    '''Returns the C function declaration at the address `ea`.'''
    res = idaapi.idc_get_type(ea)
    if res is None:
        raise internal.exceptions.MissingTypeOrAttribute(u"The function {:x} does not have a declaration.".format(ea))
    return res

def arguments(ea):
    '''Returns an array of all of the arguments within the prototype of the function at `ea`.'''
    decl = function(ea)
    args = decl[ decl.index('(') + 1 : decl.rindex(')') ]
    return [ arg.strip() for arg in args.split(',')]

def size(string):
    '''Returns the size of a type described by a C declaration in `string`.'''
    til = idaapi.cvar.idati if idaapi.__version__ < 7.0 else idaapi.get_idati()

    string = string.strip()
    if string.lower() == 'void':
        return 0
    elif string.startswith('class') and string.endswith('&'):
        res = idaapi.idc_parse_decl(til, 'void*;', 0)
    else:
        semicoloned = string if string.endswith(';') else "{:s};".format(string)
        res = idaapi.idc_parse_decl(til, internal.utils.string.to(semicoloned), 0)

    if res is None:
        raise internal.exceptions.DisassemblerError(u"Unable to parse the specified C declaration (\"{:s}\").".format(internal.utils.string.escape(string, '"')))
    _, type, _ = res
    f = idaapi.get_type_size0 if idaapi.__version__ < 6.8 else idaapi.calc_type_size
    return f(til, type)

@internal.utils.string.decorate_arguments('string')
def demangle(string):
    '''Given a mangled C++ `string`, demangle it back into a human-readable symbol.'''
    if idaapi.__version__ < 7.0:
        res = idaapi.demangle_name(internal.utils.string.to(string), idaapi.cvar.inf.long_demnames)
    else:
        res = idaapi.demangle_name(internal.utils.string.to(string), idaapi.cvar.inf.long_demnames, idaapi.DQT_FULL)
    return string if res is None else internal.utils.string.of(res)

def mangledQ(string):
    '''Return true if the provided `string` has been mangled.'''
    return any(string.startswith(item) for item in ['?', '__'])

@internal.utils.string.decorate_arguments('info')
def parse(info):
    '''Parse the string `info` into an ``idaapi.tinfo_t``.'''
    if idaapi.__version__ < 7.0:
        til, ti = idaapi.cvar.idati, idaapi.tinfo_t(),
    else:
        til, ti = idaapi.get_idati(), idaapi.tinfo_t(),

    # Convert info to a string if it's a tinfo_t
    info_s = "{!s}".format(info) if isinstance(info, idaapi.tinfo_t) else info

    # Firstly we need to ';'-terminate the type the user provided in order
    # for IDA's parser to understand it.
    terminated = info_s if info_s.endswith(';') else "{:s};".format(info_s)

    # Ask IDA to parse this into a tinfo_t for us. We pass the silent flag so
    # that we're responsible for raising an exception if there's a parsing
    # error of some sort. If it succeeds, then we can return our typeinfo.
    # Otherwise we return None because of the inability to parse it.
    if idaapi.__version__ < 6.9:
        return None if idaapi.parse_decl2(til, terminated, None, ti, idaapi.PT_SIL) is None else ti
    elif idaapi.__version__ < 7.0:
        return None if idaapi.parse_decl2(til, terminated, ti, idaapi.PT_SIL) is None else ti
    return None if idaapi.parse_decl(ti, til, terminated, idaapi.PT_SIL) is None else ti

def string(ti):
    prefix = ''
    name, indent = '', 4
    cmt, cindent = '', 4
    flags = idaapi.PRTYPE_DEF | idaapi.PRTYPE_MULTI
    return idaapi.print_tinfo(prefix, indent, cindent, flags, ti, name, cmt)

def unmangle_name(name):
    '''Return the function name from a prototype to be used for rendered an ``idaapi.tino_t``.'''

    # Check to see if our name is demangled. If not, then we can just return it.
    demangled = demangle(name)
    if not name or demangled == name:
        return demangled

    # If so, then we need to do some trickery to extract the name.
    has_parameters = any(item in demangled for item in '()')
    noparameters = demangled[:demangled.find('(')] if has_parameters else demangled

    # Strip out all templates
    notemplates, count = '', 0
    for item in noparameters:
        if item in '<>':
            count += +1 if item in '<' else -1
        elif count == 0:
            notemplates += item
        continue

    # Now we need to remove the calling convention as it should be in the typeinfo.
    items = notemplates.split(' ')
    conventions = {'__cdecl', '__stdcall', '__fastcall', '__thiscall', '__pascal', '__usercall', '__userpurge'}
    try:
        ccindex = next(idx for idx, item in enumerate(items) if any(item.endswith(cc) for cc in conventions))
        items = items[1 + ccindex:]

    # We couldn't find a calling convention, so there's no real work to do.
    except StopIteration:
        items = items[:]

    # Strip out any backticked components, operators, and other weirdness.
    foperatorQ = lambda string: string.startswith('operator') and any(string.endswith(invalid) for invalid in _string.punctuation)
    joined = ' '.join(items)
    if '::' in joined:
        components = joined.split('::')
        components = (item for item in components if not item.startswith('`'))
        components = ('operator' if foperatorQ(item) else item for item in components)
        joined = '::'.join(components)

    # Check to see if this is some operator of some kind.
    if joined.count(' ') > 0 and joined.rsplit(' ', 2)[-2].endswith('operator'):
        return '_'.join(joined.rsplit(' ', 2)[-2:])

    # Now we can drop everything before the last space, and then return it.
    return joined.rsplit(' ', 1)[-1]

def unmangle_arguments(ea, info):
    if not info.present():
        raise ValueError(info)

    # Grab the parameters from the idc type as it includes more information
    parameters = extract.arguments("{!s}".format(idaapi.idc_get_type(ea))) or extract.arguments("{!s}".format(info))
    param_s = parameters.lstrip('(').rstrip(')')

    index, indices, iterable = 0, [], ((idx, item) for idx, item in enumerate(param_s))
    for argi in range(info.get_nargs()):
        arg = info.get_nth_arg(argi)
        arg_s = "{!s}".format(arg)

        index, ch = next(iterable, (1 + index, ','))
        while ch in ' ':
            index, ch = next(iterable)

        while ch != ',':
            for item in arg_s:
                index, ch = next(iterable)
                if ch != item: break

            count = 0
            while ch != ',' or count > 0:
                index, ch = next(iterable, (1 + index, ','))
                if ch in '()':
                    count += -1 if ch in ')' else +1
                continue

            indices.append(index)

    pos, res = 0, []
    for argi, index in enumerate(indices):
        arg = info.get_nth_arg(argi)
        arg_s = "{!s}".format(arg)

        item = param_s[pos : index].strip()
        pos = 1 + index

        t, name = item[:len(arg_s)], item[len(arg_s):]
        res.append((t.strip(), name.strip()))
    return res

## examples to test below code with
#"??_U@YAPAXI@Z"
#"?_BADOFF_func@std@@YAABJXZ"
#"??$_Div@N@?$_Complex_base@NU_C_double_complex@@@std@@IAEXABV?$complex@N@1@@Z"
#"??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z"
#"??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ"
#"??_F?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ"
#"??1type_info@@UAE@XZ"
#"sub_784B543B"
#"?_Atexit@@YAXP6AXXZ@Z"
#"?__ArrayUnwind@@YGXPAXIHP6EX0@Z@Z"

# FIXME: this code is so hacky, that i need unit-tests for it...which should be properly fixed.
#        1] If I write a parser, I can easily split out these components. (proper fix)
#        2] If I use IDA's metadata to figure out each type, I can use those strings to cull them out of the declaration. (hackish)
#        3] I could use completely unmaintainable nfa-based pattern matching. (regexes whee)
#        4] I could continue to use string operations to cut parts out...except that they're unable to solve this problem
#           due to the need to keep a recursive state somewhere in order to associate types with. (current)
class extract:
    @staticmethod
    def declaration(string):
        return demangle(string)

    @staticmethod
    def convention(string):
        types = {'__cdecl', '__stdcall', '__thiscall', '__fastcall'}
        res = string.split(' ')
        return res[0]

    @staticmethod
    def fullname(string):
        decl = extract.declaration(string)
        return decl[:decl.find('(')].split(' ', 3)[-1] if any(item in decl for item in ['(', ' ']) else decl

    @staticmethod
    def name(string):
        fn = extract.fullname(string)
        return fn.rsplit(':', 2)[-1] if ':' in fn else fn

    @staticmethod
    def arguments(string):
        res, count = '', 0
        for item in string[::-1]:
            if item in '()':
                count += +1 if item in ')' else -1
                res += item
            elif count > 0:
                res += item
            elif count == 0:
                break
            continue
        return str().join(reversed(res))

    @staticmethod
    def result(string):
        decl = extract.declaration(string)
        decl = decl[:decl.find('(')].rsplit(' ', 1)[0]
        return decl.split(':', 1)[1].strip() if ':' in decl else decl.strip()

    @staticmethod
    def scope(string):
        decl = extract.declaration(string)
        decl = decl[:decl.find('(')].rsplit(' ', 1)[0]
        return decl.split(':', 1)[0].strip() if ':' in decl else ''

```

`base/_exceptions.py`:

```py
import sys, builtins as E

class UnicodeException(E.BaseException):
    """
    A base exception that handles converting a unicode message
    into its UTF-8 form so that it can be emitted using Python's
    standard console.

    Copied from Python 2.7.15 implementation.
    """
    # tp_init
    def __init__(self, *args):
        self.__args__ = args
        self.__message__ = args[0] if len(args) == 1 else ''

    # Python2 can be emitted in more than one way which requires us
    # to implement both the Exception.__str__ and Exception.__unicode__
    # methods. If returning a regular string (bytes), then we need to
    # utf-8 encode the result because IDA's console will automatically
    # decode it.
    if sys.version_info.major < 3:

        # tp_str
        def __str__(self):
            length = len(self.args)
            if length == 0:
                return ""
            elif length == 1:
                item = self.args[0]
                return str(item.encode('utf8') if isinstance(item, unicode) else item)
            return str(self.args)

        def __unicode__(self):
            # return unicode(self.__str__())
            length = len(self.args)
            if length == 0:
                return u""
            elif length == 1:
                return unicode(self.args[0])
            return unicode(self.args)

    # Python3 really only requires us to implement this method when
    # emitting an exception. This is the same as a unicode type, so
    # we should be okay with casting the exception's arguments.
    else:

        # tp_str
        def __str__(self):
            length = len(self.args)
            if length == 0:
                return ""
            elif length == 1:
                item = self.args[0]
                return str(item)
            return str(self.args)

    # tp_repr
    def __repr__(self):
        repr_suffix = repr(self.args)
        name = type(self).__name__
        dot = name.rfind('.')
        shortname = name[1 + dot:] if dot > -1 else name
        return shortname + repr_suffix

    # tp_as_sequence
    def __iter__(self):
        for item in self.args:
            yield item
        return

    # tp_as_sequence
    def __getitem__(self, index):
        return self.args[index]
    def __getslice__(self, *indices):
        res = slice(*indices)
        return self.args[res]

    # tp_getset
    @property
    def message(self):
        return self.__message__
    @message.setter
    def message(self, message):
        # self.__message__ = "{!s}".format(message)
        self.__message__ = message
    @property
    def args(self):
        return self.__args__
    @args.setter
    def args(self, args):
        self.__args__ = tuple(item for item in args)

    # tp_methods
    def __reduce__(self):
        return self.args
    def __setstate__(self, pack):
        self.args = pack

class MissingTagError(UnicodeException, E.KeyError):
    """
    The requested tag at the specified address does not exist.
    """

class MissingFunctionTagError(MissingTagError):
    """
    The requested tag for the specified function does not exist.
    """

class MissingMethodError(UnicodeException, E.NotImplementedError):
    """
    A method belonging to a superclass that is required to be overloaded was called.
    """

class MissingNameError(UnicodeException, E.NameError):
    """
    A name that was required was found missing and was unable to be recovered.
    """

class UnsupportedVersion(UnicodeException, E.NotImplementedError):
    """
    This functionality is not supported on the current version of IDA.
    """

class UnsupportedCapability(UnicodeException, E.NotImplementedError, E.EnvironmentError):
    """
    An unexpected or unsupported capability was specified.
    """

class ResultMissingError(UnicodeException, E.LookupError):
    """
    The requested item is missing from its results.
    """

class SearchResultsError(ResultMissingError):
    """
    No results were found.
    """

class DisassemblerError(UnicodeException, E.EnvironmentError):
    """
    An api call has thrown an error or was unsuccessful.
    """

class MissingTypeOrAttribute(UnicodeException, E.TypeError):
    """
    The specified location is missing some specific attribute or type.
    """

class InvalidTypeOrValueError(UnicodeException, E.TypeError, E.ValueError):
    """
    An invalid value or type was specified.
    """

class InvalidParameterError(InvalidTypeOrValueError, E.AssertionError):
    """
    An invalid parameter was specified by the user.
    """

class OutOfBoundsError(UnicodeException, E.ValueError):
    """
    The specified item is out of bounds.
    """

class AddressOutOfBoundsError(OutOfBoundsError, E.ArithmeticError):
    """
    The specified address is out of bounds.
    """

class IndexOutOfBoundsError(OutOfBoundsError, E.IndexError, E.KeyError):
    """
    The specified index is out of bounds.
    """

class ItemNotFoundError(ResultMissingError, E.KeyError):
    """
    The specified item or type was not found.
    """

class FunctionNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified function.
    """

class AddressNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified address.
    """

class SegmentNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified segment.
    """

class StructureNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified structure.
    """

class EnumerationNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified enumeration.
    """

class MemberNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified structure or enumeration member.
    """

class RegisterNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified register.
    """

class NetNodeNotFoundError(ItemNotFoundError):
    """
    Unable to locate the specified netnode.
    """

class ReadOrWriteError(UnicodeException, E.IOError, E.ValueError):
    """
    Unable to read or write the specified number of bytes .
    """

class InvalidFormatError(UnicodeException, E.KeyError, E.ValueError):
    """
    The specified data has an invalid format.
    """

class SerializationError(UnicodeException, E.ValueError, E.IOError):
    """
    There was an error while trying to serialize or deserialize the specified data.
    """

class SizeMismatchError(SerializationError):
    """
    There was an error while trying to serialize or deserialize the specified data due to its size not matching.
    """

class UnknownPrototypeError(UnicodeException, E.LookupError):
    """
    The requested prototype does not match any of the ones that are available.
    """

class DuplicateItemError(UnicodeException, E.NameError):
    """
    The requested command has failed due to a duplicate item.
    """

#structure:742 and previous to it should output the module name, classname, and method
#comment:334 should catch whatever tree.find raises
#comment:100 (this needs some kind of error when the symbol or token component is not found)
#interface:283, interface:302, interface:620, interface:640 (this should be a NameError)

```

`base/_interface.py`:

```py
"""
Interface module (internal)

This module wraps a number of features provided by IDA so that it can be
dumbed down a bit. This module is used internally and thus doesn't provide
anything that a user should use. Nonetheless, we document this for curious
individuals to attempt to understand this craziness.
"""

import six, builtins
import sys, logging, contextlib
import functools, operator, itertools, types
import collections, heapq, traceback, ctypes, math
import unicodedata as _unicodedata, string as _string, array as _array

import idaapi, internal

class typemap(object):
    """
    This namespace provides bidirectional conversion from IDA's types
    to something more pythonic. This namespace is actually pretty
    magical in that it dumbs down IDA's types for humans without
    needing a reference.

    Normally IDA defines types as flags and enumerations which require
    a user to know the correct ones in order to infer information about
    it. Although they can still do this, it's a lot more reasonable if
    we convert them into some weird python-like syntax.

    The syntax for types is fairly straight forward if one is familiar
    with the names that python exposes. Essentially the base type is
    a tuple of the format `(type, size)`. If `size` is not specified,
    then the size will be assumed to be the default word size for the
    current database. The `type` field is then any one of the python
    types such as ``int``, ``str``, ``chr``, ``float``, ``type``, or
    ``None``.

    These types have the following meanings:

        ``int`` or ``long`` - an integral
        ``chr`` - a character that is part of a string
        ``str`` - a type of string of a specific character width
        ``float`` - a floating point number
        ``type`` - a reference (pointer)
        ``None`` - alignment

    This can result in the describing of an IDA type and its size
    using a much simpler interface. Some examples can be:

        `int` - An integer with the default size
        `(int, 2)` - a 16-bit integer
        `(type, 4)` - a 32-bit referece (pointer)
        `(float, 4)` - a 16-bit floating point (ieee754 single)
        `(None, 16)` - aligned to 16 bytes
        `(str, 2)` - a 16-bit null-terminated string
        `(str, 4)` - a 32-bit null-terminated string
        `(str, 1, 4)` - an 8-bit character string with a 32-bit length prefix.
        `(str, 2, 2)` - an 16-bit character string with a 16-bit length prefix.
        `(str, 1, 0)` - an 8-bit character null-terminated string

    If an array needs to be represented, then one can simply wrap
    their type within a list. A few examples of this follows:

        `[int, 4]` - a 4 element array of default sized integers
        `[str, 9]` - an 8-bit string of 9 characters
        `[(int, 2), 3]` - a 3 element array of 16-bit integers
        `[(float, 8), 4]` - a 4 element array of 64-bit floating point numbers.
        `[type, 6]` - a 6 element array of references (pointers)
        `[(chr, 2), 7]` - a 7-element string of 16-bit characters
        `[str, 7]` - a 10-element string of 8-bit characters
        `[(str, 4), 2]` - a 2-element string of 32-bit characters

    These types are commonly associated with members of structures
    and thus can be used to quickly read or apply a type to a
    field within a structure.
    """
    MS_0TYPE, MS_1TYPE = idaapi.MS_0TYPE, idaapi.MS_1TYPE
    FF_MASKSIZE = idaapi.as_uint32(idaapi.DT_TYPE)  # Mask that select's the flag's size
    FF_MASK = FF_MASKSIZE | MS_0TYPE | MS_1TYPE     # Mask that select's the flag's repr

    # FIXME: Figure out how to update this to use/create an idaapi.tinfo_t()
    #        and also still remain backwards-compatible with the older idaapi.opinfo_t()

    ## IDA 6.95 types
    if idaapi.__version__ < 7.0:
        integermap = {
            (int,  1):(idaapi.byteflag(), -1), (int, 2):(idaapi.wordflag(), -1), (int,  3):(idaapi.tribyteflag(), -1),
            (int,  4):(idaapi.dwrdflag(), -1), (int, 8):(idaapi.qwrdflag(), -1), (int, 10):(idaapi.tbytflag(), -1),
            (int, 16):(idaapi.owrdflag(), -1),
        }
        if hasattr(idaapi, 'ywrdflag'):
            integermap[int, 32] = getattr(idaapi, 'ywrdflag')(), -1

        decimalmap = {
            (float,  4):(idaapi.floatflag(), -1),     (float, 8):(idaapi.doubleflag(), -1),
            (float, 10):(idaapi.packrealflag(), -1), (float, 12):(idaapi.packrealflag(), -1),
        }

        # we support either chr or str interchangeably
        stringmap = {
            chr:(idaapi.asciflag(), idaapi.ASCSTR_TERMCHR),
            str:(idaapi.asciflag(), idaapi.ASCSTR_TERMCHR),

            # null-terminated, char_t and wchar_t
            (str, 1): (idaapi.asciflag(), idaapi.ASCSTR_TERMCHR),
            (str, 2): (idaapi.asciflag(), idaapi.ASCSTR_UNICODE),

            (chr, 1): (idaapi.asciflag(), idaapi.ASCSTR_TERMCHR),
            (chr, 2): (idaapi.asciflag(), idaapi.ASCSTR_UNICODE),

            # variable-terminated, multiple-byte
            (str, 1, 0): (idaapi.asciflag(), idaapi.ASCSTR_TERMCHR),
            (str, 2, 0): (idaapi.asciflag(), idaapi.ASCSTR_UNICODE),
            (str, 1, 1): (idaapi.asciflag(), idaapi.ASCSTR_PASCAL),
            (str, 1, 2): (idaapi.asciflag(), idaapi.ASCSTR_LEN2),
            (str, 2, 2): (idaapi.asciflag(), idaapi.ASCSTR_ULEN2),
            (str, 2, 4): (idaapi.asciflag(), idaapi.ASCSTR_ULEN4),

            (chr, 1, 0): (idaapi.asciflag(), idaapi.ASCSTR_TERMCHR),
            (chr, 2, 0): (idaapi.asciflag(), idaapi.ASCSTR_UNICODE),
            (chr, 1, 1): (idaapi.asciflag(), idaapi.ASCSTR_PASCAL),
            (chr, 1, 2): (idaapi.asciflag(), idaapi.ASCSTR_LEN2),
            (chr, 2, 2): (idaapi.asciflag(), idaapi.ASCSTR_ULEN2),
            (chr, 2, 4): (idaapi.asciflag(), idaapi.ASCSTR_ULEN4),
        }

        if hasattr(builtins, 'unichr'):
            stringmap.setdefault(builtins.unichr, (idaapi.asciflag(), idaapi.ASCSTR_UNICODE))
        if hasattr(builtins, 'unicode'):
            stringmap.setdefault(builtins.unicode, (idaapi.asciflag(), idaapi.ASCSTR_UNICODE))

        ptrmap = { (type, sz) : (idaapi.offflag() | flg, 0) for (_, sz), (flg, _) in integermap.items() }
        nonemap = { None :(idaapi.alignflag(), -1) }

    ## IDA 7.0 types
    else:
        integermap = {
            (int,  1):(idaapi.byte_flag(), -1),  (int, 2):(idaapi.word_flag(), -1),
            (int,  4):(idaapi.dword_flag(), -1), (int, 8):(idaapi.qword_flag(), -1), (int, 10):(idaapi.tbyte_flag(), -1),
            (int, 16):(idaapi.oword_flag(), -1),
        }
        if hasattr(idaapi, 'yword_flag'):
            integermap[int, 32] = getattr(idaapi, 'yword_flag')(), -1

        decimalmap = {
            (float,  4):(idaapi.float_flag(), -1),    (float,  8):(idaapi.double_flag(), -1),
            (float, 10):(idaapi.packreal_flag(), -1), (float, 12):(idaapi.packreal_flag(), -1),
        }

        # we support either chr or str interchangeably
        stringmap = {
            chr:(idaapi.strlit_flag(), idaapi.STRTYPE_C),
            str:(idaapi.strlit_flag(), idaapi.STRTYPE_C),

            # null-terminated, multiple-byte
            (str, 1): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (str, 2): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (str, 4): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),

            (chr, 1): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (chr, 2): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (chr, 4): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),

            # variable-terminated, multiple-byte
            (str, 1, 0): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (str, 1, 1): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (str, 1, 2): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (str, 1, 4): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (str, 2, 0): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (str, 2, 1): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (str, 2, 2): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (str, 2, 4): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (str, 4, 0): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
            (str, 4, 1): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
            (str, 4, 2): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
            (str, 4, 4): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),

            (chr, 1, 0): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (chr, 1, 1): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (chr, 1, 2): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (chr, 1, 4): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_1B),
            (chr, 2, 0): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (chr, 2, 1): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (chr, 2, 2): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (chr, 2, 4): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_2B),
            (chr, 4, 0): (idaapi.strlit_flag(), idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
            (chr, 4, 1): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
            (chr, 4, 2): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
            (chr, 4, 4): (idaapi.strlit_flag(), idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT | idaapi.STRWIDTH_4B),
        }
        if hasattr(builtins, 'unichr'):
            stringmap.setdefault(builtins.unichr, (idaapi.strlit_flag(), idaapi.STRTYPE_C_16))
        if hasattr(builtins, 'unicode'):
            stringmap.setdefault(builtins.unicode, (idaapi.strlit_flag(), idaapi.STRTYPE_C_16))

        ptrmap = { (type, sz) : (idaapi.off_flag() | flg, 0) for (_, sz), (flg, _) in integermap.items() }
        nonemap = { None :(idaapi.align_flag(), -1) }

    # Generate the lookup table for looking up the correct tables for a given type.
    typemap = {
        int:integermap, float:decimalmap,
        str:stringmap, chr:stringmap,
        type:ptrmap, None:nonemap,
    }
    if hasattr(builtins, 'long'): typemap.setdefault(builtins.long, integermap)
    if hasattr(builtins, 'unicode'): typemap.setdefault(builtins.unicode, stringmap)
    if hasattr(builtins, 'unichr'): typemap.setdefault(builtins.unichr, stringmap)

    # Invert our lookup tables so that we can find the correct python types for
    # the IDAPython flags that are defined.
    inverted = {}
    for s, (f, _) in integermap.items():
        inverted[f & FF_MASKSIZE] = s
    for s, (f, _) in decimalmap.items():
        inverted[f & FF_MASKSIZE] = s
    for s, (f, _) in stringmap.items():
        if (next(iter(s)) if isinstance(s, tuple) else s) in {str}: # prioritize `str`
            inverted[f & FF_MASKSIZE, _] = s
        continue
    for s, (f, _) in nonemap.items():
        inverted[f & FF_MASKSIZE] = s

    # Add all the available flag types to support all available pointer types.
    for s, (f, _) in ptrmap.items():
        inverted[f & FF_MASK] = s
        inverted[f & FF_MASK & ~MS_0TYPE] = s
        inverted[f & FF_MASK & ~MS_1TYPE] = s
    del f

    # FIXME: this is a hack for dealing with structures that
    #        have the flag set but aren't actually structures..
    inverted[idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU] = (int, 1)

    # refinfo map for the sizes (IDA 6.9 uses the same names)
    refinfomap = {
        (type, 1) : idaapi.REF_OFF8,    (type, 2) : idaapi.REF_OFF16,
        (type, 4) : idaapi.REF_OFF32,   (type, 8) : idaapi.REF_OFF64,
    }

    # Assign the default values for the processor that was selected for the database.
    @classmethod
    def __newprc__(cls, pnum):
        info = idaapi.get_inf_structure()
        bits = 64 if info.is_64bit() else 32 if info.is_32bit() else None
        if bits is None: return

        typemap.integermap[None] = typemap.integermap[int, bits // 8]
        typemap.decimalmap[None] = typemap.decimalmap[float, bits // 8]
        typemap.ptrmap[None] = typemap.ptrmap[type, bits // 8]
        typemap.stringmap[None] = typemap.stringmap[str]

    @classmethod
    def __ev_newprc__(cls, pnum, keep_cfg):
        return cls.__newprc__(pnum)

    @classmethod
    def __nw_newprc__(cls, nw_code, is_old_database):
        pnum = idaapi.ph_get_id()
        return cls.__newprc__(pnum)

    @classmethod
    def dissolve(cls, flag, typeid, size, offset=None):
        '''Convert the specified `flag`, `typeid`, and `size` into a pythonic type at the optional `offset`.'''
        structure = sys.modules.get('structure', __import__('structure'))
        FF_STRUCT = idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU
        dtype, dsize = flag & cls.FF_MASK, flag & cls.FF_MASKSIZE
        sf = -1 if flag & idaapi.FF_SIGN == idaapi.FF_SIGN else +1

        # Check if the dtype's size field (dsize) is describing a structure and
        # verify that our type-id is an integer so that we know that we need to
        # figure out the structure's size. We also do an explicit check if the type-id
        # is a structure because in some cases, IDA will forget to set the FF_STRUCT
        # flag but still assign the structure type-id to a union member.
        if (dsize == FF_STRUCT and isinstance(typeid, six.integer_types)) or (typeid is not None and structure.has(typeid)):
            # FIXME: figure out how to fix this recursive module dependency
            t = structure.by_identifier(typeid) if offset is None else structure.by_identifier(typeid, offset=offset)

            # grab the size, and check it it's a variable-length struct so we can size it.
            sz, variableQ = t.size, t.ptr.props & getattr(idaapi, 'SF_VAR', 1)
            return t if sz == size else (t, size) if variableQ else [t, size // sz]

        # Verify that we actually have the datatype mapped and that we can look it up.
        if all(item not in cls.inverted for item in [dsize, dtype, (dtype, typeid)]):
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.dissolve({!r}, {!r}, {!r}) : Unable to locate a pythonic type that matches the specified flag.".format('.'.join([__name__, cls.__name__]), dtype, typeid, size))

        # Now that we know the datatype exists, extract the actual type (dtype)
        # and the type's size (dsize) from the inverted map while giving priority
        # to the type. This way we're checking the dtype for pointers (references)
        # and then only afterwards do we fall back to depending on the size.
        item = cls.inverted[dtype] if dtype in cls.inverted else cls.inverted[dtype,typeid] if (dtype, typeid) in cls.inverted else cls.inverted[dsize]
        if len(item) == 2:
            t, sz = item

        # If our tuple contains extra information (a string), then hack that in.
        else:
            t, width, length = item
            reduced = item if length > 0 else (t, width) if width > 1 else t

            # XXX: IDA includes the length in the actual count if we're being
            #      assigned to a structure but not within the database. So, we
            #      ignore the correct calculation (which makes the python type
            #      look inaccurate, but it represents the number of characters
            #      that fit within the prefix) and adjust it in the database module.

            #count = max(0, size - length) // width
            count = size // width
            return [reduced, count] if count > 1 else reduced if length > 0 or width > 1 else str

        # If the datatype size is not an integer, then we need to calculate the
        # size ourselves using the size parameter we were given and the element
        # size of the datatype as determined by the flags (DT_TYPE | MS_CLS).
        if not isinstance(sz, six.integer_types):
            count = size // idaapi.get_data_elsize(idaapi.BADADDR, flag, idaapi.opinfo_t())
            return [t, count] if count > 1 else t

        # If the size matches the datatype size, then this is a single element
        # which we represent with a tuple composed of the python type, and the
        # actual byte size of the datatype.
        elif sz == size:
            return t, sz * sf

        # At this point, the size does not match the datatype size which means
        # that this is an array where each element is using the datatype. So,
        # we need to return a list where the first element is the datatype with
        # the element size, and the second element is the length of the array.
        return [(t, sz * sf), size // sz]

    @classmethod
    def resolve(cls, pythonType):
        '''Convert the provided `pythonType` into IDA's `(flag, typeid, size)`.'''
        structure = sys.modules.get('structure', __import__('structure'))
        struc_flag = idaapi.struflag if idaapi.__version__ < 7.0 else idaapi.stru_flag

        sz, count = None, 1

        # If we were given a pythonic-type that's a tuple, then we know that this
        # is actually an atomic type that has its flag within our typemap. We'll
        # first use the type the user gave us to find the actual table containg
        # the sizes we want to look up, and then we extract the flag and typeid
        # from the table that we determined.
        if isinstance(pythonType, ().__class__) and not isinstance(next(iter(pythonType)), (idaapi.struc_t, structure.structure_t)):
            table = cls.typemap[builtins.next(item for item in pythonType)]

            #t, sz = pythonType
            #table = cls.typemap[t] if not isinstance(t, tuple) else cls.typemap[t[0]]
            #(t, sz), count = (pythonType, 1) if len(pythonType) == 2 else ((pythonType[0], pythonType), 1)
            if pythonType in table:
                flag, typeid = table[pythonType]
                t, width, length = pythonType if len(pythonType) == 3 else pythonType + (0,)
                return flag, typeid, width + length

            (t, sz), count = pythonType, 1
            table = table[abs(sz)]

        # If we were given a pythonic-type that's a list, then we know that this
        # is an array of some kind. We extract the count from the second element
        # of the list, but then we'll need to recurse into ourselves in order to
        # figure out the actual flag, type-id, and size of the type that we were
        # given by the first element of the list.
        elif isinstance(pythonType, [].__class__):
            res, count = pythonType
            flag, typeid, sz = cls.resolve(res)

        # If our pythonic-type is an actual structure_t, then obviously this
        # type is representing a structure. We know how to create the structure
        # flag, but we'll need to extract the type-id and the structure's size
        # from the properties of the structure that we were given.
        elif isinstance(pythonType, structure.structure_t):
            flag, typeid, sz = struc_flag(), pythonType.id, pythonType.size

        # If our pythonic-type is an idaapi.struc_t, then we need to do
        # pretty much the exact same thing that we did for the structure_t
        # and extract both its type-id and size.
        elif isinstance(pythonType, idaapi.struc_t):
            flag, typeid, sz = struc_flag(), pythonType.id, idaapi.get_struc_size(pythonType)

        # if we got here with a tuple, then that's because we're using a variable-length
        # structure...which really means the size is forced.
        elif isinstance(pythonType, ().__class__):
            t, sz = pythonType
            sptr = t.ptr if isinstance(t, structure.structure_t) else t
            flag, typeid = struc_flag(), sptr.id

            # if we're not a variable-length structure, then this pythonic type isn't
            # valid. we still don't error out, though, and we just correct the size.
            if not sptr.props & getattr(idaapi, 'SF_VAR', 1):
                sz = idaapi.get_struc_size(sptr)

        # Anything else should be the default value that we're going to have to
        # look up. We start by using the type to figure out the correct table,
        # and then we grab the flags and type-id from the None key for the
        # pythonType. This should give us the default type information for the
        # current database and architecture.
        else:
            table = cls.typemap[pythonType]
            flag, typeid = table[None]

            # Construct an opinfo_t with the type-id that was returned, and then
            # calculate the correct size for the value returned by our table.
            opinfo, typeid = idaapi.opinfo_t(), idaapi.BADADDR if typeid < 0 else typeid
            opinfo.tid = typeid
            return flag, typeid, idaapi.get_data_elsize(idaapi.BADADDR, flag, opinfo)

        # Now we can return the flags, type-id, and the total size that IDAPython
        # uses when describing a type. We also check if our size is negative
        # because then we'll need to update the flags with the FF_SIGN flag in
        # order to describe the correct type requested by the user.
        typeid = idaapi.BADADDR if typeid < 0 else typeid
        return flag | (idaapi.FF_SIGN if sz < 0 else 0), typeid, abs(sz) * count

    @classmethod
    def update_refinfo(cls, identifier, flag):
        '''This updates the refinfo for the given `identifer` according to the provided `flag`.'''
        return address.update_refinfo(identifier, flag)

class prioritybase(object):
    result = type('result', (object,), {})
    CONTINUE = type('continue', (result,), {})()
    STOP = type('stop', (result,), {})()

    def __init__(self):
        self.__cache__ = collections.defaultdict(list)
        self.__disabled = {item for item in []}
        self.__traceback = {}

    def __iter__(self):
        '''Iterate through each target that is currently attached to this object.'''
        for target in self.__cache__:
            yield target
        return

    def __contains__(self, target):
        '''Return whether the specified `target` is currently attached to this object.'''
        return target in self.__cache__

    def __len__(self):
        '''Return the number of targets that are currently attached to this object.'''
        return len(self.__cache__)

    def __formatter__(self, target):
        raise NotImplementedError

    def attach(self, target):
        '''Intended to be called as a supermethod for the specified `target` that returns True or False along with the callable that should be applied to the hook.'''
        if target in self.__cache__:
            logging.warning(u"{:s}.attach({!r}) : Unable to attach to target ({:s}) due to it already being attached.".format('.'.join([__name__, self.__class__.__name__]), target, self.__formatter__(target)))
            return False, internal.utils.fidentity

        # Otherwise we need to ping the cache so that it creates a list, and then
        # we can return the callable that should be attached by the implementation.
        self.__cache__[target]
        return True, self.__apply__(target)

    def detach(self, target):
        '''Intended to be called as a supermethod for the specified `target` that removes the target from the cache.'''
        if target in self.__cache__:
            if len(self.__cache__[target]):
                logging.warning(u"{:s}.detach({!r}) : Unable to detach from target ({:s}) due to callable items still existing in its cache.".format('.'.join([__name__, self.__class__.__name__]), target, self.__formatter__(target)))
                return False
            self.__cache__.pop(target, None)
            return True
        logging.warning(u"{:s}.detach({!r}) : Unable to detach from target ({:s}) due to it not being attached.".format('.'.join([__name__, self.__class__.__name__]), target, self.__formatter__(target)))
        raise False

    def close(self):
        '''Disconnect from all of the targets that are currently attached'''
        ok, items = True, {item for item in self.__cache__}

        # Simply detach every available target one-by-one.
        for target in items:
            if not self.detach(target):
                logging.warning(u"{:s}.close() : Error trying to detach from the specified target ({:s}).".format('.'.join([__name__, self.__class__.__name__]), self.__formatter__(target)))
                ok = False
            continue
        return ok

    @property
    def available(self):
        '''Return all of the attached targets that can be either enabled or disabled.'''

        # This property is intended to be part of the public api and
        # thus it can reimplemented by one if considered necessary.

        result = {item for item in self.__cache__}
        return sorted(result)

    def list(self):
        '''List all of the targets that are available along with a description.'''

        # This property is intended to be part of the public api and
        # thus it can reimplemented by one if considered necessary.

        sorted = self.available
        formatted = {item : "{!s}:".format(item) for item in sorted}
        length = max(map(len, formatted.values())) if formatted else 0

        if formatted:
            for item in sorted:
                six.print_(u"{:<{:d}s} {:s}".format(formatted[item], length, self.__formatter__(item)))
            return
        six.print_(u"There are no available targets.")

    @property
    def disabled(self):
        '''Return all of the attached targets that are currently disabled.'''
        result = {item for item in self.__disabled}
        return sorted(result)
    @property
    def enabled(self):
        '''Return all of the attached targets that are currently enabled.'''
        result = {item for item in self.__cache__} - {item for item in self.__disabled}
        return sorted(result)

    def __repr__(self):
        cls, enabled = self.__class__, {item for item in self.__cache__} - {item for item in self.__disabled}

        # Extract the parameters from a function. This is just a
        # wrapper around utils.multicase.ex_args so we can extract
        # the names.
        def parameters(func):
            args, defaults, (star, starstar) = internal.utils.multicase.ex_args(func)
            for item in args:
                yield "{:s}={!s}".format(item, defaults[item]) if item in defaults else item
            if star:
                yield "*{:s}".format(star)
            if starstar:
                yield "**{:s}".format(starstar)
            return

        # Render the callable as something readable.
        def repr_callable(object, pycompat=internal.utils.pycompat):

            # If a method is passed to us, then we need to extract all
            # of the relevant components that describe it.
            if isinstance(object, (types.MethodType, staticmethod, classmethod)):
                cls = pycompat.method.type(object)
                func = pycompat.method.function(object)
                module, name = func.__module__, pycompat.function.name(func)
                iterable = parameters(func)
                None if isinstance(object, staticmethod) else next(iterable)
                return '.'.join([module, cls.__name__, name]), tuple(iterable)

            # If our object is a function-type, then it's easy to grab.
            elif isinstance(object, types.FunctionType):
                module, name = object.__module__, pycompat.function.name(object)
                iterable = parameters(object)
                return '.'.join([module, name]), tuple(iterable)

            # If it's still callable, then this is likely a class.
            elif callable(object):
                symbols, module, name = object.__dict__, object.__module__, object.__name__
                cons = symbols.get('__init__', symbols.get('__new__', None))
                iterable = parameters(cons) if cons else []
                next(iterable)
                return '.'.join([module, name]), tuple(iterable)

            # Otherwise, we have no idea what it is...
            return "{!r}".format(object), None

        # Unpack a prioritytuple into its components so we can describe it.
        def repr_prioritytuple(tuple):
            priority, callable = tuple
            name, args = repr_callable(callable)
            return priority, name, args

        # If there aren't any targets available, then return immediately.
        if not self.__cache__:
            return '\n'.join(["{!s}".format(cls), "...No targets are being used...".format(cls)])

        alignment_enabled = max(len(self.__formatter__(target)) for target in enabled) if enabled else 0
        alignment_disabled = max(len("{:s} (disabled)".format(self.__formatter__(target))) for target in self.__disabled) if self.__disabled else 0
        res = ["{!s}".format(cls)]

        # First gather all our enabled hooks.
        for target in sorted(enabled):
            items = self.__cache__[target]
            hooks = sorted([(priority, callable) for priority, callable in items], key=operator.itemgetter(0))
            items = ["{description:s}[{:+d}]".format(priority, description=name if args is None else "{:s}({:s})".format(name, ', '.join(args))) for priority, name, args in map(repr_prioritytuple, hooks)]
            res.append("{:<{:d}s} : {!s}".format(self.__formatter__(target), alignment_enabled, ' '.join(items) if items else '...nothing attached...'))

        # Now we can append all the disabled ones.
        for target in sorted(self.__disabled):
            items = self.__cache__[target]
            hooks = sorted([(priority, callable) for priority, callable in items], key=operator.itemgetter(0))
            items = ["{description:s}[{:+d}]".format(priority, description=name if args is None else "{:s}({:s})".format(name, ', '.join(args))) for priority, name, args in map(repr_prioritytuple, hooks)]
            res.append("{:<{:d}s} : {!s}".format("{:s} (disabled)".format(self.__formatter__(target)), alignment_disabled, ' '.join(items) if items else '...nothing attached...'))

        # And then return it to the caller.
        return '\n'.join(res)

    def enable(self, target):
        '''Enable any callables for the specified `target` that have been previously disabled.'''
        cls = self.__class__
        if target not in self.__cache__:
            logging.fatal(u"{:s}.enable({!r}) : The requested target ({:s}) is not attached. {:s}".format('.'.join([__name__, cls.__name__]), target, self.__formatter__(target), "Currently disabled targets are: {:s}".format(', '.join(map(self.__formatter__, self.__disabled))) if self.__disabled else 'There are no disabled targets that may be enabled.'))
            return False
        if target not in self.__disabled:
            logging.fatal(u"{:s}.enable({!r}) : The requested target ({:s}) is not disabled. {:s}".format('.'.join([__name__, cls.__name__]), target, self.__formatter__(target), "Currently disabled targets are: {:s}".format(', '.join(map(self.__formatter__, self.__disabled))) if self.__disabled else 'There are no disabled targets that may be enabled.'))
            return False

        # Always explicitly do what we're told...
        self.__disabled.discard(target)

        # But if there were no entries in the cache, then warn the user about it.
        if not len(self.__cache__[target]):
            logging.warning(u"{:s}.enable({!r}) : The requested target ({:s}) does not have any callables to enable.".format('.'.join([__name__, cls.__name__]), target, self.__formatter__(target)))
            return True
        return True

    def disable(self, target):
        '''Disable execution of all the callables for the specified `target`.'''
        cls, enabled = self.__class__, {item for item in self.__cache__} - self.__disabled
        if target not in self.__cache__:
            logging.fatal(u"{:s}.disable({!r}) : The requested target ({:s}) is not attached. {:s}".format('.'.join([__name__, cls.__name__]), target, self.__formatter__(target), "Currently enabled targets are: {:s}".format(', '.join(map(self.__formatter__, enabled))) if enabled else 'All targets have already been disabled.' if self.__disabled else 'There are no currently attached targets to disable.'))
            return False
        if target in self.__disabled:
            logging.warning(u"{:s}.disable({!r}) : The requested target ({:s}) has already been disabled. {:s}".format('.'.join([__name__, cls.__name__]), target, self.__formatter__(target), "Currently enabled targets are: {:s}".format(', '.join(map(self.__formatter__, enabled))) if enabled else 'All targets have already been disabled.'))
            return False
        self.__disabled.add(target)
        return True

    def add(self, target, callable, priority):
        '''Add the `callable` to the queue for the specified `target` with the given `priority`.'''
        if not builtins.callable(callable):
            cls, format = self.__class__, "{:+d}".format if isinstance(priority, six.integer_types) else "{!r}".format
            raise TypeError(u"{:s}.add({!r}, {!s}, priority={!r}) : Refusing to add a non-callable ({!s}) for the requested target with the given priority ({!r}).".format('.'.join([__name__, cls.__name__]), target, callable, priority, callable, format(priority)))
        elif not isinstance(priority, six.integer_types):
            cls, format = self.__class__, "{:+d}".format if isinstance(priority, six.integer_types) else "{!r}".format
            raise TypeError(u"{:s}.add({!r}, {!s}, priority={!r}) : Refusing to add a callable ({!s}) for the requested target with a non-integer priority ({!r}).".format('.'.join([__name__, cls.__name__]), target, callable, priority, callable, format(priority)))

        # attach to the requested target if possible
        if target not in self.__cache__:
            cls, format = self.__class__, "{:+d}".format if isinstance(priority, six.integer_types) else "{!r}".format
            raise NameError(u"{:s}.add({!r}, {!s}, priority={:s}) : The requested target ({:s}) is not attached. {:s}".format('.'.join([__name__, cls.__name__]), target, callable, format(priority), self.__formatter__(target), "Currently attached targets are: {:s}".format(', '.join(map(self.__formatter__, self.__cache__))) if self.__cache__ else 'There are no currently attached targets to add to.'))

        # discard any callables already attached to the specified target
        self.discard(target, callable)

        # add the callable to our priority queue
        queue = self.__cache__[target]
        heapq.heappush(queue, internal.utils.priority_tuple(priority, callable))

        # preserve a backtrace so we can track where our callable is at
        self.__traceback[(target, callable)] = traceback.extract_stack()[:-1]
        return True

    def get(self, target):
        '''Return all of the callables that are attached to the specified `target`.'''
        if target not in self.__cache__:
            cls = self.__class__
            raise NameError(u"{:s}.get({!r}) : The requested target ({:s}) is not attached. {:s}".format('.'.join([__name__, cls.__name__]), target, self.__formatter__(target), "Currently attached targets are: {:s}".format(', '.join(map(self.__formatter__, self.__cache__))) if self.__cache__ else 'There are no currently attached targets to get from.'))

        # Return the callables attached to the specified target.
        res = self.__cache__[target]
        return tuple(callable for _, callable in res)

    def pop(self, target, index):
        '''Pop the item at the specified `index` from the given `target`.'''
        if target not in self.__cache__:
            cls, format = self.__class__, "{:d}".format if isinstance(index, six.integer_types) else "{!r}".format
            raise NameError(u"{:s}.pop({!r}, {:d}) : The requested target ({:s}) is not attached. Currently attached targets are {:s}.".format('.'.join([__name__, cls.__name__]), target, format(index), self.__formatter__(target), "Currently attached targets are: {:s}".format(', '.join(map(self.__formatter__, self.__cache__))) if self.__cache__ else 'There are no targets currently attached to pop from.'))
        state = []

        # Iterate through the cache for the specified target and collect
        # each callable so we can figure out which one to remove.
        for (priority, F) in self.__cache__[target][:]:
            state.append((priority, F))

        # Pop off the result the user requested, and then combine our
        # state back into the cache we took it from.
        item = state.pop(index)
        if state:
            self.__cache__[target][:] = [internal.utils.priority_tuple(*item) for item in state]

        # Otherwise our target will need to be emptied.
        else:
            self.__cache__[target][:] = []

        # Now we can return whatever it was they removed.
        priority, result = item
        return result

    def discard(self, target, callable):
        '''Discard the `callable` from our priority queue for the specified `target`.'''
        if target not in self.__cache__:
            return False
        state = []

        # Filter through our cache for the specified target, and collect
        # each callable except for the one the user provided.
        found = 0
        for index, (priority, F) in enumerate(self.__cache__[target][:]):
            if F == callable:
                found += 1
                continue
            state.append((priority, F))

        # If we aggregated some items, then replace our cache with everything
        # except for the item the user discarded.
        if state:
            self.__cache__[target][:] = [internal.utils.priority_tuple(*item) for item in state]

        # Otherwise we found nothing and we should just empty the target.
        else:
            self.__cache__[target][:] = []

        return True if found else False

    def remove(self, target, priority):
        '''Remove the first callable from the specified `target` that has the provided `priority`.'''
        if target not in self.__cache__:
            cls, format = self.__class__, "{:+d}".format if isinstance(priority, six.integer_types) else "{!r}".format
            raise NameError(u"{:s}.remove({!r}, {:s}) : The requested target ({:s}) is not attached. {:s}".format('.'.join([__name__, cls.__name__]), target, format(priority), self.__formatter__(target), "Currently attached targets are: {:s}".format(', '.join(map(self.__formatter__, self.__cache__))) if self.__cache__ else 'There are no targets currently attached to remove from.'))
        state, table = [], {}

        # Iterate through our cache for the specified target and save
        # both the state and the index of every single priority.
        for index, (prio, F) in enumerate(self.__cache__[target][:]):
            state.append((prio, F))
            table.setdefault(prio, []).append(index)

        # Before we do anything, we need to ping the priority we're searching for
        # in the table and then we grab the first index for the given priority.
        if priority not in table:
            cls, format = self.__class__, "{:+d}".format if isinstance(priority, six.integer_types) else "{!r}".format
            raise internal.exceptions.ItemNotFoundError(u"{:s}.remove({!r}, {:s}) : Unable to locate a callable with the specific priority ({:s}).".format('.'.join([__name__, cls.__name__]), target, format(prio), format(prio)))
        index = table[priority].pop(0)

        # We now can pop the index directly out of the state. Afterwards, we
        # need to shove our state back into the cache for the target.
        item = state.pop(index)
        if state:
            self.__cache__[target][:] = [internal.utils.priority_tuple(*item) for item in state]

        # If our state is empty, then we go ahead and empty the target.
        else:
            self.__cache__[target][:] = []

        # We have an item that we can now return.
        priority, result = item
        return result

    def __apply__(self, target):
        '''Return a closure that will execute all of the callables for the specified `target`.'''

        ## Define the closure that we'll hand off to attach
        def closure(*parameters):
            if target not in self.__cache__ or target in self.__disabled:
                return

            # Iterate through our priorityqueue extracting each callable and
            # executing it with the parameters we received
            hookq, captured = self.__cache__[target][:], None
            for priority, callable in heapq.nsmallest(len(hookq), hookq, key=operator.attrgetter('priority')):
                logging.debug(u"{:s}.callable({:s}) : Dispatching parameters ({:s}) to callable ({!s}) with priority ({:+d}).".format('.'.join([__name__, self.__class__.__name__]), ', '.join(map("{!r}".format, parameters)), ', '.join(map("{!r}".format, parameters)), callable, priority))

                try:
                    result = callable(*parameters)

                # if we caught an exception, then inform the user about it and stop processing our queue
                except:
                    cls = self.__class__
                    bt = traceback.format_list(self.__traceback[target, callable])
                    current = str().join(traceback.format_exception(*sys.exc_info()))

                    format = functools.partial(u"{:s}.callable({:s}) : {:s}".format, '.'.join([__name__, cls.__name__]), ', '.join(map("{!r}".format, parameters)))
                    logging.fatal(format(u"Callable for {:s} with priority ({:+d}) raised an exception while executing {!s}.".format(self.__formatter__(target), priority, callable)))
                    logging.warning(format(u"Traceback ({:s} was attached at):".format(self.__formatter__(target))))
                    [ logging.warning(format(item)) for item in str().join(bt).split('\n') ]
                    [ logging.warning(format(item)) for item in current.split('\n') ]

                    result = self.STOP

                # Check if it's one of our valid return types. If we're being
                # asked to continue, then move onto the next one.
                if result == self.CONTINUE:
                    continue

                # If we're being asked to stop, then break the loop and terminate.
                elif result == self.STOP:
                    break

                # If we received an unexpected type, then throw up an exception.
                elif isinstance(result, self.result):
                    cls = self.__class__
                    raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.callable({:s}) : Unable to determine the type of result ({!r}) returned from callable ({!s}).".format('.'.join([__name__, cls.__name__]), ', '.join(map("{!r}".format, parameters)), result, callable))

                # If there was no result, then just continue on like nothing happened.
                elif result is None:
                    continue

                # Otherwise we need to save what we got. If it was different, then
                # warn the user that someone is trying to interfere with results.
                elif captured is None:
                    cls = self.__class__
                    logging.info(u"{:s}.callable({:s}) : Captured a result ({!s}) for target {:s} from callable ({!s}) to return to caller.".format('.'.join([__name__, cls.__name__]), ', '.join(map("{!r}".format, parameters)), result, self.__formatter__(target), callable))

                elif result != captured:
                    cls = self.__class__
                    logging.warning(u"{:s}.callable({:s}) : Captured a result ({!s}) for target {:s} from callable ({!s}) that is different than the previous ({!s}).".format('.'.join([__name__, cls.__name__]), ', '.join(map("{!r}".format, parameters)), result, self.__formatter__(target), callable, captured))

                # Assign the captured return code now that we know what it is.
                captured = captured if result is None else result
            return captured

        # That's it!
        return closure

class priorityhook(prioritybase):
    """
    Helper class for allowing one to apply a number of hooks to the
    different hook points within IDA.
    """
    def __init__(self, klass, mapping={}):
        '''Construct an instance of a priority hook with the specified IDA hook type which can be one of ``idaapi.*_Hooks``.'''
        super(priorityhook, self).__init__()

        # stash away our hook class and instantiate a dummy instance of
        # the class that we're going to be attaching our hooks to.
        self.__klass__, self.object = klass, klass()

        # enumerate all of the attachable methods, and create a dictionary
        # that will contain the methods that are currently attached.
        self.__attachable__ = { name for name in klass.__dict__ if not name.startswith('__') and name not in {'hook', 'unhook', 'thisown'} }
        self.__attached__ = {}

        # stash away our mapping of supermethods so that we can return the
        # right one when we're asked to generate them for __supermethod__.
        self.__mapping__ = mapping

        # now that we have everything setup, connect our instance so that
        # when the user modifies it, the call to unhook() will succeed.
        self.object.hook()

    def __supermethod__(self, name):
        '''Generate a method that calls the super method specified by `name`.'''

        # This closure uses a cell (name) in order to generically determine
        # the correct supermethod. Implementors will have to figure out the
        # particular attribute name for the corresponding supermethod themselves
        # and so they'll need to hardcoded it in order to avoid us having to
        # inject the correct supermethod directly into their scope ourselves.
        def supermethod(self, *parameters, **keywords):
            cls = super(self.__class__, self)
            method = getattr(cls, name)
            return method(*parameters, **keywords)

        # Check the mapping of supermethods, and if one exists then return it
        # instead of our generic supermethod that was just defined.
        mapping = self.__mapping__
        return mapping.get(name, supermethod)

    def __formatter__(self, name):
        cls = self.__klass__
        return '.'.join([cls.__name__, name])

    @contextlib.contextmanager
    def __instance__(self):
        '''Return a dictionary upon context entry, and then attach its items to a new hook object upon context exit.'''
        klass, attributes = self.__klass__, {}

        # Check that our object was unhooked, and raise an exception if it
        # not. This way we don't tamper with any hooks that are in use.
        if not self.object.unhook():
            cls = self.__class__
            logging.warning(u"{:s}.__instance__() : Unable to disconnect the current instance ({!s}) during modification.".format('.'.join([__name__, cls.__name__]), self.object.__class__))

        # Now we need to yield the attributes to the caller for them to modify.
        yield attributes

        # Then we need to iterate through all of the attributes in order to
        # gather the items that we'll use to generate a closure.
        methods = {}
        for name, callable in attributes.items():
            locals = {}

            # Assign some parameters that we need to feed into our closure.
            locals['target'], locals['callable'] = name, callable
            locals['supermethod'] = self.__supermethod__(name)

            # Generate a closure that will later be converted into a method.
            def closure(locals):
                def method(instance, *args, **kwargs):
                    target, callable, supermethod = (locals[item] for item in ['target', 'callable', 'supermethod'])
                    result = callable(*args, **kwargs)

                    # If we didn't get a result to return, then just dispatch
                    # to the supermethod so that we don't interfere with anything.
                    if result is None:
                        return supermethod(instance, *args, **kwargs)

                    # Otherwise we return the code that was given to us.
                    logging.debug(u"{:s}.method({:s}) : Received a value ({!r}) to return from {!s} for {:s}.".format('.'.join([__name__, self.__class__.__name__]), self.__formatter__(target), result, callable, self.__formatter__(target)))
                    return result
                return method

            # We've generated the closure to use and so we can store it in
            # our dictionary that will be converted into methods.
            methods[name] = closure(locals)

        # Now we can use the methods we generated and stored in our dictionary to
        # create a new type and use it to instantiate a new hook object.
        cls = type(klass.__name__, (klass,), {attribute : callable for attribute, callable in methods.items()})
        instance = cls()

        # Then we just stash away our object and then install the hooks.
        self.object = instance
        if not instance.hook():
            logging.critical(u"{:s}.__instance__() : Unable to reconnect new instance ({!s}) during modification.".format('.'.join([__name__, cls.__name__]), instance.__class__))
        return

    @property
    def available(self):
        '''Return all of the targets that may be attached to.'''
        result = {name for name in self.__attachable__}
        return sorted(result)

    def list(self):
        '''List all of the available targets with their prototype and description.'''
        klass, sorted = self.__klass__, self.available
        attributes = {item : getattr(klass, item) for item in sorted}
        documentation = {item : autodocumentation.__doc__ for item, autodocumentation in attributes.items()}

        # If there weren't any attributes, then we can just leave.
        if not sorted:
            return six.print_(u"There are no available targets for {:s}.".format(klass.__name__))

        # Define a closure that we can use to extract the parameters from the documentation.
        # FIXME: This should be extracting the actual documentation instead of just the prototype.
        def parameters(doc):
            filtered = filter(None, doc.split('\n'))
            prototype = next(item for item in filtered)
            replaced = prototype.replace('self, ', '').replace('(self)', '()')
            return replaced.strip()

        # Figure out the lengths of each of the columns so that we can align them.
        length = max(map(len, map("{:s}:".format, sorted)))

        # Iterate through all of the sorted items and output them.
        six.print_(u"List of events for {:s}".format(klass.__name__))
        for item in sorted:
            doc = documentation[item]
            six.print_(u"{:<{:d}s} {:s}".format("{:s}:".format(item), length, parameters(doc)))
        return

    def close(self):
        '''Detach from all of the targets that are currently attached and disconnect the instance.'''
        cls = self.__class__
        if not super(priorityhook, self).close():
            logging.critical(u"{:s}.close() : Error trying to detach from all of the targets attached by ({!s}).".format('.'.join([__name__, cls.__name__]), self.object))
            [logging.debug(u"{:s}.close() : Instance ({!r}) is still attached to target {:s}.".format('.'.join([__name__, cls.__name__]), self.object, self.__formatter__(target))) for target in self]

        # Now that everything has been detached, disconnect the instance from all of its events.
        if self.object.unhook():
            return True

        # Log a warning if we were unable to disconnect our instance.
        logging.warning(u"{:s}.close() : Error trying to disconnect the instance ({!r}) from its events.".format('.'.join([__name__, cls.__name__]), self.object))
        return False

    def attach(self, name):
        '''Attach to the target specified by `name`.'''
        cls = self.__class__
        if name not in self.__attachable__:
            raise NameError(u"{:s}.attach({!r}) : Unable to attach to the target ({:s}) due to the target being unavailable.".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))

        # if the attribute is already assigned to our instance, then
        # the target name has already been attached.
        if name in self.__attached__:
            logging.warning(u"{:s}.attach({!r}) : Unable to attach to the target ({:s}) as it has already been attached to.".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))
            return True

        # attach the super class to grab the callable. if successful, then we
        # generate the supermethod for the target in preparation for a closure.
        ok, callable = super(priorityhook, self).attach(name)
        if ok:
            self.__attached__[name] = callable

            # now we can create a new instance of the hook object and update it
            # with the currently attached methods.
            with self.__instance__() as attach:
                attach.update(self.__attached__)

            # log some information and then leave because we were successful.
            logging.info(u"{:s}.attach({!r}) : Attached to the specified target ({:s}).".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))
            return True

        # otherwise we failed, and we need to try to detach from the target using
        # the supermethod in order to remove the target name from the cache.
        if not super(priorityhook, self).detach(name):
            logging.critical(u"{:s}.attach({!r}) : Unable to remove the specified target ({:s}) from the cache of callable items.".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))
            return False

        # we've removed the target name from the cache, so just warn the user
        # that we were unable to attach to the target that was specified.
        logging.warning(u"{:s}.attach({!r}) : Unable to attach to the specified target ({:s}).".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))
        return False

    def detach(self, name):
        '''Detach from the target specified by `name`.'''
        cls = self.__class__
        if name not in self.__attachable__:
            raise NameError(u"{:s}.detach({!r}) : Unable to detach from the target ({:s}) due to the target being unavailable.".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))

        # Check that the target name is currently attached.
        if name not in self.__attached__:
            logging.warning(u"{:s}.detach({!r}) : Unable to detach from the target ({:s}) as it is not currently attached.".format('.'.join([__name__, cls.__name__]), name, self.__formatter__(name)))
            return False

        # When detaching, we need to empty the cache for the provided target
        # before we actually unhook things.
        for callable in self.get(name):
            ok = self.discard(name, callable)
            Flogging = logging.info if ok else logging.warning
            Flogging(u"{:s}.detach({!r}) : {:s} the callable ({!s}) attached to the requested target ({:s}).".format('.'.join([__name__, cls.__name__]), name, 'Discarded' if ok else 'Unable to discard', callable, self.__formatter__(name)))

        # Now we just need to detach the target name from our attachable
        # state, and then apply it to a new instance of the hook object.
        self.__attached__.pop(name)
        with self.__instance__() as attach:
            attach.update(self.__attached__)
        return super(priorityhook, self).detach(name)

    def add(self, name, callable, priority=0):
        '''Add the `callable` to the queue for the specified `name` with the given `priority`.'''

        # If it's already attached, then we can simply add it.
        if name in self:
            return super(priorityhook, self).add(name, callable, priority)

        # Try and attach to the target name with a closure.
        if not self.attach(name):
            cls, format = self.__class__, "{:+d}".format if isinstance(priority, six.integer_types) else "{!r}".format
            raise internal.exceptions.DisassemblerError(u"{:s}.add({!r}, {!s}, {:s}) : Unable to attach to the specified target ({:s}).".format('.'.join([__name__, cls.__name__]), name, callable, format(priority), self.__formatter__(name)))

        # We should've attached, so all that's left is to add it for
        # tracking using the parent method.
        return super(priorityhook, self).add(name, callable, priority)

    def discard(self, name, callable):
        '''Discard the specified `callable` from hooking the event `name`.'''
        if name not in self.__attachable__:
            cls = self.__class__
            raise NameError(u"{:s}.discard({!r}, {!s}) : Unable to discard the callable ({!s}) from the cache due to the target ({:s}) being unavailable.".format('.'.join([__name__, cls.__name__]), name, callable, callable, self.__formatter__(name)))
        return super(priorityhook, self).discard(name, callable)

    def __repr__(self):
        klass = self.__klass__
        if len(self):
            res, items = "Events currently connected to {:s}:".format(klass.__name__), super(priorityhook, self).__repr__().split('\n')
            return '\n'.join([res] + items[1:])
        return "Events currently connected to {:s}: {:s}".format(klass.__name__, 'No events are connected.')

class prioritynotification(prioritybase):
    """
    Helper class for allowing one to apply an arbitrary number of hooks to the
    different notification points within IDA.
    """
    def __init__(self):
        super(prioritynotification, self).__init__()
        self.__lookup = { getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('NW_') }

    def __formatter__(self, notification):
        name = self.__lookup.get(notification, '')
        return "{:s}({:#x})".format(name, notification) if name else "{:#x}".format(notification)

    @property
    def available(self):
        '''Return all of the notifications that may be attached to.'''
        result = {notification for notification in self.__lookup}
        return sorted(result)

    def attach(self, notification):
        '''Attach to the specified `notification` in order to receive events from it.'''
        ok, callable = super(prioritynotification, self).attach(notification)
        return ok and idaapi.notify_when(notification, callable)

    def detach(self, notification):
        '''Detach from the specified `notification` so that events from it will not be received.'''

        # Iterate through all of our callables, and empty the cache since we're
        # actually shutting everything down here.
        cls = self.__class__
        for callable in self.get(notification):
            ok = self.discard(notification, callable)
            Flogging = logging.info if ok else logging.warning
            Flogging(u"{:s}.detach({:#x}) : {:s} the callable ({!s}) attached to the notification {:s}.".format('.'.join([__name__, cls.__name__]), notification, 'Discarded' if ok else 'Unable to discard', callable, self.__formatter__(notification)))

        # Define a dummy closure to pass to the api to avoid a dereference.
        def closure(*parameters):
            return True

        # Now we can actually pass the correct flag to remove the notification.
        ok = idaapi.notify_when(notification | idaapi.NW_REMOVE, closure)
        return ok and super(prioritynotification, self).detach(notification)

    def add(self, notification, callable, priority=0):
        '''Add the `callable` to the queue with the given `priority` for the specified `notification`.'''
        if notification in self:
            return super(prioritynotification, self).add(notification, callable, priority)

        # Notifications are always attached and enabled.
        ok = self.attach(notification)
        if not ok:
            cls = self.__class__
            raise internal.exceptions.DisassemblerError(u"{:s}.add({:#x}, {!s}, {:+d}) : Unable to attach to the notification {:s}.".format('.'.join([__name__, cls.__name__]), notification, callable, priority, self.__formatter__(notification)))

        # Add the callable to our attached notification.
        return super(prioritynotification, self).add(notification, callable, priority)

    def __repr__(self):
        if len(self):
            res, items = 'Notifications currently tracked:', super(prioritynotification, self).__repr__().split('\n')
            return '\n'.join([res] + items[1:])
        return "Notifications currently tracked: {:s}".format('No notifications are being tracked.')

class priorityhxevent(prioritybase):
    """
    Helper class for allowing one to apply an arbitrary number of hooks to the
    different event points within Hex-Rays.
    """
    def __init__(self):
        super(priorityhxevent, self).__init__()
        try:
            import ida_hexrays
        except Exception:
            cls = self.__class__
            raise internal.exceptions.UnsupportedCapability(u"{:s} : Unable to instantiate class due to missing module ({:s}).".format('.'.join([__name__, cls.__name__]), 'ida_hexrays'))
        else:
            self.__module = module = ida_hexrays

        # Initialize the hexrays plugin and make sure we're good to go.
        if not module.init_hexrays_plugin():
            cls = self.__class__
            raise internal.exceptions.DisassemblerError(u"{:s} : Failure while trying initialize the Hex-Rays plugin ({:s}).".format('.'.join([__name__, cls.__name__]), 'init_hexrays_plugin'))

        # Stash our events so that we can pretty-print them and keep a dict
        # that contains the callable that is currently attached to the event.
        self.__events__ = { getattr(ida_hexrays, name) : name for name in dir(ida_hexrays) if name.startswith(('hxe_', 'lxe_')) }
        self.__attached__ = {}

    def __formatter__(self, event):
        name = self.__events__.get(event, '')
        return "{:s}({:#x})".format(name, event) if name else "{:#x}".format(event)

    @property
    def available(self):
        '''Return all of the events that one may want to attach to.'''
        result = {event for event in self.__events__}
        return sorted(result)

    def attach(self, event):
        '''Attach to the specified `event` in order to receive them from Hex-Rays.'''
        cls = self.__class__
        if event not in self.__events__:
            raise NameError(u"{:s}.attach({!r}) : Unable to attach to the event {:s} due to the event being unavailable.".format('.'.join([__name__, cls.__name__]), event, self.__formatter__(event)))

        # If the event is already there, then the target has been attached
        if event in self.__attached__:
            logging.warning(u"{:s}.attach({!r}) : Unable to attach to the event {:s} as it has already been attached to.".format('.'.join([__name__, cls.__name__]), event, self.__formatter__(event)))
            return True

        # Attach using the super class to figure out what callable we should use.
        ok, callable = super(priorityhxevent, self).attach(event)

        # We failed...nothing to see here.
        if not ok:
            logging.warning(u"{:s}.attach({!r}) : Unable to attach to the event {:s}.".format('.'.join([__name__, cls.__name__]), event, self.__formatter__(event)))
            return False

        # Now we have a callable to use, so we just need to install it.
        if not self.__module.install_hexrays_callback(callable):
            logging.warning(u"{:s}.attach({!r}) : Unable to attach to the event {:s} with the specified callable ({!s}).".format('.'.join([__name__, cls.__name__]), event, self.__formatter__(event), callable))
            return False

        # Last thing to do is to save our state so that we can remove it later.
        self.__attached__[event] = callable
        return True

    def detach(self, event):
        '''Detach from the specified `event` so that they will not be received by Hex-Rays.'''
        cls = self.__class__
        if event not in self.__events__:
            raise NameError(u"{:s}.detach({!r}) : Unable to detach from the event {:s} due to the event being unavailable.".format('.'.join([__name__, cls.__name__]), event, self.__formatter__(event)))

        # If it's not connected, then we need to freak out at the user.
        if event not in self.__attached__:
            logging.warning(u"{:s}.detach({!r}) : Unable to detach from the event {:s} as it is not currently attached.".format('.'.join([__name__, cls.__name__]), event, self.__formatter__(event)))
            return False

        # When detaching, we need to empty the cache for the provided target
        # before we can remove the hexrays callback.
        for callable in self.get(event):
            ok = self.discard(event, callable)
            Flogging = logging.info if ok else logging.warning
            Flogging(u"{:s}.detach({!r}) : {:s} the callable ({!s}) attached to the event {:s}.".format('.'.join([__name__, cls.__name__]), event, 'Discarded' if ok else 'Unable to discard', callable, self.__formatter__(event)))

        # Because Hex-Rays callback API wants the original callable that we gave it,
        # we need to rip it out of our state so we can remove it.
        callable = self.__attached__.pop(event)
        count = self.__module.remove_hexrays_callback(callable)
        logging.info(u"{:s}.detach({!r}) : Removed {:d} callback{:s} for the callable ({!s}) attached to the event {:s}.".format('.'.join([__name__, cls.__name__]), event, count, '' if count == 1 else 's', callable, self.__formatter__(event)))

        return super(priorityhxevent, self).detach(event)

    def close(self):
        '''Remove all of the events that are currently attached.'''
        cls = self.__class__
        if not super(priorityhxevent, self).close():
            logging.critical(u"{:s}.close() : Error trying to detach from all of the events that are attached.".format('.'.join([__name__, cls.__name__])))
            [logging.debug(u"{:s}.close() : Event {:s} is still attached{:s}.".format('.'.join([__name__, cls.__name__]), self.__formatter__(event), " by callable {!s}".format(self.__attached__[event]) if event in self.__attached__ else '')) for event in self]

        # We only fail here if our state is not empty.
        return False if self.__attached__ else True

    def add(self, event, callable, priority=0):
        '''Add the `callable` to the queue with the given `priority` for the specified `event`.'''
        if event in self:
            return super(priorityhxevent, self).add(event, callable, priority)

        # Attach to the event so that we can actually do stupid things with it.
        if not self.attach(event):
            cls = self.__class__
            raise internal.exceptions.DisassemblerError(u"{:s}.add({:#x}, {!s}, {:+d}) : Unable to attach to the event {:s}.".format('.'.join([__name__, cls.__name__]), event, callable, priority, self.__formatter__(event)))

        # Add the callable to our current events to call.
        return super(priorityhxevent, self).add(event, callable, priority)

    def __apply__(self, event):
        '''Return a closure that will execute all of the callables for the specified `event`.'''
        original = super(priorityhxevent, self).__apply__(event)

        # We need to define this closure because Hex-Rays absolutely requires
        # you to return a 0 unless the event type specifies otherwise.
        def closure(ev, *parameters):
            if ev == event:
                return original(*parameters) or 0
            return 0
        return closure

    def __repr__(self):
        if len(self):
            res, items = 'Events currently attached:', super(priorityhxevent, self).__repr__().split('\n')
            return '\n'.join([res] + items[1:])
        return "Events currently attached: {:s}".format('No events are currently attached to.')

class address(object):
    """
    This namespace provides tools that assist with correcting
    arguments that a user will provide to a function. This includes
    things such as verifying that an argument references an address
    within the database, is pointing to the "head" or "tail" of an
    address, etc.

    This is needed because some APIs that IDAPython exposes tend to
    be crashy when you give it a bogus address. This way parameters
    can be corrected before they're passed to an API that may crash
    IDA.
    """
    @classmethod
    def pframe(cls):
        '''Return the python frame that was called from the main thread.'''
        res = fr = sys._getframe()
        while fr.f_back and fr.f_code.co_name != '<module>':
            res = fr
            fr = fr.f_back
        return res

    @classmethod
    def __bounds__(cls):
        if idaapi.__version__ < 7.2:
            info = idaapi.get_inf_structure()
            min, max = info.minEA, info.maxEA
        else:
            min, max = idaapi.inf_get_min_ea(), idaapi.inf_get_max_ea()
        return min, max

    @classmethod
    def __within__(cls, ea):
        l, r = cls.__bounds__()
        return l <= ea < r

    @classmethod
    def __head1__(cls, ea, **silent):
        '''Adjusts `ea` so that it is pointing to the beginning of an item.'''
        entryframe = cls.pframe()
        logF = logging.warning if not silent.get('silent', False) else logging.debug

        res = idaapi.get_item_head(ea)
        if ea != res:
            logF("{:s} : Specified address {:#x} is not pointing to the beginning of an item. Setting the address to {:#x}.".format(entryframe.f_code.co_name, ea, res))
        return res
    @classmethod
    def __head2__(cls, start, end, **silent):
        '''Adjusts both `start` and `end` so that each are pointing to the beginning of their respective items.'''
        entryframe = cls.pframe()
        logF = logging.warning if not silent.get('silent', False) else logging.debug

        res_start, res_end = idaapi.get_item_head(start), idaapi.get_item_head(end)
        # FIXME: off-by-one here, as end can be the size of the db.
        if res_start != start:
            logF("{:s} : Starting address of {:#x} is not pointing to the beginning of an item. Setting the address to {:#x}.".format(entryframe.f_code.co_name, start, res_start))
        if res_end != end:
            logF("{:s} : Ending address of {:#x} is not pointing to the beginning of an item. Setting the address to {:#x}.".format(entryframe.f_code.co_name, end, res_end))
        return res_start, res_end
    @classmethod
    def head(cls, *args, **silent):
        '''Adjusts the specified addresses so that they point to the beginning of their specified items.'''
        if len(args) > 1:
            return cls.__head2__(*args, **silent)
        return cls.__head1__(*args, **silent)

    @classmethod
    def __tail1__(cls, ea, **silent):
        '''Adjusts `ea` so that it is pointing to the end of an item.'''
        entryframe = cls.pframe()
        logF = logging.warning if not silent.get('silent', False) else logging.debug

        res = idaapi.get_item_end(ea)
        if ea != res:
            logF("{:s} : Specified address {:#x} not pointing to the end of an item. Setting the address to {:#x}.".format(entryframe.f_code.co_name, ea, res))
        return res
    @classmethod
    def __tail2__(cls, start, end, **silent):
        '''Adjusts both `start` and `end` so that each are pointing to the end of their respective items.'''
        entryframe = cls.pframe()
        logF = logging.warning if not silent.get('silent', False) else logging.debug

        res_start, res_end = idaapi.get_item_end(start), idaapi.get_item_end(end)
        # FIXME: off-by-one here, as end can be the size of the db.
        if res_start != start:
            logF("{:s} : Starting address of {:#x} is not pointing to the end of an item. Setting the address to {:#x}.".format(entryframe.f_code.co_name, start, res_start))
        if res_end != end:
            logF("{:s} : Ending address of {:#x} is not pointing to the end of an item. Setting the address to {:#x}.".format(entryframe.f_code.co_name, end, res_end))
        return res_start, res_end
    @classmethod
    def tail(cls, *args, **silent):
        '''Adjusts the specified addresses so that they point to the end of their specified items.'''
        if len(args) > 1:
            return cls.__tail2__(*args, **silent)
        return cls.__tail1__(*args, **silent)

    @classmethod
    def __inside1__(cls, ea):
        '''Check that `ea` is within the database and adjust it to point to the beginning of its item.'''
        entryframe = cls.pframe()

        if not isinstance(ea, six.integer_types):
            raise internal.exceptions.InvalidParameterError(u"{:s} : The specified address {!r} is not an integral type ({!r}).".format(entryframe.f_code.co_name, ea, ea.__class__))

        if ea == idaapi.BADADDR:
            raise internal.exceptions.InvalidParameterError(u"{:s} : An invalid address ({:#x}) was specified.".format(entryframe.f_code.co_name, ea))

        res = cls.within(ea)
        return cls.head(res, silent=True)
    @classmethod
    def __inside2__(cls, start, end):
        '''Check that both `start` and `end` are within the database and adjust them to point at their specified range.'''

        entryframe = cls.pframe()
        start, end = cls.within(start, end)
        if not isinstance(start, six.integer_types) or not isinstance(end, six.integer_types):
            raise internal.exceptions.InvalidParameterError(u"{:s} : The specified addresses ({!r}, {!r}) are not integral types ({!r}, {!r}).".format(entryframe.f_code.co_name, start, end, start.__class__, end.__class__))
        return cls.head(start, silent=True), cls.tail(end, silent=True) - 1
    @classmethod
    def inside(cls, *args):
        '''Check the specified addresses are within the database and adjust so that they point to their item or range.'''
        if len(args) > 1:
            return cls.__inside2__(*args)
        return cls.__inside1__(*args)

    @classmethod
    def __within1__(cls, ea):
        '''Check that `ea` is within the database.'''
        entryframe = cls.pframe()

        if not isinstance(ea, six.integer_types):
            raise internal.exceptions.InvalidParameterError(u"{:s} : The specified address {!r} is not an integral type ({!r}).".format(entryframe.f_code.co_name, ea, ea.__class__))

        if ea == idaapi.BADADDR:
            raise internal.exceptions.InvalidParameterError(u"{:s} : An invalid address {:#x} was specified.".format(entryframe.f_code.co_name, ea))

        if not cls.__within__(ea):
            l, r = cls.__bounds__()
            raise internal.exceptions.OutOfBoundsError(u"{:s} : The specified address {:#x} is not within the bounds of the database ({:#x}<>{:#x}).".format(entryframe.f_code.co_name, ea, l, r))
        return ea
    @classmethod
    def __within2__(cls, start, end):
        '''Check that both `start` and `end` are within the database.'''
        entryframe = cls.pframe()

        if not isinstance(start, six.integer_types) or not isinstance(end, six.integer_types):
            raise internal.exceptions.InvalidParameterError(u"{:s} : The specified addresses ({!r}, {!r}) are not integral types ({!r}, {!r}).".format(entryframe.f_code.co_name, start, end, start.__class__, end.__class__))

        # If the start and end are matching, then we don't need to fit the bounds.
        if any(not cls.__within__(ea) for ea in [start, end if start == end else end - 1]):
            l, r = cls.__bounds__()
            raise internal.exceptions.OutOfBoundsError(u"{:s} : The specified range ({:#x}<>{:#x}) is not within the bounds of the database ({:#x}<>{:#x}).".format(entryframe.f_code.co_name, start, end, l, r))
        return start, end
    @classmethod
    def within(cls, *args):
        '''Check that the specified addresses are within the database.'''
        if len(args) > 1:
            return cls.__within2__(*args)
        return cls.__within1__(*args)

    @internal.utils.multicase(ea=six.integer_types)
    @classmethod
    def refinfo(cls, ea):
        '''This returns the ``idaapi.refinfo_t`` for the address given in `ea`.'''
        OPND_ALL = getattr(idaapi, 'OPND_ALL', 0xf)
        return cls.refinfo(ea, OPND_ALL)
    @internal.utils.multicase(ea=six.integer_types, opnum=six.integer_types)
    @classmethod
    def refinfo(cls, ea, opnum):
        '''This returns the ``idaapi.refinfo_t`` for the operand `opnum` belonging to the address given in `ea`.'''
        ri = idaapi.refinfo_t()
        ok = idaapi.get_refinfo(ea, opnum, ri) if idaapi.__version__ < 7.0 else idaapi.get_refinfo(ri, ea, opnum)
        return ri if ok else None

    @classmethod
    def update_refinfo(cls, ea, flag):
        '''This updates the refinfo for the identifer given by `ea` according to the provided `flag`.'''
        get_refinfo = (lambda ri, ea, opnum: idaapi.get_refinfo(ea, opnum, ri)) if idaapi.__version__ < 7.0 else idaapi.get_refinfo
        set_refinfo, opmasks = idaapi.set_refinfo, [idaapi.FF_0OFF, idaapi.FF_1OFF]

        # Refinfo seems to be relevant to a given operand, but users really only
        # apply types to addresse unless it's an explicit operand type. So, what
        # we'll do to deal with this is take the flag that we're given and use
        # it to figure out which actual operand is being updated so that we don't
        # have to assume the one that IDA uses based on whatever's being updated.
        dtype, dsize = flag & typemap.FF_MASK, flag & typemap.FF_MASKSIZE

        # First we'll grab the size and make sure that we actually support it.
        # We should.. because we support all of IDA's native types. Then we
        # generate a list of all of the available operands to apply the ref to.
        if dsize in typemap.inverted:
            ptype, (_, size) = type, typemap.inverted[dsize]
            ritype = ptype, size
            ptrmask, _ = typemap.ptrmap[ritype]
            operands = [index for index, opmask in enumerate(opmasks) if dtype & ptrmask & opmask]

        # Anything else means that there's no references to update. If the flags say
        # that it is a string, then we already know that there's nothing to update.
        else:
            FF_STRLIT = idaapi.FF_STRLIT if hasattr(idaapi, 'FF_STRLIT') else idaapi.FF_ASCI
            if dsize != FF_STRLIT:
                logging.warning(u"{:s}.update_refinfo({:#x}, {:#x}) : Unable to determine the default reference type size due to the type ({:#0{:d}x}) from the flags ({:#0{:d}x}) being unsupported..".format('.'.join([__name__, cls.__name__]), ea, flag, dsize, 2 + 8, flag, 2 + 8))
            return 0

        # Before we change anything, do a smoke-test to ensure that we actually
        # are able to choose a default reference size if we're going to update.
        if len(operands) > 0 and ritype not in typemap.refinfomap:
            logging.warning(u"{:s}.update_refinfo({:#x}, {:#x}) : Unable to determine a default reference type for the given size ({:d}).".format('.'.join([__name__, cls.__name__]), ea, flag, size))
            return 0

        # Now we can choose our type from the refinfomap, and apply it to each
        # operand in our list of operands that we just resolved. The set_refinfo
        # api should _never_ fail, so we only log warnings if they do.
        api = [set_refinfo.__module__, set_refinfo.__name__] if hasattr(set_refinfo, '__module__') else [set_refinfo.__name__]
        for opnum in operands:
            if not set_refinfo(ea, opnum, typemap.refinfomap[ritype]):
                logging.warning(u"{:s}.update_refinfo({:#x}, {:#x}) : The api call to `{:s}(ea={:#x}, n={:d}, ri={:d})` returned failure.".format('.'.join([__name__, cls.__name__]), ea, flag, '.'.join(api), ea, opnum, typemap.refinfomap[ritype]))
            continue

        # FIXME: figure out how to update the ui so that it references the new
        #        information but without any dumb performance issues (that might
        #        be caused by asking it to redraw everything).

        # Just return the total number of operands that we updated...for now.
        return len(operands)

class range(object):
    """
    This namespace provides tools that assist with interacting with IDA 6.x's
    ``idaapi.area_t``, or IDA 7.x's ``idaapi.range_t`` in a generic manner
    without needing to know which version of IDA is being used or if the IDA
    6.95 compatibility layer is enabled.
    """

    # Define some classmethods for accessing area_t attributes in versions of IDA
    # prior to IDA 7.0.
    @classmethod
    def start_6x(cls, area):
        '''Return the "startEA" attribute of the specified `area`.'''
        return area.startEA
    @classmethod
    def end_6x(cls, area):
        '''Return the "endEA" attribute of the specified `area`.'''
        return area.endEA

    # Now we can do it for versions of IDA 7.0 and newer..
    @classmethod
    def start_7x(cls, area):
        '''Return the "startEA" attribute of the specified `area`.'''
        return area.start_ea
    @classmethod
    def end_7x(cls, area):
        '''Return the "end_ea" attribute of the specified `area`.'''
        return area.end_ea

    # Assign them based on the IDA version and add some aliases for it.
    start, end = (start_6x, end_6x) if idaapi.__version__ < 7.0 else (start_7x, end_7x)
    left, right, stop = start, end, end
    del(start_6x)
    del(end_6x)
    del(start_7x)
    del(end_7x)

    @classmethod
    def unpack(cls, area):
        '''Unpack the boundaries of the specified `area` as a tuple.'''
        return cls.start(area), cls.end(area)

    @classmethod
    def pack(cls, start, stop):
        '''Pack the address at `start` up to `stop` (exclusive) into a `range_t`.'''
        return idaapi.area_t(start, stop) if idaapi.__version__ < 7.0 else idaapi.range_t(start, stop)

    @classmethod
    def bounds(cls, area):
        '''Return the boundaries of the specified `area` as a ``bounds_t``.'''
        left, right = cls.unpack(area)
        return bounds_t(left, right) if left == right else bounds_t(left, right)

    @classmethod
    def within(cls, ea, area):
        '''Return whether the address `ea` is contained by the specified `area`.'''
        left, right = cls.unpack(area)

        # In IDA, a range_t consistently has a start address that begins
        # before the ending address. This means that if the ending address
        # is less the starting one, that the boundary between them wraps
        # across the highest address.
        if left <= right:
            return left <= ea < right
        return left <= ea or ea < right
    contains = internal.utils.alias(within, 'range')

    @classmethod
    def size(cls, area):
        '''Return the size of the specified `area` by returning the difference of its boundaries.'''
        left, right = cls.unpack(area)
        return right - left

class node(object):
    """
    This namespace contains a number of methods that extract information
    from some of the undocumented structures that IDA stores within
    netnodes for various addresses in a database.

    XXX: Hopefully these are correct!
    """
    @staticmethod
    def is_identifier(identifier):
        '''Return whether the provided `identifier` is actually valid or not.'''

        # First use the latest official api to get the private range of identifiers.
        if hasattr(idaapi, 'inf_get_privrange'):
            res = idaapi.inf_get_privrange()
            return range.within(identifier, res)

        # Otherwise, ping the module for the next best thing.
        elif all(hasattr(idaapi, item) for item in ['inf_get_privrange_start_ea', 'inf_get_privrange_end_ea']):
            start, stop = idaapi.inf_get_privrange_start_ea(), idaapi.inf_get_privrange_end_ea()
            if start <= stop:
                return start <= identifier < stop
            return start <= identifier or identifier < stop

        # If we couldn't find a privrange for the version of IDA that we care about,
        # then we try and call into IDA's supporting library directly.
        try:
            import ida
            if not hasattr(ida, 'getinf'):
                raise ImportError

        # Every single possible way has failed, so we fall back to calling each and
        # every available api to see if any one of them succeeds.
        except ImportError:
            parameters = 2 * [identifier]
            if any(Fapi(id) for Fapi, id in zip([idaapi.get_struc, idaapi.get_member_by_id], parameters)):
                return True
            iterable = (Fapi(id) for Fapi, id in zip([idaapi.get_enum_idx, idaapi.get_enum_member_enum], parameters))
            return not all(map(functools.partial(operator.eq, idaapi.BADADDR), iterable))

        # Otherwise we need to grab the INF index for both boundaries.
        INF_PRIVRANGE_START_EA = getattr(idaapi, 'INF_PRIVRANGE_START_EA', 27)
        INF_PRIVRANGE_END_EA = getattr(idaapi, 'INF_PRIVRANGE_END_EA', 28)

        # Then we can query for them with IDC's getinf() before testing them.
        bounds = map(ida.getinf, [INF_PRIVRANGE_START_EA, INF_PRIVRANGE_END_EA])
        start, stop = map(functools.partial(operator.and_, idaapi.BADADDR), bounds)
        if start <= stop:
            return start <= identifier < stop
        return start <= identifier or identifier < stop

    @internal.utils.multicase(sup=bytes)
    @classmethod
    def sup_functype(cls, sup, *supfields):
        """Given a supval, return the pointer size, model, calling convention, return type, and a tuple composed of the argument stack size and the arguments for a function.

        These bytes are typically found in a supval[0x3000] of a function.
        """
        res, ti = [], idaapi.tinfo_t()
        if not ti.deserialize(None, sup, *itertools.chain(supfields, [None] * (2 - min(2, len(supfields))))):
            raise internal.exceptions.DisassemblerError(u"{:s}.sup_functype(\"{!s}\") : Unable to deserialize the type information that was received.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup)))

        # Fetch the pointer size and the model from the realtype byte.
        if not ti.is_func():
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.sup_functype(\"{!s}\") : The type that was received ({!s}) was not a function type.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup), ti))
        byte = ti.get_realtype()
        ptrsize, model = byte & idaapi.CM_MASK, byte & idaapi.CM_M_MASK
        res += [ptrsize, model]

        # Now we can get the calling convention and append the return type.
        ftd = idaapi.func_type_data_t()
        if not ti.get_func_details(ftd):
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.sup_functype(\"{!s}\") : Unable to get the function's details from the received type information.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup)))
        byte = ftd.cc
        cc, spoiled_count = byte & idaapi.CM_CC_MASK, byte & ~idaapi.CM_CC_MASK
        res += [cc, ftd.rettype]

        # If the argument locations have been calculated, then we can add
        # them to our results. For sanity, we first validate that the number
        # of arguments corresponds to the number of elements in our ftd array.
        if ftd.flags & idaapi.FTI_ARGLOCS:
            number = ti.get_nargs()
            if number != len(ftd):
                raise internal.exceptions.AssertionError(u"{:s}.sup_functype(\"{!s}\") : The number of arguments for the function type ({:d}) does not match the number of arguments that were returned ({:d}).".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup), number, len(ftd)))

            # To grab the arguments, we need to figure out the count because our arguments
            # will be a tuple composed of the (name, type, comment) for each one.
            arguments = []
            for index in builtins.range(ti.get_nargs()):
                item = ftd[index]
                typename, typeinfo, typecomment = item.name, item.type, item.cmt
                arguments.append(typeinfo if not len(supfields) else (typeinfo, typename) if len(supfields) == 1 else (typeinfo, typename, typecomment))

            # Include the size for the arguments on the stack along with the
            # arguments that we just extracted.argument size along with the arguments.
            arglocs = ftd.stkargs, arguments

        # If the argument locations weren't calculated, then the next element we
        # append is the size of the stack that is allocated to the arguments.
        else:
            arglocs = ftd.stkargs
        res += [arglocs]

        # Now we can return everything that we've collected from the type.
        return tuple(res)
    @internal.utils.multicase(sup=bytes, ptrsize=(None.__class__, six.integer_types), model=(None.__class__, six.integer_types), cc=(None.__class__, six.integer_types), rettype=(None.__class__, idaapi.tinfo_t), arglocs=(None.__class__, builtins.list, builtins.tuple))
    @classmethod
    def sup_functype(cls, sup, ptrsize, model, cc, rettype, arglocs):
        '''Given the old supval, re-encode any of the given parameters into it whilst ignoring the parameters that are specified as ``None``.'''

        # First decode the type information that we were given since we're going
        # to use it to reconstruct the supval.
        res, ti = bytearray(), idaapi.tinfo_t()
        if not ti.deserialize(None, sup, None):
            raise internal.exceptions.DisassemblerError(u"{:s}.sup_functype(\"{!s}\", ...) : Unable to deserialize the type information that was received.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup)))

        # If it's not a function, then refuse to process it.
        if not ti.is_func():
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.sup_functype(\"{!s}\", ...) : The type that was received ({!s}) was not a function type.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup), ti))

        # Grab the extra function details so that we can sort out the caling
        # convention and types.
        ftd = idaapi.func_type_data_t()
        if not ti.get_func_details(ftd):
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.sup_functype(\"{!s}\", ...) : Unable to get the function's details from the received type information.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup)))

        # Verify that our arglocs were calculated and the number matches our type.
        if ftd.flags & idaapi.FTI_ARGLOCS:
            number = ti.get_nargs()
            if number != len(ftd):
                raise internal.exceptions.AssertionError(u"{:s}.sup_functype(\"{!s}\", ...) : The number of arguments for the function type ({:d}) does not match the number of arguments that were returned ({:d}).".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup), number, len(ftd)))

        # Start out by grabbing the first byte and compose it from the ptrsize and model.
        obyte = ti.get_realtype()
        nptrsize = obyte & idaapi.CM_MASK if ptrsize is None else ptrsize & idaapi.CM_MASK
        nmodel = obyte & idaapi.CM_M_MASK if model is None else model & idaapi.CM_M_MASK
        res.append(nptrsize | nmodel)

        # Next we compose the calling convention. We need to extract the count
        # from the old byte since the user should be giving us a straight-up
        # calling convention to use.
        obyte = ftd.cc
        ncc = obyte & idaapi.CM_CC_MASK if cc is None else cc & idaapi.CM_CC_MASK
        nspoiled_count = obyte & ~idaapi.CM_CC_MASK
        res.append(ncc | nspoiled_count)

        # Next in our queue is the serialized return type.
        otype = ftd.rettype
        nbytes, _, _ = otype.serialize() if rettype is None else rettype.serialize()
        res.extend(bytearray(nbytes))

        # The last thing we need to do is to figure out our arguments. First we'll
        # check if the user gave us any. If not, then we'll just use the previously
        # used arguments from the idaapi.tinfo_t. We start with the old length,
        # and then we serialize everything into our result.
        if arglocs is None:
            ocount = len(ftd)
            res.append(1 + ocount)

            # Now we can iterate through all of them and serialize each one
            # so that we can extend our result with it.
            for index in builtins.range(ocount):
                funcarg = ftd[index]
                obytes, _, _ = funcarg.type.serialize()
                res.extend(bytearray(obytes))

            # That was it, so we can append our null-byte because we're done.
            res.append(0)

        # Otherwise the user gave us some new arguments to use which we'll need
        # to serialize in order to extend our result. First we'll need to check
        # if we were given a tuple, because if we were then this is a tuple
        # composed of the argument stack size and our actual argument list.
        else:
            _, arglocs = arglocs if isinstance(arglocs, tuple) else (0, arglocs)

            # Now that we have our real list of arguments, we can start by
            # appending the number of arguments that we were given.
            ncount = len(arglocs)
            res.append(1 + ncount)

            # Next we iterate through each of them in order to serialize each
            # one so that we can extend our result with it.
            for index, argloc in builtins.enumerate(arglocs):
                nbytes, _, _ = argloc.serialize()
                res.extend(bytearray(nbytes))

            # Last thing to do is append our null byte.
            res.append(0)

        # We're returning a supval here, so we need to convert our bytearray
        # back to bytes in order for it to be usable.
        return builtins.bytes(res)

    # As the get_stroff_path function doesn't return a full path at all,
    # we need to figure the path ourselves using it as a suggestion.
    @classmethod
    def calculate_stroff_path(cls, offset, suggestion):
        '''Given the provided `offset` and list of identifiers as a `suggestion`, return the delta along with the full structure path as a list of ``idaapi.struc_t``and ``idaapi.member_t` pairs.'''
        items = suggestion[:]

        # After we get the list of member ids, then we can use it to
        # compose the path that we will match against later. We grab
        # the first member (which is the structure id) and convert it
        # to a structure we that we have some place to start.
        import structure
        st = structure.by_identifier(items.pop(0))
        members = [idaapi.get_member_by_id(item) for item in items]
        items = [(sptr if cls.is_identifier(sptr.id) else idaapi.get_member_struc(idaapi.get_member_fullname(mptr.id)), mptr) for mptr, _, sptr in members]

        # Now we have a list of members, we format it into a dictionary
        # so that we can look up the correct member for any given structure.
        choices = {}
        for sptr, mptr in items:
            choices.setdefault(sptr.id, []).append(mptr)

        # Now we can use the members we received to generate a closure
        # that we'll use to figure out the correct members for the operand.
        def Ffilter(parent, candidates, choices=choices):

            # If the parent is not in our list of choices, then we leave
            # because there's nothing we can do with this.
            if parent.id not in choices:
                return []

            # Grab the list for the current parent and check to see if
            # there's a member in our list that we can use. If so, then
            # we can just return it as the only choice.
            items = choices[parent.id]
            if len(items):
                return [items.pop(0)]

            # If there wasn't anything found, then just return all our
            # candidates because we're not sure how to proceed here.
            return []

        # Now we can fetch the delta and path for the requested offset,
        # and then convert it into a list of sptrs and mptrs in order
        # to return it to the caller.
        path, delta = st.members.__walk_to_realoffset__(offset, filter=Ffilter)

        # That was it, so we just need to convert the path into a list
        # of sptrs and mptrs to return to the caller.
        return delta, [(item.parent.ptr, item.ptr) for item in path]

    @classmethod
    def get_stroff_path(cls, ea, opnum):
        '''Given an address at `ea` and the operand number, return a tuple of the delta and a list of the encoded structure/field identifiers.'''
        import instruction

        # If there's no get_stroff_path, then call the old implementation that decodes
        # the path from the supval of the related netnode.
        if not hasattr(idaapi, 'get_stroff_path'):
            Fnetnode = getattr(idaapi, 'ea2node', internal.utils.fidentity)
            bits = math.trunc(math.ceil(math.log(idaapi.BADADDR, 2)))
            if not internal.netnode.sup.has(Fnetnode(ea), 0xf + opnum):
                return 0, []
            sup = internal.netnode.sup.get(Fnetnode(ea), 0xf + opnum, type=memoryview)
            return cls.sup_opstruct(sup.tobytes(), bits > 32)

        # First grab the instruction, and then use it to get the op_t.
        insn = instruction.at(ea)
        op = instruction.operand(insn.ea, opnum)

        # As IDAPython's get_stroff_path() api doesn't tell us how much
        # space we need to allocate, we need to allocate the maximum first.
        # Only then will we know the count to actually use.
        delta, path = idaapi.sval_pointer(), idaapi.tid_array(idaapi.MAXSTRUCPATH)
        count = idaapi.get_stroff_path(insn.ea, opnum, path.cast(), delta.cast()) if idaapi.__version__ < 7.0 else idaapi.get_stroff_path(path.cast(), delta.cast(), insn.ea, opnum)
        if not count:
            return delta.value(), []

        # Now that we have the right length, we can use IDAPython to
        # actually populate the tid_array here. Afterwards, we discard
        # our array by converting it into a list.
        delta, path = idaapi.sval_pointer(), idaapi.tid_array(count)
        res = idaapi.get_stroff_path(insn.ea, opnum, path.cast(), delta.cast()) if idaapi.__version__ < 7.0 else idaapi.get_stroff_path(path.cast(), delta.cast(), insn.ea, opnum)
        if res != count:
            raise internal.exceptions.DisassemblerError(u"{:s}.get_stroff_path({:#x}, {:d}) : The length ({:d}) for the path at operand {:d} changed ({:d}) during calculation.".format('.'.join([__name__, cls.__name__]), insn.ea, opnum, count, opnum, res))
        return delta.value(), [path[idx] for idx in builtins.range(count)]

    @staticmethod
    def sup_opstruct(sup, bit64Q):
        """DEPRECATED: Given a supval, return a tuple of the delta and a list of the encoded structure/field ids.

        This string is typically found in a supval[0xF + opnum] of the instruction.
        """
        le = functools.partial(functools.reduce, lambda agg, by: (agg * 0x100) | by)
        Fidentifier = getattr(idaapi, 'node2ea', internal.utils.fidentity)

        # jspelman. he's everywhere.
        ror = lambda n, shift, bits: (n>>shift) | ((n & pow(2, shift) - 1) << (bits - shift))

        # 16-bit
        # 0001 9ac1 -- _SYSTEMTIME

        # 32-bit
        # 0001 50
        # 0002 5051
        # 0001 c0006e92 -- ULARGE_INTEGER
        # 0002 c0006e92 c0006e98 -- ULARGE_INTEGER.quadpart
        # 0002 c0006e92 c0006e97 -- ULARGE_INTEGER.u.lowpart
        # 0002 c0006e92 c0006e96 -- ULARGE_INTEGER.s0.lowpart
        # (x ^ 0x3f000000)

        def id32(sup):
            iterable = (item for item in bytearray(sup))

            # First consume the offset (FIXME: we only support 2 bytes for now...)
            by = builtins.next(iterable)
            if le([by]) & 0x80:
                offset = le([by] + [builtins.next(iterable)])
                offset ^= 0x8000
            else:
                offset = 0

            count, rest = le([builtins.next(iterable)]), [item for item in iterable]
            itemsize = (len(rest) // count) if count else 1

            iterable = (item for item in rest)
            chunks = [item for item in zip(*(itemsize * [iterable]))]

            if itemsize == 1:
                return offset, [0xff000000 | le(item) for item in chunks]

            elif itemsize == 2:
                return offset, [0xff000000 | 0x8000 ^ le(item) for item in chunks]

            elif itemsize == 4:
                #res = map(le, chunks)
                #res = map(functools.partial(operator.xor, 0x3f000000), res)
                return offset, [0x3f000000 ^ le(item) for item in chunks]

            raise internal.exceptions.SizeMismatchError(u"{:s}.sup_opstruct(\"{:s}\") -> id32 : An unsupported itemsize ({:d}) was discovered while trying to decode {:d} chunks at offset {:#x} from value ({:s}).".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup), itemsize, count, offset, ["{:0{:d}x".format(item, 2 * itemsize) for item in chunks]))

        # 64-bit
        # 000002 c000888e00 c000889900 -- KEVENT.Header.anonymous_0.anonymous_0.Type
        # 000002 c000888e00 c000889a00 -- KEVENT.Header.anonymous_0.Lock
        # 000001 c000888e00        -- KEVENT.Header.anonymous_0
        # 000001 c002bdc400
        # ff0000000000088e -- KEVENT
        # ff0000000000088f -- DISPATCHER_HEADER
        # ff00000000000890 -- _DISPATCHER_HEADER::*F98
        # ff00000000000891 -- _DISPATCHER_HEADER::*F98*0C
        # (x ^ 0xc0000000ff) ror 8

        def id64(sup):
            iterable = (item for item in bytearray(sup))

            # First consume the offset (FIXME: we only support 2 bytes for now...)
            by = builtins.next(iterable)
            if le([by]) & 0x80:
                offset = le([by] + [builtins.next(iterable)])
                offset ^= 0x8000
            else:
                offset = 0

            # Now we can grab our length
            length = le([builtins.next(iterable), builtins.next(iterable)])
            rest = [item for item in iterable]

            if len(rest) % 3 == 0:
                count, mask = 3, 0x8000ff

            elif len(rest) % 5 == 0:
                count, mask = 5, 0xc0000000ff

            else:
                raise NotImplementedError(u"{:s}.sup_opstruct({!r}) -> id64 : Error decoding supval from parameter.".format('.'.join([__name__, node.__name__]), sup))

            iterable = (item for item in rest)
            chunks = [item for item in zip(*(count * [iterable]))]

            #length = le(chunks.pop(0))
            if len(chunks) != length:
                raise internal.exceptions.SizeMismatchError(u"{:s}.sup_opstruct(\"{:s}\") -> id64 : Number of chunks ({:d}) does not match the extracted length ({:d}). These chunks are {!r}.".format('.'.join([__name__, node.__name__]), internal.utils.string.tohex(sup), len(chunks), length, [bytes().join(item) for item in chunks]))
            res = map(le, chunks)
            res = map(functools.partial(operator.xor, mask), res)
            return offset, [ror(item, 8, 64) for item in res]

        offset, items = id64(sup) if bit64Q else id32(sup)
        return offset, [Fidentifier(item) for item in items]

    @internal.utils.multicase(ea=six.integer_types)
    @classmethod
    def aflags(cls, ea):
        '''Return the additional flags for the instruction at the address `ea`.'''
        NALT_AFLAGS = getattr(idaapi, 'NALT_AFLAGS', 8)
        if hasattr(idaapi, 'get_aflags'):
            return idaapi.get_aflags(ea)
        return internal.netnode.alt.get(idaapi.ea2node(ea) if hasattr(idaapi, 'ea2node') else ea, NALT_AFLAGS)
    @internal.utils.multicase(ea=six.integer_types, mask=six.integer_types)
    @classmethod
    def aflags(cls, ea, mask):
        '''Return the additional flags for the instruction at the address `ea` masked with the integer provided by `mask`.'''
        return cls.aflags(ea) & mask
    @internal.utils.multicase(ea=six.integer_types, mask=six.integer_types, value=six.integer_types)
    @classmethod
    def aflags(cls, ea, mask, value):
        '''Set the additional flags for the instruction at address `ea` using the provided `mask` and `value`.'''
        NALT_AFLAGS = getattr(idaapi, 'NALT_AFLAGS', 8)
        result, flags = cls.aflags(ea, ~mask), value & mask
        if hasattr(idaapi, 'set_aflags'):
            return idaapi.set_aflags(ea, result | flags)
        return internal.netnode.alt.set(idaapi.ea2node(ea) if hasattr(idaapi, 'ea2node') else ea, NALT_AFLAGS, result | flags)

    @classmethod
    def alt_opinverted(cls, ea, opnum):
        '''Return whether the operand `opnum` at the address `ea` has its sign inverted or not.'''
        AFL_SIGN0, AFL_SIGN1 = 0x100000, 0x200000

        # Verify that we were given an operand number that has been tested before,
        # and log it if we haven't. Although it's likely that IDA will consider
        # all of the operands that follow the second operand as inverted once the
        # inversion has been applied by the user, we log this just to be safe and
        # let the user know that we're making an assumption here.
        if opnum not in {0, 1, 2}:
            result = cls.aflags(ea)
            logging.info(u"{:s}.alt_opinverted({:#x}, {:d}) : Fetching the inversion state for the operand ({:d}) of the instruction at {:#x} has not been tested (aflags={:#x}).".format('.'.join([__name__, cls.__name__]), ea, opnum, opnum, ea, result))

        # Grab the altval containing the additional flags for the given address
        # masked with the bits that we plan on checking.
        else:
            result = cls.aflags(ea, AFL_SIGN0 | AFL_SIGN1)

        # Now we just need to figure out which flag we need to use for the
        # operand that was chosen, and then we can check its mask.
        flag = AFL_SIGN1 if opnum else AFL_SIGN0
        return result & flag == flag

    @classmethod
    def alt_opnegated(cls, ea, opnum):
        '''Return whether the operand `opnum` at the address `ea` has its value negated or not.'''
        AFL_BNOT0, AFL_BNOT1 = 0x100, 0x200
        AFL_BNOTX = AFL_BNOT0 | AFL_BNOT1

        # Verify that we were given an operand number that has been tested before,
        # and if not then log it. Although it's totally plausible that the negation
        # of the second operand will affect all of the other operands that follow
        # it when the negation is applied by the user, we do this log just to be
        # safe and let the user know that we're making an assumption.
        if opnum not in {0, 1, 2}:
            result = cls.aflags(ea)
            logging.info(u"{:s}.alt_opnegated({:#x}, {:d}) : Fetching the negation state for the operand ({:d}) of the instruction at {:#x} has not been tested (aflags={:#x}).".format('.'.join([__name__, cls.__name__]), ea, opnum, opnum, ea, result))

        # Grab the altval containing the additional flags for the given address
        # masked with the bits that we want to check.
        else:
            result = cls.aflags(ea, AFL_BNOT0 | AFL_BNOT1)

        # Similar to the alt_opinverted function, we just need to figure out
        # the flag to use for the operand number that was chosen so that we
        # check its the aflags against the correct mask.
        flag = AFL_BNOT1 if opnum else AFL_BNOT0
        return result & flag == flag

class strpath(object):
    """
    This namespace contains utilities that interact with a structure path
    which includes the generation of filters, etc.

    A structure path is a tuple composed of `(sptr, mptr, offset)`.
    """
    @classmethod
    def candidates(cls, sptr, offset):
        '''Given the specified offset, return the `(sptr, [mptrs], offset)` that it can point to.'''
        SF_VAR, SF_UNION = getattr(idaapi, 'SF_VAR', 0x1), getattr(idaapi, 'SF_UNION', 0x2)

        # Define a closure that checks whether the given member contains the specified
        # offset and then translates it. If sptr is a union, the offset needs to come
        # before the end of the member. If it's variable-sized and the last member's
        # id matches the mptr, then the offset should come after the last member. If
        # both mptr.soff and mptr.eoff are the same then the member itself is
        # variable-sized and requires us to check that the offset is in front of it.
        # Anything else requires us to just check against the member's boundaries.
        def contains(sptr, mptr, offset):
            '''Return whether the given `mptr` contains the specified offset.'''
            if sptr.props & SF_UNION:
                return offset < mptr.eoff
            elif mptr.soff == mptr.eoff:
                return mptr.eoff <= offset
            elif sptr.props & SF_VAR and sptr.memqty > 0 and sptr.get_member(sptr.memqty - 1).id == mptr.id:
                return mptr.soff <= offset
            return mptr.soff <= offset < mptr.eoff

        # First grab all the members and then use them to collect the boundaries for
        # all of the candidate members that are within the requested offset.
        members = [sptr.get_member(index) for index in builtins.range(sptr.memqty)]
        if any([0 <= offset < idaapi.get_struc_size(sptr), sptr.props & SF_VAR]):
            candidates = [mptr for mptr in members if contains(sptr, mptr, offset)]
        else:
            candidates = members if sptr.props & SF_UNION else members[:1] if offset < 0 else members[-1:]

        # We just need to return our candidates, and use the offset from wherever they
        # begin to translate the offset we were given so that it's relative to the
        # member. If we're a union, then the members start at 0 and our offset is always
        # going to be the same. No candidates, means we have no members to return.
        if candidates:
            delta = 0 if sptr.props & SF_UNION else next(mptr.soff for mptr in candidates)
            assert(sptr.props & SF_UNION or all(delta == mptr.soff for mptr in candidates))
            return sptr, candidates, offset - delta
        return sptr, [], offset

    @classmethod
    def collect(cls, struc, Fcollect):
        '''This is a utility function that starts at the given sptr in `struc` and consumes either an `sptr`, `mptr`, or an `offset` while adding completed items via `Fcollect`.'''
        SF_UNION = getattr(idaapi, 'SF_UNION', 0x2)

        sptr, mptr, offset = struc, None, 0
        while True:
            try:
                item = (yield sptr)

            # We're being told that we need to gtfo so save what's left and exit our loop.
            except GeneratorExit:
                Fcollect((sptr, mptr, offset))
                break

            # If we were given an offset and we have a member, then we can just update our
            # current offset with it. This allows one to consolidate multiple offsets, but
            # as there's a chance of there being no member defined yet will result in an
            # error as soon as they try to transition to one.
            if isinstance(item, six.integer_types):
                offset += item

            # If we were given a structure and it's the same as the one that we're on,
            # then that means the user wants the size to be used for the member.
            elif isinstance(item, idaapi.struc_t) and item.id == sptr.id:
                mptr = item

            # If we were given a structure, then we need to check that it matches the
            # structure that we expect. If so then we can switch into it.
            elif isinstance(item, idaapi.struc_t) and idaapi.get_sptr(mptr) and idaapi.get_sptr(mptr).id == item.id:
                Fcollect((sptr, mptr, offset))
                sptr, mptr, offset = item, None, 0

            # If we were given a member, then we need to check to see if we've encountered
            # it yet for the current result. We also need to check to ensure it's within
            # the current sptr that we're processing in order to log a warning if otherwise.
            elif isinstance(item, idaapi.member_t):
                expected = idaapi.get_member_struc(idaapi.get_member_fullname(item.id))

                # If we haven't assigned an item into the mptr and the item's parent is the
                # same as our current sptr, then we can just assign it and move on.
                if mptr is None and expected.id == sptr.id:
                    mptr = item

                # If we've already assigned the mptr and the item's parent is the same
                # as our current sptr, then we issue a warning and re-assign it.
                elif expected.id == sptr.id:
                    logging.warning(u"{:s}.collect({:#x}, result={!s}) : Overwriting {:s} \"{:s}\" ({:#x}) of collected results with {:s} \"{:s}\" ({:#x}) due to it belonging to the current {:s} \"{:s}\" ({:#x}).".format('.'.join([__name__, cls.__name__]), struc.id, Fcollect, mptr.__class__.__name__, internal.utils.string.escape(internal.netnode.name.get(mptr.id), '"'), mptr.id, item.__class__.__name__, internal.utils.string.escape(internal.netnode.name.get(item.id), '"'), item.id, sptr.__class__.__name__, internal.utils.string.escape(internal.netnode.name.get(sptr.id), '"'), sptr.id))
                    mptr = item

                # If we got here we need to append our state. However, mptr is None and so
                # we need to fix it up so that it points to an actual member before reset.
                elif mptr is None:
                    mptr = idaapi.get_member(sptr, offset)
                    Fcollect((sptr, mptr, offset - (0 if sptr.props & SF_UNION else mptr.soff)))
                    sptr, mptr, offset = expected, item, 0

                # If we're here, then our sptr doesn't match and we need to append our
                # state to our current results and then transition to the new sptr.
                else:
                    Fcollect((sptr, mptr, offset))
                    sptr, mptr, offset = expected, item, 0

            # If we were given the completely wrong type (or wrong order), and we have no
            # idea what to do. So, add our current position and raise an exception.
            else:
                Fcollect((sptr, mptr, offset))
                description = [item.__class__.__module__, item.__class__.__name__] if hasattr(item.__class__, '__module__') else [item.__class__.__name__]
                raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.collect({:#x}, result={!s}) : Unable to continue collecting results due to the received item ({!r}) being an unsupported type ({!s}).".format('.'.join([__name__, cls.__name__]), struc.id, Fcollect, item, '.'.join(description)))
            continue
        return

    @classmethod
    def fullname(cls, path, sep='.'):
        '''Return the given structure path as an easily-read string.'''
        result = []
        for sptr, mptr, offset in path:
            if mptr:
                _, fullname, owner = idaapi.get_member_by_id(mptr.id)
                name, msize, size = idaapi.get_member_name(mptr.id), idaapi.get_data_elsize(mptr.id, mptr.flag), idaapi.get_member_size(mptr)
                sname, oname = (internal.netnode.name.get(ptr.id) for ptr in [sptr, owner])
                arrayQ, hindex = msize != size, (size - 1) // msize
                index, item = divmod(offset, msize) if arrayQ else (0, offset)
                index, offset = (index, item) if index * msize < size or mptr.soff == mptr.eoff else (hindex, item + (offset - hindex * msize))
                item = "{:s}{:s}{:s}".format(fullname if not result else name if owner.id == sptr.id else "{{ERR!{:s}|{:s}}}{:s}".format(sname, oname, name), "[{:d}]".format(index) if arrayQ else '', "({:+#x})".format(offset) if offset else '' if mptr else "{:+#x}".format(offset))
            elif sptr:
                item = ''.join([internal.netnode.name.get(sptr.id), "({:+#x})".format(offset) if offset else ''])
            else:
                item = "{{ERR!{:+#x}}}".format(offset)
            result.append(item)
        return sep.join(result) if sep else result

    @classmethod
    def format(cls, sptr, mptr, offset=0):
        '''Return the description of an individual item for a structure path.'''
        MF_UNIMEM = getattr(idaapi, 'MF_UNIMEM', 0x2)

        sptr_t, mptr_t = idaapi.struc_t if sptr is None else sptr.__class__, idaapi.member_t if mptr is None else mptr.__class__
        sptr_description = '.'.join([sptr_t.__module__, sptr_t.__name__] if hasattr(sptr_t, '__module__') else [sptr_t.__name__])
        mptr_description = '.'.join([mptr_t.__module__, mptr_t.__name__] if hasattr(mptr_t, '__module__') else [mptr_t.__name__])
        offset_description = "{:+#x}".format(offset) if offset else ''

        # If there's no mptr or they're the same, then we're simply a structure and an offset.
        if sptr and (mptr is None or sptr.id == mptr.id):
            sname = internal.netnode.name.get(sptr.id) or ''
            return "{:s}({:#x}, \"{:s}\"){:s}".format(sptr_description, sptr.id, internal.utils.string.escape(sname, '"'), offset_description)

        # If sptr is None, then we simply figure it out for them and try again.
        elif not sptr:
            _, _, sptr = idaapi.get_member_by_id(mptr.id)
            return cls.format(sptr, mptr, offset)

        # Now we need to check that the member is actually a member. So we
        # grab its name, and try and get the member by its id.
        sname, mname = ((internal.netnode.name.get(item.id) or '') for item in [sptr, mptr])
        result = idaapi.get_member_by_id(mptr.id)

        # If we got something then we need to check that the mptr is related
        # to the sptr by comparing it to the member's structure id that we got.
        if result and sptr.id == result[2].id:
            name = mname[len(sname):]
            return "{:s}({:#x}, {:#x}{:s} {:s}={:#x}{:s})".format(mptr_description, mptr.id, sptr.id, internal.utils.string.escape(name, '"'), 'index' if mptr.props & MF_UNIMEM else 'offset', mptr.soff, offset_description)

        # Anything else means the member is not part of the structure and we
        # clarify that by listing the full name of the member and the parent.
        member = "{:s}({:#x}, \"{:s}\" {:s}={:#x}{:s})".format(mptr_description, mptr.id, internal.utils.string.escape(mname, '"'), 'index' if mptr.props & MF_UNIMEM else 'offset', mptr.soff, offset_description)
        parent = "{:s}({:#x}, \"{:s}\")".format(sptr_description, sptr.id, internal.utils.string.escape(sname, '"'))
        return ' '.join(['(ERROR)', parent, 'is unrelated to', member])

    @classmethod
    def resolve(cls, Fcollect, sptr, offset):
        """Start resolving a path at the given offset of sptr whilst allowing the caller to make decisions at each member.

        The `Fcollect` parameter contains the callable that will be used to store each path item.
        """
        SF_UNION = getattr(idaapi, 'SF_UNION', 0x2)

        # Seed some variables that we'll use to emit some friendlier error messages.
        count, position = 0, 0
        formatlog = functools.partial(u"{:s}.resolve(Fcollect={:s}, {:#x}, {:+#x}) : {:s}".format, '.'.join([__name__, cls.__name__]), '...', sptr.id, offset)

        description = "{:s} ({:#x}) of size ({:#x})".format('union' if sptr.props & SF_UNION else 'structure', sptr.id, idaapi.get_struc_size(sptr))
        logging.debug(formatlog(u"Resolving path for the {:s} towards the offset {:+#x}.".format(description, offset)))

        # Continue looping while we still have choices left. We start each iteration
        # by figuring out what members are at the chosen offset for the user to choose.
        # If there aren't any candidates, then add our current position and leave.
        while sptr:
            sptr, candidates, carry = cls.candidates(sptr, offset)

            # Give the caller the candidates and the offset we aimed for
            # for so that they can either make a choice or re-adjust it.
            [ logging.debug(formatlog(u"Potential {:s}candidate ({:d} of {:d}) for item {:d} (offset {:#x}{:+#x}) of path : {:s}".format('union ' if sptr.props & SF_UNION else '', 1 + index, len(candidates), count, position, offset, cls.format(sptr, item)))) for index, item in enumerate(candidates) ]
            try:
                choice, shift = (yield (sptr, candidates, carry))

            # If we're being told to clean up, then ignore the decision, use
            # the carry value that we determined on their behalf and quit.
            except GeneratorExit:
                mptr, offset = None, carry
                break

            # If they didn't give us a value to shift by, then assume they want the
            # offset that we used to determine the member candidates with.
            else:
                offset = carry if shift is None else shift

            # If we weren't given a choice then we have to make some decisions on
            # their behalf. If there was only one candidate, then use it. Otherwise
            # we'll just do what they tell us and use None (which will terminate).
            if not choice and len(candidates or []) in {0, 1}:
                mptr = candidates[0] if candidates else None

            # If their choice is one of our candidates, then we'll take it.
            elif isinstance(choice, idaapi.member_t) and choice.id in {item.id for item in (candidates or [])}:
                mptr = choice

            # If their choice is the structure (which is not a candidate), then they're
            # choosing its size. We're friendly, though, and honor their desired offset.
            elif choice and choice.id == sptr.id:
                mptr = choice
                break

            # Anything else is because their choice was wrong or we're not going to
            # decide for them. So we need to freak out. If they want to recover, the
            # they'll will need to compare the length of what they gave us with the
            # results we've been aggregating in order to determine what happened.
            else:
                description = 'union' if sptr.props & SF_UNION else "{:+#x} structure".format(idaapi.get_struc_size(sptr.id))
                message = "no valid candidates being chosen ({:s})".format(', '.join(map("{:#x}".format, (mptr.id for mptr in candidates)))) if choice is None else "an invalid candidate ({:s}) being chosen".format("{:#x}".format(choice.id) if hasattr(choice, 'id') else "{!r}".format(choice))
                raise internal.exceptions.MemberNotFoundError(formatlog(u"Path terminated at item {:d} (offset {:#x}{:+#x}) of {:s} ({:#x}) due to {:s}.".format(count, position, offset, description, sptr.id, message)))

            # Now that we determined the mptr for the user's choice, figure out the
            # member's total size and it's member size. From this we'll check if it's
            # actually an array, and determine its maximum index as necessary.
            size, msize = (idaapi.get_member_size(mptr), idaapi.get_data_elsize(mptr.id, mptr.flag)) if mptr else (0, 1)
            arrayQ, maxindex = mptr and msize != size, (size - 1) // msize

            # Using their offset and the mptr's member size, calculate what index the user
            # referenced. We then adjust the index so that it's clamped at the maximum possible
            # array index in order to carry the correct offset into the next item we receive.
            uindex, ubytes = divmod(offset, msize) if arrayQ else (0, offset)
            index, bytes = (uindex, ubytes) if any([uindex * msize < size, arrayQ and mptr.soff == mptr.eoff]) else (maxindex, ubytes + (offset - maxindex * msize))
            logging.debug(formatlog(u"Sender chose {:s} which will result in {:s}carrying offset {:+#x}.".format(cls.format(sptr, mptr, offset), "preserving offset {:+#x} (index {:d}) and ".format(index * msize, index) if arrayQ else '', bytes)))

            # If we've landed on a member (get_sptr returns None from either the mptr
            # being invalid or it not being a structure), then there's nothing to
            # do but exit our loop with whatever state the user has given us.
            if not idaapi.get_sptr(mptr):
                break

            # Store the caller's choice but adjust it by the offset that we received
            # (relative to carry) and the index that needs to be preserved in the item.
            Fcollect((sptr, mptr, (offset - carry) + index * msize))

            # Now we'll update our state for error messages, and then transition to the next
            # item while adjusting our offset so that way it points to the next member.
            count, position = count + 1, position + (0 if sptr.props & SF_UNION else mptr.soff) + index * msize
            sptr, offset = idaapi.get_sptr(mptr), bytes

        # No path members left to process, so the whole path should be resolved and we
        # only need to add the last member that was determined.
        Fcollect((sptr, mptr, offset))
        count, position = count + 1, position + (0 if sptr.props & SF_UNION else mptr.soff if mptr else 0)

        # Before we go, send the user off with a friendly message to thank them for their business.
        if mptr is None:
            left, right = 0, idaapi.get_struc_size(sptr)
            description = ' '.join(["{:s} ({:#x})".format('union' if sptr.props & SF_UNION else 'structure', sptr.id), "{:#x}<>{:+#x}".format(left, right)])
        else:
            left, right = 0 if sptr.props & SF_UNION else mptr.soff, mptr.eoff
            description = ' '.join(["field ({:#x})".format(mptr.id), "{:#x}<>{:s}".format(left, "{:+#x}({:+#x})".format(right, idaapi.get_struc_size(sptr)) if mptr.soff == mptr.eoff else "{:+#x}".format(right))])
        logging.debug(formatlog(u"Path terminated at item {:d} (offset {:#x}{:+#x}) with {:s}.".format(count, position, offset, description)))

    @classmethod
    def calculate(cls, delta=0, Fcollect=operator.truth):
        '''This is just a utility function that consumes `(sptr, mptr, offset)` items and yields the resulting delta to get to it.'''
        SF_UNION = getattr(idaapi, 'SF_UNION', 0x2)

        # Spin in while always returning the current delta that we've calculated on. If we
        # received an empty value, then yield our state because that's all we're good for.
        while True:
            item = (yield delta)
            if item is None:
                continue

            # This is super simple as we only need to check if our sptr is a union. We
            # don't care about validating this path because someone else should've.
            sptr, mptr, offset = item
            delta = sum([delta, 0 if sptr.props & SF_UNION else 0 if mptr is None else idaapi.get_struc_size(mptr) if mptr.id == sptr.id else mptr.soff, offset])
            Fcollect((sptr, mptr, offset))

            # If our path has actually stopped at a field, then we can just break out
            # of our loop because there's nothing that can change anything
            if isinstance(mptr, idaapi.member_t) and not idaapi.get_sptr(mptr):
                break
            continue

        # This loop just continuously yields the delta because technically our path is
        # over since we've already encountered a non-structure field.
        while True:
            (yield delta)
        return

    @classmethod
    def flail(cls, suggestion):
        '''A utility function that continuously yields decisions from a suggestion until there are no more available.'''
        flailer = {}

        # First we'll initialize our dictionary that we'll use to lookup decisions
        # that the user gave us in the suggested path and collect our description.
        suggestion_description = []
        for sptr, mptr, offset in suggestion:
            items = flailer.setdefault(sptr.id, [])
            items.append((mptr, offset))
            suggestion_description.append(cls.format(sptr, mptr, offset))

        # Now we can enter our main loop that just looks up the current structure
        # in our table and chooses the default candidate when it doesn't exist.
        sptr, candidates, carry = (yield)
        while flailer:
            items = flailer[sptr.id] if flailer.get(sptr.id, []) else flailer.pop(sptr.id, [])

            # If we know about this structure, then grab the element out of it and
            # adjust our offset by the delta we found within our suggestion.
            if items:
                mptr, delta = items.pop(0)

            # If there's nothing to flail with, then carry with the default item.
            else:
                mptr, delta = None, 0

            # If our current item has an offset, then log that we're adjusting it.
            if mptr and carry != delta:
                logging.debug(u"{:s}.flail([{:s}]) : The suggested path item {:s} does not match {:s} and its difference ({:+#x}) will likely be carried into the next member.".format('.'.join([__name__, cls.__name__]), "[{:s}]".format(', '.join(suggestion_description)), cls.format(sptr, mptr, delta), cls.format(sptr, None, carry), delta))

            # Send it off.. pray that our flailing accomplished something.
            sptr, candidates, carry = (yield (sptr, mptr, carry))

        # We terminated, so let the caller know where we actually stopped at.
        logging.debug(u"{:s}.flail([{:s}]) : Flailing ended at {:s} with {:d} possible candidates ({:s}).".format('.'.join([__name__, cls.__name__]), "[{:s}]".format(', '.join(suggestion_description)), cls.format(sptr, None, carry), len(candidates), ', '.join("{:#x}".format(item.id) for item in candidates)))

    @classmethod
    def of_tids(cls, offset, tids):
        '''Just a utility functions that uses the provided offset and a list of tids (`tid_array`) to return the complete path.'''
        iterable = (tid for tid in tids)

        # Start out by grabbing the first tid and converting it to an sptr before we start.
        sid = builtins.next(iterable, idaapi.BADADDR)
        sptr = idaapi.get_struc(sid)
        if sptr is None:
            raise internal.exceptions.StructureNotFoundError(u"{:s}.of_tids({:#x}, {:s}) : Unable to find a structure for the given identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), offset, "[{:s}]".format(', '.join(map("{:#x}".format, tids))), sid))

        # Define a class that we'll use to aggregate our results from visit_stroff_fields.
        class visitor_t(idaapi.struct_field_visitor_t):
            def visit_field(self, sptr, mptr):
                calculator.send((sptr, mptr, 0))
                return 0

        # We plan on both collecting and calculating our path so that we can figure out how
        # we should resolve what IDA spits back at us. So, seed a calculator for our results.
        visitorpath = []
        calculator = cls.calculate(0, visitorpath.append)
        visitordelta = builtins.next(calculator)

        visitor = visitor_t()
        length, path = len(tids), idaapi.tid_array(len(tids))
        for index, item in enumerate(tids):
            path[index] = item
        disp = idaapi.sval_pointer()
        disp.assign(offset)
        visit_zero = 1

        res = idaapi.visit_stroff_fields(visitor, path, length, disp, visit_zero) if idaapi.__version__ < 7.0 else  idaapi.visit_stroff_fields(visitor, tids, disp.cast(), visit_zero)
        leftover, visitordelta = disp.value(), builtins.next(calculator)
        calculator.close()

        if idaapi.BADADDR & offset != idaapi.BADADDR & (visitordelta + leftover):
            callable = idaapi.visit_stroff_fields
            raise internal.exceptions.DisassemblerError(u"{:s}.of_tids({:#x}, {:s}) : Expected the call to `{:s}` to return {:#x} bytes but {:#x}{:+#x} ({:#x}) was returned instead.".format('.'.join([__name__, cls.__name__]), offset, "[{:s}]".format(', '.join(map("{:#x}".format, tids))), '.'.join(getattr(callable, attribute) for attribute in ['__module__', '__name__'] if hasattr(callable, attribute)), offset, visitordelta, leftover, visitordelta + leftover))

        # Now we can rely on cls.resolve to figure out where our decisions actually belong. We can
        # target the offset the user gave us because IDA did all of the work for the path, and we
        # only need to figure out which fields the offset is applied to.
        result = []
        calculator = cls.calculate(0, result.append)
        resolver = cls.resolve(calculator.send, sptr, offset - leftover)
        flailer = cls.flail(visitorpath)

        resultdelta, _ = (builtins.next(item) for item in [calculator, flailer])

        # Begin resolving using the flailer till there's nothing left. We also ensure that we
        # always return an item within the bounds of the structure so we get as far as we can.
        sptr, candidates, carry = builtins.next(resolver)
        try:
            while True:
                owner, choice, zero = flailer.send((sptr, candidates, carry))
                if choice and choice.id not in {item.id for item in candidates}:
                    logging.info(u"{:s}.of_tids({:#x}, {:s}) : Ignoring the recommended choice ({:#x}) for index {:d} at offset ({:+#x}) as it was not in the list of candidates ([{:s}]).".format('.'.join([__name__, cls.__name__]), offset, "[{:s}]".format(', '.join(map("{:#x}".format, tids))), choice.id, len(result), builtins.next(calculator), ', '.join("{:#x}".format(item.id) for item in candidates)))
                    break

                sptr, candidates, carry = resolver.send((choice, carry))

            # Always complete our path with whatever the default is.
            while True:
                resolver.send((None, None))

        except (StopIteration, internal.exceptions.MemberNotFoundError):
            pass

        finally:
            flailer.close(), resolver.close()
            resultdelta, _ = builtins.next(calculator), calculator.close()

        # Now we can check our delta which contains the full path of the result against the
        # sum of the visitordelta and the leftover bytes that IDA gave us.
        if resultdelta == visitordelta:
            logging.debug(u"{:s}.of_tids({:#x}, {:s}) : Successfully resolved {:#x}{:+#x} bytes for the path {:s} to {:s}.".format('.'.join([__name__, cls.__name__]), offset, "[{:s}]".format(', '.join(map("{:#x}".format, tids))), resultdelta, leftover, cls.fullname(visitorpath), cls.fullname(result)))

        # Otherwise our resolved path was not completely resolved. Still, we'll honor what IDA
        # gave us by adjusting the visitor path despite it being busted.
        else:
            logging.info(u"{:s}.of_tids({:#x}, {:s}) : The delta ({:#x}) for the resolved path does not match the expected delta ({:#x}).".format('.'.join([__name__, cls.__name__]), offset, "[{:s}]".format(', '.join(map("{:#x}".format, tids))), resultdelta, visitordelta))
            logging.debug(u"{:s}.of_tids({:#x}, {:s}) : Truncated {:+#x} bytes from the path {:s} resulting in {:s}.".format('.'.join([__name__, cls.__name__]), offset, "[{:s}]".format(', '.join(map("{:#x}".format, tids))), resultdelta, cls.fullname(visitorpath), cls.fullname(result)))

        # If we were unable to resolve a path, then we explicitly trust the visitorpath.
        return result or visitorpath

    @classmethod
    def to_tids(cls, path):
        '''This is just a utility function that converts the final path into a list of tids (`tid_array`) containing the decisions required for unions to be displayed properly.'''
        SF_UNION = getattr(idaapi, 'SF_UNION', 0x2)

        # First we'll collect all of the identifiers that we were given
        # within our path since that's all we really care about. Then we
        # need to extract the first sptr, and then put it back so we can
        # process only the members that are part of a union.
        iterable = ((sptr, mptr) for sptr, mptr, _ in path)
        item = builtins.next(iterable)
        sptr, _ = item
        identifiers = [sptr.id]
        iterable = itertools.chain([item], iterable)

        # Now we can process all of the members in our iterator that contain
        # a user-made decision (represented by being part of a union) and
        # then just combine them into a single list of our items to return.
        members = [mptr.id for sptr, mptr in iterable if sptr.props & SF_UNION and mptr]
        return identifiers + members

    @classmethod
    def suggest(cls, struc, suggestion):
        '''This takes a path given by the user and returns the resulting path along with its delta.'''

        # We first need to convert the path that the user gave us into the actual
        # path that we'll apply to the operand. We also need to calculate the delta
        # so we'll just connect our collector to our calculator which will then
        # add any items that get processed to our items.
        result, items = [], [item for item in suggestion]
        calculator = cls.calculate(0, result.append)
        collector = cls.collect(struc, calculator.send)

        # Now we can start both of them so we can feed inputs to our collector
        # until we're asked to stop. We keep track of the last sptr to ensure
        # that we don't send two mptrs in a row for the exact same structure.
        delta, sptr = (builtins.next(coro) for coro in [calculator, collector])
        try:
            # We leave our items as a list so that if an error occurs, we can
            # better explain what we were unable to process.
            last = sptr
            while items:
                item = items.pop(0)

                # If our item is a structure or a member, then we need to convert
                # it into either an idaapi.struc_t or an idaapi.member_t.
                if hasattr(item, 'ptr'):
                    mptr = item.ptr

                # If it's a string and the previous element was an mptr, then we need
                # to transition to the last member's type (sptr) and then look it up.
                elif isinstance(item, six.string_types) and isinstance(last, idaapi.member_t):
                    last = idaapi.get_sptr(last)
                    sptr = collector.send(last)
                    mptr = idaapi.get_member_by_name(sptr, internal.utils.string.to(item))

                # If it's a string, then we can just look it up in our current
                # sptr to figure out which member_t it is.
                elif isinstance(item, six.string_types):
                    mptr = idaapi.get_member_by_name(sptr, internal.utils.string.to(item))

                # Anything else should by one of the native types or an offset.
                else:
                    mptr = item

                # Submit it to the collector and save it away if it's not an integer.
                sptr, last = collector.send(mptr), last if isinstance(mptr, six.integer_types) else mptr

        # If we received an exception, then that's because there was a busted type
        # in the collected path which we'll need to add back to our list.
        except internal.exceptions.InvalidTypeOrValueError as exc:
            ok, items = False, [mptr] + items
            logging.debug(u"{:s}.suggestion({:#x}, {!r}) : Collection was terminated with {:d} items left ({!r}) due to an invalid type ({!r}).".format('.'.join([__name__, cls.__name__]), struc.id, suggestion, len(items), items, mptr))

        # If we had no issues, then we only have to do one thing
        else:
            ok, _ = True, collector.close()

        # We should now be able to grab our delta out of the calculator, and then
        # we can close it before displaying what suggestions actually worked.
        finally:
            delta, _ = builtins.next(calculator), calculator.close()

        # Now we can check for any issues that happened while collecting their path.
        suggested = (''.join(['.'.join(map("{:#x}".format, [sptr.id, mptr.id] if mptr else [sptr.id])), "{:+#x}".format(offset) if offset else '']) for sptr, mptr, offset in result)
        suggestion_description = [item for item in itertools.chain(suggested, map("{!r}".format, items))]
        if ok:
            [ logging.debug(u"{:s}.suggestion({:#x}, [{:s}]) : Successfully interpreted path suggestion at index {:d} as {:s}.".format('.'.join([__name__, cls.__name__]), struc.id, ', '.join(suggestion_description), index, cls.format(*item))) for index, item in enumerate(result) ]

        # Verify that our path is empty and that we successfully consumed everything.
        else:
            logging.warning(u"{:s}.suggestion({:#x}, [{:s}]) : There was an error trying to interpret the suggestions for the path and was truncated to {:s}.".format('.'.join([__name__, cls.__name__]), struc.id, ', '.join(suggestion_description), cls.fullname(result)))

        [ logging.info(u"{:s}.suggestion({:#x}, [{:s}]) : Unable to interpret path suggestion at index {:d} from {!r}.".format('.'.join([__name__, cls.__name__]), struc.id, ', '.join(suggestion_description), len(suggestion) - len(items) + index, item)) for index, item in enumerate(items) ]
        return delta, result

    @classmethod
    def guide(cls, goal, struc, suggestion):
        '''This tries to determine a complete path from the sptr in `struc` to the offset `goal` using `suggestion` as a sloppy (sorta) guidance.'''
        result, suggestion_description = [], [item for item in itertools.starmap(cls.format, suggestion)]

        # Now we have the suggested path and the delta that they're aiming at. All
        # they really did was give us a suggestion as guidance, so we need to resolve
        # it to make sure it makes sense and that way we can store it in our real path.
        calculator = cls.calculate(0, result.append)
        resolver = cls.resolve(calculator.send, struc, goal)
        delta = builtins.next(calculator)

        # Seed our resolver, and then use an index to figure out where we are in our
        # suggestion. If their suggestion is busted, then we'll later use this to flail
        # around and figure out what item they actually meant when we need a decision.
        (owner, candidates, carry) = builtins.next(resolver)
        index, (sptr, mptr, offset) = 0, (owner, None, 0)
        try:
            # Now we can process all the crap they might've given us in their suggestion.
            for index, (sptr, mptr, offset) in enumerate(suggestion):

                # If we don't have an mptr, then we use the offset we were given.
                if not mptr:
                    carry = carry + offset

                # If our choice is not one of the candidates, then we need to bail so that we
                # can start flailing trying to figure out what the suggestion actually meant.
                elif mptr.id not in {item.id for item in candidates}:
                    break

                # Our suggestion still makes sense, so send our choice to the resolver
                # with the adjusted offset and continue with the next suggestion.
                (owner, candidates, carry) = resolver.send((mptr, carry))
            index += 1

        # If our loop has terminated before resolving the path, then we still have some
        # suggestions that we need to consume. Log what's left, and proceed to the next loop.
        except StopIteration:
            Flogging, discard_reason = logging.debug, 'was unnecessary and will be reused when flailing'

        # If we received this exception, then the user is doing something crazy and wants an
        # invalid path. Bump up the logging level and just leave since we can't do anything.
        except internal.exceptions.MemberNotFoundError:
            logging.critical(u"{:s}.guide({:#x}, {:#x}, {:s}) : The suggested path was invalid for offset {:#x} and was truncated at index {:d} ({:s}).".format('.'.join([__name__, cls.__name__]), goal, struc.id, "[{:s}]".format(', '.join(suggestion_description)), goal, index, cls.fullname(result)))
            Flogging, discard_reason = logging.info, 'was discarded'

        # We are finally done and we can stop resolving things. Any other elements that are
        # left weren't actually needed to get to the goal the user wanted.
        else:
            Flogging, discard_reason = logging.debug, 'was not actually used'

        # If there's any suggestions left, then just log them so we can see what's left to do.
        finally:
            for rindex, item in enumerate(suggestion[index:]):
                Flogging(u"{:s}.guide({:#x}, {:#x}, {:s}) : The path suggestion at index {:d} {:s} {:s}.".format('.'.join([__name__, cls.__name__]), goal, struc.id, "[{:s}]".format(', '.join(suggestion_description)), index + rindex, cls.format(*item), discard_reason))

        # If we didn't end up processing all of our suggestions, then we need to flail using
        # everything that's left in case the user's path was busted and needs to be repaired.
        flailer = cls.flail(suggestion[index:])
        try:
            # Now we can start it and continue to choose candidates until there's none left.
            builtins.next(flailer)
            while True:
                sptr, mptr, offset = flailer.send((owner, candidates, carry))
                owner, candidates, carry = resolver.send((mptr, offset))

        # If we have no suggestions left or we've stopped. Then we should be good to go.
        except StopIteration:
            logging.debug(u"{:s}.guide({:#x}, {:#x}, {:s}) : Successfully processed {:d} suggestion{:s} and terminated at index {:d} after processing {:s}.".format('.'.join([__name__, cls.__name__]), goal, struc.id, "[{:s}]".format(', '.join(suggestion_description)), len(suggestion[index:]), '' if len(suggestion[index:]) == 1 else 's', len(result), cls.format(sptr, mptr, offset)))

        # If resolving gave us an exception, then we couldn't do anything with the suggestion
        # even when we were flailing when trying to use all of them.
        except internal.exceptions.MemberNotFoundError:
            logging.info(u"{:s}.guide({:#x}, {:#x}, {:s}) : The suggested path was invalid for offset {:#x} and was truncated at index {:d} ({:s}).".format('.'.join([__name__, cls.__name__]), goal, struc.id, "[{:s}]".format(', '.join(suggestion_description)), goal, len(result), cls.fullname(result)))

        # Completed flailing our arms around trying to make sense of the user's suggestion.
        finally:
            flailer.close()

        # At this point, there's absolutely nothing left to do but to keep choosing the
        # default member until the resolver is complete.
        try:
            while True:
                owner, candidates, carry = resolver.send((None, carry))

        # We're finally done resolving the path. The path is now complete and in our result.
        except StopIteration:
            pass

        # If we got an exception here, then we needed to make a choice but didn't. It's
        # okay, though, because the user's path was completely resolved.
        except internal.exceptions.MemberNotFoundError:
            logging.info(u"{:s}.guide({:#x}, {:#x}, {:s}) : The suggested path was terminated at index {:d} of the result with {:d} candidate{:s} left{:s}.".format('.'.join([__name__, cls.__name__]), goal, struc.id, "[{:s}]".format(', '.join(suggestion_description)), len(result), len(candidates), '' if len(candidates) == 1 else 's', " ({:s})".format(', '.join("{:#x}".format(item.id) for item in candidates) if candidates else '')))

        finally:
            resolver.close()

        # If our result is empty, then the path the user gave us didn't even come close to
        # the goal that they wanted. We did get a structure, though, so use it instead.
        result if result else calculator.send([owner, None, carry])

        # We should now have our result resolved so we can grab our delta to return it.
        delta, _ = builtins.next(calculator), calculator.close()
        return delta, result

class tinfo(object):
    """
    This namespace provides miscellaneous utilities for interacting
    with IDA's ``idaapi.tinfo_t``. This includes both extracting
    and modification of the information contained within it.
    """
    # A lookup table for how to process locations types within tinfo_t.
    location_table = {
        idaapi.ALOC_STACK: operator.methodcaller('stkoff'),
        idaapi.ALOC_STATIC: operator.methodcaller('get_ea'),
        idaapi.ALOC_REG1: operator.methodcaller('get_reginfo'),
        idaapi.ALOC_REG2: operator.methodcaller('get_reginfo'),
        idaapi.ALOC_RREL: internal.utils.fcompose(operator.methodcaller('get_rrel'), internal.utils.fmap(operator.attrgetter('reg'), operator.attrgetter('off'))),
    }

    # Define a throwaway closure that we use for entering and recursing
    # into the location_table. This is needed because scattered types
    # are recursive, and we want to return everything that we can.
    def process_location(atype, location, table):
        F = table.get(atype, internal.utils.fidentity)
        if isinstance(location, idaapi.argpart_t):
            return atype, (F(location), location.off, location.size)
        return atype, F(location)

    # Our first user of process_location which handles any argloc_t items
    # that are stored within an iterator based around a vector.
    process_items = lambda vectorator, table, process=process_location: [ process(vectorator[index].atype(), vectorator[index], table) for index in builtins.range(vectorator.size()) ]

    # Now we can use these two closures to support scattered types.
    location_table[idaapi.ALOC_DIST] = internal.utils.fcompose(operator.methodcaller('scattered'), lambda scatter_t, process=process_items, table=location_table: process(scatter_t, table))

    # Custom types are supported...but not really.
    location_table[idaapi.ALOC_CUSTOM] = operator.methodcaller('get_custom')

    # Now we'll re-use the throwaway closure as an entrypoint to rip
    # the raw location information. This is needed because argloc_t
    # are weakly referenced when we iterate through them, so we use
    # our table to extract their information into gc'd references.
    @classmethod
    def location_raw(cls, loc, process=process_location, table=location_table):
        return process(loc.atype(), loc, table)

    # Now we can define our real entrypoint that will process a raw location
    # in order to convert an argloc_t into one of our symbolic types. We also
    # stash the process_location closure because we need a reference to it
    # in order to access the location_table with our entries.
    @classmethod
    def location(cls, size, architecture, loctype, locinfo, process=process_location):
        '''Return the symbolic location for the raw `loctype`, `locinfo`, and `size` on the given `architecture`.'''

        # This just contains an offset relative to the bottom of the args.
        if loctype == idaapi.ALOC_STACK and not hasattr(locinfo, '__iter__'):
            return location_t(locinfo, size)

        # This is just an address for the user to figure out on their own.
        elif loctype == idaapi.ALOC_STATIC:
            return locinfo

        # A single register and its offset. Offset seems to only be used
        # when using scattered (ALOC_DIST) argument location types.
        elif loctype == idaapi.ALOC_REG1 and not hasattr(locinfo, '__iter__'):
            ridx1, regoff = (locinfo & 0x0000ffff) >> 0, (locinfo & 0xffff0000) >> 16
            try: reg = architecture.by_indexsize(ridx1, size)
            except KeyError: reg = architecture.by_index(ridx1)
            return phrase_t(reg, regoff) if regoff else reg

        # A pair of registers gets returned as a list since they're contiguous.
        elif loctype == idaapi.ALOC_REG2:
            ridx1, ridx2 = (locinfo & 0x0000ffff) >> 0, (locinfo & 0xffff0000) >> 16
            try: reg1 = architecture.by_indexsize(ridx1, size // 2)
            except KeyError: reg1 = architecture.by_index(ridx1)

            try: reg2 = architecture.by_indexsize(ridx2, size // 2)
            except KeyError: reg2 = architecture.by_index(ridx2)

            # The 2nd register is the most-significant with the 1st being the least.
            return [reg2, reg1]

        # Seems to be a value relative to a register (reg+off) which we return
        # as a phrase_t if there's an offset, otherwise just the register.
        elif loctype in {idaapi.ALOC_RREL}:
            ridx, roff = locinfo
            try: reg = architecture.by_indexsize(ridx, size)
            except KeyError: reg = architecture.by_index(ridx)
            return phrase_t(reg, roff) if roff else reg

        # Scattered shit should really just be a list of things, and we
        # can just recurse into it in order to extract our results.
        elif loctype in {idaapi.ALOC_DIST}:
            F = lambda atype, item, offset, size: cls.location(size, architecture, atype, (item, offset, size))
            # XXX: we can't translate scattered_t because it's an empty vector
            #      and its stkoff() appears to be uninitialized.
            iterable = ( F(atype, *item) for atype, item in locinfo )
            return { offset : item for offset, item in iterable }

        # ALOC_REG1, but for argpart_t as a key-value pair since we handle the original further up.
        elif loctype == idaapi.ALOC_REG1:
            locinfo, offset, size = locinfo
            ridx1, regoff = (locinfo & 0x0000ffff) >> 0, (locinfo & 0xffff0000) >> 16
            try:
                reg = architecture.by_index(ridx1)
                while reg.size < regoff + size:
                    reg = architecture.promote(reg)

                if (reg.position, reg.bits) != (8 * regoff, 8 * size):
                    reg = partialregister_t(reg, 8 * regoff, 8 * size)
            except KeyError:
                reg = partialregister_t(architecture.by_index(ridx1), 8 * regoff, 8 * size)
            return offset, reg

        # This is ALOC_STACK, but for argpart_t we return it as a key-value pair.
        elif loctype == idaapi.ALOC_STACK:
            linfo, offset, size = locinfo
            return offset, location_t(linfo, size)

        # Return None if there wasn't a location type.
        elif loctype in {idaapi.ALOC_NONE}:
            return

        # FIXME: We're not supporting this because I've never used this fucker.
        elif loctype in {idaapi.ALOC_CUSTOM}:
            ltypes = {getattr(idaapi, attribute) : attribute for attribute in dir(idaapi) if attribute.startswith('ALOC_')}
            custom = locinfo.get_custom() if hasattr(locinfo, 'get_custom') else locinfo
            raise NotImplementedError(u"{:s}.location({:d}, {!r}, {:d}, {!r}, ...) : Unable to decode location of type {:s} that uses the specified information ({!s}).".format('.'.join([__name__, cls.__name__]), size, architecture, loctype, locinfo, "{:s}({:d})".format(ltypes[loctype], loctype) if loctype in ltypes else "{:d}".format(loctype), custom))

        # Anything else we just return, because we have no context to even
        # raise an exception that can inform the user about what happened.
        return locinfo

    # Now we can delete the closures we defined and its location_table, because
    # they're already attached to the function that needs them.
    del(process_location)
    del(process_items)

    @classmethod
    def function_details(cls, func, ti):
        '''Given a function location in `func` and its type information as `ti`, return the ``idaapi.tinfo_t`` and the ``idaapi.func_type_data_t`` that is associated with it.'''
        rt, ea = internal.interface.addressOfRuntimeOrStatic(func)

        # If our type is a function pointer, then we need to dereference it
        # in order to get the type that we want to extract the argument from.
        if rt and ti.is_funcptr():
            pi = idaapi.ptr_type_data_t()
            if not ti.get_ptr_details(pi):
                raise internal.exceptions.DisassemblerError(u"{:s}.function_details({:#x}, {!r}) : Unable to get the pointer target from the type ({!r}) at the specified address ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(ti), ea))
            tinfo = pi.obj_type

        # If our type is not a function pointer, but it is a pointer...then we
        # dereference it and raise an exception so the user knows it's not callable.
        elif rt and ti.is_ptr():
            tinfo = ti.get_pointed_object()
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.function_details({:#x}, {!r}) : The target of the pointer type ({!r}) at the specified address ({:#x}) is not a function.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))

        # Otherwise this a function and we just use the idaapi.tinfo_t that we got.
        elif not rt and ti.is_func():
            tinfo = ti

        # Anything else is a type error that we need to raise to the user.
        else:
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.function_details({:#x}, {!r}) : The type that was received ({!r}) for the specified function ({:#x}) was not a function type.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(ti), ea))

        # Now we can check to see if the type has details that we can grab the
        # argument type out of. If there are no details, then we raise an
        # exception informing the user.
        if not tinfo.has_details():
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.function_details({:#x}, {!r}) : The type information ({!r}) for the specified function ({:#x}) does not contain any details.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))

        # Now we can grab our function details and return them to the caller.
        ftd = idaapi.func_type_data_t()
        if not tinfo.get_func_details(ftd):
            raise internal.exceptions.DisassemblerError(u"{:s}.function_details({:#x}, {!s}) : Unable to get the details from the type information ({!r}) for the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))
        return tinfo, ftd

    @classmethod
    def update_function_details(cls, func, ti):
        '''Given a function location in `func` and its type information as `ti`, yield the ``idaapi.tinfo_t`` and the ``idaapi.func_type_data_t`` that is associated with it and then update the function with the ``idaapi.func_type_data_t`` that is sent back.'''
        rt, ea = internal.interface.addressOfRuntimeOrStatic(func)
        set_tinfo = idaapi.set_tinfo2 if idaapi.__version__ < 7.0 else idaapi.set_tinfo

        # Similar to function_details, we first need to figure out if our type is a
        # function so that we can dereference it to get the information that we yield.
        if rt and ti.is_funcptr():
            pi = idaapi.ptr_type_data_t()
            if not ti.get_ptr_details(pi):
                raise E.DisassemblerError(u"{:s}.update_function_details({:#x}, {!r}) : Unable to get the pointer target from the type ({!r}) at the specified address ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(ti), ea))
            tinfo = pi.obj_type

        # If the previous case failed, then we're our type isn't related to a function
        # and we were used on a non-callable address. If this is the case, then we need
        # to raise an exception to let the user know exactly what happened.
        elif rt and ti.is_ptr():
            tinfo = ti.get_pointed_object()
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.update_function_details({:#x}, {!r}) : The target of the pointer type ({!r}) at the specified address ({:#x}) is not a function.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))

        # Otherwise this a function and we just use the idaapi.tinfo_t that we got.
        elif not rt and ti.is_func():
            tinfo = ti

        # Anything else is a type error that we need to raise to the user.
        else:
            raise E.MissingTypeOrAttribute(u"{:s}.update_function_details({:#x}, {!r}) : The type that was received ({!r}) for the specified function ({:#x}) was not a function type.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(ti), ea))

        # Next we need to ensure that the type information has details that
        # we can modify. If they aren't there, then we need to bail.
        if not tinfo.has_details():
            raise E.MissingTypeOrAttribute(u"{:s}.update_function_details({:#x}, {!r}) : The type information ({!r}) for the specified function ({:#x}) does not contain any details.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))

        # Now we can grab our function details from the tinfo.
        ftd = idaapi.func_type_data_t()
        if not tinfo.get_func_details(ftd):
            raise E.DisassemblerError(u"{:s}.update_function_details({:#x}, {!r}) : Unable to get the details from the type information ({!r}) for the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))

        # Yield the function type along with the details to the caller and then
        # receive one back (tit-for-tat) which we'll use to re-create the tinfo_t
        # that we'll apply back to the address.
        ftd = (yield (tinfo, ftd))
        if not tinfo.create_func(ftd):
            raise E.DisassemblerError(u"{:s}.update_function_details({:#x}, {!r}) : Unable to modify the type information ({!r}) for the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(ti), "{!s}".format(tinfo), ea))

        # If we were a runtime-linked address, then we're a pointer and we need
        # to re-create it for our tinfo_t.
        if rt:
            pi.obj_type = tinfo
            if not ti.create_ptr(pi):
                raise E.DisassemblerError(u"{:s}.update_function_details({:#x}, {!r}) : Unable to modify the pointer target in the type information ({!r}) for the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info), "{!s}".format(tinfo), ea))
            newinfo = ti

        # If it wasn't a runtime function, then we're fine and can just apply the
        # tinfo that we started out using.
        else:
            newinfo = tinfo

        # Finally we have a proper idaapi.tinfo_t that we can apply. After we apply it,
        # all we need to do is return the previous one to the caller and we're good.
        if not set_tinfo(ea, newinfo):
            raise E.DisassemblerError(u"{:s}.update_function_details({:#x}, {!r}) : Unable to apply the new type information ({!r}) to the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info), "{!s}".format(newinfo), ea))

        # Spinning on that dizzy edge.. I kissed her face and kissed her head..
        # And dreamed of all the ways.. That I had to make her glow. Why are you
        # so far way, she said why won't you ever know..that I'm in love with you.
        # That I'm in love with you.
        try:
            while True:
                ftd = yield (newinfo, ftd)

        # ...and now we're safe.
        except GeneratorExit:
            pass
        return

def tuplename(*names):
    '''Given a tuple as a name, return a single name joined by "_" characters.'''
    iterable = ("{:x}".format(abs(item)) if isinstance(item, six.integer_types) else item for item in names)
    return '_'.join(iterable)

# copied mostly from the collections.namedtuple template
class namedtypedtuple(tuple):
    """
    A named tuple with actual type checking.
    """
    _fields = ()
    _types = ()

    def __new__(cls, *args):
        '''Construct a new instance of a tuple using the specified `args`.'''
        res = args[:]
        for n, t, x in zip(cls._fields, cls._types, args):
            if not isinstance(x, t):
                field_name = n.encode('utf8') if sys.version_info.major < 3 and isinstance(n, unicode) else n
                raise TypeError("Unexpected type ({!r}) for field {:s} should be {!r}.".format(type(x), field_name, t))
            continue
        return tuple.__new__(cls, res)

    @classmethod
    def _make(cls, iterable, cons=tuple.__new__, len=len):
        """Make a tuple using the values specified in `iterable`.

        If `cons` is specified as a callable, then use it to construct the type.
        If `len` is specified as a callable, then use it to return the length.
        """
        result = cons(cls, iterable)
        if len(result) != len(cls._fields):
            raise TypeError("Expected {:d} arguments, got {:d}.".format(len(cls._fields), len(result)))
        for n, t, x in zip(cls._fields, cls._types, result):
            if not isinstance(x, t):
                field_name = n.encode('utf8') if sys.version_info.major < 3 and isinstance(n, unicode) else n
                raise TypeError("Unexpected type ({!r} for field {:s} should be {!r}.".format(type(x), field_name, t))
            continue
        return result

    @classmethod
    def _type(cls, name):
        '''Return the type for the field `name`.'''
        res = (t for n, t in zip(cls._fields, cls._types) if n == name)
        try:
            result = builtins.next(res)
        except StopIteration:
            raise NameError("Unable to locate the type for an unknown field {!r}.".format(name))
        return result

    def __getattribute__(self, name):
        try:
            # honor the ._fields first
            fields = object.__getattribute__(self, '_fields')
            items = [item.lower() for item in fields]
            F = operator.itemgetter(items.index(name.lower()))
        except (IndexError, ValueError):
            F = lambda self: object.__getattribute__(self, name)
        return F(self)

    def __str__(self):
        cls, formats = self.__class__, itertools.chain(getattr(self, '_formats', []), len(self._fields) * ["{!s}".format])
        res = ("{!s}={!s}".format(internal.utils.string.escape(name, ''), format(value)) for name, value, format in zip(self._fields, self, formats))
        return "{:s}({:s})".format(cls.__name__, ', '.join(res))

    def __unicode__(self):
        cls, formats = self.__class__, itertools.chain(getattr(self, '_formats', []), len(self._fields) * ["{!s}".format])
        res = ("{!s}={!s}".format(internal.utils.string.escape(name, ''), format(value)) for name, value, format in zip(self._fields, self, formats))
        return u"{:s}({:s})".format(cls.__name__, ', '.join(res))

    def __repr__(self):
        return u"{!s}".format(self)

    def _replace(self, **fields):
        '''Assign the specified `fields` to the fields within the tuple.'''
        fc = fields.copy()
        result = self._make(map(fc.pop, self._fields, self))
        if fc:
            cls = self.__class__
            logging.warning(u"{:s}._replace({:s}) : Unable to assign unknown field names ({:s}) to tuple.".format('.'.join([__name__, cls.__name__]), internal.utils.string.kwargs(fields), '{' + ', '.join(map(internal.utils.string.repr, fc)) + '}'))
        return result
    def _asdict(self): return collections.OrderedDict(zip(self._fields, self))
    def __getnewargs__(self): return tuple(self)
    def __getstate__(self): return

class integerish(namedtypedtuple):
    """
    This is a namedtypedtuple that allows an implementor to treat it
    as an integer and perform various types of arithmetic upon it.

    The "_operand" attribute specifies which member of the tuple is
    used for performing any of the integral operations. The other
    members of the tuple are preserved. Unless one of them is None,
    which then means that the contents of that tuple are merged.
    """

    @property
    def _operands(self):
        '''This property is intended to be explicitly overwritten by the implementor.'''
        return builtins.tuple(*len(self._fields) * [internal.utils.fconstant])

    def __same__(self, other):
        '''Return true if `other` is the same type and can be used as an operand.'''
        raise NotImplementedError

    def __int__(self):
        raise NotImplementedError

    def __operator__(self, operation, other):
        cls, transform = self.__class__, [F(item) for F, item in zip(self._operands, self)]
        if isinstance(other, six.integer_types):
            result = [Fitem(operation, other) for Fitem in transform]
        elif isinstance(other, self.__class__) and self.__same__(other):
            result = [item if Fitem(operation, item) is None else Fitem(operation, item) for Fitem, item in zip(transform, other)]
        elif any([hasattr(self, '__similar__') and self.__similar__(other), hasattr(other, '__similar__') and other.__similar__(self)]):
            result = [item if Fitem(operation, item) is None else Fitem(operation, item) for Fitem, item in zip(transform, other)]
        elif hasattr(other, '__int__'):
            logging.warning(u"{:s}.__operator__({!s}, {!r}) : Coercing the instance of type `{:s}` to an integer due to a dissimilarity with type `{:s}`.".format('.'.join([__name__, cls.__name__]), operation, other, other.__class__.__name__, cls.__name__))
            return self.__operator__(operation, int(other))
        else:
            raise TypeError(u"{:s}.__operator__({!s}, {!r}) : Unable to perform {:s} operation with type `{:s}` due to a dissimilarity with type `{:s}`.".format('.'.join([__name__, cls.__name__]), operation, other, operation.__name__, other.__class__.__name__, cls.__name__))
        return self.__class__(*result)

    def __operation__(self, operation):
        cls, transform = self.__class__, [F(item) for F, item in zip(self._operands, self)]
        result = [item if Fitem(operation) is None else Fitem(operation) for Fitem in transform]
        return self.__class__(*result)

    # general arithmetic
    def __add__(self, other):
        return self.__operator__(operator.add, other)
    def __sub__(self, other):
        return self.__operator__(operator.sub, other)
    def __and__(self, other):
        return self.__operator__(operator.and_, other)
    def __or__(self, other):
        return self.__operator__(operator.or_, other)
    def __xor__(self, other):
        return self.__operator__(operator.xor_, other)
    def __lshift__(self, other):
        return self.__operator__(operator.lshift, other)
    def __rshift__(self, other):
        return self.__operator__(operator.rshift, other)

    # conversion expressions
    def __abs__(self):
        return self.__operation__(operator.abs)
    def __neg__(self):
        return self.__operation__(operator.neg)
    def __invert__(self):
        return self.__operation__(operator.invert)

    # methods that don't make sense...
    @classmethod
    def __mul__(cls, other):
        operation = operator.mul
        raise TypeError(u"{:s}.__mul__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __div__(cls, other):
        operation = operator.div
        raise TypeError(u"{:s}.__div__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __pow__(cls, other):
        operation = operator.pow
        raise TypeError(u"{:s}.__pow__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __mod__(cls, other):
        operation = operator.mod
        raise TypeError(u"{:s}.__mod__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __floordiv__(cls, other):
        operation = operator.floordiv
        raise TypeError(u"{:s}.__floordiv__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __truediv__(cls, other):
        operation = operator.truediv
        raise TypeError(u"{:s}.__truediv__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __divmod__(cls, other):
        operation = operator.divmod
        raise TypeError(u"{:s}.__divmod__({!r}) : Refusing to perform nonsensical {:s} operation with type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))

    # ...and finally opposites.
    __radd__ = __add__
    __rsub__ = __sub__
    __rand__ = __and__
    __ror__ = __or__
    __rxor__ = __xor__

    # oh, but then there's nonsensical opposites too.
    @classmethod
    def __rlshift__(cls, other):
        operation = operator.lshift
        raise TypeError(u"{:s}.__rlshift__({!r}) : Refusing to perform nonsensical {:s} operation from type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))
    @classmethod
    def __rrshift__(cls, other):
        operation = operator.rshift
        raise TypeError(u"{:s}.__rrshift__({!r}) : Refusing to perform nonsensical {:s} operation from type `{:s}`.".format('.'.join([__name__, cls.__name__]), other, operation.__name__, other.__class__.__name__))

class symbol_t(object):
    """
    An object that is used to describe something that is symbolic in nature
    and has semantics that depend on symbolic values.

    This can be used to weakly describe an expression which allows for
    a user to then enumerate any symbolic parts.
    """
    def __hash__(self):
        cls, res = self.__class__, id(self)
        return hash((cls, res))

    @property
    def symbols(self):
        '''Must be implemented by each sub-class: Return a generator that returns each symbol described by `self`.'''
        raise internal.exceptions.MissingMethodError

class register_t(symbol_t):
    """
    An object representing a particular register as part of an architecture.
    This allows a user to determine the register's name, size, and allows
    for comparison to other registers.
    """

    def __hash__(self):
        identity = self.name if self.realname is None else self.realname
        items = identity, self.dtype, self.position, self.size
        return hash(items)

    @property
    def symbols(self):
        '''Yield the symbolic components that compose the register.'''
        # a register is technically a symbol, so we yield ourselves.
        yield self

    @property
    def id(self):
        '''Return the index of the register as ordered in IDA's list of registers.'''
        if isinstance(self.realname, six.integer_types):
            return self.realname

        # otherwise we need to look in our register index for the name.
        res = idaapi.ph.regnames
        try:
            return res.index(self.realname or self.name)
        except ValueError:
            pass
        return -1

    @property
    def name(self):
        '''Return the name of the register.'''
        return self.__name__
    @property
    def dtype(self):
        '''Return the IDA dtype of the register.'''
        return self.__dtype__
    @property
    def bits(self):
        '''Return the size of the register in bits.'''
        return self.__size__
    @property
    def size(self):
        '''Return the size of the register in bytes.'''
        res = math.ceil(self.__size__ / 8)
        return math.trunc(res)
    @property
    def position(self):
        '''Return the binary offset of the current register into its full register that contains it.'''
        return self.__position__
    @property
    def type(self):
        '''Return the pythonic type of the register.'''
        return self.__ptype__, self.__size__ // 8

    def __format__(self, spec):
        '''Return the architecture's register prefix concatenated to the register's name.'''
        if spec != 's':
            cls = self.__class__
            raise TypeError("unsupported format string ({!s}) passed to {:s}".format(spec, '.'.join([cls.__name__, '__format__'])))
        prefix = getattr(self.architecture, 'prefix', '') if hasattr(self, 'architecture') else ''
        return prefix + self.name

    def __str__(self):
        '''Return the architecture's register prefix concatenated to the register's name.'''
        prefix = getattr(self.architecture, 'prefix', '') if hasattr(self, 'architecture') else ''
        return prefix + self.name

    def __repr__(self):
        iterable = (name for name in dir(idaapi) if name.startswith('dt_') and getattr(idaapi, name) == self.dtype)
        try:
            dt = next(iterable)
        except StopIteration:
            dt = 'unknown'
        cls = register_t
        return "<class '{:s}' index={:d} dtype={:s} name='{!s}' position={:d}{:+d}>".format(cls.__name__, self.id, dt, internal.utils.string.escape(self.name, '\''), self.position, self.bits)

    def __eq__(self, other):
        if isinstance(other, six.string_types):
            return self.name.lower() == other.lower()
        elif isinstance(other, register_t):
            return self is other
        elif hasattr(other, '__eq__'):  # XXX: i fucking hate python
            return other.__eq__(self)
        return other is self

    def __ne__(self, other):
        return not (self == other)

    def __contains__(self, other):
        '''Return true if the `other` register is any of the components of the current register.'''
        viewvalues = {item for item in self.__children__.values()}
        return other in viewvalues

    def subsetQ(self, other):
        '''Return true if the `other` register is a component of the current register.'''
        def collect(node):
            res = {node}
            [res.update(collect(item)) for item in node.__children__.values()]
            return res
        return other in self.alias or other in collect(self)

    def supersetQ(self, other):
        '''Return true if the `other` register uses the current register as a component.'''
        res, pos = {item for item in []}, self
        while pos is not None:
            res.add(pos)
            pos = pos.__parent__
        return other in self.alias or other in res

    def relatedQ(self, other):
        '''Return true if the `other` register may overlap with the current one and thus might be affected when one is modified.'''
        return self.supersetQ(other) or self.subsetQ(other)

    def __int__(self):
        '''Return the integer value of the current register.'''
        rv, rname = idaapi.regval_t(), self.name
        if not idaapi.get_reg_val(rname, rv):
            raise internal.exceptions.DisassemblerError(u"{!s} : Unable to fetch the integer value from the associated register name ({:s}).".format(self, rname))
        mask = pow(2, self.bits) - 1
        if rv.rvtype == idaapi.RVT_INT:
            return rv.ival & mask
        elif rv.rvtype == idaapi.RVT_FLOAT:
            logging.warning(u"{!s} : Converting a non-integer register type ({:d}) to an integer using {:d} bytes.".format(self, rv.rvtype, self.size))
            bytes = rv.fval.bytes
        else:
            logging.warning(u"{!s} : Converting a non-integer register type ({:d}) to an integer using {:d} bytes.".format(self, rv.rvtype, self.size))
            bytes = rv.bytes()
        return functools.reduce(lambda agg, item: agg * 0x100 + item, bytearray(bytes), 0)

    def __float__(self):
        '''Return the floating-point value of the current register.'''
        rv, rname = idaapi.regval_t(), self.name
        if not idaapi.get_reg_val(rname, rv):
            raise internal.exceptions.DisassemblerError(u"{!s} : Unable to fetch the floating-point value from the associated register name ({:s}).".format(self, rname))
        if rv.rvtype == idaapi.RVT_FLOAT:
            return rv.fval._get_float()
        raise internal.exceptions.InvalidTypeOrValueError(u"{!s} : Unable to concretize an unknown register value type ({:d}) to a floating-point number.".format(self, rv.rvtype))

    @property
    def bytes(self):
        '''Return the bytes that make up the value of the current register.'''
        rv, rname = idaapi.regval_t(), self.name
        if not idaapi.get_reg_val(rname, rv):
            raise internal.exceptions.DisassemblerError(u"{!s} : Unable to fetch the bytes for the associated register name ({:s}).".format(self, rname))
        return rv.bytes()

class regmatch(object):
    """
    This namespace is used to assist with doing register matching
    against instructions. This simplifies the interface for register
    matching so that one can specify whether any number of registers
    are written to or read from.
    """
    def __new__(cls, *regs, **modifiers):
        '''Construct a closure that can be used for matching instruction using the specified `regs` and `modifiers`.'''
        if not regs:
            args = ', '.join(map(internal.utils.string.escape, regs))
            mods = internal.utils.string.kwargs(modifiers)
            raise internal.exceptions.InvalidParameterError(u"{:s}({:s}{:s}) : The specified registers are empty.".format('.'.join([__name__, cls.__name__]), args, (', '+mods) if mods else ''))
        use, iterops = cls.use(regs), cls.modifier(**modifiers)
        def match(ea):
            return any(map(functools.partial(use, ea), iterops(ea)))
        return match

    @classmethod
    def use(cls, regs):
        '''Return a closure that checks if an address and opnum uses the specified `regs`.'''
        _instruction = sys.modules.get('instruction', __import__('instruction'))

        # convert any regs that are strings into their correct object type
        regs = { _instruction.architecture.by_name(r) if isinstance(r, six.string_types) else r for r in regs }

        # returns an iterable of bools that returns whether r is a subset of any of the registers in `regs`.
        match = lambda r, regs=regs: any(map(r.relatedQ, regs))

        # returns true if the operand at the specified address is related to one of the registers in `regs`.
        def uses_register(ea, opnum):
            val = _instruction.op(ea, opnum)
            if isinstance(val, symbol_t):
                return any(map(match, val.symbols))
            return False

        return uses_register

    @classmethod
    def modifier(cls, **modifiers):
        '''Return a closure iterates through all the operands in an address that use the specified `modifiers`.'''
        _instruction = sys.modules.get('instruction', __import__('instruction'))

        # by default, grab all operand indexes
        iterops = internal.utils.fcompose(_instruction.ops_count, builtins.range, sorted)

        # if `read` is specified, then only grab operand indexes that are read from
        if modifiers.get('read', False):
            iterops = _instruction.opsi_read

        # if `write` is specified that only grab operand indexes that are written to
        if modifiers.get('write', False):
            iterops = _instruction.opsi_write
        return iterops

## figure out the boundaries of sval_t
if idaapi.BADADDR == 0xffffffff:
    sval_t = ctypes.c_long
elif idaapi.BADADDR == 0xffffffffffffffff:
    sval_t = ctypes.c_longlong
else:
    sval_t = ctypes.c_int
    logging.fatal(u"{:s} : Unable to determine size of idaapi.BADADDR in order to determine boundaries of sval_t. Setting default size to {:d}-bits. The value of idaapi.BADADDR is {!r}.".format(__name__, ctypes.sizeof(sval_t), idaapi.BADADDR))

#Ref_Types = {
#    0 : 'Data_Unknown', 1 : 'Data_Offset',
#    2 : 'Data_Write', 3 : 'Data_Read', 4 : 'Data_Text',
#    5  : 'Data_Informational',
#    16 : 'Code_Far_Call', 17 : 'Code_Near_Call',
#    18 : 'Code_Far_Jump', 19 : 'Code_Near_Jump',
#    20 : 'Code_User', 21 : 'Ordinary_Flow'
#}
class reftype_t(object):
    """
    An object representing a reference type that allows one to easily extract
    semantics using membership operators. This type uses more familiar "rwx"
    that is most commonly associated with posix file permissions in order to
    simplify the semantics of the numerous available reference types.

    When testing membership, "r" means read, "w" means write, "x" means execute,
    and "&" means reference. The intention of this is to make it easier for one
    to verify whether a reference is reading, writing, or executing something.
    """

    if idaapi.__version__ < 7.0:
        __mapper__ = {
            0 : '',
            1 : '&r',
            2 : 'w', 3 : 'r'
        }
    else:
        __mapper__ = {
            idaapi.fl_CF : 'rx', idaapi.fl_CN : 'rx',
            idaapi.fl_JF : 'rx', idaapi.fl_JN : 'rx',
            idaapi.fl_F : 'rx',
            idaapi.dr_O : '&r', idaapi.dr_I : '&r',
            idaapi.dr_R : 'r', idaapi.dr_W : 'w',
            getattr(idaapi, 'fl_U', 0) : '',
        }
    __mapper__[31] = '*'        # code 31 used internally by ida-minsc

    def __operator__(self, F, item):
        cls = self.__class__
        if isinstance(item, cls):
            res = F(self.S, item.S)
        elif isinstance(item, six.integer_types):
            res = F(self.S, cls.of(item))
        else:
            res = F(self.S, item)
        return cls.of_action(str().join(res)) if isinstance(res, set) else res

    def __hash__(self):
        return hash(self.F)
    def __or__(self, other):
        return self.__operator__(operator.or_, {item for item in other})
    def __and__(self, other):
        return self.__operator__(operator.and_, {item for item in other})
    def __xor__(self, other):
        return self.__operator__(operator.xor, {item for item in other})
    def __eq__(self, other):
        return self.__operator__(operator.eq, {item for item in other})
    def __ne__(self, other):
        return self.__operator__(operator.ne, {item for item in other})
    def __sub__(self, other):
        return self.__operator__(operator.sub, {item for item in other})
    def __contains__(self, type):
        if isinstance(type, six.integer_types):
            res = self.F & type
        else:
            res = operator.contains(self.S, type.lower())
        return True if res else False
    def __getitem__(self, type):
        if isinstance(type, six.integer_types):
            res = self.F & type
        else:
            res = operator.contains(self.S, type.lower())
        return True if res else False

    def __iter__(self):
        for item in sorted(self.S):
            yield item
        return

    def __repr__(self):
        return "reftype_t({:s})".format(str().join(sorted(self.S)))

    def __init__(self, xrtype, iterable):
        '''Construct a ``reftype_t`` using `xrtype` and any semantics specified in `iterable`.'''
        self.F = xrtype
        self.S = { item for item in iterable }

    @classmethod
    def of_type(cls, xrtype):
        '''Convert an IDA reference type in `xrtype` to a ``reftype_t``.'''
        if not isinstance(xrtype, six.integer_types):
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.of_type({!r}) : Refusing the coercion of a non-integral {!s} into the required type ({!s}).".format('.'.join([__name__, cls.__name__]), xrtype, xrtype.__class__, 'xrtype'))
        items = cls.__mapper__.get(xrtype, '')
        iterable = (item for item in items)
        return cls(xrtype, iterable)
    of = of_type

    @classmethod
    def of_action(cls, state):
        '''Convert a ``reftype_t`` in `state` back into an IDA reference type.'''
        if state == '*':
            return cls(31, '*')     # code 31 used internally by ida-minsc
        elif state == 'rw':
            state = 'w'

        # Verify that the state we were given can be iterated through.
        try:
            (item for item in state)

        except TypeError:
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.of_action({!r}) : Unable to coerce the requested state ({!r}) into a valid cross-reference type ({!s}).".format('.'.join([__name__, cls.__name__]), state, state, cls.__name__))

        # Search through our mapper for the correct contents of the reftype_t.
        res = { item for item in state }
        for F, t in cls.__mapper__.items():
            if { item for item in t } == res:
                return cls(F, res)
            continue
        resP = str().join(sorted(res))
        raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.of_action({!r}) : Unable to to coerce the requested state ({!r}) into a valid cross-reference type ({!s}).".format('.'.join([__name__, cls.__name__]), resP, resP, cls.__name__))

class ref_t(integerish):
    """
    This tuple is used to represent references that include an operand number
    and has the format `(address, opnum, reftype_t)`. The operand number is
    optional as not all references will provide it.
    """
    _fields = ('address', 'opnum', 'reftype')
    _types = (six.integer_types, (six.integer_types, None.__class__), reftype_t)
    _operands = (internal.utils.fcurry, internal.utils.fconstant, internal.utils.fconstant)

    @property
    def ea(self):
        '''Return the address field that is associated with the reference.'''
        res, _, _ = self
        return res

    def __int__(self):
        address, _, _ = self
        return address

    def __same__(self, other):
        _, num, state = self
        _, onum, ostate = other
        return all(this == that for this, that in [(num, onum), (state, ostate)])

    def __similar__(self, other):
        if isinstance(other, opref_t):
            _, num, state = self
            _, onum, ostate = other
            return any([num is None, num == onum]) and state & ostate
        return False

    def __repr__(self):
        cls, fields = self.__class__, {'address'}
        res = ("{!s}={:s}".format(internal.utils.string.escape(name, ''), ("{:#x}" if name in fields else "{!s}").format(value)) for name, value in zip(self._fields, self))
        return "{:s}({:s})".format(cls.__name__, ', '.join(res))

class opref_t(integerish):
    """
    This tuple is used to represent references that include an operand number
    and has the format `(address, opnum, reftype_t)`.
    """
    _fields = ('address', 'opnum', 'reftype')
    _types = (six.integer_types, six.integer_types, reftype_t)
    _operands = (internal.utils.fcurry, internal.utils.fconstant, internal.utils.fconstant)
    _formats = "{:#x}".format, "{!s}".format, "{!s}".format

    @property
    def ea(self):
        '''Return the address field that is associated with the operand being referenced.'''
        res, _, _ = self
        return res

    def __int__(self):
        address, _, _ = self
        return address

    def __same__(self, other):
        _, num, state = self
        _, onum, ostate = other
        return all(this == that for this, that in [(num, onum), (state, ostate)])

    def __similar__(self, other):
        if isinstance(other, ref_t):
            _, num, state = self
            _, onum, ostate = other
            return any([onum is None, num == onum]) and state & ostate
        return False

# XXX: is .startea always guaranteed to point to an instruction that modifies
#      the switch's register? if so, then we can use this to calculate the
#      .range/.cases more accurately instead of them being based on .elbase.
class switch_t(object):
    """
    This object is a wrapper around the ``idaapi.switch_info_ex_t`` class and
    allows for easily querying the semantics of the different attributes that
    are exposed by the switch_info_ex_t. A number of methods are provided
    which allow one to enumerate the valid case numbers, the handlers for them
    and any tables associated with the switch.
    """
    def __init__(self, switch_info_ex):
        self.object = switch_info_ex
    def __len__(self):
        '''Return the total number of cases (including any default) handled by the switch.'''
        return len(self.range)
    @property
    def ea(self):
        '''Return the address at the beginning of the switch.'''
        return self.object.startea
    @property
    def branch_ea(self):
        '''Return the address of the branch table.'''
        return self.object.jumps
    @property
    def table_ea(self):
        '''Return the address of the case or index table.'''
        return self.object.lowcase
    @property
    def default(self):
        '''Return the address that handles the default case.'''
        return self.object.defjump
    @property
    def branch(self):
        '''Return the contents of the branch table.'''
        import database, instruction

        # if we're an indirect switch, then we can grab our length from
        # the jcases property.
        if self.indirectQ():
            ea, count = self.object.jumps, self.object.jcases
            items = database.get.array(ea, length=count)

        # otherwise, we'll need to use the ncases property for the count.
        else:
            ea, count = self.object.jumps, self.object.ncases
            items = database.get.array(ea, length=count)

        # check that the result is a proper array with a typecode.
        if not hasattr(items, 'typecode'):
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.branch() : An invalid type ({!s}) was returned from the switch table at address {:#x}.".format(cls.__name__, items.__class__, ea))

        # last thing to do is to adjust each element from our items to
        # correspond to what's described by its refinfo_t.
        ri = address.refinfo(ea)

        # the refinfo_t's flags determine whether we need to subtract or
        # add the value from the refinfo_t.base.
        f = operator.sub if ri.is_subtract() else operator.add

        # now that we know what type of operation the refinfo_t is, use
        # it to translate the array's values into database addresses, and
        # then we can return them to the caller.
        return [f(ri.base, item) for item in items]
    @property
    def index(self):
        '''Return the contents of the case or index table.'''
        import database

        # if we're not an indirect switch, then the index table is empty.
        if not self.indirectQ():
            return database.get.array(self.object.jumps, length=0)

        # otherwise, we can simply read the array and return it.
        ea, count = self.object.lowcase, self.object.ncases
        return database.get.array(ea, length=count)
    @property
    def register(self):
        '''Return the register that the switch is based on.'''
        import instruction
        ri, rt = (self.object.regnum, self.object.regdtyp) if idaapi.__version__ < 7.0 else (self.object.regnum, self.object.regdtype)
        return instruction.architecture.by_indextype(ri, rt)
    @property
    def base(self):
        '''Return the base value (lowest index of cases) of the switch.'''
        return self.object.ind_lowcase if self.object.is_indirect() else 0
    @property
    def count(self):
        '''Return the number of cases in the switch.'''
        return self.object.ncases
    def indirectQ(self):
        '''Return whether the switch is using an indirection table or not.'''
        return self.object.is_indirect()
    def subtractQ(self):
        '''Return whether the switch performs a translation (subtract) on the index.'''
        return self.object.is_subtract()
    def case(self, case):
        '''Return the handler for a particular `case`.'''
        # return the ea of the specified case number
        # FIXME: check that this works with a different .ind_lowcase
        if case < self.base or case >= self.count + self.base:
            cls = self.__class__
            raise internal.exceptions.IndexOutOfBoundsError(u"{:s}.case({:d}) : The specified case ({:d}) was out of bounds ({:#x}<>{:#x}).".format(cls.__name__, case, case, self.base, self.base+self.count - 1))
        idx = case - self.base
        if self.indirectQ():
            idx = self.index[idx]
        return self.branch[idx]
    def handler(self, ea):
        '''Return all the cases that are handled by the address `ea` as a tuple.'''
        return tuple(case for case in self.range if self.case(case) == ea)
    @property
    def cases(self):
        '''Return all of the non-default cases in the switch.'''
        import instruction
        F = lambda ea, dflt=self.default: (ea == dflt) or (instruction.type.is_jmp(ea) and instruction.op(ea, 0) == dflt)
        return tuple(idx for idx in builtins.range(self.base, self.base + self.count) if not F(self.case(idx)))
    @property
    def range(self):
        '''Return all of the possible cases for the switch.'''
        return tuple(builtins.range(self.base, self.base + self.count))
    def __str__(self):
        cls = self.__class__
        if self.indirectQ():
            return "<class '{:s}{{{:d}}}' at {:#x}> default:*{:#x} branch[{:d}]:*{:#x} index[{:d}]:*{:#x} register:{!s}".format(cls.__name__, self.count, self.ea, self.default, self.object.jcases, self.object.jumps, self.object.ncases, self.object.lowcase, self.register)
        return "<class '{:s}{{{:d}}}' at {:#x}> default:*{:#x} branch[{:d}]:*{:#x} register:{!s}".format(cls.__name__, self.count, self.ea, self.default, self.object.ncases, self.object.jumps, self.register)
    def __unicode__(self):
        cls = self.__class__
        if self.indirectQ():
            return u"<class '{:s}{{{:d}}}' at {:#x}> default:*{:#x} branch[{:d}]:*{:#x} index[{:d}]:*{:#x} register:{!s}".format(cls.__name__, self.count, self.ea, self.default, self.object.jcases, self.object.jumps, self.object.ncases, self.object.lowcase, self.register)
        return u"<class '{:s}{{{:d}}}' at {:#x}> default:*{:#x} branch[{:d}]:*{:#x} register:{!s}".format(cls.__name__, self.count, self.ea, self.default, self.object.ncases, self.object.jumps, self.register)
    def __repr__(self):
        return u"{!s}".format(self)

def xiterate(ea, start, next):
    '''Utility function for iterating through idaapi's xrefs from `start` to `end`.'''
    addr = start(ea)
    while addr != idaapi.BADADDR:
        yield addr
        addr = next(ea, addr)
    return

def addressOfRuntimeOrStatic(func):
    """Used to determine if `func` is a statically linked address or a runtime-linked address.

    This returns a tuple of the format `(runtimeQ, address)` where
    `runtimeQ` is a boolean returning true if the symbol is linked
    during runtime and `address` is the address of the entrypoint.
    """
    import function
    try:
        fn = function.by(func)

    # otherwise, maybe it's an rtld symbol
    except internal.exceptions.FunctionNotFoundError as e:
        import database
        exc_info = sys.exc_info()

        # if func is not an address, then there ain't shit we can do
        if not isinstance(func, six.integer_types): six.reraise(*exc_info)

        # make sure that we're actually data
        if not database.type.is_data(func): six.reraise(*exc_info)

        # ensure that we're an import, otherwise throw original exception
        if idaapi.segtype(func) != idaapi.SEG_XTRN:
            six.reraise(*exc_info)

        # yep, we're an import
        return True, func

    # check if we're _not_ within a function. this is because in elf IDBs, IDA will
    # create a func_t over each import in the database. since we're trying to identify
    # code and trust FF_CODE for it, imports being considered functions with code in
    # them just completely fucks up everything...hence we need to explicitly check for it.
    ea = range.start(fn)
    if not function.within(ea):
        import database

        # if we're in a SEG_XTRN, then we're an import and this is a runtime-func.
        if idaapi.segtype(ea) != idaapi.SEG_XTRN:
            raise internal.exceptions.FunctionNotFoundError(u"addressOfRuntimeOrStatic({:#x}) : Unable to locate function by address.".format(ea))

        # ok, we found a mis-defined import (thx ida)
        return True, ea

    # nope, we're just a function with real executable code inside
    return False, ea

## internal enumerations that idapython missed
class fc_block_type_t(object):
    """
    This namespace contains a number of internal enumerations for
    ``idaapi.FlowChart`` that were missed by IDAPython. This can
    be used for checking the type of the various elements within
    an ``idaapi.FlowChart``.
    """
    fcb_normal = 0  # normal block
    fcb_indjump = 1 # block ends with indirect jump
    fcb_ret = 2     # return block
    fcb_cndret = 3  # conditional return block
    fcb_noret = 4   # noreturn block
    fcb_enoret = 5  # external noreturn block (does not belong to the function)
    fcb_extern = 6  # external normal block
    fcb_error = 7   # block passes execution past the function end

class map_t(object):
    """
    An object used for mapping names to an object. This is used for
    representing the registers available for an architecture.
    """
    __slots__ = ('__state__',)
    def __init__(self):
        object.__setattr__(self, '__state__', {})

    def __getattr__(self, name):
        if name.startswith('__'):
            return getattr(self.__class__, name)
        res = self.__state__
        if name in res:
            return res[name]
        raise AttributeError(name)

    def __setattr__(self, name, register):
        res = self.__state__
        return res.__setitem__(name, register)

    def __contains__(self, name):
        return name in self.__state__

    def __repr__(self):
        return "{!s} {:s}".format(self.__class__, internal.utils.string.repr(self.__state__))

class collect_t(object):
    """
    This type is used by coroutines in order to aggregate values
    that are yielded by coroutines. It implements the receiver
    part of a coroutine.
    """
    def __init__(self, cons, f):
        '''Constructs a type using `cons` as the constructor and a callable `f` used to coerce a value into the constructed type.'''
        self.__cons__, self.__agg__ = cons, f
        self.reset()

    def type(self):
        '''Return the constructor that is used for the state.'''
        return self.__cons__

    def reset(self):
        '''Reset the current state.'''
        self.__state__ = self.__cons__()
        return self

    def send(self, value):
        '''Given a `value`, aggregate it into the current state.'''
        f, state = self.__agg__, self.__state__
        self.__state__ = res = f(state, value)
        return res

    def get(self):
        '''Return the current state of the constructed type.'''
        return self.__state__

    def __repr__(self):
        t = self.__cons__
        return "{!s} {!s} -> {!r}".format(self.__class__, getattr(t, '__name__', t), self.__state__)

class architecture_t(object):
    """
    Base class to represent how IDA maps the registers and types
    returned from an operand to a register that's uniquely
    identifiable by the user.

    This is necessary as for some architectures IDA will not include all
    the register names and thus will use the same register index to
    represent two registers that are of different types. As an example,
    on the Intel processor module the `%al` and `%ax` regs are returned in
    the operand as an index to the "ax" string.

    Similarly on the 64-bit version of the processor module, all of the
    registers `%ax`, `%eax`, and `%rax` have the same index.
    """
    __slots__ = ('__register__', '__cache__',)
    r = register = property(fget=lambda s: s.__register__)

    def __init__(self, **cache):
        """Instantiate an ``architecture_t`` object which represents the registers available to an architecture.

        If `cache` is defined, then use the specified dictionary to map
        an IDA register's `(name, dtype)` to a string containing the
        more commonly recognized register name.
        """
        self.__register__, self.__cache__ = map_t(), cache.get('cache', {})

    def new(self, name, bits, idaname=None, **kwargs):
        '''Add a register to the architecture's cache.'''

        # older
        if idaapi.__version__ < 7.0:
            dtype_by_size = internal.utils.fcompose(idaapi.get_dtyp_by_size, six.byte2int)
            dt_bitfield = idaapi.dt_bitfild
        # newer
        else:
            dtype_by_size = idaapi.get_dtype_by_size
            dt_bitfield = idaapi.dt_bitfild

        #dtyp = kwargs.get('dtyp', idaapi.dt_bitfild if bits == 1 else dtype_by_size(bits//8))
        dtype = builtins.next((kwargs[item] for item in ['dtyp', 'dtype', 'type'] if item in kwargs), dt_bitfield if bits == 1 else dtype_by_size(bits // 8))
        ptype = builtins.next((kwargs[item] for item in ['ptype'] if item in kwargs), int)

        namespace = {key : value for key, value in register_t.__dict__.items()}
        namespace.update({'__name__':name, '__parent__':None, '__children__':{}, '__dtype__':dtype, '__position__':0, '__size__':bits, '__ptype__':ptype})
        namespace['realname'] = idaname
        namespace['alias'] = kwargs.get('alias', {item for item in []})
        namespace['architecture'] = self
        res = type(name, (register_t,), namespace)()
        self.__register__.__state__[name] = res
        key = name if idaname is None else idaname
        self.__cache__[key, dtype] = self.__cache__[key] = name
        return res

    def child(self, parent, name, position, bits, idaname=None, **kwargs):
        '''Add a child register to the architecture's cache.'''

        # older
        if idaapi.__version__ < 7.0:
            dtype_by_size = internal.utils.fcompose(idaapi.get_dtyp_by_size, six.byte2int)
            dt_bitfield = idaapi.dt_bitfild
        # newer
        else:
            dtype_by_size = idaapi.get_dtype_by_size
            dt_bitfield = idaapi.dt_bitfild

        dtype = builtins.next((kwargs[item] for item in ['dtyp', 'dtype', 'type'] if item in kwargs), dt_bitfield if bits == 1 else dtype_by_size(bits // 8))
        #dtyp = kwargs.get('dtyp', idaapi.dt_bitfild if bits == 1 else dtype_by_size(bits//8))
        ptype = builtins.next((kwargs[item] for item in ['ptype'] if item in kwargs), int)

        namespace = {key : value for key, value in register_t.__dict__.items() }
        namespace.update({'__name__':name, '__parent__':parent, '__children__':{}, '__dtype__':dtype, '__position__':position, '__size__':bits, '__ptype__':ptype})
        namespace['realname'] = idaname
        namespace['alias'] = kwargs.get('alias', {item for item in []})
        namespace['architecture'] = self
        res = type(name, (register_t,), namespace)()
        self.__register__.__state__[name] = res
        key = name if idaname is None else idaname
        self.__cache__[key, dtype] = self.__cache__[key] = name
        parent.__children__[position, ptype] = res
        return res

    def by_index(self, index):
        """Lookup a register according to its `index`.

        The default size is based on the architecture that IDA is using.
        """
        res = idaapi.ph.regnames[index]
        return self.by_name(res)
    byindex = internal.utils.alias(by_index)

    def by_indextype(self, index, dtype):
        """Lookup a register according to its `index` and `dtype`.

        Some examples of dtypes: idaapi.dt_byte, idaapi.dt_word, idaapi.dt_dword, idaapi.dt_qword
        """
        res = idaapi.ph.regnames[index]
        name = self.__cache__[res, dtype]
        return getattr(self.__register__, name)
    byindextype = internal.utils.alias(by_indextype)

    def by_name(self, name):
        '''Lookup a register according to its `name`.'''
        key = name[1:].lower() if name.startswith(('%', '$', '@')) else name.lower()    # at&t, mips, windbg
        if key in self.__register__ or hasattr(self.__register__, key):
            name = key
        elif key in self.__cache__:
            name = self.__cache__[key]
        else:
            cls = self.__class__
            raise internal.exceptions.RegisterNotFoundError(u"{:s}.by_name({!r}) : Unable to find a register with the given name \"{:s}\".".format('.'.join([cls.__module__, cls.__name__]), name, internal.utils.string.escape(name, '"')))
        return getattr(self.__register__, name)
    byname = internal.utils.alias(by_name)

    def by_indexsize(self, index, size):
        '''Lookup a register according to its `index` and `size`.'''
        dtype_by_size = internal.utils.fcompose(idaapi.get_dtyp_by_size, six.byte2int) if idaapi.__version__ < 7.0 else idaapi.get_dtype_by_size
        dtype = dtype_by_size(size)
        return self.by_indextype(index, dtype)
    byindexsize = internal.utils.alias(by_indexsize)

    def has(self, name):
        '''Check if a register with the given `name` exists.'''
        key = name[1:].lower() if name.startswith(('%', '$', '@')) else name.lower()    # at&t, mips, windbg
        return key in self.__cache__ or key in self.__register__ or hasattr(self.__register__, key)

    def promote(self, register, bits=None):
        '''Promote the specified `register` to its next larger size as specified by `bits`.'''
        parent = internal.utils.fcompose(operator.attrgetter('__parent__'), (lambda *items: items), functools.partial(filter, None), iter, next)
        try:
            if bits is None:
                return parent(register)
            return register if register.bits == bits else self.promote(parent(register), bits=bits)
        except StopIteration: pass
        cls = self.__class__
        if bits is None:
            raise internal.exceptions.RegisterNotFoundError(u"{:s}.promote({!s}{:s}) : Unable to promote the specified register ({!s}) to a size larger than {!r}.".format('.'.join([cls.__module__, cls.__name__]), register, '' if bits is None else ", bits={:d}".format(bits), register, register))
        raise internal.exceptions.RegisterNotFoundError(u"{:s}.promote({!s}{:s}) : Unable to find a register of the required number of bits ({:d}) to promote {!r}.".format('.'.join([cls.__module__, cls.__name__]), register, '' if bits is None else ", bits={:d}".format(bits), bits, register))

    def demote(self, register, bits=None, type=None):
        '''Demote the specified `register` to its next smaller size as specified by `bits`.'''
        childitems = internal.utils.fcompose(operator.attrgetter('__children__'), operator.methodcaller('items'))
        firsttype = internal.utils.fcompose(childitems, lambda items: ((key, value) for key, value in items if key[1] == type), iter, next, operator.itemgetter(1))
        firstchild = internal.utils.fcompose(childitems, functools.partial(sorted, key=internal.utils.fcompose(operator.itemgetter(0), operator.itemgetter(0))), iter, next, operator.itemgetter(1))
        try:
            if bits is None:
                return firstchild(register)
            return register if register.bits == bits else self.demote(firstchild(register), bits=bits)
        except StopIteration: pass
        cls = self.__class__
        if bits is None:
            raise internal.exceptions.RegisterNotFoundError(u"{:s}.demote({!s}{:s}) : Unable to demote the specified register ({!s}) to a size smaller than {!r}.".format('.'.join([cls.__module__, cls.__name__]), register, '' if bits is None else ", bits={:d}".format(bits), register, register))
        raise internal.exceptions.RegisterNotFoundError(u"{:s}.demote({!s}{:s}) : Unable to find a register of the required number of bits ({:d}) to demote {!r}.".format('.'.join([cls.__module__, cls.__name__]), register, '' if bits is None else ", bits={:d}".format(bits), bits, register))

class bounds_t(integerish):
    """
    This tuple is used to represent references that describe a bounds
    and has the format `(left, right)`.
    """
    _fields = ('left', 'right')
    _types = (six.integer_types, six.integer_types)
    _operands = (internal.utils.fcurry, internal.utils.fcurry)
    _formats = "{:#x}".format, "{:#x}".format

    def __new__(cls, *args, **kwargs):
        if len(args) == 2 and not kwargs:
            return super(bounds_t, cls).__new__(cls, *sorted(args))

        # create a mapping containing our individual fields given with our
        # arguments. the keyword parameters are given secondary priority to
        # any argument parameters.
        fields = {fld : item for fld, item in zip(cls._fields, args)}
        [ fields.setdefault(fld, kwargs.pop(fld)) for fld in cls._fields if fld in kwargs ]

        # if the size was provided, then we can use it to calculate the
        # right size of our boundaries.
        if all(item in fields for item in cls._fields) and 'size' in kwargs:
            raise TypeError("{!s}() got unexpected keyword argument{:s} {:s}".format(cls.__name__, '' if len(kwargs) == 1 else 's', ', '.join(map("'{!s}'".format, kwargs))))

        elif 'left' in fields and 'size' in kwargs:
            fields.setdefault('right', fields['left'] + kwargs.pop('size'))

        # at this point, we should have all our boundaries. it kwargs has
        # anything left in it or any required fields are not defined, then
        # raise an exception because invalid parameters were passed to us.
        if len(kwargs):
            raise TypeError("{!s}() got unexpected keyword argument{:s} {:s}".format(cls.__name__, '' if len(kwargs) == 1 else 's', ', '.join(map("'{!s}'".format, kwargs))))
        if any(item not in fields for item in cls._fields):
            available, required = ({item for item in items} for items in [fields, cls._fields])
            missing = required - available
            raise TypeError("{!s}() is missing required field{:s} {:s}".format(cls.__name__, '' if len(missing) == 1 else 's', ', '.join(map("'{!s}'".format, (item for item in cls._fields if item in missing)))))

        # now we can use our fields to construct our type properly.
        args = (fields[item] for item in cls._fields)
        return super(bounds_t, cls).__new__(cls, *sorted(args))

    @property
    def size(self):
        '''Return the size of the area described by this boundary.'''
        left, right = self
        return right - left if left < right else left - right

    @property
    def bits(self):
        '''Return the size of the area described by this boundary in bits.'''
        return 8 * self.size

    @property
    def type(self):
        '''Return the pythonic type that may contain this boundary.'''
        return [(int, 1), self.size]

    @property
    def top(self):
        '''Return the minimum address for the current boundary.'''
        left, right = self
        return min(left, right)

    @property
    def bottom(self):
        '''Return the maximum address for the current boundary.'''
        left, right = self
        return max(left, right)

    def range(self):
        '''Return the current boundary casted to a native ``idaapi.range_t`` type.'''
        left, right = sorted(self)
        return idaapi.area_t(left, right) if idaapi.__version__ < 7.0 else idaapi.range_t(left, right)

    def contains(self, ea):
        '''Return if the address `ea` is contained by the current boundary.'''
        left, right = sorted(self)
        if isinstance(ea, six.integer_types):
            return left <= ea <= right

        # compare against another boundary
        elif isinstance(ea, tuple):
            other_left, other_right = ea
            return all([left <= other_left, right >= other_right])

        # anything else is an invalid type
        raise internal.exceptions.InvalidTypeOrValueError(u"{!s}.contains({!s}) : Unable to check containment with the provided type ({!s}).".format(self, ea, ea.__class__))
    __contains__ = contains

    def overlaps(self, bounds):
        '''Return if the boundary `bounds` overlaps with the current boundary.'''
        left, right = sorted(self)
        if isinstance(bounds, six.integer_types):
            return left <= bounds <= right

        other_left, other_right = sorted(bounds)
        return all([left <= other_right, right >= other_left])

    def union(self, other):
        '''Return a union of the current boundary with `other`.'''
        if not isinstance(other, tuple):
            return super(bounds_t, self).__or__(other)
        (left, right), (other_left, other_right) = map(sorted, [self, other])
        return self.__class__(min(left, other_left), max(right, other_right))
    __or__ = union

    def intersection(self, other):
        '''Return an intersection of the current boundary with `other`.'''
        if not isinstance(other, tuple):
            return super(bounds_t, self).__and__(other)

        # if they don't overlap, then we can't intersect and so we bail.
        if not self.overlaps(other):
            raise internal.exceptions.InvalidTypeOrValueError(u"{!s}.intersection({!s}) : Unable to intersect with a non-overlapping boundary ({!s}).".format(self, other, other))

        (left, right), (other_left, other_right) = map(sorted, [self, other])
        return self.__class__(max(left, other_left), min(right, other_right))
    __and__ = intersection

    def __format__(self, spec):
        '''Return the current boundary as a string containing only the components that are inclusive to the range.'''
        if spec != 's':
            cls = self.__class__
            raise TypeError("unsupported format string ({!s}) passed to {:s}".format(spec, '.'.join([cls.__name__, '__format__'])))
        left, right = sorted(self)
        if left < right - 1:
            return "{:#x}..{:#x}".format(left, right - 1)
        return "{:#x}".format(left)

# FIXME: should probably be a register_t, but with the different attributes
class partialregister_t(namedtypedtuple, symbol_t):
    _fields = 'register', 'position', 'bits'
    _types = register_t, six.integer_types, six.integer_types
    _operands = internal.utils.fconstant, internal.utils.fcurry, internal.utils.fcurry

    def __hash__(self):
        cls = self.__class__
        register, position, bits = self
        return hash((cls, register, position, bits))

    @property
    def symbols(self):
        '''Yield the symbolic components that compose the register part.'''
        register, _, _ = self
        yield register

    @property
    def size(self):
        '''Return the size of the register part in bytes.'''
        _, _, bits = self
        return bits // 8

    @property
    def type(self):
        '''Return the pythonic type of the current register part.'''
        _, _, bits = self
        return builtins.int, bits // 8

    @property
    def bytes(self):
        '''Return the bytes that make up the value of the current register part.'''
        register, position, bits = self
        index, size = position // 8, bits // 8
        return register.bytes[index : index + size]

    def __int__(self):
        '''Return the integer value of the current register part.'''
        bytes = bytearray(self.bytes)
        return functools.reduce(lambda agg, item: agg * 0x100 + item, bytes, 0)

    def __float__(self):
        '''Return the floating-point value of the current register part.'''
        raise internal.exceptions.InvalidTypeOrValueError(u"{!s} : Unable to resolve as a floating-point number.".format(self, rv.rvtype))

class location_t(integerish):
    """
    This tuple is used to represent the size at a given location and has the format `(offset, size)`.
    """
    _fields = ('offset', 'size')
    _types = ((six.integer_types, register_t), six.integer_types)
    _operands = (internal.utils.fcurry, internal.utils.fconstant)
    _formats = lambda offset: "{:#x}".format(offset) if isinstance(offset, six.integer_types) else "{!s}".format(offset), "{:d}".format

    def __new__(cls, offset, size):
        return super(location_t, cls).__new__(cls, offset, max(0, size))

    def __int__(self):
        offset, size = self
        if isinstance(offset, six.integer_types):
            return offset

        elif isinstance(offset, symbol_t):
            symbol, = offset.symbols
            return int(offset)

        cls = self.__class__
        raise internal.exceptions.InvalidTypeOrValueError(u"{!s} : Unable to convert the location offset ({!s}) to an integer.".format(self, offset))

    def __same__(self, other):
        thisoffset, thissize = self
        thatoffset, thatsize = other
        return all([thisoffset == thatoffset, thissize == thatsize])

    @property
    def bits(self):
        '''Return the size of the location in bits.'''
        offset, size = self
        return 8 * size

    @property
    def symbols(self):
        '''Yield the symbolic components of this location.'''
        offset, size = self
        if not isinstance(offset, six.integer_types):
            yield offset
        return

    @property
    def type(self):
        '''Return the pythonic type describing this location.'''
        offset, size = self

        # if our size is in the typemap's integermap, then we can simply use it.
        if size in typemap.integermap:
            return int, size

        # otherwise, we need to form ourselves into an array of bytes.
        return [(int, 1), size]

    @property
    def bounds(self):
        '''Return the boundaries of the current location as a ``bounds_t``.'''
        offset, size = self
        if isinstance(offset, six.integer_types):
            return bounds_t(offset, offset + size)

        # If the offset is a symbol, then we can try for an integer if possible.
        elif isinstance(offset, symbol_t):
            symbol, = offset.symbols
            offset = int(offset)
            return bounds_t(offset, offset + size)

        raise internal.exceptions.InvalidTypeOrValueError(u"{!s} : Unable to convert the location offset ({!s}) to an integer.".format(self, offset))

    def range(self):
        '''Return the current location casted to a native ``idaapi.range_t`` type.'''
        return self.bounds.range()

    def contains(self, offset):
        '''Return if the given `offset` is contained by the current location.'''
        return self.bounds.contains(offset)
    __contains__ = contains

class phrase_t(integerish, symbol_t):
    """
    This tuple is used to represent a phrase relative to a register and has the format `(register, offset)`.
    """
    _fields = 'register', 'offset'
    _types = (register_t, partialregister_t), six.integer_types
    _operands = internal.utils.fconstant, internal.utils.fcurry
    _formats = "{!s}".format, "{:#x}".format

    def __hash__(self):
        cls = self.__class__
        register, offset = self
        return hash((cls, register, offset))

    @property
    def symbols(self):
        '''Yield the register part of the tuple.'''
        register, _ = self
        yield register

    def __int__(self):
        '''Return the offset part of the tuple.'''
        _, offset = self
        return offset

    def __same__(self, other):
        register, _ = self
        oregister, _ = other
        return any([register is None, oregister is None, register == oregister])

```

`base/_netnode.py`:

```py
"""
Netnode module (internal)

This module wraps IDA's netnode API and dumbs it down so that a user
can be mindless when reading/writing/enumerating data out of a netnode.
This is an internal module and is not expected to be used by the user.
"""

import six, operator
import idaapi

import internal

MAXSPECSIZE = idaapi.MAXSTR
MAXNAMESIZE = idaapi.MAXNAMELEN

class netnode(object):
    """
    This namespace is an interface to IDA's netnode api. This aims to provide a
    portable way of accessing a netnode between all the different variations and
    versions of IDA.
    """
    try:
        # ida 6.95 splits up their idaapi module into smaller namespaces
        import _ida_netnode
    except ImportError:
        # _ida_netnode has got to be in at least one of these idaapi modules...
        import idaapi as _ida_netnode
        if not hasattr(idaapi, 'new_netnode'):
            import _idaapi as _ida_netnode

    new = get = root = _ida_netnode.new_netnode
    delete = _ida_netnode.delete_netnode
    start = _ida_netnode.netnode_start
    end = _ida_netnode.netnode_end
    index = _ida_netnode.netnode_index
    kill = _ida_netnode.netnode_kill

    # We need the following api to explicitly look up a netnode by its address.
    if hasattr(_ida_netnode, 'exist'):
        exist = staticmethod(internal.utils.fcompose(_ida_netnode.new_netnode, _ida_netnode.exist))

    # If it didn't exist, though, then we need to call directly into the ida library.
    # We're fortunate here because netnodes are really just a pointer to an integer,
    # and the netnode_exist api takes a pointer and returns a straight-up boolean.
    else:
        import ctypes, ida
        ida.netnode_exist.restype, ida.netnode_exist.argtypes = ctypes.c_bool, [ctypes.POINTER(ctypes.c_long)]
        exist = staticmethod(internal.utils.fcompose(ctypes.c_long, ctypes.pointer, ida.netnode_exist))

    # There's a chance that this api doesn't exist in IDAPython, so if it does then
    # we can assign it as-is...otherwise we create a netnode with the desired name
    # and then see if we can grab its index to confirm its existence.
    if hasattr(_ida_netnode, 'netnode_exist'):
        exist_name = _ida_netnode.netnode_exist
    else:
        exist_name = staticmethod(internal.utils.fcompose(internal.utils.frpartial(_ida_netnode.new_netnode, False, 0), _ida_netnode.netnode_index, internal.utils.fpartial(operator.ne, idaapi.BADADDR)))

    # These apis should always exist and will hopefully never change.
    long_value = _ida_netnode.netnode_long_value
    next = _ida_netnode.netnode_next
    prev = _ida_netnode.netnode_prev
    rename = _ida_netnode.netnode_rename
    #copyto = _ida_netnode.netnode_copyto
    #create = _ida_netnode.netnode_create
    #moveto = _ida_netnode.netnode_moveto
    set = _ida_netnode.netnode_set
    set_long = _ida_netnode.netnode_set_long
    delvalue = _ida_netnode.netnode_delvalue

    blobsize = _ida_netnode.netnode_blobsize
    getblob = _ida_netnode.netnode_getblob
    setblob = _ida_netnode.netnode_setblob
    delblob = _ida_netnode.netnode_delblob

    altdel = _ida_netnode.netnode_altdel
    altlast = _ida_netnode.netnode_altlast
    altprev = _ida_netnode.netnode_altprev
    altset = _ida_netnode.netnode_altset
    altval = _ida_netnode.netnode_altval

    charlast = _ida_netnode.netnode_charlast
    charprev = _ida_netnode.netnode_charprev
    chardel = _ida_netnode.netnode_chardel
    charset = _ida_netnode.netnode_charset
    charval = _ida_netnode.netnode_charval

    hashdel = _ida_netnode.netnode_hashdel
    hashlast = _ida_netnode.netnode_hashlast
    hashprev = _ida_netnode.netnode_hashprev
    hashset = _ida_netnode.netnode_hashset
    hashset_buf = _ida_netnode.netnode_hashset_buf
    hashset_idx = _ida_netnode.netnode_hashset_idx
    hashstr = _ida_netnode.netnode_hashstr
    hashstr_buf = _ida_netnode.netnode_hashstr_buf
    hashval = _ida_netnode.netnode_hashval
    hashval_long = _ida_netnode.netnode_hashval_long

    supdel = _ida_netnode.netnode_supdel
    suplast = _ida_netnode.netnode_suplast
    supprev = _ida_netnode.netnode_supprev
    supset = _ida_netnode.netnode_supset
    supstr = _ida_netnode.netnode_supstr
    supval = _ida_netnode.netnode_supval

    valobj = _ida_netnode.netnode_valobj
    valstr = _ida_netnode.netnode_valstr
    value_exists = _ida_netnode.netnode_value_exists

    # now to fix up the version skew as a result of IDA 7.0
    if idaapi.__version__ < 7.0:
        supfirst = _ida_netnode.netnode_sup1st
        supnext = _ida_netnode.netnode_supnxt
        hashnext = _ida_netnode.netnode_hashnxt
        hashfirst = _ida_netnode.netnode_hash1st
        charfirst = _ida_netnode.netnode_char1st
        charnext = _ida_netnode.netnode_charnxt
        name = _ida_netnode.netnode_name
        altfirst = _ida_netnode.netnode_alt1st
        altnext = _ida_netnode.netnode_altnxt

    else:   # >= 7.0
        supfirst = _ida_netnode.netnode_supfirst
        supnext = _ida_netnode.netnode_supnext
        hashnext = _ida_netnode.netnode_hashnext
        hashfirst = _ida_netnode.netnode_hashfirst
        charfirst = _ida_netnode.netnode_charfirst
        charnext = _ida_netnode.netnode_charnext
        name = _ida_netnode.netnode_get_name
        altfirst = _ida_netnode.netnode_altfirst
        altnext = _ida_netnode.netnode_altnext

    # default tags (older versions of IDA use a char which we'll use as well)
    alttag = idaapi.atag
    suptag = idaapi.stag
    hashtag = idaapi.htag
    chartag = b'd' if idaapi.__version__ < 7.0 else 0x64    # found while reversing ida's shared library

class utils(object):
    """
    This namespace provides utilities for interacting with a netnode and each
    of the types that it may be composed of. Primarily, these functions allow
    one to iterate through the types contained within the netnode.
    """
    @classmethod
    def get(cls, index):
        '''Return the netnode for the provided `index`.'''
        return netnode.get(index)

    @classmethod
    def range(cls):
        '''Return the bounds of each netnode (nodeidx_t) within the database.'''
        this = netnode.root()
        ok, start = netnode.start(this), netnode.index(this)
        if not ok: raise internal.exceptions.NetNodeNotFoundError(u"{:s}.range() : Unable to find first node.".format('.'.join([__name__, cls.__name__])))
        ok, end = netnode.end(this), netnode.index(this)
        if not ok: raise internal.exceptions.NetNodeNotFoundError(u"{:s}.range() : Unable to find end node.".format('.'.join([__name__, cls.__name__])))
        return start, end

    @classmethod
    def renumerate(cls):
        '''Iterate through each netnode in the database in reverse order, and yield the (nodeidx_t, netnode*) for each item found.'''
        start, end = cls.range()
        this = netnode.root()
        ok = netnode.end(this)
        if not ok:
            raise internal.exceptions.NetNodeNotFoundError(u"{:s}.renumerate() : Unable to find the end node.".format('.'.join([__name__, cls.__name__])))

        yield end, cls.get(end)
        while end != start:
            ok = netnode.prev(this)
            if not ok: break
            end = netnode.index(this)
            yield end, cls.get(end)
        return

    @classmethod
    def fenumerate(cls):
        '''Iterate through each netnode in the database in order, and yield the (nodeidx_t, netnode*) for each item found.'''
        start, end = cls.range()
        this = netnode.root()
        ok = netnode.start(this)
        if not ok:
            raise internal.exceptions.NetNodeNotFoundError(u"{:s}.fenumerate() : Unable to find the start node.".format('.'.join([__name__, cls.__name__])))

        yield start, cls.get(start)
        while start != end:
            ok = netnode.next(this)
            if not ok: break
            start = netnode.index(this)
            yield start, cls.get(start)
        return

    @classmethod
    def valfiter(cls, node, first, last, next, val, tag):
        '''Iterate through all of the values for a netnode in order, and yield the (item, value) for each item that was found for the given tag.'''
        start, end = first(node, tag), last(node, tag)
        if start in {None, idaapi.BADADDR}: return
        yield start, val(node, start, tag)
        while start != end:
            start = next(node, start, tag)
            yield start, val(node, start, tag)
        return

    @classmethod
    def valriter(cls, node, first, last, prev, val, tag):
        '''Iterate through all of the values for a netnode in reverse order, and yield the (item, value) for each item that was found for the given tag.'''
        start, end = first(node, tag), last(node, tag)
        if end in {None, idaapi.BADADDR}: return
        yield end, val(node, end, tag)
        while end != start:
            end = prev(node, end, tag)
            yield end, val(node, end, tag)
        return

    @classmethod
    def hfiter(cls, node, first, last, next, val, tag):
        '''Iterate through all of the hash values for a netnode in order, and yield the (item, value) for each item that was found for the given tag.'''
        start, end = first(node, tag), last(node, tag)

        # If the start key is None, and it's the same as the end key, then we
        # need to verify that there's no value stored for the empty key. If
        # there's no value for the empty key, then we can be sure that there's
        # no keys to iterate through and thus we can leave.
        if start is None and start == end and val(node, start or '', tag) is None:
            return

        # Otherwise we need to start at the first item and continue fetching
        # the next key until we end up at the last one.
        yield start or '', val(node, start or '', tag)
        while start != end:
            start = next(node, start or '', tag)
            yield start or '', val(node, start or '', tag)
        return

    @classmethod
    def hriter(cls, node, first, last, prev, val, tag):
        '''Iterate through all of the hash values for a netnode in reverse order, and yield the (item, value) for each item that was found for the given tag.'''
        start, end = first(node, tag), last(node, tag)

        # If the end key is None, and it's the same as the start key, then we
        # need to verify that there's no value stored for the empty key. If
        # there's no value for the empty key, then we can be sure that there's
        # no keys to iterate through and thus we can leave.
        if end is None and start == end and val(node, end or '', tag) is None:
            return

        # Otherwise we need to start at the last item and continue fetching the
        # previous key until we end up at the first one.
        yield end or '', val(node, end or '', tag)
        while end != start:
            end = prev(node, end or '', tag)
            yield end or '', val(node, end or '', tag)
        return

    @classmethod
    def falt(cls, node, tag=netnode.alttag):
        '''Iterate through each "altval" for a given `node` in order, and yield each (item, value) that was found.'''
        for item in cls.valfiter(node, netnode.altfirst, netnode.altlast, netnode.altnext, netnode.altval, tag=tag):
            yield item
        return
    @classmethod
    def ralt(cls, node, tag=netnode.alttag):
        '''Iterate through each "altval" for a given `node` in reverse order, and yield each (item, value) that was found.'''
        for item in cls.valriter(node, netnode.altfirst, netnode.altlast, netnode.altprev, netnode.altval, tag=tag):
            yield item
        return

    @classmethod
    def fsup(cls, node, value=None, tag=netnode.suptag):
        '''Iterate through each "supval" for a given `node` in order, and yield each (item, value) that was found.'''
        for item in cls.valfiter(node, netnode.supfirst, netnode.suplast, netnode.supnext, value or netnode.supval, tag=tag):
            yield item
        return
    @classmethod
    def rsup(cls, node, value=None, tag=netnode.suptag):
        '''Iterate through each "supval" for a given `node` in reverse order, and yield each (item, value) that was found.'''
        for item in cls.valriter(node, netnode.supfirst, netnode.suplast, netnode.supprev, value or netnode.supval, tag=tag):
            yield item
        return

    @classmethod
    def fhash(cls, node, value=None, tag=netnode.hashtag):
        '''Iterate through each "hashval" for a given `node` in order, and yield each (item, value) that was found.'''
        for item in cls.hfiter(node, netnode.hashfirst, netnode.hashlast, netnode.hashnext, value or netnode.hashval, tag=tag):
            yield item
        return
    @classmethod
    def rhash(cls, node, value=None, tag=netnode.hashtag):
        '''Iterate through each "hashval" for a given `node` in reverse order, and yield each (item, value) that was found.'''
        for item in cls.hriter(node, netnode.hashfirst, netnode.hashlast, netnode.hashprev, value or netnode.hashval, tag=tag):
            yield item
        return

    @classmethod
    def fchar(cls, node, value=None, tag=netnode.chartag):
        '''Iterate through each "charval" for a given `node` in order, and yield each (item, value) that was found.'''
        for item in cls.valfiter(node, netnode.charfirst, netnode.charlast, netnode.charnext, value or netnode.charval, tag=tag):
            yield item
        return
    @classmethod
    def rchar(cls, node, value=None, tag=netnode.chartag):
        '''Iterate through each "charval" for a given `node` in reverse order, and yield each (item, value) that was found.'''
        for item in cls.valriter(node, netnode.charfirst, netnode.charlast, netnode.charprev, value or netnode.charval, tag=tag):
            yield item
        return

def new(name):
    '''Create a netnode with the given `name`, and return its identifier.'''
    res = internal.utils.string.to(name)
    node = netnode.new(res, len(res), True)
    return netnode.index(node)

def has(name):
    '''Return whether the netnode with the given `name` exists in the database or not.'''
    if isinstance(name, six.integer_types):
        return netnode.exist(name)
    res = internal.utils.string.to(name)
    return netnode.exist_name(res)

def get(name):
    '''Get (or create) a netnode with the given `name`, and return its identifier.'''
    if isinstance(name, six.integer_types):
        node = utils.get(name)
        node = name
    elif isinstance(name, six.string_types):
        res = internal.utils.string.to(name)
        node = netnode.get(res, len(res))
    else:
        node = name
    return netnode.index(node)

def remove(nodeidx):
    '''Remove the netnode with the identifier `nodeidx`.'''
    node = utils.get(nodeidx)
    return netnode.kill(node)

### node name
class name(object):
    """
    This namespace is used to interact with the naming information for a given netnode.
    """

    @classmethod
    def has(cls, nodeidx):
        '''Return whether the node identified by `nodeidx` has a name associated with it.'''
        node = utils.get(nodeidx)
        res = netnode.name(node)
        return res is not None
    @classmethod
    def get(cls, nodeidx):
        '''Return the name of the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        res = netnode.name(node)
        return internal.utils.string.of(res)
    @classmethod
    def set(cls, nodeidx, string):
        '''Set the name of the netnode identified by `nodeidx` to `string`.'''
        node = utils.get(nodeidx)
        res = internal.utils.string.to(string)
        return netnode.rename(node, res)

### node value (?)
class value(object):
    """
    This namespace is used to interact with the value for a given netnode.
    """

    @classmethod
    def has(cls, nodeidx):
        '''Return whether the node identified by `nodeidx` has a value associated with it.'''
        node = utils.get(nodeidx)
        return netnode.value_exists(node)
    exists = internal.utils.alias(has, 'value')

    @classmethod
    def get(cls, nodeidx, type=None):
        '''Return the value for the netnode identified by `nodeidx` casted to the provided `type`.'''
        node = utils.get(nodeidx)
        if not netnode.value_exists(node):
            return None

        if type in {None}:
            return netnode.valobj(node)
        elif issubclass(type, memoryview):
            res = netnode.valobj(node)
            return res and memoryview(res)
        elif issubclass(type, bytes):
            res = netnode.valstr(node)
            return res and bytes(res)
        elif issubclass(type, six.string_types):
            return netnode.valstr(node)
        elif issubclass(type, six.integer_types):
            return netnode.long_value(node)
        description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
        raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.get({:#x}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's value.".format('.'.join([__name__, cls.__name__]), description, type, type))

    @classmethod
    def set(cls, nodeidx, value):
        '''Set the value for the netnode identified by `nodeidx` to the provided `value`.'''
        node = utils.get(nodeidx)
        if isinstance(value, memoryview):
            return netnode.set(nodeidx, value.tobytes())
        elif isinstance(value, bytes):
            return netnode.set(node, value)
        elif isinstance(value, six.string_types):
            return netnode.set(node, value)
        elif isinstance(value, six.integer_types):
            return netnode.set_long(node, value)
        description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
        raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.set({:#x}, {!r}) : An unsupported type ({!r}) was specified for the netnode's value.".format('.'.join([__name__, cls.__name__]), description, value, value.__class__))

    @classmethod
    def remove(cls, nodeidx):
        '''Remove the value for the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.delvalue(node)

    @classmethod
    def repr(cls, nodeidx):
        '''Display the value for the netnode identified by `nodeidx`.'''
        if not cls.has(nodeidx):
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.repr({:s}) : The specified node ({:s}) does not have any value.".format('.'.join([__name__, cls.__name__]), description, description))
        res, string, value = cls.get(nodeidx), cls.get(nodeidx, type=bytes), cls.get(nodeidx, type=int)
        return "{!r} {!r} {:#x}".format(res, string, value)

### node blob
class blob(object):
    """
    This namespace is used to interact with the blob assigned to a given netnode.
    """
    @classmethod
    def has(cls, nodeidx, tag):
        '''Return whether the node identified by `nodeidx` has a blob associated with it.'''
        node = utils.get(nodeidx)
        res = netnode.blobsize(node, 0, tag)
        return res > 0

    @classmethod
    def get(cls, nodeidx, tag, start=0):
        """Return the blob stored in `tag` for the netnode identified by `nodeidx`.

        If an offset is provided as `start`, then return the bytes from the specified offset.
        """
        node = utils.get(nodeidx)
        sz = netnode.blobsize(node, start, tag)
        res = netnode.getblob(node, start, tag)
        return None if res is None else res[:sz]

    @classmethod
    def set(cls, nodeidx, tag, value, start=0):
        """Assign the data provided by `value` to the blob stored in `tag` for the netnode identified by `nodeidx`.

        If an offset is provided as `start`, then store the provided `value` at the given offset.
        """
        node = utils.get(nodeidx)
        return netnode.setblob(node, value.tobytes() if isinstance(value, memoryview) else value, start, tag)

    @classmethod
    def remove(cls, nodeidx, tag, start=0):
        """Remove the data from the blob stored in `tag` for the netnode identified by `nodeidx`.

        If an offset is provided as `start`, then remove the data at the given offset.
        """
        node = utils.get(nodeidx)
        return netnode.delblob(node, start, tag)

    @classmethod
    def size(cls, nodeidx, tag, start=0):
        """Return the size of the blob stored in `tag` for the netnode identified by `nodeidx`.

        If an offset is provided as `start`, then return the size from the given offset.
        """
        node = utils.get(nodeidx)
        return netnode.blobsize(node, start, tag)

    @classmethod
    def repr(cls, nodeidx, tag):
        '''Display the blob stored in `tag` for the netnode identified by `nodeidx`.'''
        if cls.size(nodeidx, tag) == 0:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.repr({:s}, {!r}) : The tag {!r} for the specified node ({:s}) does not have a blob.".format('.'.join([__name__, cls.__name__]), description, tag, tag, description))
        res = cls.get(nodeidx, tag)
        return "{!r}".format(res)

### node iteration
def fiter():
    '''Iterate through each netnode index from the database in order.'''
    for nodeidx, _ in utils.fenumerate():
        yield nodeidx
    return
def riter():
    '''Iterate through each netnode index from the database in reverse order.'''
    for nodeidx, _ in utils.renumerate():
        yield nodeidx
    return

def fitems():
    '''Iterate through each netnode index and node from the database in order.'''
    for nodeidx, item in utils.fenumerate():
        yield nodeidx, item
    return
def ritems():
    '''Iterate through each netnode index and node from the database in reverse order.'''
    for nodeidx, item in utils.renumerate():
        yield nodeidx, item
    return

### node altval : sparse array[integer] = integer
class alt(object):
    """
    This namespace is used for interacting with the sparse array stored
    within a given netnode. This sparse array is used to store integers,
    and is referred to by IDA as an "altval".
    """

    @classmethod
    def has(cls, nodeidx, index, tag=None):
        '''Return whether the netnode identified by `nodeidx` has an "altval" for the specified `index`.'''
        return any(index == idx for idx in cls.fiter(nodeidx, tag=tag))

    @classmethod
    def get(cls, nodeidx, index, tag=None):
        '''Return the integer at the `index` of the "altval" array belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.altval(node, index, netnode.alttag if tag is None else tag)

    @classmethod
    def set(cls, nodeidx, index, value, tag=None):
        '''Assign the integer `value` at the `index` of the "altval" array belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.altset(node, index, value, netnode.alttag if tag is None else tag)

    @classmethod
    def remove(cls, nodeidx, index, tag=None):
        '''Remove the integer from the specified `index` of the "altval" array belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.altdel(node, index, netnode.alttag if tag is None else tag)

    @classmethod
    def fiter(cls, nodeidx, tag=None):
        '''Iterate through all of the indexes of the "altval" array belonging to the netnode identified by `nodeidx` in order.'''
        node = utils.get(nodeidx)
        for nalt, _ in utils.falt(node, tag=netnode.alttag if tag is None else tag):
            yield nalt
        return

    @classmethod
    def fitems(cls, nodeidx, tag=None):
        '''Iterate through all of the elements of the "altval" array belonging to the netnode identified by `nodeidx` in order.'''
        node = utils.get(nodeidx)
        for nalt, altval in utils.falt(node, tag=netnode.alttag if tag is None else tag):
            yield nalt, altval
        return

    @classmethod
    def riter(cls, nodeidx, tag=None):
        '''Iterate through all of the indexes of the "altval" array belonging to the netnode identified by `nodeidx` in reverse order.'''
        node = utils.get(nodeidx)
        for nalt, _ in utils.ralt(node, tag=netnode.alttag if tag is None else tag):
            yield nalt
        return

    @classmethod
    def ritems(cls, nodeidx, tag=None):
        '''Iterate through all of the elements of the "altval" array belonging to the netnode identified by `nodeidx` in reverse order.'''
        node = utils.get(nodeidx)
        for nalt, altval in utils.ralt(node, tag=netnode.alttag if tag is None else tag):
            yield nalt, altval
        return

    @classmethod
    def repr(cls, nodeidx, tag=None):
        '''Display the "altval" array belonging to the netnode identified by `nodeidx`.'''
        res = []
        for index, value in cls.fitems(nodeidx, tag=tag):
            res.append("{0:x} : {1:#x} ({1:d})".format(index, value))
        if not res:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.repr({:s}) : The specified node ({:s}) does not have any altvals.".format('.'.join([__name__, cls.__name__]), description, description))
        return '\n'.join(res)

### node supval : sparse array[integer] = str * 1024
class sup(object):
    """
    This namespace is used for interacting with the sparse array stored
    within a given netnode. This sparse array is used to store bytes,
    and is referred to by IDA as a "supval".
    """

    MAX_SIZE = 0x400

    @classmethod
    def has(cls, nodeidx, index, tag=None):
        '''Return whether the netnode identified by `nodeidx` has a "supval" for the specified `index`.'''
        return any(index == item for item in cls.fiter(nodeidx, tag=tag))

    @classmethod
    def get(cls, nodeidx, index, type=None, tag=None):
        '''Return the value at the `index` of the "supval" array belonging to the netnode identified by `nodeidx` casted as the specified `type`.'''
        node = utils.get(nodeidx)
        if type in {None}:
            return netnode.supval(node, index, netnode.suptag if tag is None else tag)
        elif issubclass(type, memoryview):
            res = netnode.supval(node, index, netnode.suptag if tag is None else tag)
            return res and memoryview(res)
        elif issubclass(type, bytes):
            return netnode.supstr(node, index, netnode.suptag if tag is None else tag)
        elif issubclass(type, six.string_types):
            return netnode.supstr(node, index, netnode.suptag if tag is None else tag)
        description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
        raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.get({:#x}, {:#x}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's supval.".format('.'.join([__name__, cls.__name__]), description, index, type, type))

    @classmethod
    def set(cls, nodeidx, index, value, tag=None):
        '''Assign the provided `value` to the specified `index` of the "supval" array belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.supset(node, index, value.tobytes() if isinstance(value, memoryview) else value, netnode.suptag if tag is None else tag)

    @classmethod
    def remove(cls, nodeidx, index, tag=None):
        '''Remove the value at the specified `index` of the "supval" array belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.supdel(node, index, netnode.suptag if tag is None else tag)

    @classmethod
    def fiter(cls, nodeidx, tag=None):
        '''Iterate through all of the indexes of the "supval" array belonging to the netnode identified by `nodeidx` in order.'''
        node = utils.get(nodeidx)
        for nsup, _ in utils.fsup(node, tag=netnode.suptag if tag is None else tag):
            yield nsup
        return

    @classmethod
    def fitems(cls, nodeidx, type=None, tag=None):
        '''Iterate through all of the elements of the "supval" array belonging to the netnode identified by `nodeidx` in order.'''
        if type in {None}:
            value, transform = netnode.supval, internal.utils.fidentity
        elif issubclass(type, memoryview):
            value, transform = netnode.supval, memoryview
        elif issubclass(type, bytes):
            value, transform = netnode.supstr, internal.utils.fidentity
        elif issubclass(type, six.string_types):
            value, transform = netnode.supstr, internal.utils.fidentity
        else:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.fitems({:#x}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's supval.".format('.'.join([__name__, cls.__name__]), description, type, type))
        node = utils.get(nodeidx)
        for nsup, supval in utils.fsup(node, value, tag=netnode.suptag if tag is None else tag):
            yield nsup, transform(supval)
        return

    @classmethod
    def riter(cls, nodeidx, tag=None):
        '''Iterate through all of the indexes of the "supval" array belonging to the netnode identified by `nodeidx` in reverse order.'''
        node = utils.get(nodeidx)
        for nsup, _ in utils.rsup(node, tag=netnode.suptag if tag is None else tag):
            yield nsup
        return

    @classmethod
    def ritems(cls, nodeidx, type=None, tag=None):
        '''Iterate through all of the elements of the "supval" array belonging to the netnode identified by `nodeidx` in reverse order.'''
        if type in {None}:
            value, transform = netnode.supval, internal.utils.fidentity
        elif issubclass(type, memoryview):
            value, transform = netnode.supval, memoryview
        elif issubclass(type, bytes):
            value, transform = netnode.supstr, internal.utils.fidentity
        elif issubclass(type, six.string_types):
            value, transform = netnode.supstr, internal.utils.fidentity
        else:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.ritems({:#x}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's supval.".format('.'.join([__name__, cls.__name__]), description, type, type))
        node = utils.get(nodeidx)
        for nsup, supval in utils.rsup(node, value, tag=netnode.suptag if tag is None else tag):
            yield nsup, transform(supval)
        return

    @classmethod
    def repr(cls, nodeidx, tag=None):
        '''Display the "supval" array belonging to the netnode identified by `nodeidx`.'''
        res = []
        for index, item in enumerate(cls.fiter(nodeidx, tag=tag)):
            value = cls.get(nodeidx, item, tag=tag)
            res.append("[{:d}] {:x} : {!r}".format(index, item, value))
        if not res:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.repr({:s}) : The specified node ({:s}) does not have any supvals.".format('.'.join([__name__, cls.__name__]), description, description))
        return '\n'.join(res)

### node hashval : sparse dictionary[str * 510] = str * 1024
class hash(object):
    """
    This namespace is used for interacting with the dictionary stored
    within a given netnode. This dictionary is keyed by bytes of a
    maximum length of 510, and is used to store bytes of a maximum
    length of 1024. IDA refers to this dictionary as a "hashval".
    """

    @classmethod
    def has(cls, nodeidx, key, tag=None):
        '''Return whether the netnode identified by `nodeidx` has a "hashval" for the specified `key`.'''
        return any(key == item for item in cls.fiter(nodeidx, tag=tag))

    @classmethod
    def get(cls, nodeidx, key, type=None, tag=None):
        '''Return the value for the provided `key` of the "hashval" dictionary belonging to the netnode identified by `nodeidx` casted as the specified `type`.'''
        node = utils.get(nodeidx)
        if type in {None}:
            return netnode.hashval(node, key, netnode.hashtag if tag is None else tag)
        elif issubclass(type, memoryview):
            res = netnode.hashval(node, key, netnode.hashtag if tag is None else tag)
            return res and memoryview(res)
        elif issubclass(type, bytes):
            res = netnode.hashval(node, key, netnode.hashtag if tag is None else tag)
            return res and bytes(res)
        elif issubclass(type, six.string_types):
            return netnode.hashstr(node, key, netnode.hashtag if tag is None else tag)
        elif issubclass(type, six.integer_types):
            return netnode.hashval_long(node, key, netnode.hashtag if tag is None else tag)
        description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
        raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.get({:#x}, {!r}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's hash.".format('.'.join([__name__, cls.__name__]), description, key, type, type))

    @classmethod
    def set(cls, nodeidx, key, value, tag=None):
        '''Assign the provided `value` to the specified `key` for the "hashval" dictionary belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        # in my testing the type really doesn't matter
        if isinstance(value, memoryview):
            return netnode.hashset(node, key, value.tobytes(), netnode.hashtag if tag is None else tag)
        elif isinstance(value, bytes):
            return netnode.hashset(node, key, value, netnode.hashtag if tag is None else tag)
        elif isinstance(value, six.string_types):
            return netnode.hashset_buf(node, key, value, netnode.hashtag if tag is None else tag)
        elif isinstance(value, six.integer_types):
            return netnode.hashset_idx(node, key, value, netnode.hashtag if tag is None else tag)
        description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
        raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.set({:#x}, {!r}, {!r}) : An unsupported type ({!r}) was specified for the netnode's hash.".format('.'.join([__name__, cls.__name__]), description, key, value, type(value)))

    @classmethod
    def remove(cls, nodeidx, key, tag=None):
        '''Remove the value assigned to the specified `key` of the "hashval" dictionary belonging to the netnode identified by `nodeidx`.'''
        node = utils.get(nodeidx)
        return netnode.hashdel(node, key, netnode.hashtag if tag is None else tag)

    @classmethod
    def fiter(cls, nodeidx, tag=None):
        '''Iterate through all of the keys of the "hashval" dictionary belonging to the netnode identified by `nodeidx` in order.'''
        node = utils.get(nodeidx)
        for idx, _ in utils.fhash(node, tag=netnode.hashtag if tag is None else tag):
            yield idx
        return

    @classmethod
    def fitems(cls, nodeidx, type=None, tag=None):
        '''Iterate through all of the elements of the "hashval" dictionary belonging to the netnode identified by `nodeidx` in order.'''
        if type in {None}:
            value, transform = netnode.hashval, internal.utils.fidentity
        elif issubclass(type, memoryview):
            value, transform = netnode.hashval, memoryview
        elif issubclass(type, bytes):
            value, transform = netnode.hashval, bytes
        elif issubclass(type, six.string_types):
            value, transform = netnode.hashstr, internal.utils.fidentity
        elif issubclass(type, six.integer_types):
            value, transform = netnode.hashval_long, internal.utils.fidentity
        else:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.fitems({:#x}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's hash.".format('.'.join([__name__, cls.__name__]), description, type, type))
        node = utils.get(nodeidx)
        for idx, hashval in utils.fhash(node, value, tag=netnode.hashtag if tag is None else tag):
            yield idx, transform(hashval)
        return

    @classmethod
    def riter(cls, nodeidx, tag=None):
        '''Iterate through all of the keys of the "hashval" dictionary belonging to the netnode identified by `nodeidx` in reverse order.'''
        node = utils.get(nodeidx)
        for idx, _ in utils.rhash(node, tag=netnode.hashtag if tag is None else tag):
            yield idx
        return

    @classmethod
    def ritems(cls, nodeidx, type=None, tag=None):
        '''Iterate through all of the elements of the "hashval" dictionary belonging to the netnode identified by `nodeidx` in reverse order.'''
        if type in {None}:
            value, transform = netnode.hashval, internal.utils.fidentity
        elif issubclass(type, memoryview):
            value, transform = netnode.hashval, memoryview
        elif issubclass(type, bytes):
            value, transform = netnode.hashval, bytes
        elif issubclass(type, six.string_types):
            value, transform = netnode.hashstr, internal.utils.fidentity
        elif issubclass(type, six.integer_types):
            value, transform = netnode.hashval_long, internal.utils.fidentity
        else:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.ritems({:#x}, type={!r}) : An unsupported type ({!r}) was requested for the netnode's hash.".format('.'.join([__name__, cls.__name__]), description, type, type))
        node = utils.get(nodeidx)
        for idx, hashval in utils.rhash(node, value, tag=netnode.hashtag if tag is None else tag):
            yield idx, transform(hashval)
        return

    @classmethod
    def repr(cls, nodeidx, tag=None):
        '''Display the "hashval" dictionary belonging to the netnode identified by `nodeidx`.'''
        res = []
        try:
            l1 = max(len(key or '') for key in cls.fiter(nodeidx, tag=tag))
            l2 = max(len("{!r}".format(cls.get(nodeidx, key, tag=tag))) for key in cls.fiter(nodeidx, tag=tag))
        except ValueError:
            l1, l2 = 0, 2

        for index, key in enumerate(cls.fiter(nodeidx, tag=tag)):
            value = "{:<{:d}s} : default={!r}, bytes={!r}, int={:#x}({:d})".format("{!r}".format(cls.get(nodeidx, key, tag=tag)), l2, cls.get(nodeidx, key, None, tag=tag), cls.get(nodeidx, key, bytes, tag=tag), cls.get(nodeidx, key, int, tag=tag), cls.get(nodeidx, key, int, tag=tag))
            res.append("[{:d}] {:<{:d}s} -> {:s}".format(index, key, l1, value))
        if not res:
            description = "{:#x}".format(nodeidx) if isinstance(nodeidx, six.integer_types) else "{!r}".format(nodeidx)
            raise internal.exceptions.MissingTypeOrAttribute(u"{:s}.repr({:s}) : The specified node ({:s}) does not have any hashvals.".format('.'.join([__name__, cls.__name__]), description, description))
        return '\n'.join(res)

# FIXME: implement a file-allocation-table based filesystem using the netnode wrappers defined above
class filesystem(object):
    ALLOCATION_TABLE = '$ file-allocation-table'
    SECTOR_TABLE = '$ sector-table'
    SECTOR = 1024
    def __init__(self, name):
        node = idaapi.netnode(name, 0, True)

```

`base/_utils.py`:

```py
"""
Utilities module (internal)

This module contains a number of tools that help with the interface for this
plugin. This contains things such as the multicase decorator, the matcher
class for querying and filtering lists of things, support for aliasing
functions, and a number of functional programming primitives (combinators).
"""

import six, builtins

import os, logging, types, weakref
import functools, operator, itertools
import sys, codecs, heapq, collections, array, math

import internal
import idaapi, ida, ctypes

__all__ = ['fpack','funpack','fcar','fcdr','finstance','fhasitem','fitemQ','fgetitem','fitem','fsetitem','fdelitem','fhasattr','fattributeQ','fgetattr','fattribute','fsetattr','fsetattribute','fconstant','fdefault','fidentity','first','second','third','last','fcompose','fdiscard','fcondition','fmap','flazy','fpartial','fapply','fcurry','frpartial','freverse','fcatch','fcomplement','fnot','ilist','liter','ituple','titer','itake','iget','islice','imap','ifilter','ichain','izip','lslice','lmap','lfilter','lzip','count']

### functional programming combinators (FIXME: probably better to document these with examples)

# return a closure that executes `F` with the arguments boxed and concatenated.
fpack = lambda F, *a, **k: lambda *ap, **kp: F(a + ap, **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that executes `F` with all of its arguments concatenated and unboxed.
funpack = lambda F, *a, **k: lambda *ap, **kp: F(*(a + functools.reduce(operator.add, builtins.map(builtins.tuple, ap), ())), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that executes `F` with only its first argument.
fcar = lambda F, *a, **k: lambda *ap, **kp: F(*(a + ap[:1]), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that executes `F` with all of it arguments but the first.
fcdr = lambda F, *a, **k: lambda *ap, **kp: F(*(a + ap[1:]), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that will check that `object` is an instance of `type`.
finstance = lambda *type: frpartial(builtins.isinstance, type)
# return a closure that will check if its argument has an item `key`.
fhasitem = fitemQ = lambda key: frpartial(operator.contains, key)
# return a closure that will get a particular element from an object.
fgetitem = fitem = lambda item, *default: lambda object: default[0] if default and item not in object else object[item]
# return a closure that will set a particular element on an object.
fsetitem = lambda item: lambda value: lambda object: operator.setitem(object, item, value) or object
# return a closure that will remove a particular element from an object and return the modified object
fdelitem = lambda *items: fcompose(fmap(fidentity, *[fcondition(fhasitem(item))(frpartial(operator.delitem, item), None) for item in items]), builtins.iter, builtins.next)
# return a closure that will check if its argument has an `attribute`.
fhasattr = fattributeQ = lambda attribute: frpartial(builtins.hasattr, attribute)
# return a closure that will get a particular attribute from an object.
fgetattr = fattribute = lambda attribute, *default: lambda object: getattr(object, attribute, *default)
# return a closure that will set a particular attribute on an object.
fsetattr = fsetattribute = lambda attribute: lambda value: lambda object: builtins.setattr(object, attribute, value) or object
# return a closure that always returns `object`.
fconstant = fconst = falways = lambda object: lambda *a, **k: object
# a closure that returns its argument always.
fidentity = lambda object: object
# a closure that returns a default value if its object is false-y
fdefault = lambda default: lambda object: object or default
# return the first, second, or third item of a box.
first, second, third, last = operator.itemgetter(0), operator.itemgetter(1), operator.itemgetter(2), operator.itemgetter(-1)
# return a closure that executes a list of functions one after another from left-to-right.
fcompose = lambda *Fa: functools.reduce(lambda F1, F2: lambda *a: F1(F2(*a)), builtins.reversed(Fa))
# return a closure that executes function `F` whilst discarding any arguments passed to it.
fdiscard = lambda F, *a, **k: lambda *ap, **kp: F(*a, **k)
# return a closure that executes function `crit` and then returns/executes `f` or `t` based on whether or not it's successful.
fcondition = lambda crit: lambda t, f: \
    lambda *a, **k: (t(*a, **k) if builtins.callable(t) else t) if crit(*a, **k) else (f(*a, **k) if builtins.callable(f) else f)
# return a closure that takes a list of functions to execute with the provided arguments
fmap = lambda *Fa: lambda *a, **k: builtins.tuple(F(*a, **k) for F in Fa)
#lazy = lambda F, state={}: lambda *a, **k: state[(F, a, builtins.tuple(builtins.sorted(k.items())))] if (F, a, builtins.tuple(builtins.sorted(k.items()))) in state else state.setdefault((F, a, builtins.tuple(builtins.sorted(k.items()))), F(*a, **k))
#lazy = lambda F, *a, **k: lambda *ap, **kp: F(*(a + ap), **{ key : value for key, value in itertools.chain(k.items(), kp.items())})
# return a memoized closure that's lazy and only executes when evaluated
def flazy(F, *a, **k):
    sortedtuple, state = fcompose(builtins.sorted, builtins.tuple), {}
    def lazy(*ap, **kp):
        A, K = a + ap, sortedtuple(builtins.tuple(k.items()) + builtins.tuple(kp.items()))
        return state[(A, K)] if (A, K) in state else state.setdefault((A, K), F(*A, **{ key : value for key, value in itertools.chain(k.items(), kp.items()) }))
    return lazy
# return a closure with the function's arglist partially applied
fpartial = functools.partial
# return a closure that applies the provided arguments to the function `F`.
fapply = lambda F, *a, **k: lambda *ap, **kp: F(*(a + ap), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that will use the specified arguments to call the provided function.
fcurry = lambda *a, **k: lambda F, *ap, **kp: F(*(a + ap), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that applies the initial arglist to the end of function `F`.
frpartial = lambda F, *a, **k: lambda *ap, **kp: F(*(ap + builtins.tuple(builtins.reversed(a))), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that applies the arglist to function `F` in reverse.
freverse = lambda F, *a, **k: lambda *ap, **kp: F(*builtins.reversed(a + ap), **{ key : value for key, value in itertools.chain(k.items(), kp.items()) })
# return a closure that executes function `F` and includes the caught exception (or None) as the first element in the boxed result.
def fcatch(F, *a, **k):
    def fcatch(*a, **k):
        try: return None, F(*a, **k)
        except: return sys.exc_info()[1], None
    return functools.partial(fcatch, *a, **k)
# boolean inversion of the result of a function
fcomplement = fnot = frpartial(fcompose, operator.not_)
# converts a list to an iterator, or an iterator to a list
ilist, liter = fcompose(builtins.iter, builtins.list), fcompose(builtins.list, builtins.iter)
# converts a tuple to an iterator, or an iterator to a tuple
ituple, titer = fcompose(builtins.iter, builtins.tuple), fcompose(builtins.tuple, builtins.iter)
# take `count` number of elements from an iterator
itake = lambda count: fcompose(builtins.iter, fmap(*[builtins.next] * count), builtins.tuple)
# get the `nth` element from an iterator
iget = lambda count: fcompose(builtins.iter, fmap(*[builtins.next] * count), builtins.tuple, operator.itemgetter(-1))
# copy from itertools
islice, imap, ifilter, ichain, izip = itertools.islice, fcompose(builtins.map, builtins.iter), fcompose(builtins.filter, builtins.iter), itertools.chain, fcompose(builtins.zip, builtins.iter)
# restoration of the Py2-compatible list types
lslice, lmap, lfilter, lzip = fcompose(itertools.islice, builtins.list), fcompose(builtins.map, builtins.list), fcompose(builtins.filter, builtins.list), fcompose(builtins.zip, builtins.list)
# count number of elements of a container
count = fcompose(builtins.iter, builtins.list, builtins.len)

# cheap pattern-like matching
class Pattern(object):
    '''Base class for fake pattern matching against a tuple.'''
    def __eq__(self, other):
        return self.__cmp__(other) == 0
    __call__ = __eq__
    def __repr__(self):
        return 'Pattern()'
class PatternAny(Pattern):
    '''Object for matching against anything it is compared against.'''
    def __cmp__(self, other):
        return 0
    def __repr__(self):
        return "{:s}({:s})".format('Pattern', '*')
class PatternAnyType(Pattern):
    '''Object for matching against any type it is compared against.'''
    def __init__(self, *other):
        self.types = other
    def __cmp__(self, other):
        return 0 if isinstance(other, self.types) else -1
    def __types__(self):
        items = {item for item in []}
        for item in self.types:
            if isinstance(item, (builtins.list, builtins.tuple, builtins.set)):
                for item in item:
                    items |= {item.__name__}
                continue
            items |= {item.__name__}
        return sorted(items)
    def __repr__(self):
        return "{:s}({:s})".format('Pattern', '|'.join(self.__types__()))

### compatibility namespace
class pycompat(object):
    class function_2x(object):
        @classmethod
        def new(cls, code, globals, name, argdefs, closure):
            return types.FunctionType(code, globals, name, argdefs, closure)

        @classmethod
        def name(cls, object):
            return object.func_name
        @classmethod
        def set_name(cls, object, name):
            result, object.func_name = object.func_name, name
            return result

        @classmethod
        def documentation(cls, object):
            return object.func_doc
        @classmethod
        def set_documentation(cls, object, string):
            result, object.func_doc = object.func_doc, string
            return result

        @classmethod
        def defaults(cls, object):
            return object.func_defaults
        @classmethod
        def globals(cls, object):
            return object.func_globals
        @classmethod
        def closure(cls, object):
            return object.func_closure
        @classmethod
        def code(cls, object):
            return object.func_code

    class function_3x(function_2x):
        @classmethod
        def name(cls, object):
            return object.__name__
        @classmethod
        def set_name(cls, object, name):
            result, object.__name__ = object.__name__, name
            return result

        @classmethod
        def documentation(cls, object):
            return object.__doc__
        @classmethod
        def set_documentation(cls, object, string):
            result, object.__doc__ = object.__doc__, string
            return result

        @classmethod
        def defaults(cls, object):
            return object.__defaults__
        @classmethod
        def globals(cls, object):
            return object.__globals__
        @classmethod
        def closure(cls, object):
            return object.__closure__
        @classmethod
        def code(cls, object):
            return object.__code__

    function = function_2x if sys.version_info.major < 3 else function_3x

    class code_2x(object):
        @classmethod
        def name(cls, object):
            return object.co_name
        @classmethod
        def flags(cls, object):
            return object.co_flags
        @classmethod
        def argcount(cls, object):
            return object.co_argcount
        @classmethod
        def varnames(cls, object):
            return object.co_varnames

        cons = collections.namedtuple('code_t', ['co_argcount', 'co_nlocals', 'co_stacksize', 'co_flags', 'co_code', 'co_consts', 'co_names', 'co_varnames', 'co_filename', 'co_name', 'co_firstlineno', 'co_lnotab', 'co_freevars', 'co_cellvars'])
        @classmethod
        def unpack(cls, object):
            return cls.cons(*(getattr(object, item) for item in cls.cons._fields))
        @classmethod
        def unpack_extra(cls, object):
            return ()
        @classmethod
        def new(cls, attributes, extra=()):
            argcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars = attributes
            return types.CodeType(*attributes)

    class code_37(code_2x):
        @classmethod
        def unpack_extra(cls, object):
            return object.co_kwonlyargcount,
        @classmethod
        def new(cls, attributes, extra=(0,)):
            argcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars = attributes
            kwonlyargcount, = extra
            return types.CodeType(argcount, kwonlyargcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars)

    class code_38(code_2x):
        @classmethod
        def unpack_extra(cls, object):
            return object.co_posonlyargcount, object.co_kwonlyargcount
        @classmethod
        def new(cls, attributes, extra=(0, 0)):
            argcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars = attributes
            posonlyargcount, kwonlyargcount = extra
            return types.CodeType(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars)

    class code_311(code_2x):
        @classmethod
        def unpack_extra(cls, object):
            return object.co_posonlyargcount, object.co_kwonlyargcount, object.co_qualname, object.co_exceptiontable
        @classmethod
        def new(cls, attributes, extra=(0, 0, str(), bytes())):
            argcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars, cellvars = attributes
            posonlyargcount, kwonlyargcount, qualname, exceptiontable = extra
            return types.CodeType(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, qualname or name, firstlineno, lnotab, exceptiontable, freevars, cellvars)

    code = code_2x if sys.version_info.major < 3 else code_37 if (sys.version_info.major, sys.version_info.minor) < (3, 8) else code_38 if (sys.version_info.major, sys.version_info.minor) < (3, 11) else code_311

    class method_2x(object):
        @classmethod
        def new(cls, function, instance, type):
            return types.MethodType(function, instance, type)

        @classmethod
        def self(cls, object):
            return object.im_self

        @classmethod
        def type(cls, object):
            return object.im_class

        @classmethod
        def function(cls, object):
            return object.im_func

    class method_3x(object):
        @classmethod
        def new(cls, function, instance, type=None):
            return types.MethodType(function, instance)

        @classmethod
        def self(cls, object):
            return object.__self__

        @classmethod
        def type(cls, object):
            return object.__self__.__class__

        @classmethod
        def function(cls, object):
            return object.__func__

    method = method_2x if sys.version_info.major < 3 else method_3x

    class co_flags_2x(object):
        CO_OPTIMIZED                = 0x00001
        CO_NEWLOCALS                = 0x00002
        CO_VARARGS                  = 0x00004
        CO_VARKEYWORDS              = 0x00008
        CO_NESTED                   = 0x00010
        CO_GENERATOR                = 0x00020
        CO_NOFREE                   = 0x00040

        CO_ITERABLE_COROUTINE       = 0x00100
        CO_GENERATOR_ALLOWED        = 0x01000
        CO_FUTURE_DIVISION          = 0x02000
        CO_FUTURE_ABSOLUTE_IMPORT   = 0x04000
        CO_FUTURE_WITH_STATEMENT    = 0x08000
        CO_FUTURE_PRINT_FUNCTION    = 0x10000
        CO_FUTURE_UNICODE_LITERALS  = 0x20000

    class co_flags_3x(co_flags_2x):
        CO_COROUTINE                = 0x00080
        CO_FUTURE_BARRY_AS_BDFL     = 0x40000
        CO_FUTURE_GENERATOR_STOP    = 0x80000

    class co_flags_311(co_flags_2x):
        CO_COROUTINE                = 0x0000080
        CO_ITERABLE_COROUTINE       = 0x0000100
        CO_ASYNC_GENERATOR          = 0x0000200

        CO_FUTURE_DIVISION          = 0x0020000
        CO_FUTURE_ABSOLUTE_IMPORT   = 0x0040000
        CO_FUTURE_WITH_STATEMENT    = 0x0080000
        CO_FUTURE_PRINT_FUNCTION    = 0x0100000
        CO_FUTURE_UNICODE_LITERALS  = 0x0200000

        CO_FUTURE_BARRY_AS_BDFL     = 0x0400000
        CO_FUTURE_GENERATOR_STOP    = 0x0800000
        CO_FUTURE_ANNOTATIONS       = 0x1000000

    co_flags = co_flags_2x if sys.version_info.major < 3 else co_flags_3x if sys.version_info.minor < 11 else co_flags_311

### decorators
class priority_tuple(object):
    """
    This class simulates a tuple because Python3's heapq implementation is
    fucking stupid and ignores the priority that we use in the tuple for
    sorting the values in the heapq.
    """
    def __init__(self, priority, items):
        self.priority, self.items = priority, items

    def __iter__(self):
        yield self.priority
        yield self.items

    def __cmp__(self, other):
        return cmp(self.priority, other.priority)
    def __lt__(self, other):
        return self.priority < other.priority
    def __gt__(self, other):
        return self.priority > other.priority

class multicase(object):
    """
    A lot of magic is in this class which allows one to define multiple cases
    for a single function.
    """
    cache_name = '__multicase_cache__'

    def __new__(cls, *other, **t_args):
        '''Decorate a case of a function with the specified types.'''
        def result(wrapped):

            # First we need to extract the function from whatever type it is
            # so that we can read any properties we need from it. We also extract
            # its "constructor" so that we can re-create it after we've processed it.
            cons, func = cls.reconstructor(wrapped), cls.ex_function(wrapped)

            # Next we need to extract all of the argument information from it. We
            # also need to determine whether it's a special type of some sort so
            # that we know that its first argument is irrelevant to our needs. We
            # also check to see if it's using the magic name "__new__" which takes
            # an implicit parameter that gets passed to it.
            args, defaults, (star, starstar) = cls.ex_args(func)
            s_args = 1 if isinstance(wrapped, (classmethod, types.MethodType)) or func.__name__ in {'__new__'} else 0

            # If the user decorated us whilst explicitly providing the previous
            # function that this case is a part of, then make sure that we use it.
            if len(other):
                ok, prev = True, other[0]

            # If we weren't given a function, then we need to be tricky and search
            # through our parent frame's locals. Hopefully it's using the same name.
            elif pycompat.function.name(func) in sys._getframe().f_back.f_locals:
                ok, prev = True, sys._getframe().f_back.f_locals[pycompat.function.name(func)]

            # Otherwise, we've hit first blood and this is the very first definition
            # of the function. This requires us to do some construction later.
            else:
                ok = False

            # So if we found an already-existing wrapper, then we need to steal its cache.
            res = ok and cls.ex_function(prev)
            if ok and hasattr(res, cls.cache_name):
                cache = getattr(res, cls.cache_name)

            # Otherwise, we simply need to create a new cache entirely.
            else:
                cache = []
                res = cls.new_wrapper(func, cache)
                res.__module__ = getattr(wrapped, '__module__', getattr(func, '__module__', '__main__'))

            # We calculate the priority of this case by trying to match against the
            # most complex definition first.
            argtuple = s_args, args, defaults, (star, starstar)
            priority = len(args) - s_args - len(t_args) + (len(args) and (next((float(i) for i, a in enumerate(args[s_args:]) if a in t_args), 0) / len(args))) + sum(0.3 for item in [star, starstar] if item)

            # Iterate through our cache whilst checking to see if our decorated
            # function is already inside of it.
            current = tuple(t_args.get(_, None) for _ in args), (star, starstar)
            for i, (p, (_, t, a)) in enumerate(cache):
                if p != priority: continue

                # Verify that the function actually matches our current entry. If
                # it does, then we can update the entry and its documentation.
                if current == (tuple(t.get(_, None) for _ in a[1]), a[3]):
                    cache[i] = priority_tuple(priority, (func, t_args, argtuple))
                    res.__doc__ = cls.document(func.__name__, [item for _, item in cache])
                    return cons(res)
                continue

            # That means we should be good to go, so it should be okay to push
            # our new entry into our heap that will be searched upon using the function.
            heapq.heappush(cache, priority_tuple(priority, (func, t_args, argtuple)))
            #heapq.heappush(cache, (priority, (func, t_args, argtuple)))

            # Completely regenerate the documentation using what we have in the cache.
            res.__doc__ = cls.document(func.__name__, [item for _, item in cache])

            # ..and then we can restore the original wrapper in all of its former glory.
            return cons(res)

        # Validate the types of all of our arguments and raise an exception if it used
        # an unsupported type.
        for name, type in t_args.items():
            if not isinstance(type, (builtins.type, builtins.tuple)) and type not in {callable}:
                error_keywords = ("{:s}={!s}".format(name, type.__name__ if isinstance(type, builtins.type) or type in {callable} else '|'.join(t_.__name__ for t_ in type) if hasattr(type, '__iter__') else "{!r}".format(type)) for name, type in t_args.items())
                raise internal.exceptions.InvalidParameterError(u"@{:s}({:s}) : The value ({!s}) specified for parameter \"{:s}\" is not a supported type.".format('.'.join([__name__, cls.__name__]), ', '.join(error_keywords), type, string.escape(name, '"')))
            continue

        # Validate the types of our arguments that we were asked to decorate with, this
        # way we can ensure that our previously decorated functions are actually of the
        # correct type. We do this strictly to assist with debugging.
        try:
            [cls.ex_function(item) for item in other]
        except Exception:
            error_keywords = ("{:s}={!s}".format(name, type.__name__ if isinstance(type, builtins.type) or type in {callable} else '|'.join(item.__name__ for item in type) if hasattr(type, '__iter__') else "{!r}".format(type)) for name, type in t_args.items())
            raise internal.exceptions.InvalidParameterError(u"@{:s}({:s}) : The specified callable{:s} {!r} {:s} not of a valid type.".format('.'.join([__name__, cls.__name__]), ', '.join(error_keywords), '' if len(other) == 1 else 's', other, 'is' if len(other) == 1 else 'are'))

        # If we were given an unexpected number of arguments to decorate with, then
        # raise an exception. This is strictly done to assist with debugging.
        if len(other) > 1:
            error_keywords = ("{:s}={!s}".format(name, type.__name__ if isinstance(type, builtins.type) or type in {callable} else '|'.join(item.__name__ for item in type) if hasattr(type, '__iter__') else "{!r}".format(type)) for name, type in t_args.items())
            raise internal.exceptions.InvalidParameterError(u"@{:s}({:s}) : More than one callable ({:s}) was specified to add a case to. Refusing to add cases to more than one callable.".format('.'.join([__name__, cls.__name__]), ', '.join(error_keywords), ', '.join("\"{:s}\"".format(string.escape(pycompat.code.name(c) if isinstance(c, types.CodeType) else c.__name__, '"')) for c in other)))
        return result

    @classmethod
    def document(cls, name, cache):
        '''Generate documentation for a multicased function.'''
        result = []

        # Iterate through every item in our cache, and generate the prototype for it.
        for function, constraints, (ignore_count, parameter_names, _, _) in cache:
            prototype = cls.prototype(function, constraints, parameter_names[:ignore_count])

            # Now that we have the prototype, we need to figure out where we need to
            # add the documentation for the individual case.
            doc = (function.__doc__ or '').split('\n')
            if len(doc) > 1:
                item, lines = "{:s} -> ".format(prototype), (item for item in doc)
                result.append("{:s}{:s}".format(item, next(lines)))
                result.extend("{: >{padding:d}s}".format(line, padding=len(item) + len(line)) for line in map(operator.methodcaller('strip'), lines))
            elif len(doc) == 1:
                result.append("{:s}{:s}".format(prototype, " -> {:s}".format(doc[0]) if len(doc[0]) else ''))
            continue
        return '\n'.join(result)

    @classmethod
    def flatten(cls, iterable):
        '''Take the provided `iterable` (or tree) and then yield each individual element resulting in it being "flattened".'''
        duplicates = {item for item in []}
        for item in iterable:
            if isinstance(item, (builtins.list, builtins.tuple, builtins.set)):
                for item in cls.flatten(item):
                    if item in duplicates:
                        continue
                    yield item
                    duplicates |= {item}
                continue
            if item in duplicates:
                continue
            yield item
            duplicates |= {item}
        return

    @classmethod
    def prototype(cls, function, constraints={}, ignored={item for item in []}):
        '''Generate a prototype for an instance of a `function`.'''
        args, defaults, (star, starstar) = cls.ex_args(function)

        def Femit_arguments(names, constraints, ignored):
            '''Yield a tuple for each individual parameter composed of the name and its constraints.'''

            # Iterate through all of our argument names. If any of them are within
            # our ignored items, however, then we can simply skip over them.
            for item in names:
                if item in ignored:
                    continue

                # If the current argument name is not within our constraints, then
                # we only have to yield the argument name and move on.
                if item not in constraints:
                    yield item, None
                    continue

                # Figure out which constraint to use for each item, and yield how
                # it should be represented back to the caller.
                constraint = constraints[item]
                if isinstance(constraint, builtins.type) or constraint in {callable}:
                    yield item, constraint.__name__
                elif hasattr(constraint, '__iter__'):
                    yield item, '|'.join(type.__name__ for type in cls.flatten(constraint))
                else:
                    yield item, "{!s}".format(constraint)
                continue
            return

        # Log any multicased functions that accidentally define type constraints for parameters
        # which don't actually exist. This is specifically done in order to aid debugging.
        unavailable = {constraint_name for constraint_name in constraints.keys()} - {argument_name for argument_name in args}
        if unavailable:
            co = pycompat.function.code(function)
            co_fullname, co_filename, co_lineno = '.'.join([function.__module__, function.__name__]), os.path.relpath(co.co_filename, idaapi.get_user_idadir()), co.co_firstlineno
            proto_s = "{:s}({:s}{:s}{:s})".format(co_fullname, ', '.join(args) if args else '', ", *{:s}".format(star) if star and args else "*{:s}".format(star) if star else '', ", **{:s}".format(starstar) if starstar and (star or args) else "**{:s}".format(starstar) if starstar else '')
            path_s = "{:s}:{:d}".format(co_filename, co_lineno)
            logging.warning("{:s}({:s}): Unable to constrain the type in {:s} for parameter{:s} ({:s}) at {:s}.".format('.'.join([__name__, 'multicase']), co_fullname, proto_s, '' if len(unavailable) == 1 else 's', ', '.join(unavailable), path_s))

        # Return the prototype for the current function with the provided parameter constraints.
        iterable = (item if parameter is None else "{:s}={:s}".format(item, parameter) for item, parameter in Femit_arguments(args, constraints, ignored))
        items = iterable, ["*{:s}".format(star)] if star else [], ["**{:s}".format(starstar)] if starstar else []
        return "{:s}({:s})".format(pycompat.function.name(function), ', '.join(itertools.chain(*items)))

    @classmethod
    def match(cls, packed_parameters, heap):
        '''Given the (`args`, `kwds`) stored in the `packed_parameters`, find the correct function according to the constraints of each member in the `heap`.'''
        args, kwds = packed_parameters

        # Iterate through all the available functions/cases within the heap that
        # we were given. This is being done in O(n) time which can be significantly
        # improved because we should be being sorted by complexity and count. This
        # really should allow use to start searching closer to the item in the list
        # that matches our parameters that we're searching with.
        for F, constraints, (parameter_ignore_count, parameter_names, parameter_defaults, (parameter_wildargs, parameter_wildkeywords)) in heap:

            # Grab our values that we're going to match with.
            parameter_iterator, parameter_keywords = (item for item in args), {kwparam : kwvalue for kwparam, kwvalue in kwds.items()}

            # Skip the ignored argument values within our parameters.
            [next(item) for item in [parameter_iterator] * parameter_ignore_count]

            # Build the argument tuple that contains the actual parameters that
            # will be passed to the matched function. When we collect the arguments,
            # we need to ensure that any keywords parameters and default parameters
            # will be inserted into the correct place within the tuple.
            parameter_values = []
            for name in parameter_names[parameter_ignore_count:]:
                try:
                    value = next(parameter_iterator)

                # If there were no parameters left within our iterator, then we
                # need to apply any keywords that we were given.
                except StopIteration:
                    if name in parameter_keywords:
                        value = parameter_keywords.pop(name)

                    # If there weren't any keywords with our parameter name, then
                    # we need to check to see if there's a default parameter to use.
                    elif name in parameter_defaults:
                        value = parameter_defaults.pop(name)

                    # If there were no default parameters, then we need to leave
                    # because we don't have a way to grab any more parameters.
                    else:
                        break

                    # We were able to get a keyword or default parameter, so we can
                    # add it to our arguments to match with.
                    parameter_values.append(value)

                # We consumed a parameter value, so we can now append it to our arguments
                # that we will match against.
                else:
                    parameter_values.append(value)
                continue

            # Now that we have our parameter values, we need to convert it into a tuple
            # so that we can process and use it. Any parameters left in parameter_iterator
            # or parameter_keywords are considered part of the wildcard parameters.
            argument_values = builtins.tuple(parameter_values)
            argument_wildcard, argument_keywords = [item for item in parameter_iterator], {kwparam : kwvalue for kwparam, kwvalue in parameter_keywords.items()}

            # First check if we have any extra parameters. If we do, but there's no wildcards
            # available in our current match, then it doesn't fit and we move onto the next one.
            if not parameter_wildargs and len(argument_wildcard):
                continue

            # If we have any extra keywords, then we need to ensure that there's a keyword
            # parameter in our current match. Otherwise, it doesn't fit and we need to move on.
            elif not parameter_wildkeywords and argument_keywords:
                continue

            # Second, we need to check that our argument length actually matches. To accomplish
            # this, we need to check if our function can take a wildcard parameter. If so, then
            # we need to ensure that the number of parameters that we were given are larger than
            # what was required.
            if parameter_wildargs and parameter_ignore_count + len(argument_values) < len(parameter_names):
                continue

            # If our function doesn't take a wildcard parameter, then our number of arguments
            # should match what we were given. If they don't, then skip onto the next one.
            elif not parameter_wildargs and parameter_ignore_count + len(argument_values) != len(parameter_names):
                continue

            # Third, we need to actually check our type constraints that our current match was
            # decorated with. If our constraint is a builtins.callable, then we just need to
            # ensure that the parameter can be called. Otherwise our constraint should be an
            # iterable of types that we can simply pass long to the isinstance() function.
            critiqueF = lambda constraint: builtins.callable if constraint == builtins.callable else frpartial(builtins.isinstance, constraint)

            # Zip our parameter names along with our argument values so that we can extract
            # the constraint, and check the value against it. If any of these checks fail,
            # then it's not a match and we need to move on to the next iteration.
            parameter_names_and_values = zip(parameter_names[parameter_ignore_count:], argument_values)
            if not all(critiqueF(constraints[name])(value) for name, value in parameter_names_and_values if name in constraints):
                continue

            # We should now have a match. So now that we've figured out all of our individual
            # parameters and their positions, we need to put them all together so that we can
            # return them to the caller so that they can actually call it.
            result_arguments = builtins.tuple(itertools.chain(args[:parameter_ignore_count], argument_values))
            return F, (result_arguments, argument_wildcard, argument_keywords)

        # If we iterated through everything in our heap, then we couldn't find a match for the
        # types the user gave us. So we need to raise an exception to inform the user that the
        # types we were given did not match any of the constraints that we know about.
        ignored = min(ignore_count for _, _, (ignore_count, _, _, _) in heap) if heap else 0
        error_arguments = [item.__class__.__name__ for item in args[ignored:]]
        error_keywords = ["{:s}={!s}".format(name, kwds[name].__class__.__name__) for name in kwds]

        # Here we extract all of the possible cases so that we can present a descriptive error
        # message. We also need to do something incredibly dirty here which involves re-splitting
        # the name from the prototypes to avoid re-calculating the name returned by cls.prototype.
        prototypes = ((F.__module__ if hasattr(F, '__module__') else None, cls.prototype(F, constraints)) for F, constraints, _ in heap)
        error_prototypes = ['.'.join([module, name]) if module else name for module, name in prototypes]
        error_names = sorted({prototype.split('(', 1)[0] for prototype in error_prototypes})

        # Now we can collect all of our components into individual lists of availability,
        # and then format them as a proper fucking sentence because we "love" our users.
        Fnames, Fhelp, Fprototype = "`{:s}`".format, "`help({:s})`".format, "{:s}".format
        available_names      = ', '.join(map(Fnames,     error_names[:-1]))      + (", and {:s}".format(*map(Fnames,     error_names[-1:]))      if len(error_names) > 1      else Fnames(error_names[0]))
        available_help       = ', '.join(map(Fhelp,      error_names[:-1]))      + (", and {:s}".format(*map(Fhelp,      error_names[-1:]))      if len(error_names) > 1      else Fhelp(error_names[0]))
        available_prototypes = ', '.join(map(Fprototype, error_prototypes[:-1])) + (", or {:s}".format( *map(Fprototype, error_prototypes[-1:])) if len(error_prototypes) > 1 else Fprototype(error_prototypes[0]))

        # Now we can format our description, create our exception, and finally raise it.
        description = ', '.join("{:s}({:s}{:s})".format(name, ', '.join(error_arguments) if args else '*()', ", {:s}".format(', '.join(error_keywords)) if error_keywords else '') for name in error_names)
        raise internal.exceptions.UnknownPrototypeError(u"{:s}: The given parameter{:s} not match any of the available prototypes for {:s}. The prototypes which are available via {:s} are: {:s}".format(description, ' does' if sum(map(len, [error_arguments, error_keywords])) == 1 else 's do', available_names, available_help, available_prototypes))

    @classmethod
    def new_wrapper(cls, func, cache):
        '''Create a new wrapper that will determine the correct function to call.'''

        # Define the wrapper for the function that we're decorating. This way whenever the
        # decorated function gets called, we can search for one that matches the correct
        # constraints and dispatch into it with the original parameters in the correct order.
        def F(*arguments, **keywords):
            heap = [item for _, item in heapq.nsmallest(len(cache), cache, key=operator.attrgetter('priority'))]

            # Pack our parameters, and then hand them off to our matching function. This
            # should then return the correct callable that matches the argument types we
            # were given so that we can dispatch to it.
            packed_parameters = arguments, keywords
            result_callable, result_parameters = cls.match(packed_parameters, heap)

            # Now we have a matching callable for the user's parameters, and we just need
            # to unpack our individual parameters and dispatch to the callable with them.
            parameters, wild_parameters, keyword_parameters = result_parameters
            return result_callable(*itertools.chain(parameters, wild_parameters), **keyword_parameters)

        # First, we need to swap out the original code object with the one from the closure
        # that we defined. In order to preserve information within the backtrace, we just
        # make a copy of all of the relevant code properties.
        f, c = F, pycompat.function.code(F)
        cargs = c.co_argcount, c.co_nlocals, c.co_stacksize, c.co_flags, \
                c.co_code, c.co_consts, c.co_names, c.co_varnames, \
                c.co_filename, '.'.join([func.__module__, pycompat.function.name(func)]), \
                c.co_firstlineno, c.co_lnotab, c.co_freevars, c.co_cellvars
        newcode = pycompat.code.new(cargs, pycompat.code.unpack_extra(c))

        # Now we can use the new code object that we created in order to create a function
        # and assign the previous name and documentation into it.
        result = pycompat.function.new(newcode, pycompat.function.globals(f), pycompat.function.name(f), pycompat.function.defaults(f), pycompat.function.closure(f))
        pycompat.function.set_name(result, pycompat.function.name(func)),
        pycompat.function.set_documentation(result, pycompat.function.documentation(func))

        # The last two things to do is to copy our cache that we were given into the function
        # that we're going to return. This way people can debug it if they feel they need to.
        setattr(result, cls.cache_name, cache)
        setattr(result, '__doc__', '')
        return result

    @classmethod
    def ex_function(cls, object):
        '''Extract the actual function type from a callable.'''
        if isinstance(object, types.FunctionType):
            return object
        elif isinstance(object, types.MethodType):
            return pycompat.method.function(object)
        elif isinstance(object, types.CodeType):
            res, = (item for item in gc.get_referrers(c) if pycompat.function.name(item) == pycompat.code.name(c) and isinstance(item, types.FunctionType))
            return res
        elif isinstance(object, (staticmethod, classmethod)):
            return object.__func__
        raise internal.exceptions.InvalidTypeOrValueError(object)

    @classmethod
    def reconstructor(cls, item):
        '''Return a closure that returns the original callable type for a function.'''
        if isinstance(item, types.FunctionType):
            return lambda f: f
        if isinstance(item, types.MethodType):
            return lambda f: pycompat.method.new(f, pycompat.method.self(item), pycompat.method.type(item))
        if isinstance(item, (staticmethod, classmethod)):
            return lambda f: type(item)(f)
        if isinstance(item, types.InstanceType):
            return lambda f: types.InstanceType(type(item), dict(f.__dict__))
        if isinstance(item, (builtins.type, types.ClassType)):
            return lambda f: type(item)(item.__name__, item.__bases__, dict(f.__dict__))
        raise internal.exceptions.InvalidTypeOrValueError(type(item))

    @classmethod
    def ex_args(cls, f):
        '''Extract the arguments from a function.'''
        c = pycompat.function.code(f)
        varnames_count, varnames_iter = pycompat.code.argcount(c), (item for item in pycompat.code.varnames(c))
        args = tuple(itertools.islice(varnames_iter, varnames_count))
        res = { a : v for v, a in zip(reversed(pycompat.function.defaults(f) or []), reversed(args)) }
        try: starargs = next(varnames_iter) if pycompat.code.flags(c) & pycompat.co_flags.CO_VARARGS else ""
        except StopIteration: starargs = ""
        try: kwdargs = next(varnames_iter) if pycompat.code.flags(c) & pycompat.co_flags.CO_VARKEYWORDS else ""
        except StopIteration: kwdargs = ""
        return args, res, (starargs, kwdargs)

    @classmethod
    def generatorQ(cls, func):
        '''Returns true if `func` is a generator.'''
        func = cls.ex_function(func)
        code = pycompat.function.code(func)
        return bool(pycompat.code.flags(code) & CO_VARGEN)

class alias(object):
    def __new__(cls, other, klass=None):
        cons, func = multicase.reconstructor(other), multicase.ex_function(other)
        if isinstance(other, types.MethodType) or klass:
            module = (func.__module__, klass or pycompat.method.type(other).__name__)
        else:
            module = (func.__module__,)
        document = "Alias for `{:s}`.".format('.'.join(module + (pycompat.function.name(func),)))
        res = cls.new_wrapper(func, document)
        return cons(res)

    @classmethod
    def new_wrapper(cls, func, document):
        # build the wrapper...
        def fn(*arguments, **keywords):
            return func(*arguments, **keywords)
        res = functools.update_wrapper(fn, func)
        res.__doc__ = document
        return res

### matcher class helper

# FIXME: figure out how to match against a bounds_t in a non-hacky way
class matcher(object):
    """
    An object that allows one to match or filter a list of things in an
    sort of elegant way.
    """

    def __init__(self):
        self.__predicate__ = {}
    def __attrib__(self, *attributes):
        if not attributes:
            return lambda item: item
        res = [(operator.attrgetter(callable_or_attribute) if isinstance(callable_or_attribute, six.string_types) else callable_or_attribute) for callable_or_attribute in attributes]
        return fcompose(*res) if len(res) > 1 else res[0]
    def attribute(self, type, *attribute):
        attr = self.__attrib__(*attribute)
        self.__predicate__[type] = lambda target: fcompose(attr, functools.partial(functools.partial(operator.eq, target)))
    def mapping(self, type, function, *attribute):
        attr = self.__attrib__(*attribute)
        mapper = fcompose(attr, function)
        self.__predicate__[type] = lambda target: fcompose(mapper, functools.partial(operator.eq, target))
    def boolean(self, type, function, *attribute):
        attr = self.__attrib__(*attribute)
        self.__predicate__[type] = lambda target: fcompose(attr, functools.partial(function, target))
    def combinator(self, type, function, *attribute):
        attr = self.__attrib__(*attribute)
        self.__predicate__[type] = fcompose(function, functools.partial(fcompose, attr))
    def predicate(self, type, *attribute):
        attr = self.__attrib__(*attribute)
        self.__predicate__[type] = functools.partial(fcompose, attr)
    def match(self, type, value, iterable):
        matcher = self.__predicate__[type](value)
        return (item for item in iterable if matcher(item))

### character processing (escaping and unescaping)
class character(object):
    """
    This namespace is responsible for performing actions on individual
    characters such as detecting printability or encoding them in a
    form that can be evaluated.
    """
    class const(object):
        ''' Constants '''
        import string as _string, unicodedata as _unicodedata

        backslash = u'\\'

        # character mappings to escaped versions
        mappings = {
            u'\a' : u'\\a',
            u'\b' : u'\\b',
            u'\t' : u'\\t',
            u'\n' : u'\\n',
            u'\v' : u'\\v',
            u'\f' : u'\\f',
            u'\r' : u'\\r',
            u'\0' : u'\\0',
            u'\1' : u'\\1',
            u'\2' : u'\\2',
            u'\3' : u'\\3',
            u'\4' : u'\\4',
            u'\5' : u'\\5',
            u'\6' : u'\\6',
            #u'\7' : u'\\7',     # this is the same as '\a'
        }

        # inverse mappings of characters plus the '\7 -> '\a' byte
        inverse = { v : k for k, v in itertools.chain([(u'\7', u'\\7')], mappings.items()) }

        # whitespace characters as a set
        whitespace = { ch for ch in _string.whitespace }

        # printable characters as a set (spaces are the only whitespace that we consider as printable)
        printable = { ch for ch in _string.printable } - whitespace | {u' '}

        # hexadecimal digits as a lookup
        hexadecimal = { ch : i for i, ch in enumerate(_string.hexdigits[:0x10]) }

    @classmethod
    def asciiQ(cls, ch):
        '''Returns whether an ascii character is printable or not.'''
        return operator.contains(cls.const.printable, ch)

    @classmethod
    def unicodeQ(cls, ch):
        '''Returns whether a unicode character is printable or not.'''
        cat = cls.const._unicodedata.category(ch)
        return cat[0] != 'C'

    @classmethod
    def whitespaceQ(cls, ch):
        '''Returns whether a character represents whitespace or not.'''
        return operator.contains(cls.const.whitespace, ch)

    @classmethod
    def mapQ(cls, ch):
        '''Returns whether a character is mappable or not.'''
        return operator.contains(cls.const.mappings, ch)

    @classmethod
    def map(cls, ch):
        '''Given a mappable character, return the string that emits it.'''
        return operator.getitem(cls.const.mappings, ch)

    @classmethod
    def hexQ(cls, ch):
        '''Returns whether a character is a hex digit or not.'''
        return operator.contains(cls.const.hexadecimal, ch)

    @classmethod
    def to_hex(cls, integer):
        '''Given an integer, return the hex digit that it represents.'''
        inverse = { digit : char for char, digit in cls.const.hexadecimal.items() }
        if integer in inverse:
            return operator.getitem(inverse, integer)
        raise ValueError(integer)

    @classmethod
    def of_hex(cls, digit):
        '''Given a hex digit, return it as an integer.'''
        return operator.getitem(cls.const.hexadecimal, digit.lower())

    @classmethod
    def escape(cls, result):
        '''Return a generator that escapes all non-printable characters and sends them to `result`.'''

        # begin processing any input that is fed to us
        while True:
            ch = (yield)
            n = ord(ch)

            # check if character has an existing escape mapping
            if cls.mapQ(ch):
                for ch in cls.map(ch):
                    result.send(ch)

            # check if character is a backslash
            elif operator.contains(cls.const.backslash, ch):
                result.send(cls.const.backslash)
                result.send(ch)

            # check if character is printable (py2 and unicode)
            elif sys.version_info.major < 3 and isinstance(ch, unicode) and cls.unicodeQ(ch):
                result.send(ch)

            # check if character is printable (py3 and unicode)
            elif 2 < sys.version_info.major and isinstance(ch, str) and cls.unicodeQ(ch):
                result.send(ch)

            # check if character is printable (ascii)
            elif isinstance(ch, six.string_types) and cls.asciiQ(ch):
                result.send(ch)

            # check if character is a single-byte ascii
            elif n < 0x100:
                result.send(cls.const.backslash)
                result.send(u'x')
                result.send(cls.to_hex((n & 0xf0) // 0x10))
                result.send(cls.to_hex((n & 0x0f) // 0x01))

            # check that character is an unprintable unicode character
            elif n < 0x10000:
                result.send(cls.const.backslash)
                result.send(u'u')
                result.send(cls.to_hex((n & 0xf000) // 0x1000))
                result.send(cls.to_hex((n & 0x0f00) // 0x0100))
                result.send(cls.to_hex((n & 0x00f0) // 0x0010))
                result.send(cls.to_hex((n & 0x000f) // 0x0001))

            # maybe the character is an unprintable long-unicode character
            elif n < 0x110000:
                result.send(cls.const.backslash)
                result.send(u'U')
                result.send(cls.to_hex((n & 0x00000000) // 0x10000000))
                result.send(cls.to_hex((n & 0x00000000) // 0x01000000))
                result.send(cls.to_hex((n & 0x00100000) // 0x00100000))
                result.send(cls.to_hex((n & 0x000f0000) // 0x00010000))
                result.send(cls.to_hex((n & 0x0000f000) // 0x00001000))
                result.send(cls.to_hex((n & 0x00000f00) // 0x00000100))
                result.send(cls.to_hex((n & 0x000000f0) // 0x00000010))
                result.send(cls.to_hex((n & 0x0000000f) // 0x00000001))

            # if we're here, then we have no idea what kind of character it is
            else:
                raise internal.exceptions.InvalidFormatError(u"{:s}.unescape({!s}) : Unable to determine how to escape the current character code ({:#x}).".format('.'.join([__name__, cls.__name__]), result, n))

            continue
        return

    @classmethod
    def unescape(cls, result):
        '''Return a generator that reads characters from an escaped string, unescapes/evaluates them, and then the unescaped character to `result`.'''

        # enter our processing loop for each character
        while True:
            ch = (yield)

            # okay, we got a backslash, so let's go...
            if ch == cls.const.backslash:
                t = (yield)

                # check if our character is in our inverse mappings
                if operator.contains(cls.const.inverse, cls.const.backslash + t):
                    ch = operator.getitem(cls.const.inverse, cls.const.backslash + t)
                    result.send(ch)

                # check if our character is a backslash
                elif operator.contains(cls.const.backslash, t):
                    result.send(cls.const.backslash)

                # check if the 'x' prefix is specified, which represents a hex digit
                elif t == u'x':
                    hb, lb = (yield), (yield)
                    if any(not cls.hexQ(b) for b in {hb, lb}):
                        raise internal.exceptions.InvalidFormatError(u"{:s}.unescape({!s}) : Expected the next two characters ('{:s}', '{:s}') to be hex digits for an ascii character.".format('.'.join([__name__, cls.__name__]), result, string.escape(hb, '\''), string.escape(lb, '\'')))

                    # convert the two hex digits into their integral forms
                    h, l = (cls.of_hex(item) for item in [hb.lower(), lb.lower()])

                    # coerce the digits into an ascii character and send the character to our result
                    result.send(six.unichr(
                        h * 0x10 |
                        l * 0x01 |
                    0))

                # if we find a 'u' prefix, then we have a unicode character
                elif t == u'u':
                    hwb, lwb, hb, lb = (yield), (yield), (yield), (yield)
                    if any(not cls.hexQ(b) for b in {hwb, lwb, hb, lb}):
                        raise internal.exceptions.InvalidFormatError(u"{:s}.unescape({!s}) : Expected the next four characters ('{:s}', '{:s}', '{:s}', '{:s}') to be hex digits for a unicode character.".format('.'.join([__name__, cls.__name__]), result, string.escape(hwb, '\''), string.escape(lwb, '\''), string.escape(hb, '\''), string.escape(lb, '\'')))

                    # convert the four hex digits into their integral forms
                    hw, lw, h, l = (cls.of_hex(item) for item in [hwb.lower(), lwb.lower(), hb.lower(), lb.lower()])

                    # coerce the digits into a unicode character and send the character to our result
                    result.send(six.unichr(
                        hw * 0x1000 |
                        lw * 0x0100 |
                        h  * 0x0010 |
                        l  * 0x0001 |
                    0))

                # if we find a 'U' prefix, then we have a long unicode character
                elif t == u'U':
                    hzb, lzb, Hwb, Lwb, hwb, lwb, hb, lb = (yield), (yield), (yield), (yield), (yield), (yield), (yield), (yield)
                    if any(not cls.hexQ(b) or cls.of_hex(b) for b in (hzb, lzb)):
                        raise internal.exceptions.InvalidFormatError(u"{:s}.unescape({!s}) : Expected the next two characters ('{:s}', '{:s}') to be zero for a long-unicode character.".format('.'.join([__name__, cls.__name__]), result, string.escape(hzb, '\''), string.escape(lzb, '\'')))
                    if any(not cls.hexQ(b) for b in {Hwb, Lwb, hwb, lwb, hb, lb}) or Hwb not in {'0', '1'}:
                        raise internal.exceptions.InvalidFormatError(u"{:s}.unescape({!s}) : Expected the next six characters ('{:s}', '{:s}', '{:s}', '{:s}', '{:s}', '{:s}') to be hex digits for a long-unicode character.".format('.'.join([__name__, cls.__name__]), result, string.escape(Hwb, '\''), string.escape(Lwb, '\''), string.escape(hwb, '\''), string.escape(lwb, '\''), string.escape(hb, '\''), string.escape(lb, '\'')))

                    # convert the six hex digits into their integral forms
                    Hw, Lw, hw, lw, h, l = (cls.of_hex(item) for item in [Hwb.lower(), Lwb.lower(), hwb.lower(), lwb.lower(), hb.lower(), lb.lower()])

                    # coerce the digits into a unicode character and send the character to our result
                    result.send(six.unichr(
                        Hw * 0x100000 |
                        Lw * 0x010000 |
                        hw * 0x001000 |
                        lw * 0x000100 |
                        h  * 0x000010 |
                        l  * 0x000001 |
                    0))

                else:
                    result.send(t)

            # we haven't received a backslash, so there's nothing to unescape
            else:
                result.send(ch)

            continue
        return

### string casting, escaping and emitting
class string(object):
    """
    IDA takes ascii strings and internally encodes them as UTF8. So
    this class aims to normalize all of these strings by converting
    them into a `unicode` type.
    """

    @classmethod
    def of_2x(cls, string):
        '''Return a string from IDA in a format that is consistent'''
        return None if string is None else string.decode('utf8') if isinstance(string, str) else string

    @classmethod
    def to_2x(cls, string):
        '''Convert a string into a form that IDA will accept.'''
        return None if string is None else string.encode('utf8') if isinstance(string, unicode) else string

    # In Python3, IDA seems to handle the native string-type properly so we can
    # just convert the desired parameter to a string and pass it through the API.

    @classmethod
    def passthrough(cls, string):
        '''Handle all strings both from IDA and to IDA transparently.'''
        return None if string is None else string

    # In older versions of IDA, according to https://hex-rays.com/products/ida/news/7_0/docs/i18n/,
    # the OEM encoding is used on the windows platform with UTF-8 on all of the others. We can get
    # the correct one on windows using ctypes with the `get_codepages` api from the sdk. This api
    # can return a constant, though, so it's up to us to figure out which encoding it actually is.
    # If we're unable to figure anything out, then we fall back to python's "mbcs" encoding which
    # should represent the current windows codepage according to the documentation.

    if idaapi.__version__ < 7.0 and sys.platform == 'win32':
        if hasattr(ida, 'get_codepages'):
            ida.get_codepages.restype, ida.get_codepages.argtypes = ctypes.c_ulong, [ctypes.POINTER(ctypes.c_ulong)]

        class codepage(object):
            """
            This class is used for getting information about the current code page so
            that it can be used to distinguishing how to encode and decode strings into
            the database and out to Python. It is temporary and shouldn't really be used.
            """

            # Now we need to figure out which codepage the disassembler is using.
            @classmethod
            def get_disassembler_codepage(cls):
                '''Return the current codepage that is used by the disassembler.'''
                cp = ctypes.pointer(ctypes.c_ulong(-1))
                return cp.contents.value if ida.get_codepages(cp) == 0 else 1   # CP_ACP(1)

            # ..And we need some function that will convert that default codepage into something python understands.
            @classmethod
            def GetCPInfoExW(cls, CodePage):
                '''Use ctypes to call the "kernel32.dll!GetCPInfoExW" Windows API and return information about the current codepage.'''
                class _cpinfoexW(ctypes.Structure):
                    MAX_LEADBYTES, MAX_DEFAULTCHAR = 12, 2
                    MAX_PATH = 260
                    _fields_ = [
                        ("MaxCharSize", ctypes.c_uint),
                        ("DefaultChar", ctypes.c_ubyte * MAX_DEFAULTCHAR),
                        ("LeadByte", ctypes.c_ubyte * MAX_LEADBYTES),
                        ("UnicodeDefaultChar", ctypes.c_wchar),
                        ("CodePage", ctypes.c_uint),
                        ("CodePageName", ctypes.c_wchar * MAX_PATH)
                    ]
                GetCPInfoExW = ctypes.windll.kernel32.GetCPInfoExW
                GetCPInfoExW.restype, GetCPInfoExW.argtypes = ctypes.c_long, [ctypes.c_uint, ctypes.c_long, ctypes.POINTER(_cpinfoexW)]
                res = _cpinfoexW()
                if not GetCPInfoExW(CodePage, 0, ctypes.pointer(res)):
                    return None
                return res

            # This lookup table is used for mapping a codepage number to a Python encoding,
            # but these encoding aren't guaranteed to be available in all versions of Python.
            codepage_codec_map = {codepage : encoding for codepage, encoding in [
                (1047, 'latin1'), (870, 'latin2'),
                (1141, 'IBM273',), (1142, 'IBM865',), (1146, 'IBM039',), (1149, 'IBM861',),
                (10000, 'mac_roman',), (10001, 'mac_roman',), (10002, 'csbig5',), (10006, 'mac_greek',), (10007, 'mac_cyrillic',), (10008, 'gb2312',), (10029, 'mac_latin2',), (10081, 'mac_turkish',),
                (12000, 'utf-32le'), (12001, 'utf-32be'),
                (20125, 'IBM855'), (20273, 'IBM273'), (20277, 'IBM277'), (20278, 'IBM278'), (20280, 'IBM280'), (20284, 'IBM284'), (20285, 'IBM285'), (20290, 'IBM290'), (20297, 'IBM297'), (20420, 'IBM420'), (20423, 'IBM423'), (20424, 'IBM424'), (20833, 'IBM833'), (20838, 'IBM838'), (20871, 'IBM871'), (20880, 'IBM880'), (20905, 'IBM905'), (20924, 'IBM924'),
                (20932, 'euc-jp'), (51949, 'euc-kr'),
                (20866, 'koi8_r'), (21866, 'koi8_u'),
                (28591, 'iso8859-1'), (28592, 'iso8859-2'), (28593, 'iso8859-3'), (28594, 'iso8859-4'), (28595, 'iso8859-5'), (28596, 'iso8859-6'), (28597, 'iso8859-7'), (28598, 'iso8859-8'), (28599, 'iso8859-9'), (28603, 'iso8859-13'), (28605, 'iso8859-15'), (38598, 'iso8859-8'),
                (50220, 'iso2022-jp'), (50221, 'iso2022-jp-ext'), (50222, 'iso2022-jp'), (50225, 'iso2022_kr'), (50227, 'iso2022_jp'), (50229, 'iso2022_jp'),
                (20936, 'gb2312'), (52936, 'hz-gb-2312'), (54936, 'gb18030'),
                (20127, 'us-ascii'), (65000, 'utf-7'), (65001, 'utf-8'), (65002, 'utf-16'),
            ]}

            @classmethod
            def lookup_codepage(cls, codepage):
                '''Use the given `codepage` to determine the string codec that will be used by Python to encode or decode strings.'''
                encoding = "CP{:03d}".format(codepage)
                try:
                    codec = codecs.lookup(encoding)
                except LookupError:
                    encoding = cls.codepage_codec_map.get(codepage, '')
                else:
                    return codec.name

                # if we couldn't find the code for the codepage, then we
                # need to try again using whatever was in our codec map.
                try:
                    codec = codecs.lookup(encoding)
                except LookupError:
                    return ''
                return codec.name

            # Define a table for describing the default codepage types available from windows.
            windows_codepage_description = {
                0: 'CP_ACP', 1: 'CP_OEMCP', 2: 'CP_MACCP', 3: 'CP_THREAD_ACP', 42: 'CP_SYMBOL',
                12000: 'CP_UTF32LE', 12001: 'CP_UTF32BE', 65000: 'CP_UTF7', 65001: 'CP_UTF8', 65002: 'CP_UTF16',
            }

            @classmethod
            def describe_codepage(cls, codepage):
                '''Return a printable description for the specified `codepage`.'''
                if codepage in cls.windows_codepage_description:
                    return "{:s}({:d})".format(cls.windows_codepage_description[codepage], codepage)
                elif codepage in cls.codepage_codec_map:
                    return cls.codepage_codec_map[codepage]
                return "unknown({:d})".format(codepage)

            @staticmethod
            def return_of_encoding(encoding):
                '''Return a closure that can be used to decode a string from the given `encoding`.'''
                def of(string):
                    '''Convert a string using the codepage of the disassembler to a python string.'''
                    return None if string is None else string.decode(encoding) if isinstance(string, str) else string
                return of

            @staticmethod
            def return_to_encoding(encoding):
                '''Return a closure that can be used to encode a string to the given `encoding`.'''
                def to(string):
                    '''Convert a python string to a string using the codepage of the disassembler.'''
                    return None if string is None else string.encode(encoding) if isinstance(string, unicode) else string
                return to

            def __new__(cls):
                '''Return a tuple of functions that may be used to decode strings from the database and encode strings into the database.'''
                cp = cls.get_disassembler_codepage()
                cpinfoex = cls.GetCPInfoExW(cp)
                if cpinfoex:
                    encoding, description = cls.lookup_codepage(cpinfoex.CodePage), cpinfoex.CodePageName
                else:
                    encoding, description = '', 'Unknown'

                # Now we need to verify that the codec actually exists, because if
                # it doesn't then we need to fallback to something.
                try:
                    codec = codecs.lookup(encoding)
                except LookupError:
                    encoding = 'MBCS' if sys.version_info.major < 3 and sys.version_info.minor < 6 else 'OEM'
                else:
                    encoding = codec.name

                # Okay, that should be it and we just need to log what we figured out.
                logging.info(u"{:s} : Detected codepage {:s} used by disassembler which will result in using the \"{:s}\" string encoding.".format('.'.join([__name__, cls.__name__]), cls.describe_codepage(cp), encoding))
                return cls.return_of_encoding(encoding), cls.return_to_encoding(encoding)

        # Now we should be able to get some functions that will encode and decode strings from the database.
        of, to = map(staticmethod, codepage())

    # Otherwise we should be able to trust that everything is going to be UTF-8.
    else:
        of = of_2x if sys.version_info.major < 3 else passthrough
        to = to_2x if sys.version_info.major < 3 else passthrough

    # dictionary for mapping control characters to their correct forms
    mapping = {
        u'\n' : u'\\n',
        u' ' : u' ',
    }

    @classmethod
    def escape(cls, string, quote=u''):
        """Escape the characters in `string` specified by `quote`.

        Handles both unicode and ascii. Defaults to escaping only
        the unprintable characters.
        """

        # construct a list for anything that gets transformed
        res = internal.interface.collect_t(list, lambda agg, value: agg + [value])

        # instantiate our generator for escaping unprintables in the string
        transform = character.escape(res); next(transform)

        # iterate through each character, sending everything to res
        for ch in (string or u''):

            # check if character is a user-specified quote or a backslash
            if any(operator.contains(set, ch) for set in {quote, u'\\'}):
                res.send(u'\\')
                res.send(ch)

            # check if character has an escape mapping to use
            elif operator.contains(cls.mapping, ch):
                [res.send(item) for item in cls.mapping[ch]]

            # otherwise we can just send it to transform to escape it
            else:
                transform.send(ch)
            continue

        # figure out the correct function that determines how to join the res
        cons = unicode() if sys.version_info.major < 3 and isinstance(string, unicode) else str()
        return cons.join(res.get())

    @classmethod
    def repr(cls, item):
        """Given an item, return the `repr()` of it whilst ensuring that a proper ascii string is returned.

        All unicode strings are encoded to UTF-8 in order to guarantee
        the resulting string can be emitted.
        """

        # Python2 string types (str/bytes and unicode)
        if isinstance(item, six.string_types) and sys.version_info.major < 3:
            res = cls.escape(item.decode('latin1') if isinstance(item, bytes) else item, u'\'')
            if all(ord(ch) < 0x100 for ch in item):
                return u"'{:s}'".format(res)
            return u"u'{:s}'".format(res)

        # Python3 string types (str and bytes)
        elif isinstance(item, six.string_types):
            res = cls.escape(item, u'\'')
            return u"'{:s}'".format(res)

        elif isinstance(item, bytes):
            res = cls.escape(item.decode('latin1'), u'\'')
            return u"b'{:s}'".format(res)

        elif isinstance(item, tuple):
            res = map(cls.repr, item)
            return u"({:s}{:s})".format(', '.join(res), ',' if len(item) == 1 else '')

        elif isinstance(item, list):
            res = map(cls.repr, item)
            return u"[{:s}]".format(', '.join(res))

        elif isinstance(item, set):
            res = map(cls.repr, item)
            return u"set([{:s}])".format(', '.join(res))

        elif isinstance(item, dict):
            res = ("{:s}: {:s}".format(cls.repr(k), cls.repr(v)) for k, v in item.items())
            return u"{{{:s}}}".format(', '.join(res))

        return u"{!r}".format(item)

    # On Python2, utf-8 strings are not rendered to a string properly. This
    # screws up the output when trying to write to the console because IDA
    # will then try to utf-8 decode the string manually. To work around this,
    # the following implementation escapes the keys manually, and then utf-8
    # encodes them when concatenating them together. After we have nicely
    # formatted our entire dict, then we re-encode it back to utf-8 for printing.
    if sys.version_info.major < 3:
        @classmethod
        def kwargs(cls, kwds):
            '''Format a dictionary (from kwargs) so that it can be emitted to a user as part of a message.'''
            res = []
            for key, value in kwds.items():
                k, v = cls.escape(key), cls.repr(value)
                res.append("{:s}={!s}".format(*(item.encode('utf8') if isinstance(item, unicode) else item for item in (k, v))))
            return ', '.join(res).decode('utf8')

    # In Python3, IDA doesn't seem to do any utf-8 trickery. So, all we need to
    # do is to escape each key and render it to the string. Then when it gets
    # printed, it should be using the correct characters.
    else:
        @classmethod
        def kwargs(cls, kwds):
            '''Format a dictionary (from kwargs) so that it can be emitted to a user as part of a message.'''
            res = []

            # Escape each key, and repr() each value so that we can emit the keyword
            # parameters for a function call using the same syntax that the user
            # would likely type it.
            for key, value in kwds.items():
                # XXX: we could probably force `key` to a string here, but kwargs should
                #      _never_ have a non-string passed as a parameter name. therefore
                #      we graciously accept any exception that gets raised here.
                res.append("{:s}={!s}".format(cls.escape(key), cls.repr(value)))
            return ', '.join(res)

    @classmethod
    def decorate_arguments(cls, *names):
        '''Given a list of argument names, decode them into unicode strings.'''
        return transform(cls.of, *names)

    @classmethod
    def digits(cls, number, base):
        '''Return the number of characters used to represent the `number` of the specified `base`.'''
        fi = sys.float_info
        mantissa, exponent = fi.mant_dig, fi.max_exp - fi.min_exp
        maxpower2 = mantissa - sys.float_info.dig + math.floor(math.log(exponent, 2))

        # These are combined with the mantissa and so the regular logarithm
        # will likely be just enough to calculate it properly.
        if base in {10}:
            logarithm = math.log10(number or 1)
            return math.trunc(1 + math.floor(logarithm))

        # Otherwise, we check if it's an even number or not in order to determine
        # that we need to use the base-less math.log implementation.
        elif not operator.mod(base, 2):
            logarithm = math.log(number or 1, base)

            # This should only use the exponent field inside a floating point number
            if number < pow(2, maxpower2):
                return math.trunc(1 + math.floor(logarithm))

            # To deal with IEEE754's imprecision, we just use Python to format
            # this number as a hexadecimal string and then use its length to
            # figure out how many digits are needed for the desired base.
            count = len("{:b}".format(number))
            return count * 2 // base

        # We don't support any other bases because the author doesn't feel like
        # spending the time to figure out the correct math for this.
        raise NotImplementedError(base)

    # Convert a string to hexadecimal so that it can be displayed.
    tohex = operator.methodcaller('encode', 'hex') if sys.version_info.major < 3 else operator.methodcaller('hex')

### wrapping functions with another caller whilst preserving the wrapped function
class wrap(object):
    """
    A lot of magic is in this class which allows one to do a proper wrap
    around a single callable.
    """

    import opcode
    if sys.version_info.major < 3:
        import compiler.consts as consts
    else:
        import inspect as consts

    # Assembler for Python2 bytecode, where each opcode is either a single-byte or a tri-byte.
    if sys.version_info.major < 3:
        @classmethod
        def co_assemble(cls, operation, operand=None):
            '''Assembles the specified `operation` and `operand` into a code string.'''
            opcode = cls.opcode.opmap[operation]
            if operand is None:
                return bytes(bytearray([opcode]))

            # if operand was defined, then encode it
            op1 = (operand & 0x00ff) // 0x0001
            op2 = (operand & 0xff00) // 0x0100
            return bytes(bytearray([opcode, op1, op2]))

    # Assembler for Python3 bytecode where each opcode is a uint16_t.
    else:
        @classmethod
        def co_assemble(cls, operation, operand=None):
            '''Assembles the specified `operation` and `operand` into a code string.'''
            opcode, ext = cls.opcode.opmap[operation], cls.opcode.EXTENDED_ARG
            if (operand or 0) < 0x00000100:
                return bytes(bytearray([opcode, operand or 0]))

            # We clamp the operands' maximum length to 4 bytes (32-bits) because
            # that is the most that python's runtime supports. When calculating
            # the MSB, we have to hack up the math because Python's imprecision
            # has a significant influence on the logarithm result.
            msb = math.ceil(math.log(operand or 1, 2))
            operands = [ 0xff & operand // pow(2, shift) for shift in range(0, min(32, msb), 8) ]

            iterable = itertools.chain(([ext, item] for item in operands[:-1]), ([opcode, item] for item in operands[-1:]))
            return bytes(bytearray(itertools.chain(*iterable)))

    @classmethod
    def co_varargsQ(cls, co):
        '''Returns whether the provided code type, `co`, takes variable arguments.'''
        return bool(pycompat.code.flags(co) & cls.consts.CO_VARARGS)

    @classmethod
    def co_varkeywordsQ(cls, co):
        '''Returns whether the provided code type, `co`, takes variable keyword arguments.'''
        return bool(pycompat.code.flags(co) & cls.consts.CO_VARKEYWORDS)

    @classmethod
    def cell(cls, *args):
        '''Convert `args` into a ``cell`` tuple.'''
        return tuple((pycompat.function.closure((lambda item: lambda : item)(arg))[0]) for arg in args)

    # The classmethods that follow are responsible for assembling the equivalent of
    # the closure that gets returned from the following python.

    # def wrap(callable, wrapper):
    #     def result(callable[arg1], callable[arg2], callable[arg3...], *callable[args], **callable[keywords]):
    #         return wrapper(callable, callable[arg1], callable[arg2], callable[arg3...], *callable[args], **callable[keywords])
    #     return result

    # The reason why we're assembling this directly is so that the returned object
    # has the _exact_ same arguments (including both wild and keyword arguments)
    # which allows the documentation to still work properly when it's decorated.

    @classmethod
    def assemble_2x(cls, function, wrapper, bound=False):
        """Assemble a ``types.CodeType`` that will execute `wrapper` with `F` as its first parameter.

        If `bound` is ``True``, then assume that the first parameter for `F` represents the instance it's bound to.
        """
        F, C, S = (cls.extract(item) for item in [function, wrapper, cls.assemble_2x])
        Fc, Cc, Sc = (pycompat.function.code(item) for item in [F, C, S])

        ## build the namespaces that we'll use
        Tc = cls.co_varargsQ(Fc), cls.co_varkeywordsQ(Fc)

        # first we'll build the globals that get passed to the wrapper
        Sargs = ('F', 'wrapper')
        Svals = (f if callable(f) else fo for f, fo in [(function, F), (wrapper, C)])

        # rip out the arguments from our target `F`
        varnames, argcount = pycompat.code.varnames(Fc), pycompat.code.argcount(Fc)
        Fargs = varnames[:argcount]
        Fwildargs = varnames[argcount : argcount + sum(Tc)]

        # combine them into tuples for looking up variables
        co_names, co_varnames = Sargs[:], Fargs[:] + Fwildargs[:]

        # free variables (that get passed to `C`)
        co_freevars = Sargs[:2]

        # constants for code type (which consist of just the self-doc)
        co_consts = (pycompat.function.documentation(F),)

        ## figure out some things for assembling the bytecode

        # first we'll grab the call instruction type to use
        call_ = {
            (False, False) : 'CALL_FUNCTION',
            (True, False)  : 'CALL_FUNCTION_VAR' if 'CALL_FUNCTION_VAR' in cls.opcode.opmap else 'CALL_FUNCTION_KW',
            (False, True)  : 'CALL_FUNCTION_KW',
            (True, True)   : 'CALL_FUNCTION_VAR_KW' if 'CALL_FUNCTION_VAR_KW' in cls.opcode.opmap else 'CALL_FUNCTION_EX',
        }
        call = call_[Tc]

        # now we'll determine the flags to apply
        flags_ = {
            (False, False) : 0,
            (True, False)  : pycompat.co_flags.CO_VARARGS,
            (False, True)  : pycompat.co_flags.CO_VARKEYWORDS,
            (True, True)   : pycompat.co_flags.CO_VARARGS | pycompat.co_flags.CO_VARKEYWORDS
        }

        co_flags = pycompat.co_flags.CO_NESTED | pycompat.co_flags.CO_OPTIMIZED | pycompat.co_flags.CO_NEWLOCALS | flags_[Tc]

        ## assemble the code type that gets turned into a function
        code_, co_stacksize = [], 0
        asm = code_.append

        # first we'll dereference our cellvar for `wrapper`
        asm(cls.co_assemble('LOAD_DEREF', co_freevars.index('wrapper')))
        co_stacksize += 1

        # include the original `F` as the first arg
        asm(cls.co_assemble('LOAD_DEREF', co_freevars.index('F')))
        co_stacksize += 1

        # now we can include all of the original arguments (cropped by +1 if bound)
        for n in Fargs[int(bound):]:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(n)))
            co_stacksize += 1

        # include any wildcard arguments
        for n in Fwildargs:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(n)))
            co_stacksize += 1

        # call `wrapper` with the correct call type (+1 for `F`, -1 if bound)
        asm(cls.co_assemble(call, len(Fargs) + 1 - int(bound)))

        # and then return its value
        asm(cls.co_assemble('RETURN_VALUE'))

        # combine it into a single code string
        co_code = bytes().join(code_)

        ## next we'll construct the code type based on what we have
        cargs = pycompat.code.cons(
            len(Fargs), len(co_names) + len(co_varnames) + len(co_freevars),
            co_stacksize, co_flags, co_code,
            co_consts, co_names, co_varnames,
            Fc.co_filename, Fc.co_name, Fc.co_firstlineno,
            bytes(), co_freevars, ()
        )

        func_code = pycompat.code.new(cargs)

        ## and then turn it back into a function
        res = pycompat.function.new(func_code, pycompat.function.globals(F), pycompat.function.name(F), pycompat.function.defaults(F), cls.cell(*Svals))
        pycompat.function.set_name(res, pycompat.function.name(F)),
        pycompat.function.set_documentation(res, pycompat.function.documentation(F))

        return res

    # The following Py3 implementation is similar to the prior Py2 impementation,
    # except that bytecodes for the parameters being different due to CALL_FUNCTION_EX.

    @classmethod
    def assemble_38x(cls, function, wrapper, bound=False):
        """Assemble a ``types.CodeType`` that will execute `wrapper` with `F` as its first parameter.

        If `bound` is ``True``, then assume that the first parameter for `F` represents the instance it's bound to.
        """
        F, C, S = (cls.extract(item) for item in [function, wrapper, cls.assemble_38x])
        Fc, Cc, Sc = (pycompat.function.code(item) for item in [F, C, S])
        Nvarargs, Nvarkwds = 1 if cls.co_varargsQ(Fc) else 0, 1 if cls.co_varkeywordsQ(Fc) else 0

        ### build the namespaces that we'll use.

        # first we'll build the externals that get passed to the wrapper.
        Sargs = ('F', 'wrapper')
        Svals = (f if callable(f) else fo for f, fo in [(function, F), (wrapper, C)])

        # rip out the arguments from our target `F`.
        varnames, argcount = pycompat.code.varnames(Fc), pycompat.code.argcount(Fc)
        Fargs, Fdefaults = varnames[:argcount], pycompat.function.defaults(F)
        Fvarargs, Fvarkwds = varnames[argcount : argcount + Nvarargs], varnames[argcount + Nvarargs : argcount + Nvarargs + Nvarkwds]

        # combine them into tuples for looking up variables.
        co_names, co_varnames = Sargs[:], Fargs[:] + Fvarargs[:] + Fvarkwds[:]

        ## free variables (that get passed to `C`).
        co_freevars = Sargs[:2]

        ## constants for code type (which consist of just the self-doc).
        co_consts = (pycompat.function.documentation(F),)

        ## flags for the code type.
        co_flags = pycompat.co_flags.CO_NESTED | pycompat.co_flags.CO_OPTIMIZED | pycompat.co_flags.CO_NEWLOCALS
        co_flags |= pycompat.co_flags.CO_VARARGS if Nvarargs > 0 else 0
        co_flags |= pycompat.co_flags.CO_VARKEYWORDS if Nvarkwds > 0 else 0

        ### figure out some things for assembling the bytecode.
        code_, co_stacksize = [], 0
        asm = code_.append

        # first we push the callable that we need to call to wrap our function.
        asm(cls.co_assemble('LOAD_DEREF', co_freevars.index('wrapper')))
        co_stacksize += 1

        ## now we need to pack all of our parameters into a tuple starting with our
        ## `F` parameter which contains the function taht's being wrapped.
        asm(cls.co_assemble('LOAD_DEREF', co_freevars.index('F')))
        co_stacksize += 1

        # now we can include all of the original arguments (cropped by +1 if bound).
        for item in Fargs[int(bound):]:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            co_stacksize += 1

        # then we can finally pack it into a tuple
        asm(cls.co_assemble('BUILD_TUPLE', 1 + len(Fargs[int(bound):])))        # pack(F, args...)

        ## now we need to pack all wildcard arguments...
        for item in Fvarargs:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
        co_stacksize = max(2 + len(Fvarargs), co_stacksize)                     # len(varags) + build_tuple + wrapper

        # ...into this unpack-with-call tuple.
        asm(cls.co_assemble('BUILD_TUPLE_UNPACK_WITH_CALL', 1 + len(Fvarargs))) # pack(pack(F, args...), varargs)

        ## now we need to pack all kw arguments...
        for item in Fvarkwds:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
        co_stacksize = max(2 + len(Fvarkwds), co_stacksize)                     # len(varkwds) + build_tuple_unpack + wrapper

        # ...into this unpack-with-call map.
        asm(cls.co_assemble('BUILD_MAP_UNPACK_WITH_CALL', len(Fvarkwds)))       # pack(pack(F, args..., varargs), kwargs)

        ## finally we have our arguments, and can now assemble our call...
        asm(cls.co_assemble('CALL_FUNCTION_EX', 1))

        # ...and then return its value.
        asm(cls.co_assemble('RETURN_VALUE'))

        ## next we'll construct the code type using our new opcodes.

        # combine our opcodes into a single code string.
        co_code = bytes().join(code_)

        # consruct the new code object with all our fields.
        cargs = pycompat.code.cons(
            len(Fargs), len(co_names) + len(co_varnames) + len(co_freevars),
            co_stacksize, co_flags, co_code,
            co_consts, co_names, co_varnames,
            Fc.co_filename, Fc.co_name, Fc.co_firstlineno,
            bytes(), co_freevars, ()
        )

        func_code = pycompat.code.new(cargs)

        ## finally take our code object, and put it back into a function/callable.
        res = pycompat.function.new(func_code, pycompat.function.globals(F), pycompat.function.name(F), pycompat.function.defaults(F), cls.cell(*Svals))
        pycompat.function.set_name(res, pycompat.function.name(F)),
        pycompat.function.set_documentation(res, pycompat.function.documentation(F))

        return res

    # The following Py3 implementation is pretty similar to the prior one, but since the
    # BUILD_XXX_UNPACK_WITH_CALL opcodes don't exist..we end up using the BUILD_LIST with
    # LIST_TO_TUPLE and BUILD_MAP with DICT_MERGE to prepare CALL_FUNCTION_EX's parameters.

    @classmethod
    def assemble_39x(cls, function, wrapper, bound=False):
        """Assemble a ``types.CodeType`` that will execute `wrapper` with `F` as its first parameter.

        If `bound` is ``True``, then assume that the first parameter for `F` represents the instance it's bound to.
        """
        F, C, S = (cls.extract(item) for item in [function, wrapper, cls.assemble_39x])
        Fc, Cc, Sc = (pycompat.function.code(item) for item in [F, C, S])
        Nvarargs, Nvarkwds = 1 if cls.co_varargsQ(Fc) else 0, 1 if cls.co_varkeywordsQ(Fc) else 0

        ### build the namespaces that we'll use.

        # first we'll build the externals that get passed to the wrapper.
        Sargs = ('F', 'wrapper')
        Svals = (f if callable(f) else fo for f, fo in [(function, F), (wrapper, C)])

        # rip out the arguments from our target `F`.
        varnames, argcount = pycompat.code.varnames(Fc), pycompat.code.argcount(Fc)
        Fargs, Fdefaults = varnames[:argcount], pycompat.function.defaults(F)
        Fvarargs, Fvarkwds = varnames[argcount : argcount + Nvarargs], varnames[argcount + Nvarargs : argcount + Nvarargs + Nvarkwds]

        # combine them into tuples for looking up variables.
        co_names, co_varnames = Sargs[:], Fargs[:] + Fvarargs[:] + Fvarkwds[:]

        ## free variables (that get passed to `C`).
        co_freevars = Sargs[:2]

        ## constants for code type (which consist of just the self-doc).
        co_consts = (pycompat.function.documentation(F),)

        ## flags for the code type.
        co_flags = pycompat.co_flags.CO_NESTED | pycompat.co_flags.CO_OPTIMIZED | pycompat.co_flags.CO_NEWLOCALS
        co_flags |= pycompat.co_flags.CO_VARARGS if Nvarargs > 0 else 0
        co_flags |= pycompat.co_flags.CO_VARKEYWORDS if Nvarkwds > 0 else 0

        ### figure out some things for assembling the bytecode.
        code_, co_stacksize = [], 0
        asm = code_.append

        # first we push the callable that we need to call to wrap our function.
        asm(cls.co_assemble('LOAD_DEREF', co_freevars.index('wrapper')))
        co_stacksize += 1

        ## now we need to pack all of our parameters into a tuple starting with our
        ## `F` parameter which contains the function that's being wrapped.
        asm(cls.co_assemble('LOAD_DEREF', co_freevars.index('F')))
        co_stacksize += 1

        # now we can include all of the original arguments (cropped by +1 if bound).
        for item in Fargs[int(bound):]:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            co_stacksize += 1

        # then we can finally pack it into a list
        asm(cls.co_assemble('BUILD_LIST', 1 + len(Fargs[int(bound):])))         # pack(F, args)

        ## now we need to pack all wildcard arguments...
        for item in Fvarargs:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            asm(cls.co_assemble('LIST_EXTEND', 1))
        co_stacksize = max(2 + len(Fvarargs), co_stacksize)                     # wrapper + pack(F, args) + load_fast(varargs)

        # ...and convert it into a tuple
        asm(cls.co_assemble('LIST_TO_TUPLE'))

        ## now we need to pack all kw arguments...
        asm(cls.co_assemble('BUILD_MAP', 0))

        for item in Fvarkwds:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            asm(cls.co_assemble('DICT_MERGE', 1))
        co_stacksize = max(2 + len(Fvarkwds), co_stacksize)                     # wrapper + pack(F, args, varargs) + load_fast(varkwds)

        ## finally we have our arguments, and can now assemble our call...
        asm(cls.co_assemble('CALL_FUNCTION_EX', 1))

        # ...and then return its value.
        asm(cls.co_assemble('RETURN_VALUE'))

        ## next we'll construct the code type using our new opcodes.

        # combine our opcodes into a single code string.
        co_code = bytes().join(code_)

        # construct the new code object with all our fields.
        cargs = pycompat.code.cons(
            len(Fargs), len(co_names) + len(co_varnames) + len(co_freevars),
            co_stacksize, co_flags, co_code,
            co_consts, co_names, co_varnames,
            Fc.co_filename, Fc.co_name, Fc.co_firstlineno,
            bytes(), co_freevars, ()
        )

        func_code = pycompat.code.new(cargs)

        ## finally take our code object, and put it back into a function/callable.
        res = pycompat.function.new(func_code, pycompat.function.globals(F), pycompat.function.name(F), pycompat.function.defaults(F), cls.cell(*Svals))
        pycompat.function.set_name(res, pycompat.function.name(F)),
        pycompat.function.set_documentation(res, pycompat.function.documentation(F))

        return res

    # The following Py3 implementation is different from the previous one due to Py311 lining
    # up the freevars and cellvars with the varnames. This results in LOAD_DEREF using an index
    # relative to varnames to access a freevar from the captured function along with the need to
    # calculate the number of locals differently. It also seems like there's some more crap we
    # can shove in the prologue that could allow Py311 to optimize it (lol). Also.. this pasta
    # definitely seems like it's nearing its ripeness.

    @classmethod
    def assemble_311x(cls, function, wrapper, bound=False):
        """Assemble a ``types.CodeType`` that will execute `wrapper` with `F` as its first parameter.

        If `bound` is ``True``, then assume that the first parameter for `F` represents the instance it's bound to.
        """
        F, C, S = (cls.extract(item) for item in [function, wrapper, cls.assemble_39x])
        Fc, Cc, Sc = (pycompat.function.code(item) for item in [F, C, S])
        Nvarargs, Nvarkwds = 1 if cls.co_varargsQ(Fc) else 0, 1 if cls.co_varkeywordsQ(Fc) else 0

        ### build the namespaces that we'll use.

        # first we'll build the externals that get passed to the wrapper.
        Sargs = ('F', 'wrapper')
        Svals = (f if callable(f) else fo for f, fo in [(function, F), (wrapper, C)])

        # rip out the arguments from our target `F`.
        varnames, argcount = pycompat.code.varnames(Fc), pycompat.code.argcount(Fc)
        Fargs, Fdefaults = varnames[:argcount], pycompat.function.defaults(F)
        Fvarargs, Fvarkwds = varnames[argcount : argcount + Nvarargs], varnames[argcount + Nvarargs : argcount + Nvarargs + Nvarkwds]

        # combine them into tuples for looking up variables.
        co_names, co_varnames = Sargs[:], Fargs[:] + Fvarargs[:] + Fvarkwds[:]

        ## free variables (that get passed to `C`).
        co_freevars = Sargs[:2]

        ## constants for code type (which consist of just the self-doc).
        co_consts = (pycompat.function.documentation(F),)

        ## flags for the code type.
        co_flags = pycompat.co_flags.CO_NESTED | pycompat.co_flags.CO_OPTIMIZED | pycompat.co_flags.CO_NEWLOCALS
        co_flags |= pycompat.co_flags.CO_VARARGS if Nvarargs > 0 else 0
        co_flags |= pycompat.co_flags.CO_VARKEYWORDS if Nvarkwds > 0 else 0

        ### figure out some things for assembling the bytecode.
        code_, co_stacksize = [], 0
        asm = code_.append

        # push the equivalence of the prologue, which copies free variables
        # from our closure and warms up Py11's predictor (lol).
        asm(cls.co_assemble('COPY_FREE_VARS', len(co_freevars)))
        asm(cls.co_assemble('RESUME', 0))
        asm(cls.co_assemble('PUSH_NULL', 0))

        # then we push the callable that we need to call to wrap our function.
        asm(cls.co_assemble('LOAD_DEREF', len(co_varnames) + co_freevars.index('wrapper')))
        co_stacksize += 1

        ## now we need to pack all of our parameters into a tuple starting with our
        ## `F` parameter which contains the function that's being wrapped.
        asm(cls.co_assemble('LOAD_DEREF', len(co_varnames) + co_freevars.index('F')))
        co_stacksize += 1

        # now we can include all of the original arguments (cropped by +1 if bound).
        for item in Fargs[int(bound):]:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            co_stacksize += 1

        # then we can finally pack it into a list
        asm(cls.co_assemble('BUILD_LIST', 1 + len(Fargs[int(bound):])))         # pack(F, args)

        ## now we need to pack all wildcard arguments...
        for item in Fvarargs:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            asm(cls.co_assemble('LIST_EXTEND', 1))
        co_stacksize = max(2 + len(Fvarargs), co_stacksize)                     # wrapper + pack(F, args) + load_fast(varargs)

        # ...and convert it into a tuple
        asm(cls.co_assemble('LIST_TO_TUPLE'))

        ## now we need to pack all kw arguments...
        asm(cls.co_assemble('BUILD_MAP', 0))

        for item in Fvarkwds:
            asm(cls.co_assemble('LOAD_FAST', co_varnames.index(item)))
            asm(cls.co_assemble('DICT_MERGE', 1))
        co_stacksize = max(2 + len(Fvarkwds), co_stacksize)                     # wrapper + pack(F, args, varargs) + load_fast(varkwds)

        ## finally we have our arguments, and can now assemble our call...
        asm(cls.co_assemble('CALL_FUNCTION_EX', 1))

        # ...and then return its value.
        asm(cls.co_assemble('RETURN_VALUE'))

        ## next we'll construct the code type using our new opcodes.

        # combine our opcodes into a single code string.
        co_code = bytes().join(code_)

        # construct the new code object with all our fields.
        cargs = pycompat.code.cons(
            len(Fargs), len(co_varnames),
            co_stacksize, co_flags, co_code,
            co_consts, co_names, co_varnames,
            Fc.co_filename, Fc.co_name, Fc.co_firstlineno,
            bytes(), co_freevars, ()
        )

        func_code = pycompat.code.new(cargs)

        ## finally take our code object, and put it back into a function/callable.
        res = pycompat.function.new(func_code, pycompat.function.globals(F), pycompat.function.name(F), pycompat.function.defaults(F), cls.cell(*Svals))
        pycompat.function.set_name(res, pycompat.function.name(F)),
        pycompat.function.set_documentation(res, pycompat.function.documentation(F))

        return res

    def __new__(cls, callable, wrapper):
        '''Return a function similar to `callable` that calls `wrapper` with `callable` as the first argument.'''
        cons, f = cls.constructor(callable), cls.extract(callable)
        Fassemble = cls.assemble_2x if sys.version_info.major < 3 else cls.assemble_38x if sys.version_info.minor < 9 else cls.assemble_39x if sys.version_info.minor < 11 else cls.assemble_311x

        # create a wrapper for the function that'll execute `callable` with the function as its first argument, and the rest with any args
        res = Fassemble(callable, wrapper, bound=isinstance(callable, (classmethod, types.MethodType)))
        res.__module__ = getattr(callable, '__module__', getattr(callable, '__module__', '__main__'))

        # now we re-construct it and then return it
        return cons(res)

    @classmethod
    def extract(cls, object):
        '''Extract a ``types.FunctionType`` from a callable.'''

        # `object` is already a function
        if isinstance(object, types.FunctionType):
            return object

        # if it's a method, then extract the function from its propery
        elif isinstance(object, types.MethodType):
            return pycompat.method.function(object)

        # if it's a code type, then walk through all of its referrers finding one that matches it
        elif isinstance(object, types.CodeType):
            res, = (item for item in gc.get_referrers(c) if pycompat.function.name(item) == pycompat.code.name(c) and isinstance(item, types.FunctionType))
            return res

        # if it's a property decorator, then they hide the function in an attribute
        elif isinstance(object, (staticmethod, classmethod)):
            return object.__func__

        # okay, no go. we have no idea what this is.
        raise internal.exceptions.InvalidTypeOrValueError(object)

    @classmethod
    def arguments(cls, f):
        '''Extract the arguments from a function `f`.'''
        c = pycompat.function.code(f)
        count, iterable = pycompat.code.argcount(c), (item for item in pycompat.code.varnames(c))
        args = tuple(itertools.islice(iterable, count))
        res = { a : v for v, a in zip(reversed(pycompat.function.defaults(f) or []), reversed(args)) }
        starargs = next(iterable, '') if pycompat.code.flags(c) & pycompat.co_flags.CO_VARARGS else ''
        kwdargs = next(iterable, '') if pycompat.code.flags(c) & pycompat.co_flags.CO_VARKEYWORDS else ''
        return args, res, (starargs, kwdargs)

    @classmethod
    def constructor(cls, callable):
        '''Return a closure that constructs the original `callable` type from a function.'''

        # `callable` is a function type, so just return a closure that returns it
        if isinstance(callable, types.FunctionType):
            return lambda func: func

        # if it's a method type, then we just need to extract the related properties to construct it
        elif isinstance(callable, types.MethodType):
            return lambda method, self=pycompat.method.self(callable), cls=pycompat.method.type(callable): pycompat.method.new(method, self, cls)

        # if it's a property decorator, we just need to pass the function as an argument to the decorator
        elif isinstance(callable, (staticmethod, classmethod)):
            return lambda method, mt=callable.__class__: mt(method)

        # if it's a method instance, then we just need to instantiate it so that it's bound
        elif isinstance(callable, types.InstanceType):
            return lambda method, mt=callable.__class__: types.InstanceType(mt, dict(method.__dict__))

        # otherwise if it's a class or a type, then we just need to create the object with its bases
        elif isinstance(n, (builtins.type, types.ClassType)):
            return lambda method, t=callable.__class__, name=callable.__name__, bases=callable.__bases__: t(name, bases, dict(method.__dict__))

        # if we get here, then we have no idea what kind of type `callable` is
        raise internal.exceptions.InvalidTypeOrValueError(callable.__class__)

### function decorator for translating arguments belonging to a function
def transform(translate, *names):
    '''This applies the callable `translate` to any function arguments that match `names` in the decorated function.'''
    names = {name for name in names}
    def wrapper(F, *rargs, **rkwds):
        f = wrap.extract(F)
        argnames, defaults, (wildname, _) = wrap.arguments(f)

        # convert any positional arguments
        res = ()
        for value, argname in zip(rargs, argnames):
            try:
                res += (translate(value) if argname in names else value),
            except Exception as E:
                cls = E.__class__
                raise cls("{!s}: Exception raised while transforming parameter `{:s}` with value {!r}".format('.'.join([f.__module__, f.__name__]), argname, value))

        # get the rest
        for value in rargs[len(res):]:
            try:
                res += (translate(value) if wildname in names else value,)
            except Exception as E:
                cls = E.__class__
                raise cls("{!s}: Exception raised while transforming parameters `{:s}` with value {!r}".format('.'.join([f.__module__, f.__name__]), wildname, value))

        # convert any keywords arguments
        kwds = {k : v for k, v in rkwds.items()}
        for argname in {item for item in rkwds.keys()} & names:
            try:
                kwds[argname] = translate(kwds[argname])
            except Exception as E:
                cls = E.__class__
                raise cls("{!s}: Exception raised while transforming parameter `{:s}` with value {!r}".format('.'.join([f.__module__, f.__name__]), argname, kwds[argname]))
        return F(*res, **kwds)

    # decorater that wraps the function `F` with `wrapper`.
    def result(F):
        return wrap(F, wrapper)
    return result

def get_array_typecode(size, *default):
    '''Return the correct integer typecode for the given size.'''
    if hasattr(get_array_typecode, 'lookup'):
        L = getattr(get_array_typecode, 'lookup')
        return L.get(size, L.get(*default)) if default else L[size]

    # wow, wtf python...
    dword = 'L' if len(array.array('I', 4 * b'\0')) > 1 else 'I'
    qword = 'Q' if len(array.array('L', 8 * b'\0')) > 1 else 'L'

    # assign out lookup dictionary
    get_array_typecode.lookup = {
        1 : 'B',
        2 : 'H',
        4 : dword,
        8 : qword,
    }
    return get_array_typecode(size, *default)

def float_of_integer(integer, mantissa_bits, exponent_bits, sign_bits):
    """Decode the specified `integer` using the sizes provided for `mantissa_bits`, `exponent_bits`, and `sign_bits`.

    Each of the sizes are to be provided as the number of bits used to represent that component.
    """

    # Use the number of bits for each of our components to calculate the
    # total number of bits.
    fraction_bits, exponent_bits, sign_bits = mantissa_bits, exponent_bits, sign_bits
    components = [fraction_bits, exponent_bits, sign_bits]
    size = math.trunc(math.ceil(sum(components) / 8))

    # This way we can use them to build an array of the shift to get to
    # each individual position.
    position, shifts = 0, []
    for cb in components:
        shifts.append(position)
        position += cb

    # Validate the sizes match.
    if position != sum(components):
        raise ValueError("The total number of bits for the components ({:d}) does not correspond to the size ({:d}) of the integer.".format(sum(components), 8 * size))

    # Build the masks we will use to compose a floating-point number
    fraction_shift, exponent_shift, sign_shift = (pow(2, item) for item in shifts)
    bias = pow(2, exponent_bits) // 2 - 1

    fraction_mask = fraction_shift * (pow(2, fraction_bits) - 1)
    exponent_mask = exponent_shift * (pow(2, exponent_bits) - 1)
    sign_mask = sign_shift * (pow(2, sign_bits) - 1)

    # Now to decode our components...
    mantissa = (integer & fraction_mask) // fraction_shift
    exponent = (integer & exponent_mask) // exponent_shift
    sign = (integer & sign_mask) // sign_shift

    # ...and then convert it into a float
    if exponent > 0 and exponent < pow(2, exponent_bits) - 1:
        s = -1 if sign else +1
        e = exponent - bias
        m = 1.0 + float(mantissa) / pow(2, fraction_bits)
        return math.ldexp(math.copysign(m, s), e)

    # Check if we need to return any special constants
    if exponent == pow(2, exponent_bits) - 1 and mantissa == 0:
        return float('-inf') if sign else float('+inf')
    elif exponent in {0, pow(2, fraction_bits) - 1} and mantissa != 0:
        return float('-nan') if sign else float('+nan')
    elif exponent == 0 and mantissa == 0:
        return float('-0') if sign else float('+0')

    # Raise an exception as we weren't able to decode the semantics for
    # each component.
    raise ValueError("Unable to decode integer ({:#x}) using the values extracted for the mantissa ({:#x}), exponent ({:#x}), and sign flag ({:d}).".format(integer, mantissa, exponent, sign))

def float_to_integer(float, mantissa_bits, exponent_bits, sign_bits):
    """Encode the specified `float` using the sizes provided for `mantissa_bits`, `exponent_bits`, and `sign_bits`.

    Each of the sizes are to be provided as the number of bits used to represent that component.
    """
    exponentbias = pow(2, exponent_bits) // 2 - 1

    # Figure out what type of floating-point number this is
    if math.isnan(float):
        sign, exponent, mantissa = 0, pow(2, exponent_bits) - 1, ~0
    elif math.isinf(float):
        sign, exponent, mantissa = 1 if float < 0 else 0, pow(2, exponent_bits) - 1, 0
    elif float == 0.0 and math.atan2(float, float) < 0.0:
        sign, exponent, mantissa = 1, 0, 0
    elif float == 0.0 and math.atan2(float, float) == 0.0:
        sign, exponent, mantissa = 0, 0, 0
    else:
        # First extract the exponent and the mantissa
        m, e = math.frexp(float)

        # Now we need to copy out the sign flag
        sign = 1 if math.copysign(1.0, m) < 0 else 0

        # Adjust the exponent so that we can remove the implicit bit
        exponent = e + exponentbias - 1
        m = abs(m) * 2.0 - 1.0 if exponent else abs(m)

        # Finally we need to convert the fractional mantissa into an integer
        mantissa = math.trunc(m * pow(2, mantissa_bits))

    # Calculate the shift and mask for each component of the encoded float
    components = [mantissa_bits, exponent_bits, sign_bits]
    position, shifts = 0, []
    for cb in components:
        shifts.append(position)
        position += cb
    mantissa_shift, exponent_shift, sign_shift = (pow(2, item) for item in shifts)
    mantissa_mask, exponent_mask, sign_mask = (pow(2, item) - 1 for item in components)

    # Now to store each component into an integer that we can return
    res = 0
    res += (sign & sign_mask) * sign_shift
    res += (exponent & exponent_mask) * exponent_shift
    res += (mantissa & mantissa_mask) * mantissa_shift
    return res

```

`base/database.py`:

```py
"""
Database module

This module exposes a number of tools that can be used on a database
and on addresses within the database. There are a number of namespaces
that allow one to query information about the database as a whole, or to
read/write to an address within the database.

The base argument type for many of the utilites within this module is
the address. This can allow one to modify the colors or comments for an
address, or to read/write from the different types of data that might
exist at an address.

Some namespaces are also provided for querying the available symbolic
information that IDA has discovered about a binary. This can be used
to search and navigate the database. Some of the available namespaces
that can be used for querying are ``functions``, ``segments``,
``names``, ``imports``, ``entries``, and ``marks``.
"""

import six, builtins

import functools, operator, itertools, types
import sys, os, logging, string, bisect
import math, codecs, array as _array, fnmatch, re, ctypes

import function, segment
import structure as _structure, instruction as _instruction
import ui, internal
from internal import utils, interface, exceptions as E

import idaapi

## properties
def here():
    '''Return the current address.'''
    return ui.current.address()
h = utils.alias(here)

@utils.multicase()
def within():
    '''Should always return true.'''
    return within(ui.current.address())
@utils.multicase(ea=six.integer_types)
def within(ea):
    '''Return true if address `ea` is within the bounds of the database.'''
    left, right = config.bounds()
    return left <= ea < right
contains = utils.alias(within)

def top():
    '''Return the very lowest address within the database.'''
    ea, _ = config.bounds()
    return ea
def bottom():
    '''Return the very highest address within the database.'''
    _, ea = config.bounds()
    return ea

class config(object):
    """
    This namespace contains various read-only properties about the
    database. This includes things such as the database boundaries,
    its filename, the path to the generated database, etc. Some tools
    for determining the type of the binary are also included.
    """

    # cache the default value for the structure
    info = idaapi.get_inf_structure()

    @classmethod
    def __init_info_structure__(cls, idp_modname):
        information = idaapi.get_inf_structure()
        if information:
            logging.debug(u"{:s}.__init_info_structure__({!s}) : Successfully fetched and cached information structure for database.".format('.'.join([__name__, cls.__name__]), utils.string.escape(idp_modname, '"')))

            # Display summary of the database and what it's used for.
            bits = "{:d}-bit".format(64 if information.is_64bit() else 32 if information.is_32bit() else 16)
            format = 'library' if information.lflags & idaapi.LFLG_IS_DLL else 'binary'

            if idaapi.__version__ < 7.0:
                byteorder = "{:s}-endian".format('big' if idaapi.cvar.inf.mf else 'little')
            else:
                byteorder = "{:s}-endian".format('big' if information.lflags & idaapi.LFLG_MSF else 'little')

            if idaapi.__version__ >= 7.0:
                mode = ' kernelspace' if information.lflags & idaapi.LFLG_KERNMODE else ' userspace'
            else:
                mode = ''
            logging.warning("Initialized {tag!s} database v{version:d} for {bits:s} {byteorder:s}{mode:s} {format:s}.".format('.'.join([information.__class__.__module__, information.__class__.__name__]), tag=information.tag, bits=bits, byteorder=byteorder, mode=mode, format=format, version=information.version))

        else:
            logging.fatal(u"{:s}.__init_info_structure__({!s}) : Unknown error while trying to get information structure for database.".format('.'.join([__name__, cls.__name__]), utils.string.escape(idp_modname, '"')))
        cls.info = information

    @classmethod
    def __nw_init_info_structure__(cls, nw_code, is_old_database):
        logging.debug(u"{:s}.__nw_init_info_structure__({!s}) : Received notification to initialize information structure for database.".format('.'.join([__name__, cls.__name__]), ', '.join(map("{!r}".format, [nw_code, is_old_database]))))
        idp_modname = idaapi.get_idp_name()
        return cls.__init_info_structure__(idp_modname)

    @utils.multicase()
    @classmethod
    def lflags(cls):
        '''Return the value of the ``idainfo.lflags`` field from the database.'''
        if idaapi.__version__ < 7.2:
            return cls.info.lflags
        return idaapi.inf_get_lflags()
    @utils.multicase(mask=six.integer_types)
    @classmethod
    def lflags(cls, mask):
        '''Return the value of the ``idainfo.lflags`` field from the database with the specified `mask`.'''
        if idaapi.__version__ < 7.2:
            return cls.info.lflags & mask
        return idaapi.inf_get_lflags() & mask
    @utils.multicase(mask=six.integer_types, value=six.integer_types)
    @classmethod
    def lflags(cls, mask, value):
        '''Set the ``idainfo.lflags`` with the provided `mask` from the database to the specified `value`.'''
        if idaapi.__version__ < 7.2:
            result, cls.info.lflags = cls.info.lflags, (result & ~mask) | (value & mask)
            return result

        # Newer versions of IDA use the idaapi.inf_get_lflags() function.
        result = idaapi.inf_get_lflags()
        if not idaapi.inf_set_lflags((result & ~mask) | (value & mask)):
            raise E.DisassemblerError(u"{:s}.lflags({:#x}, {:#x}) : Unable to modify the flags in idainfo.lflags ({:#x} & {:#x}) to the specified value ({:s}).".format('.'.join([__name__, cls.__name__]), result, mask, "{:#x} & {:#x}".format(value, mask) if value & ~mask else "{:#x}".format(value)))
        return result

    @classmethod
    def filename(cls):
        '''Return the filename that the database was built from.'''
        res = idaapi.get_root_filename()
        return utils.string.of(res)

    @classmethod
    def idb(cls):
        '''Return the full path to the database.'''
        res = idaapi.cvar.database_idb if idaapi.__version__ < 7.0 else idaapi.get_path(idaapi.PATH_TYPE_IDB)
        res = utils.string.of(res)
        return res.replace(os.sep, '/')
    database = utils.alias(idb, 'config')

    @classmethod
    def module(cls):
        '''Return the module name as per the windows loader.'''
        res = cls.filename()
        res = os.path.split(res)
        return os.path.splitext(res[1])[0]

    @utils.multicase()
    @classmethod
    def path(cls):
        '''Return the absolute path to the directory containing the database.'''
        res = cls.idb()
        path, _ = os.path.split(res)
        return path
    @utils.multicase(pathname=six.string_types)
    @classmethod
    def path(cls, pathname, *components):
        '''Return an absolute path composed of the provided `pathname` and any additional `components` relative to the directory containing the database.'''
        res = cls.idb()
        path, _ = os.path.split(res)
        return os.path.join(path, pathname, *components)

    @classmethod
    def baseaddress(cls):
        '''Return the baseaddress of the database.'''
        return idaapi.get_imagebase()

    @classmethod
    def is_readonly(cls):
        '''Return whether the database is read-only or not.'''
        if idaapi.__version__ < 7.0:
            raise E.UnsupportedVersion(u"{:s}.readonly() : This function is only supported on versions of IDA 7.0 and newer.".format('.'.join([__name__, cls.__name__])))
        elif idaapi.__version__ < 7.2:
            return cls.info.readonly_idb()
        return idaapi.inf_readonly_idb()
    readonlyQ = utils.alias(is_readonly, 'config')

    @classmethod
    def is_sharedobject(cls):
        '''Return whether the database is a shared-object or not.'''
        if idaapi.__version__ < 7.0:
            raise E.UnsupportedVersion(u"{:s}.is_sharedobject() : This function is only supported on versions of IDA 7.0 and newer.".format('.'.join([__name__, cls.__name__])))
        return True if cls.lflags(idaapi.LFLG_IS_DLL) else False
    sharedobject = is_shared = is_dll = sharedQ = utils.alias(is_sharedobject, 'config')

    @classmethod
    def is_kernelspace(cls):
        '''Return whether the database is using a kernelmode address space or not.'''
        if idaapi.__version__ < 7.0:
            raise E.UnsupportedVersion(u"{:s}.is_kernelspace() : This function is only supported on versions of IDA 7.0 and newer.".format('.'.join([__name__, cls.__name__])))
        return True if cls.lflags(idaapi.LFLG_KERNMODE) else False
    kernelspaceQ = kernelQ = utils.alias(is_kernelspace, 'config')

    @utils.multicase()
    @classmethod
    def filetype(cls):
        '''Return the file type identified by the loader when creating the database.'''
        if idaapi.__version__ < 7.2:
            return cls.info.filetype
        return idaapi.inf_get_filetype()
    @utils.multicase(filetype_t=six.integer_types)
    @classmethod
    def filetype(cls, filetype_t):
        '''Set the file type identified by the loader to the specified `filetype_t`.'''
        if idaapi.__version__ < 7.2:
            result, cls.info.filetype = cls.info.filetype, filetype_t
            return result

        # Newer versions of IDA use the idaapi.inf_get_filetype() and idaapi.inf_set_filetype() functions.
        result = idaapi.inf_get_filetype()
        if not idaapi.inf_set_filetype(filetype_t):
            raise E.DisassemblerError(u"{:s}.filetype({:#x}) : Unable to set value for idainfo.filetype to the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), filetype_t, filetype_t))
        return result
    @utils.multicase(FT_=six.string_types)
    @classmethod
    def filetype(cls, FT_):
        '''Set the file type identified by the loader to the value for the string `FT_`.'''
        prefix, choice = 'FT_', FT_.upper()
        candidates = {prefix + choice, choice}

        # Grab all of our available choices from the idc module since they're not defined anywhere else.
        import idc
        filtered = ((name, getattr(idc, name)) for name in dir(idc) if name.startswith(prefix))
        choices = {item : value for item, value in filtered if isinstance(value, six.integer_types)}

        # Find a valid choice by iterating through each one and seeing if its in our list of candidates.
        iterable = (value for item, value in choices.items() if item in candidates)
        value = builtins.next(iterable, None)
        if value is None:
            raise E.ItemNotFoundError(u"{:s}.filetype({!r}) : Unable to find the requested file type ({!r}) in the list of choices.".format('.'.join([__name__, cls.__name__]), FT_, string))

        # We found it, so we can recurse into the correct case to assign it.
        return cls.filetype(value)

    @utils.multicase()
    @classmethod
    def ostype(cls):
        '''Return the operating system type identified by the loader when creating the database.'''
        # FIXME: this is a bitflag that should be documented in libfuncs.hpp
        #        which unfortunately is not included anywhere in the sdk.
        if idaapi.__version__ < 7.2:
            return cls.info.ostype
        return idaapi.inf_get_ostype()
    @utils.multicase(ostype_t=six.integer_types)
    @classmethod
    def ostype(cls, ostype_t):
        '''Set the operating system type for the database to the specified `ostype_t`.'''
        if idaapi.__version__ < 7.2:
            result, cls.info.ostype = cls.info.ostype, ostype_t
            return result

        # Newer versions of IDA use the idaapi.inf_get_filetype() and idaapi.inf_set_filetype() functions.
        result = idaapi.inf_get_ostype()
        if not idaapi.inf_set_ostype(ostype_t):
            raise E.DisassemblerError(u"{:s}.ostype({:#x}) : Unable to set value for idainfo.ostype to the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), ostype_t, ostype_t))
        return result
    @utils.multicase(OSTYPE_=six.string_types)
    @classmethod
    def ostype(cls, OSTYPE_):
        '''Set the operating system type for the database to the value for the string `OSTYPE_`.'''
        prefix, choice = 'OSTYPE_', OSTYPE_.upper()
        candidates = {prefix + choice, choice}

        # Grab all of our available choices from the idc module since they're not defined anywhere else.
        import idc
        filtered = ((name, getattr(idc, name)) for name in dir(idc) if name.startswith(prefix))
        choices = {item : value for item, value in filtered if isinstance(value, six.integer_types)}

        # Find a valid choice by iterating through each one and seeing if its in our list of candidates.
        iterable = (value for item, value in choices.items() if item in candidates)
        value = builtins.next(iterable, None)
        if value is None:
            raise E.ItemNotFoundError(u"{:s}.ostype({!r}) : Unable to find the requested operating system type ({!r}) in the list of choices.".format('.'.join([__name__, cls.__name__]), OSTYPE_, string))

        # We found it, so we can recurse into the correct case to assign it.
        return cls.ostype(value)

    @utils.multicase()
    @classmethod
    def apptype(cls):
        '''Return the application type identified by the loader when creating the database.'''
        # FIXME: this is a bitflag that should be documented in libfuncs.hpp
        #        which unfortunately is not included anywhere in the sdk.
        if idaapi.__version__ < 7.2:
            return cls.info.apptype
        return idaapi.inf_get_apptype()
    @utils.multicase(apptype_t=six.integer_types)
    @classmethod
    def apptype(cls, apptype_t):
        '''Set the application type for the database to the specified `apptype_t`.'''
        if idaapi.__version__ < 7.2:
            result, cls.info.apptype = cls.info.ostype, apptype_t
            return result

        # Newer versions of IDA use the idaapi.inf_get_filetype() and idaapi.inf_set_filetype() functions.
        result = idaapi.inf_get_apptype()
        if not idaapi.inf_set_apptype(apptype_t):
            raise E.DisassemblerError(u"{:s}.apptype({:#x}) : Unable to set value for idainfo.apptype to the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), apptype_t, apptype_t))
        return result
    @utils.multicase(APPT_=six.string_types)
    @classmethod
    def apptype(cls, APPT_):
        '''Set the application type for the database to the value for the string `APPT_`.'''
        prefix, choice = 'APPT_', APPT_.upper()
        candidates = {prefix + choice, choice}

        # Grab all of our available choices from the idc module since they're not defined anywhere else.
        import idc
        filtered = ((name, getattr(idc, name)) for name in dir(idc) if name.startswith(prefix))
        choices = {item : value for item, value in filtered if isinstance(value, six.integer_types)}

        # Find a valid choice by iterating through each one and seeing if its in our list of candidates.
        iterable = (value for item, value in choices.items() if item in candidates)
        value = builtins.next(iterable, None)
        if value is None:
            raise E.ItemNotFoundError(u"{:s}.apptype({!r}) : Unable to find the requested application type ({!r}) in the list of choices.".format('.'.join([__name__, cls.__name__]), APPT_, string))

        # We found it, so we can recurse into the correct case to assign it.
        return cls.apptype(value)

    @classmethod
    def changes(cls):
        '''Return the number of changes within the database.'''
        if idaapi.__version__ < 7.0:
            raise E.UnsupportedVersion(u"{:s}.changes() : This function is only supported on versions of IDA 7.0 and newer.".format('.'.join([__name__, cls.__name__])))
        elif idaapi.__version__ < 7.2:
            return cls.info.database_change_count
        return idaapi.inf_get_database_change_count()

    @classmethod
    def processor(cls):
        '''Return the name of the processor used by the database.'''
        if idaapi.__version__ < 7.0:
            raise E.UnsupportedVersion(u"{:s}.processor() : This function is only supported on versions of IDA 7.0 and newer.".format('.'.join([__name__, cls.__name__])))
        elif hasattr(cls.info, 'procName'):
            result = cls.info.procName
        else:
            result = idaapi.inf_get_procname()
        return utils.string.of(result)

    @classmethod
    def compiler(cls):
        '''Return the compiler that was configured for the database.'''
        if idaapi.__version__ < 7.2:
            return cls.info.cc

        # Newer versions of IDA use the idaapi.inf_get_cc() function.
        cc = idaapi.compiler_info_t()
        if not idaapi.inf_get_cc(cc):
            raise E.DisassemblerError(u"{:s}.processor() : Unable to fetch the value for the idainfo.cc attribute.".format('.'.join([__name__, cls.__name__])))
        return cc
    @classmethod
    def version(cls):
        '''Return the version of the database.'''
        if idaapi.__version__ < 7.2:
            return cls.info.version
        return idaapi.inf_get_version()

    @classmethod
    def type(cls, typestr):
        '''Evaluates a type string and returns its size according to the compiler used by the database.'''
        lookup = {
            'bool': 'size_b',
            'short': 'size_s',
            'int': 'size_i', 'float': 'size_l', 'single': 'size_l',
            'long': 'size_l',
            'longlong': 'size_ll', 'double': 'size_ll',
            'enum': 'size_e',
            'longdouble': 'size_ldbl',
            'align': 'defalign', 'alignment': 'defalign',
        }
        string = typestr.replace(' ', '')
        return getattr(cls.compiler(), lookup.get(string.lower(), typestr.lower()))

    @classmethod
    def bits(cls):
        '''Return number of bits of the processor used by the database.'''
        result = cls.lflags(idaapi.LFLG_PC_FLAT | idaapi.LFLG_64BIT)
        if result & idaapi.LFLG_64BIT:
            return 64
        elif result & idaapi.LFLG_PC_FLAT:
            return 32
        return 32 if result & idaapi.LFLG_FLAT_OFF32 else 16

    @classmethod
    def size(cls):
        '''Return the number of bytes used by the database which can be used to distinguish whether you're running 32-bit or 64-bit.'''
        import ida_typeinf

        # This is a trick gifted by me by rolfr through his comprehensive
        # knowledge of IDA internals in order to get this attribute in the
        # exact way that IDA does it. We use the ida_typeinf module instead
        # of idaapi in order to preserve this tech throughout history in the
        # way it was bestowed upon us...

        tif = ida_typeinf.tinfo_t()
        tif.create_ptr(ida_typeinf.tinfo_t(ida_typeinf.BT_VOID))
        return tif.get_size()

    @classmethod
    def bitsize(cls):
        '''Return the number of bits used by the database.'''
        return 8 * cls.size()

    @classmethod
    def byteorder(cls):
        '''Return a string representing the byte-order used by integers in the database.'''
        if idaapi.__version__ < 7.0:
            res = idaapi.cvar.inf.mf
            return 'big' if res else 'little'
        return 'big' if cls.lflags(idaapi.LFLG_MSF) else 'little'

    @classmethod
    def main(cls):
        if idaapi.__version__ < 7.2:
            return cls.info.main
        return idaapi.inf_get_main()

    @classmethod
    def entry(cls):
        '''Return the first entry point for the database.'''
        if idaapi.__version__ < 7.2:
            return cls.info.start_ea
        return idaapi.inf_get_start_ea()

    @classmethod
    def margin(cls):
        '''Return the current margin position for the current database.'''
        return cls.info.margin if idaapi.__version__ < 7.2 else idaapi.inf_get_margin()

    @classmethod
    def bounds(cls):
        '''Return the bounds of the current database in a tuple formatted as `(left, right)`.'''
        if idaapi.__version__ < 7.2:
            min, max = cls.info.minEA, cls.info.maxEA
        else:
            min, max = idaapi.inf_get_min_ea(), idaapi.inf_get_max_ea()
        return interface.bounds_t(min, max)

    class register(object):
        """
        This namespace returns the available register names and their
        sizes for the database.
        """
        @classmethod
        def names(cls):
            '''Return all of the register names in the database.'''
            names = idaapi.ph_get_regnames()
            return [utils.string.of(item) for item in names]
        @classmethod
        def segments(cls):
            '''Return all of the segment registers in the database.'''
            sreg_first, sreg_last = (idaapi.ph_get_regFirstSreg, idaapi.ph_get_regLastSreg) if idaapi.__version__ < 7.0 else (idaapi.ph_get_reg_first_sreg, idaapi.ph_get_reg_last_sreg)

            names = cls.names()
            return [names[ri] for ri in builtins.range(sreg_first(), 1 + sreg_last())]
        @classmethod
        def codesegment(cls):
            '''Return all of the code segment registers in the database.'''
            res = idaapi.ph_get_regCodeSreg() if idaapi.__version__ < 7.0 else idaapi.ph_get_reg_code_sreg()
            return cls.names()[res]
        @classmethod
        def datasegment(cls):
            '''Return all of the data segment registers in the database.'''
            res = idaapi.ph_get_regDataSreg() if idaapi.__version__ < 7.0 else idaapi.ph_get_reg_data_sreg()
            return cls.names()[res]
        @classmethod
        def segmentbits(cls):
            '''Return the segment register size for the database.'''
            return 8 * idaapi.ph_get_segreg_size()

range = utils.alias(config.bounds, 'config')
filename, idb, module, path = utils.alias(config.filename, 'config'), utils.alias(config.idb, 'config'), utils.alias(config.module, 'config'), utils.alias(config.path, 'config')
path = utils.alias(config.path, 'config')
baseaddress = base = utils.alias(config.baseaddress, 'config')

class functions(object):
    r"""
    This namespace is used for listing all the functions inside the
    database. By default a list is returned containing the address of
    each function.

    When listing functions that are matched, the following legend can be
    used to identify certain characteristics about them:

        `+` - The function has an implicit tag (named or typed)
        `*` - The function has been explicitly tagged
        `J` - The function is a wrapper or a thunk
        `L` - The function was pattern matched as a library
        `S` - The function is declared statically
        `^` - The function does not contain a frame
        `?` - The function has its stack points calculated incorrectly and may be incorrect
        `T` - The function has a prototype that was applied to it manually or via decompilation
        `t` - The function has a prototype that was guessed
        `D` - The function has been previously decompiled

    The different types that one can match functions with are the following:

        `address` or `ea` - Match according to the function's address
        `name` - Match according to the exact name
        `like` - Filter the function names according to a glob
        `regex` - Filter the function names according to a regular-expression
        `typed` - Filter the functions for any that have type information applied to them
        `decompiled` - Filter the functions for any that have been decompiled
        `frame` - Filter the functions for any that contain a frame
        `problems` - Filter the functions for any that contain problems with their stack
        `library` - Filter the functions that any which were detected as a library function
        `wrapper` - Filter the functions that are flagged as wrappers (thunks)
        `exceptions` Filter the functions for any that either handles an exception or sets up a handler
        `tagged` - Filter the functions for any that use the specified tag(s)
        `predicate` - Filter the functions by passing their ``idaapi.func_t`` to a callable

    Some examples of how to use these keywords are as follows::

        > for ea in database.functions(): ...
        > database.functions.list('*sub*')
        > iterable = database.functions.iterate(regex='.*alloc')
        > result = database.functions.search(like='*alloc*')

    """
    __matcher__ = utils.matcher()
    __matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), function.by, function.name)
    __matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), function.by, function.name)
    __matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), function.by, function.name)
    __matcher__.boolean('address', function.contains), __matcher__.boolean('ea', function.contains)
    __matcher__.mapping('typed', operator.truth, function.top, lambda ea: idaapi.get_tinfo2(ea, idaapi.tinfo_t()) if idaapi.__version__ < 7.0 else idaapi.get_tinfo(idaapi.tinfo_t(), ea))
    __matcher__.mapping('decompiled', operator.truth, function.type.is_decompiled)
    __matcher__.mapping('frame', operator.truth, function.type.has_frame)
    __matcher__.mapping('library', operator.truth, function.by, operator.attrgetter('flags'), utils.fpartial(operator.and_, idaapi.FUNC_LIB))
    __matcher__.mapping('wrapper', operator.truth, function.by, operator.attrgetter('flags'), utils.fpartial(operator.and_, idaapi.FUNC_THUNK))
    __matcher__.boolean('tagged', lambda parameter, keys: operator.truth(keys) == parameter if isinstance(parameter, bool) else operator.contains(keys, parameter) if isinstance(parameter, six.string_types) else keys & builtins.set(parameter), function.top, function.tag, operator.methodcaller('keys'), builtins.set)
    __matcher__.predicate('predicate', function.by)
    __matcher__.predicate('pred', function.by)

    if any(hasattr(idaapi, item) for item in ['is_problem_present', 'QueueIsPresent']):
        __matcher__.mapping('problems', operator.truth, function.top, utils.frpartial(function.type.has_problem, getattr(idaapi, 'PR_BADSTACK', 0xb)))

    if all(hasattr(idaapi, Fname) for Fname in ['tryblks_t', 'get_tryblks']):
        __matcher__.mapping('exceptions', operator.truth, function.by, lambda fn: idaapi.get_tryblks(idaapi.tryblks_t(), fn), utils.fpartial(operator.ne, 0))

    # chunk matching
    #__matcher__.boolean('greater', operator.le, utils.fcompose(function.chunks, functools.partial(map, builtins.list, operator.itemgetter(-1)), max)), __matcher__.boolean('gt', operator.lt, utils.fcompose(function.chunks, functools.partial(map, builtins.list, operator.itemgetter(-1)), max))
    #__matcher__.boolean('less', operator.ge, utils.fcompose(function.chunks, functools.partial(map, builtins.list, operator.itemgetter(0)), min)), __matcher__.boolean('lt', operator.gt, utils.fcompose(function.chunks, functools.partial(map, builtins.list, operator.itemgetter(0)), min))

    # entry point matching
    __matcher__.boolean('greater', operator.le, function.top), __matcher__.boolean('gt', operator.lt, function.top)
    __matcher__.boolean('less', operator.ge, function.top), __matcher__.boolean('lt', operator.gt, function.top)

    def __new__(cls):
        '''Return a list of all of the functions in the current database.'''
        return [item for item in cls.__iterate__()]

    @utils.multicase()
    @classmethod
    def __iterate__(cls):
        '''Iterates through all of the functions in the current database (ripped from idautils).'''
        left, right = config.bounds()

        # find first function chunk
        ch = idaapi.get_fchunk(left) or idaapi.get_next_fchunk(left)
        while ch and interface.range.start(ch) < right and (ch.flags & idaapi.FUNC_TAIL) != 0:
            ui.navigation.procedure(interface.range.start(ch))
            ch = idaapi.get_next_fchunk(interface.range.start(ch))

        # iterate through the rest of the functions in the database
        while ch and interface.range.start(ch) < right:
            ui.navigation.procedure(interface.range.start(ch))
            if function.within(interface.range.start(ch)):
                yield interface.range.start(ch)
            ch = idaapi.get_next_func(interface.range.start(ch))
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def iterate(cls, string):
        '''Iterate through all of the functions in the database with a glob that matches `string`.'''
        return cls.iterate(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def iterate(cls, **type):
        '''Iterate through all of the functions in the database that match the keyword specified by `type`.'''
        iterable = cls.__iterate__()
        for key, value in (type or {'predicate': utils.fconstant(True)}).items():
            iterable = cls.__matcher__.match(key, value, iterable)
        for item in iterable: yield item

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def list(cls, string):
        '''List all of the functions in the database with a glob that matches `string`.'''
        return cls.list(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def list(cls, **type):
        '''List all of the functions in the database that match the keyword specified by `type`.'''
        listable = []

        # Some utility functions for grabbing counts of function attributes
        Fcount_lvars = utils.fcompose(function.frame.lvars, utils.count)
        Fcount_avars = utils.fcompose(function.frame.args.iterate, utils.count)

        # Set some reasonable defaults here
        maxentry = config.bounds()[0]
        maxaddr = minaddr = maxchunks = 0
        maxname = maxunmangled = chunks = marks = blocks = exits = 0
        lvars = avars = refs = 0

        # First pass through the list to grab the maximum lengths of the different fields
        for ea in cls.iterate(**type):
            func, _ = function.by(ea), ui.navigation.procedure(ea)
            maxentry = max(ea, maxentry)

            unmangled, realname = function.name(func), name(ea)
            maxname = max(len(unmangled), maxname)
            maxunmangled = max(len(unmangled), maxunmangled) if not internal.declaration.mangledQ(realname) else maxunmangled

            bounds, items = function.bounds(func), [item for item in function.chunks(func)]
            maxaddr, minaddr = max(max(bounds), maxaddr), max(min(bounds), minaddr)
            maxchunks = max(len(items), maxchunks)

            # Figure out the maximum values for each of these attributes
            blocks = max(len(builtins.list(function.blocks(func, silent=True))), blocks)
            exits = max(len(builtins.list(function.bottom(func))), exits)
            refs = max(len(xref.up(ea)), refs)
            lvars = max(Fcount_lvars(func) if idaapi.get_frame(ea) else 0, lvars)
            avars = max(Fcount_avars(func), avars)

            listable.append(ea)

        # Collect the number of digits for everything from the first pass
        cindex = utils.string.digits(len(listable), 10) if listable else 1
        try: cmaxoffset = utils.string.digits(offset(maxentry), 16)
        except E.OutOfBoundsError: cmaxoffset = 0
        cmaxentry, cmaxaddr, cminaddr = (utils.string.digits(item, 16) for item in [maxentry, maxaddr, minaddr])
        cchunks, cblocks, cexits, cavars, clvars, crefs = (utils.string.digits(item, 10) for item in [maxchunks, blocks, exits, avars, lvars, refs])

        # List all the fields of every single function that was matched
        for index, ea in enumerate(listable):
            func, decompiledQ = function.by(ui.navigation.procedure(ea)), interface.node.aflags(ui.navigation.procedure(ea), getattr(idaapi, 'AFL_HR_DETERMINED', 0xc0000000))
            tags = function.tag(ea)

            # any flags that might be useful
            ftagged = '-' if not tags else '*' if any(not item.startswith('__') for item in tags) else '+'
            ftyped = 'D' if function.type.is_decompiled(ea) else '-' if not function.type.has_typeinfo(func) else 'T' if interface.node.aflags(ea, idaapi.AFL_USERTI) else 't'
            fframe = '?' if function.type.has_problem(ea, getattr(idaapi, 'PR_BADSTACK', 0xb)) else '-' if idaapi.get_frame(ea) else '^'
            fgeneral = 'J' if func.flags & idaapi.FUNC_THUNK else 'L' if func.flags & idaapi.FUNC_LIB else 'S' if func.flags & idaapi.FUNC_STATICDEF else 'F'
            flags = itertools.chain(fgeneral, fframe, ftyped, ftagged)

            # naming information
            unmangled, realname = function.name(func), name(ea)

            # chunks and boundaries
            chunks = [item for item in function.chunks(func)]
            bounds = function.bounds(func)

            # try/except handlers
            if all(hasattr(idaapi, Fname) for Fname in ['tryblks_t', 'get_tryblks']):
                tb = idaapi.tryblks_t()
                blkcount = idaapi.get_tryblks(tb, func)
                trycount = sum(tb[i].is_cpp() for i in builtins.range(blkcount))
                iterable = (tb[i].cpp() if tb[i].is_cpp() else tb[i].seh() for i in builtins.range(tb.size()))
                ehcount = sum(item.size() for item in iterable)

            else:
                tb = None
                blkcount = trycount = ehcount = 0

            # now we can output everything that was found
            six.print_(u"{:<{:d}s} {:+#0{:d}x} : {:#0{:d}x}..{:#0{:d}x} : {:<{:d}s} {:s} : {:<{:d}s} : refs:{:<{:d}d} args:{:<{:d}d} lvars:{:<{:d}d} blocks:{:<{:d}d} exits:{:<{:d}d}{:s}".format(
                "[{:d}]".format(index), 2 + math.trunc(cindex),
                offset(ea), 3 + math.trunc(cmaxoffset),
                bounds[0], 2 + math.trunc(cminaddr), bounds[1], 2 + math.trunc(cmaxaddr),
                "({:d})".format(len(chunks)), 2 + cchunks, ''.join(flags),
                unmangled, math.trunc(maxname if internal.declaration.mangledQ(realname) else maxunmangled),
                len(xref.up(ea)), crefs,
                Fcount_avars(func), cavars,
                Fcount_lvars(func) if idaapi.get_frame(ea) else 0, clvars,
                len(builtins.list(function.blocks(func, silent=True))), cblocks,
                len(builtins.list(function.bottom(func))), cexits,
                " exceptions:{:d}+{:d}/{:d}".format(blkcount - trycount, trycount, ehcount) if tb else ''
            ))
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def search(cls, string):
        '''Search through all of the functions matching the glob `string` and return the first result.'''
        return cls.search(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def search(cls, **type):
        '''Search through all of the functions within the database and return the first result matching the keyword specified by `type`.'''
        query_s = utils.string.kwargs(type)

        listable = [item for item in cls.iterate(**type)]
        if len(listable) > 1:
            messages = ((u"[{:d}] {:s}".format(i, function.name(ea))) for i, ea in enumerate(listable))
            [ logging.info(msg) for msg in messages ]
            f = utils.fcompose(function.by, function.name)
            logging.warning(u"{:s}.search({:s}) : Found {:d} matching results. Returning the first function \"{:s}\".".format('.'.join([__name__, cls.__name__]), query_s, len(listable), utils.string.escape(f(listable[0]), '"')))

        iterable = (item for item in listable)
        res = builtins.next(iterable, None)
        if res is None:
            raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format('.'.join([__name__, cls.__name__]), query_s))
        return res

class segments(object):
    r"""
    This namespace is used for listing all the segments inside the
    database. By default each segment's boundaries are yielded.

    The different types that one can match segments with are the following:

        `name` - Match according to the true segment name
        `like` - Filter the segment names according to a glob
        `regex` - Filter the segment names according to a regular-expression
        `index` - Match the segment by its index
        `identifier` - Match the segment by its identifier (``idaapi.segment_t.name``)
        `selector` - Match the segment by its selector (``idaapi.segment_t.sel``)
        `greater` or `gt` - Filter the segments for any after the specified address
        `less` or `lt` - Filter the segments for any before the specified address
        `predicate` - Filter the segments by passing its ``idaapi.segment_t`` to a callable

    Some examples of using these keywords are as follows::

        > for l, r in database.segments(): ...
        > database.segments.list(regex=r'\.r?data')
        > iterable = database.segments.iterate(like='*text*')
        > result = database.segments.search(greater=0x401000)

    """

    def __new__(cls):
        '''Yield the bounds of each segment within the current database.'''
        for seg in segment.__iterate__():
            yield interface.range.bounds(seg)
        return

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def list(cls, name):
        '''List all of the segments defined in the database that match the glob `name`.'''
        return cls.list(like=name)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def list(cls, **type):
        '''List all of the segments in the database that match the keyword specified by `type`.'''
        return segment.list(**type)

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def iterate(cls, name):
        '''Iterate through all of the segments in the database with a glob that matches `name`.'''
        return cls.iterate(like=name)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def iterate(cls, **type):
        '''Iterate through all the segments defined in the database matching the keyword specified by `type`.'''
        return segment.__iterate__(**type)

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def search(cls, name):
        '''Search through all of the segments matching the glob `name` and return the first result.'''
        return cls.search(like=name)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def search(cls, **type):
        '''Search through all of the segments within the database and return the first result matching the keyword specified by `type`.'''
        return segment.search(**type)

@utils.multicase()
def instruction():
    '''Return the instruction at the current address as a string.'''
    return instruction(ui.current.address())
@utils.multicase(ea=six.integer_types)
def instruction(ea):
    '''Return the instruction at the address `ea` as a string.'''
    ash = idaapi.cvar.ash if idaapi.__version__ < 7.5 else idaapi.get_ash()
    cmnt1, cmnt2 = ash.cmnt, ash.cmnt2

    # first grab the disassembly and then remove all of IDA's tag information from it
    insn = idaapi.generate_disasm_line(interface.address.inside(ea))
    unformatted = idaapi.tag_remove(insn)

    # if there's a terminating comment character, locate it, and then slice out just the comment
    if cmnt2:
        lindex = unformatted.rfind(cmnt1)
        rindex = lindex + unformatted[lindex:].find(cmnt2) + len(cmnt2)
        nocomment = unformatted if lindex < 0 else unformatted[:lindex] if rindex < 0 else (nocomment[:lindex] + nocomment[rindex:])

    # there's no terminating comment character, so we just need to cull out everything after cmnt1
    elif cmnt1:
        index = unformatted.rfind(cmnt1)
        nocomment = unformatted if index < 0 else unformatted[:index]

    # if the starting cmnt1 character isn't defined, then we don't do anything.
    else:
        nocomment = unformatted

    # combine any multiple spaces into just a single space and return it
    res = utils.string.of(nocomment.strip())
    return functools.reduce(lambda agg, char: agg + (('' if agg.endswith(' ') else ' ') if char == ' ' else char), res, '')

@utils.multicase()
def disassemble(**options):
    '''Disassemble the instructions at the current address.'''
    return disassemble(ui.current.address(), **options)
@utils.multicase(ea=six.integer_types)
def disassemble(ea, **options):
    """Disassemble the instructions at the address specified by `ea`.

    If the integer `count` is specified, then return `count` number of instructions.
    If the bool `comments` is true, then return the comments for each instruction as well.
    """
    ea = interface.address.inside(ea)
    commentQ = builtins.next((options[k] for k in ['comment', 'comments'] if k in options), False)

    # grab the values we need in order to distinguish a comment
    ash = idaapi.cvar.ash if idaapi.__version__ < 7.5 else idaapi.get_ash()
    cmnt1, cmnt2 = ash.cmnt, ash.cmnt2

    # enter a loop that goes through the number of line items requested by the user
    res, count = [], options.get('count', 1)
    while count > 0:
        # grab the instruction and remove all of IDA's tag information from it
        insn = idaapi.generate_disasm_line(ea) or ''
        unformatted = idaapi.tag_remove(insn)

        # check if the terminating char (cmnt2) is defined
        if cmnt2:
            lindex = unformatted.rfind(cmnt1)
            rindex = lindex + unformatted[lindex:].find(cmnt2) + len(cmnt2)

            # so that we can separate the comment out of it
            nocomment = unformatted if lindex < 0 else unformatted[:lindex] if rindex < 0 else (nocomment[:lindex] + nocomment[rindex:])
            comment = unformatted[lindex : lindex] if lindex < 0 else unformatted[lindex:] if rindex < 0 else comment[lindex : rindex]

        # if it's not, then just use the starting char (cmnt1) to find the comment
        elif cmnt1:
            index = unformatted.rfind(cmnt1)
            nocomment, comment = (unformatted, unformatted[index : index]) if index < 0 else (unformatted[:index], unformatted[index:])

        # if this comment is undefined, then there ain't shit we can do with it,
        # and we need to just append it as-is
        else:
            res.append(u"{:x}: {:s}".format(ea, unformatted.strip()))

        # remove any surrounding spaces from the instruction
        stripped = nocomment.strip()

        # combine all multiple spaces together so it's single-spaced
        noextraspaces = functools.reduce(lambda agg, char: agg + (('' if agg.endswith(' ') else ' ') if char == ' ' else char), utils.string.of(stripped), '')

        # if we've been asked to include the comment, then first we need to clean
        # it up a bit.
        if commentQ:
            cleaned = comment[len(cmnt1) : -len(cmnt2)] if cmnt2 else comment[len(cmnt1):]
            stripped = cleaned.strip()

            # then we can concatenate it with our instruction and its comment characters
            withcharacters = u''.join([u"{:s} ".format(cmnt1) if cmnt1 else u'', stripped, u" {:s}".format(cmnt2) if cmnt2 else u''])

            # and then we can append it to our result
            res.append(u"{:x}: {:s}{:s}".format(ea, noextraspaces, u" {:s}".format(withcharacters) if stripped else ''))

        # otherwise we cna simply append it to our result with the address in front
        else:
            res.append(u"{:x}: {:s}".format(ea, noextraspaces))

        # move on to the next iteration
        ea = address.next(ea) if count > 1 else address.tail(ea)
        count -= 1
    return '\n'.join(res)
disasm = utils.alias(disassemble)

@utils.multicase()
def read():
    '''Return the bytes defined at the current selection or address.'''
    address, selection = ui.current.address(), ui.current.selection()
    if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
        return read(address, type.size(address))
    return read(selection)
@utils.multicase(ea=six.integer_types)
def read(ea):
    '''Return the number of bytes associated with the address `ea`.'''
    return read(ea, type.size(ea))
@utils.multicase(ea=six.integer_types, size=six.integer_types)
def read(ea, size):
    '''Return `size` number of bytes from address `ea`.'''
    get_bytes = idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes
    start, end = interface.address.within(ea, ea + size)
    return get_bytes(ea, end - start) or b''
@utils.multicase(bounds=tuple)
def read(bounds):
    '''Return the bytes within the specified `bounds`.'''
    get_bytes = idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes
    bounds = ea, _ = interface.bounds_t(*bounds)
    return get_bytes(ea, bounds.size) or b''

@utils.multicase(data=b''.__class__)
def write(data, **persist):
    '''Modify the database at the current address with the bytes specified in `data`.'''
    return write(ui.current.address(), data, **persist)
@utils.multicase(ea=six.integer_types, data=b''.__class__)
def write(ea, data, **persist):
    """Modify the database at address `ea` with the bytes specified in `data`

    If the bool `persist` is specified, then modify what IDA considers the original bytes.
    """
    patch_bytes, put_bytes = (idaapi.patch_many_bytes, idaapi.put_many_bytes) if idaapi.__version__ < 7.0 else (idaapi.patch_bytes, idaapi.put_bytes)

    ea, _ = interface.address.within(ea, ea + len(data))
    originalQ = builtins.next((persist[k] for k in ['original', 'persist', 'store', 'save'] if k in persist), False)
    return patch_bytes(ea, data) if originalQ else put_bytes(ea, data)

class names(object):
    """
    This namespace is used for listing all of the names (symbols) within the
    database. By default the `(address, name)` is yielded in its mangled form.

    When listing names that are matched, the following legend can be used to
    identify certain characteristics about the address of the returned name:

        `I` - The symbol is residing in an import segment
        `C` - The address of the symbol is marked as code
        `D` - The address of the symbol is marked as data
        `^` - The address of the symbol is is initialized
        `+` - The symbol has an implicit tag applied to it (named or typed)
        `*` - The symbol has an explicit tag applied to it

    The available types that one can filter the symbols with are as follows:

        `address` - Match according to the address of the symbol
        `name` - Match according to the name of the unmangled symbol
        `unmangled` - Filter the unmangled symbol names according to a regular-expression
        `like` - Filter the symbol names according to a glob
        `regex` - Filter the symbol names according to a regular-expression
        `index` - Match the symbol according to its index
        `function` - Filter the symbol names for any that are referring to a function
        `imports` - Filter the symbol names for any that are imports
        `typed` - Filter the symbol names for any that have type information applied to them
        `tagged` - Filter the symbol names for any that use the specified tag(s)
        `predicate` - Filter the symbols by passing their address to a callable

    Some examples of using these keywords are as follows::

        > list(database.names())
        > database.names.list(index=31)
        > iterable = database.names.iterate(like='str.*')
        > result = database.names.search(name='some_really_sick_symbol_name')

    """
    __matcher__ = utils.matcher()
    __matcher__.mapping('address', idaapi.get_nlist_ea), __matcher__.mapping('ea', idaapi.get_nlist_ea)
    __matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), idaapi.get_nlist_name, internal.declaration.demangle)
    __matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_nlist_name, utils.string.of)
    __matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_nlist_name, utils.string.of)
    __matcher__.combinator('unmangled', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_nlist_name, internal.declaration.demangle)
    __matcher__.combinator('demangled', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_nlist_name, internal.declaration.demangle)
    __matcher__.mapping('function', function.within, idaapi.get_nlist_ea)
    __matcher__.mapping('imports', utils.fpartial(operator.eq, idaapi.SEG_XTRN), idaapi.get_nlist_ea, idaapi.segtype)
    __matcher__.boolean('tagged', lambda parameter, keys: operator.truth(keys) == parameter if isinstance(parameter, bool) else operator.contains(keys, parameter) if isinstance(parameter, six.string_types) else keys & builtins.set(parameter), idaapi.get_nlist_ea, lambda ea: function.tag(ea) if function.within(ea) else tag(ea), operator.methodcaller('keys'), builtins.set)
    __matcher__.mapping('typed', operator.truth, idaapi.get_nlist_ea, lambda ea: idaapi.get_tinfo2(ea, idaapi.tinfo_t()) if idaapi.__version__ < 7.0 else idaapi.get_tinfo(idaapi.tinfo_t(), ea))
    __matcher__.predicate('predicate', idaapi.get_nlist_ea)
    __matcher__.predicate('pred', idaapi.get_nlist_ea)
    __matcher__.attribute('index')

    def __new__(cls):
        '''Iterate through all of the names in the database yielding a tuple of the address and its name.'''
        for index in builtins.range(idaapi.get_nlist_size()):
            res = zip([idaapi.get_nlist_ea, utils.fcompose(idaapi.get_nlist_name, utils.string.of)], 2 * [index])
            yield tuple(f(x) for f, x in res)
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def __iterate__(cls, string):
        return cls.__iterate__(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def __iterate__(cls, **type):
        iterable = (idx for idx in builtins.range(idaapi.get_nlist_size()))
        for key, value in (type or {'predicate': utils.fconstant(True)}).items():
            iterable = cls.__matcher__.match(key, value, iterable)
        for item in iterable: yield item

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def iterate(cls, string):
        '''Iterate through all of the names in the database with a glob that matches `string`.'''
        return cls.iterate(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def iterate(cls, **type):
        '''Iterate through all of the names in the database that match the keyword specified by `type`.'''
        for idx in cls.__iterate__(**type):
            ea, name = idaapi.get_nlist_ea(idx), idaapi.get_nlist_name(idx)
            yield ea, utils.string.of(name)
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def list(cls, string):
        '''List all of the names in the database with a glob that matches `string`.'''
        return cls.list(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def list(cls, **type):
        '''List all of the names in the database that match the keyword specified by `type`.'''
        MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
        Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_DATA, MANGLED_UNKNOWN))
        MNG_NODEFINIT, MNG_NOPTRTYP, MNG_LONG_FORM = getattr(idaapi, 'MNG_NODEFINIT', 8), getattr(idaapi, 'MNG_NOPTRTYP', 7), getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)

        # Set some reasonable defaults
        maxindex = 1
        maxaddr = maxname = 0

        # Perform the first pass through our listable grabbing our field lengths
        listable = []
        for index in cls.__iterate__(**type):
            maxindex = max(index, maxindex)
            maxaddr = max(idaapi.get_nlist_ea(index), maxaddr)
            maxname = max(len(idaapi.get_nlist_name(index)), maxname)

            listable.append(index)

        # Collect the sizes from our first pass
        cindex, caddr = utils.string.digits(maxindex, 10), utils.string.digits(maxaddr, 16)

        # List all the fields of each name that was found
        for index in listable:
            ea, name = ui.navigation.set(idaapi.get_nlist_ea(index)), utils.string.of(idaapi.get_nlist_name(index))
            tags = function.tag(ea) if function.within(ea) else tag(ea)

            # Any flags that could be useful
            ftype = 'I' if idaapi.segtype(ea) == idaapi.SEG_XTRN else '-' if t.is_unknown(ea) else 'C' if t.is_code(ea) else 'D' if t.is_data(ea) else '-'
            finitialized = '^' if t.is_initialized(ea) else '-'
            tags.pop('__name__', None)
            ftagged = '-' if not tags else '*' if any(not item.startswith('__') for item in tags) else '+'
            flags = itertools.chain(finitialized, ftype, ftagged)

            # Figure out which name we need to use, the mangled one or the real one.
            mangled_name_type_t = Fmangled_type(utils.string.to(name))
            realname = name if mangled_name_type_t == MANGLED_UNKNOWN else (idaapi.demangle_name(utils.string.to(name), MNG_NODEFINIT|MNG_NOPTRTYP) or name)

            # Now we can just try to demangle the name and display both mangled and unmangled forms.
            description = utils.string.of(idaapi.demangle_name(utils.string.to(name), MNG_LONG_FORM) or realname)
            six.print_(u"{:<{:d}s} {:#0{:d}x} : {:s} : {:>{:d}s} : {:s}".format("[{:d}]".format(index), 2 + math.trunc(cindex), ea, math.trunc(caddr), ''.join(flags), '' if realname == name else "({:s})".format(name), 2 + maxname, description))
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def search(cls, string):
        '''Search through all of the names matching the glob `string` and return the first result.'''
        return cls.search(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def search(cls, **type):
        '''Search through all of the names within the database and return the first result matching the keyword specified by `type`.'''
        MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
        Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE if type.is_code(ea) else MANGLED_DATA, MANGLED_UNKNOWN))
        MNG_LONG_FORM = getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)

        query_s = utils.string.kwargs(type)
        listable = [item for item in cls.__iterate__(**type)]
        if len(listable) > 1:
            f1, f2 = idaapi.get_nlist_ea, utils.fcompose(idaapi.get_nlist_name, utils.string.of)
            messages = ((u"[{:d}] {:#x} {:s}".format(idx, ea, name if Fmangled_type(utils.string.to(name)) == MANGLED_UNKNOWN else "({:s}) {:s}".format(name, utils.string.of(idaapi.demangle_name(name, MNG_LONG_FORM) or name))) for idx, ea, name in map(utils.fmap(utils.fidentity, f1, f2), listable)))
            [ logging.info(msg) for msg in messages ]
            logging.warning(u"{:s}.search({:s}) : Found {:d} matching results, Returning the first item at {:#x} with the name \"{:s}\".".format('.'.join([__name__, cls.__name__]), query_s, len(listable), f1(listable[0]), utils.string.escape(f2(listable[0]), '"')))

        iterable = (item for item in listable)
        res = builtins.next(iterable, None)
        if res is None:
            raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format('.'.join([__name__, cls.__name__]), query_s))
        return idaapi.get_nlist_ea(res)

    @utils.multicase()
    @classmethod
    def symbol(cls):
        '''Return the symbol name of the current address.'''
        return cls.symbol(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def symbol(cls, ea):
        '''Return the symbol name of the address `ea`.'''
        res = idaapi.get_nlist_idx(ea)
        return utils.string.of(idaapi.get_nlist_name(res))
    name = utils.alias(symbol, 'names')

    @classmethod
    def address(cls, index):
        '''Return the address of the symbol at `index`.'''
        return idaapi.get_nlist_ea(index)

    @utils.multicase()
    @classmethod
    def at(cls):
        '''Return the index, symbol address, and name at the current address.'''
        return cls.at(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, ea):
        '''Return the index, symbol address, and name at the address `ea`.'''
        idx = idaapi.get_nlist_idx(ea)
        ea, name = idaapi.get_nlist_ea(idx), idaapi.get_nlist_name(idx)
        return idx, ea, utils.string.of(name)

class search(object):
    """
    This namespace used for searching the database using IDA's find
    functionality.

    By default the name is used, however there are 4 search methods
    that are available. The methods that are provided are:

        ``search.by_bytes`` - Search by the specified hex bytes
        ``search.by_regex`` - Search by the specified regex
        ``search.by_text``  - Search by the specified text
        ``search.by_name``  - Search by the specified name

    Each search method has its own options, but all of them take an extra
    boolean option, `reverse`, which specifies whether to search backwards
    from the starting position or forwards.

    The ``search.iterate`` function allows one to iterate through all the results
    discovered in the database. One variation of ``search.iterate`` takes a 3rd
    parameter `predicate`. This allows usage of one of the search methods provided
    or to allow a user to include their own. This function will then yield each
    matched search result.
    """

    @utils.multicase()
    @classmethod
    def by_bytes(cls, data, **direction):
        '''Search through the database at the current address for the bytes specified by `data`.'''
        return cls.by_bytes(ui.current.address(), data, **direction)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def by_bytes(cls, ea, data, **direction):
        """Search through the database at address `ea` for the bytes specified by `data`.

        If `reverse` is specified as a bool, then search backwards from the given address.
        If `radix` is specified, then use it as the numerical radix for describing the bytes.
        If `radix` is not specified, then assume that `data` represents the exact bytes to search.
        """
        radix = direction.get('radix', 0)
        left, right = config.bounds()

        # Figure out the correct format depending on the radix that we were given by the caller.
        formats = {8: "{:0o}".format, 10: "{:d}".format, 16: "{:02X}".format}
        if radix and not operator.contains(formats, radix):
            raise E.InvalidParameterError(u"{:s}.by_bytes({:#x}, {:s}{:s}) : In invalid radix ({:d}) was specified.".format('.'.join([__name__, search.__name__]), ea, '...' if isinstance(data, idaapi.compiled_binpat_vec_t) else utils.string.repr(data), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', radix))
        format = formats[radix or 16]

        # If we're using an earlier version of IDA, then we need to completely build the query ourselves.
        if idaapi.__version__ < 7.5:

            # Convert the bytes directly into a string of base-10 integers.
            if (isinstance(data, b''.__class__) and radix == 0) or isinstance(data, bytearray):
                query = ' '.join(map(format, bytearray(data)))

            # Convert the string directly into a string of base-10 integers.
            elif isinstance(data, six.string_types) and radix == 0:
                query = ' '.join(map(format, itertools.chain(*(((ord(ch) & 0xff00) // 0x100, (ord(ch) & 0x00ff) // 0x1) for ch in data))))

            # Otherwise, leave it alone because the user specified the radix already.
            else:
                query = data

            # Assign our flags according to whatever the direction the user gave us.
            reversed = builtins.next((direction[k] for k in ['reverse', 'reversed', 'up', 'backwards'] if k in direction), False)
            flags = idaapi.SEARCH_UP if reversed else idaapi.SEARCH_DOWN

            # Now we can start our actual searching for things.
            start, stop = (left, ea) if reversed else (ea, right)
            res = idaapi.find_binary(start, stop, utils.string.to(query), radix or 16, idaapi.SEARCH_CASE | flags)
            if res == idaapi.BADADDR:
                raise E.SearchResultsError(u"{:s}.by_bytes({:#x}, {:s}{:s}) : The specified bytes ({!s}) were not found.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(data), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', query))
            return res

        # Now that we know the radix, if we were given bytes then we need to format them into the right query.
        if isinstance(data, (b''.__class__, bytearray)):
            query = ' '.join(map(format, bytearray(data)))

        # If we were given a string, then we need to encode it into some bytes.
        elif isinstance(data, six.string_types):
            query = ' '.join(map(format, itertools.chain(*(((ord(ch) & 0xff00) // 0x100, (ord(ch) & 0x00ff) // 0x1) for ch in data))))

        # If we were given an idaapi.compiled_binpat_vec_t already, then the user knows what they're doing.
        elif isinstance(data, idaapi.compiled_binpat_vec_t):
            query = data

        else:
            raise E.InvalidParameterError(u"{:s}.by_bytes({:#x}, {:s}{:s}) : A query of an unsupported type ({!s}) was provided.".format('.'.join([__name__, search.__name__]), ea, '...' if isinstance(data, idaapi.compiled_binpat_vec_t) else utils.string.repr(data), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', string.__class__))

        # Now we can actually parse what we were given if we weren't already given a pattern.
        if not isinstance(query, idaapi.compiled_binpat_vec_t):
            patterns = idaapi.compiled_binpat_vec_t()

            # It seems that idaapi.parse_binpat_str() returns an empty string on success, and None on failure...
            res = idaapi.parse_binpat_str(patterns, ea, utils.string.to(query), radix, direction.get('encoding', 0))
            ok = not (res is None)

        # Otherwise we were given an idaapi.compiled_binpat_vec_t, and we don't need to do any parsing.
        else:
            ok, patterns = len(query) > 0, query

        # If parsing has failed in some way, then throw up an error for the user to act upon.
        if not ok:
            queries = (' '.join(map(format, bytearray(item.bytes))) for item in patterns) if len(patterns) else [query]
            raise E.InvalidParameterError(u"{:s}.by_bytes({:#x}, {:s}{:s}) : Unable to parse the specified quer{:s} ({:s}).".format('.'.join([__name__, search.__name__]), ea, '...' if isinstance(data, idaapi.compiled_binpat_vec_t) else utils.string.repr(data), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', 'ies' if len(patterns) > 1 else 'y', ', '.join("\"{:s}\"".format(utils.string.escape(item, '"')) for item in queries)))

        # Once we have our pattern, let's figure first figure out our direction flags.
        reversed = builtins.next((direction[k] for k in ['reverse', 'reversed', 'up', 'backwards'] if k in direction), False)

        # Then we figure out what case option the user gave us if there was one.
        if any(k in direction for k in ['case', 'sensitive', 'casesensitive']):
            foldcase = not builtins.next(direction[k] for k in ['case', 'sensitive', 'casesensitive'])

        elif any(k in direction for k in ['fold', 'folded', 'foldcase', 'insensitive', 'nocase', 'caseless', 'caseinsensitive']):
            foldcase = builtins.next(direction[k] for k in ['fold', 'folded', 'foldcase', 'insensitive', 'nocase', 'caseless', 'caseinsensitive'])

        # Otherwise we'll be doing a case-insensitive search (non-folded case).
        else:
            foldcase = False

        # Finally we can update the flags with whatever the user gave us.
        flags = direction.get('flags', 0)
        flags |= idaapi.BIN_SEARCH_BACKWARD if reversed else idaapi.BIN_SEARCH_FORWARD
        flags |= idaapi.BIN_SEARCH_NOCASE if foldcase else idaapi.BIN_SEARCH_CASE

        # Now we actually perform our idaapi.bin_search().
        result = idaapi.bin_search(left, ea, patterns, flags) if reversed else idaapi.bin_search(ea, right, patterns, flags)
        if result == idaapi.BADADDR:
            queries = (' '.join(map(format, bytearray(item.bytes))) for item in patterns)
            raise E.SearchResultsError(u"{:s}.by_bytes({:#x}, {:s}{:s}) : The specified bytes described by the quer{:s} ({:s}) were not found.".format('.'.join([__name__, search.__name__]), ea, '...' if isinstance(data, idaapi.compiled_binpat_vec_t) else utils.string.repr(data), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', 'ies' if len(patterns) > 1 else 'y', ', '.join("\"{:s}\"".format(utils.string.escape(item, '"')) for item in queries)))
        return result

    bybytes = utils.alias(by_bytes, 'search')

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def by_regex(cls, string, **options):
        '''Search through the database at the current address for the regex matched by `string`.'''
        return cls.by_regex(ui.current.address(), string, **options)
    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def by_regex(cls, ea, string, **options):
        """Search the database at address `ea` for the regex matched by `string`.

        If `reverse` is specified as a bool, then search backwards from the given address.
        If `sensitive` is specified as bool, then perform a case-sensitive search.
        """
        queryF = utils.string.to

        reversed = builtins.next((options[k] for k in ['reverse', 'reversed', 'up', 'backwards'] if k in options), False)
        flags = idaapi.SEARCH_REGEX
        flags |= idaapi.SEARCH_UP if reversed else idaapi.SEARCH_DOWN
        flags |= idaapi.SEARCH_CASE if options.get('sensitive', False) else 0
        res = idaapi.find_text(ea, 0, 0, queryF(string), flags)
        if res == idaapi.BADADDR:
            raise E.SearchResultsError(u"{:s}.by_regex({:#x}, \"{:s}\"{:s}) : The specified regex was not found.".format('.'.join([__name__, cls.__name__]), ea, utils.string.escape(string, '"'), u", {:s}".format(utils.string.kwargs(options)) if options else '', res))
        return res
    byregex = utils.alias(by_regex, 'search')

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def by_text(cls, string, **options):
        '''Search through the database at the current address for the text matched by `string`.'''
        return cls.by_text(ui.current.address(), string, **options)
    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def by_text(cls, ea, string, **options):
        """Search the database at address `ea` for the text matched by `string`.

        If `reverse` is specified as a bool, then search backwards from the given address.
        If `sensitive` is specified as bool, then perform a case-sensitive search.
        """
        queryF = utils.string.to

        reversed = builtins.next((options[k] for k in ['reverse', 'reversed', 'up', 'backwards'] if k in options), False)
        flags = 0
        flags |= idaapi.SEARCH_UP if reversed else idaapi.SEARCH_DOWN
        flags |= idaapi.SEARCH_CASE if options.get('sensitive', False) else 0
        res = idaapi.find_text(ea, 0, 0, queryF(string), flags)
        if res == idaapi.BADADDR:
            raise E.SearchResultsError(u"{:s}.by_text({:#x}, \"{:s}\"{:s}) : The specified text was not found.".format('.'.join([__name__, cls.__name__]), ea, utils.string.escape(string, '"'), u", {:s}".format(utils.string.kwargs(options)) if options else '', res))
        return res
    bytext = by_string = bystring = utils.alias(by_text, 'search')

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by_name(cls, name, **options):
        '''Search through the database at the current address for the symbol `name`.'''
        return cls.by_name(ui.current.address(), name, **options)
    @utils.multicase(ea=six.integer_types, name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by_name(cls, ea, name, **options):
        """Search through the database at address `ea` for the symbol `name`.

        If `reverse` is specified as a bool, then search backwards from the given address.
        If `sensitive` is specified as bool, then perform a case-sensitive search.
        """
        queryF = utils.string.to

        reversed = builtins.next((options[k] for k in ['reverse', 'reversed', 'up', 'backwards'] if k in options), False)
        flags = idaapi.SEARCH_IDENT
        flags |= idaapi.SEARCH_UP if reversed else idaapi.SEARCH_DOWN
        flags |= idaapi.SEARCH_CASE if options.get('sensitive', False) else 0
        res = idaapi.find_text(ea, 0, 0, queryF(name), flags)
        if res == idaapi.BADADDR:
            raise E.SearchResultsError(u"{:s}.by_name({:#x}, \"{:s}\"{:s}) : The specified name was not found.".format('.'.join([__name__, cls.__name__]), ea, utils.string.escape(name, '"'), u", {:s}".format(utils.string.kwargs(options)) if options else '', res))
        return res
    byname = utils.alias(by_name, 'search')

    @utils.multicase(pattern=(six.string_types, b''.__class__, bytearray))
    @classmethod
    def iterate(cls, pattern, **options):
        '''Iterate through all search results that match the `pattern` starting at the current address.'''
        predicate = options.pop('predicate', cls)
        return cls.iterate(ui.current.address(), pattern, predicate, **options)
    @utils.multicase(ea=six.integer_types, pattern=(six.string_types, b''.__class__, bytearray))
    @classmethod
    def iterate(cls, ea, pattern, **options):
        '''Iterate through all search results that match the specified `pattern` starting at address `ea`.'''
        predicate = options.pop('predicate', cls)
        return cls.iterate(ea, pattern, predicate, **options)
    @utils.multicase(pattern=(six.string_types, b''.__class__, bytearray))
    @classmethod
    def iterate(cls, pattern, predicate, **options):
        '''Iterate through all search results matched by the function `predicate` with the specified `pattern` starting at the current address.'''
        return cls.iterate(ui.current.address(), pattern, predicate, **options)
    @utils.multicase(ea=six.integer_types, pattern=(six.string_types, b''.__class__, bytearray))
    @classmethod
    def iterate(cls, ea, pattern, predicate, **options):
        '''Iterate through all search results matched by the function `predicate` with the specified `pattern` starting at address `ea`.'''
        reversed = builtins.next((options[k] for k in ['reverse', 'reversed', 'up', 'backwards'] if k in options), False)
        Fnext = address.prev if reversed else address.next

        # If our predicate is a string, then we need to ensure that it's one that
        # we know about. We cheat here by checking it against our current namespace.
        if isinstance(predicate, six.string_types) and not hasattr(cls, predicate):
            raise E.InvalidParameterError(u"{:s}.iterate({:#x}, {:s}, {:s}, {:s}) : The provided predicate ({:s}) is unknown and does not refer to anything within the \"{:s}\" namespace.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(pattern), utils.string.repr(predicate), u", {:s}".format(utils.string.kwargs(options)) if options else '', predicate, cls.__name__))

        # Now we either grab the predicate from the namespace or use it as-is.
        predicate = getattr(cls, predicate) if isinstance(predicate, six.string_types) else predicate

        # Now we can begin our traversal of all search results using it.
        try:
            ea = predicate(ea, pattern, **options)
            while ea != idaapi.BADADDR:
                yield ea
                ea = predicate(Fnext(ea), pattern, **options)
        except E.SearchResultsError:
            return
        return

    @utils.multicase()
    def __new__(cls, pattern, **direction):
        '''Search through the database at the current address for the specified `pattern`.'''
        return cls(ui.current.address(), pattern, **direction)
    @utils.multicase(ea=six.integer_types)
    def __new__(cls, ea, pattern, **direction):
        """Search through the database at address `ea` for the specified `pattern`.'''

        If `reverse` is specified as a bool, then search backwards from the given address.
        If `radix` is specified, then use it as the numerical radix for describing the bytes.
        If `radix` is not specified, then assume that `data` represents the exact bytes to search.
        """
        if idaapi.__version__ < 7.5:
            direction.setdefault('radix', 16)
            return cls.by_bytes(ea, pattern, **direction)

        # If we're using a more recent version of IDA, then we can actually allow users to
        # specify their own full queries here. If they already gave us an idaapi.compiled_binpat_vec_t,
        # then we just pass that through onto by_bytes.
        if isinstance(pattern, idaapi.compiled_binpat_vec_t):
            return cls.by_bytes(ea, pattern, **direction)

        # Check if we were given multiple patterns for any particular reason and
        # combine them into a list so we can parse them all individually.
        listable = pattern if isinstance(pattern, (builtins.tuple, builtins.set, builtins.list)) else [pattern]
        patterns = [pattern for pattern in listable]

        # Extract the radix if we were given one so that we can pretty up the logs.
        radix, formats = direction.get('radix', 16), {8: "{:0o}".format, 10: "{:d}".format, 16: "{:02x}".format}
        if not operator.contains(formats, radix):
            raise E.InvalidParameterError(u"{:s}({:#x}, {:s}{:s}) : In invalid radix ({:d}) was specified.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(patterns), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', radix))
        format = formats[radix]

        # Now we need to parse them all individually into an idaapi.compiled_binpat_vec_t().
        result = idaapi.compiled_binpat_vec_t()
        for index, item in enumerate(patterns):

            # If we were given some bytes instead of a string, then format them into a
            # proper string using the specified radix.
            string = ' '.join(map(format, bytearray(item))) if isinstance(item, (b''.__class__, bytearray)) else item

            # Now to parse each one with idaapi.parse_binpat_str(), but of course the idaapi.parse_binpat_str()
            # api returns an empty string on success and a None on failure.
            if idaapi.parse_binpat_str(result, ea, utils.string.to(string), radix, direction.get('encoding', idaapi.PBSENC_ALL)) is None:
                raise E.DisassemblerError(u"{:s}({:#x}, {:s}{:s}) : Unable to parse the provided pattern {:s}(\"{:s}\").".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(patterns), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', "at index {:d} ".format(index) if len(patterns) > 1 else '', utils.string.escape(string, '"')))

            # Log what was just parsed to help with debugging things.
            parsed = result[index]
            description = "{:s}" if parsed.all_bytes_defined() else "{:s}) with mask ({:s}"
            logging.info(u"{:s}({:#x}, {:s}{:s}) : Successfully parsed the pattern at index {:d} (\"{:s}\") into bytes ({:s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(patterns), u", {:s}".format(utils.string.kwargs(direction)) if direction else '', index, utils.string.escape(string, '"'), description.format(*(' '.join(map(format, bytearray(item))) for item in [parsed.bytes, parsed.mask]))))

        # Everything was parsed, so we should be able to just hand things off to by_bytes.
        return cls.by_bytes(ea, result, **direction)

byname = by_name = utils.alias(search.by_name, 'search')

def go(ea):
    '''Jump to the specified address at `ea`.'''
    if isinstance(ea, six.string_types):
        ea = search.by_name(None, ea)
    idaapi.jumpto(interface.address.inside(ea))
    return ea
jump = jump_to = jumpto = utils.alias(go)

def go_offset(offset):
    '''Jump to the specified `offset` within the database.'''
    res, ea = address.offset(ui.current.address()), address.by_offset(offset)
    idaapi.jumpto(interface.address.inside(ea))
    return res
goof = gooffset = gotooffset = goto_offset = utils.alias(go_offset)

@utils.multicase()
def name(**flags):
    '''Return the name at the current address.'''
    return name(ui.current.address(), **flags)
@utils.multicase(ea=six.integer_types)
def name(ea, **flags):
    """Return the name defined at the address specified by `ea`.

    If `flags` is specified, then use the specified value as the flags.
    """
    ea = interface.address.inside(ea)

    # figure out what default flags to use
    fn = idaapi.get_func(ea)

    # figure out which name function to call
    if idaapi.__version__ < 6.8:
        # if get_true_name is going to return the function's name instead of a real one, then leave it as unnamed.
        if fn and interface.range.start(fn) == ea and not flags:
            return None

        aname = idaapi.get_true_name(ea) or idaapi.get_true_name(ea, ea)
    else:
        aname = idaapi.get_ea_name(ea, flags.get('flags', idaapi.GN_LOCAL))

    # return the name at the specified address or not
    return utils.string.of(aname) or None
@utils.multicase(packed=tuple)
def name(packed, **flags):
    '''Renames the current address to the given `packed` name.'''
    return name(ui.current.address(), *packed, **flags)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def name(string, *suffix, **flags):
    '''Renames the current address to `string`.'''
    return name(ui.current.address(), string, *suffix, **flags)
@utils.multicase(none=None.__class__)
def name(none, **flags):
    '''Removes the name at the current address.'''
    return name(ui.current.address(), none or '', **flags)
@utils.multicase(packed=tuple)
def name(ea, packed, **flags):
    '''Renames the address specifed by `ea` to the given `packed` name.'''
    return name(ea, *packed, **flags)
@utils.multicase(ea=six.integer_types, string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def name(ea, string, *suffix, **flags):
    """Renames the address specified by `ea` to `string`.

    If `ea` is pointing to a global and is not contained by a function, then by default the label will be added to the Names list.
    If `flags` is specified, then use the specified value as the flags.
    If the boolean `listed` is specified, then specify whether to add the label to the Names list or not.
    """
    # combine name with its suffix
    res = (string,) + suffix
    string = interface.tuplename(*res)

    # validate the address, and get the original flags
    ea = interface.address.inside(ea)
    ofl = type.flags(ea)

    ## define some closures that perform the different tasks necessary to
    ## apply a name to a given address
    def apply_name(ea, string, F):
        '''Apply the name in `string` to the address `ea` with the flags specified in `F`.'''

        # convert the specified string into a form that IDA can handle
        ida_string = utils.string.to(string)

        # validate the name
        res = idaapi.validate_name2(ida_string[:]) if idaapi.__version__ < 7.0 else idaapi.validate_name(ida_string[:], idaapi.VNT_VISIBLE)
        if ida_string and ida_string != res:
            logging.info(u"{:s}.name({:#x}, \"{:s}\"{:s}) : Stripping invalid chars from specified name resulted in \"{:s}\".".format(__name__, ea, utils.string.escape(string, '"'), u", {:s}".format(utils.string.kwargs(flags)) if flags else '', utils.string.escape(utils.string.of(res), '"')))
            ida_string = res

        # fetch the old name and set the new one at the same time.
        res, ok = name(ea), idaapi.set_name(ea, ida_string or "", F)

        if not ok:
            raise E.DisassemblerError(u"{:s}.name({:#x}, \"{:s}\"{:s}) : Unable to call `idaapi.set_name({:#x}, \"{:s}\", {:#x})`.".format(__name__, ea, utils.string.escape(string, '"'), u", {:s}".format(utils.string.kwargs(flags)) if flags else '', ea, utils.string.escape(string, '"'), F))
        return res

    def name_within(ea, string, F):
        '''Add or rename the label at the address `ea` using the name in `string` with the flags in `F`.'''
        func, realname, localname = idaapi.get_func(ea), idaapi.get_visible_name(ea), idaapi.get_visible_name(ea, idaapi.GN_LOCAL)

        # if there's a public name at this address then use the
        # flags to determine how to update the public name.
        if idaapi.is_public_name(ea) or any(F & item for item in [idaapi.SN_PUBLIC, idaapi.SN_NON_PUBLIC]):
            F |= idaapi.SN_PUBLIC if F & idaapi.SN_PUBLIC else idaapi.SN_NON_PUBLIC

        # if we're pointing to the start of the function, then unless
        # public was explicitly ,specified we need to set the local name.
        elif interface.range.start(func) == ea and not builtins.all(F & item for item in [idaapi.SN_PUBLIC, idaapi.SN_NON_PUBLIC]):
            F |= idaapi.SN_LOCAL

        # if the name is supposed to be in the list, then we need to check if there's a
        # local name.
        elif not F & idaapi.SN_NOLIST:
            if localname and realname != localname:
                idaapi.del_local_name(ea), idaapi.set_name(ea, localname, idaapi.SN_NOLIST)
            F &= ~idaapi.SN_LOCAL

        # if a regular name is defined, but not a local one, then we need to set the local
        # one first.
        elif realname and realname == localname:
            F |= idaapi.SN_NOLIST

        # otherwise we're using a local name because we're inside a function.
        else:
            F |= idaapi.SN_LOCAL

        # now we can apply the name with the flags that we determined.
        return apply_name(ea, string, F)

    def name_outside(ea, string, F):
        '''Add or rename the global at the address `ea` using the name in `string` with the flags in `F`.'''
        realname, localname = idaapi.get_visible_name(ea), idaapi.get_visible_name(ea, idaapi.GN_LOCAL)

        # preserve the name if its public
        F |= idaapi.SN_PUBLIC if idaapi.is_public_name(ea) else idaapi.SN_NON_PUBLIC

        # if 'listed' wasn't explicitly specified then ensure it's
        # not listed as requested.
        if 'listed' not in flags:
            F |= idaapi.SN_NOLIST

        # then finally apply the name.
        return apply_name(ea, string, F)

    ## now we can define the actual logic for naming the given address
    flag = idaapi.SN_NON_AUTO
    flag |= idaapi.SN_NOCHECK

    # preserve any flags that were previously applied
    flag |= 0 if idaapi.is_in_nlist(ea) else idaapi.SN_NOLIST
    flag |= idaapi.SN_WEAK if idaapi.is_public_name(ea) and idaapi.is_weak_name(ea) else idaapi.SN_NON_WEAK

    # if the bool `listed` is True, then ensure that it's added to the name list.
    if 'listed' in flags:
        flag = (flag & ~idaapi.SN_NOLIST) if flags.get('listed', False) else (flag | idaapi.SN_NOLIST)

    # if custom flags were specified, then just use those as they should get
    # priority
    if 'flags' in flags:
        return apply_name(ea, string, flags['flags'])

    # if we're within a function, then use the name_within closure to apply the name
    elif function.within(ea):
        return name_within(ea, string, flag)

    # otherwise, we use the name_without closure to apply it
    return name_outside(ea, string, flag)
@utils.multicase(ea=six.integer_types, none=None.__class__)
def name(ea, none, **flags):
    '''Removes the name defined at the address `ea`.'''
    return name(ea, none or '', **flags)

@utils.multicase()
def mangled():
    '''Return the mangled name at the current address.'''
    return mangled(ui.current.address())
@utils.multicase(ea=six.integer_types)
def mangled(ea):
    '''Return the mangled name at the address specified by `ea`.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE if type.is_code(ea) else MANGLED_DATA, MANGLED_UNKNOWN))

    result = name(ea)
    mangled_name_type_t = Fmangled_type(utils.string.to(result))
    if mangled_name_type_t == MANGLED_UNKNOWN:
        logging.warning(u"{:s}.mangled({:#x}) : The name at the given address ({:#x}) was not mangled ({:d}) and will be the same as returning the {:s} name.".format(__name__, ea, ea, mangled_name_type_t, 'regular'))
    return result
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string','suffix')
def mangled(string, *suffix):
    '''Rename the current address to the mangled version of `string` and return its previous mangled value.'''
    return mangled(ui.current.address(), string, *suffix)
@utils.multicase(none=None.__class__)
def mangled(none):
    '''Remove the mangled name at the current address and return its previous mangled value.'''
    return mangled(ui.current.address(), none)
@utils.multicase(ea=six.integer_types, string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def mangled(ea, string, *suffix):
    '''Rename the address specified by `ea` to the mangled version of `string` and return its previous mangled value.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE if type.is_code(ea) else MANGLED_DATA, MANGLED_UNKNOWN))

    mangled_name_type_t = Fmangled_type(utils.string.to(string))
    if mangled_name_type_t == MANGLED_UNKNOWN:
        raise NotImplementedError(u"{:s}.mangled({:#x}, {:s}) : Unable to mangle the specified name (\"{:s}\") before applying it to the address ({:#x}).".format(__name__, ea, ', '.join(map("{!r}".format, itertools.chain([string], suffix))), utils.string.escape(string, '"'), ea))
    if suffix:
        raise NotImplementedError(u"{:s}.mangled({:#x}, {:s}) : Unable to attach the suffix (\"{:s}\") to the unmangled name (\"{:s}\") before applying it to the address ({:#x}).".format(__name__, ea, ', '.join(map("{!r}".format, itertools.chain([string], suffix))), interface.tuplename(*suffix), internal.declaration.demangle(string), ea))
    # FIXME: mangle the string that we were given according to the schema for
    #        the default compiler type with the suffix appended to its name.
    logging.warning(u"{:s}.mangled({:#x}, {:s}) : The specified name (\"{:s}\") is already mangled ({:d}) and will be assigned to the given address ({:#x}) as \"{:s}\".".format(__name__, ea, ', '.join(map("{!r}".format, itertools.chain([string], suffix))), utils.string.escape(string, '"'), mangled_name_type_t, ea, internal.declaration.demangle(string)))
    return name(ea, string, *suffix)
@utils.multicase(ea=six.integer_types, none=None.__class__)
def mangled(ea, none):
    '''Remove the name at the address specified by `ea` and return its previous mangled value.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE if type.is_code(ea) else MANGLED_DATA, MANGLED_UNKNOWN))
    GN_DEMANGLED = getattr(idaapi, 'GN_DEMANGLED', 0)

    flags = functools.reduce(operator.or_, [GN_DEMANGLED, idaapi.GN_SHORT])
    string, _ = name(ea), name(ea, none, flags=flags)
    mangled_name_type_t = Fmangled_type(utils.string.to(string))
    if mangled_name_type_t == MANGLED_UNKNOWN:
        logging.warning(u"{:s}.mangled({:#x}, {!s}) : The name at the given address ({:#x}) was not mangled ({:d}) and will be the same as returning the {:s} name.".format(__name__, ea, none, ea, mangled_name_type_t, 'regular'))
    return string
mangle = utils.alias(mangled)

@utils.multicase()
def unmangled():
    '''Return the name at the current address in its unmangled form.'''
    return unmangled(ui.current.address())
@utils.multicase(ea=six.integer_types)
def unmangled(ea):
    '''Return the name at the address specified by `ea` in its unmangled form.'''
    GN_DEMANGLED = getattr(idaapi, 'GN_DEMANGLED', 0)

    flags = functools.reduce(operator.or_, [GN_DEMANGLED, idaapi.GN_SHORT])
    result = name(ea, flags=flags)
    return result if hasattr(idaapi, 'GN_DEMANGLED') else internal.declaration.demangle(result)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string','suffix')
def unmangled(string, *suffix):
    '''Rename the current address using the mangled version of `string` and return its previous unmangled value.'''
    return unmangled(ui.current.address(), string, *suffix)
@utils.multicase(none=None.__class__)
def unmangled(none):
    '''Remove the name at the current address and return its previous unmangled value.'''
    return unmangled(ui.current.address(), none)
@utils.multicase(ea=six.integer_types, string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def unmangled(ea, string, *suffix):
    '''Rename the address specified by `ea` using the mangled version of `string` and return its previous unmangled value.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE if type.is_code(ea) else MANGLED_DATA, MANGLED_UNKNOWN))
    GN_DEMANGLED = getattr(idaapi, 'GN_DEMANGLED', 0)

    mangled_name_type_t = Fmangled_type(utils.string.to(string))
    if mangled_name_type_t != MANGLED_UNKNOWN:
        logging.warning(u"{:s}.unmangled({:#x}, {:s}) : The specified name (\"{:s}\") is already mangled ({:d}) and will be assigned to the given address ({:#x}) as \"{:s}\".".format(__name__, ea, ', '.join(map("{!r}".format, itertools.chain([string], suffix))), utils.string.escape(string, '"'), mangled_name_type_t, ea, internal.declaration.demangle(string)))
    if suffix:
        raise NotImplementedError(u"{:s}.unmangled({:#x}, {:s}) : Unable to attach the suffix (\"{:s}\") to the unmangled name (\"{:s}\") before applying it to the address ({:#x}).".format(__name__, ea, ', '.join(map("{!r}".format, itertools.chain([string], suffix))), interface.tuplename(*suffix), internal.declaration.demangle(string), ea))
    # FIXME: correct the string, doing whatever it takes to keep it the same
    #        when it gets mangled(?) and append the given suffix to its name.
    flags = functools.reduce(operator.or_, [GN_DEMANGLED, idaapi.GN_SHORT])
    result = name(ea, string, *suffix, flags=flags)
    return result if hasattr(idaapi, 'GN_DEMANGLED') else internal.declaration.demangle(result)
@utils.multicase(ea=six.integer_types, none=None.__class__)
def unmangled(ea, none):
    '''Remove the name at the address specified by `ea` and return its previous unmangled value.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE if type.is_code(ea) else MANGLED_DATA, MANGLED_UNKNOWN))
    GN_DEMANGLED = getattr(idaapi, 'GN_DEMANGLED', 0)

    flags = functools.reduce(operator.or_, [GN_DEMANGLED, idaapi.GN_SHORT])
    string, result = name(ea), name(ea, none, flags=flags)
    mangled_name_type_t = Fmangled_type(utils.string.to(string))
    if mangled_name_type_t == MANGLED_UNKNOWN:
        logging.warning(u"{:s}.unmangled({:#x}, {!s}) : The name at the given address ({:#x}) was not mangled ({:d}) and will be the same as returning the {:s} name.".format(__name__, ea, none, ea, mangled_name_type_t, 'regular'))
    return result if hasattr(idaapi, 'GN_DEMANGLED') else internal.declaration.demangle(result)
unmangle = demangle = demangled = utils.alias(unmangled)

@utils.multicase()
def color():
    '''Return the color (RGB) for the item at the current address.'''
    return color(ui.current.address())
@utils.multicase(none=None.__class__)
def color(none):
    '''Remove the color from the item at the current address.'''
    return color(ui.current.address(), None)
@utils.multicase(ea=six.integer_types)
def color(ea):
    '''Return the color (RGB) for the item at the address specified by `ea`.'''
    DEFCOLOR = 0xffffffff
    res = idaapi.get_item_color(interface.address.inside(ea))
    b, r = (res&0xff0000)>>16, res&0x0000ff
    return None if res == DEFCOLOR else (r<<16)|(res&0x00ff00)|b
@utils.multicase(ea=six.integer_types, none=None.__class__)
def color(ea, none):
    '''Remove the color from the item at the the address specified by `ea`.'''
    DEFCOLOR = 0xffffffff
    res, void = color(ea), idaapi.set_item_color(interface.address.inside(ea), DEFCOLOR)
    return res
@utils.multicase(ea=six.integer_types, rgb=six.integer_types)
def color(ea, rgb):
    '''Set the color for the item at address `ea` to `rgb`.'''
    r, b = (rgb&0xff0000) >> 16, rgb&0x0000ff
    res, void = color(ea), idaapi.set_item_color(interface.address.inside(ea), (b<<16)|(rgb&0x00ff00)|r)
    return res

@utils.multicase()
def comment(**repeatable):
    '''Return the comment at the current address.'''
    return comment(ui.current.address(), **repeatable)
@utils.multicase(ea=six.integer_types)
def comment(ea, **repeatable):
    """Return the comment at the address `ea`.

    If the bool `repeatable` is specified, then return the repeatable comment.
    """
    res = idaapi.get_cmt(interface.address.inside(ea), repeatable.get('repeatable', False))

    # return the string in a format the user can process
    return utils.string.of(res)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string')
def comment(string, **repeatable):
    '''Set the comment at the current address to `string`.'''
    return comment(ui.current.address(), string, **repeatable)
@utils.multicase(none=None.__class__)
def comment(none, **repeatable):
    '''Remove the comment at the current address.'''
    return comment(ui.current.address(), none or '', **repeatable)
@utils.multicase(ea=six.integer_types, string=six.string_types)
@utils.string.decorate_arguments('string')
def comment(ea, string, **repeatable):
    """Set the comment at the address `ea` to `string`.

    If the bool `repeatable` is specified, then modify the repeatable comment.
    """
    # apply the comment to the specified address
    res, ok = comment(ea, **repeatable), idaapi.set_cmt(interface.address.inside(ea), utils.string.to(string), repeatable.get('repeatable', False))
    if not ok:
        raise E.DisassemblerError(u"{:s}.comment({:#x}, {!r}{:s}) : Unable to call `idaapi.set_cmt({:#x}, \"{:s}\", {!s})`.".format(__name__, ea, string, u", {:s}".format(utils.string.kwargs(repeatable)) if repeatable else '', ea, utils.string.escape(string, '"'), repeatable.get('repeatable', False)))
    return res
@utils.multicase(ea=six.integer_types, none=None.__class__)
def comment(ea, none, **repeatable):
    """Remove the comment at the address `ea`.

    If the bool `repeatable` is specified, then remove the repeatable comment.
    """
    return comment(ea, none or '', **repeatable)

class entries(object):
    """
    This namespace can be used to enumerate all of the entry points and
    exports that are defined within the database By default the address
    of each entrypoint will be yielded.

    This namespace is also aliased as ``database.exports``.

    When listing entry points that are matched, the following legend can be
    used to identify certain characteristics about them:

        `F` - The entry point is referencing a function
        `C` - The entry point is referencing code
        `A` - The entry point is referencing data (address)
        `D` - The entry point is referencing a decompiled function
        `T` - The address of the entry point has a type applied to it
        `t` - The address of the entry point has a guessable type
        `C` - The address of the entry point is marked as code
        `D` - The address of the entry point is marked as data
        `^` - The address of the entry point is marked as unknown
        `+` - The entry point has an implicit tag applied to it (named or typed)
        `*` - The entry point has an explicit tag applied to it

    The different types that one can match entrypoints with are the following:

        `address` or `ea` - Match according to the entrypoint's address
        `name` - Match according to the exact name
        `like` - Filter the entrypoint names according to a glob
        `regex` - Filter the entrypoint names according to a regular-expression
        `index` - Match according to the entrypoint's index
        `ordinal` - Match according to the entrypoint's ordinal
        `greater` or `ge` - Filter the entrypoints for any after the specified address (inclusive)
        `gt` - Filter the entrypoints for any after the specified address (exclusive)
        `less` or `le` - Filter the entrypoints for any before the specified address (inclusive)
        `lt` - Filter the entrypoints for any before the specified address (exclusive)
        `function` - Filter the entrypoints for any that are referencing a function
        `typed` - Filter the entrypoints for any that have type information applied to them
        `tagged` - Filter the entrypoints for any that use the specified tag(s)
        `predicate` - Filter the entrypoints by passing its index (ordinal) to a callable

    Some examples of using these keywords are as follows::

        > database.entries.list(greater=h())
        > iterable = database.entries.iterate(like='Nt*')
        > result = database.entries.search(index=0)

    """

    __matcher__ = utils.matcher()
    __matcher__.boolean('address', operator.eq, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('ea', operator.eq, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('greater', operator.le, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('ge', operator.le, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('gt', operator.lt, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('less', operator.ge, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('le', operator.ge, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('lt', operator.gt, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), idaapi.get_entry_ordinal, utils.fmap(idaapi.get_entry_name, utils.fcompose(idaapi.get_entry, utils.fcondition(function.within)(function.name, unmangled))), utils.fpartial(filter, None), utils.itake(1), operator.itemgetter(0), utils.fdefault(''), utils.string.of)
    __matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_entry_ordinal, utils.fmap(idaapi.get_entry_name, utils.fcompose(idaapi.get_entry, utils.fcondition(function.within)(function.name, unmangled))), utils.fpartial(filter, None), utils.itake(1), operator.itemgetter(0), utils.fdefault(''), utils.string.of)
    __matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_entry_ordinal, utils.fmap(idaapi.get_entry_name, utils.fcompose(idaapi.get_entry, utils.fcondition(function.within)(function.name, unmangled))), utils.fpartial(filter, None), utils.itake(1), operator.itemgetter(0), utils.fdefault(''), utils.string.of)
    __matcher__.mapping('function', function.within, idaapi.get_entry_ordinal, idaapi.get_entry)
    __matcher__.mapping('typed', operator.truth, idaapi.get_entry_ordinal, idaapi.get_entry, lambda ea: idaapi.get_tinfo2(ea, idaapi.tinfo_t()) if idaapi.__version__ < 7.0 else idaapi.get_tinfo(idaapi.tinfo_t(), ea))
    __matcher__.boolean('tagged', lambda parameter, keys: operator.truth(keys) == parameter if isinstance(parameter, bool) else operator.contains(keys, parameter) if isinstance(parameter, six.string_types) else keys & builtins.set(parameter), idaapi.get_entry_ordinal, idaapi.get_entry, lambda ea: function.tag(ea) if function.within(ea) else tag(ea), operator.methodcaller('keys'), builtins.set)
    __matcher__.predicate('predicate', idaapi.get_entry_ordinal),
    __matcher__.predicate('pred', idaapi.get_entry_ordinal)
    __matcher__.boolean('ordinal', operator.eq, idaapi.get_entry_ordinal)
    __matcher__.boolean('index', operator.eq)

    def __new__(cls):
        '''Yield the address of each entry point defined within the database.'''
        for ea in cls.iterate():
            yield ea
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def __iterate__(cls, string):
        return cls.__iterate__(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def __iterate__(cls, **type):
        listable = builtins.range(idaapi.get_entry_qty())
        for key, value in (type or {'predicate': utils.fconstant(True)}).items():
            listable = [item for item in cls.__matcher__.match(key, value, listable)]
        for item in listable: yield item

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def iterate(cls, string):
        '''Iterate through all of the entry points in the database with a glob that matches `string`.'''
        return cls.iterate(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def iterate(cls, **type):
        '''Iterate through all of the entry points in the database that match the keyword specified by `type`.'''
        for ea in cls.__iterate__(**type):
            yield cls.__address__(ea)
        return

    @classmethod
    def __index__(cls, ea):
        '''Return the index of the entry point at the specified `address`.'''
        f = utils.fcompose(idaapi.get_entry_ordinal, idaapi.get_entry)

        # Iterate through each entry point, and yield a tuple containing its address and index.
        Ftransform = utils.fcompose(utils.fmap(f, lambda item: item), builtins.tuple)
        iterable = (Ftransform(item) for item in builtins.range(idaapi.get_entry_qty()))

        # Iterate through each (address, index) looking for the matching address.
        Fcrit = utils.fcompose(operator.itemgetter(0), functools.partial(operator.eq, ea))
        filterable = (item for item in iterable if Fcrit(item))

        # Return the index of the address that matched.
        iterable = (index for _, index in filterable)
        return builtins.next(iterable, None)

    @classmethod
    def __address__(cls, index):
        '''Return the address of the entry point at the specified `index`.'''
        res = cls.__entryordinal__(index)
        res = idaapi.get_entry(res)
        return None if res == idaapi.BADADDR else res

    # Return the name of the entry point at the specified `index`.
    __entryname__ = staticmethod(utils.fcompose(idaapi.get_entry_ordinal, utils.fmap(idaapi.get_entry_name, utils.fcompose(idaapi.get_entry, utils.fcondition(function.within)(function.name, unmangled))), utils.fpartial(filter, None), utils.itake(1), operator.itemgetter(0), utils.fdefault(''), utils.string.of))
    # Return the ordinal of the entry point at the specified `index`.
    __entryordinal__ = staticmethod(idaapi.get_entry_ordinal)

    @utils.multicase()
    @classmethod
    def ordinal(cls):
        '''Return the ordinal of the entry point at the current address.'''
        return cls.ordinal(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def ordinal(cls, ea):
        '''Return the ordinal of the entry point at the address `ea`.'''
        res = cls.__index__(ea)
        if res is not None:
            return cls.__entryordinal__(res)
        raise E.MissingTypeOrAttribute(u"{:s}.ordinal({:#x}) : No entry point at specified address.".format('.'.join([__name__, cls.__name__]), ea))

    @utils.multicase()
    @classmethod
    def name(cls):
        '''Return the name of the entry point at the current address.'''
        return cls.name(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def name(cls, ea):
        '''Return the name of the entry point at the address `ea`.'''
        res = cls.__index__(ea)
        if res is not None:
            return cls.__entryname__(res)
        raise E.MissingTypeOrAttribute(u"{:s}.name({:#x}) : No entry point at specified address.".format('.'.join([__name__, cls.__name__]), ea))

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def list(cls, string):
        '''List all of the entry points matching the glob `string` against the name.'''
        return cls.list(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def list(cls, **type):
        '''List all of the entry points in the database that match the keyword specified by `type`.'''
        MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
        Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_CODE, MANGLED_UNKNOWN))
        MNG_NODEFINIT, MNG_NOPTRTYP, MNG_LONG_FORM = getattr(idaapi, 'MNG_NODEFINIT', 8), getattr(idaapi, 'MNG_NOPTRTYP', 7), getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)
        MNG_NOSCTYP, MNG_NOCALLC = getattr(idaapi, 'MNG_NOSCTYP', 0x400), getattr(idaapi, 'MNG_NOCALLC', 0x100)

        # Set some reasonable defaults
        maxindex = maxaddr = maxordinal = 0

        # First pass through our listable grabbing the maximum lengths of our fields
        listable = []
        for index in cls.__iterate__(**type):
            maxindex = max(index, maxindex)

            res = idaapi.get_entry_ordinal(index)
            maxaddr = max(idaapi.get_entry(res), maxaddr)
            maxordinal = max(res, maxordinal)

            listable.append(index)

        # Collect the maximum sizes for everything from the first pass
        cindex, cordinal = (utils.string.digits(maxindex, 10) for item in [maxindex, maxordinal])
        caddr = utils.string.digits(maxaddr, 16)

        # List all the fields from everything that matched
        get_tinfo = (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo
        for index in listable:
            ordinal = cls.__entryordinal__(index)
            ea = idaapi.get_entry(ordinal)
            tags = function.tag(ea) if function.within(ea) else tag(ea)
            realname = cls.__entryname__(index) or name(ea)

            # Some flags that could be useful.
            fclass = 'A' if t.is_data(ea) or t.is_unknown(ea) else 'D' if function.within(ea) and function.type.is_decompiled(ea) else 'F' if function.within(ea) else 'C' if t.is_code(ea) else '-'
            finitialized = '-' if not t.is_initialized(ea) else 'C' if t.is_code(ea) else 'D' if t.is_data(ea) else '^'
            ftyped = 'T' if get_tinfo(idaapi.tinfo_t(), ea) else 't' if t.has_typeinfo(ea) else '-'
            tags.pop('__name__', None)
            ftagged = '-' if not tags else '*' if any(not item.startswith('__') for item in tags) else '+'
            flags = itertools.chain(fclass, finitialized, ftyped, ftagged)

            # If we're within a function, then display the type information if available
            # while being aware of name mangling. If there's no type information, then
            # use the unmangled name for displaying the export.
            if function.within(ea):
                ti, mangled_name_type_t = idaapi.tinfo_t(), Fmangled_type(utils.string.to(realname))
                dname = realname if mangled_name_type_t == MANGLED_UNKNOWN else utils.string.of(idaapi.demangle_name(utils.string.to(realname), MNG_NODEFINIT|MNG_NOPTRTYP) or realname)
                demangled = utils.string.of(idaapi.demangle_name(utils.string.to(realname), MNG_LONG_FORM|MNG_NOSCTYP|MNG_NOCALLC)) or realname
                description = idaapi.print_tinfo('', 0, 0, idaapi.PRTYPE_DEF, ti, utils.string.to(dname), '') if get_tinfo(ti, ea) else demangled

            # Otherwise, we always try to display the type regardless of what's available.
            else:
                description = tags.get('__typeinfo__', realname)
            six.print_(u"{:<{:d}s} {:s} {:<#{:d}x} : {:s} : {:s}".format("[{:d}]".format(index), 2 + math.trunc(cindex), "{:>{:d}s}".format('' if ea == ordinal else "(#{:d})".format(ordinal), 2 + 1 + math.trunc(cindex)), ea, 2 + math.trunc(caddr), ''.join(flags), description))
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def search(cls, string):
        '''Search through all of the entry point names matching the glob `string` and return the first result.'''
        return cls.search(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'regex')
    def search(cls, **type):
        '''Search through all of the entry points within the database and return the first result matching the keyword specified by `type`.'''
        query_s = utils.string.kwargs(type)

        listable = [item for item in cls.__iterate__(**type)]
        if len(listable) > 1:
            messages = ((u"[{:d}] ({:s}) {:#x} : {:s} {:s}".format(idx, '' if ordinal == ea else "#{:d}".format(ordinal), ea, '[FUNC]' if function.within(ea) else '[ADDR]', name or unmangled(ea))) for idx, ordinal, name, ea in map(utils.fmap(utils.fidentity, cls.__entryordinal__, cls.__entryname__, cls.__address__), listable))
            [ logging.info(msg) for msg in messages ]
            f = utils.fcompose(idaapi.get_entry_ordinal, idaapi.get_entry)
            logging.warning(u"{:s}.search({:s}) : Found {:d} matching results, Returning the first entry point at {:#x}.".format('.'.join([__name__, cls.__name__]), query_s, len(listable), f(listable[0])))

        iterable = (item for item in listable)
        res = builtins.next(iterable, None)
        if res is None:
            raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format('.'.join([__name__, cls.__name__]), query_s))
        return cls.__address__(res)

    @utils.multicase()
    @classmethod
    def new(cls):
        '''Makes an entry point at the current address.'''
        ea, entryname, ordinal = ui.current.address(), name(ui.current.address()) or function.name(ui.current.address()), idaapi.get_entry_qty()
        if entryname is None:
            raise E.MissingTypeOrAttribute(u"{:s}.new({:#x}) : Unable to determine name at address.".format( '.'.join([__name__, cls.__name__]), ea))
        return cls.new(ea, entryname, ordinal)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def new(cls, ea):
        '''Makes an entry point at the specified address `ea`.'''
        entryname, ordinal = name(ea) or function.name(ea), idaapi.get_entry_qty()
        if entryname is None:
            raise E.MissingTypeOrAttribute(u"{:s}.new({:#x}) : Unable to determine name at address.".format( '.'.join([__name__, cls.__name__]), ea))
        return cls.new(ea, entryname, ordinal)
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def new(cls, name):
        '''Adds the current address as an entry point using `name` and the next available index as the ordinal.'''
        return cls.new(ui.current.address(), name, idaapi.get_entry_qty())
    @utils.multicase(ea=six.integer_types, name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def new(cls, ea, name):
        '''Makes the specified address `ea` an entry point having the specified `name`.'''
        ordinal = idaapi.get_entry_qty()
        return cls.new(ea, name, ordinal)
    @utils.multicase(name=six.string_types, ordinal=six.integer_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def new(cls, name, ordinal):
        '''Adds an entry point with the specified `name` to the database using `ordinal` as its index.'''
        return cls.new(ui.current.address(), name, ordinal)
    @utils.multicase(ea=six.integer_types, name=six.string_types, ordinal=six.integer_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def new(cls, ea, name, ordinal):
        '''Adds an entry point at `ea` with the specified `name` and `ordinal`.'''
        res = idaapi.add_entry(ordinal, interface.address.inside(ea), utils.string.to(name), 0)
        ui.state.wait()
        return res

    add = utils.alias(new, 'entries')
exports = entries     # XXX: ns alias

def tags():
    '''Return all of the tag names used globally within the database.'''
    return internal.comment.globals.name()

@utils.multicase()
def tag():
    '''Return all of the tags defined at the current address.'''
    return tag(ui.current.address())
@utils.multicase(ea=six.integer_types)
def tag(ea):
    '''Return all of the tags defined at address `ea`.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(0, MANGLED_UNKNOWN))
    MNG_NODEFINIT, MNG_NOPTRTYP = getattr(idaapi, 'MNG_NODEFINIT', 8), getattr(idaapi, 'MNG_NOPTRTYP', 7)

    ea = interface.address.inside(ea)

    # Check if we're within a function and determine whether it's a
    # runtime-linked address or not. If we're within a function, then
    # we need to ensure that we're using non-repeatable comments.
    try:
        func = function.by_address(ea)
        rt, _ = interface.addressOfRuntimeOrStatic(func)

    # If the address is not within a function, then assign some variables
    # so that we will use a repeatable comment.
    except E.FunctionNotFoundError:
        rt, func = False, None
    repeatable = False if func and function.within(ea) and not rt else True

    # Read both repeatable and non-repeatable comments from the chosen
    # address so that we can decode both of them into dictionaries to
    # use. We also decode the (repeatable) function comment, because in
    # some cases a function is created for a runtime-linked address.
    res = comment(ea, repeatable=False)
    d1 = internal.comment.decode(res)
    res = comment(ea, repeatable=True)
    d2 = internal.comment.decode(res)
    res = function.comment(ea, repeatable=True) if rt else ''
    d3 = internal.comment.decode(res)

    # Check if the address had content in either decoding types of
    # comments so that we can warn the user about it.
    if six.viewkeys(d1) & six.viewkeys(d2):
        logging.info(u"{:s}.tag({:#x}) : Contents of both the repeatable and non-repeatable comment conflict with one another due to using the same keys ({:s}). Giving the {:s} comment priority.".format(__name__, ea, ', '.join(six.viewkeys(d1) & six.viewkeys(d2)), 'repeatable' if repeatable else 'non-repeatable'))
    if rt and (six.viewkeys(d3) & six.viewkeys(d1) or six.viewkeys(d3) & six.viewkeys(d2)):
        logging.info(u"{:s}.tag({:#x}) : Contents of the runtime-linked comment conflict with one of the database comments due to using the same keys ({:s}). Giving the {:s} comment priority.".format(__name__, ea, ', '.join(six.viewkeys(d3) & six.viewkeys(d2) or six.viewkeys(d3) & six.viewkeys(d1)), 'function'))

    # Merge all of the decoded tags into a dictionary while giving priority
    # to the correct one. If the address was pointing to a runtime-linked
    # address and was a case that had a function comment, then we need to
    # give those tags absolute priority when building our dictionary.
    res = {}
    [res.update(d) for d in ([d1, d2] if repeatable else [d2, d1])]
    rt and res.update(d3)

    # First thing we need to figure out is whether the name exists and if
    # it's actually special in that we need to demangle it for the real name.
    aname = name(ea)
    if aname and Fmangled_type(utils.string.to(aname)) != MANGLED_UNKNOWN:
        realname = utils.string.of(idaapi.demangle_name(utils.string.to(aname), MNG_NODEFINIT|MNG_NOPTRTYP) or aname)
    else:
        realname = aname or ''

    # Add any of the implicit tags for the specified address to our results.
    if aname and type.flags(ea, idaapi.FF_NAME): res.setdefault('__name__', realname)
    eprefix = extra.__get_prefix__(ea)
    if eprefix is not None: res.setdefault('__extra_prefix__', eprefix)
    esuffix = extra.__get_suffix__(ea)
    if esuffix is not None: res.setdefault('__extra_suffix__', esuffix)
    col = color(ea)
    if col is not None: res.setdefault('__color__', col)

    # If there was some type information associated with the address, then
    # we need its name so that we can format it and add it as an implicit tag.
    try:
        if type.has_typeinfo(ea):
            ti = type(ea)

            # Filter the name we're going to render with so that it can be parsed properly.
            valid = {item for item in string.digits} | {':'}
            filtered = str().join(item if item in valid or idaapi.is_valid_typename(utils.string.to(item)) else '_' for item in realname)
            validname = ''.join(filtered)

            # Demangle just the name if it's mangled in some way, and use it to render
            # the typeinfo to return.
            ti_s = idaapi.print_tinfo('', 0, 0, 0, ti, utils.string.to(validname), '')

            # Add it to our dictionary that we return to the user.
            res.setdefault('__typeinfo__', ti_s)

    # If we caught an exception, then the name from the type information could be
    # mangled and so we need to rip the type information directly out of the name.
    except E.InvalidTypeOrValueError:
        demangled = internal.declaration.demangle(aname)

        # if the demangled name is different from the actual name, then we need
        # to extract its result type and prepend it to the demangled name.
        if demangled != aname:
            res.setdefault('__typeinfo__', demangled)

    # Finally we can return what the user cares about.
    return res
@utils.multicase(key=six.string_types)
@utils.string.decorate_arguments('key')
def tag(key):
    '''Return the tag identified by `key` at the current address.'''
    return tag(ui.current.address(), key)
@utils.multicase(key=six.string_types)
@utils.string.decorate_arguments('key', 'value')
def tag(key, value):
    '''Set the tag identified by `key` to `value` at the current address.'''
    return tag(ui.current.address(), key, value)
@utils.multicase(ea=six.integer_types, key=six.string_types)
@utils.string.decorate_arguments('key')
def tag(ea, key):
    '''Return the tag identified by `key` from the address `ea`.'''
    res = tag(ea)
    if key in res:
        return res[key]
    raise E.MissingTagError(u"{:s}.tag({:#x}, {!r}) : Unable to read tag (\"{:s}\") from address.".format(__name__, ea, key, utils.string.escape(key, '"')))
@utils.multicase(ea=six.integer_types, key=six.string_types)
@utils.string.decorate_arguments('key', 'value')
def tag(ea, key, value):
    '''Set the tag identified by `key` to `value` at the address `ea`.'''
    if value is None:
        raise E.InvalidParameterError(u"{:s}.tag({:#x}, {!r}, {!r}) : Tried to set the tag (\"{:s}\") to an unsupported type {!r}.".format(__name__, ea, key, value, utils.string.escape(key, '"'), value))

    # If any of the supported implicit tags were specified, then figure out which
    # one and using it to dispatch to the correct handler.
    if key == '__name__':
        return name(ea, value, listed=True)
    elif key == '__extra_prefix__':
        return extra.__set_prefix__(ea, value)
    elif key == '__extra_suffix__':
        return extra.__set_suffix__(ea, value)
    elif key == '__color__':
        return color(ea, value)
    elif key == '__typeinfo__':
        return type(ea, value)

    # If we're within a function, then we also need to determine whether it's a
    # runtime-linked address or not. This is because if it's a runtime-linked
    # address then a repeatable comment is used. Otherwise we encode the tags
    # within a non-repeatable comment.
    try:
        func = function.by_address(ea)
        rt, _ = interface.addressOfRuntimeOrStatic(func)

    # If the address was not within a function, then set the necessary variables
    # so that a repeatable comment is used.
    except E.FunctionNotFoundError:
        rt, func = False, None

    # If we're outside a function or pointing to a runtime-linked address, then
    # we use a repeatable comment. Anything else means a non-repeatable comment.
    repeatable = False if func and function.within(ea) and not rt else True

    # Go ahead and decode the tags that are written to all 3 comment types. This
    # way we can search them for the correct one that the user is trying to modify.
    ea = interface.address.inside(ea)
    state_correct = internal.comment.decode(comment(ea, repeatable=repeatable))
    state_wrong = internal.comment.decode(comment(ea, repeatable=not repeatable))
    state_runtime = internal.comment.decode(function.comment(ea, repeatable=True)) if func else {}

    # Now we just need to figure out which one of the dictionaries that we decoded
    # contains the key that the user is trying to modify. We need to specially
    # handle the case where the address is actually referring to a runtime address.
    if rt:
        rt, state, where = (True, state_runtime, True) if key in state_runtime else (False, state_wrong, False) if key in state_wrong else (True, state_runtime, True)
    else:
        state, where = (state_correct, repeatable) if key in state_correct else (state_wrong, not repeatable) if key in state_wrong else (state_correct, repeatable)

    # If the key was not in any of the encoded dictionaries, then we need to
    # update the reference count in the tag cache. If the address is a runtime
    # address or outside a function, then it's a global tag. Otherwise if it's
    # within a function, then it's a contents tag that we need to adjust.
    if key not in state:
        if func and function.within(ea) and not rt:
            internal.comment.contents.inc(ea, key)
        else:
            internal.comment.globals.inc(ea, key)

    # Grab the previous value from the correct dictionary that we discovered,
    # and update it with the new value that the user is modifying it with.
    res, state[key] = state.get(key, None), value

    # Now we can finally update the comment in the database. However, we need
    # to guard the modification so that the hooks don't interfere with the
    # references that we updated. We guard this situation by disabling the hooks.
    hooks = {'changing_cmt', 'cmt_changed', 'changing_range_cmt', 'range_cmt_changed', 'changing_area_cmt', 'area_cmt_changed'} & {target for target in ui.hook.idb}
    try:
        [ ui.hook.idb.disable(item) for item in hooks ]

    # If an exception was raised while disabling the hooks, then we need to bail.
    except Exception:
        raise

    # Finally we can actually encode the dictionary and write it to the address
    # the user specified using the correct comment type.
    else:
        function.comment(ea, internal.comment.encode(state), repeatable=where) if rt else comment(ea, internal.comment.encode(state), repeatable=where)

    # Lastly we release the hooks now that we've finished modifying the comment.
    finally:
        [ ui.hook.idb.enable(item) for item in hooks ]

    # Now we can return the result the user asked us for.
    return res
@utils.multicase(key=six.string_types, none=None.__class__)
def tag(key, none):
    '''Remove the tag identified by `key` from the current address.'''
    return tag(ui.current.address(), key, none)
@utils.multicase(ea=six.integer_types, key=six.string_types, none=None.__class__)
@utils.string.decorate_arguments('key')
def tag(ea, key, none):
    '''Removes the tag identified by `key` at the address `ea`.'''
    ea = interface.address.inside(ea)

    # If any of the supported implicit tags were specified, then dispatch to
    # the correct function in order to properly clear it.
    if key == '__name__':
        return name(ea, None, listed=True)
    elif key == '__extra_prefix__':
        return extra.__delete_prefix__(ea)
    elif key == '__extra_suffix__':
        return extra.__delete_suffix__(ea)
    elif key == '__typeinfo__':
        return type(ea, None)
    elif key == '__color__':
        return color(ea, None)

    # If we're within a function, then we need to distinguish whether the
    # address is a runtime-linked one or not. This way we can determine the
    # actual comment type that will be used.
    try:
        func = function.by_address(ea)
        rt, _ = interface.addressOfRuntimeOrStatic(func)

    # If the address wasn't within a function, then assign the necessary
    # values to the variables so that a repeatable comment gets used.
    except E.FunctionNotFoundError:
        rt, func = False, None

    # If we're outside a function or pointing to a runtime-linked address, then
    # a repeatable comment gets used. Inside a function is always a non-repeatable.
    repeatable = False if func and function.within(ea) and not rt else True

    # figure out which comment type the user's key is in so that we can remove
    # that one. if we're a runtime-linked address, then we need to remove the
    # tag from a repeatable function comment. if the tag isn't in any of them,
    # then it doesn't really matter since we're going to raise an exception anyways.

    # Now we decode the tags from are written to all 3 available comment types.
    # This way we can search for the correct one that the user is going to modify.
    state_correct = internal.comment.decode(comment(ea, repeatable=repeatable))
    state_wrong = internal.comment.decode(comment(ea, repeatable=not repeatable))
    state_runtime = internal.comment.decode(function.comment(ea, repeatable=True)) if func else {}

    # Then we need to figure out which one of the decoded dictionaries contains
    # the key that the user is trying to remove. The case where a runtime-linked
    # address is being referenced needs to be specially handled as IDA may
    # incorrectly declare some runtime-linked addresses as functions.
    if rt:
        rt, state, where = (True, state_runtime, True) if key in state_runtime else (False, state_wrong, False) if key in state_wrong else (True, state_runtime, True)
    else:
        state, where = (state_correct, repeatable) if key in state_correct else (state_wrong, not repeatable) if key in state_wrong else (state_correct, repeatable)

    # If the key is not in the expected dictionary, then raise an exception. If
    # it is, then we can modify the dictionary and remove it to return to the user.
    if key not in state:
        raise E.MissingTagError(u"{:s}.tag({:#x}, {!r}, {!s}) : Unable to remove non-existent tag \"{:s}\" from address.".format(__name__, ea, key, none, utils.string.escape(key, '"')))
    res = state.pop(key)

    # Now we can do our update and encode our modified dictionary, but we need
    # to guard the modification so that the hooks don't also interfere with the
    # references that we're updating. We guard by disabling the relevant hooks.
    hooks = {'changing_cmt', 'cmt_changed', 'changing_range_cmt', 'range_cmt_changed', 'changing_area_cmt', 'area_cmt_changed'} & {target for target in ui.hook.idb}
    try:
        [ ui.hook.idb.disable(item) for item in hooks ]

    # If an exception was raised while disabling the hooks, then simply bail.
    except Exception:
        raise

    # Finally we can encode the dictionary that we removed the key from and
    # write it to the correct comment at the address that the user specified.
    else:
        function.comment(ea, internal.comment.encode(state), repeatable=where) if rt else comment(ea, internal.comment.encode(state), repeatable=where)

    # Release our hooks once we've finished updating the comment.
    finally:
        [ ui.hook.idb.enable(item) for item in hooks ]

    # Now that we've removed the key from the tag and updated the comment,
    # we need to remove its reference. If the address is a runtime address
    # or outside a function, then it's a global tag being removed. Otherwise
    # it's within a function and thus a contents tag being removed.
    if func and function.within(ea) and not rt:
        internal.comment.contents.dec(ea, key)
    else:
        internal.comment.globals.dec(ea, key)

    # Finally we can return the value of the tag that was removed.
    return res

@utils.multicase(tag=six.string_types)
@utils.string.decorate_arguments('And', 'Or')
def select(tag, *And, **boolean):
    '''Query all of the global tags in the database for the specified `tag` and any others specified as `And`.'''
    res = {tag} | {item for item in And}
    boolean['And'] = {item for item in boolean.get('And', [])} | res
    return select(**boolean)
@utils.multicase()
@utils.string.decorate_arguments('And', 'Or')
def select(**boolean):
    """Query all the global tags for any tags specified by `boolean`. Yields each address found along with the matching tags as a dictionary.

    If `And` contains an iterable then require the returned address contains them.
    If `Or` contains an iterable then include any other tags that are specified.
    """
    containers = (builtins.tuple, builtins.set, builtins.list)
    boolean = {key : {item for item in value} if isinstance(value, containers) else {value} for key, value in boolean.items()}

    # Nothing specific was queried, so just yield all tags that are available.
    if not boolean:
        for ea in internal.comment.globals.address():
            ui.navigation.set(ea)
            Ftag, owners = (function.tag, {f for f in function.chunk.owners(ea)}) if function.within(ea) else (tag, {ea})
            tags = Ftag(ea)
            if tags and ea in owners: yield ea, tags
            elif ea not in owners: logging.info(u"{:s}.select() : Refusing to yield {:d} global tag{:s} for {:s} ({:#x}) possibly due to cache inconsistency as it is not referencing one of the candidate locations ({:s}).".format(__name__, len(tags), '' if len(tags) == 1 else 's', 'function address' if function.within(ea) else 'address', ea, ', '.join(map("{:#x}".format, owners))))
        return

    # Collect the tagnames to query as specified by the user.
    Or, And = ({item for item in boolean.get(B, [])} for B in ['Or', 'And'])

    # Walk through every tagged address so we can cross-check them with the query.
    for ea in internal.comment.globals.address():
        collected, _ = {}, ui.navigation.set(ea)
        Ftag, owners = (function.tag, {f for f in function.chunk.owners(ea)}) if function.within(ea) else (tag, {ea})
        tags = Ftag(ea)

        # Or(|) includes any of the tagnames that were queried.
        collected.update({key : value for key, value in tags.items() if key in Or})

        # And(&) includes any tags that include all of the queried tagnames.
        if And:
            if And & six.viewkeys(tags) == And:
                collected.update({key : value for key, value in tags.items() if key in And})
            else: continue

        # If we collected anything (matches), then yield the address and the matching tags.
        if collected and ea in owners: yield ea, collected
        elif ea not in owners: logging.info(u"{:s}.select({:s}) : Refusing to select from {:d} global tag{:s} for {:s} ({:#x}) possibly due to cache inconsistency as it is not referencing one of the candidate locations ({:s}).".format(__name__, utils.string.kwargs(boolean), len(tags), '' if len(tags) == 1 else 's', 'function address' if function.within(ea) else 'address', ea, ', '.join(map("{:#x}".format, owners))))
    return

@utils.multicase(tag=six.string_types)
@utils.string.decorate_arguments('tag', 'And', 'Or')
def selectcontents(tag, *Or, **boolean):
    '''Query all function contents for the specified `tag` or any others specified as `Or`.'''
    res = {tag} | {item for item in Or}
    boolean['Or'] = {item for item in boolean.get('Or', [])} | res
    return selectcontents(**boolean)
@utils.multicase()
@utils.string.decorate_arguments('And', 'Or')
def selectcontents(**boolean):
    """Query all function contents for any tags specified by `boolean`. Yields each function and the tags that match as a set.

    If `And` contains an iterable then require the returned function contains them.
    If `Or` contains an iterable then include any other tags that are specified.
    """
    containers = (builtins.tuple, builtins.set, builtins.list)
    boolean = {key : {item for item in value} if isinstance(value, containers) else {value} for key, value in boolean.items()}

    # Nothing specific was queried, so just yield all tagnames that are available.
    if not boolean:
        for ea, _ in sorted(internal.comment.contents.iterate()):
            if function.within(ui.navigation.procedure(ea)):
                contents, owners, Flogging = internal.comment.contents.name(ea, target=ea), {f for f in function.chunk.owners(ea)}, logging.info
            else:
                contents, owners, Flogging = [], {f for f in []}, logging.warning
            if contents and ea in owners: yield ea, contents
            elif ea not in owners: Flogging(u"{:s}.selectcontents() : Refusing to yield {:d} contents tag{:s} for {:s} ({:#x}) possibly due to cache inconsistency as it is not referencing {:s}.".format(__name__, len(contents), '' if len(contents) == 1 else 's', 'function address' if function.within(ea) else 'address', ea, "a candidate function address ({:s})".format(', '.join(map("{:#x}".format, owners)) if owners else 'a function')))
        return

    # Collect the tagnames to query as specified by the user.
    Or, And = ({item for item in boolean.get(B, [])} for B in ['Or', 'And'])

    # Walk through the index verifying that they're within a function. This
    # way we can cross-check their cache against the user's query.
    for ea, cache in sorted(internal.comment.contents.iterate()):
        if function.within(ui.navigation.procedure(ea)):
            sup, contents = {key for key in cache}, internal.comment.contents._read(ea, ea) or {}

        # Otherwise if we're not within a function then our cache is lying to us
        # and we need to skip this iteration.
        else:
            q = utils.string.kwargs(boolean)
            logging.warning(u"{:s}.selectcontents({:s}) : Detected cache inconsistency where address ({:#x}) should be referencing a function.".format(__name__, q, ea))
            continue

        # Check to see that the global contents cache (supval) matches the actual
        # function contents cache (blob). This isn't too serious because we always
        # trust the real function cache, but it implies that there was an
        # inconsistency when the global index of written tagnames was updated.
        blob = {key for key in contents}
        if blob != sup:
            f, q = function.address(ea), utils.string.kwargs(boolean)
            sup_formatted, blob_formatted = (', '.join(items) for items in [sup, blob])
            logging.warning(u"{:s}.selectcontents({:s}) : Detected cache inconsistency between contents of {:s} address ({:#x}) and address ({:#x}) due to a difference between the supval ({:s}) and its corresponding blob ({:s}).".format(__name__, q, f, 'function', ea, sup_formatted, blob_formatted))

        # Now start aggregating the tagnames that the user is searching for.
        collected, names, owners = {item for item in []}, internal.comment.contents.name(ea, target=ea), {item for item in function.chunk.owners(ea)}

        # Or(|) includes the address if any of the tagnames matched.
        collected.update(Or & names)

        # And(&) includes tags only if the address includes all of the specified tagnames.
        if And:
            if And & names == And:
                collected.update(And)
            else: continue

        # If anything was collected (tagnames were matched), then yield the
        # address along with the matching tagnames.
        if collected and ea in owners: yield ea, collected
        elif ea not in owners: logging.info(u"{:s}.selectcontents({:s}) : Refusing to select from {:d} contents tag{:s} for {:s} address ({:#x}) possibly due to cache inconsistency as it is not referencing {:s}.".format(__name__, utils.string.kwargs(boolean), len(names), '' if len(names) == 1 else 's', 'function', ea, "a candidate function address ({:s})".format(', '.join(map("{:#x}".format, owners)) if owners else 'a function')))
    return
selectcontent = utils.alias(selectcontents)

## imports
class imports(object):
    """
    This namespace is used for listing all of the imports within the
    database. Each import is represented by an address along with any
    naming information that is required to dynamically link external
    symbols with the binary.

    By default a tuple is yielded for each import with the format
    `(address, (shared-object, name, hint))`. In this tuple,
    `shared-object` represents the name of the shared object the
    import is imported from. The `name` is the symbol name to link
    with, and `hint` is the import ordinal hint which is used to speed
    up the linking process.

    When listing the imports that are matched, the following legend can be
    used to identify certain characteristics about them:

        `T` - The import has a type that was explicitly applied
        `t` - The import has a type that was guessted
        `H` - The import contains an ordinal number as a hint
        `+` - The import has an implicit tag applied to it (named or typed)
        `*` - The import has an explicit tag applied to it

    The different types that one can match imports with are the following:

        `address` or `ea` - Match according to the import's address
        `name` - Match according to the import's symbol name
        `module` - Filter the imports according to the specified module name
        `fullname` - Match according to the full symbol name (module + symbol)
        `like` - Filter the symbol names of all the imports according to a glob
        `regex` - Filter the symbol names of all the imports according to a regular-expression
        `ordinal` - Match according to the import's hint (ordinal)
        `index` - Match according index of the import
        `typed` - Filter all of the imports based on whether they have a type applied to them
        `tagged` - Filter the imports for any that use the specified tag(s)
        `predicate` Filter the imports by passing the above (default) tuple to a callable

    Some examples of using these keywords are as follows::

        > database.imports.list(module='kernelbase.dll')
        > iterable = database.imports.iterate(like='*alloc*')
        > result = database.imports.search(index=42)

    """
    def __new__(cls):
        return cls.__iterate__()

    @staticmethod
    def __symbol__(module_name_ordinal):
        module, name, ordinal = module_name_ordinal

        # FIXME: I believe this is a windows-only scheme...
        name = name or u"Ordinal{:d}".format(ordinal)

        # FIXME: I think this is a gnu-only thing...
        if module is None and '@@' in name:
            nestname, nestmodule = name.rsplit('@@', 1)
            return utils.string.of(nestmodule), utils.string.of(nestname)
        return utils.string.of(module), utils.string.of(name)

    @staticmethod
    def __formats__(module_name_ordinal):
        _, name = imports.__symbol__(module_name_ordinal)
        return name
    @staticmethod
    def __formatl__(module_name_ordinal):
        module, name = imports.__symbol__(module_name_ordinal)
        # FIXME: use "`" instead of "!" when analyzing an OSX fat binary
        return u"{:s}!{:s}".format(module, name)

    __format__ = __formatl__

    __matcher__ = utils.matcher()
    __matcher__.mapping('address', operator.itemgetter(0)), __matcher__.mapping('ea', operator.itemgetter(0))
    __matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), operator.itemgetter(1), __formats__.__func__)
    __matcher__.combinator('fullname', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(1), __formatl__.__func__)
    __matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(1), __formats__.__func__)
    __matcher__.combinator('module', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(1), operator.itemgetter(0))
    __matcher__.mapping('ordinal', utils.fcompose(operator.itemgetter(1), operator.itemgetter(-1)))
    __matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(1), __format__.__func__)
    __matcher__.mapping('typed', operator.truth, operator.itemgetter(0), lambda ea: idaapi.get_tinfo2(ea, idaapi.tinfo_t()) if idaapi.__version__ < 7.0 else idaapi.get_tinfo(idaapi.tinfo_t(), ea))
    __matcher__.boolean('tagged', lambda parameter, keys: operator.truth(keys) == parameter if isinstance(parameter, bool) else operator.contains(keys, parameter) if isinstance(parameter, six.string_types) else keys & builtins.set(parameter), tag, operator.methodcaller('keys'), builtins.set)
    __matcher__.predicate('predicate', lambda item: item)
    __matcher__.predicate('pred', lambda item: item)
    __matcher__.mapping('index', operator.itemgetter(0))

    @classmethod
    def __iterate__(cls):
        """Iterate through all of the imports in the database.

        Yields `(address, (module, name, ordinal))` for each iteration.
        """
        for idx in builtins.range(idaapi.get_import_module_qty()):
            module = idaapi.get_import_module_name(idx)
            listable = []
            idaapi.enum_import_names(idx, utils.fcompose(lambda *items: items, listable.append, utils.fconstant(True)))
            for ea, name, ordinal in listable:
                ui.navigation.set(ea)
                realmodule, realname = cls.__symbol__((module, name, ordinal))
                yield ea, (utils.string.of(realmodule), utils.string.of(realname), ordinal)
            continue
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def iterate(cls, string):
        '''Iterate through all of the imports in the database with a glob that matches `string`.'''
        return cls.iterate(like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'module', 'fullname', 'like', 'regex')
    def iterate(cls, **type):
        '''Iterate through all of the imports in the database that match the keyword specified by `type`.'''
        iterable = cls.__iterate__()
        for key, value in (type or {'predicate': utils.fconstant(True)}).items():
            iterable = (item for item in cls.__matcher__.match(key, value, iterable))
        for item in iterable: yield item

    # searching
    @utils.multicase()
    @classmethod
    def at(cls):
        '''Return the import at the current address.'''
        return cls.at(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, ea):
        '''Return the import at the address `ea`.'''
        ea = interface.address.inside(ea)
        Fcrit = utils.fcompose(operator.itemgetter(0), functools.partial(operator.eq, ea))
        iterable = (item for item in cls.__iterate__() if Fcrit(item))
        try:
            _, item = builtins.next(iterable)
            return item
        except StopIteration:
            pass
        raise E.MissingTypeOrAttribute(u"{:s}.at({:#x}) : Unable to determine import at specified address.".format('.'.join([__name__, cls.__name__]), ea))

    @utils.multicase()
    @classmethod
    def module(cls):
        '''Return the import module at the current address.'''
        return cls.module(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def module(cls, ea):
        '''Return the import module at the specified address `ea`.'''
        ea = interface.address.inside(ea)
        for addr, (module, _, _) in cls.__iterate__():
            if addr == ea:
                return module
            continue
        raise E.MissingTypeOrAttribute(u"{:s}.module({:#x}) : Unable to determine import module name at specified address.".format('.'.join([__name__, cls.__name__]), ea))

    # specific parts of the import
    @utils.multicase()
    @classmethod
    def fullname(cls):
        '''Return the full name of the import at the current address.'''
        return cls.fullname(ui.current.address())
    @utils.multicase()
    @classmethod
    def fullname(cls, ea):
        '''Return the full name of the import at address `ea`.'''
        return cls.__formatl__(cls.at(ea))

    @utils.multicase()
    @classmethod
    def name(cls):
        '''Return the name of the import at the current address.'''
        return cls.name(ui.current.address())
    @utils.multicase()
    @classmethod
    def name(cls, ea):
        '''Return the name of the import at address `ea`.'''
        return cls.__formats__(cls.at(ea))

    @utils.multicase()
    @classmethod
    def ordinal(cls):
        '''Return the ordinal of the import at the current address.'''
        return cls.ordinal(ui.current.address())
    @utils.multicase()
    @classmethod
    def ordinal(cls, ea):
        '''Return the ordinal of the import at the address `ea`.'''
        _, _, ordinal = cls.at(ea)
        return ordinal

    # FIXME: maybe implement a modules class for getting information on import modules
    @classmethod
    def modules(cls):
        '''Return all of the import modules defined in the database.'''
        iterable = (module for _, (module, _, _) in cls.__iterate__())
        settable = {item for item in iterable if item}
        return [utils.string.of(item) for item in settable]

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def list(cls, string):
        '''List all of the imports matching the glob `string` against the fullname.'''
        return cls.list(fullname=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'module', 'fullname', 'like', 'regex')
    def list(cls, **type):
        '''List all of the imports in the database that match the keyword specified by `type`.'''
        MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
        Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(MANGLED_DATA, MANGLED_UNKNOWN))
        MNG_NODEFINIT, MNG_NOPTRTYP, MNG_LONG_FORM = getattr(idaapi, 'MNG_NODEFINIT', 8), getattr(idaapi, 'MNG_NOPTRTYP', 7), getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)

        # Set some reasonable defaults
        maxaddr = maxmodule = cordinal = maxname = 0
        has_ordinal = False

        # Perform the first pass through our listable grabbing our field lengths
        listable = []
        for ea, (module, name, ordinal) in cls.iterate(**type):
            maxaddr = max(ea, maxaddr)
            maxname = max(len(name or ''), maxname)

            # Figure out the module with the longest name and store its length
            # whilst including the ordinal length.
            if len(module or '') > maxmodule:
                maxmodule, cordinal = len(module or ''), len("<{:d}>".format(ordinal))
            has_ordinal = has_ordinal or ordinal > 0

            # Save the item we just iterated through so we don't have to go
            # through it again.
            listable.append((ea, (module, name, ordinal)))

        # Collect the number of digits for the maximum address extracted from the first pass
        caddr = utils.string.digits(maxaddr, 16)

        # List all the fields of every import that was matched
        prefix, get_tinfo = '__imp_', (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo
        for ea, (module, name, ordinal) in listable:
            ui.navigation.set(ea)
            moduleordinal = "{:s}<{:d}>".format(module or '', ordinal) if ordinal else (module or '')

            address_s = "{:<#0{:d}x}".format(ea, 2 + math.trunc(caddr))
            module_s = "{:>{:d}s}".format(moduleordinal if module else '', maxmodule + (2 + cordinal if has_ordinal else 0))

            # Clean up the the name and then figure out what the actual name would be. We first
            # strip out the import prefix, then figure out the type before we render just the name.
            name = name[len(prefix):] if name.startswith(prefix) else name
            mangled_name_type_t = Fmangled_type(utils.string.to(name))
            realname = name if mangled_name_type_t == MANGLED_UNKNOWN else utils.string.of(idaapi.demangle_name(utils.string.to(name), MNG_NODEFINIT|MNG_NOPTRTYP) or name)

            # Some flags that are probably useful.
            ftyped = 'T' if get_tinfo(idaapi.tinfo_t(), ea) else 't' if t.has_typeinfo(ea) else '-'
            fordinaled = 'H' if ordinal > 0 else '-'

            tags = tag(ea)
            tags.pop('__name__', None)
            ftagged = '-' if not tags else '*' if any(not item.startswith('__') for item in tags) else '+'

            flags = itertools.chain(ftyped, fordinaled, ftagged)

            # If there's any type information for the address, then we can just render it.
            ti = idaapi.tinfo_t()
            if get_tinfo(ti, ea):
                description = idaapi.print_tinfo('', 0, 0, idaapi.PRTYPE_DEF, ti, utils.string.to(realname), '')
                six.print_(u"{:s} : {:s} : {:s} : {:s}".format(address_s, ''.join(flags), module_s, utils.string.of(description)))

            # Otherwise we'll use the realname to demangle it to something displayable.
            else:
                description = idaapi.demangle_name(utils.string.to(name), MNG_LONG_FORM) or realname
                six.print_(u"{:s} : {:s} : {:s} : {:s}".format(address_s, ''.join(flags), module_s, utils.string.of(description)))
            continue
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def search(cls, string):
        '''Search through all of the imports matching the fullname glob `string`.'''
        return cls.search(fullname=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'module', 'fullname', 'like', 'regex')
    def search(cls, **type):
        '''Search through all of the imports within the database and return the first result matching the keyword specified by `type`.'''
        query_s = utils.string.kwargs(type)

        listable = [item for item in cls.iterate(**type)]
        if len(listable) > 1:
            messages = (u"{:x} {:s}{:s} {:s}".format(ea, module, "<{:d}>".format(ordinal) if ordinal else '', name) for ea, (module, name, ordinal) in listable)
            [ logging.info(msg) for msg in messages ]
            f = utils.fcompose(operator.itemgetter(1), cls.__formatl__)
            logging.warning(u"{:s}.search({:s}) : Found {:d} matching results. Returning the first import \"{:s}\".".format('.'.join([__name__, cls.__name__]), query_s, len(listable), utils.string.escape(f(listable[0]), '"')))

        iterable = (item for item in listable)
        res = builtins.next(iterable, None)
        if res is None:
            raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format('.'.join([__name__, cls.__name__]), query_s))
        return res[0]

###
class address(object):
    """
    This namespace is used for translating an address in the database
    to another address according to a number of constraints or types.
    Essentially these functions are used to assist with navigation.
    As an example, these functions allow one to navigate between the
    next and previous "call" instructions, addresses that contain
    data references, or even to navigate to unknown (undefined)
    addresses.

    This namespace is also aliased as ``database.a``.

    Some of the more common functions are used so often that they're also
    aliased as globals. Each of these can be used for navigation or for
    determining the next valid address. These are:

        ``database.next`` - Return the "next" defined address
        ``database.prev`` - Return the "previous" defined address
        ``database.nextref`` - Return the "next" address with a reference.
        ``database.prevref`` - Return the "previous" address with a reference
        ``database.nextreg`` - Return the "next" address using a register
        ``database.prevreg`` - Return the "previous" address using a register

    Some examples of using this namespace can be::

        > ea = database.a.next(ea)
        > ea = database.a.prevreg(ea, 'edx', write=1)
        > ea = database.a.nextref(ea)
        > ea = database.a.prevcall(ea)

    """

    # FIXME
    # The methods in this namespace should be put into a utils class. This way
    # each of these operations can be exposed to the user in function.chunks,
    # function.block, etc. Most of these functions only need to know their
    # searching boundaries, and so we should derive from that logic for our class.

    @utils.multicase()
    def __new__(cls):
        '''Return the current address or a list of addresses for the current selection.'''
        address, selection = ui.current.address(), ui.current.selection()
        if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.head(address)
        start, stop = selection
        return [ea for ea in cls.iterate(start, stop)]
    @utils.multicase(ea=six.integer_types)
    def __new__(cls, ea):
        '''Return the address of the item containing the address `ea`.'''
        return cls.head(ea)
    @utils.multicase(start=six.integer_types, end=six.integer_types)
    def __new__(cls, start, end):
        '''Return a list containing each of the addresses from `start` to `end`.'''
        return [ea for ea in cls.iterate(start, end)]
    @utils.multicase(start=six.integer_types, end=six.integer_types, step=callable)
    def __new__(cls, start, end, step):
        '''Return a list containing each of the addresses from `start` to `end` using the callable `step` to determine the next address.'''
        return [ea for ea in cls.iterate(start, end, step)]
    @utils.multicase(bounds=tuple)
    def __new__(cls, bounds):
        '''Return a list containing each of the addresses within `bounds`.'''
        return [ea for ea in cls.iterate(bounds)]
    @utils.multicase(bounds=tuple, step=callable)
    def __new__(cls, bounds, step):
        '''Return a list containing each of the addresses within `bounds` using the callable `step` to determine the next address.'''
        return [ea for ea in cls.iterate(bounds, step)]

    @utils.multicase()
    @classmethod
    def bounds(cls):
        '''Return the bounds of the current address or selection in a tuple formatted as `(left, right)`.'''
        address, selection = ui.current.address(), ui.current.selection()
        if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.bounds(address)
        start, stop = selection
        return interface.bounds_t(start, cls.next(stop))
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def bounds(cls, ea):
        '''Return the bounds of the specified address `ea` in a tuple formatted as `(left, right)`.'''
        return interface.bounds_t(ea, ea + type.size(ea))

    @staticmethod
    def __walk__(ea, next, predicate):
        '''Return the first address from `ea` using `next` for stepping while the callable in `predicate` returns true.'''
        res = interface.address.inside(ea)

        # Now that we know we're a valid address in the database,
        # we simply need to keeping calling next() while match()
        # continuously allows us to.
        while res not in {None, idaapi.BADADDR} and predicate(res):
            ea = ui.navigation.analyze(res)
            res = next(ea)
        return res

    @utils.multicase()
    @classmethod
    def iterate(cls):
        '''Iterate through the currently selected addresses.'''
        selection = ui.current.selection()
        return cls.iterate(selection)
    @utils.multicase(end=six.integer_types)
    @classmethod
    def iterate(cls, end):
        '''Iterate from the current address to `end`.'''
        return cls.iterate(ui.current.address(), end)
    @utils.multicase(end=six.integer_types, step=callable)
    @classmethod
    def iterate(cls, end, step):
        '''Iterate from the current address to `end` using the callable `step` to determine the next address.'''
        return cls.iterate(ui.current.address(), end, step)
    @utils.multicase(start=six.integer_types, end=six.integer_types)
    @classmethod
    def iterate(cls, start, end):
        '''Iterate from address `start` to `end`.'''
        start, end = interface.address.within(start, end)
        step = cls.prev if start > end else cls.next
        return cls.iterate(start, end, step)
    @utils.multicase(start=six.integer_types, end=six.integer_types, step=callable)
    @classmethod
    def iterate(cls, start, end, step):
        '''Iterate from address `start` to `end` using the callable `step` to determine the next address.'''
        left, right = config.bounds()

        # we need to always ensure that the maximum address is always excluded. no
        # good reason for this, but i'm pretty sure that this is how this had always
        # worked as the positions we get should be thought of like a cursor.
        op = operator.lt if start <= end else operator.ge
        ea, stop = interface.address.within(start, end) if start <= end else reversed(sorted(interface.address.inside(end, start - 1)))

        # loop continuosly until we terminate or we run out of bounds.
        try:
            while ea not in {idaapi.BADADDR, None} and op(ea, stop):
                yield ea
                ea = step(ea)
        except E.OutOfBoundsError:
            pass
        return
    @utils.multicase(bounds=tuple)
    @classmethod
    def iterate(cls, bounds):
        '''Iterate through all of the addresses defined within `bounds`.'''
        left, right = bounds
        return cls.iterate(left, right, cls.prev if left > right else cls.next)
    @utils.multicase(bounds=tuple, step=callable)
    @classmethod
    def iterate(cls, bounds, step):
        '''Iterate through all of the addresses defined within `bounds` using the callable `step` to determine the next address.'''
        left, right = bounds
        return cls.iterate(left, right, step)

    @utils.multicase()
    @classmethod
    def blocks(cls):
        '''Iterate through the currently selected blocks.'''
        selection = ui.current.selection()
        return cls.blocks(selection)
    @utils.multicase(end=six.integer_types)
    @classmethod
    def blocks(cls, end):
        '''Yields the boundaries of each block from the current address to `end`.'''
        return cls.blocks(ui.current.address(), end)
    @utils.multicase(bounds=tuple)
    @classmethod
    def blocks(cls, bounds):
        '''Yields the boundaries of each block within the specified `bounds`.'''
        left, right = bounds
        return cls.blocks(left, right)
    @utils.multicase(start=six.integer_types, end=six.integer_types)
    @classmethod
    def blocks(cls, start, end):
        '''Yields the boundaries of each block between the addresses `start` and `end`.'''
        block, _ = start, end = interface.address.head(start), address.tail(end) + 1
        for ea in cls.iterate(start, end):
            nextea = cls.next(ea)

            ## XXX: it seems that idaapi.is_basic_block_end requires the following to be called
            # idaapi.decode_insn(insn, ea)
            ## XXX: for some reason is_basic_block_end will occasionally include some stray 'call' instructions
            # if idaapi.is_basic_block_end(ea):
            #     yield block, nextea
            ## XXX: in later versions of ida, is_basic_block_end takes two args (ea, bool call_insn_stops_block)

            # skip call instructions
            if _instruction.type.is_call(ea):
                continue

            # halting instructions terminate a block
            if _instruction.type.is_return(ea):
                yield interface.bounds_t(block, nextea)
                block = ea

            # branch instructions will terminate a block
            elif cxdown(ea):
                yield interface.bounds_t(block, nextea)
                block = nextea

            # a branch target will also terminate a block
            elif cxup(ea) and block != ea:
                yield interface.bounds_t(block, ea)
                block = ea
            continue
        return

    @utils.multicase()
    @classmethod
    def head(cls):
        '''Return the address of the byte at the beginning of the current address.'''
        return cls.head(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def head(cls, ea):
        '''Return the address of the byte at the beginning of the address `ea`.'''
        ea = interface.address.within(ea)
        return idaapi.get_item_head(ea)

    @utils.multicase()
    @classmethod
    def tail(cls):
        '''Return the last byte at the end of the current address.'''
        return cls.tail(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def tail(cls, ea):
        '''Return the address of the last byte at the end of the address at `ea`.'''
        ea = interface.address.within(ea)
        return idaapi.get_item_end(ea) - 1

    @utils.multicase()
    @classmethod
    def prev(cls, **count):
        '''Return the previous address from the current address.'''
        return cls.prev(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prev(cls, predicate, **count):
        '''Return the previous address from the current address that satisfies the provided `predicate`.'''
        return cls.prev(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prev(cls, ea):
        '''Return the previous address from the address specified by `ea`.'''
        return cls.prev(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prev(cls, ea, predicate):
        '''Return the previous address from the address `ea` that satisfies the provided `predicate`.'''
        return cls.prevF(ea, predicate, 1)
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prev(cls, ea, count):
        '''Return the previous `count` addresses from the address specified by `ea`.'''
        return cls.prevF(ea, utils.fidentity, count)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable, count=six.integer_types)
    @classmethod
    def prev(cls, ea, predicate, count):
        '''Return the previous `count` addresses from the address `ea` that satisfies the provided `predicate`.'''
        return cls.prevF(ea, predicate, count)

    @utils.multicase()
    @classmethod
    def next(cls, **count):
        '''Return the next address from the current address.'''
        return cls.next(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def next(cls, predicate, **count):
        '''Return the next address from the current address that satisfies the provided `predicate`.'''
        return cls.next(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def next(cls, ea):
        '''Return the next address from the address `ea`.'''
        return cls.next(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def next(cls, ea, predicate):
        '''Return the next address from the address `ea` that satisfies the provided `predicate`.'''
        return cls.nextF(ea, predicate, 1)
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def next(cls, ea, count):
        '''Return the next `count` addresses from the address specified by `ea`.'''
        return cls.nextF(ea, utils.fidentity, count)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable, count=six.integer_types)
    @classmethod
    def next(cls, ea, predicate, count):
        '''Return the next `count` addresses from the address `ea` that satisfies the provided `predicate`.'''
        return cls.nextF(ea, predicate, count)

    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevF(cls, predicate, **count):
        '''Return the previous address from the current one that satisfies the provided `predicate`.'''
        return cls.prevF(ui.current.address(), predicate, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevF(cls, ea, predicate, **count):
        '''Return the previous address from the address `ea` that satisfies the provided `predicate`.'''
        return cls.prevF(ea, predicate, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable, count=six.integer_types)
    @classmethod
    def prevF(cls, ea, predicate, count):
        '''Return the previous `count` addresses from the address `ea` that satisfies the provided `predicate`.'''
        Fprev, Finverse = utils.fcompose(interface.address.within, idaapi.prev_not_tail), utils.fcompose(predicate, operator.not_)

        # If we're at the very bottom address of the database then skip
        # the boundary check for interface.address.within().
        _, bottom = config.bounds()
        if ea == bottom:
            Fprev = idaapi.prev_not_tail

        # Otherwise if we're already at the top, there's nowhere else to go.
        if Fprev(ea) == idaapi.BADADDR:
            raise E.AddressOutOfBoundsError(u"{:s}.prevF: Refusing to seek past the top of the database ({:#x}). Stopped at address {:#x}.".format('.'.join([__name__, cls.__name__]), config.bounds()[0], ea))

        # Walk until right before the matching address, and then return the one before.
        res = cls.__walk__(Fprev(ea), Fprev, Finverse)
        return cls.prevF(res, predicate, count - 1) if count > 1 else res

    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextF(cls, predicate, **count):
        '''Return the next address from the current one that satisfies the provided `predicate`.'''
        return cls.nextF(ui.current.address(), predicate, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextF(cls, ea, predicate, **count):
        '''Return the next address from the address `ea` that satisfies the provided `predicate`.'''
        return cls.nextF(ea, predicate, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable, count=six.integer_types)
    @classmethod
    def nextF(cls, ea, predicate, count):
        '''Return the next `count` addresses from the address `ea` that satisfies the provided `predicate`.'''
        Fnext, Finverse = utils.fcompose(interface.address.within, idaapi.next_not_tail), utils.fcompose(predicate, operator.not_)

        # If we're at the very bottom of the database, then we're done.
        if Fnext(ea) == idaapi.BADADDR:
            raise E.AddressOutOfBoundsError(u"{:s}.nextF: Refusing to seek past the bottom of the database ({:#x}). Stopped at address {:#x}.".format('.'.join([__name__, cls.__name__]), config.bounds()[1], idaapi.get_item_end(ea)))

        # Walk until right before the matching address, and then return the one after.
        res = cls.__walk__(Fnext(ea), Fnext, Finverse)
        return cls.nextF(res, predicate, count - 1) if count > 1 else res

    @utils.multicase()
    @classmethod
    def prevref(cls, **count):
        '''Return the previous address from the current one that has anything referencing it.'''
        return cls.prevref(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevref(cls, predicate, **count):
        '''Return the previous address from the current one that has anything referencing it and satisfies the provided `predicate`.'''
        return cls.prevref(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevref(cls, ea):
        '''Return the previous address from the address `ea` that has anything referencing it.'''
        return cls.prevref(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevref(cls, ea, predicate, **count):
        '''Return the previous address from the address `ea` that has anything referencing it and satisfies the provided `predicate`.'''
        Fxref = utils.fcompose(xref.up, len, functools.partial(operator.lt, 0))
        F = utils.fcompose(utils.fmap(Fxref, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevref(cls, ea, count):
        '''Return the previous `count` addresses from the address `ea` that has anything referencing it.'''
        Fxref = utils.fcompose(xref.up, len, functools.partial(operator.lt, 0))
        return cls.prevF(ea, Fxref, count)

    @utils.multicase()
    @classmethod
    def nextref(cls, **count):
        '''Return the next address from the current one that has anything referencing it.'''
        return cls.nextref(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextref(cls, predicate, **count):
        '''Return the next address from the current one that has anything referencing it and satisfies the provided `predicate`.'''
        return cls.nextref(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextref(cls, ea):
        '''Return the next address from the address `ea` that has anything referencing it.'''
        return cls.nextref(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextref(cls, ea, predicate, **count):
        '''Return the next address from the address `ea` that has anything referencing it and satisfies the provided `predicate`.'''
        Fxref = utils.fcompose(xref.up, len, functools.partial(operator.lt, 0))
        F = utils.fcompose(utils.fmap(Fxref, predicate), builtins.all)
        return cls.nextF(ea, Fxref, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextref(cls, ea, count):
        '''Return the next `count` addresses from the address `ea` that has anything referencing it.'''
        Fxref = utils.fcompose(xref.up, len, functools.partial(operator.lt, 0))
        return cls.nextF(ea, Fxref, count)

    @utils.multicase()
    @classmethod
    def prevdref(cls, **count):
        '''Return the previous address from the current one that has data referencing it.'''
        return cls.prevdref(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevdref(cls, predicate, **count):
        '''Return the previous address from the current one that has data referencing it and satisfies the provided `predicate`.'''
        return cls.prevdref(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevdref(cls, ea):
        '''Return the previous address from the address `ea` that has data referencing it.'''
        return cls.prevdref(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevdref(cls, ea, predicate, **count):
        '''Return the previous address from the address `ea` that has data referencing it and satisfies the provided `predicate`.'''
        Fdref = utils.fcompose(xref.data_up, len, functools.partial(operator.lt, 0))
        F = utils.fcompose(utils.fmap(Fdref, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevdref(cls, ea, count):
        '''Return the previous `count` addresses from the address `ea` that has data referencing it.'''
        Fdref = utils.fcompose(xref.data_up, len, functools.partial(operator.lt, 0))
        return cls.prevF(ea, Fdref, count)

    @utils.multicase()
    @classmethod
    def nextdref(cls, **count):
        '''Return the next address from the current one that has data referencing it.'''
        return cls.nextdref(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextdref(cls, predicate, **count):
        '''Return the next address from the current one that has data referencing it and satisfies the provided `predicate`.'''
        return cls.nextdref(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextdref(cls, ea):
        '''Return the next address from the address `ea` that has data referencing it.'''
        return cls.nextdref(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextdref(cls, ea, predicate, **count):
        '''Return the next address from the address `ea` that has data referencing it and satisfies the provided `predicate`.'''
        Fdref = utils.fcompose(xref.data_up, len, functools.partial(operator.lt, 0))
        F = utils.fcompose(utils.fmap(Fdref, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextdref(cls, ea, count):
        '''Return the next `count` addresses from the address `ea` that has data referencing it.'''
        Fdref = utils.fcompose(xref.data_up, len, functools.partial(operator.lt, 0))
        return cls.nextF(ea, Fdref, count)

    # FIXME: the semantics of these aliases are wrong, and they really shouldn't be
    #        aliasing a data reference. thus, we should be checking the address' type.
    prevdata, nextdata = utils.alias(prevdref, 'address'), utils.alias(nextdref, 'address')

    @utils.multicase()
    @classmethod
    def prevcref(cls, **count):
        '''Return the previous address from the current one that has code referencing it.'''
        return cls.prevcref(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevcref(cls, predicate, **count):
        '''Return the previous address from the current one that has code referencing it and satisfies the provided `predicate`.'''
        return cls.prevcref(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevcref(cls, ea):
        '''Return the previous address from the address `ea` that has code referencing it.'''
        return cls.prevcref(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevcref(cls, ea, predicate, **count):
        '''Return the previous address from the address `ea` that has code referencing it and satisfies the provided `predicate`.'''
        Fcref = utils.fcompose(xref.code_up, len, functools.partial(operator.lt, 0))
        F = utils.fcompose(utils.fmap(Fcref, predicate), builtins.all)
        return cls.prevF(ea, Fcref, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevcref(cls, ea, count):
        '''Return the previous `count` addresses from the address `ea` that has code referencing it.'''
        Fcref = utils.fcompose(xref.code_up, len, functools.partial(operator.lt, 0))
        return cls.prevF(ea, Fcref, count)

    @utils.multicase()
    @classmethod
    def nextcref(cls, **count):
        '''Return the next address from the current one that has code referencing it.'''
        return cls.nextcref(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextcref(cls, predicate, **count):
        '''Return the next address from the current one that has code referencing it and satisfies the provided `predicate`.'''
        return cls.nextcref(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextcref(cls, ea):
        '''Return the next address from the address `ea` that has code referencing it.'''
        return cls.nextcref(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextcref(cls, ea, predicate, **count):
        '''Return the next address from the address `ea` that has code referencing it and satisfies the provided `predicate`.'''
        Fcref = utils.fcompose(xref.code_up, len, functools.partial(operator.lt, 0))
        F = utils.fcompose(utils.fmap(Fcref, predicate), builtins.all)
        return cls.nextF(ea, Fcref, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextcref(cls, ea, count):
        '''Return the next `count` addresses from the address `ea` that has code referencing it.'''
        Fcref = utils.fcompose(xref.code_up, len, functools.partial(operator.lt, 0))
        return cls.nextF(ea, Fcref, count)

    # FIXME: the semantics of these aliases are wrong, and they really shouldn't be#
    #        aliasing a code reference. thus, we should be checking the address' type.
    prevcode, nextcode = utils.alias(prevcref, 'address'), utils.alias(nextcref, 'address')

    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def prevreg(cls, reg, *regs, **modifiers):
        '''Return the previous address containing an instruction that uses `reg` or any one of the specified `regs`.'''
        return cls.prevreg(ui.current.address(), reg, *regs, **modifiers)
    @utils.multicase(predicate=builtins.callable, reg=(six.string_types, interface.register_t))
    @classmethod
    def prevreg(cls, predicate, reg, *regs, **modifiers):
        '''Return the previous address containing an instruction that uses `reg` or any one of the specified `regs` and satisfies the provided `predicate`.'''
        return cls.prevreg(ui.current.address(), predicate, reg, *regs, **modifiers)
    @utils.multicase(ea=six.integer_types, reg=(six.string_types, interface.register_t))
    @classmethod
    def prevreg(cls, ea, reg, *regs, **modifiers):
        '''Return the previous address from the address `ea` containing an instruction that uses `reg` or any one of the specified `regs`.'''
        return cls.prevreg(ea, utils.fconst(True), reg, *regs, **modifiers)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable, reg=(six.string_types, interface.register_t))
    @classmethod
    def prevreg(cls, ea, predicate, reg, *regs, **modifiers):
        '''Return the previous address from the address `ea` containing an instruction that uses `reg` or any one of the specified `regs` and satisfies the provided `predicate`.'''
        regs = (reg,) + regs
        count = modifiers.get('count', 1)
        args = u', '.join(["{:x}".format(ea)] + ["{!r}".format(predicate)] + ["\"{:s}\"".format(utils.string.escape(str(reg), '"')) for reg in regs])
        args = args + (u", {:s}".format(utils.string.kwargs(modifiers)) if modifiers else '')

        # generate each helper using the regmatch class
        iterops = interface.regmatch.modifier(**modifiers)
        uses_register = interface.regmatch.use(regs)

        # if within a function, then make sure we're within the chunk's bounds and we're a code type
        if function.within(ea):
            (start, _) = function.chunk(ea)
            fwithin = utils.fcompose(utils.fmap(functools.partial(operator.le, start), type.is_code), builtins.all)

        # otherwise ensure that we're not in the function and we're a code type.
        else:
            fwithin = utils.fcompose(utils.fmap(utils.fcompose(function.within, operator.not_), type.is_code), builtins.all)

            start = cls.__walk__(ea, cls.prev, fwithin)
            start = top() if start == idaapi.BADADDR else start

        # define a predicate for cls.walk to continue looping when true
        Freg = lambda ea: fwithin(ea) and not builtins.any(uses_register(ea, opnum) for opnum in iterops(ea))
        F = utils.fcompose(utils.fmap(Freg, predicate), builtins.all)

        ## skip the current address
        prevea = cls.prev(ea)
        if prevea is None:
            # FIXME: include registers in message
            logging.fatal(u"{:s}.prevreg({:s}) : Unable to start walking from the previous address of {:#x}.".format('.'.join([__name__, cls.__name__]), args, ea))
            return ea

        # now walk while none of our registers match
        res = cls.__walk__(prevea, cls.prev, F)
        if res in {None, idaapi.BADADDR} or (cls == address and res < start):
            # FIXME: include registers in message
            raise E.RegisterNotFoundError(u"{:s}.prevreg({:s}) : Unable to find register{:s} within the chunk {:#x}{:+#x}. Stopped at address {:#x}.".format('.'.join([__name__, cls.__name__]), args, '' if len(regs)==1 else 's', start, ea, res))

        # if the address is not a code type, then recurse so we can skip it.
        if not type.is_code(res):
            return cls.prevreg(res, predicate, *regs, **modifiers)

        # recurse if the user specified it
        modifiers['count'] = count - 1
        return cls.prevreg(res, predicate, *regs, **modifiers) if count > 1 else res

    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def nextreg(cls, reg, *regs, **modifiers):
        '''Return the next address containing an instruction that uses `reg` or any one of the specified `regs`.'''
        return cls.nextreg(ui.current.address(), reg, *regs, **modifiers)
    @utils.multicase(predicate=builtins.callable, reg=(six.string_types, interface.register_t))
    @classmethod
    def nextreg(cls, predicate, reg, *regs, **modifiers):
        '''Return the next address containing an instruction uses `reg` or any one of the specified `regs` and satisfies the provided `predicate`.'''
        return cls.nextreg(ui.current.address(), predicate, reg, *regs, **modifiers)
    @utils.multicase(ea=six.integer_types, reg=(six.string_types, interface.register_t))
    @classmethod
    def nextreg(cls, ea, reg, *regs, **modifiers):
        '''Return the next address from the address `ea` containing an instruction that uses `reg` or any one of the specified `regs`.'''
        return cls.nextreg(ea, utils.fconst(True), reg, *regs, **modifiers)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable, reg=(six.string_types, interface.register_t))
    @classmethod
    def nextreg(cls, ea, predicate, reg, *regs, **modifiers):
        '''Return the next address from the address `ea` containing an instruction that uses `reg` or any one of the specified `regs` and satisfies the provided `predicate`.'''
        regs = (reg,) + regs
        count = modifiers.get('count', 1)
        args = u', '.join(["{:x}".format(ea)] + ["{!r}".format(predicate)] + ["\"{:s}\"".format(utils.string.escape(str(reg), '"')) for reg in regs])
        args = args + (u", {:s}".format(utils.string.kwargs(modifiers)) if modifiers else '')

        # generate each helper using the regmatch class
        iterops = interface.regmatch.modifier(**modifiers)
        uses_register = interface.regmatch.use(regs)

        # if within a function, then make sure we're within the chunk's bounds.
        if function.within(ea):
            (_, end) = function.chunk(ea)
            fwithin = utils.fcompose(utils.fmap(functools.partial(operator.gt, end), type.is_code), builtins.all)

        # otherwise ensure that we're not in a function and we're a code type.
        else:
            fwithin = utils.fcompose(utils.fmap(utils.fcompose(function.within, operator.not_), type.is_code), builtins.all)

            end = cls.__walk__(ea, cls.next, fwithin)
            end = bottom() if end == idaapi.BADADDR else end

        # define a predicate for cls.walk to continue looping when true
        Freg = lambda ea: fwithin(ea) and not builtins.any(uses_register(ea, opnum) for opnum in iterops(ea))
        F = utils.fcompose(utils.fmap(Freg, predicate), builtins.all)

        # skip the current address
        nextea = cls.next(ea)
        if nextea is None:
            # FIXME: include registers in message
            logging.fatal(u"{:s}.nextreg({:s}) : Unable to start walking from the next address of {:#x}.".format('.'.join([__name__, cls.__name__]), args, ea))
            return ea

        # now walk while none of our registers match
        res = cls.__walk__(nextea, cls.next, F)
        if res in {None, idaapi.BADADDR} or (cls == address and res >= end):
            # FIXME: include registers in message
            raise E.RegisterNotFoundError(u"{:s}.nextreg({:s}) : Unable to find register{:s} within chunk {:#x}{:+#x}. Stopped at address {:#x}.".format('.'.join([__name__, cls.__name__]), args, '' if len(regs)==1 else 's', ea, end, res))

        # if the address is not a code type, then recurse so we can skip it.
        if not type.is_code(res):
            return cls.nextreg(res, predicate, *regs, **modifiers)

        # recurse if the user specified it
        modifiers['count'] = count - 1
        return cls.nextreg(res, predicate, *regs, **modifiers) if count > 1 else res

    @utils.multicase(delta=six.integer_types)
    @classmethod
    def prevstack(cls, delta):
        '''Return the previous instruction from the current one that is past the specified sp `delta`.'''
        return cls.prevstack(ui.current.address(), delta)
    @utils.multicase(ea=six.integer_types, delta=six.integer_types)
    @classmethod
    def prevstack(cls, ea, delta):
        '''Return the previous instruction from the address `ea` that is past the specified sp `delta`.'''

        # FIXME: it'd be much better to keep track of this with a global class that wraps the logger
        if getattr(cls, '__prevstack_warning_count__', 0) == 0:
            logging.warning(u"{:s}.prevstack({:#x}, {:#x}) : This function's semantics are subject to change and may be deprecated in the future..".format('.'.join([__name__, cls.__name__]), ea, delta))
            cls.__prevstack_warning_count__ = getattr(cls, '__prevstack_warning_count__', 0) + 1

        # Get all the stack changes within the current function chunk, and the
        # current sp. This way we can bisect to found our starting point and
        # traverse backwards from there.
        points = [(item, sp) for item, sp in function.chunk.points(ea)]
        addresses = [item for item, _ in points]

        # Now we'll bisect our list of items in order to slice the points that
        # out that are completely irrelevant, and reverse the list so that
        # we can just walk it until we find the address that matches our argument.
        index = bisect.bisect_left(addresses, ea)
        filtered = points[:index][::-1]

        # Return the first entry in the list that has a delta (difference
        # between its sp and the starting address) that's larger than what
        # was requested by the user.
        start, position = function.get_spdelta(ea), cls.prev(ea)
        for address, sp in filtered:
            if delta <= abs(start - sp):
                return cls.next(position) if delta < abs(start - sp) else position
            position = cls.prev(address)

        # If we ran out of entries in the list, then save the last address
        # so that we can raise an exception to the user.
        else:
            fn, end = function.address(ea), address
        raise E.AddressOutOfBoundsError(u"{:s}.prevstack({:#x}, {:+#x}) : Unable to locate instruction matching contraints due to encountering the top ({:#x}) of the function {:#x}.".format('.'.join([__name__, cls.__name__]), ea, delta, end, fn))

    # FIXME: modify this to just locate _any_ amount of change in the sp delta by default
    @utils.multicase(delta=six.integer_types)
    @classmethod
    def nextstack(cls, delta):
        '''Return the next instruction from the current one that is past the sp `delta`.'''
        return cls.nextstack(ui.current.address(), delta)
    @utils.multicase(ea=six.integer_types, delta=six.integer_types)
    @classmethod
    def nextstack(cls, ea, delta):
        '''Return the next instruction from the address `ea` that is past the sp `delta`.'''

        # FIXME: it'd be much better to keep track of this with a global class that wraps the logger
        if getattr(cls, '__nextstack_warning_count__', 0) == 0:
            logging.warning(u"{:s}.nextstack({:#x}, {:#x}) : This function's semantics are subject to change and may be deprecatd in the future.".format('.'.join([__name__, cls.__name__]), ea, delta))
            cls.__nextstack_warning_count__ = getattr(cls, '__nextstack_warning_count__', 0) + 1

        # Get all the stack changes within the current function chunk, and the
        # current sp. This way we can bisect to find out where to start from
        # continue to walk forwards from there looking for our match.
        points = [(item, sp) for item, sp in function.chunk.points(ea)]
        addresses = [item for item, _ in points]

        # Now we'll bisect our list of items in order to select only the
        # point thats are relevant. This way we can just walk the list
        # until we find the address with the matching delta.
        index = bisect.bisect_right(addresses, ea)
        filtered = points[index:]

        # Traverse our filtered list until we find the first entry that
        # has the delta from the starting address that is larger than the
        # size that was requested by the user.
        start = function.get_spdelta(ea)
        for address, sp in filtered:
            if delta <= abs(start - sp):
                return cls.prev(address) if delta < abs(start - sp) else address
            continue

        # If we completed processing our filtered list, then we ran out
        # of addresses and need to save the address to raise an exception.
        else:
            fn, end = function.address(ea), address
        raise E.AddressOutOfBoundsError(u"{:s}.nextstack({:#x}, {:+#x}) : Unable to locate instruction matching contraints due to encountering the bottom ({:#x}) of the function {:#x}.".format('.'.join([__name__, cls.__name__]), ea, delta, end, fn))

    # FIXME: we should add aliases for a stack point as per the terminology that's used
    #        by IDA in its ``idaapi.func_t`` when getting points for a function or a chunk.
    prevdelta, nextdelta = utils.alias(prevstack, 'address'), utils.alias(nextstack, 'address')

    @utils.multicase()
    @classmethod
    def prevcall(cls, **count):
        '''Return the previous call instruction from the current address.'''
        return cls.prevcall(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevcall(cls, predicate, **count):
        '''Return the previous call instruction from the current address that satisfies the provided `predicate`.'''
        return cls.prevcall(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevcall(cls, ea):
        '''Return the previous call instruction from the address `ea`.'''
        return cls.prevcall(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevcall(cls, ea, predicate, **count):
        '''Return the previous call instruction from the address `ea` that satisfies the provided `predicate`.'''
        F = utils.fcompose(utils.fmap(_instruction.type.is_call, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevcall(cls, ea, count):
        '''Return the previous `count` call instructions from the address `ea`.'''
        return cls.prevF(ea, _instruction.type.is_call, count)

    @utils.multicase()
    @classmethod
    def nextcall(cls, **count):
        '''Return the next call instruction from the current address.'''
        return cls.nextcall(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextcall(cls, predicate, **count):
        '''Return the next call instruction from the current address that satisfies the provided `predicate`.'''
        return cls.nextcall(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextcall(cls, ea):
        '''Return the next call instruction from the address `ea`.'''
        return cls.nextcall(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextcall(cls, ea, predicate, **count):
        '''Return the next call instruction from the address `ea` that satisfies the provided `predicate`.'''
        F = utils.fcompose(utils.fmap(_instruction.type.is_call, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextcall(cls, ea, count):
        '''Return the next `count` call instructions from the address `ea`.'''
        return cls.nextF(ea, _instruction.type.is_call, count)

    @utils.multicase()
    @classmethod
    def prevbranch(cls, **count):
        '''Return the previous branch instruction from the current one.'''
        return cls.prevbranch(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevbranch(cls, predicate, **count):
        '''Return the previous branch instruction from the current one that satisfies the provided `predicate`.'''
        return cls.prevbranch(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevbranch(cls, ea):
        '''Return the previous branch instruction from the address `ea`.'''
        return cls.prevbranch(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevbranch(cls, ea, predicate, **count):
        '''Return the previous branch instruction from the address `ea` that satisfies the provided `predicate`.'''
        Fnocall = utils.fcompose(_instruction.type.is_call, operator.not_)
        Fbranch = _instruction.type.is_branch
        Fx = utils.fcompose(utils.fmap(Fnocall, Fbranch), builtins.all)
        F = utils.fcompose(utils.fmap(Fx, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevbranch(cls, ea, count):
        '''Return the previous `count` branch instructions from the address `ea`.'''
        Fnocall = utils.fcompose(_instruction.type.is_call, operator.not_)
        Fbranch = _instruction.type.is_branch
        F = utils.fcompose(utils.fmap(Fnocall, Fbranch), builtins.all)
        return cls.prevF(ea, F, count)

    @utils.multicase()
    @classmethod
    def nextbranch(cls, **count):
        '''Return the next branch instruction from the current one.'''
        return cls.nextbranch(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextbranch(cls, predicate, **count):
        '''Return the next branch instruction that satisfies the provided `predicate`.'''
        return cls.nextbranch(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextbranch(cls, ea):
        '''Return the next branch instruction from the address `ea`.'''
        return cls.nextbranch(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextbranch(cls, ea, predicate, **count):
        '''Return the next branch instruction from the address `ea` that satisfies the provided `predicate`.'''
        Fnocall = utils.fcompose(_instruction.type.is_call, operator.not_)
        Fbranch = _instruction.type.is_branch
        Fx = utils.fcompose(utils.fmap(Fnocall, Fbranch), builtins.all)
        F = utils.fcompose(utils.fmap(Fx, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextbranch(cls, ea, count):
        '''Return the next `count` branch instructions from the address `ea`.'''
        Fnocall = utils.fcompose(_instruction.type.is_call, operator.not_)
        Fbranch = _instruction.type.is_branch
        F = utils.fcompose(utils.fmap(Fnocall, Fbranch), builtins.all)
        return cls.nextF(ea, F, count)

    @utils.multicase(mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple))
    @classmethod
    def prevmnemonic(cls, mnemonics):
        '''Return the address of the previous instruction from the current address that uses any of the specified `mnemonics`.'''
        return cls.prevmnemonic(ui.current.address(), mnemonics, 1)
    @utils.multicase(mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), predicate=builtins.callable)
    @classmethod
    def prevmnemonic(cls, mnemonics, predicate, **count):
        '''Return the address of the previous instruction from the current address that uses any of the specified `mnemonics` and satisfies the provided `predicate`.'''
        return cls.prevmnemonic(ui.current.address(), mnemonics, predicate, **count)
    @utils.multicase(mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), count=six.integer_types)
    @classmethod
    def prevmnemonic(cls, mnemonics, count):
        '''Return the address of the previous `count` instructions from the current address that uses any of the specified `mnemonics`.'''
        return cls.prevmnemonic(ui.current.address(), mnemonics, count)
    @utils.multicase(ea=six.integer_types, mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple))
    @classmethod
    def prevmnemonic(cls, ea, mnemonics):
        '''Return the address of the previous instruction from the address `ea` that uses any of the specified `mnemonics`.'''
        return cls.prevmnemonic(ea, mnemonics, 1)
    @utils.multicase(ea=six.integer_types, mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), predicate=builtins.callable)
    @classmethod
    def prevmnemonic(cls, ea, mnemonics, predicate, **count):
        '''Return the address of the previous instruction from the address `ea` that uses any of the specified `mnemonics` and satisfies the provided `predicate`.'''
        items = {mnemonics} if isinstance(mnemonics, six.string_types) else {item for item in mnemonics}
        Fuses_mnemonics = utils.fcompose(_instruction.mnemonic, utils.fpartial(operator.contains, items))
        F = utils.fcompose(utils.fmap(Fuses_mnemonics, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), count=six.integer_types)
    @classmethod
    def prevmnemonic(cls, ea, mnemonics, count):
        '''Return the address of the previous `count` instructions from the address `ea` that uses any of the specified `mnemonics`.'''
        items = {mnemonics} if isinstance(mnemonics, six.string_types) else {item for item in mnemonics}
        Fuses_mnemonics = utils.fcompose(_instruction.mnemonic, utils.fpartial(operator.contains, items))
        return cls.prevF(ea, Fuses_mnemonics, count)

    @utils.multicase(mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple))
    @classmethod
    def nextmnemonic(cls, mnemonics):
        '''Return the address of the next instruction from the current address that uses any of the specified `mnemonics`.'''
        return cls.nextmnemonic(ui.current.address(), mnemonics, 1)
    @utils.multicase(mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), predicate=builtins.callable)
    @classmethod
    def nextmnemonic(cls, mnemonics, predicate, **count):
        '''Return the address of the next instruction from the current address that uses any of the specified `mnemonics` and satisfies the provided `predicate`.'''
        return cls.nextmnemonic(ui.current.address(), mnemonics, predicate, **count)
    @utils.multicase(mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), count=six.integer_types)
    @classmethod
    def nextmnemonic(cls, mnemonics, count):
        '''Return the address of the next `count` instructions from the current address that uses any of the specified `mnemonics`.'''
        return cls.nextmnemonic(ui.current.address(), mnemonics, count)
    @utils.multicase(ea=six.integer_types, mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple))
    @classmethod
    def nextmnemonic(cls, ea, mnemonics):
        '''Return the address of the next instruction from the address `ea` that uses any of the specified `mnemonics`.'''
        return cls.nextmnemonic(ea, mnemonics, 1)
    @utils.multicase(ea=six.integer_types, mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), predicate=builtins.callable)
    @classmethod
    def nextmnemonic(cls, ea, mnemonics, predicate, **count):
        '''Return the address of the next instruction from the address `ea` that uses any of the specified `mnemonics` and satisfies the provided `predicate`.'''
        items = {mnemonics} if isinstance(mnemonics, six.string_types) else {item for item in mnemonics}
        Fuses_mnemonics = utils.fcompose(_instruction.mnemonic, utils.fpartial(operator.contains, items))
        F = utils.fcompose(utils.fmap(Fuses_mnemonics, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, mnemonics=(six.string_types, builtins.list, builtins.set, builtins.tuple), count=six.integer_types)
    @classmethod
    def nextmnemonic(cls, ea, mnemonics, count):
        '''Return the address of the next `count` instructions from the address `ea` that uses any of the specified `mnemonics`.'''
        items = {mnemonics} if isinstance(mnemonics, six.string_types) else {item for item in mnemonics}
        Fuses_mnemonics = utils.fcompose(_instruction.mnemonic, utils.fpartial(operator.contains, items))
        return cls.nextF(ea, Fuses_mnemonics, count)

    @utils.multicase()
    @classmethod
    def prevlabel(cls, **count):
        '''Return the address of the previous label from the current address.'''
        return cls.prevlabel(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevlabel(cls, predicate, **count):
        '''Return the address of the previous label from the current address that satisfies the provided `predicate`.'''
        return cls.prevlabel(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevlabel(cls, ea):
        '''Return the address of the previous label from the address `ea`.'''
        return cls.prevlabel(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevlabel(cls, ea, predicate, **count):
        '''Return the address of the previous label from the address `ea` that satisfies the provided `predicate`.'''
        Flabel = type.has_label
        F = utils.fcompose(utils.fmap(Flabel, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevlabel(cls, ea, count):
        '''Return the address of the previous `count` labels from the address `ea`.'''
        return cls.prevF(ea, type.has_label, count)

    @utils.multicase()
    @classmethod
    def nextlabel(cls, **count):
        '''Return the address of the next label from the current address.'''
        return cls.nextlabel(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextlabel(cls, predicate, **count):
        '''Return the address of the next label from the current address that satisfies the provided `predicate`.'''
        return cls.nextlabel(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextlabel(cls, ea):
        '''Return the address of the next label from the address `ea`.'''
        return cls.nextlabel(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextlabel(cls, ea, predicate, **count):
        '''Return the address of the next label from the address `ea` that satisfies the provided `predicate`.'''
        Flabel = type.has_label
        F = utils.fcompose(utils.fmap(Flabel, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextlabel(cls, ea, count):
        '''Return the address of the next `count` labels from the address `ea`.'''
        return cls.nextF(ea, type.has_label, count)

    @utils.multicase()
    @classmethod
    def prevcomment(cls, **repeatable):
        '''Return the previous address from the current one that has any type of comment.'''
        return cls.prevcomment(ui.current.address(), repeatable.pop('count', 1), **repeatable)
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevcomment(cls, predicate, **repeatable):
        '''Return the previous address from the current one that has any type of comment and satisfies the provided `predicate`.'''
        return cls.prevcomment(ui.current.address(), predicate, **repeatable)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevcomment(cls, ea, **repeatable):
        '''Return the previous address from the address `ea` that has any type of comment.'''
        return cls.prevcomment(ea, repeatable.pop('count', 1), **repeatable)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevcomment(cls, ea, predicate, **repeatable):
        """Return the previous address from the address `ea` that has any type of comment and satisfies the provided `predicate`.

        If the bool `repeatable` is defined, then use it to determine whether to only track repeatable or non-repeatable comments.
        """
        if 'repeatable' in repeatable:
            Fcheck_comment = utils.fcompose(utils.frpartial(idaapi.get_cmt, not repeatable['repeatable']), utils.fpartial(operator.is_, None))
            Fx = utils.fcompose(utils.fmap(type.has_comment, Fcheck_comment), builtins.all)
        else:
            Fx = type.has_comment
        F = utils.fcompose(utils.fmap(Fx, predicate), builtins.all)
        return cls.prevF(ea, F, repeatable.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevcomment(cls, ea, count, **repeatable):
        """Return the previous `count` addresses from the address `ea` that has any type of comment.

        If the bool `repeatable` is defined, then use it to determine whether to only track repeatable or non-repeatable comments.
        """
        if 'repeatable' in repeatable:
            Fcheck_comment = utils.fcompose(utils.frpartial(idaapi.get_cmt, not repeatable['repeatable']), utils.fpartial(operator.is_, None))
            F = utils.fcompose(utils.fmap(type.has_comment, Fcheck_comment), builtins.all)
        else:
            F = type.has_comment
        return cls.prevF(ea, F, count)

    @utils.multicase()
    @classmethod
    def nextcomment(cls, **repeatable):
        '''Return the next address from the current one that has any type of comment.'''
        return cls.nextcomment(ui.current.address(), repeatable.pop('count', 1), **repeatable)
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextcomment(cls, predicate, **repeatable):
        '''Return the next address from the current one that has any type of comment and satisfies the provided `predicate`.'''
        return cls.nextcomment(ui.current.address(), predicate, **repeatable)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextcomment(cls, ea, **repeatable):
        '''Return the next address from the address `ea` that has any type of comment.'''
        return cls.nextcomment(ea, repeatable.pop('count', 1), **repeatable)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextcomment(cls, ea, predicate, **repeatable):
        """Return the next address from the address `ea` that has any type of comment and satisfies the provided `predicate`.

        If the bool `repeatable` is defined, then use it to determine whether to only track repeatable or non-repeatable comments.
        """
        if 'repeatable' in repeatable:
            Fcheck_comment = utils.fcompose(utils.frpartial(idaapi.get_cmt, not repeatable['repeatable']), utils.fpartial(operator.is_, None))
            Fx = utils.fcompose(utils.fmap(type.has_comment, Fcheck_comment), builtins.all)
        else:
            Fx = type.has_comment
        F = utils.fcompose(utils.fmap(Fx, predicate), builtins.all)
        return cls.nextF(ea, F, repeatable.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextcomment(cls, ea, count, **repeatable):
        """Return the next `count` addresses from the address `ea` that has any type of comment.

        If the bool `repeatable` is defined, then use it to determine whether to only track repeatable or non-repeatable comments.
        """
        if 'repeatable' in repeatable:
            Fcheck_comment = utils.fcompose(utils.frpartial(idaapi.get_cmt, not repeatable['repeatable']), utils.fpartial(operator.is_, None))
            F = utils.fcompose(utils.fmap(type.has_comment, Fcheck_comment), builtins.all)
        else:
            F = type.has_comment
        return cls.nextF(ea, F, count)

    # FIXME: We should add the Or= or And= tests to this or we should allow specifying a set of tags.
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def prevtag(cls, **tagname):
        '''Return the previous address that contains a tag using the specified `tagname`.'''
        return cls.prevtag(ui.current.address(), tagname.pop('count', 1), **tagname)
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def prevtag(cls, predicate, **tagname):
        '''Return the previous address that contains a tag using the specified `tagname` and satisfies the provided `predicate`.'''
        return cls.prevtag(ui.current.address(), predicate, **tagname)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def prevtag(cls, ea, **tagname):
        '''Return the previous address from `ea` that contains a tag using the specified `tagname`.'''
        return cls.prevtag(ea, tagname.pop('count', 1), **tagname)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def prevtag(cls, ea, predicate, **tagname):
        '''Return the previous address from `ea` that contains a tag using the specified `tagname` and satisfies the provided `predicate`.'''
        tagname = builtins.next((tagname[kwd] for kwd in ['tagname', 'tag', 'name'] if kwd in tagname), None)
        Ftag = type.has_comment if tagname is None else utils.fcompose(tag, utils.frpartial(operator.contains, tagname))
        F = utils.fcompose(utils.fmap(Ftag, predicate), builtins.all)
        return cls.prevF(ea, F, tagname.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def prevtag(cls, ea, count, **tagname):
        '''Return the previous `count` addresses from `ea` that contains a tag using the specified `tagname`.'''
        tagname = builtins.next((tagname[kwd] for kwd in ['tagname', 'tag', 'name'] if kwd in tagname), None)
        Ftag = type.has_comment if tagname is None else utils.fcompose(tag, utils.frpartial(operator.contains, tagname))
        return cls.prevF(ea, Ftag, count)

    # FIXME: We should add the Or= or And= tests to this or we should allow specifying a set of tags.
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def nexttag(cls, **tagname):
        '''Return the next address that contains a tag using the specified `tagname`.'''
        return cls.nexttag(ui.current.address(), tagname.pop('count', 1), **tagname)
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def nexttag(cls, predicate, **tagname):
        '''Return the next address that contains a tag using the specified `tagname` and satisfies the provided `predicate`.'''
        return cls.nexttag(ui.current.address(), predicate, **tagname)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def nexttag(cls, ea, **tagname):
        '''Return the next address from `ea` that contains a tag using the specified `tagname`.'''
        return cls.nexttag(ea, tagname.pop('count', 1), **tagname)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def nexttag(cls, ea, predicate, **tagname):
        '''Return the next address from `ea` that contains a tag using the specified `tagname` and satisfies the provided `predicate`.'''
        tagname = builtins.next((tagname[kwd] for kwd in ['tagname', 'tag', 'name'] if kwd in tagname), None)
        Ftag = type.has_comment if tagname is None else utils.fcompose(tag, utils.frpartial(operator.contains, tagname))
        F = utils.fcompose(utils.fmap(Ftag, predicate), builtins.all)
        return cls.nextF(ea, F, tagname.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    @utils.string.decorate_arguments('tagname', 'tag', 'name')
    def nexttag(cls, ea, count, **tagname):
        '''Return the next `count` addresses from `ea` that contains a tag using the specified `tagname`.'''
        tagname = builtins.next((tagname[kwd] for kwd in ['tagname', 'tag', 'name'] if kwd in tagname), None)
        Ftag = type.has_comment if tagname is None else utils.fcompose(tag, utils.frpartial(operator.contains, tagname))
        return cls.nextF(ea, Ftag, count)

    @utils.multicase()
    @classmethod
    def prevunknown(cls, **count):
        '''Return the previous address from the current one that is undefined.'''
        return cls.prevunknown(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def prevunknown(cls, predicate, **count):
        '''Return the previous address from the current one that is undefined and satisfies the provided `predicate`.'''
        return cls.prevunknown(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevunknown(cls, ea):
        '''Return the previous address from the address `ea` that is undefined.'''
        return cls.prevunknown(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevunknown(cls, ea, predicate, **count):
        '''Return the previous address from the address `ea` that is undefined and satisfies the provided `predicate`.'''
        F = utils.fcompose(utils.fmap(type.is_unknown, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevunknown(cls, ea, count):
        '''Return the previous `count` addresses from the address `ea` that is undefined.'''
        return cls.prevF(ea, type.is_unknown, count)

    @utils.multicase()
    @classmethod
    def nextunknown(cls, **count):
        '''Return the next address from the current one that is undefined.'''
        return cls.nextunknown(ui.current.address(), count.pop('count', 1))
    @utils.multicase(predicate=builtins.callable)
    @classmethod
    def nextunknown(cls, predicate, **count):
        '''Return the next address from the current one that is undefined and satisfies the provided `predicate`.'''
        return cls.nextunknown(ui.current.address(), predicate, **count)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextunknown(cls, ea):
        '''Return the next address from the address `ea` that is undefined.'''
        return cls.nextunknown(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextunknown(cls, ea, predicate, **count):
        '''Return the next address from the address `ea` that is undefined and satisfies the provided `predicate`.'''
        F = utils.fcompose(utils.fmap(type.is_unknown, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextunknown(cls, ea, count):
        '''Return the next `count` addresses from the address `ea` that is undefined.'''
        return cls.nextF(ea, type.is_unknown, count)

    @utils.multicase()
    @classmethod
    def prevfunction(cls, **count):
        '''Return the previous address from the current address that is within a function.'''
        return cls.prevfunction(ui.current.address(), count.pop('count', 1))
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prevfunction(cls, ea):
        '''Return the previous address from the address `ea` that is within a function.'''
        return cls.prevfunction(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def prevfunction(cls, ea, predicate, **count):
        '''Return the previous address from the address `ea` that is within a function and satisfies the provided `predicate`.'''
        F = utils.fcompose(utils.fmap(function.within, predicate), builtins.all)
        return cls.prevF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def prevfunction(cls, ea, count):
        '''Return the previous `count` addresses from the address `ea` that is within a function.'''
        return cls.prevF(ea, function.within, count)

    @utils.multicase()
    @classmethod
    def nextfunction(cls, **count):
        '''Return the next address from the current address that is within a function.'''
        return cls.nextfunction(ui.current.address(), count.pop('count', 1))
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def nextfunction(cls, ea):
        '''Return the next address from the address `ea` that is within a function.'''
        return cls.nextfunction(ea, 1)
    @utils.multicase(ea=six.integer_types, predicate=builtins.callable)
    @classmethod
    def nextfunction(cls, ea, predicate, **count):
        '''Return the next address from the address `ea` that is within a function and satisfies the provided `predicate`.'''
        F = utils.fcompose(utils.fmap(function.within, predicate), builtins.all)
        return cls.nextF(ea, F, count.pop('count', 1))
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def nextfunction(cls, ea, count):
        '''Return the next `count` addresses from the address `ea` that is within a function.'''
        return cls.nextF(ea, function.within, count)

    prevfunc, nextfunc = utils.alias(prevfunction, 'address'), utils.alias(nextfunction, 'address')

    # address translations
    @classmethod
    def by_offset(cls, offset):
        '''Return the specified `offset` translated to an address in the database.'''
        return config.baseaddress() + offset
    byoffset = utils.alias(by_offset, 'address')

    @utils.multicase()
    @classmethod
    def offset(cls):
        '''Return the current address translated to an offset relative to the base address of the database.'''
        return cls.offset(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def offset(cls, ea):
        '''Return the address `ea` translated to an offset relative to the base address of the database.'''
        return interface.address.inside(ea) - config.baseaddress()
    getoffset = utils.alias(offset, 'address')

    @utils.multicase()
    @classmethod
    def fileoffset(cls):
        '''Return the file offset in the input file for the current address.'''
        return cls.fileoffset(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def fileoffset(cls, ea):
        '''Return the file offset in the input file for the address `ea`.'''
        return idaapi.get_fileregion_offset(ea)

    @utils.multicase(offset=six.integer_types)
    @classmethod
    def by_fileoffset(cls, offset):
        '''Return the address in the database for the specified file `offset` of the input file.'''
        return idaapi.get_fileregion_ea(offset)
    byfileoffset = utils.alias(by_fileoffset, 'address')

a = addr = address  # XXX: ns alias

# address translations
offset = getoffset = get_offset = getOffset = utils.alias(address.offset, 'address')
byoffset = by_offset = byOffset = utils.alias(address.by_offset, 'address')

# datapoint navigation
prev, next = utils.alias(address.prev, 'address'), utils.alias(address.next, 'address')
prevref, nextref = utils.alias(address.prevref, 'address'), utils.alias(address.nextref, 'address')
prevreg, nextreg = utils.alias(address.prevreg, 'address'), utils.alias(address.nextreg, 'address')

class type(object):
    """
    This namespace is for fetching type information from the different
    addresses defined within the database. The functions within this
    namespace allow one to extract various type information from the
    different locations within the database.

    This namespace is also aliased as ``database.t``.

    By default, this namespace will return the ``idaapi.DT_TYPE`` of the
    specified address.

    Some examples of using this namespace can be::

        > print( database.type.size(ea) )
        > print( database.type.is_initialized(ea) )
        > print( database.type.is_data(ea) )
        > length = database.t.array.length(ea)
        > st = database.t.structure(ea)

    """

    @utils.multicase()
    def __new__(cls):
        '''Return the type information for the current address as an ``idaapi.tinfo_t``.'''
        return cls(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    def __new__(cls, ea):
        '''Return the type information for the address `ea` as an ``idaapi.tinfo_t``.'''
        get_tinfo = (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo

        # First try and get the actual typeinfo for the given address. If it
        # actually worked, then we can just return it as-is.
        ti = idaapi.tinfo_t()
        if get_tinfo(ti, ea):
            return ti

        # Otherwise we'll go ahead and guess the typeinfo for the same address.
        res = idaapi.guess_tinfo2(ea, ti) if idaapi.__version__ < 7.0 else idaapi.guess_tinfo(ti, ea)

        # If we failed, then we'll try and hack around it using idaapi.print_type.
        if res != idaapi.GUESS_FUNC_OK:
            fl = idaapi.PRTYPE_1LINE
            info_s = idaapi.print_type(ea, fl)

            # If we still couldn't get the typeinfo, then return None because
            # there isn't any typeinfo associated with the specified address.
            if info_s is None:
                return None

            # Parse the type information string that IDA gave us and return it.
            ti = internal.declaration.parse(info_s)
            if ti is None:
                raise E.InvalidTypeOrValueError(u"{:s}.info({:#x}) : Unable to parse the returned type declaration ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(info_s)))
            return ti
        return ti
    @utils.multicase(none=None.__class__)
    def __new__(cls, none):
        '''Remove the type information from the current address.'''
        return cls(ui.current.address(), None)
    @utils.multicase(info=(six.string_types, idaapi.tinfo_t))
    def __new__(cls, info, **guessed):
        '''Apply the type information in `info` to the current address.'''
        return cls(ui.current.address(), info, **guessed)
    @utils.multicase(ea=six.integer_types, info=idaapi.tinfo_t)
    def __new__(cls, ea, info, **guessed):
        """Apply the ``idaapi.tinfo_t`` in `info` to the address `ea`.

        If `guess` is true, then apply the type information as a guess.
        If `force` is true, then apply the type as-is regardless of its location.
        """
        TINFO_GUESSED, TINFO_DEFINITE = getattr(idaapi, 'TINFO_GUESSED', 0), getattr(idaapi, 'TINFO_DEFINITE', 1)
        info_s = "{!s}".format(info)

        # Check if we're pointing directly at a function, because if we are,
        # then we need to use function.type instead.
        try:
            rt, ea = interface.addressOfRuntimeOrStatic(ea)
            if not rt:
                return function.type(ea, info)

        except E.FunctionNotFoundError:
            pass

        # If we didn't exception, then that means we're pointing at a runtime
        # address. If we are then we need to ensure that our type is a pointer.
        else:
            ti = idaapi.tinfo_t()
            if any([info.is_ptr(), info.is_func()]) or builtins.next((guessed[kwd] for kwd in ['force', 'forced'] if kwd in guessed), False):
                ti, ok = info, True

            # If it's not a pointer then we need to promote it.
            else:
                logging.warning(u"{:s}.info({:#x}, {!s}) : Promoting the given type ({!s}) to a pointer before applying it to the runtime-linked address ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(info_s), utils.string.repr(info_s), ea))
                pi = idaapi.ptr_type_data_t()
                pi.obj_type = info
                ok = ti.create_ptr(pi)

            # If we couldn't promote it to a pointer, then we need to bail so we
            # don't damage anything that the user might not have intended to do.
            if not ok:
                raise E.DisassemblerError(u"{:s}.info({:#x}, {!s}) : Unable to promote type ({!s}) to a pointer for the runtime-linked address ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(info_s), utils.string.repr(info_s), ea))
            info = ti

        # All we need to do is to use idaapi to apply our tinfo_t to the address.
        result, ok = cls(ea), idaapi.apply_tinfo(ea, info, TINFO_DEFINITE)
        if not ok:
            raise E.DisassemblerError(u"{:s}.info({:#x}, {!s}) : Unable to apply typeinfo ({!s}) to the address ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(info_s), utils.string.repr(info_s), ea))

        # TINFO_GUESSED doesn't appear to work, so instead we'll force the option
        # here by clearing the aflag if the user wants to mark this as guessed.
        if builtins.next((guessed[kwd] for kwd in ['guess', 'guessed'] if kwd in guessed), False):
            interface.node.aflags(ea, idaapi.AFL_USERTI, 0)
        return result
    @utils.multicase(none=None.__class__)
    def __new__(cls, ea, none):
        '''Remove the type information from the address `ea`.'''
        del_tinfo = idaapi.del_tinfo2 if idaapi.__version__ < 7.0 else idaapi.del_tinfo

        # Grab the previous typeinfo if there was something there, and coerce
        # it to None if we got an error of some sort.
        try:
            ti = cls(ea)

        except E.DisassemblerError:
            ti = None

        result, _ = ti, del_tinfo(ea)
        return result
    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @utils.string.decorate_arguments('string')
    def __new__(cls, ea, string, **guessed):
        '''Parse the type information in `string` into an ``idaapi.tinfo_t`` and apply it to the address `ea`.'''

        # Check if we're pointing directly at a function, because if we are,
        # then we need to use function.type instead.
        try:
            rt, ea = interface.addressOfRuntimeOrStatic(ea)
            if not rt:
                return function.type(ea, string)

        except E.FunctionNotFoundError:
            pass

        # Now we can just ask IDA to parse this into a tinfo_t for us and then recurse
        # into ourselves. If we received None, then that's pretty much a parsing error.
        ti = internal.declaration.parse(string)
        if ti is None:
            raise E.InvalidTypeOrValueError(u"{:s}.info({:#x}) : Unable to parse the specified type declaration ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(string)))
        return cls(ea, ti, **guessed)

    @utils.multicase()
    @classmethod
    def size(cls):
        '''Return the size of the item at the current address.'''
        return size(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def size(cls, ea):
        '''Return the size of the item at the address `ea`.'''
        ea = interface.address.within(ea)
        return idaapi.get_item_size(ea)

    @utils.multicase()
    @classmethod
    def flags(cls):
        '''Return the flags of the item at the current address.'''
        return cls.flags(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def flags(cls, ea):
        '''Return the flags of the item at the address `ea`.'''
        getflags = idaapi.getFlags if idaapi.__version__ < 7.0 else idaapi.get_full_flags
        return getflags(interface.address.within(ea))
    @utils.multicase(ea=six.integer_types, mask=six.integer_types)
    @classmethod
    def flags(cls, ea, mask):
        '''Return the flags at the address `ea` masked with `mask`.'''
        getflags = idaapi.getFlags if idaapi.__version__ < 7.0 else idaapi.get_full_flags
        return getflags(interface.address.within(ea)) & idaapi.as_uint32(mask)
    @utils.multicase(ea=six.integer_types, mask=six.integer_types, value=six.integer_types)
    @classmethod
    def flags(cls, ea, mask, value):
        '''Sets the flags at the address `ea` masked with `mask` set to `value`.'''
        if idaapi.__version__ < 7.0:
            ea = interface.address.within(ea)
            res = idaapi.getFlags(ea)
            idaapi.setFlags(ea, (res & ~mask) | value)
            return res & mask
        raise E.UnsupportedVersion(u"{:s}.flags({:#x}, {:#x}, {:d}) : IDA 7.0 has unfortunately deprecated `idaapi.setFlags(...)`.".format('.'.join([__name__, cls.__name__]), ea, mask, value))

    @utils.multicase()
    @classmethod
    def is_initialized(cls):
        '''Return if the current address is initialized.'''
        return cls.is_initialized(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_initialized(cls, ea):
        '''Return if the address specified by `ea` is initialized.'''
        return cls.flags(interface.address.within(ea), idaapi.FF_IVL) == idaapi.FF_IVL
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def is_initialized(cls, ea, size):
        '''Return if the address specified by `ea` up to `size` bytes is initialized.'''
        ea = interface.address.within(ea)
        return all(cls.flags(ea + offset, idaapi.FF_IVL) == idaapi.FF_IVL for offset in builtins.range(size))
    initialize = initialized = initializedQ = utils.alias(is_initialized, 'type')

    @utils.multicase()
    @classmethod
    def is_code(cls):
        '''Return if the current address is marked as code.'''
        return cls.is_code(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_code(cls, ea):
        '''Return if the address specified by `ea` is marked as code.'''
        return cls.flags(interface.address.within(ea), idaapi.MS_CLS) == idaapi.FF_CODE
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def is_code(cls, ea, size):
        '''Return if the address specified by `ea` up to `size` bytes is marked as code.'''
        ea = interface.address.within(ea)
        return all(cls.flags(ea + offset, idaapi.MS_CLS) == idaapi.FF_CODE for offset in builtins.range(size))
    code = codeQ = utils.alias(is_code, 'type')

    @utils.multicase()
    @classmethod
    def is_data(cls):
        '''Return if the current address is marked as data.'''
        return cls.is_data(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_data(cls, ea):
        '''Return if the address specified by `ea` is marked as data.'''
        return cls.flags(interface.address.within(ea), idaapi.MS_CLS) == idaapi.FF_DATA
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def is_data(cls, ea, size):
        '''Return if the address specified by `ea` up to `size` bytes is marked as data.'''
        ea = interface.address.within(ea)
        return all(cls.flags(ea + offset, idaapi.MS_CLS) == idaapi.FF_DATA for offset in builtins.range(size))
    data = dataQ = utils.alias(is_data, 'type')

    # True if ea marked unknown
    @utils.multicase()
    @classmethod
    def is_unknown(cls):
        '''Return if the current address is marked as unknown.'''
        return cls.is_unknown(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_unknown(cls, ea):
        '''Return if the address specified by `ea` is marked as unknown.'''
        return cls.flags(interface.address.within(ea), idaapi.MS_CLS) == idaapi.FF_UNK
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def is_unknown(cls, ea, size):
        '''Return if the address specified by `ea` up to `size` bytes is marked as unknown.'''
        ea = interface.address.within(ea)
        return all(cls.flags(ea + offset, idaapi.MS_CLS) == idaapi.FF_UNK for offset in builtins.range(size))
    unknown = unknownQ = is_undefined = undefinedQ = utils.alias(is_unknown, 'type')

    @utils.multicase()
    @classmethod
    def is_head(cls):
        '''Return if the current address is aligned to a definition in the database.'''
        return cls.is_head(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_head(cls, ea):
        '''Return if the address `ea` is aligned to a definition in the database.'''
        return cls.flags(interface.address.within(ea), idaapi.FF_DATA) != 0
    head = headQ = utils.alias(is_head, 'type')

    @utils.multicase()
    @classmethod
    def is_tail(cls):
        '''Return if the current address is not aligned to a definition in the database.'''
        return cls.is_tail(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_tail(cls, ea):
        '''Return if the address `ea` is not aligned to a definition in the database.'''
        return cls.flags(interface.address.within(ea), idaapi.MS_CLS) == idaapi.FF_TAIL
    tail = tailQ = utils.alias(is_tail, 'type')

    @utils.multicase()
    @classmethod
    def is_align(cls):
        '''Return if the current address is defined as an alignment.'''
        return cls.is_align(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_align(cls, ea):
        '''Return if the address at `ea` is defined as an alignment.'''
        is_align = idaapi.isAlign if idaapi.__version__ < 7.0 else idaapi.is_align
        return is_align(cls.flags(ea))
    align = aligned = alignQ = utils.alias(is_align, 'type')

    @utils.multicase()
    @classmethod
    def has_comment(cls):
        '''Return if the current address is commented.'''
        return cls.has_comment(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_comment(cls, ea):
        '''Return if the address at `ea` is commented.'''
        return cls.flags(interface.address.within(ea), idaapi.FF_COMM) == idaapi.FF_COMM
    comment = commented = commentQ = utils.alias(has_comment, 'type')

    @utils.multicase()
    @classmethod
    def has_reference(cls):
        '''Return if the data at the current address is referenced by another address.'''
        return cls.has_reference(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_reference(cls, ea):
        '''Return if the data at the address `ea` is referenced by another address.'''
        return cls.flags(interface.address.within(ea), idaapi.FF_REF) == idaapi.FF_REF
    referenced = referencedQ = is_referenced = utils.alias(has_reference, 'type')

    @utils.multicase()
    @classmethod
    def has_label(cls):
        '''Return if the current address has a label.'''
        return cls.has_label(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_label(cls, ea):
        '''Return if the address at `ea` has a label.'''
        return idaapi.has_any_name(cls.flags(ea)) or cls.has_dummyname(ea) or cls.has_customname(ea)
    label = labeled = labelQ = nameQ = has_name = utils.alias(has_label, 'type')

    @utils.multicase()
    @classmethod
    def has_customname(cls):
        '''Return if the current address has a custom name.'''
        return cls.has_customname(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_customname(cls, ea):
        '''Return if the address at `ea` has a custom name.'''
        return cls.flags(interface.address.within(ea), idaapi.FF_NAME) == idaapi.FF_NAME
    customname = customnamed = customnameQ = utils.alias(has_customname, 'type')

    @utils.multicase()
    @classmethod
    def has_dummyname(cls):
        '''Return if the current address has a dummy name.'''
        return cls.has_dummyname(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_dummyname(cls, ea):
        '''Return if the address at `ea` has a dummy name.'''
        return cls.flags(ea, idaapi.FF_LABL) == idaapi.FF_LABL
    dummyname = dummynamed = dummynameQ = utils.alias(has_dummyname, 'type')

    @utils.multicase()
    @classmethod
    def has_autoname(cls):
        '''Return if the current address was automatically named.'''
        return cls.has_autoname(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_autoname(cls, ea):
        '''Return if the address `ea` was automatically named.'''
        return idaapi.has_auto_name(cls.flags(ea))
    autoname = autonamed = autonameQ = utils.alias(has_autoname, 'type')

    @utils.multicase()
    @classmethod
    def has_publicname(cls):
        '''Return if the current address has a public name.'''
        return cls.has_publicname(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_publicname(cls, ea):
        '''Return if the address at `ea` has a public name.'''
        return idaapi.is_public_name(interface.address.within(ea))
    publicname = publicnamed = publicnameQ = utils.alias(has_publicname, 'type')

    @utils.multicase()
    @classmethod
    def has_weakname(cls):
        '''Return if the current address has a name with a weak type.'''
        return cls.has_weakname(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_weakname(cls, ea):
        '''Return if the address at `ea` has a name with a weak type.'''
        return idaapi.is_weak_name(interface.address.within(ea))
    weakname = weaknamed = weaknameQ = utils.alias(has_weakname, 'type')

    @utils.multicase()
    @classmethod
    def has_listedname(cls):
        '''Return if the current address has a name that is listed.'''
        return cls.has_listedname(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_listedname(cls, ea):
        '''Return if the address at `ea` has a name that is listed.'''
        return idaapi.is_in_nlist(interface.address.within(ea))
    listedname = listednameQ = utils.alias(has_listedname, 'type')

    @utils.multicase()
    @classmethod
    def has_typeinfo(cls):
        '''Return if the current address has any type information associated with it.'''
        return cls.has_typeinfo(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_typeinfo(cls, ea):
        '''Return if the address at `ea` has any type information associated with it.'''
        try:
            ok = cls(ea) is not None

        # If we got an exception raised, then we were unable to parse this type
        # properly. Prior to failing, check to see if the name is a mangled C++
        # symbol that contains type information.
        except E.InvalidTypeOrValueError as e:
            #logging.warning(u"{:s}.has_typeinfo({:#x}) : Unable to interpret the type information at address {:#x}.".format('.'.join([__name__, type.__name__]), ea, ea), exc_info=True)
            realname = name(ea)
            ok = internal.declaration.demangle(realname) != realname
        return ok
    typeinfo = info = typeinfoQ = infoQ = utils.alias(has_typeinfo, 'type')

    @utils.multicase()
    @classmethod
    def is_string(cls):
        '''Return if the current address is defined as a string.'''
        return cls.is_string(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_string(cls, ea):
        '''Return if the address at `ea` is defined as a string.'''
        FF_STRLIT = idaapi.FF_STRLIT if hasattr(idaapi, 'FF_STRLIT') else idaapi.FF_ASCI
        return cls.flags(ea, idaapi.DT_TYPE) == FF_STRLIT
    string = stringQ = utils.alias(is_string, 'type')

    @utils.multicase()
    @classmethod
    def is_structure(cls):
        '''Return if the current address is defined as a structure.'''
        return cls.is_structure(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_structure(cls, ea):
        '''Return if the address at `ea` is defined as a structure.'''
        FF_STRUCT = idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU
        return cls.flags(ea, idaapi.DT_TYPE) == FF_STRUCT
    struct = structure = structQ = structureQ = is_struc = is_struct = utils.alias(is_structure, 'type')

    @utils.multicase()
    @classmethod
    def is_reference(cls):
        '''Return if the current address is referencing another address.'''
        return cls.is_reference(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_reference(cls, ea):
        '''Return if the address at `ea` is referencing another address.'''

        # If it has reference information, then we're good. It's a reference.
        if interface.address.refinfo(ea):
            return True

        # Otherwise, we need to check our downrefs to see if any exist. However,
        # if it's code with codeflow, then we need to exclude the next instruction
        # from our list unless it has the CF_STOP feature applied to it.
        ignored = {address.next(ea)} if cls.is_code(ea) and _instruction.type.feature(ea, idaapi.CF_STOP) != idaapi.CF_STOP else {}
        return any(item not in ignored for item in itertools.chain(xref.code(ea, True), xref.data(ea, True)))
    reference = is_ref = referenceQ = utils.alias(is_reference, 'type')

    @utils.multicase()
    @classmethod
    def has_relocation(cls):
        '''Return if the current address was relocated by a relocation during load.'''
        address, selection = ui.current.address(), ui.current.selection()
        if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.has_relocation(address)
        return cls.has_relocation(selection)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_relocation(cls, ea):
        '''Return if the address at `ea` was relocated by a relocation during load.'''
        return True if internal.interface.address.refinfo(ea) else False
    @utils.multicase(bounds=tuple)
    @classmethod
    def has_relocation(cls, bounds):
        '''Return if an address within the specified `bounds` was relocated by a relocation during load.'''
        return any(internal.interface.address.refinfo(ea) for ea in address.iterate(bounds))
    relocation = relocated = is_relocation = is_relocated = relocationQ = relocatedQ = utils.alias(has_relocation, 'type')

    class array(object):
        """
        This namespace is for returning type information about an array
        that is defined within the database. By default this namespace
        will return the array's element type and its number of elements
        as a list `[size, count]`.

        Some examples of using this namespace can be::

            > type, length = database.t.array()
            > print( database.t.array.size(ea) )
            > print( database.t.array.member(ea) )
            > print( database.t.array.element(ea) )
            > print( database.t.array.length(ea) )

        """
        @utils.multicase()
        def __new__(cls):
            '''Return the `[type, length]` of the array at the current selection or address.'''
            address, selection = ui.current.address(), ui.current.selection()
            if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
                return cls(address)
            return cls(selection)
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea):
            '''Return the `[type, length]` of the array at the address specified by `ea`.'''
            return cls(ea, idaapi.get_item_size(ea))
        @utils.multicase(bounds=tuple)
        def __new__(cls, bounds):
            '''Return the `[type, length]` of the specified `bounds` as an array.'''
            left, right = ea, _ = sorted(bounds)
            return cls(ea, max(0, right - left))
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea, size):
            '''Return the `[type, length]` of the address `ea` if it was an array using the specified `size` (in bytes).'''
            ea = interface.address.head(ea)
            F, ti, cb = type.flags(ea), idaapi.opinfo_t(), abs(size)

            # get the opinfo at the current address to verify if there's a structure or not
            ok = idaapi.get_opinfo(ea, 0, F, ti) if idaapi.__version__ < 7.0 else idaapi.get_opinfo(ti, ea, 0, F)
            tid = ti.tid if ok else idaapi.BADADDR

            # convert it to a pythonic type using the address we were given.
            res = interface.typemap.dissolve(F, tid, cb, offset=min(ea, ea + size))

            # if it's a list, then validate the result and return it
            if isinstance(res, list):
                element, length = res

                # if the address is a string type, then we need to know the prefix size
                # so that we can add it to our length to work around the difference
                # between how these sizes are calc'd in structs versus addresses.
                if isinstance(element, tuple) and len(element) == 3:
                    _, width, extra = element
                    return [element, length - extra // width]

                # simply return the element that we resolved.
                return [element, length]

            # this shouldn't ever happen, but if it does then it's a
            # single element array
            return [res, 1]

        @utils.multicase()
        @classmethod
        def member(cls):
            '''Return the type for the member of the array at the current address.'''
            return cls.member(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def member(cls, ea):
            '''Return the type for the member of the array at the address specified by `ea`.'''
            res, _ = cls(ea)
            return res

        @utils.multicase()
        @classmethod
        def element(cls):
            '''Return the type information for the member of the array defined at the current address.'''
            return cls.element(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def element(cls, ea):
            '''Return the type information for the member of the array defined at the address specified by `ea`.'''
            ti = type(ea)
            if ti is None:
                raise E.MissingTypeOrAttribute(u"{:s}.info({:#x}) : Unable to fetch any type information from the address at {:#x}.".format('.'.join([__name__, 'type', cls.__name__]), ea, ea))
            return ti.get_array_element() if ti.is_array() else ti
        info = typeinfo = utils.alias(element, 'type.array')

        @utils.multicase()
        @classmethod
        def size(cls):
            '''Return the size of a member in the array at the current address.'''
            return cls.size(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def size(cls, ea):
            '''Return the size of a member in the array at the address specified by `ea`.'''
            ea, FF_STRUCT = interface.address.head(ea), idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU
            F, T = type.flags(ea), type.flags(ea, idaapi.DT_TYPE)
            return _structure.size(type.structure.id(ea)) if T == FF_STRUCT else idaapi.get_full_data_elsize(ea, F)

        @utils.multicase()
        @classmethod
        def length(cls):
            '''Return the number of members in the array at the current address.'''
            return cls.length(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def length(cls, ea):
            '''Return the number of members in the array at the address specified by `ea`.'''
            ea = interface.address.head(ea)
            sz, ele = idaapi.get_item_size(ea), idaapi.get_full_data_elsize(ea, type.flags(ea))
            return sz // ele

    class structure(object):
        """
        This namespace for returning type information about a structure
        that is defined within the database. By default this namespace
        will return the ``structure_t`` at the given address.

        Some of the ways to use this namespace are::

            > st = database.t.struct()
            > print( database.t.struct.size() )
            > st = structure.by(database.t.id(ea))

        """
        @utils.multicase()
        def __new__(cls):
            '''Return the structure type at the current address.'''
            return cls(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea):
            '''Return the structure type at address `ea`.'''
            ea = interface.address.head(ea)
            res = cls.id(ea)
            return _structure.by(res, offset=ea)

        @utils.multicase()
        @classmethod
        def id(cls):
            '''Return the identifier of the structure at the current address.'''
            return cls.id(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def id(cls, ea):
            '''Return the identifier of the structure at address `ea`.'''
            ea, FF_STRUCT = interface.address.head(ea), idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU

            res = type.flags(ea, idaapi.DT_TYPE)
            if res != FF_STRUCT:
                raise E.MissingTypeOrAttribute(u"{:s}.id({:#x}) : The type at specified address is not an FF_STRUCT({:#x}) and is instead {:#x}.".format('.'.join([__name__, 'type', cls.__name__]), ea, FF_STRUCT, res))

            ti, F = idaapi.opinfo_t(), type.flags(ea)
            res = idaapi.get_opinfo(ea, 0, F, ti) if idaapi.__version__ < 7.0 else idaapi.get_opinfo(ti, ea, 0, F)
            if not res:
                raise E.DisassemblerError(u"{:s}.id({:#x}) : The call to `idaapi.get_opinfo()` failed at {:#x}.".format('.'.join([__name__, 'type', cls.__name__]), ea, ea))
            return ti.tid

        @utils.multicase()
        @classmethod
        def folded(cls):
            '''Return whether the structure displayed at the current address has been folded into a single line.'''
            return cls.folded(ui.current.address())
        @utils.multicase(terse=bool)
        @classmethod
        def folded(cls, terse):
            '''Modify the way the structure at the current address is displayed as specified by the boolean in `terse`.'''
            return cls.folded(ui.current.address(), terse)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def folded(cls, ea):
            '''Return whether the structure at the address `ea` has been folded into a single line.'''
            return True if interface.node.aflags(ea, idaapi.AFL_TERSESTR) else False
        @utils.multicase(ea=six.integer_types, terse=(six.integer_types, bool))
        @classmethod
        def folded(cls, ea, terse):
            '''Modify the way the structure at the address `ea` is displayed as specified by the boolean in `terse`.'''
            res = interface.node.aflags(ea, idaapi.AFL_TERSESTR)
            interface.node.aflags(ea, idaapi.AFL_TERSESTR, -1 if terse else 0)
            return True if res else False
        @utils.multicase()
        @classmethod
        def fold(cls):
            '''Fold the structure displayed at the current address into a terse format.'''
            return cls.folded(ui.current.address(), True)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def fold(cls, ea):
            '''Fold the structure displayed at the address `ea` into a terse format.'''
            return cls.folded(ea, True)
        @utils.multicase()
        @classmethod
        def unfold(cls):
            '''Fold the structure displayed at the current address into a terse format.'''
            return cls.folded(ui.current.address(), False)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def unfold(cls, ea):
            '''Fold the structure displayed at the address `ea` into a terse format.'''
            return cls.folded(ea, False)
        show, hide = utils.alias(unfold, 'type.structure'), utils.alias(fold, 'type.structure')

        @utils.multicase()
        @classmethod
        def size(cls):
            '''Return the total size of the structure at the current address.'''
            return cls.size(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def size(cls, ea):
            '''Return the total size of the structure at address `ea`.'''
            id = cls.id(ea)
            ptr = idaapi.get_struc(id)
            return idaapi.get_struc_size(ptr)
    struc = struct = structure  # ns alias

    @utils.multicase()
    @classmethod
    def switch(cls):
        '''Return whether the current address is part of a switch_t.'''
        return cls.switch(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def switch(cls, ea):
        '''Return whether the address `ea` is part of a switch_t.'''
        F, get_switch_info = cls.flags(ea), idaapi.get_switch_info_ex if idaapi.__version__ < 7.0 else idaapi.get_switch_info

        # First check if the address is already part of the switch. This
        # is technically the fast path.
        if get_switch_info(ea):
            return True

        # If we're code being referenced by data, then try all their
        # data refs to see if they're part of a table for a switch.
        elif cls.is_code(ea) and cls.is_referenced(ea):
            drefs = (ref for ref in xref.data_up(ea) if not interface.node.is_identifier(ref) and cls.is_data(ref))
            refs = (ref for ref in itertools.chain(*map(xref.data_up, drefs)) if cls.is_code(ref))

        # Otherwise, if we're pointing at data and it's referencing something
        # as well as being referenced, then we need its upward refs to check.
        elif cls.is_data(ea) and cls.has_reference(ea) and cls.is_referenced(ea):
            refs = (ref for ref in xref.data_up(ea) if not interace.node.is_identifier(ref) and cls.is_code(ref))

        # Any other case means that it's code that's referencing an entry
        # into the switch. We can't do any instruction-based logic here, so
        # we literally follow the reference and then look for a dataref to it.
        elif cls.is_code(ea) and cls.is_reference(ea):
            crefs = (ref for ref in xref.code_down(ea))
            drefs = (ref for ref in itertools.chain(*map(xref.data_up, crefs)) if cls.is_data(ref))
            refs = (ref for ref in itertools.chain(*map(xref.data_up, drefs)) if cls.is_code(ref))

        # Anything else, isn't a switch because it doesn't have enough references.
        else:
            refs = ()

        return True if any(get_switch_info(ref) for ref in refs) else False

    @utils.multicase()
    @classmethod
    def is_exception(cls, **flags):
        '''Return if the current selection or address is guarded by an exception or part of an exception handler.'''
        address, selection = ui.current.address(), ui.current.selection()
        if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.is_exception(address, **flags)
        return cls.is_exception(address, **flags)
    @utils.multicase(ea=(six.integer_types, builtins.tuple))
    @classmethod
    def is_exception(cls, ea, **flags):
        """Return if the address or boundaries in `ea` is guarded by an exception or part of an exception handler.

        If `seh` or `cpp` is specified, then include or exclude that exception type.
        If `guarded` or `try` is true, then return if the address is guarded by an exception.
        If `handler` or `catch` is true, then return if the address is part of an exception handler.
        If `fallthrough` is true, then return if the address is part of the fall-through case for a handler.
        If `filter` or `finally` is true, then return if the address is part of an SEH filter or SEH finalizer (respectively).
        """
        if not hasattr(idaapi, 'TBEA_ANY'):
            logging.fatal(u"{:s}.is_exception({:s}{:s}) : Support for interacting with exceptions is not available in your version ({:.1f}) of the IDA Pro disassembler (requires {:.1f}).".format('.'.join([__name__, cls.__name__]), "{:#x}".format(ea) if isinstance(ea, six.integer_types) else ea, u", {:s}".format(utils.string.kwargs(flags)) if flags else '', idaapi.__version__, 7.7))
            return cls.is_exception(ea, 0)

        tryflags = flags.pop('flags', 0) if flags else idaapi.TBEA_ANY

        # pre-assign some keyword args that we will map into actual flags.
        default = {
            'guard': idaapi.TBEA_TRY | idaapi.TBEA_SEHTRY, 'guarded': idaapi.TBEA_TRY | idaapi.TBEA_SEHTRY, 'try': idaapi.TBEA_TRY | idaapi.TBEA_SEHTRY,
            'handler': idaapi.TBEA_CATCH | idaapi.TBEA_SEHFILT, 'catch': idaapi.TBEA_CATCH | idaapi.TBEA_SEHFILT,
            'fall': idaapi.TBEA_FALLTHRU, 'fallthrough': idaapi.TBEA_FALLTHRU, 'fallthru': idaapi.TBEA_FALLTHRU,
        }

        # first comes the c++ keywords which are pretty minimalistic.
        try_kwargs = {
            'guard': idaapi.TBEA_TRY, 'guarded': idaapi.TBEA_TRY, 'try': idaapi.TBEA_TRY,
            'handler': idaapi.TBEA_CATCH, 'catch': idaapi.TBEA_CATCH,
        }

        # now do the same for seh keywords. we do these separately so we can
        # choose to either combine both try/seh or not.
        seh_kwargs = {
            'guard': idaapi.TBEA_SEHTRY, 'guarded': idaapi.TBEA_SEHTRY, 'try': idaapi.TBEA_SEHTRY,
            'filter': idaapi.TBEA_SEHFILT,
            'handler': idaapi.TBEA_CATCH, 'catch': idaapi.TBEA_CATCH,
            'finalizer': idaapi.TBEA_SEHLPAD, 'finally': idaapi.TBEA_SEHLPAD, 'final': idaapi.TBEA_SEHLPAD,
        }

        # and now a union...for the user that wants it all. we default with seh because
        # usually that's the thing people know first when they have no idea what they want.
        indecisive = {k : v for k, v in default.items()}
        [ indecisive.setdefault(k, v) for k, v in itertools.chain(*map(operator.methodcaller('items'), [seh_kwargs, try_kwargs])) ]

        # god i hope that ida doesn't add any more exception types or i might need to
        # wield science and turn this crap into a decision tree...
        try_choices = {flags.pop(key, False) for key in {'c++', 'cpp'} if operator.contains(flags, key)}
        seh_choices = {flags.pop(key, False) for key in {'seh', 'eh'} if operator.contains(flags, key)}

        explicit = try_explicit, seh_explicit = ((any(choices) if choices else None) for choices in [try_choices, seh_choices])
        kwargs = indecisive if all(explicit) else default if all(choices is None for choices in explicit) else [try_kwargs, seh_kwargs][0 if try_explicit else 1]

        # now we iterate through the kwargs and figure out what flags they wanted.
        tryflags, userflags = tryflags, {kw : value for kw, value in flags.items()}
        for key in flags:
            if not any(operator.contains(args, key) for args in [kwargs, default]):
                continue

            choice, value = userflags.pop(key), kwargs.get(key, default.get(key, 0))
            Fchoice = functools.partial(operator.or_, value) if choice else functools.partial(operator.and_, ~value)
            tryflags = idaapi.BADADDR & Fchoice(tryflags)

        # figure out if there were any flags that we couldn't interpret and warn the user about it.
        if userflags:
            leftover = sorted(userflags)
            logging.warning(u"{:s}.is_exception({:s}{:s}) : Ignored {:d} unknown parameter{:s} that {:s} passed as flags ({:s}).".format('.'.join([__name__, cls.__name__]), "{:#x}".format(ea) if isinstance(ea, six.integer_types) else ea, ", {:s}".format(utils.string.kwargs(flags)) if flags else '', len(leftover), '' if len(leftover) == 1 else 's', 'was' if len(leftover) == 1 else 'were', ', '.join(leftover)))

        # now we can get to the actual api.
        return cls.is_exception(ea, tryflags)
    @utils.multicase(ea=six.integer_types, flags=six.integer_types)
    @classmethod
    def is_exception(cls, ea, flags):
        '''Return if the address in `ea` is referenced by an exception matching the specified `flags` (``idaapi.TBEA_*``).'''
        is_ea_tryblks = idaapi.is_ea_tryblks if hasattr(idaapi, 'is_ea_tryblks') else utils.fconstant(False)
        return True if is_ea_tryblks(ea, flags) else False
    @utils.multicase(bounds=builtins.tuple, flags=six.integer_types)
    @classmethod
    def is_exception(cls, bounds, flags):
        '''Return if the given `bounds` is referenced by an exception matching the specified `flags` (``idaapi.TBEA_*``).'''
        return any(cls.is_exception(ea, flags) for ea in address.iterate(bounds))
    exception = has_exception = isexception = hasexception = exceptionQ = utils.alias(is_exception, 'type')

t = type    # XXX: ns alias
size = utils.alias(type.size, 'type')
is_code = utils.alias(type.is_code, 'type')
is_data = utils.alias(type.is_data, 'type')
is_unknown = utils.alias(type.is_unknown, 'type')
is_head = utils.alias(type.is_head, 'type')
is_tail = utils.alias(type.is_tail, 'type')
is_align = utils.alias(type.is_align, 'type')

class types(object):
    """
    This namespace is for interacting with the local types that are
    defined within the database. The functions within this namespace
    can be used to create, query, or fetch the types that have been
    defined.

    When listing the types that are matched, the following legend can be
    used to identify certain characteristics about them:

        `L` - The type originated from a type library
        `I` - The type originated from an inherited type library
        `+` - The type comes from the local type library
        `T` - The type is a type definition and references another type
        `P` - The contents of the type is a pointer
        `F` - The contents of the type is a floating-point value (float, double, long double)
        `E` - The contents of the type is an enumeration
        `I` - The contents of the type is an integral
        `A` - The type represents an array
        `F` - The type represents a function
        `S` - The type represents a structure
        `V` - The type represents a virtual function table
        `C` - The type represents a structure containing a virtual function table
        `U` - The type represents a union
        `?` - The type is currently not defined

    The available types that one can filter the local types with are as follows:

        `ordinal` - Match according to the ordinal of the local type.
        `name` - Match according to the name of the local type.
        `like` - Filter the names of the local types according to a glob.
        `definition` - Filter the local types by applying a glob to their definition.
        `regex` - Filter the local types by applying a regular-expression to their definition.
        `typeref` or `typedef` - Filter the local types for any that are an alias declared with typedef.
        `defined` or `present` - Filter the local types for any that are defined.
        `size` - Filter the local types according to their size.
        `greater` or `ge` - Filter the local types for the ones that are larger or equal to a certain size.
        `gt` - Filter the local types for the ones that are larger than a certain size.
        `less` or `le` - Filter the local types for the ones that are less or equal to a certain size.
        `lt` - Filter the local types for the ones that are less than a certain size.
        `integer` - Filter the local types for any that are integers.
        `pointer` - Filter the local types for any that are pointers.
        `function` - Filter the local types for any that are functions.
        `float` - Filter the local types for any that are floating-point.
        `array` - Filter the local types for any that describe an array.
        `structure` - Filter the local types for any that describe a structure.
        `union` - Filter the local types for any that describe a union.
        `enumeration` - Filter the local types for any that describe an enumeration.
        `predicate` - Filter the types by passing their ordinal and ``idaapi.tinfo_t`` to a callable.

    Some examples of using these keywords are as follows::

        > database.types.list('*::*')
        > iterable = database.types.iterate(definition='*Cookie*')
        > result = database.types.search(regex='.*const.*')
    """

    @utils.multicase(library=idaapi.til_t)
    @classmethod
    def __formatter__(cls, library):
        lcls, description = library.__class__, library.desc
        return "<{:s}; <{:s}>>".format('.'.join([lcls.__module__, lcls.__name__]), utils.string.of(description))
    @utils.multicase(library=idaapi.til_t, ordinal=six.integer_types)
    @classmethod
    def __formatter__(cls, library, ordinal):
        ocls, name = idaapi.tinfo_t, idaapi.get_numbered_type_name(library, ordinal)
        if idaapi.get_type_ordinal(library, name) == ordinal:
            return "<{:s}; #{:d} \"{:s}\">".format('.'.join([lcls.__module__, lcls.__name__]), ordinal, utils.string.of(name))
        count = idaapi.get_ordinal_qty(library)
        if name is None:
            return "<{:s}; #{:s}>".format('.'.join([lcls.__module__, lcls.__name__]), "{:d}".format(ordinal) if 0 < ordinal < count else '???')
        return "<{:s}; #{:s} \"{:s}\">".format('.'.join([lcls.__module__, lcls.__name__]), "{:d}".format(ordinal) if 0 < ordinal < count else '???', name)
    @utils.multicase(library=idaapi.til_t, name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def __formatter__(cls, library, name):
        ocls, ordinal = idaapi.tinfo_t, idaapi.get_type_ordinal(library, utils.string.to(name))
        return "<{:s}; #{:s} \"{:s}\">".format('.'.join([lcls.__module__, lcls.__name__]), "{:d}".format(ordinal) if ordinal else '???', name)

    __matcher__ = utils.matcher()
    __matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), operator.itemgetter(1))
    __matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(1))
    __matcher__.predicate('predicate'), __matcher__.predicate('pred')
    __matcher__.boolean('ordinal', operator.eq, operator.itemgetter(0)), __matcher__.boolean('index', operator.eq, operator.itemgetter(0))
    __matcher__.combinator('definition', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(2), "{!s}".format)
    __matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), operator.itemgetter(2), "{!s}".format)
    __matcher__.mapping('typeref', operator.truth, operator.itemgetter(2), operator.methodcaller('is_typeref'))
    __matcher__.mapping('typedef', operator.truth, operator.itemgetter(2), operator.methodcaller('is_typeref'))
    __matcher__.mapping('defined', operator.truth, operator.itemgetter(2), operator.methodcaller('present')), __matcher__.mapping('present', operator.truth, operator.itemgetter(2), operator.methodcaller('present'))

    __matcher__.mapping('integer', operator.truth, operator.itemgetter(2), operator.methodcaller('is_integral'))
    __matcher__.mapping('pointer', operator.truth, operator.itemgetter(2), operator.methodcaller('is_ptr'))
    __matcher__.mapping('function', operator.truth, operator.itemgetter(2), operator.methodcaller('is_func'))
    __matcher__.mapping('float', operator.truth, operator.itemgetter(2), operator.methodcaller('is_floating'))
    __matcher__.mapping('array', operator.truth, operator.itemgetter(2), operator.methodcaller('is_array'))
    __matcher__.mapping('structure', operator.truth, operator.itemgetter(2), operator.methodcaller('is_struct'))
    __matcher__.mapping('union', operator.truth, operator.itemgetter(2), operator.methodcaller('is_union'))
    __matcher__.mapping('enumeration', operator.truth, operator.itemgetter(2), operator.methodcaller('is_enum'))

    __matcher__.boolean('size', operator.eq, operator.itemgetter(2), operator.methodcaller('get_size'))
    __matcher__.boolean('greater', operator.le, operator.itemgetter(2), operator.methodcaller('get_size')), __matcher__.boolean('ge', operator.le, operator.itemgetter(2), operator.methodcaller('get_size'))
    __matcher__.boolean('gt', operator.lt, operator.itemgetter(2), operator.methodcaller('get_size')),
    __matcher__.boolean('less', operator.ge, operator.itemgetter(2), operator.methodcaller('get_size')), __matcher__.boolean('le', operator.ge, operator.itemgetter(2), operator.methodcaller('get_size'))
    __matcher__.boolean('lt', operator.gt, operator.itemgetter(2), operator.methodcaller('get_size'))

    @utils.multicase()
    @classmethod
    def __iterate__(cls):
        '''Iterates through all of the types in the current type library.'''
        til = idaapi.get_idati()
        return cls.__iterate__(til)
    @utils.multicase(library=idaapi.til_t)
    @classmethod
    def __iterate__(cls, library):
        '''Iterates through all of the types in the specified type `library`.'''
        count, errors = idaapi.get_ordinal_qty(library), {getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('sc_')}
        for ordinal in builtins.range(1, count):
            name, serialized = idaapi.get_numbered_type_name(library, ordinal), idaapi.get_numbered_type(library, ordinal)

            # if we didn't get any information returned, then this ordinal was deleted.
            if serialized is None:
                logging.warning(u"{:s}.__iterate__({:s}) : Skipping the type at the current ordinal ({:d}) due to it having been deleted.".format('.'.join([__name__, cls.__name__]), cls.__formatter__(library), ordinal))
                continue

            # try and create a new type from the serialized information. if we
            # fail at this, then this is a critical error.
            ti = cls.get(ordinal, library)
            if ti is None:
                logging.fatal(u"{:s}.__iterate__({:s}) : Skipping the type at the current ordinal ({:d}) due to an error during deserialization.".format('.'.join([__name__, cls.__name__]), cls.__formatter__(library), ordinal))
                continue

            # if the type is empty, then we can just issue a warning and skip it.
            elif ti.empty():
                logging.warning(u"{:s}.__iterate__({:s}) : Skipping the type at the current ordinal ({:d}) due to it being empty.".format('.'.join([__name__, cls.__name__]), cls.__formatter__(library), ordinal))
                continue

            yield ordinal, utils.string.of(name or ''), ti
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def iterate(cls, string):
        '''Iterate through all of the types in current type library with a glob that matches `string`.'''
        til = idaapi.get_idati()
        return cls.iterate(til, like=string)
    @utils.multicase(string=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('string')
    def iterate(cls, string, library):
        '''Iterate through all of the types in the specified type `library` with a glob that matches `string`.'''
        return cls.iterate(library, like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'type', 'regex')
    def iterate(cls, **type):
        '''Iterate through all of the types in the current type library that match the keyword specified by `type`.'''
        til = idaapi.get_idati()
        return cls.iterate(til, **type)
    @utils.multicase(library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'type', 'regex')
    def iterate(cls, library, **type):
        '''Iterate through all of the types in the specified type `library` that match the keyword specified by `type`.'''
        iterable = cls.__iterate__(library)
        for key, value in (type or {'predicate': utils.fconstant(True)}).items():
            iterable = cls.__matcher__.match(key, value, iterable)
        for ordinal, name, tinfo in iterable:
            res, td = idaapi.tinfo_t(), idaapi.typedef_type_data_t(library, ordinal, True)
            if not res.create_typedef(td):
                logging.warning(u"{:s}.iterate({:s}{:s}) : Unable to create a type that references the ordinal ({:d}).".format('.'.join([__name__, cls.__name__]), cls.__formatter__(library), ", {:s}".format(utils.string.kwargs(type)) if type else '', ordinal))
            yield ordinal, name, res
        return

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def search(cls, string):
        '''Search through all of the type names in the current type library matching the glob `string` and return the first result.'''
        til = idaapi.get_idati()
        return cls.search(til, like=string)
    @utils.multicase(string=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('string')
    def search(cls, string, library):
        '''Search through all of the type names in the specified type `library` matching the glob `string` and return the first result.'''
        return cls.search(library, like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'type', 'regex')
    def search(cls, **type):
        '''Search through all of the types in the current type library that match the keyword specified by `type`.'''
        til = idaapi.get_idati()
        return cls.search(til, **type)
    @utils.multicase(library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'type', 'regex')
    def search(cls, library, **type):
        '''Search through all of the types in the specified type `library` that match the keyword specified by `type`.'''
        query_s = utils.string.kwargs(type)

        listable = [item for item in cls.iterate(library, **type)]
        if len(listable) > 1:
            messages = ((u"[{:d}] {:+#x} {!s}".format(ordinal, ti.get_size() if ti.present() else 0, item)) for ordinal, item, ti in listable)
            [ logging.info(msg) for msg in messages ]
            ordinal, name, _ = listable[0]
            logging.warning(u"{:s}.search({:s}) : Found {:d} matching results. Returning the first type (#{:d}) \"{:s}\".".format('.'.join([__name__, cls.__name__]), query_s, len(listable), ordinal, utils.string.escape("{!s}".format(name), '"')))

        iterable = (ti for ordinal, name, ti in listable)
        res = builtins.next(iterable, None)
        if res is None:
            raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format('.'.join([__name__, cls.__name__]), query_s))
        return res

    @utils.multicase(string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def list(cls, string):
        '''List all of the types in the current type library with a glob that matches `string`.'''
        til = idaapi.get_idati()
        return cls.list(til, like=string)
    @utils.multicase(string=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('string')
    def list(cls, string, library):
        '''List all of the types in the specified type `library` with a glob that matches `string`.'''
        return cls.list(library, like=string)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'type', 'regex')
    def list(cls, **type):
        '''List all of the types in the specified type `library` that match the keyword specified by `type`.'''
        til = idaapi.get_idati()
        return cls.list(til, **type)
    @utils.multicase(library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name', 'like', 'type', 'regex')
    def list(cls, library, **type):
        '''List all of the types in the specified type `library` that match the keyword specified by `type`.'''
        iterable = cls.__iterate__(library)
        for key, value in (type or {'predicate': utils.fconstant(True)}).items():
            iterable = cls.__matcher__.match(key, value, iterable)

        # Set some reasonable defaults for the list of types
        maxordinal = maxname = maxsize = 0

        # Perform the first pass through our listable grabbing all the lengths.
        listable = []
        for ordinal, name, ti in iterable:
            maxordinal = max(ordinal, maxordinal)
            maxname = max(len(name or ''), maxname)
            maxsize = max(ti.get_size(), maxsize)

            #res, td = idaapi.tinfo_t(), idaapi.typedef_type_data_t(library, ordinal, True)
            #if not res.create_typedef(td):
            #    logging.warning(u"{:s}.list({:s}{:s}) : Unable to create a type that references the ordinal ({:d}).".format('.'.join([__name__, cls.__name__]), cls.__formatter__(library), ", {:s}".format(utils.string.kwargs(type)) if type else '', ordinal))
            listable.append((ordinal, name, ti))

        # We just need to calculate the number of digits for the largest and size.
        cordinal = 2 + utils.string.digits(maxordinal, 10)
        csize = 2 + utils.string.digits(maxsize, 16)

        # Lookup table for figuring out some useful flags
        items = [
            ('T', 'is_typeref'),
        ]
        rlookup = [(q, operator.methodcaller(name)) for q, name in items if hasattr(idaapi.tinfo_t, name)]

        items = [
            ('P', 'is_ptr'),
            ('F', 'is_floating'),
            ('E', 'is_enum'),
            ('I', 'is_integral'),
        ]
        ilookup = [(q, operator.methodcaller(name)) for q, name in items if hasattr(idaapi.tinfo_t, name)]

        items = [
            ('A', 'is_array'),
            ('F', 'is_func'),
            ('V', 'is_vftable'),
            ('C', 'has_vftable'),
            ('S', 'is_struct'),
            ('U', 'is_union'),
        ]
        glookup = [(q, operator.methodcaller(name)) for q, name in items if hasattr(idaapi.tinfo_t, name)]

        # Now we can list each type information located within the type library.
        for ordinal, name, ti in listable:

            # Apparently we can't use builtins.next because python is garbage.
            flibrary = '?' if not ti.present() else 'I' if ti.is_from_subtil() else 'L' if not internal.netnode.has(name) else '+' if ti.get_til() else '-'
            items = [q for q, F in rlookup if F(ti)]
            frtype = items[0] if items else '-'
            items = [q for q, F in ilookup if F(ti)]
            fitype = items[0] if items else '-'
            items = [q for q, F in glookup if F(ti)]
            fgtype = items[0] if items else '-'
            flags = itertools.chain(flibrary, frtype, fitype, fgtype)

            # Render the type and clamp it to some arbitrary size.
            # FIXME: is there some way to calculate the width of the console rather than hardcoding 0xa0 here?
            width, description = 0xa0 - sum([cordinal, 1 + csize, maxname]), "{!s}".format(ti)
            clamped_description = description if len(description) < width else "{:s}...".format(description[:width][:-3])

            # That was it, now we can just display it.
            six.print_(u"{:<{:d}s} {:>+#{:d}x} : {:s} : {:<{:d}s} : {:s}".format("[{:d}]".format(ordinal), cordinal, ti.get_size() if ti.present() else 0, 1 + csize, ''.join(flags), name, maxname, clamped_description))
        return

    @utils.multicase(ordinal=six.integer_types)
    @classmethod
    def by(cls, ordinal):
        '''Return the type information that is at the given `ordinal`.'''
        return cls.by_index(ordinal)
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by(cls, name):
        '''Return the type information that has the specified `name`.'''
        return cls.by_name(name)
    @utils.multicase(ordinal=six.integer_types, library=idaapi.til_t)
    @classmethod
    def by(cls, ordinal, library):
        '''Return the type information from the specified `library` that is at the given `ordinal`.'''
        return cls.by_index(ordinal, library)
    @utils.multicase(name=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by(cls, name, library):
        '''Return the type information from the specified `library` that is using the given `name`.'''
        return cls.by_name(name, library)

    @utils.multicase(ordinal=six.integer_types)
    @classmethod
    def has(cls, ordinal):
        '''Return whether the current type library has a type at the given `ordinal`.'''
        til = idaapi.get_idati()
        return cls.has(ordinal, til)
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def has(cls, name):
        '''Return whether the current type library has a type with the specified `name`.'''
        til = idaapi.get_idati()
        return cls.has(name, til)
    @utils.multicase(ordinal=six.integer_types, library=idaapi.til_t)
    @classmethod
    def has(cls, ordinal, library):
        '''Return whether the provided type `library` has a type at the given `ordinal`.'''
        serialized = idaapi.get_numbered_type(library, ordinal)
        return True if serialized else False
    @utils.multicase(name=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def has(cls, name, library):
        '''Return whether the provided type `library` has a type with the specified `name`.'''
        ordinal = idaapi.get_type_ordinal(library, utils.string.to(name))
        return True if ordinal else False

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by_name(cls, name):
        '''Return the type information that has the specified `name`.'''
        til = idaapi.get_idati()
        return cls.by_name(name, til)
    @utils.multicase(name=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by_name(cls, name, library):
        '''Return the type information from the specified `library` that is using the given `name`.'''
        ordinal = idaapi.get_type_ordinal(library, utils.string.to(name))
        if ordinal:
            return cls.by_index(ordinal, library)
        raise E.ItemNotFoundError(u"{:s}.by_name({!r}, {:s}) : No type information was found in the type library with the specified name (\"{:s}\").".format('.'.join([__name__, cls.__name__]), name, cls.__formatter__(library), utils.string.escape(name, '"')))

    @utils.multicase(ordinal=six.integer_types)
    @classmethod
    def by_index(cls, ordinal):
        '''Return the type information that is at the given `ordinal`.'''
        til = idaapi.get_idati()
        return cls.by_index(ordinal, til)
    @utils.multicase(ordinal=six.integer_types, library=idaapi.til_t)
    @classmethod
    def by_index(cls, ordinal, library):
        '''Return the type information from the specified `library` that is at the given `ordinal`.'''
        if not (0 < ordinal < idaapi.get_ordinal_qty(library)):
            raise E.ItemNotFoundError(u"{:s}.by_index({:d}, {:s}) : No type information was found in the type library for the specified ordinal ({:d}).".format('.'.join([__name__, cls.__name__]), ordinal, cls.__formatter__(library), ordinal))

        ti, td = idaapi.tinfo_t(), idaapi.typedef_type_data_t(library, ordinal, True)
        if not ti.create_typedef(td):
            raise E.DisassemblerError(u"{:s}.get({:d}, {:s}) : Unable to create a type that references the specified ordinal ({:d}).".format('.'.join([__name__, cls.__name__]), ordinal, cls.__formatter__(library), ordinal))
        return ti

    @utils.multicase(info=idaapi.tinfo_t)
    @classmethod
    def name(cls, info):
        '''Return the name of the type from the current type library that matches the given type `info`.'''
        til = idaapi.get_idati()
        return cls.name(info, til)
    @utils.multicase(ordinal=six.integer_types)
    @classmethod
    def name(cls, ordinal):
        '''Return the name of the type from the current type library at the specified `ordinal`.'''
        til = idaapi.get_idati()
        return cls.name(ordinal, til)
    @utils.multicase(info=idaapi.tinfo_t, library=idaapi.til_t)
    @classmethod
    def name(cls, info, library):
        '''Return the name of the type from the specified type `library` that matches the given type `info`.'''
        # FIXME: i seriously doubt that this is actually possible
        raise NotImplementedError
    @utils.multicase(ordinal=six.integer_types, library=idaapi.til_t)
    @classmethod
    def name(cls, ordinal, library):
        '''Return the name of the type from the specified type `library` at the given `ordinal`.'''
        res = idaapi.get_numbered_type_name(library, ordinal)
        if res is None:
            raise E.ItemNotFoundError(u"{:s}.name({:d}, {:s}) : Unable to return the name of specified ordinal ({:d}) from the type library.".format('.'.join([__name__, cls.__name__]), ordinal, cls.__formatter__(library), ordinal))

        # FIXME: which one do we return? the mangled or unmangled name?
        return utils.string.of(res)
    @utils.multicase(ordinal=six.integer_types, string=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('string')
    def name(cls, ordinal, string, **mangled):
        '''Set the name of the type at the specified `ordinal` from the current library to `string`.'''
        til = idaapi.get_idati()
        return cls.name(ordinal, string, til, **mangled)
    @utils.multicase(ordinal=six.integer_types, string=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('string')
    def name(cls, ordinal, string, library, **mangled):
        """Set the name of the type at the specified `ordinal` of the given type `library` to `string`.

        If the boolean `mangled` is specified, then the given name is mangled.
        """
        name, ti = cls.name(ordinal, library), cls.get(ordinal, library)
        if ti is None:
            raise E.DisassemblerError(u"{:s}.name({:d}, {!r}, {:s}{:s}) : Unable to get the type information from the given ordinal ({:d}) of the type library.".format('.'.join([__name__, cls.__name__]), ordinal, string, cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', ordinal))

        # now that we saved the type information, we can re-assign the type
        # and change the ordinal's name at the very same tie.
        res = cls.set(ordinal, utils.string.to(string), ti, library, **mangled)
        if ti.serialize() != res.serialize():
            logging.warning(u"{:s}.name({:d}, {!r}, {:s}{:s}) : The type information for the given ordinal ({:d}) applied the type library has changed during the assignment of the new name ({!r}).".format('.'.join([__name__, cls.__name__]), ordinal, string, cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', ordinal, utils.string.of(string)))
        return name

    @utils.multicase(ordinal=six.integer_types)
    @classmethod
    def get(cls, ordinal):
        '''Get the type information at the given `ordinal` of the current type library and return it.'''
        til = idaapi.get_idati()
        return cls.get(ordinal, til)
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def get(cls, name):
        '''Get the type information with the given `name` from the current type library and return it.'''
        til = idaapi.get_idati()
        return cls.get(name, til)
    @utils.multicase(ordinal=six.integer_types, library=idaapi.til_t)
    @classmethod
    def get(cls, ordinal, library):
        '''Get the type information at the given `ordinal` of the specified type `library` and return it.'''
        if 0 < ordinal < idaapi.get_ordinal_qty(library):
            serialized = idaapi.get_numbered_type(library, ordinal)
            if serialized is not None:
                return cls.get(serialized, library)
        raise E.ItemNotFoundError(u"{:s}.get({:d}, {:s}) : No type information was found for the specified ordinal ({:d}) in the type library.".format('.'.join([__name__, cls.__name__]), ordinal, cls.__formatter__(library), ordinal))
    @utils.multicase(name=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def get(cls, name, library):
        '''Get the type information with the given `name` from the specified type `library` and return it.'''
        ordinal = idaapi.get_type_ordinal(library, utils.string.to(name))
        if ordinal:
            return cls.get(ordinal, library)
        raise E.ItemNotFoundError(u"{:s}.get({!r}, {:s}) : No type information with the specified name (\"{:s}\") was found in the type library.".format('.'.join([__name__, cls.__name__]), name, cls.__formatter__(library), utils.string.escape(name, '"')))

    # The following cases for the "types.get" functon are actually a lie and
    # only exist as a way to get an "idaapi.tinfo_t" from any IDAPython API
    # that returns the information in its serialized form.

    @utils.multicase(serialized=builtins.tuple)
    @classmethod
    def get(cls, serialized):
        '''Convert the `serialized` type information from the current type library and return it.'''
        til = idaapi.get_idati()
        return cls.get(serialized, til)
    @utils.multicase(serialized=builtins.tuple, library=idaapi.til_t)
    @classmethod
    def get(cls, serialized, library):
        '''Convert the `serialized` type information from the specified type `library` and return it.'''
        type, fields, cmt, fieldcmts, sclass = itertools.chain(serialized, [b'', getattr(idaapi, 'sc_unk', 0)][len(serialized) - 5:] if len(serialized) < 5 else [])

        # ugh..because ida can return a non-bytes as one of the comments, we
        # need to convert it so that the api will fucking understand us.
        res = cmt or fieldcmts or b''
        comments = res if isinstance(res, b''.__class__) else res.encode('latin1')

        # we need to generate a description so that we can format error messages the user will understand.
        errors = {getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('sc_')}
        names = ['type', 'fields', 'cmt', 'fieldcmts']

        items = itertools.chain(["{:s}={!r}".format(name, item) for name, item in zip(names, serialized) if item], ["{:s}={!s}".format('sclass', sclass)] if len(serialized) == 5 else [])
        description = [item for item in items]

        # try and deserialize the type information. if we succeeded then we
        # can actually return the damned thing.
        ti = idaapi.tinfo_t()
        if ti.deserialize(library, type, fields, comments):
            return ti

        # if we were unable to do that, then we need to log a critical error
        # that's somewhat useful before returning None back to the user.
        logging.fatal(u"{:s}.get({:s}{:s}) : Unable to deserialize the type information for a type using the returned storage class {:s}.".format('.'.join([__name__, cls.__name__]), cls.__formatter__(library), ", {:s}".format(', '.join(description)) if description else '', "{:s}({:d})".format(errors[sclass], sclass) if sclass in errors else "({:d})".format(sclass)))
        return

    @utils.multicase(ordinal=six.integer_types, info=(six.string_types, idaapi.tinfo_t))
    @classmethod
    def set(cls, ordinal, info):
        '''Assign the type information `info` to the type at the specified `ordinal` of the current type library.'''
        til = idaapi.get_idati()
        return cls.set(ordinal, info, til)
    @utils.multicase(ordinal=six.integer_types, name=six.string_types, info=(six.string_types, idaapi.tinfo_t))
    @classmethod
    @utils.string.decorate_arguments('name')
    def set(cls, ordinal, name, info, **mangled):
        '''Assign the type information `info` with the specified `name` to the given `ordinal` of the current type library.'''
        til = idaapi.get_idati()
        return cls.set(ordinal, name, info, til, **mangled)
    @utils.multicase(ordinal=six.integer_types, info=(six.string_types, idaapi.tinfo_t), library=idaapi.til_t)
    @classmethod
    def set(cls, ordinal, info, library):
        '''Assign the type information `info` to the type at the `ordinal` of the specified type `library`.'''
        try:
            # FIXME: do we get the mangled or unmangled name?
            name = cls.name(ordinal, library)

        except Exception:
            # FIXME: if we couldn't find a name, can we create one based on the ordinal number (is_ordinal_name)?
            raise E.MissingNameError(u"{:s}.set({:d}, {!r}, {:s}) : Unable to assign the type information to the specified ordinal ({:d}) because it needs a name and a previous one was not found.".format('.'.join([__name__, cls.__name__]), ordinal, "{!s}".format(info), cls.__formatter__(library), ordinal))
        return cls.set(ordinal, name, info, library)
    @utils.multicase(ordinal=six.integer_types, name=six.string_types, string=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name', 'string')
    def set(cls, ordinal, name, string, library, **mangled):
        '''Assign the type information in `string` with the specified `name` to the specified `ordinal` of the given type `library`.'''
        ti = internal.declaration.parse(string)
        if ti is None:
            raise E.InvalidTypeOrValueError(u"{:s}.set({:d}, {!r}, {!r}, {:s}{:s}) : Unable to parse the specified type declaration ({!s}).".format('.'.join([__name__, cls.__name__]), ordinal, name, string, cls.__formatter__(library), ", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', utils.string.repr(string)))
        return cls.set(ordinal, name, ti, library, **mangled)
    @utils.multicase(ordinal=six.integer_types, name=six.string_types, info=idaapi.tinfo_t, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def set(cls, ordinal, name, info, library, **mangled):
        """Assign the type information `info` with the specified `name` to the given `ordinal` of the type `library`.

        If the boolean `mangled` is specified, then the given name is mangled.
        """
        errors = {getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('TERR_')}

        # first try to get the type information at the given ordinal so that we can return it.
        try:
            ti = cls.get(ordinal, library)
        except Exception:
            ti = None

        # serialize the type information that we're being asked to assign.
        serialized = info.serialize()
        if serialized is None:
            raise E.DisassemblerError(u"{:s}.set({:d}, {!r}, {!r}, {:s}{:s}) : Unable to serialize the given type information to assign to the ordinal ({:d}) of the type library.".format('.'.join([__name__, cls.__name__]), ordinal, name, "{!s}".format(info), cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', ordinal))

        # we aren't given all of the necessary parameters for set_numbered_type,
        # so we assign some defaults so we can actually set it.
        type, fields, fieldcmts = serialized
        cmt, sclass, fieldcmts = b'', idaapi.sc_unk, fieldcmts or b''

        # set the default flags that we're going to use when using set_numbered_type.
        flags = mangled.get('flags', idaapi.NTF_CHKSYNC)
        flags |= idaapi.NTF_SYMM if mangled.get('mangled', False) else idaapi.NTF_SYMU

        # now we need to actually validate the name that we were given. IDA's names
        # handle the first character differently (like an identifier), so we need
        # to check that first before we figure out the rest of them.
        iterable = (item for item in name)
        item = builtins.next(iterable, '_')
        identifier = item if idaapi.is_valid_typename(utils.string.to(item)) else '_'
        identifier+= str().join(item if idaapi.is_valid_typename(identifier + utils.string.to(item)) else '_' for item in iterable)

        # we need to now assign the serialized data we were given, making sure
        # that any of the any of the comments are properly being passed as bytes
        # and then we can check to see if it returned an error.
        res = idaapi.set_numbered_type(library, ordinal, idaapi.NTF_REPLACE | flags, utils.string.to(identifier), type, fields, cmt.decode('latin1') if isinstance(cmt, b''.__class__) else cmt, fieldcmts if isinstance(fieldcmts, b''.__class__) else fieldcmts.encode('latin1'), sclass)
        if res == idaapi.TERR_WRONGNAME:
            raise E.DisassemblerError(u"{:s}.set({:d}, {!r}, {!r}, {:s}) : Unable to set the type information for the ordinal ({:d}) in the type library with the given name ({!r}) due to error {:s}.".format('.'.join([__name__, cls.__name__]), ordinal, name, "{!s}".format(info), cls.__formatter__(library), ordinal, identifier, "{:s}({:d})".format(errors[res], res) if res in errors else "code ({:d})".format(res)))
        elif res != idaapi.TERR_OK:
            raise E.DisassemblerError(u"{:s}.set({:d}, {!r}, {!r}, {:s}) : Unable to set the type information for the ordinal ({:d}) in the specified type library due to error {:s}.".format('.'.join([__name__, cls.__name__]), ordinal, name, "{!s}".format(info), cls.__formatter__(library), ordinal, "{:s}({:d})".format(errors[res], res) if res in errors else "code ({:d})".format(res)))
        return ti

    @utils.multicase(ordinal=six.integer_types)
    @classmethod
    def remove(cls, ordinal):
        '''Remove the type information at the specified `ordinal` of the current type library.'''
        til = idaapi.get_idati()
        return cls.remove(ordinal, til)
    @utils.multicase(ordinal=six.integer_types, library=idaapi.til_t)
    @classmethod
    def remove(cls, ordinal, library):
        '''Remove the type information at the `ordinal` of the specified type `library`.'''
        res = cls.get(ordinal, library)
        if not idaapi.del_numbered_type(library, ordinal):
            raise E.ItemNotFoundError(u"{:s}.remove({:d}, {:s}) : Unable to delete the type information at the specified ordinal ({:d}) of the type library.".format('.'.join([__name__, cls.__name__]), ordinal, cls.__formatter__(library), ordinal))
        return res
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def remove(cls, name, **mangled):
        '''Remove the type information with the specified `name` from the current type library.'''
        til = idaapi.get_idati()
        return cls.remove(name, til, **mangled)
    @utils.multicase(name=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def remove(cls, name, library, **mangled):
        """Remove the type information with the specified `name` from the specified type `library`.

        If the boolean `mangled` is specified, then the given name is mangled.
        """
        res = cls.get(ordinal, library)

        # we need to figure out what flags to use from the keyword parameters.
        flags = mangled.get('flags', 0)
        flags |= idaapi.NTF_SYMM if mangled.get('mangled', False) else idaapi.NTF_SYMU

        # now we can actually try using del_named_type with our given name and flags.
        if not idaapi.del_named_type(library, utils.string.to(name), idaapi.NTF_TYPE | flags):
            raise E.ItemNotFoundError(u"{:s}.remove({!r}, {:s}{:s}) : Unable to delete the type information with the specified name (\"{:s}\") from the type library.".format('.'.join([__name__, cls.__name__]), name, cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', utils.string.escape(name, '"')))
        return res

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def add(cls, name, **mangled):
        '''Add an empty type with the provided `name` to the current type library.'''
        til = idaapi.get_idati()
        return cls.add(name, til, **mangled)
    @utils.multicase(name=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def add(cls, name, library, **mangled):
        '''Add an empty type with the provided `name` to the specified type `library`.'''
        ti = cls.parse(' '.join(['struct', name]))
        return cls.add(name, ti, library, **mangled)
    @utils.multicase(name=six.string_types, info=(six.string_types, idaapi.tinfo_t))
    @classmethod
    @utils.string.decorate_arguments('name')
    def add(cls, name, info, **mangled):
        '''Add the type information in `info` to the current type library using the provided `name`.'''
        til = idaapi.get_idati()
        return cls.add(name, info, til, **mangled)
    @utils.multicase(name=six.string_types, string=six.string_types, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def add(cls, name, string, library, **mangled):
        '''Add the type information in `string` to the specified type `library` using the provided `name`.'''
        ti = internal.declaration.parse(string)
        if ti is None:
            raise E.InvalidTypeOrValueError(u"{:s}.add({!r}, {!r}, {:s}{:s}) : Unable to parse the specified type declaration ({:s}).".format('.'.join([__name__, cls.__name__]), name, string, cls.__formatter__(library), ", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', utils.string.repr(string)))
        return cls.add(name, ti, library, **mangled)
    @utils.multicase(name=six.string_types, info=idaapi.tinfo_t, library=idaapi.til_t)
    @classmethod
    @utils.string.decorate_arguments('name')
    def add(cls, name, info, library, **mangled):
        """Add the type information in `info` to the specified type `library` using the provided `name`.

        If the boolean `mangled` is specified, then the given name is mangled.
        """
        errors = {getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('TERR_')}

        # first we'll try to serialize the type before we make any perma-changes.
        serialized = info.serialize()
        if serialized is None:
            raise E.DisassemblerError(u"{:s}.add({!r}, {!r}, {:s}{:s}) : Unable to serialize the type information that will be added to the type library.".format('.'.join([__name__, cls.__name__]), name, "{!s}".format(info), cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else ''))

        # serialization does not give us all of the parameters required to actually
        # use set_numbered_type, so we assign some defaults to use.
        type, fields, fieldcmts = serialized
        cmt, sclass, fieldcmts = b'', idaapi.sc_unk, fieldcmts or b''

        # now we can allocate a slot for the ordinal within the type library.
        ordinal = idaapi.alloc_type_ordinals(library, 1)
        if not ordinal:
            raise E.DisassemblerError(u"{:s}.add({!r}, {!r}, {:s}{:s}) : Unable to allocate an ordinal within the specified type library.".format('.'.join([__name__, cls.__name__]), name, "{!s}".format(info), cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else ''))

        # set the default flags that we're going to use when using set_numbered_type.
        flags = mangled.get('flags', idaapi.NTF_CHKSYNC | idaapi.NTF_TYPE)
        flags |= idaapi.NTF_SYMM if mangled.get('mangled', False) else idaapi.NTF_SYMU

        # last thing we need to do is correct the name we were given to a valid one
        # since IDA wants these to follow the format (character set) for a general C
        # identifier. so we'll simply do the first character, then finish the rest.
        iterable = (item for item in name)
        item = builtins.next(iterable, '_')
        identifier = item if idaapi.is_valid_typename(utils.string.to(item)) else '_'
        identifier+= str().join(item if idaapi.is_valid_typename(identifier + utils.string.to(item)) else '_' for item in iterable)

        # we can now assign the serialized data that we got, making sure that
        # the comments are properly being passed as bytes before checking for error.
        res = idaapi.set_numbered_type(library, ordinal, flags, utils.string.to(identifier), type, fields, cmt.decode('latin1') if isinstance(cmt, b''.__class__) else cmt, fieldcmts if isinstance(fieldcmts, b''.__class__) else fieldcmts.encode('latin1'), sclass)
        if res == idaapi.TERR_OK:
            return ordinal

        # if we got an error, then we need to delete the ordinal we just added
        # and then we can just raise an exception for the user to deal with.
        if not idaapi.del_numbered_type(library, ordinal):
            logging.fatal(u"{:s}.add({!r}, {!r}, {:s}{:s}) : Unable to delete the recently added ordinal ({:d}) from the specified type library.".format('.'.join([__name__, cls.__name__]), name, info, cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', ordinal))

        # now we can check the error code and fail properly with an exception.
        if res == idaapi.TERR_WRONGNAME:
            raise E.DisassemblerError(u"{:s}.add({!r}, {!r}, {:s}{:s}) : Unable to add the type information to the type library at the allocated ordinal ({:d}) with the given name ({!r}) due to error {:s}.".format('.'.join([__name__, cls.__name__]), name, "{!s}".format(info), cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', ordinal, identifier, "{:s}({:d})".format(errors[res], res) if res in errors else "code ({:d})".format(res)))
        raise E.DisassemblerError(u"{:s}.add({!r}, {!r}, {:s}{:s}) : Unable to add the type information to the type library at the allocated ordinal ({:d}) due to error {:s}.".format('.'.join([__name__, cls.__name__]), name, "{!s}".format(info), cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(mangled)) if mangled else '', ordinal, "{:s}({:d})".format(errors[res], res) if res in errors else "code ({:d})".format(res)))

    @utils.multicase()
    @classmethod
    def count(cls):
        '''Return the number of types that are available in the current type library.'''
        til = idaapi.get_idati()
        return cls.count(til)
    @utils.multicase(library=idaapi.til_t)
    @classmethod
    def count(cls, library):
        '''Return the number of types that are available in the specified type `library`.'''
        return idaapi.get_ordinal_qty(library)

    @utils.multicase(string=six.string_types)
    @classmethod
    def declare(cls, string, **flags):
        '''Parse the given `string` into an ``idaapi.tinfo_t`` using the current type library and return it.'''
        til = idaapi.cvar.idati if idaapi.__version__ < 7.0 else idaapi.get_idati()
        return cls.parse(string, til, **flags)
    @utils.multicase(string=six.string_types, library=idaapi.til_t)
    @classmethod
    def declare(cls, string, library, **flags):
        """Parse the given `string` into an ``idaapi.tinfo_t`` using the specified type `library` and return it.

        If the integer `flags` is provided, then use the specified flags (``idaapi.PT_*``) when parsing the `string`.
        """
        ti, flag = idaapi.tinfo_t(), flags.get('flags', idaapi.PT_SIL | idaapi.PT_TYP)

        # Firstly we need to ';'-terminate the type the user provided in order
        # for IDA's parser to understand it.
        terminated = string if string.endswith(';') else "{:s};".format(string)

        # Ask IDA to parse this into a tinfo_t for us. We default to the silent flag
        # so that we're responsible for handling it if there's a parsing error of
        # some sort. If it succeeds, then we can return our typeinfo otherwise we'll
        # return None to avoid returning a completely invalid type.
        if idaapi.__version__ < 6.9:
            ok, name = idaapi.parse_decl2(library, terminated, None, ti, flag), None
        elif idaapi.__version__ < 7.0:
            ok, name = idaapi.parse_decl2(library, terminated, ti, flag), None
        else:
            name = idaapi.parse_decl(ti, library, terminated, flag)
            ok = name is not None

        # If we couldn't parse the type we were given, then simply bail.
        if not ok:
            raise E.DisassemblerError(u"{:s}.declare({!r}, {:s}{:s}) : Unable to parse the provided string into a valid type.".format('.'.join([__name__, cls.__name__]), string, cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(flags)) if flags else ''))

        # If we were given the idaapi.PT_VAR flag, then we return the parsed name too.
        logging.info(u"{:s}.declare({!r}, {:s}{:s}) : Successfully parsed the given string into a valid type{:s}.".format('.'.join([__name__, cls.__name__]), string, cls.__formatter__(library), u", {:s}".format(utils.string.kwargs(flags)) if flags else '', " ({:s})".format(name) if name else ''))
        return (name, ti) if flag & idaapi.PT_VAR else ti
    parse = decl = utils.alias(declare, 'types')

class xref(object):
    """
    This namespace is for navigating the cross-references (xrefs)
    associated with an address in the database. This lets one identify
    code xrefs from data xrefs and even allows one to add or remove
    xrefs as they see fit.

    This namespace is also aliased as ``database.x``.

    Some of the more common functions are used so often that they're
    also aliased as globals. Some of these are:

        ``database.up`` - Return all addresses that reference an address
        ``database.down`` - Return all addresses that an address references
        ``database.drefs`` - Return all the data references for an address
        ``database.crefs`` - Return all the code references for an address
        ``database.dxup`` - Return all the data references that reference an address
        ``database.dxdown`` - Return all the data references that an address references
        ``database.cxup`` - Return all the code references that reference an address
        ``database.cxdown`` - Return all the code references that an address references

    Some ways to utilize this namespace can be::

        > print( database.x.up() )
        > for ea in database.x.down(): ...
        > for ea in database.x.cu(ea): ...
        > ok = database.x.add_code(ea, target)
        > ok = database.x.rm_data(ea)

    """

    @utils.multicase()
    @staticmethod
    def code():
        '''Return all of the code xrefs that refer to the current address.'''
        return xref.code(ui.current.address(), False)
    @utils.multicase(descend=bool)
    @staticmethod
    def code(descend):
        return xref.code(ui.current.address(), descend)
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def code(ea):
        '''Return all of the code xrefs that refer to the address `ea`.'''
        return xref.code(ea, False)
    @utils.multicase(ea=six.integer_types, descend=bool)
    @staticmethod
    def code(ea, descend):
        """Return all of the code xrefs that refer to the address `ea`.

        If the bool `descend` is defined, then return only code refs that are referred by the specified address.
        """
        if descend:
            start, next = idaapi.get_first_cref_from, idaapi.get_next_cref_from
        else:
            start, next = idaapi.get_first_cref_to, idaapi.get_next_cref_to

        ea = interface.address.inside(ea)
        for addr in interface.xiterate(ea, start, next):
            yield addr
        return
    c = utils.alias(code, 'xref')

    @utils.multicase()
    @staticmethod
    def data():
        '''Return all of the data xrefs that refer to the current address.'''
        return xref.data(ui.current.address(), False)
    @utils.multicase(descend=bool)
    @staticmethod
    def data(descend):
        return xref.data(ui.current.address(), descend)
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def data(ea):
        '''Return all of the data xrefs that refer to the address `ea`.'''
        return xref.data(ea, False)
    @utils.multicase(ea=six.integer_types, descend=bool)
    @staticmethod
    def data(ea, descend):
        """Return all of the data xrefs that refer to the address `ea`.

        If the bool `descend` is defined, then return only the data refs that are referred by the specified address.
        """
        if descend:
            start, next = idaapi.get_first_dref_from, idaapi.get_next_dref_from
        else:
            start, next = idaapi.get_first_dref_to, idaapi.get_next_dref_to

        ea = interface.address.inside(ea)
        for addr in interface.xiterate(ea, start, next):
            yield addr
        return
    d = utils.alias(data, 'xref')

    @utils.multicase()
    @staticmethod
    def data_down():
        '''Return all of the data xrefs that are referenced by the current address.'''
        return xref.data_down(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def data_down(ea):
        '''Return all of the data xrefs that are referenced by the address `ea`.'''
        return sorted(xref.data(ea, True))
    dd = utils.alias(data_down, 'xref')

    @utils.multicase()
    @staticmethod
    def data_up():
        '''Return all of the data xrefs that refer to the current address.'''
        return xref.data_up(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def data_up(ea):
        '''Return all of the data xrefs that refer to the address `ea`.'''
        return sorted(xref.data(ea, False))
    du = utils.alias(data_up, 'xref')

    @utils.multicase()
    @staticmethod
    def code_down():
        '''Return all of the code xrefs that are referenced by the current address.'''
        return xref.code_down(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def code_down(ea):
        '''Return all of the code xrefs that are referenced by the address `ea`.'''
        res = {item for item in xref.code(ea, True)}

        # if we're not pointing at code, then the logic that follows is irrelevant
        if not type.is_code(ea):
            return sorted(res)

        try:
            # try and grab the next instruction which might be referenced
            next_ea = address.next(ea)

            # if the current instruction is a non-"stop" instruction, then it will
            # include a reference to the next instruction. so, we'll remove it.
            if type.is_code(ea) and _instruction.type.feature(ea, idaapi.CF_STOP) != idaapi.CF_STOP:
                res.discard(next_ea)

        except E.OutOfBoundsError:
            pass

        return sorted(res)
    cd = utils.alias(code_down, 'xref')

    @utils.multicase()
    @staticmethod
    def code_up():
        '''Return all of the code xrefs that are referenced by the current address.'''
        return xref.code_up(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def code_up(ea):
        '''Return all of the code xrefs that refer to the address `ea`.'''
        res = {item for item in xref.code(ea, False)}

        # if we're not pointing at code, then the logic that follows is irrelevant
        if not type.is_code(ea):
            return sorted(res)

        try:
            # try and grab the previous instruction which be referenced
            prev_ea = address.prev(ea)

            # if the previous instruction is a non-"stop" instruction, then it will
            # reference the current instruction which is a reason to remove it.
            if type.is_code(prev_ea) and _instruction.type.feature(prev_ea, idaapi.CF_STOP) != idaapi.CF_STOP:
                res.discard(prev_ea)

        except E.OutOfBoundsError:
            pass

        return sorted(res)
    cu = utils.alias(code_up, 'xref')

    @utils.multicase()
    @staticmethod
    def up():
        '''Return all of the references that refer to the current address.'''
        return xref.up(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def up(ea):
        '''Return all of the references that refer to the address `ea`.'''
        code, data = {item for item in xref.code_up(ea)}, {item for item in xref.data_up(ea)}
        return sorted(code | data)
    u = utils.alias(up, 'xref')

    # All locations that are referenced by the specified address
    @utils.multicase()
    @staticmethod
    def down():
        '''Return all of the references that are referred by the current address.'''
        return xref.down(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def down(ea):
        '''Return all of the references that are referred by the address `ea`.'''
        code, data = {item for item in xref.code_down(ea)}, {item for item in xref.data_down(ea)}
        return sorted(code | data)
    d = utils.alias(down, 'xref')

    @utils.multicase(target=six.integer_types)
    @staticmethod
    def add_code(target, **reftype):
        '''Add a code reference from the current address to `target`.'''
        return xref.add_code(ui.current.address(), target, **reftype)
    @utils.multicase(ea=six.integer_types, target=six.integer_types)
    @staticmethod
    def add_code(ea, target, **reftype):
        """Add a code reference from address `ea` to `target`.

        If the reftype `call` is true, then specify this ref as a function call.
        """
        ea, target = interface.address.head(ea, target)

        isCall = builtins.next((reftype[k] for k in ['call', 'is_call', 'isCall', 'iscall', 'callQ'] if k in reftype), None)
        if abs(target - ea) > pow(2, config.bits() // 2):
            flowtype = idaapi.fl_CF if isCall else idaapi.fl_JF
        else:
            flowtype = idaapi.fl_CN if isCall else idaapi.fl_JN
        idaapi.add_cref(ea, target, flowtype | idaapi.XREF_USER)
        return target in xref.code_down(ea)
    ac = utils.alias(add_code, 'xref')

    @utils.multicase(target=six.integer_types)
    @staticmethod
    def add_data(target, **reftype):
        '''Add a data reference from the current address to `target`.'''
        return xref.add_data(ui.current.address(), target, **reftype)
    @utils.multicase(ea=six.integer_types, target=six.integer_types)
    @staticmethod
    def add_data(ea, target, **reftype):
        """Add a data reference from the address `ea` to `target`.

        If the reftype `write` is true, then specify that this ref is writing to the target.
        """
        ea, target = interface.address.head(ea, target)
        isWrite = reftype.get('write', False)
        flowtype = idaapi.dr_W if isWrite else idaapi.dr_R
        idaapi.add_dref(ea, target, flowtype | idaapi.XREF_USER)
        return target in xref.data_down(ea)
    ad = utils.alias(add_data, 'xref')

    @utils.multicase()
    @staticmethod
    def rm_code():
        '''Delete _all_ the code references at the current address.'''
        return xref.rm_code(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def rm_code(ea):
        '''Delete _all_ the code references at `ea`.'''
        ea = interface.address.inside(ea)
        [ idaapi.del_cref(ea, target, 0) for target in xref.code_down(ea) ]
        return False if len(xref.code_down(ea)) > 0 else True
    @utils.multicase(ea=six.integer_types, target=six.integer_types)
    @staticmethod
    def rm_code(ea, target):
        '''Delete any code references at `ea` that point to address `target`.'''
        ea = interface.address.inside(ea)
        idaapi.del_cref(ea, target, 0)
        return target not in xref.code_down(ea)
    rc = utils.alias(rm_code, 'xref')

    @utils.multicase()
    @staticmethod
    def rm_data():
        '''Delete _all_ the data references at the current address.'''
        return xref.rm_data(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def rm_data(ea):
        '''Delete _all_ the data references at `ea`.'''
        ea = interface.address.inside(ea)
        [ idaapi.del_dref(ea, target) for target in xref.data_down(ea) ]
        return False if len(xref.data_down(ea)) > 0 else True
    @utils.multicase(ea=six.integer_types, target=six.integer_types)
    @staticmethod
    def rm_data(ea, target):
        '''Delete any data references at `ea` that point to address `target`.'''
        ea = interface.address.inside(ea)
        idaapi.del_dref(ea, target)
        return target not in xref.data_down(ea)
    rd = utils.alias(rm_data, 'xref')

    @utils.multicase()
    @staticmethod
    def erase():
        '''Clear all references at the current address.'''
        return xref.erase(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @staticmethod
    def erase(ea):
        '''Clear all references at the address `ea`.'''
        ea = interface.address.inside(ea)
        return all(ok for ok in [xref.rm_code(ea), xref.rm_data(ea)])
    rx = utils.alias(rm_data, 'xref')

x = xref    # XXX: ns alias

drefs, crefs = utils.alias(xref.data, 'xref'), utils.alias(xref.code, 'xref')
dxdown, dxup = utils.alias(xref.data_down, 'xref'), utils.alias(xref.data_up, 'xref')
cxdown, cxup = utils.alias(xref.code_down, 'xref'), utils.alias(xref.code_up, 'xref')
up, down = utils.alias(xref.up, 'xref'), utils.alias(xref.down, 'xref')

# create/erase a mark at the specified address in the .idb
class marks(object):
    """
    This namespace is for interacting with the marks table within the
    database. By default, this namespace is capable of yielding the
    `(address, description)` of each mark within the database.

    This allows one to manage the marks. Although it is suggested to
    utilize "tags" as they provide significantly more flexibility.
    Using marks allows for one to use IDA's mark window for quick
    navigation to a mark.

    The functions in this namespace can be used like::

        > for ea, descr in database.marks(): ...
        > database.marks.new('this is my description')
        > database.marks.remove(ea)
        > ea, descr = database.marks.by(ea)

    """
    MAX_SLOT_COUNT = 0x400
    table = {}

    # FIXME: implement a matcher class for this too
    def __new__(cls):
        '''Yields each of the marked positions within the database.'''
        listable = [item for item in cls.iterate()] # make a copy in-case someone is actively modifying it
        for ea, comment in listable:
            yield ea, comment
        return

    @utils.multicase(description=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('description')
    def new(cls, description):
        '''Create a mark at the current address with the given `description`.'''
        return cls.new(ui.current.address(), description)
    @utils.multicase(ea=six.integer_types, description=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('description')
    def new(cls, ea, description, **extra):
        '''Create a mark at the address `ea` with the given `description` and return its index.'''
        ea = interface.address.inside(ea)
        try:
            idx = cls.__find_slotaddress(ea)
            ea, res = cls.by_index(idx)
            logging.warning(u"{:s}.new({:#x}, {!r}{:s}) : Replacing mark {:d} at {:#x} and changing the description from \"{:s}\" to \"{:s}\".".format('.'.join([__name__, cls.__name__]), ea, description, u", {:s}".format(utils.string.kwargs(extra)) if extra else '', idx, ea, utils.string.escape(res, '"'), utils.string.escape(description, '"')))
        except (E.ItemNotFoundError, E.OutOfBoundsError):
            res, idx = None, cls.__free_slotindex()
            logging.info(u"{:s}.new({:#x}, {!r}{:s}) : Creating mark {:d} at {:#x} with the description \"{:s}\".".format('.'.join([__name__, cls.__name__]), ea, description, u", {:s}".format(utils.string.kwargs(extra)) if extra else '', idx, ea, utils.string.escape(description, '"')))
        cls.__set_description(idx, ea, description, **extra)
        return res

    @utils.multicase()
    @classmethod
    def remove(cls):
        '''Remove the mark at the current address.'''
        return cls.remove(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def remove(cls, ea):
        '''Remove the mark at the specified address `ea` returning the previous description.'''
        ea = interface.address.inside(ea)
        idx = cls.__find_slotaddress(ea)
        descr = cls.__get_description(idx)
        cls.__set_description(idx, ea, '')
        logging.warning(u"{:s}.remove({:#x}) : Removed mark {:d} at {:#x} with the description \"{:s}\".".format('.'.join([__name__, cls.__name__]), ea, idx, ea, utils.string.escape(descr, '"')))
        return descr

    @classmethod
    def iterate(cls):
        '''Iterate through all of the marks in the database.'''
        count = 0
        try:
            for idx in builtins.range(cls.MAX_SLOT_COUNT):
                yield cls.by_index(idx)
        except (E.OutOfBoundsError, E.AddressNotFoundError):
            pass
        return

    @classmethod
    def length(cls):
        '''Return the number of marks in the database.'''
        listable = [item for item in cls.iterate()]
        return len(listable)

    @classmethod
    def by_index(cls, index):
        '''Return the `(address, description)` of the mark at the specified `index` in the mark list.'''
        if 0 <= index < cls.MAX_SLOT_COUNT:
            return (cls.__get_slotaddress(index), cls.__get_description(index))
        raise E.IndexOutOfBoundsError(u"{:s}.by_index({:d}) : The specified mark slot index ({:d}) is out of bounds ({:s}).".format('.'.join([__name__, cls.__name__]), index, index, ("{:d} < 0".format(index)) if index < 0 else ("{:d} >= MAX_SLOT_COUNT".format(index))))
    byindex = utils.alias(by_index, 'marks')

    @utils.multicase()
    @classmethod
    def by_address(cls):
        '''Return the mark at the current address.'''
        return cls.by_address(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def by_address(cls, ea):
        '''Return the `(address, description)` of the mark at the given address `ea`.'''
        return cls.by_index(cls.__find_slotaddress(ea))
    by = byaddress = utils.alias(by_address, 'marks')

    ## Internal functions depending on which version of IDA is being used (<7.0)
    if idaapi.__version__ < 7.0:
        @classmethod
        def __location(cls, **attrs):
            '''Return a location_t object with the specified attributes.'''
            res = idaapi.curloc()
            [item for item in itertools.starmap(functools.partial(setattr, res), attrs.items())]
            return res

        @classmethod
        @utils.string.decorate_arguments('description')
        def __set_description(cls, index, ea, description, **extra):
            '''Modify the mark at `index` to point to the address `ea` with the specified `description`.'''
            res = cls.__location(ea=ea, x=extra.get('x', 0), y=extra.get('y', 0), lnnum=extra.get('y', 0))
            title, descr = map(utils.string.to, (description, description))
            res.mark(index, title, descr)
            #raise E.DisassemblerError(u"{:s}.set_description({:d}, {:#x}, {!r}{:s}) : Unable to get slot address for specified index.".format('.'.join([__name__, cls.__name__]), index, ea, description, u", {:s}".format(utils.string.kwargs(extra)) if extra else '')))
            return index

        @classmethod
        def __get_description(cls, index):
            '''Return the description of the mark at the specified `index`.'''
            res = cls.__location().markdesc(index)
            return utils.string.of(res)

        @classmethod
        def __find_slotaddress(cls, ea):
            '''Return the index of the mark at the specified address `ea`.'''
            # FIXME: figure out how to fail if this address isn't found
            res = itertools.islice(itertools.count(), cls.MAX_SLOT_COUNT)
            res, iterable = itertools.tee(map(cls.__get_slotaddress, res))
            try:
                count = len(builtins.list(itertools.takewhile(lambda item: item != ea, res)))
            except:
                raise E.AddressNotFoundError(u"{:s}.find_slotaddress({:#x}) : Unable to find specified slot address.".format('.'.join([__name__, cls.__name__]), ea))
            [item for item in itertools.islice(iterable, count)]
            if builtins.next(iterable) != ea:
                raise E.AddressNotFoundError(u"{:s}.find_slotaddress({:#x}) : Unable to find specified slot address.".format('.'.join([__name__, cls.__name__]), ea))
            return count

        @classmethod
        def __free_slotindex(cls):
            '''Return the index of the next available mark slot.'''
            return cls.length()

        @classmethod
        def __get_slotaddress(cls, index):
            '''Return the address of the mark at the specified `index`.'''
            loc = cls.__location()
            intp = idaapi.int_pointer()
            intp.assign(index)
            res = loc.markedpos(intp)
            if res == idaapi.BADADDR:
                raise E.AddressNotFoundError(u"{:s}.get_slotaddress({:d}) : Unable to get slot address for specified index.".format('.'.join([__name__, cls.__name__]), index))
            return address.head(res)

    ## Internal functions depending on which version of IDA is being used (>= 7.0)
    else:
        @classmethod
        @utils.string.decorate_arguments('description')
        def __set_description(cls, index, ea, description, **extra):
            '''Modify the mark at `index` to point to the address `ea` with the specified `description`.'''
            res = utils.string.to(description)
            idaapi.mark_position(ea, extra.get('lnnum', 0), extra.get('x', 0), extra.get('y', 0), index, res)
            #raise E.AddressNotFoundError(u"{:s}.set_description({:d}, {:#x}, {!r}{:s}) : Unable to get slot address for specified index.".format('.'.join([__name__, cls.__name__]), index, ea, description, u", {:s}".format(utils.string.kwargs(extra)) if extra else ''))
            return index

        @classmethod
        def __get_description(cls, index):
            '''Return the description of the mark at the specified `index`.'''
            res = idaapi.get_mark_comment(index)
            return utils.string.of(res)

        @classmethod
        def __find_slotaddress(cls, ea):
            '''Return the index of the mark at the specified address `ea`.'''
            res = itertools.islice(itertools.count(), cls.MAX_SLOT_COUNT)
            res, iterable = itertools.tee(map(cls.__get_slotaddress, res))
            try:
                count = len(builtins.list(itertools.takewhile(lambda item: item != ea, res)))
            except:
                raise E.AddressNotFoundError(u"{:s}.find_slotaddress({:#x}) : Unable to find specified slot address.".format('.'.join([__name__, cls.__name__]), ea))
            [item for item in itertools.islice(iterable, count)]
            if builtins.next(iterable) != ea:
                raise E.AddressNotFoundError(u"{:s}.find_slotaddress({:#x}) : Unable to find specified slot address.".format('.'.join([__name__, cls.__name__]), ea))
            return count

        @classmethod
        def __free_slotindex(cls):
            '''Return the index of the next available mark slot.'''
            res = builtins.next((i for i in builtins.range(cls.MAX_SLOT_COUNT) if idaapi.get_marked_pos(i) == idaapi.BADADDR), None)
            if res is None:
                raise OverflowError("{:s}.free_slotindex() : No free slots available for mark.".format('.'.join([__name__, 'marks', cls.__name__])))
            return res

        @classmethod
        def __get_slotaddress(cls, index):
            '''Get the address of the mark at index `index`.'''
            res = idaapi.get_marked_pos(index)
            if res == idaapi.BADADDR:
                raise E.AddressNotFoundError(u"{:s}.get_slotaddress({:d}) : Unable to get slot address for specified index.".format('.'.join([__name__, cls.__name__]), index))
            return address.head(res)

@utils.multicase()
def mark():
    '''Return the mark at the current address.'''
    _, res = marks.by_address(ui.current.address())
    return res
@utils.multicase(none=None.__class__)
def mark(none):
    '''Remove the mark at the current address.'''
    return mark(ui.current.address(), None)
@utils.multicase(ea=six.integer_types)
def mark(ea):
    '''Return the mark at the specified address `ea`.'''
    _, res = marks.by_address(ea)
    return res
@utils.multicase(description=six.string_types)
@utils.string.decorate_arguments('description')
def mark(description):
    '''Set the mark at the current address to the specified `description`.'''
    return mark(ui.current.address(), description)
@utils.multicase(ea=six.integer_types, none=None.__class__)
def mark(ea, none):
    '''Erase the mark at address `ea`.'''
    try:
        tag(ea, 'mark', None)
    except E.MissingTagError:
        pass
    color(ea, None)
    return marks.remove(ea)
@utils.multicase(ea=six.integer_types, description=six.string_types)
@utils.string.decorate_arguments('description')
def mark(ea, description):
    '''Sets the mark at address `ea` to the specified `description`.'''
    return marks.new(ea, description)

class extra(object):
    r"""
    This namespace is for interacting with IDA's "extra" comments that
    can be associated with an address. This allows one to prefix or
    suffix an address with a large block of text simulating a
    multilined or paragraph comment.

    To add extra comments, one can do this like::

        > res = database.ex.prefix(ea, 'this\nis\na\nmultilined\ncomment')
        > res = database.ex.suffix(ea, "whee\nok...i'm over it.")
        > database.ex.insert(ea, 1)
        > database.extra.append(ea, 2)

    """

    MAX_ITEM_LINES = 5000   # defined in cfg/ida.cfg according to python/idc.py
    MAX_ITEM_LINES = (idaapi.E_NEXT-idaapi.E_PREV) if idaapi.E_NEXT > idaapi.E_PREV else idaapi.E_PREV-idaapi.E_NEXT

    @classmethod
    def __has_extra__(cls, ea, base):
        sup, Fnetnode = internal.netnode.sup, getattr(idaapi, 'ea2node', utils.fidentity)
        return sup.get(Fnetnode(ea), base, type=memoryview) is not None

    @utils.multicase()
    @classmethod
    def has_prefix(cls):
        '''Return true if there are any extra comments that prefix the item at the current address.'''
        return cls.__has_extra__(ui.current.address(), idaapi.E_PREV)
    @utils.multicase()
    @classmethod
    def has_suffix(cls):
        '''Return true if there are any extra comments that suffix the item at the current address.'''
        return cls.__has_extra__(ui.current.address(), idaapi.E_NEXT)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_prefix(cls, ea):
        '''Return true if there are any extra comments that prefix the item at the address `ea`.'''
        return cls.__has_extra__(ea, idaapi.E_PREV)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def has_suffix(cls, ea):
        '''Return true if there are any extra comments that suffix the item at the address `ea`.'''
        return cls.__has_extra__(ea, idaapi.E_NEXT)
    prefixQ, suffixQ = utils.alias(has_prefix, 'extra'), utils.alias(has_suffix, 'extra')

    @classmethod
    def __count__(cls, ea, base):
        sup, Fnetnode = internal.netnode.sup, getattr(idaapi, 'ea2node', utils.fidentity)
        for i in builtins.range(cls.MAX_ITEM_LINES):
            row = sup.get(Fnetnode(ea), base + i, type=memoryview)
            if row is None: break
        return i or None

    if idaapi.__version__ < 7.0:
        @classmethod
        def __hide__(cls, ea):
            '''Hide the extra comments at the address `ea`.'''
            if type.flags(ea, idaapi.FF_LINE) == idaapi.FF_LINE:
                type.flags(ea, idaapi.FF_LINE, 0)
                return True
            return False

        @classmethod
        def __show__(cls, ea):
            '''Show the extra comments at the address `ea`.'''
            if type.flags(ea, idaapi.FF_LINE) != idaapi.FF_LINE:
                type.flags(ea, idaapi.FF_LINE, idaapi.FF_LINE)  # FIXME: IDA 7.0 : ida_nalt.set_visible_item?
                return True
            return False

        @classmethod
        def __get__(cls, ea, base):
            '''Fetch the extra comments from the address `ea` that are specified by the index in `base`.'''
            sup, Fnetnode = internal.netnode.sup, getattr(idaapi, 'ea2node', utils.fidentity)

            # count the number of rows
            count = cls.__count__(ea, base)
            if count is None: return None

            # now we can fetch them
            res = (sup.get(Fnetnode(ea), base + i, type=b''.__class__) for i in builtins.range(count))

            # remove the null-terminator if there is one
            res = (row.rstrip(b'\0') for row in res)

            # fetch them from IDA and join them with newlines
            return '\n'.join(map(utils.string.of, res))
        @classmethod
        @utils.string.decorate_arguments('string')
        def __set__(cls, ea, string, base):
            '''Set the newline-delimited `string` as the extra comments for the address `ea` at the index specified by `base`.'''
            cls.__hide__(ea)
            sup, Fnetnode = internal.netnode.sup, getattr(idaapi, 'ea2node', utils.fidentity)

            # break the string up into rows, and encode each type for IDA
            res = [ utils.string.to(item) for item in string.split('\n') ]

            # assign them directly into IDA
            [ sup.set(Fnetnode(ea), base + i, row + b'\0') for i, row in enumerate(res) ]

            # now we can show (refresh) them
            cls.__show__(ea)

            # an exception before this happens would imply failure
            return True
        @classmethod
        def __delete__(cls, ea, base):
            '''Remove the extra comments from the address `ea` that start at the index in `base`.'''
            sup, Fnetnode = internal.netnode.sup, getattr(idaapi, 'ea2node', utils.fidentity)

            # count the number of rows to remove
            count = cls.__count__(ea, base)
            if count is None: return False

            # hide them before we modify it
            cls.__hide__(ea)

            # now we can remove them
            [ sup.remove(Fnetnode(ea), base + i) for i in builtins.range(count) ]

            # and then show (refresh) it
            cls.__show__(ea)
            return True
    else:
        @classmethod
        def __get__(cls, ea, base):
            '''Fetch the extra comments from the address `ea` that are specified by the index in `base`.'''
            # count the number of rows
            count = cls.__count__(ea, base)
            if count is None: return None

            # grab the extra comments from the database
            iterable = (idaapi.get_extra_cmt(ea, base + i) or '' for i in builtins.range(count))

            # convert them back into Python and join them with a newline
            iterable = (utils.string.of(item) for item in iterable)
            return '\n'.join(iterable)
        @classmethod
        @utils.string.decorate_arguments('string')
        def __set__(cls, ea, string, base):
            '''Set the newline-delimited `string` as the extra comments for the address `ea` at the index specified by `base`.'''
            # break the string up into rows, and encode each type for IDA
            iterable = (utils.string.to(item) for item in string.split('\n'))

            # assign them into IDA using its api
            [ idaapi.update_extra_cmt(ea, base + i, row) for i, row in enumerate(iterable) ]

            # return how many newlines there were
            return string.count('\n')
        @classmethod
        def __delete__(cls, ea, base):
            '''Remove the extra comments from the address `ea` that start at the index in `base`.'''

            # count the number of extra comments to remove
            res = cls.__count__(ea, base)
            if res is None: return 0

            # now we can delete them using the api
            [idaapi.del_extra_cmt(ea, base + i) for i in builtins.range(res)]

            # return how many comments we deleted
            return res

    @utils.multicase(ea=six.integer_types)
    @classmethod
    def __get_prefix__(cls, ea):
        '''Return the prefixed comment at address `ea`.'''
        return cls.__get__(ea, idaapi.E_PREV)

    @utils.multicase(ea=six.integer_types)
    @classmethod
    def __get_suffix__(cls, ea):
        '''Return the suffixed comment at address `ea`.'''
        return cls.__get__(ea, idaapi.E_NEXT)

    @utils.multicase(ea=six.integer_types)
    @classmethod
    def __delete_prefix__(cls, ea):
        '''Delete the prefixed comment at address `ea`.'''
        res = cls.__get__(ea, idaapi.E_PREV)
        cls.__delete__(ea, idaapi.E_PREV)
        return res
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def __delete_suffix__(cls, ea):
        '''Delete the suffixed comment at address `ea`.'''
        res = cls.__get__(ea, idaapi.E_NEXT)
        cls.__delete__(ea, idaapi.E_NEXT)
        return res

    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @classmethod
    def __set_prefix__(cls, ea, string):
        '''Set the prefixed comment at address `ea` to the specified `string`.'''
        res, ok = cls.__delete_prefix__(ea), cls.__set__(ea, string, idaapi.E_PREV)
        ok = cls.__set__(ea, string, idaapi.E_PREV)
        return res
    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @classmethod
    def __set_suffix__(cls, ea, string):
        '''Set the suffixed comment at address `ea` to the specified `string`.'''
        res, ok = cls.__delete_suffix__(ea), cls.__set__(ea, string, idaapi.E_NEXT)
        return res

    @utils.multicase()
    @classmethod
    def __get_prefix__(cls):
        '''Return the prefixed comment at the current address.'''
        return cls.__get_prefix__(ui.current.address())
    @utils.multicase()
    @classmethod
    def __get_suffix__(cls):
        '''Return the suffixed comment at the current address.'''
        return cls.__get_suffix__(ui.current.address())
    @utils.multicase()
    @classmethod
    def __delete_prefix__(cls):
        '''Delete the prefixed comment at the current address.'''
        return cls.__delete_prefix__(ui.current.address())
    @utils.multicase()
    @classmethod
    def __delete_suffix__(cls):
        '''Delete the suffixed comment at the current address.'''
        return cls.__delete_suffix__(ui.current.address())
    @utils.multicase(string=six.string_types)
    @classmethod
    def __set_prefix__(cls, string):
        '''Set the prefixed comment at the current address to the specified `string`.'''
        return cls.__set_prefix__(ui.current.address(), string)
    @utils.multicase(string=six.string_types)
    @classmethod
    def __set_suffix__(cls, string):
        '''Set the suffixed comment at the current address to the specified `string`.'''
        return cls.__set_suffix__(ui.current.address(), string)

    @utils.multicase()
    @classmethod
    def prefix(cls):
        '''Return the prefixed comment at the current address.'''
        return cls.__get_prefix__(ui.current.address())
    @utils.multicase(string=six.string_types)
    @classmethod
    def prefix(cls, string):
        '''Set the prefixed comment at the current address to the specified `string`.'''
        return cls.__set_prefix__(ui.current.address(), string)
    @utils.multicase(none=None.__class__)
    @classmethod
    def prefix(cls, none):
        '''Delete the prefixed comment at the current address.'''
        return cls.__delete_prefix__(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def prefix(cls, ea):
        '''Return the prefixed comment at address `ea`.'''
        return cls.__get_prefix__(ea)
    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @classmethod
    def prefix(cls, ea, string):
        '''Set the prefixed comment at address `ea` to the specified `string`.'''
        return cls.__set_prefix__(ea, string)
    @utils.multicase(ea=six.integer_types, none=None.__class__)
    @classmethod
    def prefix(cls, ea, none):
        '''Delete the prefixed comment at address `ea`.'''
        return cls.__delete_prefix__(ea)

    @utils.multicase()
    @classmethod
    def suffix(cls):
        '''Return the suffixed comment at the current address.'''
        return cls.__get_suffix__(ui.current.address())
    @utils.multicase(string=six.string_types)
    @classmethod
    def suffix(cls, string):
        '''Set the suffixed comment at the current address to the specified `string`.'''
        return cls.__set_suffix__(ui.current.address(), string)
    @utils.multicase(none=None.__class__)
    @classmethod
    def suffix(cls, none):
        '''Delete the suffixed comment at the current address.'''
        return cls.__delete_suffix__(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def suffix(cls, ea):
        '''Return the suffixed comment at address `ea`.'''
        return cls.__get_suffix__(ea)
    @utils.multicase(ea=six.integer_types, string=six.string_types)
    @classmethod
    def suffix(cls, ea, string):
        '''Set the suffixed comment at address `ea` to the specified `string`.'''
        return cls.__set_suffix__(ea, string)
    @utils.multicase(ea=six.integer_types, none=None.__class__)
    @classmethod
    def suffix(cls, ea, none):
        '''Delete the suffixed comment at address `ea`.'''
        return cls.__delete_suffix__(ea)

    @classmethod
    def __insert_space(cls, ea, count, getter_setter_remover):
        getter, setter, remover = getter_setter_remover

        res = getter(ea)
        lstripped, nl = ('', 0) if res is None else (res.lstrip('\n'), len(res) - len(res.lstrip('\n')) + 1)
        return setter(ea, '\n'*(nl + count - 1) + lstripped) if nl + count > 0 or lstripped else remover(ea)
    @classmethod
    def __append_space(cls, ea, count, getter_setter_remover):
        getter, setter, remover = getter_setter_remover

        res = getter(ea)
        rstripped, nl = ('', 0) if res is None else (res.rstrip('\n'), len(res) - len(res.rstrip('\n')) + 1)
        return setter(ea, rstripped + '\n'*(nl + count - 1)) if nl + count > 0 or rstripped else remover(ea)

    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def preinsert(cls, ea, count):
        '''Insert `count` lines in front of the item at address `ea`.'''
        res = cls.__get_prefix__, cls.__set_prefix__, cls.__delete_prefix__
        return cls.__insert_space(ea, count, res)
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def preappend(cls, ea, count):
        '''Append `count` lines in front of the item at address `ea`.'''
        res = cls.__get_prefix__, cls.__set_prefix__, cls.__delete_prefix__
        return cls.__append_space(ea, count, res)

    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def postinsert(cls, ea, count):
        '''Insert `count` lines after the item at address `ea`.'''
        res = cls.__get_suffix__, cls.__set_suffix__, cls.__delete_suffix__
        return cls.__insert_space(ea, count, res)
    @utils.multicase(ea=six.integer_types, count=six.integer_types)
    @classmethod
    def postappend(cls, ea, count):
        '''Append `count` lines after the item at address `ea`.'''
        res = cls.__get_suffix__, cls.__set_suffix__, cls.__delete_suffix__
        return cls.__append_space(ea, count, res)

    @utils.multicase(count=six.integer_types)
    @classmethod
    def preinsert(cls, count):
        '''Insert `count` lines in front of the item at the current address.'''
        return cls.preinsert(ui.current.address(), count)
    @utils.multicase(count=six.integer_types)
    @classmethod
    def preappend(cls, count):
        '''Append `count` lines in front of the item at the current address.'''
        return cls.preappend(ui.current.address(), count)

    @utils.multicase(count=six.integer_types)
    @classmethod
    def postinsert(cls, count):
        '''Insert `count` lines after the item at the current address.'''
        return cls.postinsert(ui.current.address(), count)
    @utils.multicase(count=six.integer_types)
    @classmethod
    def postappend(cls, count):
        '''Append `count` lines after the item at the current address.'''
        return cls.postappend(ui.current.address(), count)

    insert, append = utils.alias(preinsert, 'extra'), utils.alias(preappend, 'extra')
ex = extra  # XXX: ns alias

class set(object):
    """
    This namespace for setting the type of an address within the
    database. This allows one to apply a particular type to a given
    address. This allows one to specify whether a type is a string,
    undefined, code, data, an array, or even a structure.

    This can be used as in the following examples::

        > database.set.unknown(ea)
        > database.set.aligned(ea, alignment=0x10)
        > database.set.string(ea)
        > database.set.structure(ea, structure.by('mystructure'))

    """
    @utils.multicase(info=(six.string_types, idaapi.tinfo_t))
    def __new__(cls, info):
        '''Set the type information at the current address to `info`.'''
        return type(ui.current.address(), info)
    @utils.multicase(ea=six.integer_types, info=(six.string_types, idaapi.tinfo_t))
    def __new__(cls, ea, info):
        '''Set the type information at the address `ea` to `info`.'''
        # FIXME: instead of just setting the type, we need to use the type
        #        to actually modify the data at the specified address.
        return type(ea, info)
    info = typeinfo = utils.alias(__new__, 'set')

    @utils.multicase()
    @classmethod
    def unknown(cls):
        '''Set the data at the current selection or address to undefined.'''
        selection = ui.current.selection()
        if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.unknown(ui.current.address())
        start, stop = selection
        return cls.unknown(start, address.next(stop) - start)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def unknown(cls, ea):
        '''Set the data at address `ea` to undefined.'''
        size = idaapi.get_item_size(ea)
        if idaapi.__version__ < 7.0:
            ok = idaapi.do_unknown_range(ea, size, idaapi.DOUNK_SIMPLE)
        else:
            ok = idaapi.del_items(ea, idaapi.DELIT_SIMPLE, size)
        return size if ok and type.is_unknown(ea, size) else idaapi.get_item_size(ea) if type.is_unknown(ea) else 0
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def unknown(cls, ea, size):
        '''Set the data at address `ea` to undefined.'''
        if idaapi.__version__ < 7.0:
            ok = idaapi.do_unknown_range(ea, size, idaapi.DOUNK_SIMPLE)
        else:
            ok = idaapi.del_items(ea, idaapi.DELIT_SIMPLE, size)
        return size if ok and type.is_unknown(ea, size) else idaapi.get_item_size(ea) if type.is_unknown(ea) else 0
    undef = undefine = undefined = utils.alias(unknown, 'set')

    @utils.multicase()
    @classmethod
    def code(cls):
        '''Set the data at the current address to code.'''
        return cls.code(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def code(cls, ea):
        '''Set the data at address `ea` to code.'''
        if idaapi.__version__ < 7.0:
            return idaapi.create_insn(ea)

        res = idaapi.insn_t()
        try:
            return idaapi.create_insn(ea, res)
        except TypeError:
            pass
        return idaapi.create_insn(res, ea)

    @utils.multicase(size=six.integer_types)
    @classmethod
    def data(cls, size, **type):
        '''Set the data at the current address to have the specified `size` and `type`.'''
        return cls.data(ui.current.address(), size, **type)
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def data(cls, ea, size, **type):
        """Set the data at address `ea` to have the specified `size` and `type`.

        If `type` is not specified, then choose the correct type based on the size.
        """

        ## Set some constants for anything older than IDA 7.0
        if idaapi.__version__ < 7.0:
            FF_STRUCT = idaapi.FF_STRU

            # Try and fetch some attributes..if we're unable to then we use None
            # as a placeholder so that we know that we need to use the older way
            # that IDA applies structures or alignment
            create_data, create_struct, create_align = idaapi.do_data_ex, getattr(idaapi, 'doStruct', None), getattr(idaapi, 'doAlign', None)

            lookup = {
                1 : idaapi.FF_BYTE, 2 : idaapi.FF_WORD, 4 : idaapi.FF_DWRD,
                8 : idaapi.FF_QWRD
            }

            # Older versions of IDA might not define FF_OWRD, so we just
            # try and add if its available. We fall back to an array anyways.
            if hasattr(idaapi, 'FF_OWRD'): lookup[16] = idaapi.FF_OWRD

        ## Set some constants used for IDA 7.0 and newer
        else:
            FF_STRUCT = idaapi.FF_STRUCT
            create_data, create_struct, create_align = idaapi.create_data, idaapi.create_struct, idaapi.create_align

            lookup = {
                1 : idaapi.FF_BYTE, 2 : idaapi.FF_WORD, 4 : idaapi.FF_DWORD,
                8 : idaapi.FF_QWORD, 16 : idaapi.FF_OWORD
            }

        ## Now we can apply the type to the given address
        try:
            res = type['type'] if 'type' in type else lookup[size]

        # If the size doesn't exist, then let the user know that we don't know what to do
        except KeyError:
            raise E.InvalidTypeOrValueError("{:s}.data({:#x}, {:d}{:s}) : Unable to determine the correct type for the specified size ({:+d}) to assign to the data.".format('.'.join([__name__, cls.__name__]), ea, size, u", {:s}".format(utils.string.kwargs(type)) if type else '', size))

        # Check if we need to use older IDA logic by checking of any of our api calls are None
        if idaapi.__version__ < 7.0 and any(f is None for f in [create_struct, create_align]):
            ok = create_data(ea, idaapi.FF_STRUCT if isinstance(res, _structure.structure_t) else res, size, res.id if isinstance(res, _structure.structure_t) else 0)

        # Otherwise we can create structures normally
        elif isinstance(res, (_structure.structure_t, idaapi.struc_t)):
            ok = create_struct(ea, size, res.id)

        # Or apply alignment properly...
        elif res == idaapi.FF_ALIGN and hasattr(idaapi, 'create_align'):
            ok = create_align(ea, size, 0)

        # Anything else is just regular data that we can fall back to
        else:
            ok = idaapi.create_data(ea, res, size, 0)

        # Return our new size if we were successful
        return idaapi.get_item_size(ea) if ok else 0

    @utils.multicase()
    @classmethod
    def alignment(cls, **alignment):
        '''Set the data at the current address as aligned with the specified `alignment`.'''
        return cls.align(ui.current.address(), **alignment)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def alignment(cls, ea, **alignment):
        """Set the data at address `ea` as aligned.

        If `alignment` is specified, then use it as the number of bytes to align the data to.
        If `size` is specified, then align that number of bytes.
        """
        if not type.is_unknown(ea):
            logging.warning("{:s}.set.alignment({:#x}{:s}) : Refusing to align the specified address ({:#x}) as it has already been defined.".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(alignment)) if alignment else '', ea))  # XXX: define a custom warning
            return 0

        # alignment can only be determined if there's an actual size, so
        # we'll need some way to calculate the size if we weren't given one.
        def calculate_size(ea):

            # if the address is initialized, then we'll figure it out by
            # looking for bytes that repeat.
            if type.is_initialized(ea):
                size, by = 0, read(ea, 1)
                while read(ea + size, 1) == by:
                    size += 1
                return size

            # if it's uninitialized, then use the next label as the boundary
            # for calculating the size that we need.
            return address.nextlabel(ea) - ea

        # first of all, we need to check if idaapi.create_align exists,
        # because if it doesn't then we need to calculate things ourselves.
        if not hasattr(idaapi, 'create_align'):

            # grab the size out of the kwarg or calculate it if one wasn't given.
            size = alignment['size'] if operator.contains(alignment, 'size') else calculate_size(ea)

            # now we can just hand our size off to create_data because
            # this is the very best that we can do.
            return cls.data(ea, size, type=idaapi.FF_ALIGN)

        # otherwise we can actually use the create_align which can infer the
        # size and align it on our behalf. we'll start by trying to grab the
        # alignment and converting from a multiple to an actual exponent.
        align = builtins.next((alignment[k] for k in ['align', 'alignment'] if k in alignment), 0)
        e = math.trunc(math.floor(math.log(align, 2))) if align else 0

        # if we were given an alignment, then we'll need to convert it from
        # its multiple that the user wants to an actual exponent for the api.
        # next we'll need to grab the size if the user gave us one.
        if operator.contains(alignment, 'size'):
            size = alignment['size']

        # if our size is unset and we're using an older version of IDA, then
        # we actually need to figure the size out ourselves regardless.
        elif idaapi.__version__ < 7.6:
            size = alignment.get('size', calculate_size(ea))

        # if they didn't give us one, then we need at least one of them to
        # figure out the other. we do this by calculating the size ourselves.
        else:
            size = alignment.get('size', 0 if align else calculate_size(ea))

        # now we should be good to go and can return the new size or 0 on failure.
        if not idaapi.create_align(ea, size, e):
            return 0
        return idaapi.get_item_size(ea)
    align = aligned = utils.alias(alignment, 'set')

    @utils.multicase()
    @classmethod
    def string(cls, **strtype):
        '''Set the data at the current selection or address to a string with the specified `strtype`.'''
        address, selection = ui.current.address(), ui.current.selection()
        if 'length' in strtype or operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.string(address, **strtype)
        return cls.string(selection, **strtype)
    @utils.multicase(bounds=tuple)
    @classmethod
    def string(cls, bounds, **strtype):
        '''Set the data within the provided `bounds` to a string with the specified `strtype`.'''
        widthtype = {1: idaapi.STRWIDTH_1B, 2: idaapi.STRWIDTH_2B, 4: idaapi.STRWIDTH_4B}
        lengthtype = {0: idaapi.STRLYT_TERMCHR, 1: idaapi.STRLYT_PASCAL1, 2: idaapi.STRLYT_PASCAL2, 4: idaapi.STRLYT_PASCAL4}

        # Before we do anything, we're going to need to figure out what the string
        # type so that we can calculate what the actual string length will be.
        if any(item in strtype for item in ['strtype', 'type']):
            res = builtins.next(strtype[item] for item in ['strtype', 'type'] if item in strtype)
            width_t, length_t = res if isinstance(res, (builtins.list, builtins.tuple)) else (res, 0)

        # If we didn't get one, then we need to use the default one from the database.
        else:
            inf = config.info.strtype if idaapi.__version__ < 7.2 else idaapi.inf_get_strtype()
            width, layout = ((inf >> shift) & mask for shift, mask in [(0, idaapi.STRWIDTH_MASK), (idaapi.STRLYT_SHIFT, idaapi.STRLYT_MASK)])
            match_width = (item for item, value in widthtype.items() if value == width)
            match_layout = (item for item, value in lengthtype.items() if value == layout)
            width_t, length_t = builtins.next(match_width, 1), builtins.next(match_layout, 0)

        # Now we have the character width and the length prefix size. So to start out, we
        # take the difference between our bounds and subtract the layout length from it.
        distance = operator.sub(*reversed(sorted(bounds)))
        if length_t > distance:
            logging.warning("{:s}.string({!s}{:s}) : Attempting to apply a string with a prefix length ({:d}) that is larger than the given boundaries ({:s}).".format('.'.join([__name__, cls.__name__]), bounds, u", {!s}".format(utils.string.kwargs(strtype)) if strtype else '', length_t, bounds))
        leftover = distance - length_t if distance > length_t else 0

        # Next we can just take our total number of leftover bytes and divide it by the
        # character width to get the real string length that we'll use. We round it up
        # to ensure that the bounds the user gave us covers everything they selected.
        ea, _ = bounds
        return cls.string(ea, math.trunc(math.ceil(leftover / width_t)), **strtype)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def string(cls, ea, **strtype):
        '''Set the data at address `ea` to a string with the specified `strtype`.'''
        return cls.string(ea, strtype.pop('length', 0), **strtype)
    @utils.multicase(ea=six.integer_types, length=six.integer_types)
    @classmethod
    def string(cls, ea, length, **strtype):
        """Set the data at address `ea` to a string with the specified `length`.

        If the integer `strtype` is specified, then apply a string of the specified character width.
        If the tuple `strtype` is specified, the first item is the string's character width and the second item is the size of the length prefix.
        """
        widthtype = {1: idaapi.STRWIDTH_1B, 2: idaapi.STRWIDTH_2B, 4: idaapi.STRWIDTH_4B}
        lengthtype = {0: idaapi.STRLYT_TERMCHR, 1: idaapi.STRLYT_PASCAL1, 2: idaapi.STRLYT_PASCAL2, 4: idaapi.STRLYT_PASCAL4}

        # First try grab the type that the user gave us from the parameters. If it wasn't a tuple,
        # then convert it into one with a null-terminator, as the user might've just given us the
        # character width.
        if any(item in strtype for item in ['strtype', 'type']):
            res = builtins.next(strtype[item] for item in ['strtype', 'type'] if item in strtype)
            width_t, length_t = res if isinstance(res, (builtins.list, builtins.tuple)) else (res, 0)

        # Otherwise, we need to unpack the default one from the database into the width and layout.
        else:
            inf = config.info.strtype if idaapi.__version__ < 7.2 else idaapi.inf_get_strtype()
            width, layout = ((inf >> shift) & mask for shift, mask in [(0, idaapi.STRWIDTH_MASK), (idaapi.STRLYT_SHIFT, idaapi.STRLYT_MASK)])
            match_width = (item for item, value in widthtype.items() if value == width)
            match_layout = (item for item, value in lengthtype.items() if value == layout)
            width_t, length_t = builtins.next(match_width, 1), builtins.next(match_layout, 0)

        # Now we can just validate the width and the length size.
        if not operator.contains(widthtype, width_t):
            raise E.InvalidTypeOrValueError("{:s}.string({:#x}, {:d}{:s}) : The requested character width ({:d}) is unsupported.".format('.'.join([__name__, cls.__name__]), ea, length, u", {!s}".format(utils.string.kwargs(strtype)) if strtype else '', width_t))
        if not operator.contains(lengthtype, length_t):
            raise E.InvalidTypeOrValueError("{:s}.string({:#x}, {:d}{:s}) : An invalid size ({:d}) was provided for the string length prefix.".format('.'.join([__name__, cls.__name__]), ea, length, u", {!s}".format(utils.string.kwargs(strtype)) if strtype else '', length_t))

        # Convert the width and length into an actual size.
        size = width_t * length

        # Now we can combine them into the string type that IDA actually understands.
        res = (lengthtype[length_t] << idaapi.STRLYT_SHIFT) & idaapi.STRLYT_MASK
        res|= widthtype[width_t] & idaapi.STRWIDTH_MASK

        # If the size is larger than 0, then the user knows what they want and we
        # need to undefine that number of bytes first. The value of length_t is
        # added because we need to undefine the length prefix as well.
        if size > 0 and not type.is_unknown(ea):
            cb = cls.unknown(ea, length_t + size)
            if cb != length_t + size:
                raise E.DisassemblerError(u"{:s}.string({:#x}, {:d}{:s}) : Unable to undefine {:d} bytes for the requested string.".format('.'.join([__name__, cls.__name__]), ea, length, u", {:s}".format(utils.string.kwargs(strtype)) if strtype else '', length_t + size))

        # Make a string at the specified address of the suggested size with
        # the desired string type.
        ok = idaapi.make_ascii_string(ea, size and (size + length_t), res) if idaapi.__version__ < 7.0 else idaapi.create_strlit(ea, size and (size + length_t), res)
        if not ok:
            raise E.DisassemblerError(u"{:s}.string({:#x}, {:d}{:s}) : Unable to define the specified address as a string of the requested strtype {:#04x}.".format('.'.join([__name__, cls.__name__]), ea, length, u", {:s}".format(utils.string.kwargs(strtype)) if strtype else '', res))

        # In order to determine the correct length, we need to subtract the
        # length prefix the size, and divide the total by the character width.
        res = idaapi.get_item_size(ea) - length_t
        return get.string(ea, length=res // width_t)

    class integer(object):
        """
        This namespace used for applying various sized integer types to
        a particular address.

        This namespace is also aliased as ``database.set.i`` and can be used
        as follows::

            > database.set.i.uint8_t(ea)
            > database.set.i.uint64_t(ea)

        """
        @utils.multicase()
        def __new__(cls):
            '''Set the data at the current address to an integer.'''
            return cls(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea):
            '''Set the data at address `ea` to an integer of a type determined by its size.'''
            res = type.size(ea)
            return cls(ea, res)
        @utils.multicase(ea=six.integer_types, size=six.integer_types)
        def __new__(cls, ea, size):
            '''Set the data at the address `ea` to an integer of the specified `size`.'''
            res = set.unknown(ea, size)
            if not type.is_unknown(ea, size) or res < size:
                raise E.DisassemblerError(u"{:s}({:#x}, {:d}) : Unable to undefine {:d} byte{:s} for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, size, '' if size == 1 else 's'))

            ok = set.data(ea, size)
            if not ok:
                raise E.DisassemblerError(u"{:s}({:#x}, {:d}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, size, 8 * size))
            return get.signed(ea, size) if type.flags(ea, idaapi.FF_SIGN) else get.unsigned(ea, size)

        @utils.multicase()
        @classmethod
        def uint8_t(cls):
            '''Set the data at the current address to a uint8_t.'''
            return cls.uint8_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint8_t(cls, ea):
            '''Set the data at address `ea` to a uint8_t.'''
            res = set.unknown(ea, 1)
            if not type.is_unknown(ea, 1) or res < 1:
                raise E.DisassemblerError(u"{:s}.uint8_t({:#x}) : Unable to undefine {:d} byte for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 1))

            # Apply our data type after undefining it
            ok = set.data(ea, res, type=idaapi.FF_BYTE)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint8_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Return our new size
            return get.unsigned(ea, res)
        @utils.multicase()
        @classmethod
        def sint8_t(cls):
            '''Set the data at the current address to a sint8_t.'''
            return cls.sint8_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint8_t(cls, ea):
            '''Set the data at address `ea` to a sint8_t.'''
            res = set.unknown(ea, 1)
            if not type.is_unknown(ea, 1) or res < 1:
                raise E.DisassemblerError(u"{:s}.sint8_t({:#x}) : Unable to undefine {:d} byte for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 1))

            # Apply our data type after undefining it
            ok = set.data(ea, res, type=idaapi.FF_BYTE)
            if not ok:
                raise E.DisassemblerError(u"{:s}.sint8_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if not type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Return our new size
            return get.signed(ea, res)
        byte = utils.alias(uint8_t, 'set.integer')

        @utils.multicase()
        @classmethod
        def uint16_t(cls):
            '''Set the data at the current address to a uint16_t.'''
            return cls.uint16_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint16_t(cls, ea):
            '''Set the data at address `ea` to a uint16_t.'''
            res = set.unknown(ea, 2)
            if not type.is_unknown(ea, 2) or res < 2:
                raise E.DisassemblerError(u"{:s}.uint16_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 2))

            # Apply our data type after undefining it
            ok = set.data(ea, res, type=idaapi.FF_WORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint16_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Return our new size
            return get.unsigned(ea, res)
        @utils.multicase()
        @classmethod
        def sint16_t(cls):
            '''Set the data at the current address to a sint16_t.'''
            return cls.sint16_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint16_t(cls, ea):
            '''Set the data at address `ea` to a sint16_t.'''
            res = set.unknown(ea, 2)
            if not type.is_unknown(ea, 2) or res < 2:
                raise E.DisassemblerError(u"{:s}.sint16_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 2))

            # Apply our data type after undefining it
            ok = set.data(ea, res, type=idaapi.FF_WORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.sint16_t({:#x}) : Unable to set the specfied address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if not type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Return our new size
            return get.signed(ea, res)
        word = utils.alias(uint16_t, 'set.integer')

        @utils.multicase()
        @classmethod
        def uint32_t(cls):
            '''Set the data at the current address to a uint32_t.'''
            return cls.uint32_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint32_t(cls, ea):
            '''Set the data at address `ea` to a uint32_t.'''
            FF_DWORD = idaapi.FF_DWORD if hasattr(idaapi, 'FF_DWORD') else idaapi.FF_DWRD

            # Undefine the data at the specified address
            res = set.unknown(ea, 4)
            if not type.is_unknown(ea, 4) or res < 4:
                raise E.DisassemblerError(u"{:s}.uint32_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 4))

            # Apply our new data type after undefining it
            ok = set.data(ea, res, type=FF_DWORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint32_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Now we can return our new size
            return get.unsigned(ea, res)
        @utils.multicase()
        @classmethod
        def sint32_t(cls):
            '''Set the data at the current address to a sint32_t.'''
            return cls.sint32_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint32_t(cls, ea):
            '''Set the data at address `ea` to a sint32_t.'''
            FF_DWORD = idaapi.FF_DWORD if hasattr(idaapi, 'FF_DWORD') else idaapi.FF_DWRD

            # Undefine the data at the specified address
            res = set.unknown(ea, 4)
            if not type.is_unknown(ea, 4) or res < 4:
                raise E.DisassemblerError(u"{:s}.uint32_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 4))

            # Apply our new data type after undefining it
            ok = set.data(ea, res, type=FF_DWORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint32_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if not type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Now we can return our new size
            return get.signed(ea, res)
        dword = utils.alias(uint32_t, 'set.integer')

        @utils.multicase()
        @classmethod
        def uint64_t(cls):
            '''Set the data at the current address to a uint64_t.'''
            return cls.uint64_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint64_t(cls, ea):
            '''Set the data at address `ea` to a uint64_t.'''
            FF_QWORD = idaapi.FF_QWORD if hasattr(idaapi, 'FF_QWORD') else idaapi.FF_QWRD

            # Undefine the data at the specified address
            res = set.unknown(ea, 8)
            if not type.is_unknown(ea, 8) or res < 8:
                raise E.DisassemblerError(u"{:s}.uint64_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 8))

            # Apply our new data type after undefining it
            ok = set.data(ea, res, type=FF_QWORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint64_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Now we can return our new value since everything worked
            return get.unsigned(ea, res)
        @utils.multicase()
        @classmethod
        def sint64_t(cls):
            '''Set the data at the current address to a sint64_t.'''
            return cls.sint64_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint64_t(cls, ea):
            '''Set the data at address `ea` to a sint64_t.'''
            FF_QWORD = idaapi.FF_QWORD if hasattr(idaapi, 'FF_QWORD') else idaapi.FF_QWRD

            # Undefine the data at the specified address
            res = set.unknown(ea, 8)
            if not type.is_unknown(ea, 8) or res < 8:
                raise E.DisassemblerError(u"{:s}.uint64_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 8))

            # Apply our new data type after undefining it
            ok = set.data(ea, res, type=FF_QWORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint64_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if not type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Now we can return our new value since everything worked
            return get.signed(ea, res)
        qword = utils.alias(uint64_t, 'set.integer')

        @utils.multicase()
        @classmethod
        def uint128_t(cls):
            '''Set the data at the current address to an uint128_t.'''
            return cls.uint128_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint128_t(cls, ea):
            '''Set the data at address `ea` to an uint128_t.'''
            FF_OWORD = idaapi.FF_OWORD if hasattr(idaapi, 'FF_OWORD') else idaapi.FF_OWRD

            # Undefine the data at the specified address
            res = set.unknown(ea, 16)
            if not type.is_unknown(ea, 16) or res < 16:
                raise E.DisassemblerError(u"{:s}.uint128_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 16))

            # Apply our new data type after undefining it
            ok = set.data(ea, res, type=FF_OWORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint128_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Now we can return our new value if we succeeded
            return get.signed(ea, res)
        @utils.multicase()
        @classmethod
        def sint128_t(cls):
            '''Set the data at the current address to a sint128_t.'''
            return cls.sint128_t(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint128_t(cls, ea):
            '''Set the data at address `ea` to an sint128_t.'''
            FF_OWORD = idaapi.FF_OWORD if hasattr(idaapi, 'FF_OWORD') else idaapi.FF_OWRD

            # Undefine the data at the specified address
            res = set.unknown(ea, 16)
            if not type.is_unknown(ea, 16) or res < 16:
                raise E.DisassemblerError(u"{:s}.uint128_t({:#x}) : Unable to undefine {:d} bytes for the integer.".format('.'.join([__name__, 'set', cls.__name__]), ea, 16))

            # Apply our new data type after undefining it
            ok = set.data(ea, res, type=FF_OWORD)
            if not ok:
                raise E.DisassemblerError(u"{:s}.uint128_t({:#x}) : Unable to set the specified address to an integer ({:d}-bit).".format('.'.join([__name__, 'set', cls.__name__]), ea, 8 * res))

            # Check if we need to flip the sign flag, and do it if necessary
            if not type.flags(ea, idaapi.FF_SIGN):
                idaapi.toggle_sign(ea, 0)

            # Now we can return our new value if we succeeded
            return get.signed(ea, res)
        oword = utils.alias(uint128_t, 'set.integer')

    i = integer # XXX: ns alias

    class float(object):
        """
        This namespace used for applying various sized floating-point types
        to a particular address.

        This namespace is aliased as ``database.set.f`` and can be used as
        follows::

            > database.set.f.single(ea)
            > database.set.f.double(ea)

        """
        @utils.multicase()
        def __new__(cls):
            '''Sets the data at the current address to an IEEE-754 floating-point number based on its size.'''
            return cls(ui.current.address())
        @utils.multicase()
        def __new__(cls, ea):
            '''Sets the data at address `ea` to an IEEE-754 floating-point number based on its size.'''
            size = type.size(ea)
            if size < 4 and type.is_unknown(ea, 4):
                logging.warning(u"{:s}({:#x}) : Promoting number at address {:#x} to 32-bit single due to item size ({:+d}) being less than the smallest available IEEE-754 number ({:+d}).".format('.'.join([__name__, 'set', cls.__name__]), ea, size, 4))
                return cls.single(ea)
            elif size == 4:
                return cls.single(ea)
            elif size == 8:
                return cls.double(ea)
            raise E.InvalidTypeOrValueError(u"{:s}({:#x}) : Unable to determine the type of floating-point number for the item's size ({:+#x}).".format('.'.join([__name__, 'set', cls.__name__]), ea, size))

        @utils.multicase()
        @classmethod
        def single(cls):
            '''Set the data at the current address to an IEEE-754 single'''
            return cls.single(ui.current.address())
        @utils.multicase()
        @classmethod
        def single(cls, ea):
            '''Set the data at address `ea` to an IEEE-754 single.'''
            res = set.unknown(ea, 4)
            if not type.is_unknown(ea, 4) or res < 4:
                raise E.DisassemblerError(u"{:s}.single({:#x}) : Unable to undefine {:d} bytes for the float.".format('.'.join([__name__, 'set', cls.__name__]), ea, 4))

            # Apply our data type after undefining it
            ok = set.data(ea, res, type=idaapi.FF_FLOAT & 0xf0000000)
            if not ok:
                raise E.DisassemblerError(u"{:s}.single({:#x}) : Unable to assign a single to the specified address.".format('.'.join([__name__, 'set', cls.__name__]), ea))

            # Return our new value
            return get.float.single(ea)

        @utils.multicase()
        @classmethod
        def double(cls):
            '''Set the data at the current address to an IEEE-754 double'''
            return cls.double(ui.current.address())
        @utils.multicase()
        @classmethod
        def double(cls, ea):
            '''Set the data at address `ea` to an IEEE-754 double.'''
            res = set.unknown(ea, 8)
            if not type.is_unknown(ea, 8) or res < 8:
                raise E.DisassemblerError(u"{:s}.double({:#x}) : Unable to undefine {:d} bytes for the float.".format('.'.join([__name__, 'set', cls.__name__]), ea, 8))

            # Apply our data type after undefining it
            ok = set.data(ea, res, type=idaapi.FF_DOUBLE & 0xf0000000)
            if not ok:
                raise E.DisassemblerError(u"{:s}.double({:#x}) : Unable to assign a double to the specified address.".format('.'.join([__name__, 'set', cls.__name__]), ea))

            # Return our new value
            return get.float.double(ea)

    f = float   # XXX: ns alias

    @utils.multicase(type=_structure.structure_t)
    @classmethod
    def structure(cls, type):
        '''Set the data at the current address to the structure_t specified by `type`.'''
        return cls.structure(ui.current.address(), type)
    @utils.multicase(name=six.string_types)
    @classmethod
    def structure(cls, name):
        '''Set the data at the current address to the structure_t with the given `name`.'''
        return cls.structure(ui.current.address(), name)
    @utils.multicase(sptr=idaapi.struc_t)
    @classmethod
    def structure(cls, sptr):
        '''Set the data at the current address to the structure_t for the specified `sptr`.'''
        return cls.structure(ui.current.address(), sptr)
    @utils.multicase(ea=six.integer_types, type=_structure.structure_t)
    @classmethod
    def structure(cls, ea, type):
        '''Set the data at address `ea` to the structure_t specified by `type`.'''
        ok = cls.data(ea, type.size, type=type.ptr)
        if not ok:
            raise E.DisassemblerError(u"{:s}.structure({:#x}, {!r}) : Unable to define the specified address as a structure.".format('.'.join([__name__, cls.__name__]), ea, type))
        return get.structure(ea, type)
    @utils.multicase(ea=six.integer_types, name=six.string_types)
    @classmethod
    def structure(cls, ea, name):
        '''Set the data at address `ea` to the structure_t with the given `name`.'''
        st = _structure.by(name)
        return cls.structure(ea, st)
    @utils.multicase(ea=six.integer_types, sptr=idaapi.struc_t)
    @classmethod
    def structure(cls, ea, sptr):
        '''Set the data at address `ea` to the structure_t for the specified `sptr`.'''
        st = _structure.by(sptr)
        return cls.structure(ea, st)
    @utils.multicase(ea=six.integer_types, identifier=six.integer_types)
    @classmethod
    def structure(cls, ea, identifier):
        '''Set the data at address `ea` to the structure_t that has the specified `identifier`.'''
        st = _structure.by_identifier(identifier)
        return cls.structure(ea, st)

    struc = struct = utils.alias(structure, 'set')

    @utils.multicase()
    @classmethod
    def array(cls):
        '''Set the data at the current selection to an array of the type at the current address.'''
        ea, item = ui.current.address(), type.array()

        # Extract the type from the current address and use it to get its size.
        original_type, original_length = item
        _, _, nbytes = interface.typemap.resolve(original_type)

        # If the length at the current address is irrelevant, then we can just
        # chain to the other selection code using the type that we snagged.
        if original_length <= 1:
            return cls.array(original_type)

        # Otherwise we grab the selection and unpack it in order to calculate
        # the new length and determine if we need to warn the user about it.
        start, stop = ui.current.selection()
        result = math.ceil((stop - start) / nbytes)

        # Now we compare if the user is asking us to change the length in some way.
        length = math.trunc(result)
        if original_length > 1 and length != original_length:
            logging.warning(u"{:s}.array() : Modifying the number of elements ({:d}) for the array at the current selection ({:#x}<>{:#x}) to {:d}.".format('.'.join([__name__, cls.__name__]), original_length, start, stop, length))
        return cls.array(original_type, length)
    @utils.multicase(length=six.integer_types)
    @classmethod
    def array(cls, length):
        '''Set the data at the current selection to an array of the specified `length` using the type at the current address.'''
        ea, item = ui.current.address(), type.array()
        original_type, original_length = item

        # If the length is being changed, then warn the user about it.
        if original_length > 1 and original_length != length:
            logging.warning(u"{:s}.array({:d}) : Modifying the number of elements ({:d}) for the array at the current address ({:#x}) to {:d}.".format('.'.join([__name__, cls.__name__]), length, original_length, ea, length))
        return cls.array(ea, original_type, length)
    @utils.multicase()
    @classmethod
    def array(cls, type, **length):
        '''Set the data at the current address to an array of the specified `type` using the length determined from the current selection if `length` is not specified.'''
        if 'length' in length and isinstance(type, list):
            ttype, tlength = type
            if tlength != length['length']:
                raise E.InvalidParameterError(u"{:s}.array({!r}{:s}) : Multiple values for the array length were passed in the type ({:d}) and the parameter ({:d}).".format('.'.join([__name__, cls.__name__]), ttype, ", {:s}".format(utils.string.kwargs(length)) if length else '', tlength, length['length']))
            return cls.array(ui.current.address(), ttype, tlength)
        elif isinstance(type, list):
            type, length = type
            return cls.array(ui.current.address(), type, length)
        elif 'length' in length:
            return cls.array(ui.current.address(), type, length['length'])

        # If no length was specified, then we'll check the current selection.
        selection = ui.current.selection()
        if operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.array(ui.current.address(), type)
        start, stop = selection
        return cls.array((start, address.next(stop)), type)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def array(cls, ea, type):
        '''Set the data at the address `ea` to an array of the given `type`.'''
        type, length = type if isinstance(type, builtins.list) else (type, 1)
        return cls.array(ea, type, length)
    @utils.multicase(bounds=tuple)
    @classmethod
    def array(cls, bounds, type):
        '''Set the data at the provided `bounds` to an array of the given `type`.'''
        if isinstance(type, builtins.list):
            raise E.InvalidParameterError(u"{:s}.array({!s}, {!r}) : Unable to set the provided boundary ({!r}) to the specified type ({!s}) due to it resulting in another array.".format('.'.join([__name__, cls.__name__]), bounds, type, bounds, type))
        start, stop = sorted(bounds)

        # Calculate the size of the type that we were given.
        _, _, nbytes = interface.typemap.resolve(type)
        length = operator.sub(*reversed(sorted(bounds)))

        # Now we can use it to calculate the length and apply it.
        res = math.ceil(length / nbytes)
        return cls.array(start, type, math.trunc(res))
    @utils.multicase(ea=six.integer_types, length=six.integer_types)
    @classmethod
    def array(cls, ea, type, length):
        '''Set the data at the address `ea` to an array with the given `length` and `type`.'''

        # if the type is already specifying a list, then combine it with
        # the specified length
        if isinstance(type, list):
            t, l = type
            realtype, reallength = [t, l * length], l * length

        # otherwise, promote it into an array
        else:
            realtype, reallength = [type, length], length

        # now we can figure out its IDA type and create the data. after
        # that, though, we need to update its refinfo before we leave.
        flags, typeid, nbytes = interface.typemap.resolve(realtype)
        if not idaapi.create_data(ea, flags, nbytes, typeid):
            raise E.DisassemblerError(u"{:s}.array({:#x}, {!r}, {:d}) : Unable to define the specified address as an array.".format('.'.join([__name__, cls.__name__]), ea, type, length))
        interface.address.update_refinfo(ea, flags)

        # return the array that we just created.
        return get.array(ea, length=reallength)

class get(object):
    """
    This namespace used to fetch and decode the data from the database
    at a given address. This allows one to interpret the semantics of
    parts of the database and then perform an action based on what was
    decoded. This includes standard functions for reading integers of
    different sizes, decoding structures, and even reading of arrays
    from the database.

    In order to decode various things out of the database, some of the
    following examples can be used::

        > res = database.get.signed()
        > res = database.get.unsigned(ea, 8, byteorder='big')
        > res = database.get.array(ea)
        > res = database.get.array(length=42)
        > res = database.get.structure(ea)
        > res = database.get.structure(ea, structure=structure.by('mystructure'))

    """
    @utils.multicase()
    @classmethod
    def info(cls):
        '''Return the type information for the current address as an ``idaapi.tinfo_t``.'''
        return cls.info(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def info(cls, ea):
        '''Return the type information for the address `ea` as an ``idaapi.tinfo_t``.'''
        return type(ea)
    typeinfo = utils.alias(info, 'get')

    @utils.multicase()
    @classmethod
    def unsigned(cls, **byteorder):
        '''Read an unsigned integer from the current address.'''
        ea = ui.current.address()
        return cls.unsigned(ea, type.size(ea), **byteorder)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def unsigned(cls, ea, **byteorder):
        '''Read an unsigned integer from the address `ea` using the size defined in the database.'''
        return cls.unsigned(ea, type.size(ea), **byteorder)
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def unsigned(cls, ea, size, **byteorder):
        """Read an unsigned integer from the address `ea` with the specified `size`.

        If `byteorder` is 'big' then read in big-endian form.
        If `byteorder` is 'little' then read in little-endian form.

        The default value of `byteorder` is the same as specified by the database architecture.
        """
        data = read(ea, size)
        endian = byteorder.get('order', None) or byteorder.get('byteorder', config.byteorder())
        if endian.lower().startswith('little'):
            data = data[::-1]
        return functools.reduce(lambda agg, byte: agg << 8 | byte, bytearray(data), 0)

    @utils.multicase()
    @classmethod
    def signed(cls, **byteorder):
        '''Read a signed integer from the current address.'''
        ea = ui.current.address()
        return cls.signed(ea, type.size(ea), **byteorder)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def signed(cls, ea, **byteorder):
        '''Read a signed integer from the address `ea` using the size defined in the database.'''
        return cls.signed(ea, type.size(ea), **byteorder)
    @utils.multicase(ea=six.integer_types, size=six.integer_types)
    @classmethod
    def signed(cls, ea, size, **byteorder):
        """Read a signed integer from the address `ea` with the specified `size`.

        If `byteorder` is 'big' then read in big-endian form.
        If `byteorder` is 'little' then read in little-endian form.

        The default value of `byteorder` is the same as specified by the database architecture.
        """
        bits = 8 * size
        sf = pow(2, bits) >> 1
        res = cls.unsigned(ea, size, **byteorder)
        return (res - pow(2, bits)) if res & sf else res

    class integer(object):
        """
        This namespace contains the different ISO standard integer types that
        can be used to read integers out of the database.

        This namespace is also aliased as ``database.get.i`` and can be used
        like in the following examples::

            > res = database.get.i.uint32_t()
            > res = database.get.i.sint64_t(ea)
            > res = database.get.i.uint8_t(ea)

        """
        @utils.multicase()
        def __new__(cls, **byteorder):
            '''Read an integer from the current address.'''
            return get.signed(**byteorder) if type.flags(ui.current.address(), idaapi.FF_SIGN) else get.unsigned(**byteorder)
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea, **byteorder):
            '''Read an integer from the address `ea`.'''
            return get.signed(ea, **byteorder) if type.flags(ea, idaapi.FF_SIGN) else get.unsigned(ea, **byteorder)
        @utils.multicase(ea=six.integer_types, size=six.integer_types)
        def __new__(cls, ea, size, **byteorder):
            '''Read an integer of the specified `size` from the address `ea`.'''
            return get.signed(ea, size, **byteorder) if type.flags(ea, idaapi.FF_SIGN) else get.unsigned(ea, size, **byteorder)

        @utils.multicase()
        @classmethod
        def uint8_t(cls, **byteorder):
            '''Read a uint8_t from the current address.'''
            return get.unsigned(ui.current.address(), 1, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint8_t(cls, ea, **byteorder):
            '''Read a uint8_t from the address `ea`.'''
            return get.unsigned(ea, 1, **byteorder)
        @utils.multicase()
        @classmethod
        def sint8_t(cls, **byteorder):
            '''Read a sint8_t from the current address.'''
            return get.signed(ui.current.address(), 1, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint8_t(cls, ea, **byteorder):
            '''Read a sint8_t from the address `ea`.'''
            return get.signed(ea, 1, **byteorder)
        byte = utils.alias(uint8_t, 'get.integer')

        @utils.multicase()
        @classmethod
        def uint16_t(cls, **byteorder):
            '''Read a uint16_t from the current address.'''
            return get.unsigned(ui.current.address(), 2, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint16_t(cls, ea, **byteorder):
            '''Read a uint16_t from the address `ea`.'''
            return get.unsigned(ea, 2, **byteorder)
        @utils.multicase()
        @classmethod
        def sint16_t(cls, **byteorder):
            '''Read a sint16_t from the current address.'''
            return get.signed(ui.current.address(), 2, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint16_t(cls, ea, **byteorder):
            '''Read a sint16_t from the address `ea`.'''
            return get.signed(ea, 2, **byteorder)
        word = utils.alias(uint16_t, 'get.integer')

        @utils.multicase()
        @classmethod
        def uint32_t(cls, **byteorder):
            '''Read a uint32_t from the current address.'''
            return get.unsigned(ui.current.address(), 4, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint32_t(cls, ea, **byteorder):
            '''Read a uint32_t from the address `ea`.'''
            return get.unsigned(ea, 4, **byteorder)
        @utils.multicase()
        @classmethod
        def sint32_t(cls, **byteorder):
            '''Read a sint32_t from the current address.'''
            return get.signed(ui.current.address(), 4, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint32_t(cls, ea, **byteorder):
            '''Read a sint32_t from the address `ea`.'''
            return get.signed(ea, 4, **byteorder)
        dword = utils.alias(uint32_t, 'get.integer')

        @utils.multicase()
        @classmethod
        def uint64_t(cls, **byteorder):
            '''Read a uint64_t from the current address.'''
            return get.unsigned(ui.current.address(), 8, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint64_t(cls, ea, **byteorder):
            '''Read a uint64_t from the address `ea`.'''
            return get.unsigned(ea, 8, **byteorder)
        @utils.multicase()
        @classmethod
        def sint64_t(cls, **byteorder):
            '''Read a sint64_t from the current address.'''
            return get.signed(ui.current.address(), 8, **byteorder)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint64_t(cls, ea, **byteorder):
            '''Read a sint64_t from the address `ea`.'''
            return get.signed(ea, 8, **byteorder)
        qword = utils.alias(uint64_t, 'get.integer')

        @utils.multicase()
        @classmethod
        def uint128_t(cls, **byteorder):
            '''Read a uint128_t from the current address.'''
            return get.unsigned(ui.current.address(), 16)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def uint128_t(cls, ea, **byteorder):
            '''Read a uint128_t from the address `ea`.'''
            return get.unsigned(ea, 16, **byteorder)
        @utils.multicase()
        @classmethod
        def sint128_t(cls, **byteorder):
            '''Read a sint128_t from the current address.'''
            return get.signed(ui.current.address(), 16)
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def sint128_t(cls, ea, **byteorder):
            '''Read a sint128_t from the address `ea`.'''
            return get.signed(ea, 16, **byteorder)
        oword = utils.alias(uint128_t, 'get.integer')

    i = integer # XXX: ns alias

    class float(object):
        """
        This namespace contains a number of functions for fetching floating
        point numbers out of the database. These floating-point numbers are
        encoded according to the IEEE-754 specification.

        This namespace is also aliased as ``database.get.f`` and can be used
        as in the following examples::

            > res = database.get.f.half()
            > res = database.get.f.single(ea)
            > res = database.get.f.double(ea)

        If one needs to describe a non-standard encoding for a floating-point
        number, one can use the ``database.float`` function. This function
        takes a tuple representing the number of bits for the different
        components of a floating-point number. This can be used as in the
        following for reading a floating-point "half" from the database::

            > res = database.get.float(components=(10, 5, 1))

        This specifies 10-bits for the mantissa, 5 for the exponent, and 1
        bit for the signed flag. This allows one to specify arbitrary
        encodings for different floating-point numbers.
        """

        @utils.multicase()
        def __new__(cls, **byteorder):
            '''Read a floating-number from the current address using the number type that matches its size.'''
            return cls(ui.current.address(), **byteorder)
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea, **byteorder):
            '''Read a floating-number at the address `ea` using the number type that matches its size.'''
            size = type.size(ea)
            if size == 2:
                return cls.half(ea, **byteorder)
            elif size == 4:
                return cls.single(ea, **byteorder)
            elif size == 8:
                return cls.double(ea, **byteorder)
            elif size > 8:
                logging.warning(u"{:s}({:#x}) : Demoting size ({:+d}) for floating-point number at {:#x} down to largest available IEEE-754 number ({:+d}).".format('.'.join([__name__, 'get', cls.__name__]), ea, size, ea, 8))
                return cls.double(ea, **byteorder)
            raise E.InvalidTypeOrValueError(u"{:s}({:#x}) : Unable to determine the type of floating-point number for the item's size ({:+#x}).".format('.'.join([__name__, 'get', cls.__name__]), ea, size))

        @utils.multicase(components=tuple)
        def __new__(cls, components, **byteorder):
            '''Read a floating-point number at the current address encoded with the specified `components`.'''
            return cls(ui.current.address(), components, **byteorder)
        @utils.multicase(ea=six.integer_types, components=tuple)
        def __new__(cls, ea, components, **byteorder):
            """Read a floating-point number at the address `ea` that is encoded with the specified `components`.

            The `components` parameter is a tuple (mantissa, exponent, sign) representing the number of bits for each component of the floating-point number.
            If `byteorder` is 'big' then read in big-endian form.
            If `byteorder` is 'little' then read in little-endian form.

            The default value of `byteorder` is the same as specified by the database architecture.
            """
            cb = sum(components) // 8

            # Read our data from the database as an integer, as we'll use this
            # to decode our individual components.
            integer = get.unsigned(ea, cb, **byteorder)

            # Unpack the components the user gave us.
            fraction, exponent, sign = components

            # Use the components to decode the floating point number
            try:
                res = utils.float_of_integer(integer, fraction, exponent, sign)

            except ValueError as message:
                raise ValueError(u"{:s}({:#x}, {!s}) : {!s}".format('.'.join([__name__, cls.__name__]), ea, components, message))

            return res

        @utils.multicase()
        @classmethod
        def half(cls, **byteorder):
            '''Read a half from the current address.'''
            return cls.half(ui.current.address(), **byteorder)
        @utils.multicase()
        @classmethod
        def half(cls, ea, **byteorder):
            '''Read a half from the address `ea`.'''
            bits = 10, 5, 1
            return cls(ea, bits, **byteorder)

        @utils.multicase()
        @classmethod
        def single(cls, **byteorder):
            '''Read a single from the current address.'''
            return cls.single(ui.current.address(), **byteorder)
        @utils.multicase()
        @classmethod
        def single(cls, ea, **byteorder):
            '''Read a single from the address `ea`.'''
            bits = 23, 8, 1
            return cls(ea, bits, **byteorder)

        @utils.multicase()
        @classmethod
        def double(cls, **byteorder):
            '''Read a double from the current address.'''
            return cls.double(ui.current.address(), **byteorder)
        @utils.multicase()
        @classmethod
        def double(cls, ea, **byteorder):
            '''Read a double from the address `ea`.'''
            bits = 52, 11, 1
            return cls(ea, bits, **byteorder)

    f = float   # XXX: ns alias

    @utils.multicase()
    @classmethod
    def array(cls, **length):
        '''Return the values of the array at the current selection or address.'''
        address, selection = ui.current.address(), ui.current.selection()
        if 'length' in length or operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.array(address, **length)
        return cls.array(selection)
    @utils.multicase(bounds=tuple)
    @classmethod
    def array(cls, bounds):
        '''Return the values within the provided `bounds` as an array.'''
        start, stop = sorted(bounds)
        length = (stop - start) / idaapi.get_item_size(start)
        return cls.array(start, length=math.trunc(math.ceil(length)))
    @utils.multicase(bounds=tuple)
    @classmethod
    def array(cls, bounds, type):
        '''Return the values within the provided `bounds` as an array of the pythonic element `type`.'''
        start, stop = sorted(bounds)

        # figure out the element size from our pythonic type parameter.
        _, _, size = interface.typemap.resolve(type)

        # the bounds might not divide evenly by the given type, but we want
        # to lean towards reading too much rather than reading too little.
        length = (stop - start) / size
        count = math.trunc(math.ceil(length))
        return cls.array(start, length=count, type=type)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def array(cls, ea, **length):
        """Return the values of the array at the address specified by `ea`.

        If the integer `length` is defined, then use it as the number of elements for the array.
        If a pythonic type is passed to `type`, then use it for the element type of the array when decoding.
        """
        ea = interface.address.within(ea) if 'length' not in length else ea

        # FIXME: this function is just too fucking large...srsly.
        FF_STRUCT = idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU
        FF_STRLIT = idaapi.FF_STRLIT if hasattr(idaapi, 'FF_STRLIT') else idaapi.FF_ASCI

        def numeric_lookup_tables():
            '''
            This closure is responsible for returning the lookup tables to map IDA types to
            either lengths or array typecodes which will be used for decoding the elements
            of the array.
            '''

            # This numerics table is responsible for mapping an idaapi.DT_TYPE
            # type to a typecode for the _array class.
            numerics = {
                idaapi.FF_BYTE : utils.get_array_typecode(1),
                idaapi.FF_WORD : utils.get_array_typecode(2),
                idaapi.FF_DWORD if hasattr(idaapi, 'FF_DWORD') else idaapi.FF_DWRD : utils.get_array_typecode(4),
                idaapi.FF_FLOAT : 'f',
                idaapi.FF_DOUBLE : 'd',
            }

            # Some 32-bit versions of python might not have array.array('Q')
            # and some versions of IDA also might not have FF_QWORD..
            try:
                _array.array(utils.get_array_typecode(8))
                numerics[idaapi.FF_QWORD if hasattr(idaapi, 'FF_QWORD') else idaapi.FF_QWRD] = utils.get_array_typecode(8)
            except (AttributeError, ValueError):
                pass

            # This long-numerics table is a mapping-type for converting an
            # idaapi.DT_TYPE to a length. This way we can manually read the
            # elements of the array into a list that we can return to the user.
            lnumerics = {
                idaapi.FF_BYTE : 1, idaapi.FF_ALIGN : 1,
                idaapi.FF_WORD : 2,
                idaapi.FF_DWORD if hasattr(idaapi, 'FF_DWORD') else idaapi.FF_DWRD : 4,
                idaapi.FF_FLOAT : 4,
                idaapi.FF_DOUBLE : 8,
            }

            # If we have FF_QWORD defined but it cannot be represented by the
            # _array class, then we'll need to add its size to our long-numerics
            # table so that we can still read its elements manually.
            if any(hasattr(idaapi, name) for name in {'FF_QWRD', 'FF_QWORD'}):
                name = builtins.next(name for name in {'FF_QWRD', 'FF_QWORD'} if hasattr(idaapi, name))
                value = getattr(idaapi, name)
                if value not in numerics:
                    lnumerics[value] = 8
                pass

            # FF_OWORD, FF_YWORD and FF_ZWORD might not exist in older versions
            # of IDA, so try to add them to our long-numerics "softly".
            try:
                lnumerics[idaapi.FF_QWORD if hasattr(idaapi, 'FF_QWORD') else idaapi.FF_QWRD] = 8
                lnumerics[idaapi.FF_OWORD if hasattr(idaapi, 'FF_OWORD') else idaapi.FF_OWRD] = 16
                lnumerics[idaapi.FF_YWORD if hasattr(idaapi, 'FF_YWORD') else idaapi.FF_YWRD] = 32
                lnumerics[idaapi.FF_ZWORD if hasattr(idaapi, 'FF_ZWORD') else idaapi.FF_ZWRD] = 64
            except AttributeError:
                pass

            # Depending on the version of IDAPython, some of IDA's flags (FF_*) can
            # be signed or unsigned. Since we're explicitly testing for them by using
            # container membership, we'll need to ensure that they're unsigned when
            # storing them into their lookup tables. This way our membership tests
            # will actually work when determining the types to use.
            numerics = { idaapi.as_uint32(ff) : typecode for ff, typecode in numerics.items() }
            lnumerics = { idaapi.as_uint32(ff) : length for ff, length in lnumerics.items() }

            # Now they're safe to return to the caller for people to use.
            return numerics, lnumerics

        def decode_array(ea, T, count, numerics, lnumerics):
            '''
            This closure is responsible for decoding an array from the given address
            using the provided type (T) and count for the number of elements. The
            `numerics` and `lnumerics` tables are used for looking up the typecode
            or length given a DT_TYPE.
            '''

            # If the array has a refinfo_t at its address or the signed flag is
            # set, then we need to lowercase the typecode to get signed or
            # relative values from the array.
            if interface.address.refinfo(ea) or F & idaapi.FF_SIGN:

                # FIXME: If the user has set the signed flag, then we need to return
                #        the negative values that are displayed instead of just
                #        decoding the array's integers as signed.
                typecode = numerics[T].lower()

            # Otherwise, we can simply lookup the typecode and use that one.
            else:
                typecode = numerics[T]

            # Create an _array using the typecode that we determined so that it can
            # be decoded and then returned to the caller.
            res = _array.array(typecode)

            # If our _array's itemsize doesn't match the element size that we expected,
            # then we need to warn the user that something fucked up and that we're
            # hijacking the array decoding with our own hardcoded unsigned length.
            cb = lnumerics[T]
            if res.itemsize != cb:
                logging.warning(u"{:s}.array({:#x}{:s}) : Refusing to decode array at address {:#x} using the array size ({:+d}) identified for DT_TYPE ({:#x}) due to the size of the DT_TYPE ({:#x}) not corresponding to the desired element size ({:+d}).".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', ea, res.itemsize, T, T, cb))

                # Reconstruct the array but with the expected element size.
                try:
                    res = _array.array(utils.get_array_typecode(cb, 1))

                # If we can't use the typecode determined by the element size, then
                # just assume that the elements are just individual bytes.
                except ValueError:
                    res = _array.array(utils.get_array_typecode(1))

            # Get the number of elements for our array, and use it to read our data
            # from the database. Then we can use the data to initialize the _array
            # that we're going to return to the user.
            data = read(ea, count * cb)
            res.fromstring(data) if sys.version_info.major < 3 else res.frombytes(data)

            # Validate the _array's length so that we can warn the user if it's wrong.
            if len(res) != count:
                logging.warning(u"{:s}.array({:#x}{:s}) : The decoded array length ({:d}) is different from the expected length ({:d}).".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', len(res), count))
            return res

        # If the "type" parameter was provided, then resolve that type into the
        # flags and DT_TYPE that we will need.
        if 'type' in length:
            F, tid, total = interface.typemap.resolve(length['type'])

            # If we were given an array in the "type" parameter, then reassign
            # that back into the "length" parameter so it can be used later.
            if isinstance(length['type'], builtins.list):
                _, count = length['type']
                length.setdefault('length', count)

        # Otherwise we extract the flags and DT_TYPE directly from the address.
        else:
            F, total = type.flags(ea), idaapi.get_item_size(ea)
            tid = type.structure.id(ea) if type.flags(ea, idaapi.DT_TYPE) == FF_STRUCT else idaapi.BADADDR

        # Set the array's length if it hasn't been determined yet.
        if not operator.contains(length, 'length'):
            length['length'] = type.array.length(ea)

        # Now that we have the flags and the type, we can use it to determine
        # how we need to decode the array. Since there's no utilities or
        # anything for performing these conversions in minsc, we'll need to
        # handle all of the element types ourselves by explicitly handling
        # each supported case.
        T = idaapi.as_uint32(F & idaapi.DT_TYPE)
        numerics, lnumerics = numeric_lookup_tables()

        # If this is a string-literal, then we need to figure out the element
        # size in order to figure out which character width to use.
        if T in {FF_STRLIT}:
            elesize = idaapi.get_full_data_elsize(ea, F)

            # Python's "u" typecode for their _array can actually change sizes. So
            # we have no choice here other than to just use the integer typecodes
            # for both 16-bit and 32-bit wide-character strings.
            strings = { 1: 'c', 2: utils.get_array_typecode(2), 4: utils.get_array_typecode(4) }
            t = strings[elesize]

            # Now we need to fix the value for T so that it corresponds to its
            # element size by checking the lnumerics array. Afterwards we can
            # simply decode it as normal.
            T = builtins.next(ff for ff, size in lnumerics.items() if size == elesize)
            return decode_array(ea, T, length['length'], numerics, lnumerics)

        # If we found a structure at this address, then we'll simply take its
        # length and use it to create a structure for each individual element.
        elif T in {FF_STRUCT}:
            cb = _structure.size(tid)
            # FIXME: this math doesn't work with dynamically sized structures (of course)
            count = length.get('length', math.trunc(math.ceil(float(total) / cb)))
            return [ cls.structure(ea + index * cb, identifier=tid) for index in builtins.range(count) ]

        # If the DT_TYPE was found in our numerics dictionary, then we're able
        # to use a native _array with the decode_array closure.
        elif T in numerics:
            return decode_array(ea, T, length['length'], numerics, lnumerics)

        # If the DT_TYPE was found in our lnumerics (long) dictionary, then use
        # that to figure out the element size, and read each integer as a list
        # due there being no native _array type.
        elif T in lnumerics:
            cb, total = lnumerics[T], idaapi.get_item_size(ea)
            # FIXME: Instead of returning the signed version of an integer, we
            #        need to return IDA's signed representation of the integer
            #        so that it directly corresponds to the user's view.
            Fgetinteger = get.signed if F & idaapi.FF_SIGN == idaapi.FF_SIGN else get.unsigned
            count = length.get('length', math.trunc(math.ceil(float(total) / cb)))
            return [ Fgetinteger(ea + index * cb, cb) for index in builtins.range(count) ]

        # Otherwise the DT_TYPE is unsupported, and we don't have a clue on how
        # this should be properly decoded...
        raise E.UnsupportedCapability(u"{:s}.array({:#x}{:s}) : Unknown DT_TYPE found in flags at address {:#x}. The flags {:#x} have the `idaapi.DT_TYPE` as {:#x}.".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', ea, F, T))

    @utils.multicase()
    @classmethod
    def string(cls, **length):
        '''Return the array at the current selection or address as a string.'''
        address, selection = ui.current.address(), ui.current.selection()
        if 'length' in length or operator.eq(*(internal.interface.address.head(ea, silent=True) for ea in selection)):
            return cls.string(address, **length)
        return cls.string(selection, **length)
    @utils.multicase(bounds=tuple)
    @classmethod
    def string(cls, bounds, **length):
        '''Return the array described by the specified `bounds` as a string.'''
        widthtype = {idaapi.STRWIDTH_1B: 1, idaapi.STRWIDTH_2B: 2, idaapi.STRWIDTH_4B: 4}

        # Similar to the get.string function, we're need to figure out the string
        # type to calculate what the string length means for the given bounds.
        if any(item in length for item in ['strtype', 'type']):
            res = builtins.next(length[item] for item in ['strtype', 'type'] if item in length)
            width_t, length_t = res if isinstance(res, (builtins.list, builtins.tuple)) else (res, 0)

        # If we didn't get one, then we actually figure it out by applying the
        # default string character width from the database. We're explicitly
        # ignoring the prefix here so the user has to explicitly specify it.
        else:
            inf = config.info.strtype if idaapi.__version__ < 7.2 else idaapi.inf_get_strtype()
            width_t, length_t = widthtype.get(inf & idaapi.STRWIDTH_MASK, 1), 0

        # Now we have the character width and the size of the length prefix size. So we
        # take the difference between our bounds and subtract the layout length from it.
        distance = operator.sub(*reversed(sorted(bounds)))
        if length_t > distance:
            logging.warning("{:s}.string({!s}{:s}) : Attempting to apply a string with a prefix length ({:d}) that is larger than the given boundaries ({:s}).".format('.'.join([__name__, cls.__name__]), bounds, u", {!s}".format(utils.string.kwargs(length)) if length else '', length_t, bounds))
        leftover = distance - length_t if distance > length_t else 0

        # That was it, we can now just use the leftover bytes to calculate our length,
        # assigned it into our kwargs, and chain to the real get.string functionality.
        ea, _ = bounds
        length.setdefault('length', math.trunc(math.ceil(leftover / width_t)))
        return cls.string(ea, **length)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def string(cls, ea, **length):
        """Return the array at the address specified by `ea` as a string.

        If an integer `length` is provided, then use it explicitly as the string's length when reading.
        If an integer `strtype` is provided, then use it as the string's character width when reading.
        If a tuple `strtype` is specified, then the first item is the character width and the second is the size of the length prefix when reading.
        """

        # For older versions of IDA, we get the strtype from the opinfo
        if idaapi.__version__ < 7.0:
            res = address.head(ea)
            ti, F = idaapi.opinfo_t(), type.flags(res)
            strtype = ti.strtype if idaapi.get_opinfo(res, 0, F, ti) else idaapi.BADADDR

            # and cast the result from idaapi.get_str_type_code to an integer
            get_str_type_code = utils.fcompose(idaapi.get_str_type_code, six.byte2int)

        # Fetch the string type at the given address using the newer API
        else:
            strtype = idaapi.get_str_type(address.head(ea))
            get_str_type_code = idaapi.get_str_type_code

        # Define some lookup tables that we'll use to figure out the lengths.
        widthtype = {1: idaapi.STRWIDTH_1B, 2: idaapi.STRWIDTH_2B, 4: idaapi.STRWIDTH_4B}
        lengthtype = {0: idaapi.STRLYT_TERMCHR, 1: idaapi.STRLYT_PASCAL1, 2: idaapi.STRLYT_PASCAL2, 4: idaapi.STRLYT_PASCAL4}

        # If a strtype was provided in the parameters, then convert it into a proper
        # string typecode so that the logic which follows will still work.
        if any(item in length for item in ['strtype', 'type']):

            # Extract the strtype that the user gave us whilst ensuring that we remove
            # the items out of the parameters since we later pass them to `get.array`.
            res = builtins.next((length.pop(item) for item in ['strtype', 'type'] if item in length))
            width_t, length_t = res if isinstance(res, (builtins.list, builtins.tuple)) else (res, 0)

            # Now that we've unpacked the string width and length prefix size from the
            # parameter, we can recombine them into a strtype code.
            strtype = (lengthtype[length_t] << idaapi.STRLYT_SHIFT) & idaapi.STRLYT_MASK
            strtype|= widthtype[width_t] & idaapi.STRWIDTH_MASK

            # Since the user gave us an explicit type, we need to update the keywords
            # which get passed to `get.array` so that each element is of the correct width.
            length['type'] = int, width_t

        # If we weren't given a strtype, then we still need to figure out what the default
        # is that was set in the database. This way we can actually fall back to something.
        else:
            inf = config.info.strtype if idaapi.__version__ < 7.2 else idaapi.inf_get_strtype()
            strwidth_t = inf & idaapi.STRWIDTH_MASK
            default_width = builtins.next((item for item, value in widthtype.items() if value == strwidth_t), 1)

        # If no string was found, then try to treat it as a plain old array
        # XXX: idaapi.get_str_type() seems to return 0xffffffff on failure instead of idaapi.BADADDR
        if strtype in {idaapi.BADADDR, 0xffffffff}:
            res = cls.array(ea, **length)

            # Warn the user what we're doing before we start figuring out
            # the element size of the string.
            if isinstance(res, _array.array):
                logging.warning(u"{:s}.string({:#x}{:s}) : Unable to guess the string type for address {:#x}. Reading it as an array of {:d}-byte sized integers and converting it to a string instead.".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', ea, res.itemsize))

            # If we were unable to retrieve an _array.array, then it's likely because the address
            # is defined as a structure or a weird size. To fix it, we will set the type to the
            # default character width, warn the user that we're ignoring IDA, and try it again.
            else:
                logging.warning(u"{:s}.string({:#x}{:s}) : The data at address {:#x} is using a non-integral type and will be treated as an array of {:d}-byte sized characters.".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', ea, default_width))
                length['type'] = int, default_width
                res = cls.array(ea, **length)

            # This really should be an assertion error or really a "unit-test" for cls.array,
            # because we _absolutely_ should have gotten an _array.array from cls.array.
            if not isinstance(res, _array.array):
                raise E.DisassemblerError(u"{:s}.string({:#x}{:s}) : There was a failure while trying to read the data at address {:#x} as an array of integers ({!s}).".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', ea, res.__class__))

            # We can't figure out the shift.. So, since that's a dead end we have to assume that
            # the terminator is a null byte. Since we're already guessing, use the widthtype
            # that corresponds to our array itemsize whilst falling back to the default.
            sentinels, sl = '\0', idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT
            sw = widthtype[res.itemsize if res.itemsize in widthtype else default_width]

            # FIXME: We should probably figure out the default codec for the character width here.
            encoding = idaapi.encoding_from_strtype(idaapi.STRENC_DEFAULT)
            decoder = None

        # Otherwise we can extract the string's characteristics directly from the strtype code.
        else:
            # Get the terminal characters that can terminate the string.
            sentinels = idaapi.get_str_term1(strtype) + idaapi.get_str_term2(strtype)

            # Extract the fields out of the string type code.
            res = get_str_type_code(strtype)
            sl, sw = res & idaapi.STRLYT_MASK, res & idaapi.STRWIDTH_MASK

            # Get the string encoding and look it up in our available codecs. If we can't find
            # it, then that's okay because we'll fall-back to one of the UTF-XX encodings.
            encoding = idaapi.encoding_from_strtype(strtype)

            try:
                decoder = functools.partial(codecs.lookup(encoding).decode, errors='replace')
            except LookupError:
                decoder = None
            finally:
                if not decoder:
                    logging.warning(u"{:s}.string({:#x}{:s}) : Due to the string at {:#x} being encoded with an unknown encoding ({:s}), the encoding will be determined based on the character size ({:d}).".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', ea, encoding, {idaapi.STRWIDTH_1B: 1, idaapi.STRWIDTH_2B: 2, idaapi.STRWIDTH_4B: 4}.get(sw, -1)))

        # Figure out how the STRLYT field shifts and terminates the string.
        if sl == idaapi.STRLYT_TERMCHR << idaapi.STRLYT_SHIFT:
            shift, fterminate = 0, operator.methodcaller('rstrip', sentinels)
        elif sl == idaapi.STRLYT_PASCAL1 << idaapi.STRLYT_SHIFT:
            shift, fterminate = 1, utils.fidentity
        elif sl == idaapi.STRLYT_PASCAL2 << idaapi.STRLYT_SHIFT:
            shift, fterminate = 2, utils.fidentity
        elif sl == idaapi.STRLYT_PASCAL4 << idaapi.STRLYT_SHIFT:
            shift, fterminate = 4, utils.fidentity
        else:
            raise E.UnsupportedCapability(u"{:s}.string({:#x}{:s}) : Unsupported STRLYT({:d}) found in string at address {:#x}.".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', sl, ea))

        # Figure out how the STRWIDTH field affects the string.
        if sw == idaapi.STRWIDTH_1B:
            cb, fdecode = 1, utils.fcompose(decoder, operator.itemgetter(0)) if decoder else operator.methodcaller('decode', 'utf-8', 'replace')
        elif sw == idaapi.STRWIDTH_2B:
            cb, fdecode = 2, utils.fcompose(decoder, operator.itemgetter(0)) if decoder else operator.methodcaller('decode', 'utf-16', 'replace')
        elif sw == idaapi.STRWIDTH_4B:
            cb, fdecode = 4, utils.fcompose(decoder, operator.itemgetter(0)) if decoder else operator.methodcaller('decode', 'utf-32', 'replace')
        else:
            raise E.UnsupportedCapability(u"{:s}.string({:#x}{:s}) : Unsupported STRWIDTH({:d}) found in string at address {:#x}.".format('.'.join([__name__, cls.__name__]), ea, u", {:s}".format(utils.string.kwargs(length)) if length else '', sw, ea))

        # If we don't need to shift our address, then just trust get.array.
        if not shift:
            res = cls.array(ea + shift, **length)

        # Otherwise use our length and the string width to figure out the
        # boundaries of the array and then we can read it.
        else:
            left, right = ea + shift, ea + shift + cb * cls.unsigned(ea, shift)
            res = cls.array((left, right), (int, cb))

        # Convert it to a string and then process it with the callables we determined.
        data = res.tostring() if sys.version_info.major < 3 else res.tobytes()
        return fterminate(fdecode(data))
    @utils.multicase()
    @classmethod
    def structure(cls):
        '''Return a dictionary of ctypes for the ``structure_t`` that is applied to the current address.'''
        return cls.structure(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def structure(cls, ea):
        '''Return a dictionary of ctypes for the ``structure_t`` that is applied to the address `ea`.'''
        sid = type.structure.id(ea)
        return cls.structure(ea, sid)
    @utils.multicase(ea=six.integer_types, sptr=idaapi.struc_t)
    @classmethod
    def structure(cls, ea, sptr):
        '''Return a dictionary of ctypes for the ``structure_t`` identified by `sptr` at the address `ea`.'''
        return cls.structure(ea, sptr.id)
    @utils.multicase(ea=six.integer_types, name=six.string_types)
    @classmethod
    def structure(cls, ea, name):
        '''Return a dictionary of ctypes for the ``structure_t`` with the specified `name` at the address `ea`.'''
        st = _structure.by(name)
        return cls.structure(ea, st)
    @utils.multicase(ea=six.integer_types, type=_structure.structure_t)
    @classmethod
    def structure(cls, ea, type):
        '''Return a dictionary of ctypes for the ``structure_t`` specified by `type` at the address `ea`.'''
        return cls.structure(ea, type.id)
    @utils.multicase(ea=six.integer_types, identifier=six.integer_types)
    @classmethod
    def structure(cls, ea, identifier):
        '''Return a dictionary of ctypes for the ``structure_t`` with the specified `identifier` at the address `ea`.'''
        ea = interface.address.within(ea)

        # FIXME: consolidate this conversion into an interface or something
        st = _structure.by_identifier(identifier, offset=ea)
        typelookup = {
            (int, -1) : ctypes.c_int8,   (int, 1) : ctypes.c_uint8,
            (int, -2) : ctypes.c_int16,  (int, 2) : ctypes.c_uint16,
            (int, -4) : ctypes.c_int32,  (int, 4) : ctypes.c_uint32,
            (int, -8) : ctypes.c_int64,  (int, 8) : ctypes.c_uint64,
            (float, 4) : ctypes.c_float, (float, 8) : ctypes.c_double,

            # pointer types, would be cool if we could have variable-sized pointers..but we don't.
            (builtins.type, -1) : ctypes.c_int8,    (builtins.type, 1) : ctypes.c_uint8,
            (builtins.type, -2) : ctypes.c_int16,   (builtins.type, 2) : ctypes.c_uint16,
            (builtins.type, -4) : ctypes.c_int32,   (builtins.type, 4) : ctypes.c_uint32,
            (builtins.type, -8) : ctypes.c_int64,   (builtins.type, 8) : ctypes.c_uint64,

            # FIXME: add support for string types
        }

        res = {}
        for m in st.members:
            t, val = m.type, read(m.offset, m.size) or b''

            # try and lookup the individual type + size
            try:
                ct = typelookup[t]

            # either we don't support it, or it's an array
            except (TypeError, KeyError):

                # if it's an array, then unpack the count. otherwise we'll use a
                # count of -1 so that we can tell ctypes to not actually create
                # the type as an array. we can't use 0 here because ctypes
                # recognizes 0-length arrays.
                ty, count = t if isinstance(t, builtins.list) else (t, -1)

                # check that we really are handling an array, and lookup its type
                # to build a ctype with its count
                if isinstance(t, builtins.list) and operator.contains(typelookup, ty):
                    t = typelookup[ty]
                    ct = t if count < 0 else (t * count)

                # if our type is a string type, then we can simply make a ctype for it
                elif ty in {chr, str}:
                    ct = ctypes.c_char if count < 0 else (ctypes.c_char * count)

                # otherwise we have no idea what ctype we can use for this, so skip it
                # by creating a buffer for it
                else:
                    logging.warning(u"{:s}.structure({:#x}, ...) : Using buffer with size {:+#x} for member #{:d} ({:s}) due to unsupported type {!s}.".format('.'.join([__name__, cls.__name__]), ea, m.size, m.index, m.fullname, ty if count < 0 else [ty, count]))
                    ct = None

            # finally we can add the member to our result by creating a buffer for it
            res[m.name] = val if any(item is None for item in [ct, val]) else ctypes.cast(ctypes.pointer(ctypes.c_buffer(val)), ctypes.POINTER(ct)).contents
        return res
    struc = struct = utils.alias(structure, 'get')

    class switch(object):
        """
        Function for fetching an instance of a ``switch_t`` from a given address.
        Despite this being a namespace, by default it is intended to be used
        as a function against any known component of a switch. It will then
        return a class that allows one to query the different attributes of
        an ``idaapi.switch_info_t``.

        This namespace can be used as in the following example::

            > sw = database.get.switch(ea)
            > print( sw )

        """
        @classmethod
        def __of_label__(cls, ea):
            F, get_switch_info = type.flags(ea), idaapi.get_switch_info_ex if idaapi.__version__ < 7.0 else idaapi.get_switch_info

            # Technically a label for a switch is a code data type that is
            # referenced by by some data. We do this instead of checking the names.
            if type.is_code(ea) and type.is_referenced(ea):
                drefs = (ref for ref in xref.data_up(ea) if type.is_data(ref))

                # With the data references, we need need to walk up one more step
                # and grab any code references to it while looking for a switch.
                refs = (ref for ref in itertools.chain(*map(xref.data_up, drefs)) if type.is_code(ref) and get_switch_info(ref) is not None)

                # Now we'll just grab the very first reference we found. If we
                # got an address, then use it to grab the switch_info_t we want.
                ref = builtins.next(refs, None)
                si = None if ref is None else get_switch_info(ref)

            # Without a label, there's nothing we can do to find the switch_info_t.
            else:
                si = None

            # If we didn't find a switch_info_t, then raise a warning. Otherwise
            # the only thing left to do is to wrap it up for the user and return it.
            if si is None:
                switch_t = idaapi.switch_info_ex_t if idaapi.__version__ < 7.0 else idaapi.switch_info_t
                raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to instantiate a `{:s}` at the target label for the given address ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, switch_t.__name__, ea))
            return interface.switch_t(si)

        @classmethod
        def __of_array__(cls, ea):
            get_switch_info = idaapi.get_switch_info_ex if idaapi.__version__ < 7.0 else idaapi.get_switch_info

            # Grab all of the upward data references to the array at the given
            # address # that can give us an actual switch_info_t.
            refs = (ea for ea in xref.data_up(ea) if get_switch_info(ea) is not None)

            # Then we can grab the first one and use it. If we didn't get a valid
            # reference, then we're not going to get a valid switch.
            ref = builtins.next(refs, None)
            if ref is None:
                si = None

            # We have an address, so now we can just straight-up snag the switch.
            else:
                si = get_switch_info(ref)

            # If we were unable to get a switch, then just raise an exception. If we
            # did grab it, however, then we just need to wrap it up and then return.
            if si is None:
                switch_t = idaapi.switch_info_ex_t if idaapi.__version__ < 7.0 else idaapi.switch_info_t
                raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to instantiate a `{:s}` using the array at the given address ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, switch_t.__name__, ea))
            return interface.switch_t(si)

        @classmethod
        def __of_address__(cls, ea):
            get_switch_info = idaapi.get_switch_info_ex if idaapi.__version__ < 7.0 else idaapi.get_switch_info

            # Try and get a switch from the given address. If it worked, then
            # we just need to wrap it up nicely for them to use.
            si = get_switch_info(ea)
            if si is not None:
                return interface.switch_t(si)

            # Otherwise, we iterate through all of the address' downward
            # references to see if any valid candidates can be derived.
            for ref in xref.code_down(ea):
                found = not (get_switch_info(ref) is None)

                if interface.node.is_identifier(ref):
                    continue

                # If we actually grabbed the switch, then the current reference
                # actually is our only candidate and we should use it.
                if found:
                    candidates = (item for item in [ref])

                # Otherwise if the reference is pointing to data, then treat
                # it an array where we need to follow the downward references.
                elif type.is_data(ref):
                    items = (case for case in xref.code_down(ref))
                    candidates = (label for label in itertools.chain(*map(xref.data_up, items)) if get_switch_info(label))

                # Otherwise this must be code and so we'll check any of its
                # upward references to derive the necessary candidates.
                elif not found:
                    candidates = (label for label in xref.up(ref) if get_switch_info(label))

                # Grab the first location from our available candidates, and
                # try and get a switch_info_t using it.
                location = builtins.next(candidates, None)
                si = None if location is None else get_switch_info(location)

                # If we did grab a switch_info_t, then all we have to do is to
                # simply wrap it up before we can return it to the user.
                if si is not None:
                    return interface.switch_t(si)
                continue

            # If the loop exhaused all of the references for the given address,
            # then we didn't find shit and so we need to let the user know.
            switch_t = idaapi.switch_info_ex_t if idaapi.__version__ < 7.0 else idaapi.switch_info_t
            raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to instantiate a `{:s}` using the branch instruction at the given address ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, switch_t.__name__, ea))

        @classmethod
        def __of_block__(cls, ea):
            if not function.within(ea):
                switch_t = idaapi.switch_info_ex_t if idaapi.__version__ < 7.0 else idaapi.switch_info_t
                raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to instantiate a `{:s}` using the given address ({:#x}) due to it not being within a function.".format('.'.join([__name__, 'type', cls.__name__]), ea, switch_t.__name__, ea))
            bounds = function.block(ea)

            # Now that we have the block, grab the last address as it could be
            # a branch that enters the switch, and feed it back into another method.
            left, right = bounds
            last = address.prev(right)
            return cls.__of_address__(last)

        @utils.multicase()
        def __new__(cls):
            '''Return the switch that is referenced at the current address.'''
            return cls(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        def __new__(cls, ea):
            '''Return the switch that is referenced by the address at `ea`.'''
            ea = interface.address.within(ea)

            # Try literally everything we can with the specifeid address in order to
            # traverse to the branch instruction that is used by the switch.
            try:
                return cls.__of_address__(ea)
            except E.MissingTypeOrAttribute:
                pass
            try:
                return cls.__of_array__(ea)
            except E.MissingTypeOrAttribute:
                pass
            try:
                return cls.__of_label__(ea)
            except E.MissingTypeOrAttribute:
                pass
            try:
                return cls.__of_block__(ea)
            except E.MissingTypeOrAttribute:
                pass

            # Nope. Absolutely nothing we tried actually worked and we need to give up.
            switch_t = idaapi.switch_info_ex_t if idaapi.__version__ < 7.0 else idaapi.switch_info_t
            raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to determine how to instantiate a `{:s}` using the information at the given address ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, switch_t.__name__, ea))


```

`base/enumeration.py`:

```py
"""
Enumeration module

This module exposes a number of tools that can be used to interact
with the enumerations or their members defined within the database.
The base argument type for interacting with an enumeration is the
enumeration identifier ``idaapi.enum_t``. This is an opaque integer
that will need to be passed to the different tools in order to
reference the enumeration that the user is referring to.

There are a number of tools within the ``member`` namespace that can
be used to enumerate or locate the members of an enumeration. As
typically an enumeration is simply a constant, each result that is
returned will either be a value or a name. The identifier for these
is a ``idaapi.uval_t``.

To list the different enumerations available in the database, one
can use ``enumeration.list(...)`` specifying their preferred method
of filtering. This will list all of the available enumerations at
which point the user can then request it by passing an identifier
to ``enumeration.by(...)``. The types that can be used to filter are
as follows:

    `name` - Match according to the enumeration name
    `like` - Filter the enumeration names according to a glob
    `regex` - Filter the enumeration names according to a regular-expression
    `index` - Match the enumeration by its index
    `identifier` or `id` - Match the enumeration by its identifier
    `predicate` - Filter the enumerations by passing their identifier to a callable

"""

import six, builtins

import functools, operator, itertools
import logging, sys, math
import fnmatch, re

import database

import internal
from internal import utils, interface, exceptions as E

import idaapi

# FIXME: complete this with more types similar to the 'structure' module.
# FIXME: normalize the documentation.

@utils.multicase(enum=six.integer_types)
def has(enum):
    '''Return truth if an enumeration with the identifier `enum` exists within the database.'''
    ENUM_QTY_IDX, ENUM_FLG_IDX, ENUM_FLAGS, ENUM_ORDINAL = -1, -3, -5, -8
    return interface.node.is_identifier(enum) and idaapi.get_enum_idx(enum) != idaapi.BADADDR
@utils.multicase(name=six.string_types)
def has(name):
    '''Return truth if an enumeration with the specified `name` exists within the database.'''
    string = utils.string.to(name)
    return idaapi.get_enum(string) != idaapi.BADADDR

def count():
    '''Return the total number of enumerations in the database.'''
    return idaapi.get_enum_qty()

@utils.multicase()
def flags(enum):
    '''Return the flags for the enumeration identified by `enum`.'''
    eid = by(enum)
    return idaapi.get_enum_flag(eid)
@utils.multicase(flags=six.integer_types)
def flags(enum, flags):
    '''Set the flags for the enumeration `enum` to the value specified by `flags`.'''
    eid = by(enum)

    # Define some flags that we may later allow the user to set explicitly.
    ENUM_FLAGS_IS_BF, ENUM_FLAGS_HIDDEN, = 0x00000001, 0x00000002,
    ENUM_FLAGS_FROMTIL, ENUM_FLAGS_WIDTH = 0x00000004, 0x00000038

    # Fetch the previous flag, and assign the new ones.
    res, ok = idaapi.get_enum_flag(eid), idaapi.set_enum_flag(eid, flags)
    if not ok:
        raise E.DisassemblerError(u"{:s}.flags({!r}, {:#x}) : Unable to set the flags for the specified enumeration ({:#x}) to {:#x}.".format(__name__, enum, flags, eid, flags))
    return res

@utils.multicase()
def index(enum):
    '''Return the index in the enumeration list for the enumeration identified by `enum`.'''
    eid = by(enum)
    return idaapi.get_enum_idx(eid)
@utils.multicase(index=six.integer_types)
def index(enum, index):
    '''Set the position in the enumeration list for the enumeration `enum` to the specified `index`.'''
    eid = by(enum)
    res, ok = idaapi.get_enum_idx(eid), idaapi.set_enum_idx(eid, index)
    if not ok:
        raise E.DisassemblerError(u"{:s}.index({!r}, {:d}) : Unable to set the index for the specified enumeration ({:#x}) to {:#x}.".format(__name__, enum, index, eid, index))
    return res

@utils.string.decorate_arguments('name')
def by_name(name):
    '''Return the identifier for the enumeration with the given `name`.'''
    string = utils.string.to(name)
    res = idaapi.get_enum(string)
    if res == idaapi.BADADDR:
        raise E.EnumerationNotFoundError(u"{:s}.by_name({!s}) : Unable to locate the enumeration with the specified name ({!s}).".format(__name__, utils.string.repr(name), utils.string.repr(name)))
    return res
byname = utils.alias(by_name)

def by_index(index):
    '''Return the identifier for the enumeration at the specified `index`.'''
    res = idaapi.getn_enum(index)
    if res == idaapi.BADADDR:
        raise E.EnumerationNotFoundError(u"{:s}.by_index({:#x}) : Unable to locate the enumeration at index {:d}.".format(__name__, index, index))
    return res
byindex = utils.alias(by_index)

def by_identifier(eid):
    '''Return the identifier for the enumeration using the specified `eid`.'''
    if not has(eid):
        raise E.EnumerationNotFoundError(u"{:s}.by_identifier({!s}) : Unable to locate the enumeration with the specified identifier ({:#x}).".format(__name__, eid, eid))
    return eid
byidentifier = utils.alias(by_identifier)

@utils.multicase(index=six.integer_types)
def by(index):
    '''Return the identifier for the enumeration at the specified `index`.'''
    return by_identifier(index) if interface.node.is_identifier(index) else by_index(index)
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name')
def by(name):
    '''Return the identifier for the enumeration with the specified `name`.'''
    return by_name(name)
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def by(**type):
    '''Return the identifier for the first enumeration matching the keyword specified by `type`.'''
    searchstring = utils.string.kwargs(type)

    listable = [item for item in iterate(**type)]
    if len(listable) > 1:
        messages = (u"[{:d}] {:s}{:s} ({:d} members){:s}".format(idaapi.get_enum_idx(item), idaapi.get_enum_name(item), u" & {:#x}".format(mask(item)) if bitfield(item) else u'', len(builtins.list(members(item))), u" // {:s}".format(comment(item)) if comment(item) else u'') for i, item in enumerate(listable))
        [ logging.info(msg) for msg in messages ]
        logging.warning(u"{:s}.search({:s}) : Found {:d} matching results. Returning the first enumeration {:#x}.".format(__name__, searchstring, len(listable), listable[0]))

    iterable = (item for item in listable)
    res = next(iterable, None)
    if res is None:
        raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format(__name__, searchstring))
    return res

@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string')
def search(string):
    '''Return the identifier of the first enumeration that matches the glob `string`.'''
    return by(like=string)
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def search(**type):
    '''Return the identifier of the first enumeration that matches the keyword specified by `type`.'''
    return by(**type)

def names(enum):
    '''Return a set of all of the names belonging to the enumeration `enum`.'''
    return {item for item in members.names(enum)}
keys = utils.alias(names)

def values(enum):
    '''Return a set of all of the values belonging to the enumeration `enum`.'''
    return {item for item in members.values(enum)}

## creation/deletion
@utils.string.decorate_arguments('name')
def new(name, flags=0):
    '''Create an enumeration with the specified `name` and `flags` using ``idaapi.add_enum``.'''
    idx, string = count(), utils.string.to(name)
    res = idaapi.add_enum(idx, string, flags)
    if res == idaapi.BADADDR:
        raise E.DisassemblerError(u"{:s}.new({!s}, flags={:d}) : Unable to create an enumeration with the specified name ({!s}).".format(__name__, utils.string.repr(name), flags, utils.string.repr(name)))
    return res

def delete(enum):
    '''Delete the enumeration `enum`.'''
    eid = by(enum)
    return idaapi.del_enum(eid)
create, remove = utils.alias(new), utils.alias(delete)

## setting enum options
@utils.multicase()
def name(enum):
    '''Return the name of the enumeration `enum`.'''
    eid = by(enum)
    res = idaapi.get_enum_name(eid)
    return utils.string.of(res)
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name')
def name(enum, name):
    '''Rename the enumeration `enum` to the string `name`.'''
    eid, string = by(enum), utils.string.to(name)
    res, ok = idaapi.get_enum_name(eid), idaapi.set_enum_name(eid, string)
    if not ok:
        raise E.DisassemblerError(u"{:s}.name({!r}, {!s}) : Unable to set the name for the specified enumeration ({:#x}) to {!s}.".format(__name__, enum, utils.string.repr(name), eid, utils.string.repr(name)))
    return utils.string.of(res)

@utils.multicase()
def comment(enum, **repeatable):
    """Return the comment for the enumeration `enum`.

    If the bool `repeatable` is specified, then return the repeatable comment.
    """
    eid = by(enum)
    res = idaapi.get_enum_cmt(eid, repeatable.get('repeatable', True))
    return utils.string.of(res)
@utils.multicase(comment=six.string_types)
@utils.string.decorate_arguments('comment')
def comment(enum, comment, **repeatable):
    """Set the comment for the enumeration `enum` to `comment`.

    If the bool `repeatable` is specified, then modify the repeatable comment.
    """
    eid, string = by(enum), utils.string.to(comment)
    res, ok = idaapi.get_enum_cmt(eid, repeatable.get('repeatable', True)), idaapi.set_enum_cmt(eid, string, repeatable.get('repeatable', True))
    if not ok:
        adjective = (u'repeatable' if repeatable.get('repeatable', True) else u'non-repeatable') if repeatable else u''
        raise E.DisassemblerError(u"{:s}.comment({!r}, {!s}{:s}) : Unable to set the {:s}comment for the specified enumeration ({:#x}) to {!s}.".format(__name__, enum, utils.string.repr(comment), u", {:s}".format(utils.string.kwargs(repeatable)) if repeatable else u'', u" {:s}".format(adjective) if adjective else u'', eid, utils.string.repr(comment)))
    return utils.string.of(res)
@utils.multicase(none=None.__class__)
def comment(enum, none, **repeatable):
    '''Remove the comment from the enumeration `enum`.'''
    return comment(enum, none or u'', **repeatable)

@utils.multicase()
def size(enum):
    '''Return the number of bytes for the enumeration `enum`.'''
    eid = by(enum)
    return idaapi.get_enum_width(eid)
@utils.multicase(width=six.integer_types)
def size(enum, width):
    '''Set the number of bytes for the enumeration `enum` to `width`.'''
    eid = by(enum)
    res, ok = idaapi.get_enum_width(eid), idaapi.set_enum_width(eid, width)
    if not ok:
        raise E.DisassemblerError(u"{:s}.size({!r}, {:#x}) : Unable to set the width for the specified enumeration ({:#x}) to {:d}.".format(__name__, enum, width, eid, width))
    return res

@utils.multicase()
def bits(enum):
    '''Return the number of bits for the enumeration `enum`.'''
    return 8 * size(enum)
@utils.multicase(width=six.integer_types)
def bits(enum, width):
    '''Set the number of bits for the enumeration `enum` to `width`.'''
    res = math.trunc(math.ceil(width / 8.0))
    return size(enum, math.trunc(res))

def mask(enum):
    '''Return the bitmask for the enumeration `enum`.'''
    eid = by(enum)
    res = bits(eid)
    return pow(2, res) - 1

@utils.multicase()
def bitfield(enum):
    '''Return whether the enumeration identified by `enum` is a bitfield or not.'''
    eid = by(enum)
    return idaapi.is_bf(eid)
@utils.multicase(boolean=(six.integer_types, bool))
def bitfield(enum, boolean):
    '''Toggle the bitfield setting of the enumeration `enum` depending on the value of `boolean`.'''
    eid = by(enum)
    res, ok = idaapi.is_bf(eid), idaapi.set_enum_bf(eid, True if boolean else False)
    if not ok:
        raise E.DisassemblerError(u"{:s}.bitfield({!r}, {!s}) : Unable to set the bitfield flag for the specified enumeration ({:#x}) to {!s}.".format(__name__, enum, boolean, eid, boolean))
    return res
bitflag = utils.alias(bitfield)

def up(enum):
    '''Return all structure or frame members within the database that reference the specified `enum`.'''
    X, eid = idaapi.xrefblk_t(), by(enum)

    # IDA does not seem to create xrefs to enumeration identifiers.
    raise E.UnsupportedCapability(u"{:s}.up({:#x}) : Unable to locate any cross-references for the specified enumeration due to the disassembler not keeping track of them.".format(__name__, eid))

    # Grab the first reference to the enumeration.
    if not X.first_to(eid, idaapi.XREF_ALL):
        return []

    # Continue to grab all the rest of the refs to the enumeration.
    refs = [(X.frm, X.iscode, X.type)]
    while X.next_to():
        refs.append((X.frm, X.iscode, X.type))

    # Iterate through each xref and figure out if the enumeration id is
    # applied to a structure type.
    res = []
    for ref, _, _ in refs:

        # If the reference is not an identifier, then we don't care about
        # it because it's pointing to code and the member.refs function
        # should be used for grabbing those.
        if not interface.node.is_identifier(ref):
            continue

        # Get mptr, full member name, and sptr for the identifier we found.
        mpack = idaapi.get_member_by_id(ref)
        if mpack is None:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}.up({:#x}) : Unable to locate the member identified by {:#x}.".format(__name__, eid, ref))

        mptr, name, sptr = mpack
        if not interface.node.is_identifier(sptr.id):
            sptr = idaapi.get_member_struc(idaapi.get_member_fullname(mptr.id))

        # Verify the type of the mptr is correct so that we can use it.
        if not isinstance(mptr, idaapi.member_t):
            cls, name = self.__class__, idaapi.get_member_fullname(ref)
            raise E.InvalidTypeOrValueError(u"{:s}.up({:#x}) : Unexpected type {!s} returned for member \"{:s}\".".format(__name__, eid, mptr.__class__, internal.utils.string.escape(name, '"')))

        # Use the mptr identifier to determine if we're referencing a frame.
        frname, _ = name.split('.', 1)
        frid = internal.netnode.get(frname)
        ea = idaapi.get_func_by_frame(frid)

        # If we couldn't find a frame for it, then this is a structure member
        # and we can just grab it using the structure module.
        if ea == idaapi.BADADDR:
            st = structure.by_identifier(sptr.id)
            mem = st.members.by_identifier(mptr.id)
            res.append(mem)
            continue

        # Otherwise, we know that this is a a function frame and
        # we can just grab it using idaapi.get_frame. We also
        # need the idaapi.func_t for it to get the frame size.
        fr = idaapi.get_frame(ea)
        if fr is None:
            cls = self.__class__
            raise E.MissingTypeOrAttribute(u"{:s}.up({:#x}) : The function at {:#x} for frame member {:#x} does not have a frame.".format(__name__, eid, ea, mptr.id))

        f = idaapi.get_func(ea)
        if f is None:
            cls = self.__class__
            raise E.FunctionNotFoundError(u"{:s}.up({:#x}) : Unable to locate the function for frame member {:#x} by address {:#x}.".format(__name__, eid, mptr.id, ea))

        # Now that we have everything we need, we use the structure
        # module and the idaapi.func_t we fetched to instantiate the
        # structure with the correct offset and then fetch the member
        # to aggregate to our list of results.
        st = structure.by_identifier(fr.id, offset=-idaapi.frame_off_args(f))
        mem = st.members.by_identifier(mptr.id)
        res.append(mem)
    return res

def repr(enum):
    '''Return a printable summary of the enumeration `enum`.'''
    eid = by(enum)
    w, cmt = 2 * size(eid), comment(enum, repeatable=True) or comment(enum, repeatable=False)
    items = [(member.name(item), member.value(item), member.mask(item), member.comment(item, repeatable=True) or member.comment(item, repeatable=False)) for item in members.iterate(eid)]

    # Figure out the padding for each component belonging to a member of the
    # enumeration in order to keep them aligned properly when displaying them.
    maxindex = max(len("[{:d}]".format(index)) for index, _ in enumerate(items)) if items else 1
    maxname = max(len(name) for name, _, _, _ in items) if items else 0
    maxvalue = max(len("{:#{:d}x}".format(value, 2 + w)) for name, value, mask, _ in items) if items else 1
    maxbname = max(len(utils.string.of(idaapi.get_bmask_name(eid, mask)) if idaapi.get_bmask_name(eid, mask) else u'') for name, value, mask, _ in items) if items else 0

    # If the enumeration is a bitfield, then make sure to include the bitmask and
    # its name if one was defined.
    if bitfield(eid):
        iterable = (u"{:<{alignindex:d}s} {:<{alignname}s} : {:#0{alignvalue}x} & {:<{alignmask:d}s}".format(u"[{:d}]".format(i), name, value, u"{:s}({:#0{:d}x})".format(utils.string.of(idaapi.get_bmask_name(eid, bmask)), bmask, maxvalue) if utils.string.of(idaapi.get_bmask_name(eid, bmask)) else u"{:#0{:d}x}".format(bmask, maxvalue), alignindex=maxindex, alignname=maxname, alignvalue=maxvalue, alignmask=(maxbname + 2 if maxbname else 0) + maxvalue) + (u" // {:s}".format(comment) if comment else u'') for i, (name, value, bmask, comment) in enumerate(items))

    # Otherwise, we just need to emit each member with its comment added to the end.
    else:
        iterable = (u"{:<{alignindex:d}s} {:<{alignname}s} : {:#0{alignvalue}x}".format(u"[{:d}]".format(i), name, value, alignindex=maxindex, alignname=maxname, alignvalue=maxvalue) + (u" // {:s}".format(comment) if comment else u'') for i, (name, value, bmask, comment) in enumerate(items))

    # Return our newline-joined result to the caller. If it's a bitfield, then we need
    # to include the length for " & " in the calculation. Then, if the mask has a name,
    # then we also need to include the length for "()" in the resulting calculation.
    description = u"<type 'enum'> {:s}".format(name(eid))
    padding_mask = maxindex + 1 + maxname + 3 + maxvalue + 3 + maxvalue + (maxbname + 2 if maxbname else 0)
    padding_enum = maxindex + 1 + maxname + 3 + maxvalue

    # Now that we've figured out our header, format it and then join it together with
    # each item belonging to the enumeration/bitfield.
    header = "{:<{padding}s}{:s}".format(description, u" // {:s}".format(cmt) if cmt else u'', padding=padding_mask if bitfield(eid) else padding_enum)
    return u'\n'.join(itertools.chain([header], iterable))

__matcher__ = utils.matcher()
__matcher__.attribute('index', idaapi.get_enum_idx)
__matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_enum_name, utils.string.of)
__matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_enum_name, utils.string.of)
__matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), idaapi.get_enum_name, utils.string.of)
__matcher__.boolean('bitfield', operator.eq, bitfield)
__matcher__.attribute('id')
__matcher__.attribute('identifier')
__matcher__.predicate('pred')
__matcher__.predicate('predicate')

def __iterate__():
    '''Yield the identifier of each enumeration within the database.'''
    for item in range(idaapi.get_enum_qty()):
        yield idaapi.getn_enum(item)
    return

@utils.string.decorate_arguments('regex', 'like', 'name')
def iterate(**type):
    '''Iterate through all of the enumerations in the database that match the keyword specified by `type`.'''
    if not type: type = {'predicate': lambda item: True}
    listable = [item for item in __iterate__()]
    for key, value in type.items():
        listable = [item for item in __matcher__.match(key, value, listable)]
    for item in listable: yield item

@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string')
def list(string):
    '''List any enumerations that match the glob in `string`.'''
    return list(like=string)
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def list(**type):
    '''List all of the enumerations within the database that match the keyword specified by `type`.'''
    res = [item for item in iterate(**type)]

    maxindex = max(builtins.map(idaapi.get_enum_idx, res) if res else [1])
    maxname = max(builtins.map(utils.fcompose(idaapi.get_enum_name, len), res) if res else [0])
    maxsize = max(builtins.map(size, res) if res else [0])
    cindex = utils.string.digits(maxindex, 10)
    try: cmask = max(len("{:x}".format(mask(item))) for item in res) if res else database.config.bits() / 4.0
    except Exception: cmask = 0
    has_bitfield = any(map(bitfield, res)) if res else False

    for item in res:
        name, bitfieldQ = idaapi.get_enum_name(item), bitfield(item)
        if bitfieldQ:
            six.print_(u"{:<{:d}s} {:>{:d}s} & {:<#{:d}x} ({:d} members){:s}".format("[{:d}]".format(idaapi.get_enum_idx(item)), 2 + math.trunc(cindex), utils.string.of(name), maxname, mask(item), 2 + math.trunc(cmask), len(builtins.list(members(item))), u" // {:s}".format(comment(item)) if comment(item) else u''))
        else:
            six.print_(u"{:<{:d}s} {:>{:d}s}{:s} ({:d} members){:s}".format("[{:d}]".format(idaapi.get_enum_idx(item)), 2 + math.trunc(cindex), utils.string.of(name), maxname, ' '*(3 + 2 + math.trunc(cmask)) if has_bitfield else u'', len(builtins.list(members(item))), u" // {:s}".format(comment(item)) if comment(item) else u''))
        continue
    return

## members
class members(object):
    """
    This namespace allows one to interact with the members belonging
    to an enumeration once the enumeration's id has been determined.
    This allows one to iterate through all of its members or add
    and remove values to the enumeration.

    By default this namespace will yield the names of all of the
    members of an enumeration.

    Some examples of using this namespace are::

        > eid = enum.by('example_enumeration')
        > mid = enum.members.add(eid, 'name', 0x1000)
        > ok = enum.members.remove(eid, mid)
        > mid = enum.members.by_name(eid, 'name')
        > mid = enum.members.by_value(eid, 0x1000)
        > for mid in enum.members.iterate(eid): ...
        > enum.members.list(e)

    """

    def __new__(cls, enum):
        """Yield the name, and value of each member from the enumeration `enum`.

        If the enumeration `enum` is a bitfield, then yield each member's name, value, and bitmask.
        """
        eid = by(enum)
        for mid in cls.iterate(eid):

            # If this enumeration is a bitfield, then we need to yield the name,
            # value, and bitmask for each member that's being returned.
            if bitfield(eid):
                yield member.name(mid), member.value(mid), member.mask(mid)

            # If it's just a regular enumeration, then we can just return the name and value.
            else:
                yield member.name(mid), member.value(mid)
            continue
        return

    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def has(cls, enum, name):
        '''Return whether the enumeration `enum` contains a member with the specified `name`.'''
        eid = by(enum)
        try:
            cls.by_name(eid, name)
        except E.MemberNotFoundError:
            return False
        return True
    @utils.multicase(value=six.integer_types)
    @classmethod
    def has(cls, enum, value, **bitmask):
        """Return whether the enumeration `enum` contains a member with the specified `value`.

        If an integral is provided for `bitmask` or `serial`, then only return true if the member is within the specified bitmask, or uses the provided serial.
        """
        eid = by(enum)
        iterable = (mid for mid in cls.iterate(eid))
        iterable = ((member.value(mid), member.mask(mid), member.serial(mid)) for mid in iterable)
        for item, mask, cid in iterable:
            if (item, mask) == (value, bitmask.get('bitmask', idaapi.DEFMASK)):
                if bitmask['serial'] == cid if 'serial' in bitmask else True:
                    return True
                continue
            continue
        return False

    ## scope
    @classmethod
    @utils.string.decorate_arguments('name')
    def add(cls, enum, name, value, **bitmask):
        """Add an enumeration member `name` with the specified `value` to the enumeration `enum`.

        If the integral, `bitmask`, is specified then use it as the bitmask for the enumeration.
        """
        eid = by(enum)
        bmask = bitmask.get('bitmask', idaapi.DEFMASK)

        fullname = interface.tuplename(name) if isinstance(name, tuple) else name
        string = utils.string.to(fullname)
        ok = idaapi.add_enum_member(eid, string, value, bmask)

        err = {getattr(idaapi, item) : item for item in ['ENUM_MEMBER_ERROR_NAME', 'ENUM_MEMBER_ERROR_VALUE', 'ENUM_MEMBER_ERROR_ENUM', 'ENUM_MEMBER_ERROR_MASK', 'ENUM_MEMBER_ERROR_ILLV']}
        if ok in err.keys():
            raise E.DisassemblerError(u"{:s}.add({!r}, {!s}, {:#x}{:s}) : Unable to add a member to the enumeration ({:#x}) with the specified name ({!s}) and value ({:#x}) due to error {:s}({:d}).".format('.'.join([__name__, cls.__name__]), enum, utils.string.repr(name), value, u", {:s}".format(utils.string.kwargs(bitmask)) if bitmask else u'', eid, utils.string.repr(fullname), value, err[ok], ok))
        return eid
    new = create = utils.alias(add, 'members')

    @classmethod
    @utils.multicase(mid=six.integer_types)
    def remove(cls, mid):
        '''Remove the member identified by `mid` from the enumeration that owns it.'''
        eid = member.parent(mid)
        return member.remove(mid)
    @classmethod
    @utils.multicase()
    def remove(cls, enum, member):
        '''Remove the specified `member` of the enumeration `enum`.'''
        eid = by(enum)
        mid = cls.by(eid, member)
        value, serial, mask = idaapi.get_enum_member_value(mid), idaapi.get_enum_member_serial(mid), idaapi.get_enum_member_bmask(mid)
        ok = idaapi.del_enum_member(eid, value, serial, mask)
        if not ok:
            raise E.DisassemblerError(u"{:s}.remove({!r}, {!r}) : Unable to remove the specified member ({:#x}) having the value {:d} from the enumeration ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, member, mid, value, eid))
        return ok
    delete = destroy = utils.alias(remove, 'members')

    ## aggregations
    @classmethod
    def names(cls, enum):
        '''Return a set of all the names belonging to the enumeration `enum`.'''
        eid = by(enum)
        return { member.name(mid) for mid in cls.iterate(eid) }

    @classmethod
    def values(cls, enum):
        """Return a set of all the values belonging to the enumeration `enum`.

        If the enumeration is a bitfield, then each item in the result is the value and its bitmask.
        """
        eid = by(enum)
        if bitfield(eid):
            return { (member.value(mid), member.mask(mid)) for mid in cls.iterate(eid) }
        return { member.value(mid) for mid in cls.iterate(eid) }

    @classmethod
    def mapping(cls, enum):
        '''Return a dictionary mapping all the values values to their names for the enumeration `enum`.'''
        eid = by(enum)
        return { member.value(mid) : member.name(mid) for mid in cls.iterate(eid) }

    ## searching
    @classmethod
    def by_index(cls, enum, index):
        '''Return the member identifier for the member of the enumeration `enum` at the specified `index`.'''
        eid = by(enum)
        try:
            res = next(mid for i, mid in enumerate(cls.iterate(eid)) if i == index)
        except StopIteration:
            raise E.MemberNotFoundError(u"{:s}.by_index({!r}, {:d}) : Unable to locate the member at index {:d} of the specified enumeration ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, index, index, eid))
        return res

    @classmethod
    def by_identifier(cls, enum, mid):
        '''Return the member of the enumeration specified by `enum` and its `mid`.'''
        eid = by(enum)
        if member.parent(mid) != eid:
            raise E.MemberNotFoundError(u"{:s}.by_identifier({!r}, {:#x}) : Unable to locate a member in the enumeration ({:#x}) with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, mid, eid, mid))
        return mid

    @classmethod
    def by_value(cls, enum, value, **filters):
        """Return the member identifier for the member of the enumeration `enum` with the specified `value`.

        If the integrals, `bitmask` or `serial`, is specified then use them to filter the returned enumeration members.
        """
        eid  = by(enum)
        bitfieldQ = bitfield(eid)

        # First we need to figure out if this is a bitfield, because if
        # it is..then we need to figure out the masks to filter by.
        if bitfieldQ:
            results = [item for _, item in masks(eid)]

        # Otherwise, there's only one mask to search through, the DEFMASK.
        else:
            results = [idaapi.DEFMASK]

        # Now that we have all the masks, we need to figure out all of the
        # serial numbers for the desired value throughout all our masks.
        available = []
        for mask in results:

            # We start by getting the first serial number for the value
            # and mask. If we get a BADNODE, then we know it's not in this
            # mask and can skip to the next one.
            first = item, cid = mid, _ = idaapi.get_first_serial_enum_member(eid, value, mask)
            if item == idaapi.BADNODE:
                continue
            available.append((item, mask, cid))

            # Now we can get the id and serial number for the last value
            # and mask. If it matches to the first, then we can add it to
            # our results and proceed to the next mask continuing our search.
            last = idaapi.get_last_serial_enum_member(eid, value, mask)
            if first == last:
                continue

            # Otherwise, we need continue through all of the serials for
            # the value and add every single one of them before continuing.
            while [item, cid] != idaapi.get_last_serial_enum_member(eid, value, mask):
                item, cid = idaapi.get_next_serial_enum_member(mid, cid) if idaapi.__version__ < 7.0 else idaapi.get_next_serial_enum_member(cid, mid)
                if item == idaapi.BADNODE:
                    break
                available.append((item, mask, cid))
            continue

        # We should now have a list of all possible values in our results,
        # and we need to figure out whether we need to filter them. If it's
        # a bitfield, then we need to filter them according to the mask the
        # user has given us. If they haven't given us one, then we'll still
        # just process what we have because we might've actually found it.
        bitmask = filters.get('bitmask', idaapi.DEFMASK)
        if bitfieldQ and 'bitmask' in filters:
            filtered = [(item, mask, cid) for item, mask, cid in available if mask in {bitmask}]

        # Otherwise we just take everything from the matched so that way we
        # can do filter for the serial if the caller gave it to us.
        else:
            filtered = [(item, mask, cid) for item, mask, cid in available]

        # Next we need to check to see if the user gave us a serial to filter
        # our results. So we check our parameters, and then gather our results.
        serial = filters.get('serial', 0)
        if 'serial' in filters:
            results = [(item, mask, cid) for item, mask, cid in filtered if cid in {serial}]

        # Otherwise we now have our results ready to return to the caller.
        else:
            results = filtered[:]

        # If our results are empty, then we were unable to find what the user
        # was looking for and thus we need to let them know what's up.
        if not results:
            raise E.MemberNotFoundError(u"{:s}.by_value({!r}, {:#x}{:s}) : Unable to locate a member in the enumeration ({:#x}) with the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, value, u", {:s}".format(utils.string.kwargs(filters)) if filters else u'', eid, value))

        # If we found more than one result, then we need to grab all the fields
        # that we plan on emitting so that we can just let the user know what
        # was found when raising our exception.
        elif len(results) > 1:
            iterable = ((mid, mask, cid, utils.string.of(idaapi.get_bmask_name(eid, mask)) or u'', utils.string.of(idaapi.get_enum_member_name(mid)) or u'') for mid, mask, cid in results)
            spec = u"[{serial:d}] {name!s} {value:#0{:d}x} & {mask:s}".format if bitfieldQ else u"[{serial:d}] {name!s} {value:#0{:d}x}".format
            formatter = utils.fpartial(spec, 2 + 2 * size(eid))
            messages = (formatter(serial=cid, name=name, mask=u"{:s}({:#0{:d}x})".format(maskname, mask, 2 + 2 * size(eid)) if maskname else u"{:#0{:d}x}".format(mask, 2 + 2 * size(eid)), value=idaapi.get_enum_member_value(mid)) for mid, mask, cid, maskname, name in iterable)
            logging.fatal(u"{:s}.by_value({!r}, {:#x}{:s}) : Multiple members with varying bitmask or serial were found in the enumeration ({:#x}) for the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, value, u", {:s}".format(utils.string.kwargs(filters)) if filters else u'', eid, value))
            [ logging.warning(msg) for msg in messages ]
            if bitfieldQ:
                raise E.MemberNotFoundError(u"{:s}.by_value({!r}, {:#x}{:s}) : Multiple members with varying bitmask or serial were found in the enumeration ({:#x}) for the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, value, u", {:s}".format(utils.string.kwargs(filters)) if filters else u'', eid, value))
            raise E.MemberNotFoundError(u"{:s}.by_value({!r}, {:#x}{:s}) : Multiple members with different serial numbers were found in the enumeration ({:#x}) for the specified value ({:#x}).".format('.'.join([__name__, cls.__name__]), enum, value, u", {:s}".format(utils.string.kwargs(filters)) if filters else u'', eid, value))

        # Otherwise there was only one item found, so we just need to unpack it.
        res, = results
        mid, _, _ = res
        return mid
    byvalue = utils.alias(by_value, 'members')

    @classmethod
    @utils.string.decorate_arguments('name')
    def by_name(cls, enum, name):
        '''Return the member identifier for the member of the enumeration `enum` with the specified `name`.'''
        eid = by(enum)
        for mid in cls.iterate(eid):
            if name == member.name(mid):
                return mid
            continue
        raise E.MemberNotFoundError(u"{:s}.by_name({!r}, {!s}) : Unable to locate a member in the enumeration ({:#x}) with the specified name ({!s}).".format('.'.join([__name__, cls.__name__]), enum, utils.string.repr(name), eid, utils.string.repr(name)))
    byname = utils.alias(by_name, 'members')

    @utils.multicase(n=six.integer_types)
    @classmethod
    def by(cls, enum, n):
        '''Return the member belonging to `enum` identified by its index or id in `n`.'''
        return cls.by_identifier(enum, n) if interface.node.is_identifier(n) else cls.by_index(enum, n)
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name')
    def by(cls, enum, name):
        '''Return the member of the enumeration `enum` with the given `name`.'''
        return cls.by_name(enum, name)

    # FIXME: Implement a matcher class for enumeration members that can be used with .iterate and .list below.
    __member_matcher = utils.matcher()

    @classmethod
    def __iterate__(cls, eid):
        '''Iterate through all the members of the enumeration identified by `eid` and yield their values.'''

        # First we need to define a closure that iterates through all of the
        # values for the masks inside an enumeration. This is because IDA
        # gives us values, and we need to conver these values to identifiers.
        def values(eid, bitmask):

            # We start with the first enumeration member (or value), and
            # then yield it if there was no error while fetching it. If
            # there was, then we just continue onto the next mask.
            value = idaapi.get_first_enum_member(eid, bitmask)
            if value == idaapi.BADADDR:
                return
            yield value

            # Continue fetching and yielding values until we get to the
            # very last one of the enumeration.
            while value != idaapi.get_last_enum_member(eid, bitmask):
                value = idaapi.get_next_enum_member(eid, value, bitmask)
                yield value
            return

        # Now we need to iterate through all of the masks, feeding them
        # to our "values" closure. Then with the values we can iterate
        # through all of the serials, and use that to get each identifier.
        for bitmask in masks.iterate(eid):
            for value in values(eid, bitmask):

                # Start out with the first serial for the member. We compare
                # this against idaapi.BADNODE in order to determine if there
                # was nothing found and we need to continue to the next value.
                item, cid = mid, _ = idaapi.get_first_serial_enum_member(eid, value, bitmask)
                if item == idaapi.BADNODE:
                    continue
                yield mid

                # Now we should be able to loop until we get to the last serial
                # number while yielding each valid identifier that we receive.
                while [item, cid] != idaapi.get_last_serial_enum_member(eid, value, bitmask):
                    item, cid = idaapi.get_next_serial_enum_member(mid, cid) if idaapi.__version__ < 7.0 else idaapi.get_next_serial_enum_member(cid, mid)
                    if item == idaapi.BADNODE:
                        break
                    yield item
                continue
            continue
        return

    @classmethod
    def iterate(cls, enum):
        '''Iterate through all ids of each member associated with the enumeration `enum`.'''
        eid = by(enum)
        for item in cls.__iterate__(eid):
            yield item
        return

    @classmethod
    def list(cls, enum):
        '''List all the members belonging to the enumeration identified by `enum`.'''
        # FIXME: make this consistent with every other .list using the matcher class
        eid = by(enum)
        listable = [item for item in cls.iterate(eid)]
        maxindex = max(len("[{:d}]".format(index)) for index, _ in enumerate(listable)) if listable else 1
        maxvalue = max(builtins.map(utils.fcompose(member.value, "{:#x}".format, len), listable) if listable else [1])
        maxname = max(builtins.map(utils.fcompose(member.name, len), listable) if listable else [0])
        maxbname = max([len(utils.string.of(idaapi.get_bmask_name(eid, mask)) if idaapi.get_bmask_name(eid, mask) else u'') for mask in builtins.map(member.mask, listable)] if listable else [0])
        masksize = 2 * size(eid)

        # If this enumeration is a bitfield, then we need to consider the mask of
        # each enumeration member when writing them to the output.
        if bitfield(eid):
            for i, mid in enumerate(listable):
                bname = utils.string.of(idaapi.get_bmask_name(eid, member.mask(mid))) or u''
                cmt = member.comment(eid, mid, repeatable=True) or member.comment(eid, mid, repeatable=False)
                six.print_(u"{:<{:d}s} {:<{:d}s} {:#0{:d}x} & {:s}".format("[{:d}]".format(i), maxindex, member.name(mid), maxname, member.value(mid), maxvalue, u"{:s}({:#0{:d}x})".format(bname, member.mask(mid), 2 + masksize) if bname else "{:#0{:d}x}".format(member.mask(mid), 2 + masksize)) + (u" // {:s}".format(cmt) if cmt else u''))
            return

        # Otherwise this isn't a bitfield, and we don't need to worry about the mask.
        for i, mid in enumerate(listable):
            cmt = member.comment(eid, mid, repeatable=True) or member.comment(eid, mid, repeatable=False)
            six.print_(u"{:<{:d}s} {:<{:d}s} {:#0{:d}x}".format("[{:d}]".format(i), maxindex, member.name(mid), maxname, member.value(mid), maxvalue) + (u" // {:s}".format(cmt) if cmt else u''))
        return

class member(object):
    """
    This namespace allows one to interact with a member belonging
    to an enumeration once the enumeration's id has been determined.
    This allows one to modify the property of any one of an
    enumeration's members.

    Some examples of how to use this namespace can be::

        > eid = enum.by('example_enumeration')
        > mid = enum.members.by_value(eid, 0x1000)
        > oldname = enum.member.name(mid, 'somename')
        > oldvalue = enum.member.value(mid, 0x100)
        > oldcomment = enum.member.comment(mid, 'This is an example comment')
        > ok = enum.member.remove(mid)

    """
    @classmethod
    def parent(cls, mid):
        '''Return the id of the enumeration that owns the member `mid`.'''
        CONST_ENUM = -2
        return idaapi.get_enum_member_enum(mid)
    owner = utils.alias(parent, 'member')

    @classmethod
    def by(cls, mid):
        '''Return the enumeration member as specified by the provided `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.by({!s}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        eid = cls.parent(mid)
        return members.by_identifier(eid, mid)

    @utils.multicase(mid=six.integer_types)
    @classmethod
    def remove(cls, mid):
        '''Remove the enumeration member with the given `mid`.'''
        eid, value, serial, mask = cls.parent(mid), cls.value(mid), cls.serial(mid), cls.mask(mid)
        ok = idaapi.del_enum_member(eid, value, serial, mask)
        if not ok:
            raise E.DisassemblerError(u"{:s}.remove({:#x}) : Unable to remove the specified member ({:#x}) having the value {:d} from the enumeration ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid, value, eid))
        return ok
    @utils.multicase()
    @classmethod
    def remove(cls, enum, member):
        '''Remove the specified `member` of the enumeration `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.remove(mid)

    ## properties
    @utils.multicase(mid=six.integer_types)
    @classmethod
    def name(cls, mid):
        '''Return the name of the enumeration member `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.name({:#x}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        res = idaapi.get_enum_member_name(mid)
        return utils.string.of(res)
    @utils.multicase()
    @classmethod
    def name(cls, enum, member):
        '''Return the name of the enumeration `member` belonging to `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.name(mid)
    @utils.multicase(mid=six.integer_types, name=(six.string_types, tuple))
    @classmethod
    @utils.string.decorate_arguments('name')
    def name(cls, mid, name):
        '''Rename the enumeration member `mid` to `name`.'''
        fullname = interface.tuplename(*name) if isinstance(name, tuple) else name
        string = utils.string.to(fullname)
        res, ok = idaapi.get_enum_member_name(mid), idaapi.set_enum_member_name(mid, string)
        if not ok:
            raise E.DisassemblerError(u"{:s}.name({:#x}, {!s}) : Unable to set the name for the specified member ({:#x}) to {!s}.".format('.'.join([__name__, cls.__name__]), mid, utils.string.repr(name), mid, utils.string.repr(fullname)))
        return utils.string.of(res)
    @utils.multicase(name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name', 'suffix')
    def name(cls, enum, member, name, *suffix):
        '''Rename the enumeration `member` belonging to `enum` to `name`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        fullname = (name,) + suffix
        return cls.name(mid, fullname)

    @utils.multicase(mid=six.integer_types)
    @classmethod
    def comment(cls, mid, **repeatable):
        """Return the comment for the enumeration member `mid`.

        If the bool `repeatable` is specified, then return the repeatable comment.
        """
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.comment({:#x}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        res = idaapi.get_enum_member_cmt(mid, repeatable.get('repeatable', True))
        return utils.string.of(res)
    @utils.multicase()
    @classmethod
    def comment(cls, enum, member, **repeatable):
        '''Return the comment for the enumeration `member` belonging to `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.comment(mid, **repeatable)
    @utils.multicase(mid=six.integer_types, comment=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('comment')
    def comment(cls, mid, comment, **repeatable):
        """Set the comment for the enumeration member id `mid` to `comment`.

        If the bool `repeatable` is specified, then set the repeatable comment.
        """
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.comment({:#x}, {!s}{:s}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, utils.string.repr(comment), u", {:s}".format(utils.string.kwargs(repeatable)) if repeatable else u'', mid))
        string = utils.string.to(comment)
        res, ok = idaapi.get_enum_member_cmt(mid, repeatable.get('repeatable', True)), idaapi.set_enum_member_cmt(mid, string, repeatable.get('repeatable', True))
        if not ok:
            adjective = (u'repeatable' if repeatable.get('repeatable', True) else u'non-repeatable') if repeatable else u''
            raise E.DisassemblerError(u"{:s}.comment({:#x}, {!s}{:s})) : Unable to set the {:s}comment for the specified member ({:#x}) to {!s}.".format('.'.join([__name__, cls.__name__]), mid, utils.string.repr(comment), u", {:s}".format(utils.string.kwargs(repeatable)) if repeatable else u'', u" {:s}".format(adjective) if adjective else u'', mid, utils.string.repr(comment)))
        return utils.string.of(res)
    @utils.multicase(comment=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('comment')
    def comment(cls, enum, member, comment, **repeatable):
        '''Set the comment for the enumeration `member` belonging to `enum` to the string `comment`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.comment(mid, comment, **repeatable)
    @utils.multicase(none=None.__class__)
    @classmethod
    def comment(cls, enum, member, none, **repeatable):
        '''Remove the comment from the `member` belonging to the enumeration `enum`.'''
        return cls.comment(enum, member, none or u'', **repeatable)

    @utils.multicase(mid=six.integer_types)
    @classmethod
    def value(cls, mid):
        '''Return the value of the enumeration member `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.value({:#x}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        return idaapi.get_enum_member_value(mid)
    @utils.multicase()
    @classmethod
    def value(cls, enum, member):
        '''Return the value of the specified `member` belonging to the enumeration `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.value(mid)
    @utils.multicase(mid=six.integer_types, value=six.integer_types)
    @classmethod
    def value(cls, mid, value):
        '''Assign the integer specified by `value` to the enumeration member `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.value({:#x}, {:#x}{:s}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, value, u", {:s}".format(utils.string.kwargs(bitmask)) if bitmask else u'', mid))
        eid = cls.parent(mid)

        # Figure out the actual altval index that contains the value we want to modify
        CONST_VALUE, CONST_BMASK = -3, -6
        altidx_value, altidx_bmask = (idaapi.as_signed(item, utils.string.digits(idaapi.BADADDR, 2)) & idaapi.BADADDR for item in [CONST_VALUE, CONST_BMASK])

        # Fetch the mask for the enumeration, and then for the actual member. We don't
        # actually let the user modify the bitmask because it seems that IDA's bmask
        # enumeration api doesn't work in the same way when an enumeration member's
        # CONST_BMASK altval is modified.
        emask, bmask = pow(2, size(eid) * 8) - 1 if size(eid) else idaapi.DEFMASK, internal.netnode.alt.get(mid, altidx_bmask) - 1 if internal.netnode.alt.has(mid, altidx_bmask) else idaapi.DEFMASK
        altval_value = emask & value & bmask

        # Now we can grab the previous value, and then assign the new one. After the
        # assignment, we can then just return our result and be good to go.
        res, ok = idaapi.get_enum_member_value(mid), internal.netnode.alt.set(mid, altidx_value, altval_value)
        if not ok:
            raise E.DisassemblerError(u"{:s}.value({:#x}, {:#x}{:s}) : Unable to set the value for the specified member ({:#x}) to {:#x}{:s}.".format('.'.join([__name__, cls.__name__]), mid, value, u", {:s}".format(utils.string.kwargs(bitmask)) if bitmask else u'', mid, value, u" & {:#x}".format(bmask) if bmask else u''))
        return res
    @utils.multicase(value=six.integer_types)
    @classmethod
    def value(cls, enum, member, value, **bitmask):
        '''Set the `value` for the enumeration `member` belonging to `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.value(mid, value)

    @utils.multicase(mid=six.integer_types)
    @classmethod
    def serial(cls, mid):
        '''Return the serial of the enumeration member `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.serial({:#x}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        CONST_SERIAL = -7
        return idaapi.get_enum_member_serial(mid)
    @utils.multicase()
    @classmethod
    def serial(cls, enum, member):
        '''Return the serial of the enumeration `member` belonging to `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.serial(mid)

    @utils.multicase(mid=six.integer_types)
    @classmethod
    def mask(cls, mid):
        '''Return the bitmask for the enumeration member `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.mask({:#x}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        CONST_BMASK = -6
        return idaapi.get_enum_member_bmask(mid)
    @utils.multicase()
    @classmethod
    def mask(cls, enum, member):
        '''Return the bitmask for the enumeration `member` belonging to `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.mask(mid)

    @utils.multicase()
    @classmethod
    def refs(cls, mid):
        '''Return the `(address, opnum, type)` of all the instructions that reference the enumeration member `mid`.'''
        if not interface.node.is_identifier(mid):
            raise E.MemberNotFoundError(u"{:s}.mask({:#x}) : Unable to locate a member with the specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, mid))
        eid = cls.parent(mid)

        # Assign some constants that we'll use for verifying the references
        # available for each operand.
        NALT_ENUM0, NALT_ENUM1 = (getattr(idaapi, name, 0xb + idx) for idx, name in enumerate(['NALT_ENUM0', 'NALT_ENUM1']))
        Fnetnode, Fidentifier = (getattr(idaapi, api, utils.fidentity) for api in ['ea2node', 'node2ea'])

        # Check if there's an xref that points to the enumeration member
        # identifier. If there isn't one, then we return an empty list.
        X = idaapi.xrefblk_t()
        if not X.first_to(mid, idaapi.XREF_ALL):
            fullname = '.'.join([name(eid), cls.name(mid)])
            logging.warning(u"{:s}.refs({:#x}) : No references found to enumeration member {:s} ({:#x}).".format('.'.join([__name__, cls.__name__]), mid, fullname, mid))
            return []

        # As we were able to find at least one, iterate through any others
        # that we found whilst gathering the 3 attributes that we care about.
        refs = [(X.frm, X.iscode, X.type)]
        while X.next_to():
            refs.append((X.frm, X.iscode, X.type))

        # Now that we have a list of xrefs, we need to convert each element
        # into an internal.opref_t. We do this by figuring out which operand
        # the member is in for each address. We double-verify that the member
        # from the operand actually belongs to the enumeration.
        res = []
        for ea, _, t in refs:
            ops = ((opnum, internal.netnode.alt.get(Fnetnode(ea), altidx)) for opnum, altidx in enumerate([NALT_ENUM0, NALT_ENUM1]) if internal.netnode.alt.has(Fnetnode(ea), altidx))
            ops = (opnum for opnum, mid in ops if cls.parent(Fidentifier(mid)) == eid)
            res.extend(interface.opref_t(ea, int(opnum), interface.reftype_t.of(t)) for opnum in ops)
        return res

    @utils.multicase()
    @classmethod
    def refs(cls, enum, member):
        '''Returns the `(address, opnum, type)` of all the instructions that reference the enumeration `member` belonging to `enum`.'''
        eid = by(enum)
        mid = members.by(eid, member)
        return cls.refs(mid)

class masks(object):
    """
    This namespace allows one to interact with a masks that are within
    an enumeration with its "bitfield" flag set. This is a very basic
    namespace that provides some minor utilities to deal with the
    naming of the bitmasks in an enumeration.

    Some examples of how to use this namespace can be::

        > values = enum.masks('example_enumeration')
        > ok = enum.masks.has(eid, 'mask_name')
        > mask = enum.masks.by(eid, 'mask_name')
        > mask = enum.masks.by(eid, 0x1234)

    """
    def __new__(cls, enum):
        '''Iterate through all of the masks belonging to the enumeration `enum` and yield their name and value.'''
        eid = by(enum)
        for mask in cls.iterate(eid):
            yield cls.name(eid, mask), mask
        return

    @classmethod
    def has(cls, enum, mask):
        '''Return whether the enumeration `enum` uses the specified `mask`.'''
        eid = by(enum)
        return any(item == mask for item in cls.iterate(eid))

    @classmethod
    def __iterate__(cls, eid):
        '''Iterate through all of the masks available in the enumeration identified by `eid` and yield their values.'''
        bmask = idaapi.get_first_bmask(eid)
        yield idaapi.DEFMASK if bmask == idaapi.BADADDR else bmask

        # Now we can continue fetching and yielding the masks until
        # we get to an idaapi.BADADDR. That way we'll know we're done.
        while bmask != idaapi.get_last_bmask(eid):
            bmask = idaapi.get_next_bmask(eid, bmask)
            yield bmask
        return

    @classmethod
    def iterate(cls, enum):
        '''Iterate through all of the masks belonging to the enumeration `enum`.'''
        eid = by(enum)
        for item in cls.__iterate__(eid):
            yield item
        return

    @utils.multicase(mask=six.integer_types)
    @classmethod
    def name(cls, enum, mask):
        '''Return the name for the given `mask` belonging to the enumeration `enum`.'''
        eid = by(enum)
        res = idaapi.get_bmask_name(eid, mask)
        return utils.string.of(res) or ''
    @utils.multicase(mask=six.integer_types, name=(six.string_types, tuple))
    @classmethod
    @utils.string.decorate_arguments('name')
    def name(cls, enum, mask, name):
        '''Set the name for the `mask` belonging to the enumeration `enum` to the provided `name`.'''
        eid = by(enum)
        fullname = interface.tuplename(*name) if isinstance(name, tuple) else name
        string = utils.string.to(fullname)
        res, ok = idaapi.get_bmask_name(eid, mask), idaapi.set_bmask_name(eid, mask, string)
        if not ok:
            raise E.DisassemblerError(u"{:s}.name({!r}, {:#x}, {!s}) : Unable to rename the mask ({:#x}) for the specified enumeration ({:#x}) to {!s}.".format('.'.join([__name__, cls.__name__]), enum, mask, utils.string.repr(name), 2 + 2 * size(eid), eid, utils.string.repr(fullname)))
        return utils.string.of(res)
    @utils.multicase(mask=six.integer_types, name=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('name', 'suffix')
    def name(cls, enum, mask, name, *suffix):
        '''Set the name for the `mask` belonging to the enumeration `enum` to the provided `name`.'''
        eid = by(enum)
        fullname = (name,) + suffix
        return cls.name(eid, mask, fullname)

    @utils.multicase(mask=six.integer_types)
    @classmethod
    def comment(cls, enum, mask, **repeatable):
        """Return the comment for the `mask` belonging to the enumeration `enum`.

        If the bool `repeatable` is specified, then return the repeatable comment.
        """
        eid = by(enum)
        res = idaapi.get_bmask_cmt(eid, mask, repeatable.get('repeatable', True))
        return utils.string.of(res)
    @utils.multicase(mask=six.integer_types, comment=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('comment')
    def comment(cls, enum, mask, comment, **repeatable):
        """Set the comment for the `mask` belonging to the enumeration `enum` to `comment`.

        If the bool `repeatable` is specified, then set the repeatable comment.
        """
        eid = by(enum)
        string = utils.string.to(comment)
        res, ok = idaapi.get_bmask_cmt(eid, mask, repeatable.get('repeatable', True)), idaapi.set_bmask_cmt(eid, mask, string, repeatable.get('repeatable', True))
        if not ok:
            adjective = (u'repeatable' if repeatable.get('repeatable', True) else u'non-repeatable') if repeatable else u''
            raise E.DisassemblerError(u"{:s}.comment({!r}, {:#x}, {!s}, {:s}) : Unable to set the {:s}comment for the specified mask ({:#0{:d}x}) from the enumeration ({:#x}) to {!s}.".format('.'.join([__name__, cls.__name__]), enum, mask, utils.string.repr(comment), u", {:s}".format(utils.string.kwargs(repeatable)) if repeatable else u'', u" {:s}".format(adjective) if adjective else u'', mask, 2 + 2 * size(eid), eid, utils.string.repr(comment)))
        return utils.string.of(res)
    @utils.multicase(mask=six.integer_types, none=None.__class__)
    @classmethod
    def comment(cls, enum, mask, none, **repeatable):
        '''Remove the comment for the `mask` belonging to the enumeration `enum`.'''
        return cls.comment(enum, mask, none or u'', **repeatable)

    @classmethod
    def list(cls, enum):
        '''List all the masks belonging to the enumeration identified by `enum`.'''
        eid = by(enum)
        listable = [item for item in cls.iterate(eid)]

        maxindex = max(len("[{:d}]".format(index)) for index, _ in enumerate(listable)) if listable else 1
        maxname = max(len(cls.name(eid, mask)) for mask in listable) if listable else 0
        maxmask = max(listable) if listable else 1
        masksize = 2 * size(eid) if size(eid) else utils.string.digits(maxmask, 16)

        for i, mask in enumerate(listable):
            padding = 3 + maxname
            cmt = cls.comment(eid, mask, repeatable=True) or cls.comment(eid, mask, repeatable=False)
            item = u"{:<{:d}s} {:#0{:d}x}{:s}".format("[{:d}]".format(i), maxindex, mask, 2 + masksize, " : {:<{:d}s}".format(cls.name(eid, mask), maxname) if idaapi.get_bmask_name(eid, mask) else ' ' * padding)
            six.print_(item + (u" // {:s}".format(cmt) if cmt else u''))
        return

```

`base/function.py`:

```py
"""
Function module

This module exposes a number of tools that can be used on or in
a particular function. There are a couple of namespaces that can allow
one to interact with the different components that are available for
a function.

The base argument type for a number of the utilities within this module
is the ``idaapi.func_t``. This type is interchangeable with an address or
a name and either can be used to identify a function. Some of the tools
exposed in this module allow for one to modify comments, rename, or
determine the relationships between functions.

Some namespaces are provided for interacting with the different components
that IDA associates with each function. This can be used to navigate
to the different parts of a function. Some of the available namespaces
are ``type``, ``block``, ``chunk``, ``blocks``, ``chunks``, and ``frame``.
"""

import six, builtins

import functools, operator, itertools, types
import logging, string

import database, instruction, structure
import ui, internal
from internal import utils, interface, exceptions as E

import idaapi

## searching
@utils.multicase()
def by_address():
    '''Return the function at the current address.'''
    return by_address(ui.current.address())
@utils.multicase(ea=six.integer_types)
def by_address(ea):
    '''Return the function containing the address `ea`.'''
    ea = interface.address.within(ea)
    res = idaapi.get_func(ea)
    if res is None:
        raise E.FunctionNotFoundError(u"{:s}.by_address({:#x}) : Unable to locate function by address.".format(__name__, ea))
    return res
byaddress = utils.alias(by_address)

@utils.string.decorate_arguments('name')
def by_name(name):
    '''Return the function with the specified `name`.'''
    # convert the name into something friendly for IDA
    res = utils.string.to(name)

    # ask IDA to get its address
    ea = idaapi.get_name_ea(idaapi.BADADDR, res)
    if ea == idaapi.BADADDR:
        raise E.FunctionNotFoundError(u"{:s}.by_name({!r}) : Unable to locate function by name.".format(__name__, name))

    # now that we have its address, return the func_t
    res = idaapi.get_func(ea)
    if res is None:
        raise E.FunctionNotFoundError(u"{:s}.by_name({!r}) : Unable to locate function by address.".format(__name__, name))
    return res
byname = utils.alias(by_name)

@utils.multicase()
def by():
    '''Return the current function.'''
    return by_address(ui.current.address())
@utils.multicase(func=idaapi.func_t)
def by(func):
    '''Return the function identified by `func`.'''
    return func
@utils.multicase(ea=six.integer_types)
def by(ea):
    '''Return the function at the address `ea`.'''
    return by_address(ea)
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name')
def by(name):
    '''Return the function with the specified `name`.'''
    return by_name(name)
@utils.multicase(frame=idaapi.struc_t)
def by(frame):
    '''Return the function that owns the specified `frame`.'''
    if frame.props & idaapi.SF_FRAME:
        ea = idaapi.get_func_by_frame(frame.id)
        return by(ea)
    raise E.FunctionNotFoundError(u"{:s}.by({:#x}) : Unable to locate function using a structure that is not a frame.".format(__name__, frame.id))
@utils.multicase(frame=structure.structure_t)
def by(frame):
    '''Return the function that owns the specified `frame`.'''
    return by(frame.ptr)

# FIXME: implement a matcher class for func_t

@utils.multicase()
def offset():
    '''Return the offset from the base of the database for the current function.'''
    func = ui.current.function()
    return offset(func, 0)
@utils.multicase()
def offset(func):
    '''Return the offset from the base of the database for the function `func`.'''
    return offset(func, 0)
@utils.multicase(offset=six.integer_types)
def offset(func, offset):
    '''Return the offset from the base of the database for the function `func` and add the provided `offset` to it.'''
    ea = address(func)
    return database.address.offset(ea) + offset

## properties
@utils.multicase()
def comment(**repeatable):
    '''Return the comment for the current function.'''
    fn = ui.current.function()
    res = idaapi.get_func_cmt(fn, repeatable.get('repeatable', True))
    return utils.string.of(res)
@utils.multicase()
def comment(func, **repeatable):
    """Return the comment for the function `func`.

    If the bool `repeatable` is specified, then return the repeatable comment.
    """
    fn = by(func)
    res = idaapi.get_func_cmt(fn, repeatable.get('repeatable', True))
    return utils.string.of(res)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string')
def comment(string, **repeatable):
    '''Set the comment for the current function to `string`.'''
    fn = ui.current.function()
    return comment(fn, string, **repeatable)
@utils.multicase(none=None.__class__)
def comment(none, **repeatable):
    '''Remove the comment for the current function.'''
    fn = ui.current.function()
    return comment(fn, none or '', **repeatable)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string')
def comment(func, string, **repeatable):
    """Set the comment for the function `func` to `string`.

    If the bool `repeatable` is specified, then modify the repeatable comment.
    """
    fn = by(func)

    res, ok = comment(fn, **repeatable), idaapi.set_func_cmt(fn, utils.string.to(string), repeatable.get('repeatable', True))
    if not ok:
        raise E.DisassemblerError(u"{:s}.comment({:#x}, \"{:s}\"{:s}) : Unable to call `idaapi.set_func_cmt({:#x}, {!r}, {!s})`.".format(__name__, ea, utils.string.escape(string, '"'), u", {:s}".format(utils.string.kwargs(repeatable)) if repeatable else '', ea, utils.string.to(string), repeatable.get('repeatable', True)))
    return res
@utils.multicase(none=None.__class__)
def comment(func, none, **repeatable):
    """Remove the comment for the function `func`.

    If the bool `repeatable` is specified, then remove the repeatable comment.
    """
    return comment(func, none or '', **repeatable)

@utils.multicase()
def name():
    '''Return the name of the current function.'''
    return name(ui.current.address())
@utils.multicase()
def name(func):
    '''Return the name of the function `func`.'''
    get_name = functools.partial(idaapi.get_name, idaapi.BADADDR) if idaapi.__version__ < 7.0 else idaapi.get_name
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(0, MANGLED_UNKNOWN))
    MNG_LONG_FORM = getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)

    # check to see if it's a runtime-linked function
    rt, ea = interface.addressOfRuntimeOrStatic(func)
    if rt:
        name = get_name(ea)
        mangled_name_type_t = Fmangled_type(name)
        return utils.string.of(name) if mangled_name_type_t == MANGLED_UNKNOWN else utils.string.of(idaapi.demangle_name(name, MNG_LONG_FORM) or name)
        #return internal.declaration.demangle(res) if internal.declaration.mangledQ(res) else res
        #return internal.declaration.extract.fullname(internal.declaration.demangle(res)) if internal.declaration.mangledQ(res) else res

    # otherwise it's a regular function, so try and get its name in a couple of ways
    name = idaapi.get_func_name(ea)
    if not name: name = get_name(ea)
    if not name: name = idaapi.get_true_name(ea, ea) if idaapi.__version__ < 6.8 else idaapi.get_ea_name(ea, idaapi.GN_VISIBLE)

    # decode the string from IDA's UTF-8 and demangle it if we need to
    # XXX: how does demangling work with utf-8? this would be implementation specific, no?
    mangled_name_type_t = Fmangled_type(name)
    return utils.string.of(name) if mangled_name_type_t == MANGLED_UNKNOWN else utils.string.of(idaapi.demangle_name(name, MNG_LONG_FORM) or name)
    #return internal.declaration.demangle(res) if internal.declaration.mangledQ(res) else res
    #return internal.declaration.extract.fullname(internal.declaration.demangle(res)) if internal.declaration.mangledQ(res) else res
    #return internal.declaration.extract.name(internal.declaration.demangle(res)) if internal.declaration.mangledQ(res) else res
@utils.multicase(none=None.__class__)
def name(none, **flags):
    '''Remove the custom-name from the current function.'''
    # we use ui.current.address() instead of ui.current.function()
    # in case the user might be hovering over an import table
    # function and wanting to rename that instead.
    return name(ui.current.address(), none or '', **flags)
@utils.multicase(packed=tuple)
def name(packed, **flags):
    '''Set the name of the current function to the given `packed` name.'''
    return name(ui.current.address(), *packed, **flags)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def name(string, *suffix, **flags):
    '''Set the name of the current function to `string`.'''
    return name(ui.current.address(), string, *suffix, **flags)
@utils.multicase(none=None.__class__)
def name(func, none, **flags):
    '''Remove the custom-name from the function `func`.'''
    return name(func, none or '', **flags)
@utils.multicase(packed=tuple)
def name(func, packed, **flags):
    '''Set the name of the function `func` to the given `packed` name.'''
    return name(func, *packed, **flags)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def name(func, string, *suffix, **flags):
    """Set the name of the function `func` to `string`.

    If `flags` is specified, then use the specified value as the flags.
    If the boolean `listed` is specified, then specify whether to add the label to the Names list or not.
    """

    # combine name with its suffix
    res = (string,) + suffix
    string = interface.tuplename(*res)

    # figure out if address is a runtime or static function
    rt, ea = interface.addressOfRuntimeOrStatic(func)

    # set the default flags that we'll use based on whether the listed parameter was set.
    res = idaapi.SN_NOWARN | (0 if flags.get('listed', idaapi.is_in_nlist(ea)) else idaapi.SN_NOLIST)

    # if it's a runtime-linked function, then it's not a public name.
    if rt:
        flags.setdefault('flags', res | idaapi.SN_NON_PUBLIC)

    # if it's a static function, then we need to preserve its flags.
    else:
        res |= idaapi.SN_PUBLIC if idaapi.is_public_name(ea) else idaapi.SN_NON_PUBLIC
        res |= idaapi.SN_WEAK if idaapi.is_weak_name(ea) else idaapi.SN_NON_WEAK
        flags.setdefault('flags', res)

    # FIXME: mangle the name and shuffle it into the prototype if possible
    return database.name(ea, string, **flags)

@utils.multicase()
def prototype():
    '''Return the prototype of the current function if it has one.'''
    # use ui.current.address() instead of ui.current.function() to deal with import table entries
    return prototype(ui.current.address())
@utils.multicase()
def prototype(func):
    '''Return the prototype of the function `func` if it has one.'''
    rt, ea = interface.addressOfRuntimeOrStatic(func)
    funcname = database.name(ea) or name(ea)
    try:
        decl = internal.declaration.function(ea)
        idx = decl.find('(')
        res = "{result:s} {name:s}{parameters:s}".format(result=decl[:idx], name=funcname, parameters=decl[idx:])

    except E.MissingTypeOrAttribute:
        if not internal.declaration.mangledQ(funcname):
            raise
        return internal.declaration.demangle(funcname)
    return res

@utils.multicase()
def bounds():
    '''Return a tuple containing the bounds of the first chunk of the current function.'''
    fn = ui.current.function()
    return interface.range.bounds(fn)
@utils.multicase()
def bounds(func):
    '''Return a tuple containing the bounds of the first chunk of the function `func`.'''
    try:
        fn = by(func)
    except E.ItemNotFoundError:
        raise E.FunctionNotFoundError(u"{:s}.bounds({!r}) : Unable to find function at the given location.".format(__name__, func))
    return interface.range.bounds(fn)
range = utils.alias(bounds)

@utils.multicase()
def color():
    '''Return the color (RGB) of the current function.'''
    return color(ui.current.function())
@utils.multicase()
def color(func):
    '''Return the color (RGB) of the function `func`.'''
    fn, DEFCOLOR = by(func), 0xffffffff
    b, r = (fn.color&0xff0000)>>16, fn.color&0x0000ff
    return None if fn.color == DEFCOLOR else (r<<16) | (fn.color&0x00ff00) | b
@utils.multicase(none=None.__class__)
def color(func, none):
    '''Remove the color for the function `func`.'''
    fn, DEFCOLOR = by(func), 0xffffffff
    res, fn.color = fn.color, DEFCOLOR
    if not idaapi.update_func(fn):
        F, ea = idaapi.update_func, interface.range.start(fn)
        raise E.DisassemblerError(u"{:s}.color({:#x}, {!s}) : Unable to clear the color of the function at {:#x} with `{:s}({:#x})`.".format(__name__, ea, none, ea, '.'.join([F.__module__ or '', F.__name__]), ea))
    b, r = (res&0xff0000)>>16, res&0x0000ff
    return None if res == DEFCOLOR else (r<<16) | (res&0x00ff00) | b
@utils.multicase(rgb=six.integer_types)
def color(func, rgb):
    '''Set the color (RGB) of the function `func` to `rgb`.'''
    r, b = (rgb&0xff0000)>>16, rgb&0x0000ff
    fn, DEFCOLOR = by(func), 0xffffffff
    res, fn.color = fn.color, (b<<16) | (rgb&0x00ff00) | r
    if not idaapi.update_func(fn):
        F, ea = idaapi.update_func, interface.range.start(fn)
        raise E.DisassemblerError(u"{:s}.color({:#x}, {:#x}) : Unable to set the color of the function at {:#x} with `{:s}({:#x})`.".format(__name__, ea, rgb, ea, '.'.join([F.__module__ or '', F.__name__]), ea))
    b, r = (res&0xff0000)>>16, res&0x0000ff
    return None if res == DEFCOLOR else (r<<16) | (res&0x00ff00) | b
@utils.multicase(none=None.__class__)
def color(none):
    '''Remove the color from the current function.'''
    return color(ui.current.function(), None)

@utils.multicase()
def address():
    '''Return the address of the entrypoint for the current function.'''
    try:
        res = ui.current.function()
    except E.ItemNotFoundError:
        raise E.FunctionNotFoundError(u"{:s}.address({:#x}) : Unable to locate the current function.".format(__name__, ui.current.address()))
    return interface.range.start(res)
@utils.multicase()
def address(func):
    '''Return the address for the entrypoint belonging to the function `func`.'''
    return address(func, 0)
@utils.multicase(offset=six.integer_types)
def address(func, offset):
    '''Return the address for the entrypoint belonging to the function `func` and add the provided `offset` to it.'''
    res = by(func)
    return interface.range.start(res) + offset
top = addr = utils.alias(address)

@utils.multicase()
def bottom():
    '''Return the exit-points of the current function.'''
    return bottom(ui.current.function())
@utils.multicase()
def bottom(func):
    '''Return the exit-points of the function `func`.'''
    fn = by(func)
    fc = blocks.flowchart(fn, idaapi.FC_PREDS)
    exit_types = (
        interface.fc_block_type_t.fcb_ret,
        interface.fc_block_type_t.fcb_cndret,
        interface.fc_block_type_t.fcb_noret,
        interface.fc_block_type_t.fcb_enoret,
        interface.fc_block_type_t.fcb_error
    )
    return tuple(database.address.prev(interface.range.end(item)) for item in fc if item.type in exit_types)

@utils.multicase()
def marks():
    '''Return all the marks in the current function.'''
    return marks(ui.current.function())
@utils.multicase()
def marks(func):
    '''Return all the marks in the function `func`.'''
    fn, res = by(func), []
    for ea, comment in database.marks():
        try:
            if address(ea) == interface.range.start(fn):
                res.append((ea, comment))
        except E.FunctionNotFoundError:
            pass
        continue
    return res

## functions
@utils.multicase()
def new():
    '''Create a new function at the current address.'''
    return new(ui.current.address())
@utils.multicase(ea=six.integer_types)
def new(ea):
    '''Create a new function at the address specified by `ea`.'''
    start = interface.address.inside(ea)
    if not idaapi.add_func(start, idaapi.BADADDR):
        fullname = '.'.join([getattr(idaapi.add_func, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.add_func, attribute)])
        raise E.DisassemblerError(u"{:s}.new({:#x}) : Unable create a new function at the given address ({:#x}) with `{:s}`.".format(__name__, ea, start, fullname))
    ui.state.wait()
    return interface.range.bounds(by_address(start))
@utils.multicase(start=six.integer_types, end=six.integer_types)
def new(start, end):
    '''Create a new function from the address `start` until `end`.'''
    bounds = ea, stop = interface.bounds_t(*interface.address.within(start, end))
    if not idaapi.add_func(ea, stop):
        fullname = '.'.join([getattr(idaapi.add_func, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.add_func, attribute)])
        raise E.DisassemblerError(u"{:s}.new({:#x}, {:#x}) : Unable create a new function for the given boundaries ({:s}) with `{:s}`.".format(__name__, start, end, bounds, fullname))
    ui.state.wait()
    return interface.range.bounds(by_address(ea))
@utils.multicase(bounds=tuple)
def new(bounds):
    '''Create a new function using the specified `bounds`.'''
    start, end = bounds
    return new(start, end)

make = add = utils.alias(new)

@utils.multicase()
def remove():
    '''Remove the current function from the database.'''
    return remove(ui.current.function())
@utils.multicase()
def remove(func):
    '''Remove the function `func` from the database.'''
    fn = by(func)
    bounds = ea, _ = interface.range.bounds(fn)
    if not idaapi.del_func(ea):
        fullname = '.'.join([getattr(idaapi.del_func, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.del_func, attribute)])
        raise E.DisassemblerError(u"{:s}.remove({!r}) : Unable to delete the function at {:#x} ({:s}) with `{:s}`.".format(__name__, func, interface.range.start(fn), bounds, fullname))
    return bounds
@utils.multicase(bounds=tuple)
def remove(bounds):
    '''Remove the function specified by `bounds` from the database.'''
    ea, _ = bounds
    return remove(ea)

## chunks
class chunks(object):
    """
    This namespace is for interacting with the different chunks
    associated with a function. By default this namespace will yield
    the boundaries of each chunk associated with a function.

    Some of the ways to use this namespace are::

        > for l, r in function.chunks(): ...
        > for ea in function.chunks.iterate(ea): ...

    """
    @utils.multicase()
    def __new__(cls):
        '''Yield the bounds of each chunk within current function.'''
        return cls(ui.current.function())
    @utils.multicase()
    def __new__(cls, func):
        '''Yield the bounds of each chunk for the function `func`.'''
        fn = by(func)
        fci = idaapi.func_tail_iterator_t(fn, interface.range.start(fn))
        if not fci.main():
            raise E.DisassemblerError(u"{:s}.chunks({:#x}) : Unable to create an `idaapi.func_tail_iterator_t`.".format(__name__, interface.range.start(fn)))

        results = []
        while True:
            ch = fci.chunk()
            results.append(interface.range.bounds(ch))
            if not fci.next(): break
        return results

    @utils.multicase()
    @classmethod
    def iterate(cls):
        '''Iterate through all the instructions for each chunk in the current function.'''
        return cls.iterate(ui.current.function())
    @utils.multicase()
    @classmethod
    def iterate(cls, func):
        '''Iterate through all the instructions for each chunk in the function `func`.'''
        for start, end in cls(func):
            for ea in database.address.iterate(start, end):
                if database.type.is_code(ea):
                    yield ea
                continue
            continue
        return

    @utils.multicase()
    @classmethod
    def at(cls):
        '''Return an ``idaapi.range_t`` describing the bounds of the current function chunk.'''
        return cls.at(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, ea):
        '''Return an ``idaapi.range_t`` describing the bounds of the function chunk at the address `ea`.'''
        fn = by_address(ea)
        return cls.at(fn, ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, func, ea):
        '''Return an ``idaapi.range_t`` describing the bounds of the function chunk belonging to `func` at the address `ea`.'''
        fn = by(func)
        for left, right in cls(fn):
            if left <= ea < right:
                area = interface.bounds_t(left, right)
                return area.range()
            continue
        raise E.AddressNotFoundError(u"{:s}.at({:#x}, {:#x}) : Unable to locate the chunk for the given address ({:#x}) in function {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), ea, ea, interface.range.start(fn)))

    @utils.multicase()
    @classmethod
    def contains(cls):
        '''Returns True if the current function contains the current address in any of its chunks.'''
        return cls.contains(ui.current.function(), ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def contains(cls, ea):
        '''Returns True if the current function contains the address `ea` in any of its chunks.'''
        return cls.contains(ui.current.function(), ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def contains(cls, func, ea):
        '''Returns True if the function `func` contains the address `ea` in any of its chunks.'''
        try:
            fn, ea = by(func), interface.address.within(ea)

        # If the function is not found, or the address is out of bounds
        # then the address isn't contained in the function. Simple.
        except (E.FunctionNotFoundError, E.OutOfBoundsError):
            return False

        # If we didn't raise any exceptions, then grab all of the chunks
        # for the function that we determined.
        else:
            iterable = cls(fn)

        # Now we can just iterate through each chunk whilst checking the bounds.
        return any(start <= ea < end for start, end in iterable)

    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, reg, *regs, **modifiers):
        '''Yield each `(address, opnum, state)` within the current function that uses `reg` or any one of the registers in `regs`.'''
        return cls.register(ui.current.function(), reg, *regs, **modifiers)
    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, func, reg, *regs, **modifiers):
        """Yield each `(address, opnum, state)` within the function `func` that uses `reg` or any one of the registers in `regs`.

        If the keyword `write` is True, then only return the result if it's writing to the register.
        """
        iterops = interface.regmatch.modifier(**modifiers)
        uses_register = interface.regmatch.use( (reg,) + regs )

        for ea in cls.iterate(func):
            for opnum in iterops(ea):
                if uses_register(ea, opnum):
                    items = ea, opnum, instruction.op_state(ea, opnum)
                    yield interface.opref_t(*items)
            continue
        return

    @utils.multicase()
    @classmethod
    def points(cls):
        '''Yield the `(address, delta)` for each stack point where the delta changes in the current function.'''
        return cls.points(ui.current.function())
    @utils.multicase()
    @classmethod
    def points(cls, func):
        '''Yield the `(address, delta)` for each stack point where the delta changes in the function `func`.'''
        fn = by(func)
        for ch, _ in cls(fn):
            for ea, delta in chunk.points(fn, ch):
                yield ea, delta
            continue
        return
    stackpoints = utils.alias(points, 'chunks')

iterate = utils.alias(chunks.iterate, 'chunks')
contains = utils.alias(chunks.contains, 'chunks')
register = utils.alias(chunks.register, 'chunks')

class chunk(object):
    """
    This namespace is for interacting with a specific chunk belonging
    to a function. By default this namespace will return the bounds of
    the chunk containing the requested address.

    The functions in this namespace can be used as::

        > l, r = function.chunk(ea)
        > ea = function.chunk.top()
        > function.chunk.add(function.by(), 0x401000, 0x402000)
        > function.chunk.remove(ea)

    """
    @utils.multicase()
    def __new__(cls):
        '''Return a tuple containing the bounds of the function chunk at the current address.'''
        return cls(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    def __new__(cls, ea):
        '''Return a tuple containing the bounds of the function chunk at the address `ea`.'''
        area = cls.at(ea, ea)
        return interface.range.bounds(area)

    @utils.multicase()
    @classmethod
    def owner(cls):
        '''Return the primary owner of the function chunk containing the current address.'''
        return cls.owner(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def owner(cls, ea):
        '''Return the primary owner of the function chunk containing the address specified by `ea`.'''
        if within(ea):
            return next(item for item in cls.owners(ea))
        raise E.FunctionNotFoundError(u"{:s}.owner({:#x}) : Unable to locate a function at the specified address ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, ea))
    @utils.multicase(bounds=tuple)
    @classmethod
    def owner(cls, bounds):
        '''Return the primary owner of the function chunk specified by `bounds`.'''
        ea, _ = bounds
        return cls.owner(ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def owner(cls, ea, func):
        '''Set the primary owner of the chunk at `ea` to the function `func`.'''
        ea, fn = interface.address.within(ea), by(func)
        result, ok = cls.owner(ea), idaapi.set_tail_owner(fn, ea)
        if not ok:
            fullname = '.'.join([getattr(idaapi.set_tail_owner, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.set_tail_owner, attribute)])
            raise E.DisassemblerError(u"{:s}.owner({#x}, {!r}) : Unable to modify the owner of the chunk at {:#x} to the given function ({:#x}) with `{:s}`.".format('.'.join([__name__, cls.__name__]), ea, func, ea, interface.range.start(fn), fullname))
        return result
    @utils.multicase(bounds=tuple)
    @classmethod
    def owner(cls, bounds, func):
        '''Set the primary owner of the chunk specified by `bounds` to the function `func`.'''
        ea, _ = bounds
        return cls.owner(ea, func)

    @utils.multicase()
    @classmethod
    def owners(cls):
        '''Yield each of the owners which have the current function chunk associated with it.'''
        ea = ui.current.address()
        return (item for item in cls.owners(ea))
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def owners(cls, ea):
        '''Yield each of the owners which have the function chunk containing the address `ea` associated with it.'''
        res = idaapi.get_func(ea)

        # If we're not associated with a function, then we just leave. Otherwise,
        # we grab the function chunk for the requested address.
        if res is None:
            return

        # If we were unable to get the function chunk for the provided address,
        # then we can just return because there's nothing that owns it.
        ch = idaapi.get_fchunk(ea)
        if ch is None:
            raise internal.exceptions.DisassemblerError(u"{:s}.owners({:#x}) : Unable to read the chunk at {:#x} belonging to the function at {!s}.".format('.'.join([__name__, cls.__name__]), ea, ea, interface.range.bounds(res)))
        owner, bounds = map(interface.range.bounds, [res, ch])

        # If this is a function tail, then we need to iterate through the referers
        # for the chunk so that we can yield each address. Older versions of IDA
        # don't always give us an array, so we construct it if we don't get one.
        if ch.flags & idaapi.FUNC_TAIL:
            count, iterator = ch.refqty, idaapi.func_parent_iterator_t(ch)

            # Try and seek to the very first member of the iterator. This should
            # always succeed, so if it errors out then this is critical...but only
            # if our "refqty" is larger than 1. If it's less than 1, then we can
            # just warn the user..but we're gonna fall back to the func_t anyways.
            if not iterator.first():
                if count > 1:
                    raise internal.exceptions.DisassemblerError(u"{:s}.owners({:#x}) : Unable to seek to the first element of the `{:s}` for the function tail at {!s}.".format('.'.join([__name__, cls.__name__]), ea, iterator.__class__.__name__, bounds))

                # We should only have one single referrer to return. Just in case,
                # though, we return an empty list if our "refqty" is actually 0.
                logging.warning(u"{:s}.owners({:#x}) : Returning initial owner ({!s}) for the function tail at {!s} due to being unable to seek to the first element of the associated `{:s}`.".format('.'.join([__name__, cls.__name__]), ea, owner, bounds, iterator.__class__.__name__))
                referrers = [ea for ea, _ in ([owner] if count else [])]

            # Grab the first parent address. Afterwards we continue looping
            # whilst stashing parents in our list of referrers.
            else:
                referrers = [iterator.parent()]
                while iterator.next():
                    item = iterator.parent()
                    referrers.append(item)

            # That was easy enough, so now we just need to confirm that the
            # number of our referrers matches to the "refqty" of the chunk.
            if count != len(referrers):
                logging.warning(u"{:s}.owners({:#x}) : Expected to find {:d} referrer{:s} for the function tail at {!s}, but {:s}{:s} returned.".format('.'.join([__name__, cls.__name__]), ea, count, '' if count == 1 else 's', bounds, 'only ' if len(referrers) < count else '', "{:d} was".format(len(referrers)) if len(referrers) == 1 else "{:d} were".format(len(referrers))))

            # That was it, we just need to convert our results to an iterator.
            iterable = (ea for ea in referrers)

        # Otherwise, we just need to yield the function that owns this chunk.
        else:
            iterable = (ea for ea, _ in [owner])

        # We've collected all of our items, so iterate through what we've collected
        # and then yield them to the caller before returning.
        for ea in iterable:
            yield ea
        return

    @utils.multicase()
    @classmethod
    def iterate(cls):
        '''Iterate through all the instructions for the function chunk containing the current address.'''
        for ea in cls.iterate(ui.current.address()):
            yield ea
        return
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def iterate(cls, ea):
        '''Iterate through all the instructions for the function chunk containing the address ``ea``.'''
        start, end = cls(ea)
        for ea in database.address.iterate(start, end):
            if database.type.is_code(ea):
                yield ea
            continue
        return

    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, reg, *regs, **modifiers):
        '''Yield each `(address, opnum, state)` within the function chunk containing the current address which uses `reg` or any one of the registers in `regs`.'''
        return cls.register(ui.current.address(), reg, *regs, **modifiers)
    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, ea, reg, *regs, **modifiers):
        """Yield each `(address, opnum, state)` within the function chunk containing the address `ea` which uses `reg` or any one of the registers in `regs`.

        If the keyword `write` is True, then only return the result if it's writing to the register.
        """
        iterops = interface.regmatch.modifier(**modifiers)
        uses_register = interface.regmatch.use( (reg,) + regs )

        for ea in cls.iterate(ea):
            for opnum in filter(functools.partial(uses_register, ea), iterops(ea)):
                items = ea, opnum, instruction.op_state(ea, opnum)
                yield interface.opref_t(*items)
            continue
        return

    @utils.multicase()
    @classmethod
    def points(cls):
        '''Yield the `(address, delta)` for each stack point where the delta changes in the current function chunk.'''
        return cls.points(ui.current.function(), ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def points(cls, ea):
        '''Yield the `(address, delta)` for each stack point where the delta changes in the chunk containing the address `ea`.'''
        fn = by_address(ea)
        return cls.points(fn, ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def points(cls, func, ea):
        '''Yield the `(address, delta)` for each stack point where the delta changes in the chunk containing the address `ea` belonging to the function `func`.'''
        fn, ch = by(func), idaapi.get_fchunk(ea)

        # If we were unable to get the function chunk for the provided address,
        # then IDA didn't calculate any stack deltas for what was requested.
        if ch is None:
            return

        # If this is a function tail, then we need to use the function we got
        # to filter out just the desired addresses and get their stackpoints.
        if ch.flags & idaapi.FUNC_TAIL and hasattr(getattr(fn, 'points', None), '__getitem__'):
            Fcontains, owner = interface.range.bounds(ch).contains, fn

            # Now all we need to do is to grab all of the stack points for
            # the function, and filter them by our chunk's boundaries.
            points = (owner.points[index] for index in builtins.range(owner.pntqty))
            iterable = ((point.ea, point.spd) for point in points if Fcontains(point.ea))

        # A non-tail just requires us to iterate through the points stored in the
        # chunk, so we can yield the address and delta for each individual point.
        elif hasattr(ch, 'points') and hasattr(ch.points, '__getitem__'):
            points = (ch.points[index] for index in builtins.range(ch.pntqty))
            iterable = ((point.ea, point.spd) for point in points)

        # If we were completely unable to access the correct attributes, then we
        # need to do all of the work ourselves. We walk the entire function, filter
        # for deltas in our chunk, sort them, and then yield each of them one-by-one.
        else:
            spd, points = 0, {}
            for ea in chunks.iterate(fn):
                res = idaapi.get_spd(fn, ea)
                if res == spd:
                    continue
                points[ea], spd = res, spd

            filtered = filter(interface.range.bounds(ch).contains, points)
            iterable = ((ea, points[ea]) for ea in sorted(filtered))

        # We have our iterator of points, so all we need to do is to unpack each
        # one and yield it to our caller.
        for ea, spd in iterable:
            yield ea, spd
        return
    stackpoints = utils.alias(points, 'chunk')

    @utils.multicase()
    @classmethod
    def at(cls):
        '''Return an ``idaapi.range_t`` describing the bounds of the current function chunk.'''
        return cls.at(ui.current.function(), ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, ea):
        '''Return an ``idaapi.range_t`` describing the bounds of the function chunk at the address `ea`.'''
        fn = by_address(ea)
        return cls.at(fn, ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, func, ea):
        '''Return an ``idaapi.range_t`` describing the bounds of the function chunk belonging to `func` at the address `ea`.'''
        return chunks.at(func, ea)

    @utils.multicase()
    @classmethod
    def top(cls):
        '''Return the top address of the chunk at the current address.'''
        left, _ = cls()
        return left
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def top(cls, ea):
        '''Return the top address of the chunk at address `ea`.'''
        left, _ = cls(ea)
        return left
    @utils.multicase(ea=six.integer_types, address=six.integer_types)
    @classmethod
    def top(cls, ea, address):
        '''Change the top address of the chunk at address `ea` to the specified `address`.'''
        bounds = cls(ea)
        left, _ = bounds

        # Set the function start and return the previous top if we modified it successfully.
        result = idaapi.set_func_start(left, address)
        if result == idaapi.MOVE_FUNC_OK:
            return left

        # Otherwise we got an error code and we need to raise an exception.
        errors = {getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('MOVE_FUNC_')}
        raise E.DisassemblerError(u"{:s}.top({:#x}, {:#x}) : Unable to modify the top of the specified chunk with `idaapi.set_func_start({:#x}, {:#x})` due to error ({:s}).".format('.'.join([__name__, cls.__name__]), ea, address, left, address, errors.get(result, "{:#x}".format(result))))

    @utils.multicase()
    @classmethod
    def bottom(cls):
        '''Return the bottom address of the chunk at the current address.'''
        _, right = cls()
        return right
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def bottom(cls, ea):
        '''Return the bottom address of the chunk at address `ea`.'''
        _, right = cls(ea)
        return right
    @utils.multicase(ea=six.integer_types, address=six.integer_types)
    @classmethod
    def bottom(cls, ea, address):
        '''Change the bottom address of the chunk at address `ea` to the specified `address`.'''
        bounds = cls(ea)
        left, right = bounds
        if not idaapi.set_func_end(left, address):
            raise E.DisassemblerError(u"{:s}.bottom({:#x}, {:#x}) : Unable to modify the bottom of the specified chunk with `idaapi.set_func_end({:#x}, {:#x})`.".format('.'.join([__name__, cls.__name__]), ea, address, left, address))
        return right

    @utils.multicase()
    @classmethod
    def address(cls):
        '''Return the top address of the function chunk containing the current address.'''
        return cls.address(ui.current.address(), 0)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def address(cls, ea):
        '''Return the top address of the function chunk containing the address `ea`.'''
        return cls.address(ea, 0)
    @utils.multicase(ea=six.integer_types, offset=six.integer_types)
    @classmethod
    def address(cls, ea, offset):
        '''Return the address of the function chunk containing the address `ea` and add the provided `offset` to it.'''
        left, _ = cls(ea)
        return left + offset

    @utils.multicase()
    @classmethod
    def offset(cls):
        '''Return the offset from the base of the database for the current function chunk.'''
        return cls.offset(ui.current.address(), 0)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def offset(cls, ea):
        '''Return the offset from the base of the database for the function chunk containing the address `ea`.'''
        return cls.offset(ea, 0)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def offset(cls, ea, offset):
        '''Return the offset from the base of the database for the function chunk containing the address `ea` and add the provided `offset` to it.'''
        left, _ = cls(ea)
        return database.address.offset(left) + offset

    @utils.multicase(start=six.integer_types)
    @classmethod
    def add(cls, start):
        '''Add the chunk starting at the address `start` to the current function.'''
        return cls.add(ui.current.function(), start)
    @utils.multicase(bounds=tuple)
    @classmethod
    def add(cls, bounds):
        '''Add the chunk specified by `bounds` to the current function.'''
        return cls.add(ui.current.function(), bounds)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def add(cls, func, ea):
        '''Add the chunk starting at address `ea` to the function `func`.'''
        fn = by(func)
        start = interface.address.inside(ea)
        if not idaapi.append_func_tail(fn, start, idaapi.BADADDR):
            fullname = '.'.join([getattr(idaapi.append_func_tail, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.append_func_tail, attribute)])
            raise E.DisassemblerError(u"{:s}.add({!r}, {:#x}) : Unable add the chunk at the specified address ({:#x}) to the function at {:#x} with `{:s}`.".format('.'.join([__name__, cls.__name__]), func, ea, start, interface.range.start(fn), fullname))
        ui.state.wait()
        return cls(start)
    @utils.multicase(start=six.integer_types, end=six.integer_types)
    @classmethod
    def add(cls, func, start, end):
        '''Add the chunk from the address `start` until `end` to the function `func`.'''
        fn = by(func)
        ea, stop = bounds = interface.bounds_t(*interface.address.within(start, end))
        if not idaapi.append_func_tail(fn, ea, stop):
            fullname = '.'.join([getattr(idaapi.append_func_tail, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.append_func_tail, attribute)])
            raise E.DisassemblerError(u"{:s}.add({!r}, {:#x}, {:#x}) : Unable add the specified chunk ({:s}) to the function at {:#x} with `{:s}`.".format('.'.join([__name__, cls.__name__]), func, start, end, bounds, interface.range.start(fn), fullname))
        ui.state.wait()
        return cls(ea)
    @utils.multicase(bounds=tuple)
    @classmethod
    def add(cls, func, bounds):
        '''Add the chunk specified by `bounds` to the function `func`.'''
        start, end = bounds
        return cls.add(func, start, end)

    @utils.multicase()
    @classmethod
    def remove(cls):
        '''Remove the chunk containing the current address from its function.'''
        return cls.remove(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def remove(cls, ea):
        '''Remove the chunk at `ea` from its function.'''
        return cls.remove(ea, ea)
    @utils.multicase(bounds=tuple)
    @classmethod
    def remove(cls, bounds):
        '''Remove the chunk specified by `bounds` from its function.'''
        ea, _ = bounds
        return cls.remove(ea, ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def remove(cls, func, ea):
        '''Remove the chunk at `ea` from the function `func`.'''
        fn, ea = by(func), interface.address.within(ea)
        bounds = cls(ea)
        if not idaapi.remove_func_tail(fn, ea):
            fullname = '.'.join([getattr(idaapi.remove_func_tail, attribute) for attribute in ['__module__', '__name__'] if hasattr(idaapi.remove_func_tail, attribute)])
            raise E.DisassemblerError(u"{:s}.remove({!r}, {:#x}) : Unable to delete the chunk ({:s}) for the function at {:#x} with `{:s}`.".format('.'.join([__name__, cls.__name__]), func, ea, bounds, interface.range.start(fn), fullname))
        return bounds
    @utils.multicase(bounds=tuple)
    @classmethod
    def remove(cls, func, bounds):
        '''Remove the chunk specified by `bounds` from the function `func`.'''
        ea, _ = bounds
        return cls.remove(func, ea)
add_chunk, remove_chunk = utils.alias(chunk.add, 'chunk'), utils.alias(chunk.remove, 'chunk')

@utils.multicase()
def within():
    '''Return if the current address is within a function.'''
    return within(ui.current.address())
@utils.multicase(ea=six.integer_types)
def within(ea):
    '''Return if the address `ea` is within a function.'''
    try:
        ea = interface.address.within(ea)
    except E.OutOfBoundsError:
        return False
    return idaapi.get_func(ea) is not None and idaapi.segtype(ea) != idaapi.SEG_XTRN

class blocks(object):
    """
    This namespace is for interacting with all of the basic blocks within
    the specified function. By default this namespace will yield the
    boundaries of each basic block defined within the function.

    This namespace provides a small number of utilities that can be
    used to extract the basic blocks of a function and convert them
    into a flow-graph such as ``idaapi.FlowChart``, or a digraph as used
    by the ``networkx`` module.

    Due to ``idaapi.FlowChart`` and networkx's digraph being used so
    often, these functions are exported globally as ``function.flowchart``
    and ``function.digraph``.

    Some examples of this namespace's usage::

        > for bb in function.blocks(calls=False): ...
        > chart = function.blocks.flowchart(ea)
        > G = function.blocks.graph()

    """
    @utils.multicase()
    def __new__(cls, **external):
        '''Return the bounds of each basic block for the current function.'''
        return cls(ui.current.function(), **external)
    @utils.multicase()
    def __new__(cls, func, **external):
        '''Returns the bounds of each basic block for the function `func`.'''
        iterable = cls.iterate(func, **external)
        return [ interface.range.bounds(bb) for bb in iterable ]
    @utils.multicase(bounds=tuple)
    def __new__(cls, bounds, **external):
        '''Return each basic block contained within the specified `bounds`.'''
        (left, _), (_, right) = map(interface.range.unpack, map(cls.at, bounds))
        return cls(left, right + 1, **external)
    @utils.multicase()
    def __new__(cls, left, right, **external):
        """Returns each basic block contained between the addresses `left` and `right`.

        If `external` is true, then include all blocks that are a branch target despite being outside the function boundaries.
        If `split` is false, then do not allow a call instruction to split a block.
        """
        fn = by_address(left)

        # Define a closure that filters the basic-blocks within the given range.
        def filtered(left, right, iterable=cls.iterate(fn, **external)):
            for bb in cls.iterate(fn, **external):
                if interface.range.start(bb) >= left and interface.range.end(bb) < right:
                    yield interface.range.bounds(bb)
                continue
            return

        # Take the range we were given, and return it as a list.
        (left, _), (_, right) = map(interface.range.unpack, map(cls.at, [left, right]))
        return [ bounds for bounds in filtered(left, right) ]

    @utils.multicase()
    @classmethod
    def iterate(cls, **external):
        '''Return each ``idaapi.BasicBlock`` for the current function.'''
        return cls.iterate(ui.current.function(), **external)
    @utils.multicase()
    @classmethod
    def iterate(cls, func, **external):
        """Returns each ``idaapi.BasicBlock`` for the function `func`.

        If `external` is true, then include all blocks that are a branch target despite being outside the function boundaries.
        If `split` is false, then do not allow a call instruction to split a block.
        """
        FC_NOEXT, FC_CALL_ENDS = getattr(idaapi, 'FC_NOEXT', 2), getattr(idaapi, 'FC_CALL_ENDS', 0x20)
        fc_flags = external.pop('flags', idaapi.FC_PREDS)
        fc_flags |= 0 if any(external.get(item, False) for item in ['external', 'externals']) else FC_NOEXT
        fc_flags |= 0 if any(not external[item] for item in ['call', 'calls', 'split'] if item in external) else FC_CALL_ENDS
        return cls.iterate(func, fc_flags, **external)
    @utils.multicase(flags=six.integer_types)
    @classmethod
    def iterate(cls, func, flags, **silent):
        '''Returns each ``idaapi.BasicBlock`` from the flowchart built with the specified `flags` (``idaapi.FC_*``) for the function `func`.'''
        fn, FC_CALL_ENDS, has_calls = by(func), getattr(idaapi, 'FC_CALL_ENDS', 0x20), hasattr(idaapi, 'FC_CALL_ENDS')
        boundaries = [bounds for bounds in chunks(fn)]

        # iterate through all the basic-blocks in the flow chart and yield
        # each of them back to the caller. we need to ensure that the bounds
        # are actually contained by the function, so we collect this too.
        for bb in cls.flowchart(fn, flags):
            left, right = interface.range.unpack(bb)
            bounds = interface.range.bounds(bb)
            ea, _ = bounds

            # if we're unable to split up calls, then we need to traverse this
            # block so that we can figure out where we need to split.
            if not has_calls and flags & FC_CALL_ENDS:
                start, stop, locations = left, right, [ea for ea in block.iterate(bb) if instruction.type.is_call(ea)]
                for item in locations:
                    left, right = start, database.address.next(item)
                    yield idaapi.BasicBlock(bb.id, interface.range.pack(left, right), bb._fc)
                    start = right

                # if the addresses are diffrent, then we have one more block to yield.
                if start < stop:
                    yield idaapi.BasicBlock(bb.id, interface.range.pack(start, stop), bb._fc)

                # if they're the same and we didn't have to chop it up, then this is external.
                elif start == stop and not locations:
                    yield idaapi.BasicBlock(bb.id, interface.range.pack(start, stop), bb._fc)

            # if we've been asked to be silent, then just yield what we got.
            elif silent.get('silent', False):
                yield bb

            # unpack the boundaries of the basic block to verify it's in one
            # of them, so that way we can yield it to the user if so.
            elif any(start <= ea <= stop for start, stop in boundaries) and left != right:
                yield bb

            # otherwise warn the user about it just in case they're processing
            # them and are always expecting an address within the function.
            else:
                f, api, Flogging = interface.range.start(fn), idaapi.FlowChart, logging.warning if flags & idaapi.FC_NOEXT else logging.info
                Flogging(u"{:s}.iterate({:#x}, {:#x}{:s}) : The current block {!s} ({:s}) being returned by `{:s}` is outside the boundaries of the requested function ({:#x}).".format('.'.join([__name__, cls.__name__]), f, flags, ", {:s}".format(utils.string.kwargs(silent)) if silent else '', bb, bounds, '.'.join([api.__module__, api.__name__]), f))
                yield bb
            continue
        return

    @utils.multicase()
    @classmethod
    def walk(cls, **flags):
        '''Traverse each of the successor blocks starting from the beginning of the current function.'''
        fn = ui.current.function()
        return cls.traverse(fn, interface.range.start(fn), operator.methodcaller('succs'), **flags)
    @utils.multicase()
    @classmethod
    def walk(cls, func, **flags):
        '''Traverse each of the successor blocks starting from the beginning of the function `func`.'''
        fn = by(func)
        return cls.traverse(fn, interface.range.start(fn), operator.methodcaller('succs'), **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def walk(cls, func, ea, **flags):
        '''Traverse each of the successor blocks of the block identified by `ea` belonging to the function `func`.'''
        return cls.traverse(func, ea, operator.methodcaller('succs'), **flags)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def walk(cls, bb):
        '''Traverse each of the successor blocks from the ``idaapi.BasicBlock`` identified by `bb`.'''
        return cls.traverse(bb, operator.methodcaller('succs'))
    @utils.multicase()
    @classmethod
    def moonwalk(cls, **flags):
        '''Traverse each of the predecessor blocks for the current function starting with the block at the current address.'''
        ea = ui.current.address()
        return cls.traverse(ea, ea, operator.methodcaller('preds'), **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def moonwalk(cls, ea, **flags):
        '''Traverse each of the predecessor blocks for a function starting with the block at the address `ea`.'''
        return cls.traverse(ea, ea, operator.methodcaller('preds'), **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def moonwalk(cls, func, ea, **flags):
        '''Traverse each of the predecessor blocks from the block at address `ea` belonging to the function `func`.'''
        return cls.traverse(func, ea, operator.methodcaller('preds'), **flags)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def moonwalk(cls, bb):
        '''Traverse each of the predecessor blocks from the ``idaapi.BasicBlock`` identified by `bb`.'''
        return cls.traverse(bb, operator.methodcaller('preds'))

    @utils.multicase()
    @classmethod
    def traverse(cls, **flags):
        '''Traverse each of the successor blocks starting from the beginning of the current function.'''
        fn = ui.current.function()
        return cls.traverse(fn, interface.range.start(fn), operator.methodcaller('succs'), **flags)
    @utils.multicase(predicate=callable)
    @classmethod
    def traverse(cls, predicate, **flags):
        '''Traverse the blocks from the beginning of the current function until the callable `predicate` returns no more elements.'''
        fn = ui.current.function()
        return cls.traverse(fn, interface.range.start(fn), predicate, **flags)
    @utils.multicase(predicate=callable)
    @classmethod
    def traverse(cls, func, predicate, **flags):
        '''Traverse the blocks from the beginning of function `func` until the callable `predicate` returns no more elements.'''
        fn = by(func)
        ea = interface.range.start(fn)
        return cls.traverse(fn, ea, predicate, **flags)
    @utils.multicase(ea=six.integer_types, predicate=callable)
    @classmethod
    def traverse(cls, func, ea, predicate, **flags):
        '''Traverse the blocks of function `func` from the block given by `ea` until the callable `predicate` returns no more elements.'''
        fn = by(func)
        bb = cls.at(fn, ea, **flags)
        return cls.traverse(bb, predicate)
    @utils.multicase(bb=idaapi.BasicBlock, predicate=callable)
    @classmethod
    def traverse(cls, bb, predicate):
        '''Traverse the blocks of function `func` from the ``idaapi.BasicBlock`` given by `bb` until the callable `predicate` returns no more elements.'''
        visited = {item for item in []}

        # define a closure containing the core of our functionality.
        def Fchoose(item, items, bb=bb, visited=visited):
            if item is None:
                filtered = [bounds for bounds in items if bounds not in visited]
                if len(filtered) != len(items):
                    removed = [bounds for bounds in items if bounds in visited]
                    logging.warning(u"{:s}.traverse({!s}) : Discarded {:d} already visited block{:s} ({:s}) leaving only {:d} ({:s}) to choose a default from.".format('.'.join([__name__, cls.__name__]), bb, len(removed), '' if len(removed) == 1 else 's', ', '.join(map("{:s}".format, removed)), len(filtered), ', '.join(map("{:s}".format, filtered))))
                iterable = (choice for choice in filtered[:1])
            elif isinstance(item, six.integer_types):
                iterable = (choice for choice in choices if choice.contains(item))
            elif item in items:
                iterable = (choice for choice in [item])
            else:
                iterable = (choice for choice in [])

            # grab our result and error out if its an integer and didn't match a block.
            result = builtins.next(iterable, None)
            if result is None and isinstance(item, six.integer_types):
                message = 'any of the available blocks' if len(items) > 1 else 'the only available block'
                raise E.ItemNotFoundError(u"{:s}.traverse({!s}) : The specified address ({:#x}) is not within {:s} ({:s}).".format('.'.join([__name__, cls.__name__]), bb, item, message, ', '.join(map("{:s}".format, items))))

            # otherwise, it was something else, and we couldn't match it.
            elif result is None:
                item_descr = interface.bounds_t(*item) if isinstance(item, tuple) else "{!s}".format(item)
                message = 'is not one of the available choices' if len(items) > 1 else 'does not match the only available block'
                raise E.ItemNotFoundError(u"{:s}.traverse({!s}) : The specified block ({:s}) {:s} ({:s}).".format('.'.join([__name__, cls.__name__]), bb, item_descr, message, ', '.join(map("{:s}".format, items))))
            return result

        # start out with the basic-block we were given, and use it for each decision.
        available = {interface.range.bounds(bb) : bb}
        choices = [item for item in available]

        # continue while we still have choices to choose from.
        while len(choices):
            selected = (yield choices if len(choices) > 1 else choices[0])
            choice = Fchoose(selected, choices)
            items, _ = predicate(available[choice]), visited.add(choice)
            available = {interface.range.bounds(item) : item for item in items}
            choices = [item for item in available]
        return

    @utils.multicase()
    @classmethod
    def at(cls, **flags):
        '''Return the ``idaapi.BasicBlock`` at the current address in the current function.'''
        return cls.at(ui.current.function(), ui.current.address(), **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, ea, **flags):
        '''Return the ``idaapi.BasicBlock`` of address `ea` in the current function.'''
        fn = by_address(ea)
        return cls.at(fn, ea, **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, func, ea, **flags):
        '''Return the ``idaapi.BasicBlock`` in function `func` at address `ea`.'''
        FC_NOEXT, FC_CALL_ENDS = getattr(idaapi, 'FC_NOEXT', 2), getattr(idaapi, 'FC_CALL_ENDS', 0x20)
        fc_flags = flags.get('flags', idaapi.FC_PREDS | FC_NOEXT)
        fc_flags |= 0 if any(not flags[item] for item in ['call', 'calls', 'split'] if item in flags) else FC_CALL_ENDS
        return cls.at(func, ea, fc_flags)
    @utils.multicase(ea=six.integer_types, flags=six.integer_types)
    @classmethod
    def at(cls, func, ea, flags):
        '''Return the ``idaapi.BasicBlock`` with the specified `flags` (``idaapi.FC_*``) for function `func` at address `ea`.'''
        fn = by(func)
        for bb in cls.iterate(fn, flags):
            if interface.range.within(ea, bb):
                return bb
            continue
        raise E.AddressNotFoundError(u"{:s}.at({:#x}, {:#x}) : Unable to locate `idaapi.BasicBlock` for address {:#x} in the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), ea, ea, interface.range.start(fn)))
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def at(cls, bb):
        '''Return the ``idaapi.BasicBlock`` matching the boundaries identifed by `bb`.'''
        bounds = interface.range.bounds(bb)

        # try and grab the idaapi.qflow_chart_t out of bb.
        fcpath = map(operator.attrgetter, ['_fc', '_q'])
        try:
            fc = functools.reduce(lambda agg, item: item(agg), fcpath, bb)

        # if we can't get ahold of the flowchart, then we need to use
        # BasicBlock's address to find the function it's a part of.
        except AttributeError:
            fn = func.by(bounds.left)
            logging.warning(u"{:s}.at({!s}) : Unable to determine the flowchart from the provided `idaapi.BasicBlock` ({:s}) for function {:#x}.".format('.'.join([__name__, cls.__name__]), bounds, bounds, interface.range.start(fn)))
            return cls.at(fn, bb)

        # now we can extract the function and its flags to regenerate the flowchart.
        fn, flags = fc.pfn, fc.flags

        # regenerate the flowchart, and generate an iterator that gives us matching
        # blocks so that we can return the first one that matches.
        iterable = (item for item in cls.iterate(fn, flags) if bounds.left == interface.range.start(item) or bounds.contains(interface.range.start(item)))
        result = builtins.next(iterable, None)
        if result is None:
            raise E.ItemNotFoundError(u"{:s}.at({!s}) : Unable to locate the `idaapi.BasicBlock` for the given bounds ({:s}) in function {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), bounds, bounds, interface.range.start(fn)))
        return result
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def at(cls, func, bb):
        '''Return the ``idaapi.BasicBlock`` in function `func` identifed by `bb`.'''
        fn, bounds = by(func), interface.range.bounds(bb)

        # now we need to extract the flags from the fc if possible.
        path = map(operator.attrgetter, ['_fc', '_q', 'flags'])
        try:
            flags = functools.reduce(lambda agg, item: item(agg), path, bb)

        # warn the user about not being able to figure it out.
        except AttributeError:
            flags = idaapi.FC_PREDS | idaapi.FC_NOEXT
            logging.warning(u"{:s}.at({:#x}, {!s}) : Unable to determine the original flags for the `idaapi.BasicBlock` ({:s}) in function {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), interface.range.bounds(bb), interface.range.start(fn)))

        # regenerate the flowchart, and generate an iterator that gives
        # us matching blocks. then we can return the first one and be good.
        iterable = (item for item in cls.iterate(fn, flags) if bounds.left == interface.range.start(item) or bounds.contains(interface.range.start(item)))
        result = builtins.next(iterable, None)
        if result is None:
            raise E.ItemNotFoundError(u"{:s}.at({:#x}, {!s}) : Unable to locate the `idaapi.BasicBlock` for the given bounds ({:s}) in function {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), bounds, bounds, interface.range.start(fn)))
        return result

    @utils.multicase()
    @classmethod
    def flowchart(cls, **flags):
        '''Return an ``idaapi.FlowChart`` object for the current function.'''
        return cls.flowchart(ui.current.function(), **flags)
    @utils.multicase()
    @classmethod
    def flowchart(cls, func, **flags):
        '''Return an ``idaapi.FlowChart`` object for the function `func`.'''
        return cls.flowchart(func, flags.get('flags', idaapi.FC_PREDS))
    @utils.multicase(flags=six.integer_types)
    @classmethod
    def flowchart(cls, func, flags):
        '''Return an ``idaapi.FlowChart`` object built with the specified `flags` for the function `func`.'''
        fn = by(func)
        return idaapi.FlowChart(f=fn, flags=flags)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def flowchart(cls, bb):
        '''Return an ``idaapi.FlowChart`` object for the given ``idaapi.BasicBlock``.'''
        fcpath = map(operator.attrgetter, ['_fc', '_q'])

        # try and grab the idaapi.qflow_chart_t out of bb.
        try:
            fc = functools.reduce(lambda agg, item: item(agg), fcpath, bb)

        # if we couldn't get the flowchart, then there's nothing we can do.
        except AttributeError:
            bounds = interface.range.bounds(bb)
            raise E.InvalidTypeOrValueError(u"{:s}.at({!s}) : Unable to determine the flowchart from the provided `idaapi.BasicBlock` ({:s}).".format('.'.join([__name__, cls.__name__]), bounds, bounds))
        return fc

    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('And', 'Or')
    def select(cls, **boolean):
        '''Query the basic blocks of the current function for any tags specified by `boolean`'''
        return cls.select(ui.current.function(), **boolean)
    @utils.multicase(tag=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('tag', 'And', 'Or')
    def select(cls, tag, *Or, **boolean):
        '''Query the basic blocks of the current function for the specified `tag` and any others specified as `Or`.'''
        res = {tag} | {item for item in Or}
        boolean['Or'] = {item for item in boolean.get('Or', [])} | res
        return cls.select(ui.current.function(), **boolean)
    @utils.multicase(tag=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('tag', 'And', 'Or')
    def select(cls, func, tag, *Or, **boolean):
        '''Query the basic blocks of the function `func` for the specified `tag` and any others specified as `Or`.'''
        res = {tag} | {item for item in Or}
        boolean['Or'] = {item for item in boolean.get('Or', [])} | res
        return cls.select(func, **boolean)
    @utils.multicase(tag=(builtins.set, builtins.list))
    @classmethod
    @utils.string.decorate_arguments('tag', 'And', 'Or')
    def select(cls, func, tag, *Or, **boolean):
        '''Query the basic blocks of the function `func` for the specified `tag` and any others specified as `Or`.'''
        res = {item for item in tag} | {item for item in Or}
        boolean['Or'] = {item for item in boolean.get('Or', [])} | res
        return cls.select(func, **boolean)
    @utils.multicase()
    @classmethod
    @utils.string.decorate_arguments('And', 'Or')
    def select(cls, func, **boolean):
        """Query the basic blocks of the function `func` for any tags specified by `boolean`. Yields each basic block found along with the matching tags as a dictionary.

        If `And` contains an iterable then require the returned address contains them.
        If `Or` contains an iterable then include any other tags that are specified.
        """
        target, flags = by(func), getattr(idaapi, 'FC_NOEXT', 2) | getattr(idaapi, 'FC_CALL_ENDS', 0x20)

        # Turn all of our parameters into a dict of sets that we can iterate through.
        containers = (builtins.tuple, builtins.set, builtins.list)
        boolean = {key : {item for item in value} if isinstance(value, containers) else {value} for key, value in boolean.items()}

        # Grab the addresses that are actually tagged into a set, and then the basic
        # blocks in an ordered dictionary so that we can union them for our results.
        available = {ea for ea in internal.comment.contents.address(interface.range.start(target), target=interface.range.start(target))}
        order, iterable = [], ((item, interface.range.bounds(item)) for item in blocks.iterate(target, flags))
        results = {bounds.left : [order.append(bounds.left), item].pop(1) for item, bounds in iterable }

        # Now we just need to union both our tagged addresses with the ones which
        # are basic-blocks to get a list of the selected addresses.
        selected = {ea for ea in available} & {ea for ea in order}
        ordered = [ea for ea in order if ea in selected]

        # If nothing specific was queried, then iterate through our ordered
        # blocks and yield absolutely everything that we found.
        if not boolean:
            for ea in ordered:
                ui.navigation.analyze(ea)
                address = database.tag(ea)
                if address: yield interface.range.bounds(results[ea]), address
            return

        # Collect the tagnames being queried as specified by the user.
        Or, And = ({item for item in boolean.get(B, [])} for B in ['Or', 'And'])

        # Walk through every tagged address and cross-check it against the query.
        for ea in ordered:
            ui.navigation.analyze(ea)
            collected, address = {}, database.tag(ea)

            # Or(|) includes any of the tagnames that were selected.
            collected.update({key : value for key, value in address.items() if key in Or})

            # And(&) includes tags only if the address includes all of the specified tagnames.
            if And:
                if And & six.viewkeys(address) == And:
                    collected.update({key : value for key, value in address.items() if key in And})
                else: continue

            # If anything was collected (matched), then yield the block and the matching tags.
            if collected: yield interface.range.bounds(results[ea]), collected
        return

    @utils.multicase()
    @classmethod
    def digraph(cls):
        '''Return a ``networkx.DiGraph`` of the function at the current address.'''
        return cls.digraph(ui.current.function())
    @utils.multicase()
    @classmethod
    def digraph(cls, func, **flags):
        """Return a ``networkx.DiGraph`` of the function `func`.

        Requires the ``networkx`` module in order to build the graph.
        """
        fn, fcflags = by(func), flags.get('flags', idaapi.FC_PREDS | idaapi.FC_NOEXT | getattr(idaapi, 'FC_CALL_ENDS', 0x20))
        ea = interface.range.start(fn)

        # assign some default values and create some tools to use when creating the graph
        availableChunks = [item for item in chunks(ea)]

        # create digraph
        import networkx
        attrs = tag(ea)
        attrs.setdefault('__address__', ea)
        attrs.setdefault('__chunks__', availableChunks)

        # set some dot-related attributes
        attrs.setdefault('mode', 'hier')
        attrs.setdefault('splines', 'curved')
        attrs.setdefault('rankdir', 'TB')

        try:
            attrs.setdefault('__frame__', frame(fn))

        except E.MissingTypeOrAttribute:
            pass

        if color(fn) is not None:
            operator.setitem(attrs, '__color__', color(fn))

        G = networkx.DiGraph(name=name(ea), **attrs)

        # assign some default values, and create some tools to use when adding nodes
        empty = {item for item in []}
        fVisibleTags = lambda items: {tag for tag in items if not tag.startswith('__')}

        # create a node for each block in the flowchart
        nodes_iterable, edges_iterable = itertools.tee(cls.iterate(fn, fcflags), 2)
        for B in nodes_iterable:
            bounds = block(B)

            # check if the boundary is zero-sized and handle it differently if so.
            if bounds.size:
                items = [item for item in database.address.iterate(bounds)]
                last = database.address.prev(bounds.right)

            # as the boundaries are defining an empty basic-block, we only need
            # to find the one address that it's actually pointing to.
            else:
                items = [item for item in {bound for bound in bounds}]
                last, = items

            # figure out all of the tags in the list of addresses (items).
            tags = [database.tag(item) for item in items]

            # now we can continue to collect attributes to add to our graph.
            attrs = database.tag(bounds.left)
            comment = attrs.pop('', None)
            comment and attrs.setdefault('__comment__', comment)

            attrs.setdefault('__count__', len(items))
            attrs.setdefault('__bounds__', bounds)
            attrs.setdefault('__address__', bounds.left)
            attrs.setdefault('__edge__', last)
            attrs.setdefault('__size__', getattr(bounds, 'size', bounds.right - bounds.left))

            attrs.setdefault('__entry__', bounds.left == ea or not any(B.preds()))
            attrs.setdefault('__sentinel__', instruction.type.is_sentinel(last) or not any(B.succs()))
            attrs.setdefault('__conditional__', instruction.type.is_jxx(last))
            attrs.setdefault('__unconditional__', any(F(last) for F in [instruction.type.is_jmp, instruction.type.is_jmpi]))
            attrs.setdefault('__calls__', [ea for ea in items if instruction.type.is_call(ea)])

            attrs.setdefault('__chunk_index__', next((idx for idx, ch in enumerate(availableChunks) if ch.left <= bounds.left < ch.right), None))
            attrs.setdefault('__chunk_start__', bounds.left in {item.left for item in availableChunks})
            attrs.setdefault('__chunk_stop__', bounds.right in {item.right for item in availableChunks})

            if block.color(bounds) is not None:
                operator.setitem(attrs, '__color__', block.color(bounds))

            visibletags = [fVisibleTags(t) for t in tags]
            attrs.setdefault('__tags__', [item for item in functools.reduce(operator.or_, visibletags, empty)])

            # convert some of the attributes to dot
            operator.setitem(attrs, 'id', "{:#x}".format(bounds.left))

            if operator.contains(attrs, '__color__'):
                clr = attrs.pop('__color__')
                r, g, b = clr & 0x00ff0000 // 0x10000, clr & 0x0000ff00 // 0x100, clr & 0x000000ff // 0x1
                operator.setitem(attrs, 'color', "#{R:02x}{G:02x}{B:02x}".format(R=r, G=g, B=b))

            if attrs.get('__entry__', False):
                operator.setitem(attrs, 'rank', 'max')
                operator.setitem(attrs, 'shape', 'diamond')
                attrs.setdefault('__name__', database.name(bounds.left) or name(bounds.left))

            elif attrs.get('__sentinel__', False):
                operator.setitem(attrs, 'rank', 'min')
                operator.setitem(attrs, 'shape', 'box')

            else:
                operator.setitem(attrs, 'rank', 'same')

            operator.setitem(attrs, 'label', attrs.pop('__name__', "{:#x}<>{:#x}".format(bounds.left, bounds.right - 1)))

            # add the actual node
            G.add_node(bounds.left, **attrs)

        # for every single basic-block from the flowchart...
        for B in edges_iterable:

            # ...add an edge for its predecessors
            for Bp in B.preds():
                source, target = database.address.prev(interface.range.end(Bp)), interface.range.start(B)

                # FIXME: figure out some more default attributes to include
                attrs = {}
                if interface.range.end(Bp) == target:
                    operator.setitem(attrs, '__contiguous__', interface.range.end(Bp) == target)
                elif instruction.type.is_jxx(source):
                    operator.setitem(attrs, '__conditional__', True)
                elif instruction.type.is_jmp(source) or instruction.type.is_jmpi(source):
                    operator.setitem(attrs, '__unconditional__', True)
                else:
                    operator.setitem(attrs, '__branch__', instruction.type.is_branch(source))

                # add the dot attributes for the edge
                operator.setitem(attrs, 'dir', 'forward')

                if any(attrs.get(item, False) for item in ['__branch__', '__conditional__', '__unconditional__']):
                    attrs['label'] = instruction.mnem(source)

                # add the edge to the predecessor
                G.add_edge(interface.range.start(Bp), target, **attrs)

            # ...add an edge for its successors
            for Bs in B.succs():
                source, target = database.address.prev(interface.range.end(B)), interface.range.start(Bs)

                # FIXME: figure out some more default attributes to include
                attrs = {}
                if interface.range.end(B) == target:
                    operator.setitem(attrs, '__contiguous__', interface.range.end(B) == target)
                elif instruction.type.is_jxx(source):
                    operator.setitem(attrs, '__conditional__', True)
                elif instruction.type.is_jmp(source) or instruction.type.is_jmpi(source):
                    operator.setitem(attrs, '__unconditional__', True)
                else:
                    operator.setitem(attrs, '__branch__', instruction.type.is_branch(source))

                # add the dot attributes for the edge
                operator.setitem(attrs, 'dir', 'forward')

                if any(attrs.get(item, False) for item in ['__branch__', '__conditional__', '__unconditional__']):
                    attrs['label'] = instruction.mnem(source)

                # add the edge to the successor
                G.add_edge(interface.range.start(B), target, **attrs)
            continue
        return G
    graph = utils.alias(digraph, 'blocks')

    @utils.multicase(start=six.integer_types, exits=(six.integer_types, builtins.list, builtins.tuple, builtins.set))
    @classmethod
    def subgraph(cls, start, exits):
        '''Return a ``networkx.DiGraph`` subgraph of the current function from address `start` and terminating at any address in `exits`.'''
        return cls.subgraph(ui.current.function(), start, exits)
    @utils.multicase(start=six.integer_types, exits=(six.integer_types, builtins.list, builtins.tuple, builtins.set))
    @classmethod
    def subgraph(cls, func, start, exits):
        """Return a ``networkx.DiGraph`` subgraph of the function `func` from address `start` and terminating at any address in `exits`.

        Requires the ``networkx`` module in order to build the graph.
        """
        g, exits = cls.digraph(func), {item for item in exits} if hasattr(exits, '__iter__') else {exits}
        start_block = block(start).left
        exit_blocks = { item.left for item in map(block, exits) }

        # Generate the subgraph using nodes that are within the path the user specified.
        import networkx
        nodes = {ea for ea in g.nodes if networkx.has_path(g, start_block, ea) and any(networkx.has_path(g, ea, item) for item in exit_blocks)}
        G = g.subgraph(nodes)

        # Update the node attributes so that the entry and exits can still be used.
        [ operator.setitem(G.nodes[item], '__entry__', True) for item in [start_block] ]
        [ operator.setitem(G.nodes[item], '__sentinel__', not G.succ[item]) for item in G ]
        return G

    # XXX: Implement .register for filtering blocks
    # XXX: Implement .search for filtering blocks
flowchart = utils.alias(blocks.flowchart, 'blocks')
digraph = graph = utils.alias(blocks.digraph, 'blocks')

class block(object):
    """
    This namespace is for interacting with a single basic block
    belonging to a function. By default the bounds of the selected
    basic block will be returned. This bounds or an address within
    these bounds can then be used in other functions within this
    namespace.

    Some examples of this functionality can be::

        > B = function.block(ea)
        > bid = function.block.id()
        > c = function.block.color(ea, rgb)
        > print( function.block.before(ea) )
        > for ea in function.block.iterate(): print( database.disasm(ea) )
        > for ea, op, st in function.block.register('eax', read=1): ...
        > print( function.block.read().encode('hex') )
        > print( function.block.disasm(ea) )

    """
    @utils.multicase()
    @classmethod
    def at(cls, **flags):
        '''Return the ``idaapi.BasicBlock`` of the current address in the current function.'''
        return cls.at(ui.current.function(), ui.current.address(), **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, ea, **flags):
        '''Return the ``idaapi.BasicBlock`` of address `ea` in the current function.'''
        fn = by_address(ea)
        return cls.at(fn, ea, **flags)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def at(cls, func, ea, **flags):
        '''Return the ``idaapi.BasicBlock`` of address `ea` in the function `func`.'''
        return blocks.at(func, ea, **flags)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def at(cls, bb):
        '''Return the ``idaapi.BasicBlock`` of the basic block `bb`.'''
        return bb
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def at(cls, bounds, **flags):
        '''Return the ``idaapi.BasicBlock`` identified by `bounds`.'''
        left, _ = bounds
        return cls.at(left, **flags)

    @utils.multicase()
    @classmethod
    def id(cls):
        '''Return the block id of the current address in the current function.'''
        return cls.at(ui.current.function(), ui.current.address()).id
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def id(cls, ea):
        '''Return the block id of address `ea` in the current function.'''
        return cls.at(ea).id
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def id(cls, func, ea):
        '''Return the block id of address `ea` in the function `func`.'''
        return cls.at(func, ea).id
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def id(cls, bb):
        '''Return the block id of the basic block `bb`.'''
        return bb.id
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def id(cls, bounds):
        '''Return the block id of the basic block identified by `bounds`.'''
        return cls.at(bounds).id

    @utils.multicase()
    def __new__(cls, **flags):
        '''Returns the boundaries of the current basic block.'''
        return cls(ui.current.function(), ui.current.address(), **flags)
    @utils.multicase(ea=six.integer_types)
    def __new__(cls, ea, **flags):
        '''Returns the boundaries of the basic block at address `ea`.'''
        return cls(by_address(ea), ea, **flags)
    @utils.multicase(ea=six.integer_types)
    def __new__(cls, func, ea, **flags):
        '''Returns the boundaries of the basic block at address `ea` in function `func`.'''
        res = blocks.at(func, ea, **flags)
        return interface.range.bounds(res)
    @utils.multicase(ea=six.integer_types, flags=six.integer_types)
    def __new__(cls, func, ea, flags):
        '''Returns the boundaries of the basic block with the specified `flags` (``idaapi.FC_*``) at address `ea` in function `func`.'''
        res = blocks.at(func, ea, flags)
        return interface.range.bounds(res)
    @utils.multicase(bb=idaapi.BasicBlock)
    def __new__(cls, bb):
        '''Returns the boundaries of the basic block `bb`.'''
        return interface.range.bounds(bb)
    @utils.multicase(bounds=builtins.tuple)
    def __new__(cls, bounds, **flags):
        '''Return the boundaries of the basic block identified by `bounds`.'''
        left, _ = bounds
        return cls(left, **flags)

    @utils.multicase(ea=six.integer_types)
    @classmethod
    def contains(cls, ea):
        '''Return whether the address `ea` is within the current basic block.'''
        left, right = cls()
        return left <= ea < right
    @utils.multicase(address=six.integer_types, ea=six.integer_types)
    @classmethod
    def contains(cls, address, ea):
        '''Return whether the address `ea` is within the basic block at the specified `address`.'''
        left, right = cls(address)
        return left <= ea < right
    @utils.multicase(address=six.integer_types, ea=six.integer_types)
    @classmethod
    def contains(cls, func, address, ea):
        '''Return whether the address `ea` is within the basic block for the function `func` at the specified `address`.'''
        left, right = cls(func, address)
        return left <= ea < right
    @utils.multicase(bb=idaapi.BasicBlock, ea=six.integer_types)
    @classmethod
    def contains(cls, bb, ea):
        '''Return whether the address `ea` is within the basic block `bb`.'''
        left, right = cls(bb)
        return left <= ea < right
    @utils.multicase(bounds=builtins.tuple, ea=six.integer_types)
    @classmethod
    def contains(cls, bounds, ea):
        '''Return whether the address `ea` is within the basic block identified by `bounds`.'''
        left, right = cls(bounds)
        return left <= ea < right

    @utils.multicase()
    @classmethod
    def top(cls):
        '''Return the top address of the basic block at the current address.'''
        left, _ = cls()
        return left
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def top(cls, ea):
        '''Return the top address of the basic block at address `ea`.'''
        left, _ = cls(ea)
        return left
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def top(cls, bb):
        '''Return the top address of the basic block `bb`.'''
        left, _ = cls(bb)
        return left
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def top(cls, bounds):
        '''Return the top address of the basic block identified by `bounds`.'''
        left, _ = cls(bounds)
        return left
    address = addr = utils.alias(top, 'block')

    @utils.multicase()
    @classmethod
    def bottom(cls):
        '''Return the bottom address of the basic block at the current address.'''
        _, right = cls()
        return right
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def bottom(cls, ea):
        '''Return the bottom address of the basic block at address `ea`.'''
        _, right = cls(ea)
        return right
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def bottom(cls, bb):
        '''Return the bottom address of the basic block `bb`.'''
        _, right = cls(bb)
        return right
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def bottom(cls, bounds):
        '''Return the bottom address of the basic block identified by `bounds`.'''
        _, right = cls(bounds)
        return right

    @utils.multicase()
    @classmethod
    def address(cls):
        '''Return the top address for the basic block containing the current address.'''
        return cls.address(ui.current.address(), 0)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def address(cls, ea):
        '''Return the top address for the basic block containing the address `ea`.'''
        return cls.address(ea, 0)
    @utils.multicase(ea=six.integer_types, offset=six.integer_types)
    @classmethod
    def address(cls, ea, offset):
        '''Return the top address for the basic block containing the address `ea` and add the provided `offset` to it.'''
        left, _ = cls(ea)
        return left + offset

    @utils.multicase()
    @classmethod
    def offset(cls):
        '''Return the offset from the base of the database for the basic block at the current address.'''
        return cls.offset(ui.current.address(), 0)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def offset(cls, ea):
        '''Return the offset from the base of the database for the basic block at the address `ea`.'''
        return cls.offset(ea, 0)
    @utils.multicase(ea=six.integer_types, offset=six.integer_types)
    @classmethod
    def offset(cls, ea, offset):
        '''Return the offset from the base of the database for the basic block at address `ea` and add the provided `offset` to it.'''
        left, _ = cls(ea)
        return database.address.offset(left) + offset

    @utils.multicase()
    @classmethod
    def color(cls):
        '''Returns the color of the basic block at the current address.'''
        return cls.color(ui.current.address())
    @utils.multicase(none=None.__class__)
    @classmethod
    def color(cls, none):
        '''Removes the color of the basic block at the current address.'''
        return cls.color(ui.current.address(), None)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def color(cls, ea):
        '''Returns the color of the basic block at the address `ea`.'''
        bb = cls.at(ea)
        return cls.color(bb)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def color(cls, bb):
        '''Returns the color of the basic block `bb`.'''
        get_node_info = idaapi.get_node_info2 if idaapi.__version__ < 7.0 else idaapi.get_node_info

        fn, ni = by_address(interface.range.start(bb)), idaapi.node_info_t()
        ok = get_node_info(ni, interface.range.start(fn), bb.id)
        if ok and ni.valid_bg_color():
            res = ni.bg_color
            b, r = (res&0xff0000)>>16, res&0x0000ff
            return (r<<16) | (res&0x00ff00) | b
        return None
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def color(cls, bounds):
        '''Returns the color of the basic block identified by `bounds`.'''
        bb = cls.at(bounds)
        return cls.color(bb)
    @utils.multicase(ea=six.integer_types, none=None.__class__)
    @classmethod
    def color(cls, ea, none):
        '''Removes the color of the basic block at the address `ea`.'''
        clr_node_info = idaapi.clr_node_info2 if idaapi.__version__ < 7.0 else idaapi.clr_node_info

        res, fn, bb = cls.color(ea), by_address(ea), cls.id(ea)
        try: clr_node_info(interface.range.start(fn), bb, idaapi.NIF_BG_COLOR | idaapi.NIF_FRAME_COLOR)
        finally: idaapi.refresh_idaview_anyway()

        # clear the color of each item too.
        for ea in block.iterate(ea):
            database.color(ea, None)
        return res
    @utils.multicase(bounds=builtins.tuple, none=None.__class__)
    @classmethod
    def color(cls, bounds, none):
        '''Removes the color of the basic block identified by `bounds`.'''
        bb = cls.at(bounds)
        return cls.color(bb, None)
    @utils.multicase(bb=idaapi.BasicBlock, none=None.__class__)
    @classmethod
    def color(cls, bb, none):
        '''Removes the color of the basic block `bb`.'''
        clr_node_info = idaapi.clr_node_info2 if idaapi.__version__ < 7.0 else idaapi.clr_node_info

        res, fn = cls.color(bb), by_address(interface.range.start(bb))
        try: clr_node_info(interface.range.start(fn), bb.id, idaapi.NIF_BG_COLOR | idaapi.NIF_FRAME_COLOR)
        finally: idaapi.refresh_idaview_anyway()

        # clear the color of each item too.
        for ea in block.iterate(bb):
            database.color(ea, None)
        return res
    @utils.multicase(ea=six.integer_types, rgb=six.integer_types)
    @classmethod
    def color(cls, ea, rgb, **frame):
        """Sets the color of the basic block at the address `ea` to `rgb`.

        If the color `frame` is specified, set the frame to the specified color.
        """
        set_node_info = idaapi.set_node_info2 if idaapi.__version__ < 7.0 else idaapi.set_node_info

        res, fn, bb = cls.color(ea), by_address(ea), cls.id(ea)
        ni = idaapi.node_info_t()

        # specify the bgcolor
        r, b = (rgb&0xff0000) >> 16, rgb&0x0000ff
        ni.bg_color = ni.frame_color = (b<<16) | (rgb&0x00ff00) | r

        # now the frame color
        frgb = frame.get('frame', 0x000000)
        fr, fb = (frgb&0xff0000)>>16, frgb&0x0000ff
        ni.frame_color = (fb<<16) | (frgb&0x00ff00) | fr

        # set the node
        f = (idaapi.NIF_BG_COLOR|idaapi.NIF_FRAME_COLOR) if frame else idaapi.NIF_BG_COLOR
        try: set_node_info(interface.range.start(fn), bb, ni, f)
        finally: idaapi.refresh_idaview_anyway()

        # update the color of each item too
        for ea in block.iterate(ea):
            database.color(ea, rgb)
        return res
    @utils.multicase(bb=idaapi.BasicBlock, rgb=six.integer_types)
    @classmethod
    def color(cls, bb, rgb, **frame):
        '''Sets the color of the basic block `bb` to `rgb`.'''
        set_node_info = idaapi.set_node_info2 if idaapi.__version__ < 7.0 else idaapi.set_node_info
        res, fn, ni = cls.color(bb), by_address(interface.range.start(bb)), idaapi.node_info_t()

        # specify the bg color
        r, b = (rgb&0xff0000) >> 16, rgb&0x0000ff
        ni.bg_color = ni.frame_color = (b<<16) | (rgb&0x00ff00) | r

        # now the frame color
        frgb = frame.get('frame', 0x000000)
        fr, fb = (frgb&0xff0000)>>16, frgb&0x0000ff
        ni.frame_color = (fb<<16) | (frgb&0x00ff00) | fr

        # set the node
        f = (idaapi.NIF_BG_COLOR|idaapi.NIF_FRAME_COLOR) if frame else idaapi.NIF_BG_COLOR
        try: set_node_info(interface.range.start(fn), bb.id, ni, f)
        finally: idaapi.refresh_idaview_anyway()

        # update the colors of each item too.
        for ea in block.iterate(bb):
            database.color(ea, rgb)
        return res
    @utils.multicase(bounds=builtins.tuple, rgb=six.integer_types)
    @classmethod
    def color(cls, bounds, rgb, **frame):
        '''Sets the color of the basic block identifed by `bounds` to `rgb`.'''
        bb = cls.at(bounds)
        return cls.color(bb, rgb, **frame)

    @utils.multicase()
    @classmethod
    def before(cls):
        '''Return the addresses of all the instructions that branch to the current basic block.'''
        return cls.before(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def before(cls, ea):
        '''Return the addresses of all the instructions that branch to the basic block at address `ea`.'''
        res = blocks.at(ea)
        return cls.before(res)
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def before(cls, bounds):
        '''Return the addresses of all the instructions that branch to the basic block identified by `bounds`.'''
        bb = cls.at(bounds)
        return cls.before(bb)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def before(cls, bb):
        '''Return the addresses of all the instructions that branch to the basic block `bb`.'''
        return [ database.address.prev(interface.range.end(bb)) for bb in bb.preds() ]
    predecessors = preds = utils.alias(before, 'block')

    @utils.multicase()
    @classmethod
    def after(cls):
        '''Return the addresses of all the instructions that the current basic block leaves to.'''
        return cls.after(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def after(cls, ea):
        '''Return the addresses of all the instructions that the basic block at address `ea` leaves to.'''
        bb = cls.at(ea)
        return cls.after(bb)
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def after(cls, bounds):
        '''Return the addresses of all the instructions that branch to the basic block identified by `bounds`.'''
        bb = cls.at(bounds)
        return cls.after(bb)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def after(cls, bb):
        '''Return the addresses of all the instructions that branch to the basic block `bb`.'''
        return [interface.range.start(bb) for bb in bb.succs()]
    successors = succs = utils.alias(after, 'block')

    @utils.multicase()
    @classmethod
    def iterate(cls):
        '''Yield all the addresses in the current basic block.'''
        return cls.iterate(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def iterate(cls, ea):
        '''Yield all the addresses in the basic block at address `ea`.'''
        left, right = cls(ea)
        return database.address.iterate(left, right)
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def iterate(cls, bounds):
        '''Yield all the addresses in the basic block identified by `bounds`.'''
        return database.address.iterate(bounds)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def iterate(cls, bb):
        '''Yield all the addresses in the basic block `bb`.'''
        left, right = interface.range.unpack(bb)
        return database.address.iterate(left, right)

    # current block
    @utils.multicase()
    @classmethod
    def tag(cls):
        '''Returns all the tags defined for the current basic block.'''
        return cls.tag(ui.current.address())
    @utils.multicase(key=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('key')
    def tag(cls, key):
        '''Returns the value of the tag identified by `key` for the current basic block.'''
        return cls.tag(ui.current.address(), key)
    @utils.multicase(key=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('key')
    def tag(cls, key, value):
        '''Sets the value for the tag `key` to `value` for the current basic block.'''
        return cls.tag(ui.current.address(), key, value)
    @utils.multicase(key=six.string_types, none=None.__class__)
    @classmethod
    @utils.string.decorate_arguments('key')
    def tag(cls, key, none):
        '''Removes the tag identified by `key` for the current basic block.'''
        return cls.tag(ui.current.address(), key, none)

    # address or bounds of block
    @utils.multicase(ea=(six.integer_types, tuple))
    @classmethod
    def tag(cls, ea):
        '''Returns all the tags defined for the basic block at `ea`.'''
        bb = cls.at(ea)
        return cls.tag(bb)
    @utils.multicase(ea=(six.integer_types, tuple), key=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('key')
    def tag(cls, ea, key):
        '''Returns the value of the tag identified by `key` for the basic block at `ea`.'''
        bb = cls.at(ea)
        return cls.tag(bb, key)
    @utils.multicase(ea=(six.integer_types, tuple), key=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('key', 'value')
    def tag(cls, ea, key, value):
        '''Sets the value for the tag `key` to `value` for the basic block at `ea`.'''
        bb = cls.at(ea)
        return cls.tag(bb, key, value)
    @utils.multicase(ea=(six.integer_types, tuple), key=six.string_types, none=None.__class__)
    @classmethod
    @utils.string.decorate_arguments('key')
    def tag(cls, ea, key, none):
        '''Removes the tag identified by `key` for the basic block at `ea`.'''
        bb = cls.at(ea)
        return cls.tag(bb, key, none)

    # actual basic block
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    @utils.string.decorate_arguments('key', 'value')
    def tag(cls, bb):
        '''Returns all the tags defined for the ``idaapi.BasicBlock`` given in `bb`.'''
        ea = interface.range.start(bb)

        # first thing to do is to read the tags for the address. this
        # gives us "__extra_prefix__", "__extra_suffix__", and "__name__".
        res = database.tag(ea)

        # next, we're going to remove the one implicit tag that we
        # need to handle...and that's the "__color__" tag.
        col, _ = cls.color(bb), res.pop('__color__', None)
        if col is not None: res.setdefault('__color__', col)

        # that was pretty much it, so we can just return our results.
        return res
    @utils.multicase(bb=idaapi.BasicBlock, key=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('key', 'value')
    def tag(cls, bb, key):
        '''Returns the value of the tag identified by `key` from the ``idaapi.BasicBlock`` given in `bb`.'''
        res = cls.tag(bb)
        if key in res:
            return res[key]
        bounds = interface.range.bounds(bb)
        raise E.MissingTagError(u"{:s}.tag({!s}, {!r}) : Unable to read the specified tag (\"{:s}\") from the basic block ({:s}).".format(__name__, bounds, key, utils.string.escape(key, '"'), bounds))
    @utils.multicase(bb=idaapi.BasicBlock, key=six.string_types)
    @classmethod
    @utils.string.decorate_arguments('key', 'value')
    def tag(cls, bb, key, value):
        '''Sets the value for the tag `key` to `value` in the ``idaapi.BasicBlock`` given by `bb`.'''
        ea = interface.range.start(bb)

        # the only real implicit tag we need to handle is "__color__", because our
        # database.tag function does "__extra_prefix__", "__extra_suffix__", and "__name__".
        if key == '__color__':
            return cls.color(bb, value)

        # now we can passthrough to database.tag for everything else.
        return database.tag(ea, key, value)
    @utils.multicase(bb=idaapi.BasicBlock, key=six.string_types, none=None.__class__)
    @classmethod
    @utils.string.decorate_arguments('key')
    def tag(cls, bb, key, none):
        '''Removes the tag identified by `key` from the ``idaapi.BasicBlock`` given by `bb`.'''
        ea = interface.range.start(bb)

        # if the '__color__' tag was specified, then explicitly clear it.
        if key == '__color__':
            return cls.color(bb, none)

        # passthrough to database.tag for removing the ones we don't handle.
        return database.tag(ea, key, none)

    @utils.multicase(reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, reg, *regs, **modifiers):
        '''Yield each `(address, opnum, state)` within the current block that uses `reg` or any one of the registers in `regs`.'''
        return cls.register(ui.current.address(), reg, *regs, **modifiers)
    @utils.multicase(ea=six.integer_types, reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, ea, reg, *regs, **modifiers):
        '''Yield each `(address, opnum, state)` within the block containing `ea` that uses `reg` or any one of the registers in `regs`.'''
        bb = cls.at(ea, **modifiers)
        return cls.register(bb, reg, *regs, **modifiers)
    @utils.multicase(bounds=builtins.tuple, reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, bounds, reg, *regs, **modifiers):
        '''Yield each `(address, opnum, state)` within the block identified by `bounds` that uses `reg` or any one of the registers in `regs`.'''
        iterops = interface.regmatch.modifier(**modifiers)
        uses_register = interface.regmatch.use( (reg,) + regs )

        for ea in database.address.iterate(bounds):
            for opnum in iterops(ea):
                if uses_register(ea, opnum):
                    items = ea, opnum, instruction.op_state(ea, opnum)
                    yield interface.opref_t(*items)
                continue
            continue
        return
    @utils.multicase(bb=idaapi.BasicBlock, reg=(six.string_types, interface.register_t))
    @classmethod
    def register(cls, bb, reg, *regs, **modifiers):
        """Yield each `(address, opnum, state)` within the block `bb` that uses `reg` or any one of the registers in `regs`.

        If the keyword `write` is true, then only return the result if it's writing to the register.
        """
        iterops = interface.regmatch.modifier(**modifiers)
        uses_register = interface.regmatch.use( (reg,) + regs )

        for ea in cls.iterate(bb):
            for opnum in iterops(ea):
                if uses_register(ea, opnum):
                    items = ea, opnum, instruction.op_state(ea, opnum)
                    yield interface.opref_t(*items)
                continue
            continue
        return

    @utils.multicase()
    @classmethod
    def read(cls):
        '''Return all the bytes contained in the current basic block.'''
        return cls.read(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def read(cls, ea):
        '''Return all the bytes contained in the basic block at address `ea`.'''
        bb = cls.at(ea)
        return cls.read(bb)
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def read(cls, bounds):
        '''Return all the bytes contained in the basic block identified by `bounds`.'''
        bb = cls.at(bounds)
        return cls.read(bb)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def read(cls, bb):
        '''Return all the bytes contained in the basic block `bb`.'''
        bounds = interface.range.bounds(bb)
        return database.read(bounds)

    @utils.multicase()
    @classmethod
    def disassemble(cls, **options):
        '''Returns the disassembly of the basic block at the current address.'''
        return cls.disassemble(ui.current.address(), **options)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def disassemble(cls, ea, **options):
        '''Returns the disassembly of the basic block at the address `ea`.'''
        F = functools.partial(database.disassemble, **options)
        return '\n'.join(map(F, cls.iterate(ea)))
    @utils.multicase(bounds=builtins.tuple)
    @classmethod
    def disassemble(cls, bounds, **options):
        '''Returns the disassembly of the basic block identified by `bounds`.'''
        bb = cls.at(bounds, **options)
        return cls.disassemble(bb, **options)
    @utils.multicase(bb=idaapi.BasicBlock)
    @classmethod
    def disassemble(cls, bb, **options):
        '''Returns the disassembly of the basic block `bb`.'''
        F = functools.partial(database.disassemble, **options)
        return '\n'.join(map(F, cls.iterate(bb)))
    disasm = utils.alias(disassemble, 'block')

    # FIXME: implement .decompile for an idaapi.BasicBlock type too
    @utils.multicase()
    @classmethod
    def decompile(cls):
        '''(UNSTABLE) Returns the decompiled code of the basic block at the current address.'''
        return cls.decompile(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def decompile(cls, ea):
        '''(UNSTABLE) Returns the decompiled code of the basic block at the address `ea`.'''
        source = idaapi.decompile(ea)

        res = map(functools.partial(operator.getitem, source.eamap), cls.iterate(ea))
        res = itertools.chain(*res)
        formatted = functools.reduce(lambda t, c: t if t[-1].ea == c.ea else t + [c], res, [next(res)])

        res = []
        # FIXME: This has been pretty damn unstable in my tests.
        try:
            for fmt in formatted:
                res.append( fmt.print1(source.__deref__()) )
        except TypeError: pass
        res = map(idaapi.tag_remove, res)
        return '\n'.join(map(utils.string.of, res))

class frame(object):
    """
    This namespace is for getting information about the selected
    function's frame. By default, this namespace will return a
    ``structure_t`` representing the frame belonging to the specified
    function. The returned frame will include any preserved registers
    so that offset 0 will point at the beginning of the parameters.

    Some ways of using this can be::

        > print( function.frame() )
        > print( hex(function.frame.id(ea)) )
        > sp = function.frame.delta(ea)

    """
    @utils.multicase()
    def __new__(cls):
        '''Return the frame of the current function.'''
        return cls(ui.current.function())

    @utils.multicase()
    def __new__(cls, func):
        '''Return the frame of the function `func`.'''
        fn = by(func)
        res = idaapi.get_frame(interface.range.start(fn))
        if res is not None:
            size = idaapi.frame_off_args(fn)
            return structure.by_identifier(res.id, offset=-size)
        raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : The specified function does not have a frame.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn)))

    @utils.multicase()
    @classmethod
    def new(cls):
        '''Add an empty frame to the current function.'''
        fn = ui.current.function()
        return cls.new(fn, 0, idaapi.get_frame_retsize(fn), 0)
    @utils.multicase(lvars=six.integer_types, args=six.integer_types)
    @classmethod
    def new(cls, lvars, args):
        '''Add a frame to the current function using the sizes specified by `lvars` for local variables, and `args` for arguments.'''
        fn = ui.current.function()
        return cls.new(fn, lvars, idaapi.get_frame_retsize(fn), args)
    @utils.multicase(lvars=six.integer_types, regs=six.integer_types, args=six.integer_types)
    @classmethod
    def new(cls, lvars, regs, args):
        '''Add a frame to the current function using the sizes specified by `lvars` for local variables, `regs` for frame registers, and `args` for arguments.'''
        return cls.new(ui.current.function(), lvars, regs, args)
    @utils.multicase(lvars=six.integer_types, regs=six.integer_types, args=six.integer_types)
    @classmethod
    def new(cls, func, lvars, regs, args):
        """Add a frame to the function `func` using the sizes specified by `lvars` for local variables, `regs` for frame registers, and `args` for arguments.

        When specifying the size of the registers (`regs`) the size of the saved instruction pointer must also be included.
        """
        fn = by(func)
        _r = idaapi.get_frame_retsize(fn)
        ok = idaapi.add_frame(fn, lvars, regs - _r, args)
        if not ok:
            raise E.DisassemblerError(u"{:s}.new({:#x}, {:+#x}, {:+#x}, {:+#x}) : Unable to use `idaapi.add_frame({:#x}, {:d}, {:d}, {:d})` to add a frame to the specified function.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), lvars, regs - _r, args, interface.range.start(fn), lvars, regs - _r, args))
        return cls(fn)

    @utils.multicase()
    @classmethod
    def id(cls):
        '''Returns the structure id for the current function's frame.'''
        return cls.id(ui.current.function())
    @utils.multicase()
    @classmethod
    def id(cls, func):
        '''Returns the structure id for the function `func`.'''
        fn = by(func)
        return fn.frame

    @utils.multicase()
    @classmethod
    def delta(cls):
        '''Returns the stack delta for the current address within its function.'''
        return cls.delta(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def delta(cls, ea):
        '''Returns the stack delta for the address `ea` within its given function.'''
        fn, ea = by_address(ea), interface.address.inside(ea)
        return idaapi.get_spd(fn, ea)
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def delta(cls, func, ea):
        '''Returns the stack delta for the address `ea` within the function `func`.'''
        fn, ea = by(func), interface.address.inside(ea)
        return idaapi.get_spd(fn, ea)

    class arguments(object):
        """
        This namespace is for returning information about the arguments
        within a function's frame. By default, this namespace will yield
        each argument as a tuple containing the `(offset, name, size)`.

        Some ways of using this are::

            > print( function.frame.arguments(f) )
            > print( function.frame.arguments.registers(f) )
            > print( function.frame.arguments.size(f) )
            > print( function.frame.arguments.location(ea) )

        """

        @utils.multicase()
        def __new__(cls):
            '''Yield the `(offset, name, size)` of each argument belonging to the current function.'''
            return cls(ui.current.address())
        @utils.multicase()
        def __new__(cls, func):
            '''Yield the `(offset, name, size)` of each argument belonging to the function `func`.'''
            _, ea = interface.addressOfRuntimeOrStatic(func)

            # first we'll need to check if there's a tinfo_t for the address to
            # give it priority over the frame. then we can grab its details.
            if database.type.has_typeinfo(ea):
                tinfo = type(ea)
                _, ftd = interface.tinfo.function_details(ea, tinfo)

                # iterate through the parameters and collect only arguments that
                # are allocated on the stack so that we can use their information
                # when yielding our results.
                items = []
                for index in builtins.range(ftd.size()):
                    arg, loc = ftd[index], ftd[index].argloc

                    # not allocated on the stack? then we skip it..
                    if loc.atype() != idaapi.ALOC_STACK:
                        continue

                    # extract the stack offset, and then add the argument
                    # information that we collected to our list.
                    stkoff = loc.stkoff()
                    items.append((index, stkoff, utils.string.of(arg.name), arg.type))

                # our results shouldn't have duplicates, but they might. actually,
                # our results could technically be overlapping too. still, this is
                # just to priority the tinfo_t and we only care about the stkoff.
                locations = {}
                for index, offset, name, tinfo in items:
                    if operator.contains(locations, offset):
                        old_index, old_name, _ = locations[offset]
                        logging.warning(u"{:s}({:#x}) : Overwriting the parameter {:s}(index {:d}) for function ({:#x}) due to parameter {:s}(index {:d}) being allocated at the same frame offset ({:+#x}).".format('.'.join([__name__, cls.__name__]), ea, "\"{:s}\" ".format(utils.string.escape(old_name, '"')) if old_name else '', old_index, ea, "\"{:s}\" ".format(utils.string.escape(name, '"')) if name else '', index, offset))
                    locations[offset] = (index, name, tinfo)

                # that was it, we have our locations and we can proceed.
                locations = locations

            # if there was no type information, then we have no locations to reference.
            else:
                locations = {}

            # now we need to check if our address actually includes a frame. if it
            # doesn't, then we need to explicitly process our locations here.
            fr, results = idaapi.get_frame(ea), []
            if fr is None:
                items = [offset for offset in locations]

                # before we do anything, we need to figure out our lowest offset
                # so that we can return the unnamed members that will exist in
                # between our $pc and any actual args allocated on the stack.
                delta = min(locations) if locations else 0
                if delta:
                    results.append((0, None, delta))

                # now we can iterate through all our locations and yield each one.
                for offset in sorted(locations):
                    _, name, ti = locations[offset]
                    results.append((offset, name or None, ti.get_size()))
                return results

            # to proceed, we need to know the function to get its frame sizes.
            else:
                fn = idaapi.get_func(ea)

            # once we have our locations, we can grab a fragment from the frame
            # and yield all of the members that are considered as arguments.
            current, base = 0, idaapi.frame_off_args(fn)
            for offset, size, content in structure.fragment(fr.id, base, structure.size(fr.id) - base):
                stkoff = offset - base

                # check our locations to see if we have any type information for
                # the given stkoff so that way we can prioritize it.
                if operator.contains(locations, stkoff):
                    index, tname, tinfo = locations.pop(stkoff)

                    # grab the tinfo name and tinfo size. if the name wasn't found,
                    # then fall back to using the member name from the frame.
                    name, tsize = tname or content.get('__name__', None), tinfo.get_size()

                    # if our member size matches our tinfo size, then we can yield it.
                    if tsize == size:
                        results.append((stkoff, name, tsize))

                    # if the tinfo size is smaller then the member's, then we're
                    # going to need to pad it up to the expected member size.
                    elif tsize < size:
                        results.append((stkoff, name, tsize))
                        results.append((stkoff + tsize, None, size - tsize))

                    # otherwise, the member size is smaller than the tinfo size.
                    # if this is the case, then we need to use the member size
                    # but log a warning that we're ignoring the size of the tinfo.
                    else:
                        logging.warning(u"{:s}({:#x}) : Ignoring the type size for parameter {:s}(index {:d}) for function ({:#x}) due to the frame member at offset ({:+#x}) being smaller ({:+#x}).".format('.'.join([__name__, cls.__name__]), ea, "\"{:s}\" ".format(utils.string.escape(tname, '"')) if tname else '', index, ea, stkoff, size))
                        results.append((stkoff, name, size))

                # otherwise we'll just yield the information from the member.
                else:
                    results.append((stkoff, content.get('__name__', None), size))

                # update our current offset and proceed to the next member.
                current = stkoff + size

            # iterate through all of the locations that we have left.
            for stkoff in sorted(locations):
                _, name, ti = locations[stkoff]

                # if our current position is not pointing at the expected stkoff,
                # then we need to yield some padding that will put us there.
                if current < stkoff:
                    results.append((current, None, stkoff - current))

                # now we can yield the next member and adjust our current position.
                results.append((stkoff, name or None, ti.get_size()))
                current = stkoff + ti.get_size()
            return results

        @utils.multicase()
        @classmethod
        def location(cls):
            '''Return the list of address locations for each of the parameters that are passed to the function call at the current address.'''
            return cls.location(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def location(cls, ea):
            '''Return the list of address locations for each of the parameters that are passed to the function call at `ea`.'''
            if not any(Finstruction(ea) for Finstruction in [instruction.type.is_call, instruction.type.is_branch]):
                raise E.MissingTypeOrAttribute(u"{:s}.location({:#x}) : The instruction at the specified address ({:#x}) is not a function call.".format('.'.join([__name__, cls.__name__]), ea, ea))

            items = idaapi.get_arg_addrs(ea)
            if items is None:
                raise E.DisassemblerError(u"{:s}.location({:#x}) : Unable to retrieve the initialization addresses for the arguments to the function call at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, ea))
            return [ea for ea in items]
        @utils.multicase(ea=six.integer_types, index=six.integer_types)
        @classmethod
        def location(cls, ea, index):
            '''Return the initialization address for the parameter at `index` for the function call at `ea`.'''
            items = cls.location(ea)
            if not (0 <= index < len(items)):
                raise E.InvalidTypeOrValueError(u"{:s}.location({:#x}, {:d}) : The requested argument index ({:d}) for the function call at address {:#x} is not within the bounds of the function's arguments ({:d} <= {:d} < {:d}).".format('.'.join([__name__, cls.__name__]), ea, index, index, ea, 0, index, len(items)))
            return items[index]
        locations = utils.alias(location, 'frame.args')

        @utils.multicase()
        @classmethod
        def iterate(cls):
            '''Yield the `(member, type, name)` associated with the arguments for the current function.'''
            return cls.iterate(ui.current.address())
        @utils.multicase()
        @classmethod
        def iterate(cls, func):
            '''Yield the `(member, type, name)` associated with the arguments for the function `func`.'''
            rt, ea = interface.addressOfRuntimeOrStatic(func)
            fn, has_tinfo = None if rt else by(ea), type.has_typeinfo(ea)

            # We need our frame to be correct, so we confirm it by checking the problem queue.
            Fproblem = builtins.next((getattr(idaapi, candidate) for candidate in ['is_problem_present', 'QueueIsPresent'] if hasattr(idaapi, candidate)), utils.fconstant(False))
            PR_BADSTACK = getattr(idaapi, 'PR_BADSTACK', 0xb)

            # Build a lookup table that we'll use to deserialize the correct type for each size.
            bits, tilookup = database.config.bits(), {
                8: idaapi.BT_INT8, 16: idaapi.BT_INT16, 32: idaapi.BT_INT32,
                64: idaapi.BT_INT64, 128: idaapi.BT_INT128, 80: idaapi.BTF_TBYTE,
            }

            # Then build an array_type_data_t for absolutely everything else.
            at, byte = idaapi.array_type_data_t(), idaapi.tinfo_t()
            byte.create_simple_type(idaapi.BTF_BYTE)
            at.base, at.nelems, at.elem_type = 0, 0, byte

            # If we have no type information, then we can only process arguments if we're within
            # a function. If we're not not part of a functon, then we log a warning and bail.
            if not has_tinfo:
                if not fn:
                    logging.warning(u"{:s}.iterate({:#x}) : Unable to iterate through the arguments for the given function ({:#x}) due to missing type information.".format('.'.join([__name__, cls.__name__]), ea, ea))

                # If our function's regargqty is larger than zero, then we're supposed to extract the
                # regargs directly out of the func_t.
                elif fn.regargqty:
                    items = []

                    # If regargqty is set, but regargs is None...then we need to call read_regargs on our
                    # fn to get IDA to actually read it...The funny thing is, on earlier versions of IDA
                    # it seems that read_regargs won't always allocate an iterator...so this means that
                    # we manually make it a list and then this way we can iterate through the fucker.
                    idaapi.read_regargs(fn) if fn.regargs is None else None
                    if isinstance(fn.regargs, idaapi.regarg_t):
                        regargs = [fn.regargs]
                    else:
                        regargs = [fn.regargs[index] for index in builtins.range(fn.regargqty)]

                    # Iterate through all of our arguments and grab the register, the type information, and
                    # argument name out of the register argument.
                    for index, regarg in enumerate(regargs):
                        ti = idaapi.tinfo_t()

                        # Deserialize the type information that we received from the register argument.
                        if ti.deserialize(None, regarg.type, None):
                            items.append((regarg, ti))

                        # If we failed, then log a warning and try to append a void* as a placeholder.
                        elif ti.deserialize(None, bytes(bytearray([idaapi.BT_PTR, idaapi.BT_VOID])), None):
                            logging.warning(u"{:s}.iterate({:#x}) : Using the type {!r} as a placeholder due to being unable to decode the type information ({!s}) for the argument at index {:d}.".format('.'.join([__name__, cls.__name__]), ea, ti._print(), regarg.type, index))
                            items.append((regarg, ti))

                        # If we couldn't even create a void*, then this is a critical failure and we
                        # really need to get the argument size correct. So, we just look it up.
                        else:
                            if not operator.contains(tilookup, bits) or not ti.deserialize(None, bytes(bytearray([tilookup[bits]])), None):
                                raise E.DisassemblerError(u"{:s}.iterate({:#x}) : Unable to create a type that fits within the number of bits for the database ({:d}).".format('.'.join([__name__, cls.__name__]), ea, bits))
                            logging.critical(u"{:s}.iterate({:#x}) : Falling back to the type {!r} as a placeholder due to being unable to cast the type information ({!r}) for the argument at index {:d}.".format('.'.join([__name__, cls.__name__]), ea, ti._print(), regarg.type, index))
                            items.append((regarg, ti))
                        continue

                    # Now that we have the regarg and its tinfo_t, we just need to extract
                    # its properties to turn it into a register_t and grab its name.
                    for regarg, ti in items:
                        try:
                            reg = instruction.architecture.by_indexsize(regarg.reg, ti.get_size())
                        except KeyError:
                            reg = instruction.architecture.by_index(regarg.reg)
                        yield reg, ti, utils.string.of(regarg.name)

                    # We processed the registers, so we can fallthrough to the next one.

                # If we have a frame, then we do our best to figure out the parameters from it.
                if fn and idaapi.get_frame(ea):
                    fr, asize, rsize = frame(ea), cls.size(ea), fn.frregs + idaapi.get_frame_retsize(fn)

                    # Before we start checking the frame, though, we need to make sure that IDA
                    # didn't have any problems calculating the stackpoints. If so, then we need
                    # to access the member differently using an "inexact" methodology.
                    Flocation = operator.attrgetter('offset') if Fproblem(PR_BADSTACK, ea) else utils.fidentity

                    # Now we can grab the fragment of the structure containing the parameters. If
                    # there's no content, then skip it and move onto the next member.
                    for offset, size, content in structure.fragment(fr.id, fr.size - asize, asize):
                        if not content:
                            continue

                        # Now we can calculate our location and create a default type for it.
                        aoffset = offset - fr.size + asize
                        location, aname = interface.location_t(aoffset + rsize, size), interface.tuplename('arg', aoffset)

                        ti, at.nelems = idaapi.tinfo_t(), size
                        if not ti.create_array(at):
                            raise E.DisassemblerError(u"{:s}.iterate({:#x}) : Unable to create an array of the required number of bytes ({:d}).".format('.'.join([__name__, cls.__name__]), ea, size))

                        # Use the location to try and find the member that it points to.
                        try:
                            item = fr.members.by(Flocation(location))
                        except (E.MemberNotFoundError, E.OutOfBoundsError):
                            if not operator.contains(tilookup, 8 * size) or not ti.deserialize(None, bytes(bytearray([tilookup[8 * size]])), None):
                                raise E.DisassemblerError(u"{:s}.iterate({:#x}) : Unable to create a type of the required number of bytes ({:d}).".format('.'.join([__name__, cls.__name__]), ea, size))
                            item, ti, name = location, ti, aname
                        else:
                            item, ti, name = (item, item.typeinfo, item.name) if item.offset == location.offset else (location, ti, aname)
                        yield item, ti, name

                    # That was all the arguments we found in the frame...which means, we're done.
                return

            # If we got here, then we have type information that we can grab out
            # of the given address. Once we have it, rip the details out o it.
            tinfo = type(ea)
            _, ftd = interface.tinfo.function_details(ea, tinfo)

            # Now we just need to iterate through our parameters collecting the
            # raw location information for all of them. We preserve the type
            # information in case we're unable to find the argument in a member.
            items = []
            for index in builtins.range(ftd.size()):
                arg, loc = ftd[index], ftd[index].argloc
                items.append((index, utils.string.of(arg.name), arg.type, interface.tinfo.location_raw(loc)))

            # Last thing that we need to do is to extract each location and
            # figure out whether we return it as a register or an actual member.
            fr = None if rt else frame(ea) if idaapi.get_frame(ea) else None
            for index, name, ti, location in items:
                atype, ainfo = location
                loc = interface.tinfo.location(ti.get_size(), instruction.architecture, atype, ainfo)

                # If it's a location, then we can just add the register size to
                # find where the member is located at. This becomes our result
                # if we have a frame. Otherwise we return the location.
                if isinstance(loc, interface.location_t):
                    aname = name or interface.tuplename('arg', loc.offset)
                    try:
                        item = fr.members.by(loc) if fr else loc
                    except (E.MemberNotFoundError, E.OutOfBoundsError):
                        item, name = loc, aname
                    else:
                        name = item.name if fr else aname
                    finally:
                        yield item, ti, name or aname

                # If it's a tuple, then we check if it contains any registers
                # so that way we can process them if necessary. If its a register
                # offset where its second item is an integer and it's zero, then
                # we can simply exclude the offset from our results.
                elif isinstance(loc, builtins.tuple) and any(isinstance(item, interface.register_t) for item in loc):
                    reg, offset = loc
                    yield loc if offset else reg, ti, name

                # Otherwise, it's one of the custom locations that we don't
                # support. So we can just return it as we received it.
                else:
                    yield loc, ti, name
                continue
            return

        @utils.multicase()
        @classmethod
        def registers(cls):
            '''Return the register information associated with the arguments of the current function.'''
            return cls.registers(ui.current.address())
        @utils.multicase()
        @classmethod
        def registers(cls, func):
            '''Return the register information associated with the arguments of the function `func`.'''
            result = []
            for reg, ti, name in cls.iterate(func):
                result.append(reg) if any([isinstance(reg, interface.register_t), isinstance(reg, builtins.tuple) and all(isinstance(item, interface.register_t) for item in reg)]) else None
            return result
        regs = utils.alias(registers, 'frame.args')

        @utils.multicase()
        @classmethod
        def size(cls):
            '''Returns the size of the arguments for the current function.'''
            return cls.size(ui.current.function())
        @utils.multicase()
        @classmethod
        def size(cls, func):
            '''Returns the size of the arguments for the function `func`.'''
            fn = by(func)
            max = structure.size(get_frameid(fn))
            total = frame.lvars.size(fn) + frame.regs.size(fn)
            return max - total
    args = arg = arguments  # XXX: ns alias

    class lvars(object):
        """
        This namespace provides information about the local variables
        defined within a function's frame.

        Some ways to get this information can be::

            > print( function.frame.lvars.size() )

        """
        @utils.multicase()
        def __new__(cls):
            '''Yield the `(offset, name, size)` of each local variable relative to the stack pointer for the current function.'''
            return cls(ui.current.address())
        @utils.multicase()
        def __new__(cls, func):
            '''Yield the `(offset, name, size)` of each local variable relative to the stack pointer for the function `func`.'''
            fn = by(func)

            # figure out the frame
            fr = idaapi.get_frame(fn)
            if fr is None:  # unable to figure out arguments
                raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to get the function frame.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn)))

            results = []
            for off, size, content in structure.fragment(fr.id, 0, fn.frsize):
                results.append((off - idaapi.frame_off_savregs(fn), content.get('__name__', None), size))
            return results

        @utils.multicase()
        @classmethod
        def size(cls):
            '''Returns the size of the local variables for the current function.'''
            return cls.size(ui.current.function())
        @utils.multicase()
        @classmethod
        def size(cls, func):
            '''Returns the size of the local variables for the function `func`.'''
            fn = by(func)
            return fn.frsize
    vars = lvars    # XXX: ns alias

    class regs(object):
        """
        This namespace provides information about the registers that
        are saved when a function constructs its frame.

        An example of using this namespace::

            > print( function.frame.regs.size(ea) )

        """

        @utils.multicase()
        def __new__(cls):
            '''Yield the `(offset, name, size)` of each saved register relative to the stack pointer of the current function.'''
            return cls(ui.current.address())
        @utils.multicase()
        def __new__(cls, func):
            '''Yield the `(offset, name, size)` of each saved register relative to the stack pointer of the function `func`.'''
            fn = by(func)

            # figure out the frame
            fr = idaapi.get_frame(fn)
            if fr is None:  # unable to figure out arguments
                raise E.MissingTypeOrAttribute(u"{:s}({:#x}) : Unable to get the function frame.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn)))

            results, regsize, delta = [], sum([fn.frregs, idaapi.get_frame_retsize(fn)]), idaapi.frame_off_args(fn)
            iterable = structure.fragment(fr.id, idaapi.frame_off_savregs(fn), regsize) if regsize else []
            for off, size, content in iterable:
                results.append((off - delta, content.get('__name__', None), size))
            return results

        @utils.multicase()
        @classmethod
        def size(cls):
            '''Returns the number of bytes occupied by the saved registers in the current function.'''
            return cls.size(ui.current.function())
        @utils.multicase()
        @classmethod
        def size(cls, func):
            '''Returns the number of bytes occupied by the saved registers for the function `func`.'''
            fn = by(func)
            return fn.frregs + idaapi.get_frame_retsize(fn)

get_frameid = utils.alias(frame.id, 'frame')
get_args_size = utils.alias(frame.args.size, 'frame.args')
get_vars_size = utils.alias(frame.lvars.size, 'frame.lvars')
get_regs_size = utils.alias(frame.regs.size, 'frame.regs')
get_spdelta = spdelta = utils.alias(frame.delta, 'frame')

## instruction iteration/searching
## tagging
@utils.multicase()
def tag():
    '''Returns all the tags defined for the current function.'''
    return tag(ui.current.address())
@utils.multicase(key=six.string_types)
@utils.string.decorate_arguments('key')
def tag(key):
    '''Returns the value of the tag identified by `key` for the current function.'''
    return tag(ui.current.address(), key)
@utils.multicase(key=six.string_types)
@utils.string.decorate_arguments('key', 'value')
def tag(key, value):
    '''Sets the value for the tag `key` to `value` for the current function.'''
    return tag(ui.current.address(), key, value)
@utils.multicase(key=six.string_types)
@utils.string.decorate_arguments('key')
def tag(func, key):
    '''Returns the value of the tag identified by `key` for the function `func`.'''
    res = tag(func)
    if key in res:
        return res[key]
    raise E.MissingFunctionTagError(u"{:s}.tag({:s}, {!r}) : Unable to read the specified tag (\"{:s}\") from the function.".format(__name__, ("{:#x}" if isinstance(func, six.integer_types) else "{!r}").format(func), key, utils.string.escape(key, '"')))
@utils.multicase()
def tag(func):
    '''Returns all the tags defined for the function `func`.'''
    MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
    Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(0, MANGLED_UNKNOWN))
    MNG_NODEFINIT, MNG_NOPTRTYP, MNG_LONG_FORM = getattr(idaapi, 'MNG_NODEFINIT', 8), getattr(idaapi, 'MNG_NOPTRTYP', 7), getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)

    try:
        rt, ea = interface.addressOfRuntimeOrStatic(func)

    # If the given location was not within a function, then fall back to a database tag.
    except E.FunctionNotFoundError:
        logging.warning(u"{:s}.tag({:s}) : Attempted to read any tags from a non-function. Falling back to using database tags.".format(__name__, ("{:#x}" if isinstance(func, six.integer_types) else "{!r}").format(func)))
        return database.tag(func)

    # If we were given a runtime function, then the address actually uses a database tag.
    if rt:
        logging.warning(u"{:s}.tag({:#x}) : Attempted to read any tags from a runtime-linked address. Falling back to using database tags.".format(__name__, ea))
        return database.tag(ea)

    # Read both repeatable and non-repeatable comments from the address, and
    # decode the tags that are stored within to a dictionary.
    fn, repeatable = by_address(ea), True
    res = comment(fn, repeatable=False)
    d1 = internal.comment.decode(res)
    res = comment(fn, repeatable=True)
    d2 = internal.comment.decode(res)

    # Detect if the address had content in both repeatable or non-repeatable
    # comments so we can warn the user about what we're going to do.
    if six.viewkeys(d1) & six.viewkeys(d2):
        logging.info(u"{:s}.tag({:#x}) : Contents of both the repeatable and non-repeatable comment conflict with one another due to using the same keys ({!r}). Giving the {:s} comment priority.".format(__name__, ea, ', '.join(six.viewkeys(d1) & six.viewkeys(d2)), 'repeatable' if repeatable else 'non-repeatable'))

    # Then we can store them into a dictionary whilst preserving priority.
    res = {}
    [ res.update(d) for d in ([d1, d2] if repeatable else [d2, d1]) ]

    # Collect all of the naming information for the function.
    fname, mangled = name(ea), utils.string.of(idaapi.get_func_name(ea))
    if fname and Fmangled_type(utils.string.to(mangled)) != MANGLED_UNKNOWN:
        realname = utils.string.of(idaapi.demangle_name(utils.string.to(mangled), MNG_NODEFINIT|MNG_NOPTRTYP) or fname)
    else:
        realname = fname or ''

    # Add any of the implicit tags for the given function into our results.
    fname = fname
    if fname and database.type.flags(interface.range.start(fn), idaapi.FF_NAME): res.setdefault('__name__', realname)
    fcolor = color(fn)
    if fcolor is not None: res.setdefault('__color__', fcolor)

    # For the function's type information within the implicit "__typeinfo__"
    # tag, we'll need to extract the prototype and the function's name. This
    # is so that we can use the name to emit a proper function prototype.
    try:
        if type.has_prototype(fn):
            ti = type(fn)

            # Filter the name we're going to render with so that it can be parsed properly.
            valid = {item for item in string.digits} | {':'}
            filtered = str().join(item if item in valid or idaapi.is_valid_typename(utils.string.to(item)) else '_' for item in realname)
            validname = ''.join(filtered)

            # Use the validname to render the type into a string so that we
            # can return it to the user in its proper format.
            fprototype = idaapi.print_tinfo('', 0, 0, 0, ti, utils.string.to(validname), '')
            res.setdefault('__typeinfo__', fprototype)

    # If an exception was raised, then we're using an older version of IDA and we
    # need to rip the type information from the unmangled name.
    except E.InvalidTypeOrValueError:
        if fname != realname:
            res.setdefault('__typeinfo__', fname)

    # Finally we can hand our result back to the caller.
    return res
@utils.multicase(key=six.string_types)
@utils.string.decorate_arguments('key', 'value')
def tag(func, key, value):
    '''Sets the value for the tag `key` to `value` for the function `func`.'''
    if value is None:
        raise E.InvalidParameterError(u"{:s}.tag({:s}, {!r}, {!r}) : Tried to set the tag (\"{:s}\") to an unsupported type ({!s}).".format(__name__, ("{:#x}" if isinstance(func, six.integer_types) else "{!r}").format(func), key, value, utils.string.escape(key, '"'), value))

    # Check to see if function tag is being applied to an import
    try:
        rt, ea = interface.addressOfRuntimeOrStatic(func)

    # If we're not even in a function, then use a database tag.
    except E.FunctionNotFoundError:
        logging.warning(u"{:s}.tag({:s}, {!r}, {!r}) : Attempted to set tag (\"{:s}\") for a non-function. Falling back to a database tag.".format(__name__, ("{:#x}" if isinstance(func, six.integer_types) else "{!r}").format(func), key, value, utils.string.escape(key, '"')))
        return database.tag(func, key, value)

    # If we are a runtime-only function, then write the tag to the import
    if rt:
        logging.warning(u"{:s}.tag({:#x}, {!r}, {!r}) : Attempted to set tag (\"{:s}\") for a runtime-linked symbol. Falling back to a database tag.".format(__name__, ea, key, value, utils.string.escape(key, '"')))
        return database.tag(ea, key, value)

    # Otherwise, it's a function.
    fn = by_address(ea)

    # If the user wants to modify any of the implicit tags, then we use the key
    # to figure out which function to dispatch to in order to modify it.
    if key == '__name__':
        return name(fn, value)
    elif key == '__color__':
        return color(fn, value)
    elif key == '__typeinfo__':
        return type(fn, value)

    # Decode both comment types for the function so that we can figure out which
    # type that the tag they specified is currently in. If it's in neither, then
    # we can simply use a repeatable comment because we're a function.
    state_correct = internal.comment.decode(comment(fn, repeatable=True)), True
    state_wrong = internal.comment.decode(comment(fn, repeatable=False)), False
    state, where = state_correct if key in state_correct[0] else state_wrong if key in state_wrong[0] else state_correct

    # Grab the previous value from the correct dictionary, and update it with
    # the new value that was given to us.
    res, state[key] = state.get(key, None), value

    # Now we need to guard the modification of the comment so that we don't
    # mistakenly tamper with any of the reference counts in the tag cache.
    hooks = {'changing_range_cmt', 'range_cmt_changed', 'changing_area_cmt', 'area_cmt_changed'} & {target for target in ui.hook.idb}
    try:
        [ ui.hook.idb.disable(item) for item in hooks ]

    # If we weren't able to disable the hooks due to an exception, then don't
    # bother to re-encoding the tags back into the comment.
    except Exception:
        raise

    # Finally we can encode the modified dict and write it to the function comment.
    else:
        comment(fn, internal.comment.encode(state), repeatable=where)

    # Release the hooks that we disabled since we finished modifying the comment.
    finally:
        [ ui.hook.idb.enable(item) for item in hooks ]

    # If there wasn't a key in any of the dictionaries we decoded, then
    # we know one was added and so we need to update the tagcache.
    if res is None:
        internal.comment.globals.inc(interface.range.start(fn), key)

    # return what we fetched from the dict
    return res
@utils.multicase(key=six.string_types, none=None.__class__)
@utils.string.decorate_arguments('key')
def tag(key, none):
    '''Removes the tag identified by `key` for the current function.'''
    return tag(ui.current.address(), key, None)
@utils.multicase(key=six.string_types, none=None.__class__)
@utils.string.decorate_arguments('key')
def tag(func, key, none):
    '''Removes the tag identified by `key` from the function `func`.'''

    # Check to see if function tag is being applied to an import
    try:
        rt, ea = interface.addressOfRuntimeOrStatic(func)

    # If we're not even in a function, then use a database tag.
    except E.FunctionNotFoundError:
        logging.warning(u"{:s}.tag({:s}, {!r}, {!s}) : Attempted to clear the tag for a non-function. Falling back to a database tag.".format(__name__, ('{:#x}' if isinstance(func, six.integer_types) else '{!r}').format(func), key, none))
        return database.tag(func, key, none)

    # If so, then write the tag to the import
    if rt:
        logging.warning(u"{:s}.tag({:#x}, {!r}, {!s}) : Attempted to set tag for a runtime-linked symbol. Falling back to a database tag.".format(__name__, ea, key, none))
        return database.tag(ea, key, none)

    # Otherwise, it's a function.
    fn = by_address(ea)

    # If the user wants to remove any of the implicit tags, then we need to
    # dispatch to the correct function in order to clear the requested value.
    if key == '__name__':
        return name(fn, None)
    elif key == '__color__':
        return color(fn, None)
    elif key == '__typeinfo__':
        return type(fn, None)

    # Decode both comment types so that we can figure out which comment type
    # the tag they're trying to remove is in. If it's in neither, then we just
    # assume which comment it should be in as an exception will be raised later.
    state_correct = internal.comment.decode(comment(fn, repeatable=True)), True
    state_wrong = internal.comment.decode(comment(fn, repeatable=False)), False
    state, where = state_correct if key in state_correct[0] else state_wrong if key in state_wrong[0] else state_correct

    # If the user's key was not in any of the decoded dictionaries, then raise
    # an exception because the key doesn't exist within the function's tags.
    if key not in state:
        raise E.MissingFunctionTagError(u"{:s}.tag({:#x}, {!r}, {!s}) : Unable to remove non-existent tag (\"{:s}\") from function.".format(__name__, interface.range.start(fn), key, none, utils.string.escape(key, '"')))
    res = state.pop(key)

    # Before modifying the comment, we first need to guard its modification
    # so that the hooks don't also tamper with the reference count in the cache.
    hooks = {'changing_range_cmt', 'range_cmt_changed', 'changing_area_cmt', 'area_cmt_changed'} & {target for target in ui.hook.idb}
    try:
        [ ui.hook.idb.disable(item) for item in hooks ]

    # If an exception was raised while trying to disable the hooks, then we just
    # give up and avoid re-encoding the user's tags back into the comment.
    except Exception:
        raise

    # Finally we can encode the modified dict back into the function comment.
    else:
        comment(fn, internal.comment.encode(state), repeatable=where)

    # Release the hooks that were disabled now that that comment has been written.
    finally:
        [ ui.hook.idb.enable(item) for item in hooks ]

    # If we got here cleanly without an exception, then the tag was successfully
    # removed and we just need to update the tag cache with its removal.
    internal.comment.globals.dec(interface.range.start(fn), key)
    return res

@utils.multicase()
def tags():
    '''Returns all of the content tags for the function at the current address.'''
    return tags(ui.current.address())
@utils.multicase(ea=six.integer_types)
def tags(ea):
    '''Returns all of the content tags for the function at the address `ea`.'''
    fn, owners = by(ea), {item for item in chunk.owners(ea)}

    # If we have multiple owners, then consolidate all of their tags into a set.
    if len(owners) > 1:
        logging.warning(u"{:s}.tags({:#x}) : Returning all of the tags for the functions owning the given address ({:#x}) as it is owned by multiple functions ({:s}).".format(__name__, ea, ea, ', '.join(map("{:#x}".format, owners))))
        return {item for item in itertools.chain(*map(tags, owners))}

    # If we have only one owner, then we just need to point ourselves at it.
    item, = owners

    # Although if the chunk address wasn't in the owner list, then warn the user that we fixed it.
    if interface.range.start(fn) not in owners:
        logging.warning(u"{:s}.tags({:#x}) : Returning the tags for the function at address ({:#x}) as the chunk address ({:#x}) is not referencing a function ({:s}).".format(__name__, ea, item, interface.range.start(fn), ', '.join(map("{:#x}".format, owners))))
    return internal.comment.contents.name(item, target=item)
@utils.multicase()
def tags(func):
    '''Returns all of the content tags for the function `func`.'''
    fn = by(func)
    ea = interface.range.start(fn)
    return tags(ea)

@utils.multicase()
@utils.string.decorate_arguments('And', 'Or')
def select(**boolean):
    '''Query the contents of the current function for any tags specified by `boolean`'''
    return select(ui.current.function(), **boolean)
@utils.multicase(tag=six.string_types)
@utils.string.decorate_arguments('tag', 'And', 'Or')
def select(tag, *Or, **boolean):
    '''Query the contents of the current function for the specified `tag` and any others specified as `Or`.'''
    res = {tag} | {item for item in Or}
    boolean['Or'] = {item for item in boolean.get('Or', [])} | res
    return select(ui.current.function(), **boolean)
@utils.multicase(tag=six.string_types)
@utils.string.decorate_arguments('tag', 'And', 'Or')
def select(func, tag, *Or, **boolean):
    '''Query the contents of the function `func` for the specified `tag` and any others specified as `Or`.'''
    res = {tag} | {item for item in Or}
    boolean['Or'] = {item for item in boolean.get('Or', [])} | res
    return select(func, **boolean)
@utils.multicase(tag=(builtins.set, builtins.list))
@utils.string.decorate_arguments('tag', 'And', 'Or')
def select(func, tag, *Or, **boolean):
    '''Query the contents of the function `func` for the specified `tag` and any others specified as `Or`.'''
    res = {item for item in tag} | {item for item in Or}
    boolean['Or'] = {item for item in boolean.get('Or', [])} | res
    return select(func, **boolean)
@utils.multicase()
@utils.string.decorate_arguments('And', 'Or')
def select(func, **boolean):
    """Query the contents of the function `func` for any tags specified by `boolean`. Yields each address found along with the matching tags as a dictionary.

    If `And` contains an iterable then require the returned address contains them.
    If `Or` contains an iterable then include any other tags that are specified.
    """
    target = by(func)
    containers = (builtins.tuple, builtins.set, builtins.list)
    boolean = {key : {item for item in value} if isinstance(value, containers) else {value} for key, value in boolean.items()}

    # If nothing specific was queried, then yield all tags that are available.
    if not boolean:
        for ea in sorted(internal.comment.contents.address(interface.range.start(target), target=interface.range.start(target))):
            ui.navigation.analyze(ea)
            address = database.tag(ea)
            if address: yield ea, address
        return

    # Collect the tagnames being queried as specified by the user.
    Or, And = ({item for item in boolean.get(B, [])} for B in ['Or', 'And'])

    # Walk through every tagged address and cross-check it against the query.
    for ea in sorted(internal.comment.contents.address(interface.range.start(target), target=interface.range.start(target))):
        ui.navigation.analyze(ea)
        collected, address = {}, database.tag(ea)

        # Or(|) includes any of the tagnames that were selected.
        collected.update({key : value for key, value in address.items() if key in Or})

        # And(&) includes tags only if the address includes all of the specified tagnames.
        if And:
            if And & six.viewkeys(address) == And:
                collected.update({key : value for key, value in address.items() if key in And})
            else: continue

        # If anything was collected (matched), then yield the address and the matching tags.
        if collected: yield ea, collected
    return

@utils.multicase()
def switches():
    '''Yield each switch found in the current function.'''
    return switches(ui.current.function())
@utils.multicase()
def switches(func):
    '''Yield each switch found in the function identifed by `func`.'''
    get_switch_info = idaapi.get_switch_info_ex if idaapi.__version__ < 7.0 else idaapi.get_switch_info
    for ea in iterate(func):
        si = get_switch_info(ea)
        if si: yield interface.switch_t(si)
    return

class type(object):
    """
    This namespace allows one to query type information about a
    specified function. This allows one to get any attributes that IDA
    or a user has applied to a function within the database. This alows
    one to filter functions according to their particular attributes.

    This namespace is aliased as ``function.t``.

    Some of the functions within this namespace are also aliased as
    the following globals:

        ``function.convention`` - Interact with the calling convention (``idaapi.CM_CC_*``) for a function's prototype.
        ``function.result`` - Interact with the result type associated with a function's prototype.

    Some simple ways of getting information about a function::

        > print( function.type.has_noframe() )
        > for ea in filter(function.type.is_library, database.functions()): ...

    """
    @utils.multicase()
    def __new__(cls):
        '''Return the type information for the current function as an ``idaapi.tinfo_t``.'''
        return cls(ui.current.address())
    @utils.multicase(info=(six.string_types, idaapi.tinfo_t))
    def __new__(cls, info, **guessed):
        '''Apply the type information in `info` to the current function.'''
        return cls(ui.current.address(), info, **guessed)
    @utils.multicase(none=None.__class__)
    def __new__(cls, none):
        '''Remove the type information for the current function.'''
        return cls(ui.current.address(), None)
    @utils.multicase(func=(six.integer_types, idaapi.func_t))
    def __new__(cls, func):
        '''Return the type information for the function `func` as an ``idaapi.tinfo_t``.'''
        _, ea = interface.addressOfRuntimeOrStatic(func)

        # Guess the type information for the function ahead of time because
        # they should _always_ have type information associated with them.
        ti = idaapi.tinfo_t()
        if idaapi.GUESS_FUNC_FAILED == idaapi.guess_tinfo2(ea, ti) if idaapi.__version__ < 7.0 else idaapi.guess_tinfo(ti, ea):
            logging.debug(u"{:s}({:#x}) : Ignoring failure ({:d}) when trying to guess the `{:s}` for the specified function.".format('.'.join([__name__, cls.__name__]), ea, idaapi.GUESS_FUNC_FAILED, ti.__class__.__name__))

        # If we can find a proper typeinfo then use that, otherwise return
        # whatever it was that was guessed.
        return database.type(ea) or ti
    @utils.multicase(info=idaapi.tinfo_t)
    def __new__(cls, func, info, **guessed):
        '''Apply the ``idaapi.tinfo_t`` in `info` to the function `func`.'''
        TINFO_GUESSED, TINFO_DEFINITE = getattr(idaapi, 'TINFO_GUESSED', 0), getattr(idaapi, 'TINFO_DEFINITE', 1)

        # Now we can figure out what address we're actually working with.
        rt, ea = interface.addressOfRuntimeOrStatic(func)

        # If the type is not a function type whatsoever, then bail.
        if not any([info.is_func(), info.is_funcptr()]):
            raise E.InvalidTypeOrValueError("{:s}({:#x}, {!r}) : Refusing to apply a non-function type ({!r}) to the given {:s} ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info), 'address' if rt else 'function', ea))

        # If it's a regular function, then we can just use it as-is.
        if not rt:
            ti = info

        # If we're being used against an export, then we need to make sure that
        # our type is a function pointer and we need to promote it if not.
        elif not info.is_ptr():
            pi = idaapi.ptr_type_data_t()
            pi.obj_type = info
            ti = idaapi.tinfo_t()
            if not ti.create_ptr(pi):
                raise E.DisassemblerError("{:s}({:#x}, {!r}) : Unable to promote type to a pointer due to being applied to a function pointer.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info)))
            logging.warning("{:s}({:#x}, {!r}) : Promoting type ({!r}) to a function pointer ({!r}) due to the address ({:#x}) being runtime-linked.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info), "{!s}".format(info), "{!s}".format(ti), ea))

        # and then we just need to apply the type to the given address.
        result, ok = cls(ea), idaapi.apply_tinfo(ea, ti, TINFO_DEFINITE)
        if not ok:
            raise E.DisassemblerError("{:s}({:#x}, {!r}) : Unable to apply typeinfo ({!r}) to the {:s} ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info), "{!s}".format(ti), 'address' if rt else 'function', ea))

        # since TINFO_GUESSED doesn't always work, we clear aflags here.
        if guessed.get('guessed', False):
            interface.node.aflags(ea, idaapi.AFL_USERTI, 0)
        return result
    @utils.multicase(info=six.string_types)
    @utils.string.decorate_arguments('info')
    def __new__(cls, func, info, **guessed):
        '''Parse the type information string in `info` into an ``idaapi.tinfo_t`` and apply it to the function `func`.'''
        TINFO_GUESSED, TINFO_DEFINITE = getattr(idaapi, 'TINFO_GUESSED', 0), getattr(idaapi, 'TINFO_DEFINITE', 1)
        MANGLED_CODE, MANGLED_DATA, MANGLED_UNKNOWN = getattr(idaapi, 'MANGLED_CODE', 0), getattr(idaapi, 'MANGLED_DATA', 1), getattr(idaapi, 'MANGLED_UNKNOWN', 2)
        Fmangled_type = idaapi.get_mangled_name_type if hasattr(idaapi, 'get_mangled_name_type') else utils.fcompose(utils.frpartial(idaapi.demangle_name, 0), utils.fcondition(operator.truth)(0, MANGLED_UNKNOWN))
        MNG_NODEFINIT, MNG_NOPTRTYP, MNG_LONG_FORM = getattr(idaapi, 'MNG_NODEFINIT', 8), getattr(idaapi, 'MNG_NOPTRTYP', 7), getattr(idaapi, 'MNG_LONG_FORM', 0x6400007)
        til = idaapi.cvar.idati if idaapi.__version__ < 7.0 else idaapi.get_idati()

        # Figure out what we're actually going to be applying the type information to,
        # and figure out what its real name is so that we can mangle it if necessary.
        rt, ea = interface.addressOfRuntimeOrStatic(func)

        fname, mangled = name(ea), database.name(ea) if rt else utils.string.of(idaapi.get_func_name(ea))
        if fname and Fmangled_type(utils.string.to(mangled)) != MANGLED_UNKNOWN:
            realname = utils.string.of(idaapi.demangle_name(utils.string.to(mangled), MNG_NODEFINIT|MNG_NOPTRTYP) or fname)
        else:
            realname = fname

        # Now we can parse it and see what we have. If we couldn't parse it or it
        # wasn't an actual function of any sort, then we need to bail.
        ti = internal.declaration.parse(info)
        if not ti:
            raise E.InvalidTypeOrValueError(u"{:s}.info({:#x}, {!r}) : Unable to parse the provided string (\"{!s}\") into an actual type.".format('.'.join([__name__, cls.__name__]), ea, info, utils.string.escape(info, '"')))

        elif not any([ti.is_func(), ti.is_funcptr()]):
            raise E.InvalidTypeOrValueError("{:s}({:#x}, {!r}) : Refusing to apply a non-function type (\"{!s}\") to the given {:s} ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, info, utils.string.escape(info, '"'), 'address' if rt else 'function', ea))

        # Otherwise, te type is valid and we only need to figure out if it needs
        # to be promoted to a pointer or not.
        if rt and not ti.is_funcptr():
            pi = idaapi.ptr_type_data_t()
            pi.obj_type = ti
            ti = idaapi.tinfo_t()
            if not ti.create_ptr(pi):
                raise E.DisassemblerError("{:s}({:#x}, {!r}) : Unable to promote type to a pointer due to being applied to a function pointer.".format('.'.join([__name__, cls.__name__]), ea, info))

            # Now we re-render it into a string so that it can be applied.
            logging.warning("{:s}({:#x}, {!r}) : Promoting type ({!r}) to a function pointer ({!r}) due to the address ({:#x}) being runtime-linked.".format('.'.join([__name__, cls.__name__]), ea, info, info, "{!s}".format(ti), ea))
            info = idaapi.print_tinfo('', 0, 0, 0, ti, utils.string.to(realname), '')

        # Terminate the typeinfo string with a ';' so that IDA can parse it.
        terminated = info if info.endswith(';') else "{:s};".format(info)

        # Now we should just be able to apply it to the function.
        result, ok = cls(ea), idaapi.apply_cdecl(til, ea, terminated, TINFO_DEFINITE)
        if not ok:
            raise E.InvalidTypeOrValueError(u"{:s}.info({:#x}) : Unable to apply the specified type declaration (\"{!s}\").".format('.'.join([__name__, cls.__name__]), ea, utils.string.escape(info, '"')))

        # since TINFO_GUESSED doesn't always work, we clear aflags here.
        if guessed.get('guessed', False):
            interface.node.aflags(ea, idaapi.AFL_USERTI, 0)
        return result
    @utils.multicase(none=None.__class__)
    def __new__(cls, func, none):
        '''Remove the type information for the function `func`.'''
        rt, ea = interface.addressOfRuntimeOrStatic(func)

        # If we're interacting with a runtime address, then it's just regular type
        # information and we can just assign empty type information to it.
        if rt:
            return database.type(ea, none)

        # All we need to do is just delete the type information from the address.
        if hasattr(idaapi, 'del_tinfo'):
            result, _ = cls(ea), idaapi.del_tinfo(ea)

        elif idaapi.__version__ < 7.0:
            result, _ = cls(ea), idaapi.del_tinfo2(ea)

        # We don't have a real way to remove the type information from a function,
        # but what we can do is remove the NSUP_TYPEINFO(3000) and clear the its aflags.
        else:
            supvals = [idaapi.NSUP_TYPEINFO, idaapi.NSUP_TYPEINFO + 1]
            aflags = [idaapi.AFL_TI, idaapi.AFL_USERTI, getattr(idaapi, 'AFL_HR_GUESSED_FUNC', 0x40000000), getattr(idaapi, 'AFL_HR_GUESSED_DATA', 0x80000000)]

            # Save the original type, and zero out everything. This should pretty much get it done...
            result, _  = cls(ea), interface.node.aflags(ea, functools.reduce(operator.or_, aflags), 0)
            [ internal.netnode.sup.remove(ea, val) for val in supvals ]
        return result

    @utils.multicase()
    @classmethod
    def flags(cls):
        '''Return the flags for the current function.'''
        return cls.flags(ui.current.function())
    @utils.multicase()
    @classmethod
    def flags(cls, func):
        '''Return the flags for the function `func`.'''
        fn = by(func)
        return idaapi.as_uint32(fn.flags)
    @utils.multicase(mask=six.integer_types)
    @classmethod
    def flags(cls, func, mask):
        '''Return the flags for the function `func` selected with the specified `mask`.'''
        fn = by(func)
        return idaapi.as_uint32(fn.flags & mask)
    @utils.multicase(mask=six.integer_types, integer=(bool, six.integer_types))
    @classmethod
    def flags(cls, func, mask, integer):
        '''Set the flags for the function `func` selected by the specified `mask` to the provided `integer`.'''
        fn, preserve, value = by(func), idaapi.as_uint32(~mask), idaapi.as_uint32(-1 if integer else 0) if isinstance(integer, bool) else idaapi.as_uint32(integer)
        res, fn.flags = fn.flags, (fn.flags & preserve) | (value & mask)
        if not idaapi.update_func(fn):
            description = ("{:#x}" if isinstance(func, six.integer_types) else "{!r}").format(func)
            logging.fatal(u"{:s}.flags({:s}, {:#x}, {!s}) : Unable to change the flags ({:#x}) for function at {:s} to requested value ({:#x}).".format('.'.join([__name__, cls.__name__]), description, mask, value, idaapi.as_uint32(res), description, idaapi.as_uint32(fn.flags)))
        return idaapi.as_uint32(res & mask)

    @utils.multicase()
    @classmethod
    def has_problem(cls):
        '''Return if the current function has a problem associated with it.'''
        return cls.has_problem(ui.current.address())
    @utils.multicase()
    @classmethod
    def has_problem(cls, func):
        '''Return if the function `func` has a problem associated with it.'''
        PR_END = getattr(idaapi, 'PR_END', 17)
        iterable = (getattr(idaapi, attribute) for attribute in ['is_problem_present', 'QueueIsPresent'] if hasattr(idaapi, attribute))
        Fproblem = builtins.next(iterable, utils.fconstant(False))

        # Really only PR_BADSTACK is relevant, but we generalize all the problems
        # and by default only ignore ones related to decisions or FLAIR.
        ignored = {getattr(idaapi, name, default) for name, default in [('PR_FINAL', 13), ('PR_COLLISION', 14), ('PR_DECIMP', 15)]}
        problems = {problem for problem in builtins.range(1, PR_END)} - ignored

        # Figure out the function's address, and check if any of the problems apply.
        _, ea = interface.addressOfRuntimeOrStatic(func)
        return any(Fproblem(problem, ea) for problem in problems)
    @utils.multicase(problem=six.integer_types)
    @classmethod
    def has_problem(cls, func, problem):
        '''Return if the function `func` has the specified `problem` associated with it.'''
        PR_END = getattr(idaapi, 'PR_END', 17)
        iterable = (getattr(idaapi, attribute) for attribute in ['is_problem_present', 'QueueIsPresent'] if hasattr(idaapi, attribute))
        Fproblem = builtins.next(iterable, utils.fconstant(False))

        # Now we can just ask if the specified problem exists for the function.
        _, ea = interface.addressOfRuntimeOrStatic(func)
        return Fproblem(problem, ea)
    problem = problemQ = utils.alias(has_problem, 'type')

    @utils.multicase()
    @classmethod
    def problems(cls):
        '''Return the problems within the current function as set of integers which correspond to one of the ``idaapi.PR_*`` constants.'''
        return cls.problems(ui.current.function())
    @utils.multicase()
    @classmethod
    def problems(cls, func):
        '''Return the problems within the function `func` as set of integers which correspond to one of the ``idaapi.PR_*`` constants.'''
        PR_END = getattr(idaapi, 'PR_END', 17)
        iterable = (getattr(idaapi, attribute) for attribute in ['is_problem_present', 'QueueIsPresent'] if hasattr(idaapi, attribute))
        Fproblem = builtins.next(iterable, utils.fconstant(False))
        _, ea = interface.addressOfRuntimeOrStatic(func)
        return {problem for problem in builtins.range(1, PR_END) if Fproblem(problem, ea)}

    @utils.multicase()
    @classmethod
    def is_decompiled(cls):
        '''Return if the current function has been decompiled.'''
        return cls.is_decompiled(ui.current.address())
    @utils.multicase()
    @classmethod
    def is_decompiled(cls, func):
        '''Return if the function `func` has been decompiled.'''
        AFL_HR_DETERMINED = getattr(idaapi, 'AFL_HR_DETERMINED', 0xc0000000)
        _, ea = interface.addressOfRuntimeOrStatic(func)
        return interface.node.aflags(ea, AFL_HR_DETERMINED)
    decompiled = decompiledQ = utils.alias(is_decompiled, 'type')

    @utils.multicase()
    @classmethod
    def has_frame(cls):
        '''Return if the current function has a frame allocated to it.'''
        return cls.has_frame(ui.current.function())
    @utils.multicase()
    @classmethod
    def has_frame(cls, func):
        '''Return if the function `func` has a frame allocated to it.'''
        fn = by(func)
        return fn.frame != idaapi.BADADDR
    frame = frameQ = utils.alias(has_frame, 'type')

    @utils.multicase()
    @classmethod
    def has_frameptr(cls):
        '''Return if the current function uses a frame pointer (register).'''
        return cls.has_frameptr(ui.current.function())
    @utils.multicase()
    @classmethod
    def has_frameptr(cls, func):
        '''Return if the function `func` uses a frame pointer (register).'''
        return True if cls.flags(func, idaapi.FUNC_FRAME) else False
    frameptr = frameptrQ = utils.alias(has_frameptr, 'type')

    @utils.multicase()
    @classmethod
    def has_name(cls):
        '''Return if the current function has a user-defined name.'''
        return cls.has_name(ui.current.address())
    @utils.multicase()
    @classmethod
    def has_name(cls, func):
        '''Return if the function `func` has a user-defined name.'''
        _, ea = interface.addressOfRuntimeOrStatic(func)
        return database.type.has_customname(ea)
    named = nameQ = customnameQ = has_customname = utils.alias(has_name, 'type')

    @utils.multicase()
    @classmethod
    def has_return(cls):
        '''Return if the current function returns.'''
        return cls.has_return(ui.current.function())
    @utils.multicase()
    @classmethod
    def has_return(cls, func):
        '''Return if the function `func` returns.'''
        fn = by(func)
        if fn.flags & idaapi.FUNC_NORET_PENDING == idaapi.FUNC_NORET_PENDING:
            logging.warning(u"{:s}.has_return({:s}) : Analysis for function return is still pending. The flag (`idaapi.FUNC_NORET_PENDING`) is still set.".format('.'.join([__name__, cls.__name__]), ("{:#x}" if isinstance(func, six.integer_types) else "{!r}").format(func)))
        return not (fn.flags & idaapi.FUNC_NORET == idaapi.FUNC_NORET)
    returns = returnQ = utils.alias(has_return, 'type')

    @utils.multicase()
    @classmethod
    def is_library(cls):
        '''Return a boolean describing whether the current function is considered a library function.'''
        return cls.is_library(ui.current.function())
    @utils.multicase()
    @classmethod
    def is_library(cls, func):
        '''Return a boolean describing whether the function `func` is considered a library function.'''
        return True if cls.flags(func, idaapi.FUNC_LIB) else False
    libraryQ = utils.alias(is_library, 'type')

    @utils.multicase()
    @classmethod
    def library(cls):
        '''Return a boolean describing whether the current function is considered a library function.'''
        return cls.is_library(ui.current.function())
    @utils.multicase()
    @classmethod
    def library(cls, func):
        '''Return a boolean describing whether the function `func` is considered a library function.'''
        return cls.is_library(func)
    @utils.multicase()
    @classmethod
    def library(cls, func, boolean):
        '''Modify the attributes of the function `func` to set it as a library function depending on the value of `boolean`.'''
        return cls.flags(func, idaapi.FUNC_LIB, -1 if boolean else 0) == idaapi.FUNC_LIB

    @utils.multicase()
    @classmethod
    def is_thunk(cls):
        '''Return a boolean describing whether the current function was determined to be a code thunk.'''
        return cls.is_thunk(ui.current.function())
    @utils.multicase()
    @classmethod
    def is_thunk(cls, func):
        '''Return a boolean describing whether the function `func` was determined to be a code thunk.'''
        return True if cls.flags(func, idaapi.FUNC_THUNK) else False
    thunkQ = utils.alias(is_thunk, 'type')

    @utils.multicase()
    @classmethod
    def thunk(cls):
        '''Return a boolean describing whether the current function was determined to be a code thunk.'''
        return cls.is_thunk(ui.current.function())
    @utils.multicase()
    @classmethod
    def thunk(cls, func):
        '''Return a boolean describing whether the function `func` was determined to be a code thunk.'''
        return cls.is_thunk(func)
    @utils.multicase()
    @classmethod
    def thunk(cls, func, boolean):
        '''Modify the attributes of the function `func` to set it as a code thunk depending on the value of `boolean`.'''
        return cls.flags(func, idaapi.FUNC_THUNK, -1 if boolean else 0) == idaapi.FUNC_THUNK

    @utils.multicase()
    @classmethod
    def is_far(cls):
        '''Return a boolean describing whether the current function is considered a "far" function by IDA or the user.'''
        return cls.is_far(ui.current.function())
    @utils.multicase()
    @classmethod
    def is_far(cls, func):
        '''Return a boolean describing whether the function `func` is considered a "far" function by IDA or the user.'''
        return True if cls.flags(func, idaapi.FUNC_FAR | idaapi.FUNC_USERFAR) else False
    far = farQ = utils.alias(is_far, 'type')

    @utils.multicase()
    @classmethod
    def is_static(cls):
        '''Return a boolean describing whether the current function is defined as a static function.'''
        return cls.is_static(ui.current.function())
    @utils.multicase()
    @classmethod
    def is_static(cls, func):
        '''Return a boolean describing whether the function `func` is defined as a static function.'''
        FUNC_STATICDEF = idaapi.FUNC_STATICDEF if hasattr(idaapi, 'FUNC_STATICDEF') else idaapi.FUNC_STATIC
        return True if cls.flags(func, FUNC_STATICDEF) else False
    staticQ = utils.alias(is_static, 'type')

    @utils.multicase()
    @classmethod
    def static(cls):
        '''Return a boolean describing whether the current function is defined as a static function.'''
        return cls.is_static(ui.current.function())
    @utils.multicase()
    @classmethod
    def static(cls, func):
        '''Return a boolean describing whether the function `func` is defined as a static function.'''
        return cls.is_static(func)
    @utils.multicase()
    @classmethod
    def static(cls, func, boolean):
        '''Modify the attributes of the function `func` to set it as a static function depending on the value of `boolean`.'''
        FUNC_STATICDEF = idaapi.FUNC_STATICDEF if hasattr(idaapi, 'FUNC_STATICDEF') else idaapi.FUNC_STATIC
        return cls.flags(func, FUNC_STATICDEF, -1 if boolean else 0) == FUNC_STATICDEF

    @utils.multicase()
    @classmethod
    def is_hidden(cls):
        '''Return a boolean describing whether the current function is hidden.'''
        return cls.is_hidden(ui.current.function())
    @utils.multicase()
    @classmethod
    def is_hidden(cls, func):
        '''Return a boolean describing whether the function `func` is hidden.'''
        return True if cls.flags(func, idaapi.FUNC_HIDDEN) else False
    hiddenQ = utils.alias(is_hidden, 'type')

    @utils.multicase()
    @classmethod
    def hidden(cls):
        '''Return a boolean describing whether the current function is hidden.'''
        return cls.is_hidden(ui.current.function())
    @utils.multicase()
    @classmethod
    def hidden(cls, func):
        '''Return a boolean describing whether the function `func` is hidden.'''
        return cls.is_hidden(func)
    @utils.multicase()
    @classmethod
    def hidden(cls, func, boolean):
        '''Modify the attributes of the function `func` to set it as a hidden function depending on the value of `boolean`.'''
        return cls.flags(func, idaapi.FUNC_HIDDEN, -1 if boolean else 0) == idaapi.FUNC_HIDDEN

    @utils.multicase()
    @classmethod
    def has_prototype(cls):
        '''Return a boolean describing whether the current function has a prototype associated with it.'''
        return cls.has_prototype(ui.current.address())
    @utils.multicase()
    @classmethod
    def has_prototype(cls, func):
        '''Return a boolean describing whether the function `func` has a prototype associated with it.'''
        _, ea = interface.addressOfRuntimeOrStatic(func)
        return database.type.has_typeinfo(ea)
    prototype = prototypeQ = has_typeinfo = typeinfoQ = utils.alias(has_prototype, 'type')

    @utils.multicase()
    @classmethod
    def convention(cls):
        '''Return the calling convention of the current function.'''
        # we avoid ui.current.function() so that we can also act on pointers.
        return cls.convention(ui.current.address())
    @utils.multicase()
    @classmethod
    def convention(cls, func):
        """Return the calling convention of the function `func`.

        The integer returned corresponds to one of the ``idaapi.CM_CC_*`` constants.
        """
        get_tinfo = (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo
        try:
            _, ea = interface.addressOfRuntimeOrStatic(func)

        # If we couldn't resolve the function, then consider our parameter
        # as the calling convention that we're going to apply to the current address.
        except E.FunctionNotFoundError:
            return cls.convention(ui.current.address(), func)

        # Grab the type information from the address that we resolved. We avoid
        # doing any "guessing" here and only work with an explicitly applied type.
        ti = idaapi.tinfo_t()
        if not get_tinfo(ti, ea):
            raise E.MissingTypeOrAttribute(u"{:s}.convention({:#x}) : Specified function {:#x} does not contain a prototype declaration.".format('.'.join([__name__, cls.__name__]), ea, ea))

        # Now we can just grab the function details for this type, use it to extract
        # the convention and the spoiled count, and then return what we found.
        _, ftd = interface.tinfo.function_details(ea, ti)
        result, spoiled_count = ftd.cc & idaapi.CM_CC_MASK, ftd.cc & ~idaapi.CM_CC_MASK
        return result
    @utils.multicase(convention=six.string_types)
    @classmethod
    def convention(cls, func, convention):
        '''Set the calling convention used by the prototype for the function `func` to the specified `convention` string.'''
        cclookup = {
            '__cdecl': idaapi.CM_CC_CDECL,
            '__stdcall': idaapi.CM_CC_STDCALL,
            '__pascal': idaapi.CM_CC_PASCAL,
            '__fastcall': idaapi.CM_CC_FASTCALL,
            '__thiscall': idaapi.CM_CC_THISCALL,
        }

        # Try to normalize the string so that it will match an entry in our table.
        noncommonsuffix = {item for item in cclookup if not item.endswith('call')}
        prefixed = convention.lower() if convention.startswith('__') else "__{:s}".format(convention).lower()
        string = prefixed if operator.contains(noncommonsuffix, prefixed) or prefixed.endswith('call') else "{:s}call".format(prefixed)

        # FIXME: we should probably use globs, or something more intelligent
        #        to figure out what convention the user is trying apply.

        # Verify that the string can be found in our lookup table, and then use it to grab our cc.
        if not operator.contains(cclookup, string):
            raise E.ItemNotFoundError(u"{:s}.convention({!r}, {!r}) : The convention that was specified ({!r}) is not of the known types ({:s}).".format('.'.join([__name__, cls.__name__]), func, convention, string, ', '.join(cclookup)))
        cc = cclookup[string]

        # Now we have the calling convention integer that we can use.
        return cls.convention(func, cc)
    @utils.multicase(convention=six.integer_types)
    @classmethod
    def convention(cls, func, convention):
        '''Set the calling convention used by the prototype for the function `func` to the specified `convention`.'''
        _, ea = interface.addressOfRuntimeOrStatic(func)
        get_tinfo = (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo

        # Grab the type information from the resolved address.
        ti = idaapi.tinfo_t()
        if not get_tinfo(ti, ea):
            raise E.MissingTypeOrAttribute(u"{:s}.convention({:#x}, {:#x}) : The specified function ({:#x}) does not contain a prototype declaration.".format('.'.join([__name__, cls.__name__]), ea, convention, ea))

        # Now we just need to create the strpath.update_function_details
        # coroutine. Our first result will contain the function details
        # for us to tinker with.
        updater = interface.tinfo.update_function_details(ea, ti)
        _, ftd = builtins.next(updater)

        # Update the calling convention whilst preserving the spoiled count.
        # If it has extra bits that were set, then we need to warn the user
        # about it, and then we can send it back to the updater.
        if convention & ~idaapi.CM_CC_MASK:
            logging.warning(u"{:s}.convention({:#x}, {:#x}) : The convention that was provided ({:#x}) contains extra bits ({:#x}) that will be masked ({:#x}) out.".format('.'.join([__name__, cls.__name__]), ea, convention, convention, convention & ~idaapi.CM_CC_MASK, idaapi.CM_CC_MASK))
        result, ftd.cc = ftd.cc, (ftd.cc & ~idaapi.CM_CC_MASK) | (convention & idaapi.CM_CC_MASK)

        # Now we can send the updater our modified ftd, close it, and then
        # return the value that was set prevously.
        updater.send(ftd), updater.close()
        return result & idaapi.CM_CC_MASK
    cc = utils.alias(convention, 'type')

    class result(object):
        """
        This namespace allows one to interact with the result as defined
        within a function prototype. This allows one to fetch or modify
        the type information that is returned by a function.

        Some ways to utilize this namespace can be::

            > print( function.type.result() )
            > print( function.type.result.location() )

        """
        @utils.multicase()
        def __new__(cls):
            '''Return the result type for the current function as an ``idaapi.tinfo_t``.'''
            # we avoid ui.current.function() so that we can also act on function pointers.
            return cls(ui.current.address())
        @utils.multicase(info=idaapi.tinfo_t)
        def __new__(cls, info):
            '''Modify the result type for the current function to the type information provided as an ``idaapi.tinfo_t`` provided in `info`.'''
            return cls(ui.current.address(), info)
        @utils.multicase()
        def __new__(cls, func):
            '''Return the result type for the function `func` as an ``idaapi.tinfo_t``.'''
            try:
                _, ea = internal.interface.addressOfRuntimeOrStatic(func)

            # If we couldn't resolve the function, then consider our parameter
            # as some type information that we're going to apply to the current one.
            except E.FunctionNotFoundError:
                return cls(ui.current.address(), func)

            # The user gave us a function to try out, so we'll try and grab the
            # type information from the address we resolved.
            else:
                ti = type(ea)

            # Now we can grab our function details and then return the type.
            _, ftd = interface.tinfo.function_details(ea, ti)
            return ftd.rettype
        @utils.multicase(info=six.string_types)
        @utils.string.decorate_arguments('info')
        def __new__(cls, func, info):
            '''Modify the result type for the function `func` to the type information provided as a string in `info`.'''

            # FIXME: figure out the proper way to parse a type instead of as a declaration
            tinfo = internal.declaration.parse(info)
            if tinfo is None:
                raise E.InvalidTypeOrValueError(u"{:s}.result({!r}, {!r}) : Unable to parse the provided type information ({!r})".format('.'.join([__name__, cls.__name__]), func, info, info))
            return cls(func, tinfo)
        @utils.multicase(info=idaapi.tinfo_t)
        def __new__(cls, func, info):
            '''Modify the result type for the function `func` to the type information provided as an ``idaapi.tinfo_t`` in `info`.'''
            _, ea = interface.addressOfRuntimeOrStatic(func)
            get_tinfo = (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo

            # Grab the type information from the function that we'll update with.
            ti = idaapi.tinfo_t()
            if not get_tinfo(ti, ea):
                raise E.MissingTypeOrAttribute(u"{:s}.result({:#x}, {!r}) : Specified function {:#x} does not contain a prototype declaration.".format('.'.join([__name__, cls.__name__]), ea, "{!s}".format(info), ea))

            # Now we can create an updater, and grab the details out of it.
            updater = interface.tinfo.update_function_details(ea, ti)
            _, ftd = builtins.next(updater)

            # From this, we'll trade the return type with the one the user gave us,
            # and then send it back to the updater to write it to the address.
            result, ftd.rettype = ftd.rettype, info
            updater.send(ftd), updater.close()

            # That was it and we only need to return the previous value.
            return result

        @utils.multicase()
        @classmethod
        def storage(cls):
            '''Return the storage location of the result belonging to the current function.'''
            return cls.storage(ui.current.address())
        @utils.multicase()
        @classmethod
        def storage(cls, func):
            '''Return the storage location of the result belonging to the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti = type(ea)

            # Grab the function details, rip the result type and location out of them.
            _, ftd = interface.tinfo.function_details(ea, ti)
            tinfo, location = ftd.rettype, ftd.retloc
            locinfo = interface.tinfo.location_raw(location)

            # Get the location out of it, and then figure out how to return it.
            result = interface.tinfo.location(tinfo.get_size(), instruction.architecture, *locinfo)
            if builtins.isinstance(result, builtins.tuple) and any(isinstance(item, interface.register_t) for item in result):
                reg, offset = result
                return result if offset else reg
            return result

    class argument(object):
        """
        This namespace allows one to interact with individual arguments
        within a function prototype. This allows one to rename or modify
        the type information for a particular argument within its definition.

        This namespace is aliased as ``function.type.arg`` and ``function.type.parameter``.

        Some simple ways of fetching or modifying the type of the first parameter
        in a function:

            > print( function.argument(0) )
            > print( function.argument.name(1) )
            > oldtype = function.argument(0, 'void*')
            > oldname = function.argument.name(1)
            > storage = function.argument.storage(2)
            > index = function.argument.remove(3)

        """

        @utils.multicase(index=six.integer_types)
        def __new__(cls, index):
            '''Return the type information for the parameter at the specified `index` of the current function.'''
            return cls(ui.current.address(), index)
        @utils.multicase(index=six.integer_types, info=(six.string_types, idaapi.tinfo_t))
        def __new__(cls, index, info):
            '''Modify the type information for the parameter at the specified `index` of the current function to `info`.'''
            return cls(ui.current.address(), index, info)
        @utils.multicase(index=six.integer_types)
        def __new__(cls, func, index):
            '''Return the type information for the parameter at the specified `index` of the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti = type(ea)

            # Use the address and tinfo to grab the details containing our arguments,
            # and then check that the index is within its boundaries.
            _, ftd = interface.tinfo.function_details(ea, ti)
            if not (0 <= index < ftd.size()):
                raise E.InvalidTypeOrValueError(u"{:s}({:#x}, {:d}) : The provided index ({:d}) is not within the range of the number of arguments ({:d}) for the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, index, index, ftd.size(), ea))

            # Now we can grab the argument using the index we were given and return its type.
            result = ftd[index]
            return result.type
        @utils.multicase(index=six.integer_types, info=idaapi.tinfo_t)
        def __new__(cls, func, index, info):
            '''Modify the type information for the parameter at the specified `index` of the function `func` to `info`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti = type(ea)

            # We're going to update the type information as the specified address.
            # So we'll use interface.tinfo.update_function_details to create an
            # updater...
            updater = interface.tinfo.update_function_details(ea, ti)

            # ...and then we grab the details out of it to check the user's index.
            _, ftd = builtins.next(updater)
            if not (0 <= index < ftd.size()):
                raise E.InvalidTypeOrValueError(u"{:s}({:#x}, {:d}, {!r}) : The provided index ({:d}) is not within the range of the number of arguments ({:d}) for the specified function ({:#x}).".format('.'.join([__name__, cls.__name__]), ea, index, "{!s}".format(info), index, ftd.size(), ea))

            # Now we can just trade their type with the argument at the given index.
            argument = ftd[index]
            result, argument.type = argument.type, info

            # Then we can send it back to our updater, and return the previous value.
            updater.send(ftd), updater.close()
            return result
        @utils.multicase(index=six.integer_types, info=six.string_types)
        @utils.string.decorate_arguments('info')
        def __new__(cls, func, index, info):
            '''Modify the type information for the parameter at the specified `index` of the function `func` to the string in `info`.'''
            tinfo = internal.declaration.parse(info)
            if tinfo is None:
                raise E.InvalidTypeOrValueError(u"{:s}({!r}, {:d}, {!r}) : Unable to parse the provided type information ({!r}).".format('.'.join([__name__, cls.__name__]), func, index, info, info))
            return cls(func, index, tinfo)

        @utils.multicase(index=six.integer_types)
        @classmethod
        def name(cls, index):
            '''Return the name of the parameter at the specified `index` in the current function.'''
            return cls.name(ui.current.address(), index)
        @utils.multicase(index=six.integer_types, none=None.__class__)
        @classmethod
        def name(cls, index, none):
            '''Remove the name from the parameter at the specified `index` in the current function.'''
            return cls.name(ui.current.address(), index, none)
        @utils.multicase(index=six.integer_types, string=six.string_types)
        @classmethod
        def name(cls, index, string, *suffix):
            '''Modify the name of the parameter at the specified `index` of the current function to `string`.'''
            return cls.name(ui.current.address(), index, string, *suffix)
        @utils.multicase(index=six.integer_types)
        @classmethod
        def name(cls, func, index):
            '''Return the name of the parameter at the specified `index` in the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti = type(ea)

            # Use the address and type to get the function details, and then check that
            # the user's index is within their boundaries to access the argument name.
            _, ftd = interface.tinfo.function_details(ea, ti)
            if not (0 <= index < ftd.size()):
                raise E.InvalidTypeOrValueError(u"{:s}.name({:#x}, {:d}) : The provided index ({:d}) is not within the range of the number of arguments ({:d}) for the specified function ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, index, index, ftd.size(), ea))

            # Now we can grab the argument using the index we were given and return its name.
            result = ftd[index]
            return utils.string.of(result.name) or None
        @utils.multicase(index=six.integer_types, none=None.__class__)
        @classmethod
        def name(cls, func, index, none):
            '''Remove the name from the parameter at the specified `index` in the function `func`.'''
            return cls.name(func, index, '')
        @utils.multicase(index=six.integer_types, string=six.string_types)
        @classmethod
        @utils.string.decorate_arguments('string', 'suffix')
        def name(cls, func, index, string, *suffix):
            '''Modify the name of the parameter at the specified `index` of the function `func` to `string`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti, name = type(ea), interface.tuplename(*itertools.chain([string], suffix))

            # Now we can just use the address and type to create an updater for
            # our function details. Grab the func_type_data_t from it and check
            # that the user's argument index is within its bounds.
            updater = interface.tinfo.update_function_details(ea, ti)
            _, ftd = builtins.next(updater)
            if not (0 <= index < ftd.size()):
                raise E.InvalidTypeOrValueError(u"{:s}.name({:#x}, {:d}, {!s}) : The provided index ({:d}) is not within the range of the number of arguments ({:d}) for the specified function ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, index, utils.string.repr(name), index, ftd.size(), ea))

            # Only thing left to do is to trade the name the user gave us with
            # whatever was stored at the parameter index they specified.
            argument = ftd[index]
            result, argument.name = argument.name, utils.string.to(name)

            # Now we can send the whole thing back to the updater, close it,
            # and then return the previous result that was assigned.
            updater.send(ftd), updater.close()
            return result or None

        @utils.multicase(index=six.integer_types)
        @classmethod
        def storage(cls, index):
            '''Return the storage location of the parameter at the specified `index` in the current function.'''
            return cls.storage(ui.current.address(), index)
        @utils.multicase(index=six.integer_types)
        @classmethod
        def storage(cls, func, index):
            '''Return the storage location of the parameter at the specified `index` in the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            locations = [item for _, _, item in type.arguments.iterate(func)]

            # As always, check our bounds and raise an exception...cleanly.
            if not (0 <= index < len(locations)):
                raise E.InvalidTypeOrValueError(u"{:s}.storage({:#x}, {:d}) : The provided index ({:d}) is not within the range of the number of arguments ({:d}) for the specified function ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, index, index, len(locations), ea))
            location = locations[index]

            # Otherwise, this might be a tuple and we return the whole thing
            # unless its a (register, offset). If it is, then check that it's
            # a zero-offset because then we can return just the register.
            if isinstance(location, builtins.tuple):
                reg, off = location
                if isinstance(off, six.integer_types) and off == 0:
                    return reg
                return location
            return location

        @utils.multicase(index=six.integer_types)
        @classmethod
        def remove(cls, index):
            '''Remove the parameter at the specified `index` from the current function.'''
            return cls.remove(ui.current.address(), index)
        @utils.multicase(index=six.integer_types)
        @classmethod
        def remove(cls, func, index):
            '''Remove the parameter at the specified `index` from the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            updater = interface.tinfo.update_function_details(ea, type(ea))

            # Grab the type and the details and verify the index is valid before
            # collecting into a list that we'll use for modifying things.
            ti, ftd = builtins.next(updater)
            if not (0 <= index < ftd.size()):
                raise E.InvalidTypeOrValueError(u"{:s}.remove({:#x}, {:d}) : The provided index ({:d}) is not within the range of the number of arguments ({:d}) for the specified function ({:#x}).".format('.'.join([__name__, 'type', cls.__name__]), ea, index, index, ftd.size(), ea))
            items = [ftd[idx] for idx in builtins.range(ftd.size())]

            # Now we can safely modify out list, and pop out the funcarg_t from it.
            farg = items.pop(index)
            name, result, location, comment = utils.string.of(farg.name), farg.type, farg.argloc, farg.cmt

            # Instead of recreating the func_type_data_t, we'll reassign the
            # references back in, and then resize it afterwards.
            for idx, item in enumerate(items):
                ftd[idx] = item
            ftd.resize(len(items))

            # At this point we shouldn't have any references to anything that we
            # modified, and can send it back to update the prototype correctly.
            updater.send(ftd), updater.close()
            return result
        pop = utils.alias(remove, 'type.argument')

        @utils.multicase(index=six.integer_types)
        @classmethod
        def location(cls, index):
            '''Return the address of the parameter at `index` that is passed to the function referenced at the current address.'''
            return cls.location(ui.current.address(), index)
        @utils.multicase(ea=six.integer_types, index=six.integer_types)
        @classmethod
        def location(cls, ea, index):
            '''Return the address of the parameter at `index` that is passed to the function referenced at the address `ea`.'''
            items = type.arguments.locations(ea)
            return items[index]

    arg = parameter = argument  # XXX: ns alias

    class arguments(object):
        """
        This namespace allows one to interact the with the arguments
        belonging to a function prototype as a whole. This can allow
        one to count the number of arguments, or fetch all their names
        and types in their entirety.

        This namespace is aliased as ``function.type.args`` and ``function.type.parameters``.
        """
        @utils.multicase()
        def __new__(cls):
            '''Return the type information for each of the parameters belonging to the current function.'''
            return cls(ui.current.address())
        @utils.multicase()
        def __new__(cls, func):
            '''Return the type information for each of the parameters belonging to the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti = type(ea)

            # Use the address and type to snag the details requested by the
            # caller, iterate through it, and then return each type as a list.
            _, ftd = interface.tinfo.function_details(ea, ti)
            iterable = (ftd[index] for index in builtins.range(ftd.size()))
            return [item.type for item in iterable]
        @utils.multicase(types=(builtins.list, builtins.tuple))
        def __new__(cls, func, types):
            '''Overwrite the type information for the parameters belonging to the function `func` with the provided list of `types`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            updater = interface.tinfo.update_function_details(ea, type(ea))

            # Grab the type and parameters so we can capture all of the ones that will be replaced.
            ti, ftd = builtins.next(updater)

            # Iterate through all of the parameters capturing all of the state that we'll return.
            results = []
            for idx in builtins.range(ftd.size()):
                farg = ftd[idx]
                aname, atype, aloc, acmt = farg.name, farg.type, farg.argloc, farg.cmt
                results.append((aname, atype, aloc, acmt))

            # Now we should able to resize our details, and then update them with our input.
            ftd.resize(len(types))
            for index, item in enumerate(types):
                aname, ainfo = item if isinstance(item, builtins.tuple) else ('', item)
                ftd[index].name, ftd[index].type = utils.string.to(aname), internal.declaration.parse(ainfo) if isinstance(ainfo, six.string_types) else ainfo
            updater.send(ftd), updater.close()

            # The very last thing we need to do is to return our results. Even though we collected
            # all their information for safety, we return just the types for simplicity.
            return [item for _, item, _, _ in results]

        @utils.multicase()
        @classmethod
        def count(cls):
            '''Return the number of parameters in the prototype for the current function.'''
            return cls.count(ui.current.address())
        @utils.multicase()
        @classmethod
        def count(cls, func):
            '''Return the number of parameters in the prototype of the function identified by `func`.'''
            ti = type(func)
            return ti.get_nargs()

        @utils.multicase()
        @classmethod
        def types(cls):
            '''Return the type information for each of the parameters belonging to the current function.'''
            return cls(ui.current.address())
        @utils.multicase()
        @classmethod
        def types(cls, func):
            '''Return the type information for each of the parameters belonging to the function `func`.'''
            return cls(func)
        @utils.multicase(types=(builtins.list, builtins.tuple))
        @classmethod
        def types(cls, func, types):
            '''Overwrite the type information for the parameters belonging to the function `func` with the provided list of `types`.'''
            return cls(func, types)
        type = utils.alias(types, 'type.arguments')

        @utils.multicase()
        @classmethod
        def names(cls):
            '''Return the names for each of the parameters belonging to the current function.'''
            return cls.names(ui.current.address())
        @utils.multicase()
        @classmethod
        def names(cls, func):
            '''Return the names for each of the parameters belonging to the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti, ftd = interface.tinfo.function_details(ea, type(ea))

            # Iterate through the function details and return each name as a list.
            iterable = (ftd[index] for index in builtins.range(ftd.size()))
            return [utils.string.to(item.name) for item in iterable]
        @utils.multicase(names=(builtins.list, builtins.tuple))
        @classmethod
        def names(cls, names):
            '''Overwrite the names for the parameters belonging to the current function with the provided list of `names`.'''
            return cls.names(ui.current.address(), names)
        @utils.multicase(names=(builtins.list, builtins.tuple))
        @classmethod
        def names(cls, func, names):
            '''Overwrite the names for the parameters belonging to the function `func` with the provided list of `names`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)

            # Grab the type and parameters so we can capture all of the ones that will be replaced.
            updater = interface.tinfo.update_function_details(ea, type(ea))
            ti, ftd = builtins.next(updater)

            # Force all of the names we were given into string that we can actually apply. Afterwards
            # we check to see if we were given any extra that we need to warn the user about.
            strings = [item for item in map("{!s}".format, names)]
            if strings[ftd.size():]:
                discarded = ["\"{:s}\"".format(utils.string.escape(item, '"')) for item in strings[ftd.size():]]
                logging.warning(u"{:s}.names({:#x}, {!r}) : Discarding {:d} additional name{:s} ({:s}) that {:s} given for the specified function which has only {:d} parameter{:s}.".format('.'.join([__name__, cls.__name__]), ea, names, len(discarded), '' if len(discarded) == 1 else 's', ', '.join(discarded), 'was' if len(discarded) == 1 else 'were', ftd.size(), '' if ftd.size() == 1 else 's'))

            # Now we'll go through all of the available parameters, and update the names. If
            # we weren't given one, then we just assign an empty name to the funcarg_t.
            results = []
            for index in builtins.range(ftd.size()):
                farg, item = ftd[index], strings[index] if index < len(strings) else ''
                results.append(utils.string.of(farg.name))
                ftd[index].name = utils.string.to(item)

            # That was it, just need to update everything and return our results.
            updater.send(ftd), updater.close()
            return results
        name = utils.alias(names, 'type.arguments')

        @utils.multicase()
        @classmethod
        def iterate(cls):
            '''Yield the `(name, type, storage)` of each of the parameters belonging to the current function.'''
            return cls.iterate(ui.current.address())
        @utils.multicase()
        @classmethod
        def iterate(cls, func):
            '''Yield the `(name, type, storage)` of each of the parameters belonging to the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            ti = type(ea)

            # This should be easy, as we only need to grab the details from the type.
            _, ftd = interface.tinfo.function_details(ea, ti)

            # Then we can just iterate through them and grab their raw values.
            items = []
            for index in builtins.range(ftd.size()):
                loc, name, ti = ftd[index].argloc, ftd[index].name, ftd[index].type
                locinfo = interface.tinfo.location_raw(loc)
                items.append((utils.string.of(name), ti, locinfo))

            # Now we can iterate through each of these items safely, process them,
            # and then yield each individual item to the caller.
            for index, item in enumerate(items):
                name, ti, storage = item
                ltype, linfo = storage
                result = interface.tinfo.location(ti.get_size(), instruction.architecture, ltype, linfo)

                # Check to see if we got an error. We do this with a hack, by
                # doing an identity check on what was returned.
                if result is linfo:
                    ltype_table = {getattr(idaapi, attribute) : attribute for attribute in dir(idaapi) if attribute.startswith('ALOC_')}
                    ltype_s = ltype_table.get(ltype, '')
                    logging.warning(u"{:s}.iterate({:#x}) : Unable to handle the unsupported type {:s}({:#x}) for argument at index {:d}{:s}{:s}.".format('.'.join([__name__, cls.__name__]), ea, ltype_s, ltype, index, " with the name \"{:s}\"".format(utils.string.escape(name, '"')) if name else '', " of the type {!s}".format(ti) if ti.is_well_defined() else ''))

                # Now we can yield our result that we determined for each parameter.
                yield name, ti, result
            return

        @utils.multicase()
        @classmethod
        def registers(cls):
            '''Return the registers for each of the parameters belonging to the current function.'''
            return cls.registers(ui.current.address())
        @utils.multicase()
        @classmethod
        def registers(cls, func):
            '''Return the registers for each of the parameters belonging to the function `func`.'''
            result = []
            for _, _, loc in cls.iterate(func):
                if isinstance(loc, builtins.tuple) and any(isinstance(item, interface.register_t) for item in loc):
                    reg, offset = loc
                    item = loc if all(isinstance(item, interface.register_t) for item in loc) else loc if offset else reg
                    result.append(item)
                continue
            return result
        regs = utils.alias(registers, 'type.arguments')

        @utils.multicase()
        @classmethod
        def storage(cls):
            '''Return the storage location for each of the parameters belonging to the current function.'''
            return cls.storage(ui.current.address())
        @utils.multicase()
        @classmethod
        def storage(cls, func):
            '''Return the storage locations for each of the parameters belonging to the function `func`.'''
            iterable = (location for _, _, location in cls.iterate(func))
            result = []
            for _, _, item in cls.iterate(func):
                if isinstance(item, builtins.tuple) and isinstance(item[1], six.integer_types):
                    register, offset = item
                    result.append(item if offset else register)
                else:
                    result.append(item)
                continue
            return result

        @utils.multicase(info=(six.string_types, idaapi.tinfo_t))
        @classmethod
        def add(cls, info):
            '''Add the provided type information in `info` as another parameter to the current function.'''
            return cls.add(ui.current.address(), info, '')
        @utils.multicase(info=(six.string_types, idaapi.tinfo_t))
        @classmethod
        def add(cls, func, info):
            '''Add the provided type information in `info` as another parameter to the function `func`.'''
            return cls.add(func, info, '')
        @utils.multicase(info=(six.string_types, idaapi.tinfo_t), name=six.string_types)
        @classmethod
        @utils.string.decorate_arguments('name', 'suffix')
        def add(cls, func, info, name, *suffix):
            '''Add the provided type information in `info` with the given `name` as another parameter to the function `func`.'''
            _, ea = internal.interface.addressOfRuntimeOrStatic(func)
            updater = interface.tinfo.update_function_details(ea, type(ea))

            # Grab the type and the details, and then resize it to add space for another parameter.
            ti, ftd = builtins.next(updater)
            index, _ = ftd.size(), ftd.resize(ti.get_nargs() + 1)

            # Convert all our parameters and update the index we allocated space for.
            res = name if isinstance(name, tuple) else (name,)
            aname, ainfo = interface.tuplename(*(res + suffix)), internal.declaration.parse(info) if isinstance(info, six.string_types) else info
            ftd[index].name, ftd[index].type = utils.string.to(aname), ainfo

            # We should be good to go and we just need to return the index.
            updater.send(ftd), updater.close()
            return index
        append = utils.alias(add, 'type.arguments')

        @utils.multicase()
        @classmethod
        def locations(cls):
            '''Return the address of each of the parameters being passed to the function referenced at the current address.'''
            return cls.locations(ui.current.address())
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def locations(cls, ea):
            '''Return the address of each of the parameters being passed to the function referenced at address `ea`.'''
            if not database.xref.code_down(ea):
                raise E.InvalidTypeOrValueError(u"{:s}.arguments({:#x}) : Unable to return any parameters as the provided address ({:#x}) {:s} code references.".format('.'.join([__name__, cls.__name__]), ea, ea, 'does not have any' if instruction.type.is_call(ea) else 'is not a call instruction with'))
            items = idaapi.get_arg_addrs(ea)
            return [] if items is None else [ea for ea in items]
        @utils.multicase(ea=six.integer_types)
        @classmethod
        def locations(cls, func, ea):
            '''Return the address of each of the parameters for the function `func` that are being passed to the function referenced at address `ea`.'''
            refs = {ref for ref in cls.up(func)}
            if ea not in refs:
                logging.warning(u"{:s}.arguments({!r}, {:#x}) : Ignoring the provided function ({:#x}) as the specified reference ({:#x}) is not referring to it.".format('.'.join([__name__, cls.__name__]), func, ea, address(func), ea))
            return cls.locations(ea)
        location = utils.alias(locations, 'type.arguments')

    args = parameters = arguments

t = type # XXX: ns alias
convention = cc = utils.alias(type.convention, 'type')
result = type.result # XXX: ns alias
arguments = args = type.arguments   # XXX: ns alias
argument = arg = type.argument  # XXX: ns alias

class xref(object):
    """
    This namespace is for navigating the cross-references (xrefs)
    associated with a function in the database. This allows for one
    to return all of the callers for a function, as well as all of
    the functions that it may call.

    This namespace is aliased as ``function.x``.

    Some of the functions within this namespace are also aliased as
    the following globals:

        ``function.up`` - Return all the addresses that reference a function
        ``function.down`` - Return the callable addresses referenced by a function

    Some ways to utilize this namespace can be::

        > print( function.xref.up() )
        > for ea in function.xref.down(): ...

    """

    ## referencing
    @utils.multicase()
    @classmethod
    def down(cls, **references):
        '''Return all of the addresses that are referenced by a branch instruction from the current function.'''
        return down(ui.current.function(), **references)
    @utils.multicase()
    @classmethod
    def down(cls, func, **references):
        """Return all of the addresses that are referenced by a branch instruction from the function `func`.

        If the boolean `references` is true, then include the reference address of each instruction along with its.
        """
        get_switch_info = idaapi.get_switch_info_ex if idaapi.__version__ < 7.0 else idaapi.get_switch_info

        # define a closure that will get us all of the related code references so we can process them.
        def Freferences(fn):
            branches = [instruction.is_call, instruction.is_branch]
            for ea in iterate(fn):

                # if it isn't code, then we skip it.
                if not database.type.is_code(ea):
                    continue

                # if it's a branching or call-type instruction that has no xrefs, then log a warning for the user.
                elif not len(database.xref.down(ea)) and any(F(ea) for F in branches):
                    logging.warning(u"{:s}.down({:#x}) : Discovered the \"{:s}\" instruction at {:#x} that might've contained a reference but was unresolved.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn), utils.string.escape(database.instruction(ea), '"'), ea))
                    continue

                # now we need to check which code xrefs are actually going to be something we care
                # about by checking to see if there's an xref pointing outside our function.
                for xref in filter(database.within, database.xref.code_down(ea)):
                    if not contains(fn, xref):
                        yield ea, xref

                    # if it's a branching or call-type instruction, but referencing non-code, then we care about it.
                    elif not database.type.is_code(xref) and any(F(ea) for F in branches):
                        yield ea, xref

                    # if we're recursive and there's a code xref that's referencing our entrypoint,
                    # then we're going to want that too.
                    elif interface.range.start(fn) == xref:
                        yield ea, xref
                    continue

                # if we're at a switch branch, then we don't need to follow any
                # data references, and we can just skip the rest of our logic.
                if get_switch_info(ea):
                    continue

                # last thing we need to determine is which data xrefs are relevant
                # which only includes things that reference code outside of us.
                for xref in filter(database.within, database.xref.data_down(ea)):
                    if database.type.is_code(xref) and not contains(fn, xref):
                        yield ea, xref

                    # if it's referencing an external, then yeah...this is definitely an xref we want.
                    elif idaapi.segtype(xref) in {idaapi.SEG_XTRN}:
                        # FIXME: technically an external could also be a non-callable address, but we
                        #        don't care because the user is gonna wanna know about it anyways.
                        yield ea, xref

                    # otherwise if it's a branch, but not referencing any code
                    # then this is probably a global containing a code pointer.
                    elif not database.type.is_code(xref) and any(F(ea) for F in branches):
                        yield ea, xref
                    continue
                continue
            return

        # grab our function and then grab all of the references from it.
        fn = by(func)
        iterable = Freferences(fn)

        # now we need to figure out if we're just going to return the referenced addresses.
        if not builtins.next((references[k] for k in ['reference', 'references', 'refs'] if k in references), False):
            return sorted({d for _, d in iterable})

        # otherwise we're being asked to return the source with its target reference for each one.
        results = {ea : d for ea, d in iterable}
        return [(ea, results[ea]) for ea in sorted(results)]

    @utils.multicase()
    @classmethod
    def up(cls):
        '''Return all of the addresses that reference the current function.'''
        return up(ui.current.address())
    @utils.multicase()
    @classmethod
    def up(cls, func):
        '''Return all of the addresses that reference the function `func`.'''
        rt, ea = interface.addressOfRuntimeOrStatic(func)
        # runtime
        if rt:
            return database.xref.up(ea)
        # regular
        return database.xref.up(ea)

    @utils.multicase(index=six.integer_types)
    @classmethod
    def argument(cls, index):
        '''Return the address of the parameter being passed to the function reference at the current address for the specified `index`.'''
        items = cls.arguments(ui.current.address())
        return items[index]
    @utils.multicase(index=six.integer_types, ea=six.integer_types)
    @classmethod
    def argument(cls, index, ea):
        '''Return the address of the parameter being passed to the function reference at the address `ea` for the specified `index`.'''
        items = cls.arguments(ea)
        return items[index]
    @utils.multicase(index=six.integer_types, ea=six.integer_types)
    @classmethod
    def argument(cls, func, index, ea):
        '''Return the address of the parameter from the specified `index` of the function `func` that is being passed to the function reference at the address `ea`.'''
        items = cls.arguments(func, ea)
        return items[index]
    arg = utils.alias(argument, 'xref')

    @utils.multicase()
    @classmethod
    def arguments(cls):
        '''Return the address of each of the parameters being passed to the function reference at the current address.'''
        return cls.arguments(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def arguments(cls, ea):
        '''Return the address of each of the parameters being passed to the function reference at address `ea`.'''
        if not database.xref.code_down(ea):
            raise E.InvalidTypeOrValueError(u"{:s}.arguments({:#x}) : Unable to return any parameters as the provided address ({:#x}) {:s} code references.".format('.'.join([__name__, cls.__name__]), ea, ea, 'does not have any' if instruction.type.is_call(ea) else 'is not a call instruction with'))
        items = idaapi.get_arg_addrs(ea)
        return [] if items is None else [ea for ea in items]
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def arguments(cls, func, ea):
        '''Return the address of each of the parameters for the function `func` that are being passed to the function reference at address `ea`.'''
        refs = {ref for ref in cls.up(func)}
        if ea not in refs:
            logging.warning(u"{:s}.arguments({!r}, {:#x}) : Ignoring the provided function ({:#x}) as the specified reference ({:#x}) is not referring to it.".format('.'.join([__name__, cls.__name__]), func, ea, address(func), ea))
        return cls.arguments(ea)
    args = utils.alias(arguments, 'xref')

x = xref    # XXX: ns alias
up, down = utils.alias(xref.up, 'xref'), utils.alias(xref.down, 'xref')

```

`base/instruction.py`:

```py
"""
Instruction module

This module exposes a number of tools for interacting with an
instruction defined within the database. There are three types
of tools within this module and each can be distinguished by their
prefixes which can be used to decode the operands for an instruction.
At the present time, only the Intel, AArch32/AArch64 (ARM), and the
MIPS32/MIPS64 architectures are currently supported.

Although IDA internally uses the ``idaapi.insn_t`` and ``idaapi.op_t``
to represent an instruction and its operands, this module's base
argument type is typically an address or an operand index. When
dealing with an instruction's operands, the ``ops_`` prefix represents
all of the instructions operands and typically will take only an
address.  Likewise when dealing with a single operand, the ``op_``
prefix is used and will take an address and the operand index.

To request the actual IDA types (``idaapi.insn_t`` and ``idaapi.op_t``)
there are two tools that are provided. The ``instruction.at`` tool will
take an address and return an ``idaapi.insn_t``. To get an operand type
(``idaapi.op_t``), a user can use ``instruction.operand``.  This will
take an address and an operand index and return the desired type.

Some globals are also defined for the given architecture which
can be used to query or access the registers that are currently
available. Once IDA has determined the architecture for the database
the ``register_t`` class is instantiated for each available register.
This object allows one to reference any register that is defined for
the architecture.

Another object that is created is the ``architecture_t`` object.
Searching for a register can be done by index and size or simply by
its name. This object also allows one to promote or demote a register
between its various sizes. This allows one to navigate between the
8-bit, 16-bit, 32-bit, or 64-bit versions of a register available in
the architecture.
"""

import six, builtins

import functools, operator, itertools, types
import logging, collections, math

import database, function
import structure, enumeration
import ui, internal
from internal import utils, interface, exceptions as E

import idaapi

## operand types
class __optype__(object):
    """
    This namespace is a registration table for all the different operand
    type decoders available for the known architectures. This is used
    for looking up an operand according to the operand and processor
    types.
    """
    cache = {}
    @classmethod
    def define(cls, processor, type, ptype=None):
        '''Register the operand decoder for the specfied `processor` and `type`'''
        def decorator(fn):
            res = processor, type
            cls.cache.setdefault(res, (fn, ptype))
            return fn
        return decorator

    @classmethod
    def lookup(cls, type, processor=None):
        '''Lookup the operand decoder and type for a specific `type` and `processor`.'''
        try: Fdecoder, ptype = cls.cache[processor or idaapi.ph.id, type]
        except KeyError: Fdecoder, ptype = cls.cache[0, type]
        return Fdecoder, ptype

    @classmethod
    def decode(cls, insn, op, processor=None):
        '''Using the specified `processor`, decode the operand `op` for the specified instruction `insn`.'''
        F, _ = cls.lookup(op.type, processor=processor)
        return F(insn, op)

    @classmethod
    def type(cls, op, processor=None):
        '''Return the operand decoder type's name for the specified `processor` and `op`.'''
        F, _ = cls.lookup(op.type, processor=processor)
        return F.__name__

    @classmethod
    def ptype(cls, op, processor=None):
        '''Return the pythonic type for the specified `processor` and `op`.'''
        _, t = cls.lookup(op.type, processor=processor)
        return t

    @classmethod
    def size(cls, op, processor=None):
        '''Return the size of the operand identified by `op` for the specified `processor`.'''
        if idaapi.__version__ < 7.0:
            return idaapi.get_dtyp_size(op.dtyp)
        return idaapi.get_dtype_size(op.dtype)

## general functions
@utils.multicase()
def at():
    '''Returns the ``idaapi.insn_t`` instance at the current address.'''
    return at(ui.current.address())
@utils.multicase(ea=six.integer_types)
def at(ea):
    '''Returns the ``idaapi.insn_t`` instance at the address `ea`.'''
    ea = interface.address.inside(ea)
    if not database.type.is_code(ea):
        raise E.InvalidTypeOrValueError(u"{:s}.at({:#x}) : Unable to decode a non-instruction at the specified address ({:#x}).".format(__name__, ea, ea))

    # If we're using backwards-compatiblity mode (which means decode_insn takes
    # different parameters, then manage the result using idaapi.cmd
    if hasattr(idaapi, 'cmd'):
        length = idaapi.decode_insn(ea)
        if idaapi.__version__ < 7.0:
            return idaapi.cmd.copy()

        tmp = idaapi.insn_t()
        tmp.assign(idaapi.cmd)
        return tmp

    # Otherwise we can just use the API as we see fit
    res = idaapi.insn_t()
    length = idaapi.decode_insn(res, ea)
    return res

@utils.multicase()
def size():
    '''Returns the length of the instruction at the current address.'''
    return size(ui.current.address())
@utils.multicase(ea=six.integer_types)
def size(ea):
    '''Returns the length of the instruction at the address `ea`.'''
    return at(ea).size

@utils.multicase(opnum=six.integer_types)
def opinfo(opnum):
    '''Returns the ``idaapi.opinfo_t`` for the operand `opnum` belonging to the instruction at the current address.'''
    return opinfo(ui.current.address(), opnum)
@utils.multicase(opnum=six.integer_types, info=idaapi.opinfo_t)
def opinfo(opnum, info, **flags):
    '''Set the opinfo for the operand `opnum` at the current address to the ``idaapi.opinfo_t`` provided by `info`.'''
    return opinfo(ui.current.address(), opnum, info, **flags)
@utils.multicase(reference=interface.opref_t)
def opinfo(reference):
    '''Returns the ``idaapi.opinfo_t`` for the operand pointed to by the provided `reference`.'''
    address, opnum, _ = reference
    return opinfo(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def opinfo(ea, opnum):
    '''Returns the ``idaapi.opinfo_t`` for the operand `opnum` belonging to the instruction at the address `ea`.'''
    ti, flags = idaapi.opinfo_t(), database.type.flags(ea)
    return idaapi.get_opinfo(ea, opnum, flags, ti) if idaapi.__version__ < 7.0 else idaapi.get_opinfo(ti, ea, opnum, flags)
@utils.multicase(reference=interface.opref_t, info=idaapi.opinfo_t)
def opinfo(reference, info, **flags):
    '''Set the operand info for the operand specified by `reference` to the ``idaapi.opinfo_t`` provided by `info`.'''
    address, opnum, _ = reference
    return opinfo(address, opnum, info, **flags)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, info=idaapi.opinfo_t)
def opinfo(ea, opnum, info, **flags):
    """Set the operand info for the operand `opnum` at the address `ea` to the ``idaapi.opinfo_t`` provided by `info`.

    If any `flags` have been specified, then also set the operand's flags to the provided value.
    """
    ok = idaapi.set_opinfo(ea, opnum, flags.get('flags', database.type.flags(ea)), info)
    if not ok:
        raise E.DisassemblerError(u"{:s}.opinfo({:#x}, {:d}, {!s}) : Unable to set the operand info for operand {:d}.".format(__name__, ea, opnum, info, opnum))
    return opinfo(ea, opnum)

@utils.multicase()
def mnemonic():
    '''Returns the mnemonic of the instruction at the current address.'''
    return mnemonic(ui.current.address())
@utils.multicase(ea=six.integer_types)
def mnemonic(ea):
    '''Returns the mnemonic of the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    if not database.type.is_code(ea):
        raise E.InvalidTypeOrValueError(u"{:s}.mnemonic({:#x}) : Unable to get the mnemonic for a non-instruction at the specified address ({:#x}).".format(__name__, ea, ea))

    res = (idaapi.ua_mnem(ea) or '').lower()
    return utils.string.of(res)
mnem = utils.alias(mnemonic)

## functions that return an ``idaapi.op_t`` for an operand
@utils.multicase()
def operands():
    '''Returns all of the ``idaapi.op_t`` instances for the instruction at the current address.'''
    return operands(ui.current.address())
@utils.multicase(ea=six.integer_types)
def operands(ea):
    '''Returns all of the ``idaapi.op_t`` instances for the instruction at the address `ea`.'''
    insn = at(ea)

    # if we're in compatibility mode, then old-fashioned IDA requires us to copy
    # our operands into our new types.
    if hasattr(idaapi, 'cmd'):

        # take operands until we encounter an idaapi.o_void
        iterable = itertools.takewhile(utils.fcompose(operator.attrgetter('type'), functools.partial(operator.ne, idaapi.o_void)), insn.Operands)

        # if we're using IDA < 7.0, then make copies of each instruction and return it
        if idaapi.__version__ < 7.0:
            return tuple(op.copy() for op in iterable)

        # otherwise, we need to make an instance of it and then assign to make a copy
        iterable = ((idaapi.op_t(), op) for op in iterable)
        return tuple([n.assign(op), n][1] for n, op in iterable)

    # apparently idaapi is not increasing a reference count for our operands, so we
    # need to make a copy of them quickly before we access them.
    operands = [idaapi.op_t() for index in range(idaapi.UA_MAXOP)]
    [ op.assign(insn.ops[index]) for index, op in enumerate(operands)]

    # now we can just fetch them until idaapi.o_void
    iterable = itertools.takewhile(utils.fcompose(operator.attrgetter('type'), functools.partial(operator.ne, idaapi.o_void)), operands)

    # and return it as a tuple
    return tuple(iterable)

@utils.multicase(opnum=six.integer_types)
def operand(opnum):
    '''Returns the ``idaapi.op_t`` for the operand `opnum` belonging to the instruction at the current address.'''
    return operand(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def operand(reference):
    '''Returns the ``idaapi.op_t`` for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return operand(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def operand(ea, opnum):
    '''Returns the ``idaapi.op_t`` for the operand `opnum` belonging to the instruction at the address `ea`.'''
    insn = at(ea)
    if opnum >= len(operands(ea)):
        raise E.InvalidTypeOrValueError(u"{:s}.operand({:#x}, {:d}) : The specified operand number ({:d}) is larger than the number of operands ({:d}) for the instruction at address {:#x}.".format(__name__, ea, opnum, opnum, len(operands(ea)), ea))

    # If we're using backwards-compatiblity mode then we need to assign the
    # operand into our op_t.
    if hasattr(idaapi, 'cmd'):
        # IDA < 7.0 means we can just call .copy() to duplicate it
        if idaapi.__version__ < 7.0:
            return insn.Operands[opnum].copy()

        # Otherwise we'll need to instantiate it, and then .assign() into it
        res = idaapi.op_t()
        res.assign(insn.Operands[opnum])
        return res

    # Otherwise we need to make a copy of it because IDA will crash if we don't
    res = idaapi.op_t()
    res.assign(insn.ops[opnum])
    return res

## functions vs all operands of an insn
@utils.multicase()
def ops_count():
    '''Returns the number of operands of the instruction at the current address.'''
    return ops_count(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_count(ea):
    '''Returns the number of operands of the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    return len(operands(ea))

@utils.multicase()
def ops_repr():
    '''Returns a tuple of the ``op_repr`` of all the operands for the instruction at the current address.'''
    return ops_repr(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_repr(ea):
    '''Returns a tuple of the ``op_repr`` of all the operands for the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    f = functools.partial(op_repr, ea)
    return tuple(map(f, range(ops_count(ea))))

@utils.multicase()
def ops():
    '''Returns a tuple of all the operands for the instruction at the current address.'''
    return ops(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops(ea):
    '''Returns a tuple of all the operands for the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    f = functools.partial(op, ea)
    return tuple(map(f, range(ops_count(ea))))
ops_value = utils.alias(ops)

@utils.multicase()
def ops_size():
    '''Returns a tuple with all the sizes of each operand for the instruction at the current address.'''
    return ops_size(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_size(ea):
    '''Returns a tuple with all the sizes of each operand for the instruction at the address `ea`.'''
    get_dtype_attribute = operator.attrgetter('dtyp' if idaapi.__version__ < 7.0 else 'dtype')
    get_dtype_size = idaapi.get_dtyp_size if idaapi.__version__ < 7.0 else idaapi.get_dtype_size

    ea = interface.address.inside(ea)
    f = utils.fcompose(functools.partial(operand, ea), get_dtype_attribute, get_dtype_size, int)
    return tuple(map(f, range(ops_count(ea))))

@utils.multicase()
def opts():
    '''Returns a tuple of the pythonic types for all the operands in the instruction at the current address.'''
    return ops_type(ui.current.address())
@utils.multicase(ea=six.integer_types)
def opts(ea):
    '''Returns a tuple of the pythonic types for all the operands in the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    f = functools.partial(opt, ea)
    return tuple(map(f, range(ops_count(ea))))
ops_type = utils.alias(opts)

@utils.multicase()
def ops_decoder():
    '''Return a tuple of the names of the decoders that will be used for all the operands in the instruction at the current address.'''
    return ops_decoder(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_decoder(ea):
    '''Return a tuple of the names of the decoders that will be used for all the operands in the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    f = functools.partial(op_decoder, ea)
    return tuple(map(f, range(ops_count(ea))))

@utils.multicase()
def ops_state():
    '''Returns a tuple for all the operands containing one of the states "r", "w", or "rw"` describing how the operands for the current instruction operands are modified.'''
    return ops_state(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_state(ea):
    '''Returns a tuple of for all the operands containing one of the states "r", "w", or "rw" describing how the operands are modified for the instruction at address `ea`.'''
    ea = interface.address.inside(ea)
    f = type.feature(ea)
    res = ( ((f & ops_state.read[i]), (f & ops_state.write[i])) for i in range(ops_count(ea)) )
    return tuple(interface.reftype_t.of_action((r and 'r' or '') + (w and 'w' or '')) for r, w in res)

# pre-cache the CF_ flags from idaapi inside ops_state
ops_state.read, ops_state.write = zip(*((getattr(idaapi, "CF_USE{:d}".format(1 + idx), 1 << (7 + idx)), getattr(idaapi, "CF_CHG{:d}".format(1 + idx), 1 << (1 + idx))) for idx in range(idaapi.UA_MAXOP)))

@utils.multicase()
def opsi_read():
    '''Returns the indices of any operands that are being read from by the instruction at the current address.'''
    return opsi_read(ui.current.address())
@utils.multicase(ea=six.integer_types)
def opsi_read(ea):
    '''Returns the indices of any operands that are being read from by the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    return tuple(opnum for opnum, state in enumerate(ops_state(ea)) if 'r' in state)
@utils.multicase()
def ops_read():
    '''Return the operands that are being read from by the instruction at the current address.'''
    return ops_read(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_read(ea):
    '''Return the operands that are being read from by the instruction at the current address.'''
    return tuple(op(ea, index) for index in opsi_read(ea))

@utils.multicase()
def opsi_write():
    '''Returns the indices of the operands that are being written to by the instruction at the current address.'''
    return opsi_write(ui.current.address())
@utils.multicase(ea=six.integer_types)
def opsi_write(ea):
    '''Returns the indices of the operands that are being written to by the instruction at the address `ea`.'''
    ea = interface.address.inside(ea)
    return tuple(opnum for opnum, state in enumerate(ops_state(ea)) if 'w' in state)
@utils.multicase()
def ops_write():
    '''Return the operands that are being written to by the instruction at the current address.'''
    return ops_write(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_write(ea):
    '''Return the operands that are being written to by the instruction at the current address.'''
    return tuple(op(ea, index) for index in opsi_write(ea))

@utils.multicase()
def opsi_constant():
    '''Return the indices of any operands in the current instruction that are constants.'''
    return opsi_constant(ui.current.address())
@utils.multicase(ea=six.integer_types)
def opsi_constant(ea):
    '''Return the indices of any operands in the instruction at `ea` that are constants.'''
    ea = interface.address.inside(ea)
    return tuple(opnum for opnum, value in enumerate(ops_value(ea)) if isinstance(value, six.integer_types))
opsi_const = utils.alias(opsi_constant)
@utils.multicase()
def ops_constant():
    '''Return the operands that are being written to by the instruction at the current address.'''
    return ops_constant(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_constant(ea):
    '''Return the operands that are being written to by the instruction at the current address.'''
    return tuple(op(ea, index) for index in opsi_constant(ea))
ops_const = utils.alias(ops_constant)

@utils.multicase()
def opsi_register(**modifiers):
    '''Returns the index of each operand in the instruction at the current address which uses a register.'''
    return opsi_register(ui.current.address(), **modifiers)
@utils.multicase(ea=six.integer_types)
def opsi_register(ea, **modifiers):
    '''Returns the index of each operand in the instruction at the address `ea` which uses a register.'''
    ea = interface.address.inside(ea)
    iterops = interface.regmatch.modifier(**modifiers)
    fregisterQ = utils.fcompose(op, utils.fcondition(utils.finstance(interface.symbol_t))(utils.fcompose(utils.fattribute('symbols'), functools.partial(map, utils.finstance(interface.register_t)), any), utils.fconstant(False)))
    return tuple(filter(functools.partial(fregisterQ, ea), iterops(ea)))
@utils.multicase(reg=(six.string_types, interface.register_t))
def opsi_register(reg, *regs, **modifiers):
    '''Returns the index of each operand in the instruction at the current address that uses `reg` or any one of the registers in `regs`.'''
    return opsi_register(ui.current.address(), reg, *regs, **modifiers)
@utils.multicase(ea=six.integer_types, reg=(six.string_types, interface.register_t))
def opsi_register(ea, reg, *regs, **modifiers):
    """Returns the index of each operand in the instruction at address `ea` that uses `reg` or any one of the registers in `regs`.

    If the keyword `write` is true, then only return the result if it's writing to the register.
    """
    ea = interface.address.inside(ea)
    iterops = interface.regmatch.modifier(**modifiers)
    uses = interface.regmatch.use( (reg,) + regs )
    return tuple(filter(functools.partial(uses, ea), iterops(ea)))
opsi_regi = opsi_reg = opsi_regs = opsi_registers = utils.alias(opsi_register)

@utils.multicase()
def ops_register(**modifiers):
    '''Returns each register operand in the instruction at the current address.'''
    return ops_register(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_register(ea, **modifiers):
    '''Returns each register operand in the instruction at the current address.'''
    return tuple(op(ea, index) for index in opsi_register(ea, **modifiers))
@utils.multicase(reg=(six.string_types, interface.register_t))
def ops_register(reg, *regs, **modifiers):
    '''Returns each register operand in the instruction at the current address that is `reg` or any one of the registers in `regs`.'''
    return ops_register(ui.current.address(), reg, *regs, **modifiers)
@utils.multicase(ea=six.integer_types, reg=(six.string_types, interface.register_t))
def ops_register(ea, reg, *regs, **modifiers):
    """Returns each register operand in the instruction at the address `ea` that is `reg` or any one of the registers in `regs`.'''

    If the keyword `write` is true, then only return the result if it's writing to the register.
    """
    return tuple(op(ea, index) for index in opsi_register(ea, reg, *regs, **modifiers))
ops_reg = ops_regs = ops_registers = utils.alias(ops_register)

## functions vs a specific operand of an insn
@utils.multicase(opnum=six.integer_types)
def op_repr(opnum):
    '''Returns the representation for the operand `opnum` belonging to the instruction at the current address.'''
    return op_repr(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_repr(reference):
    '''Returns the representation for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_repr(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_repr(ea, opnum):
    '''Returns the representation for the operand `opnum` belonging to the instruction at the address `ea`.'''
    insn = at(ea)
    oppr = idaapi.ua_outop2 if idaapi.__version__ < 7.0 else idaapi.print_operand
    outop = utils.fcompose(idaapi.ua_outop2, idaapi.tag_remove) if idaapi.__version__ < 7.0 else utils.fcompose(idaapi.print_operand, idaapi.tag_remove)
    try:
        res = outop(insn.ea, opnum) or "{:s}".format(op(insn.ea, opnum))
    except:
        logging.warning(u"{:s}({:#x}, {:d}) : Unable to strip tags from operand \"{:s}\". Returning the result from {:s} instead.".format('.'.join([__name__, 'op_repr']), ea, opnum, utils.string.escape(oppr(insn.ea, opnum), '"'), '.'.join([__name__, 'op'])))
        return u"{!s}".format(op(insn.ea, opnum))
    return utils.string.of(res)

@utils.multicase(opnum=six.integer_types)
def op_state(opnum):
    '''Returns the modification state for the operand `opnum` belonging to the current instruction.'''
    return op_state(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_state(reference):
    '''Returns the modification state for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_state(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_state(ea, opnum):
    """Returns the modification state for the operand `opnum` belonging to the instruction at the address `ea`.

    The returned state is a string that can be "r", "w", or "rw" depending on
    whether the operand is being read from, written to, or modified (both).
    """
    f = type.feature(ea)

    # Verify that we're using a valid operand number.
    if opnum >= len(operands(ea)):
        raise E.InvalidTypeOrValueError(u"{:s}.op_state({:#x}, {:d}) : The specified operand number ({:d}) is larger than the number of operands ({:d}) for the instruction at address {:#x}.".format(__name__, ea, opnum, opnum, len(operands(ea)), ea))

    # Now we can check our instruction feature for what the operand state is.
    r, w = f & ops_state.read[opnum], f & ops_state.write[opnum]
    res = (r and 'r' or '') + (w and 'w' or '')

    # Make a reftype_t from the state we determined. If we couldn't figure it out,
    # then fallback to "r" as the operand still exists and it must be doing something.
    return interface.reftype_t.of_action(res or 'r')

# we needed an adjective, but "read" is a verb and a noun. this should be thought of in its noun form.
@utils.multicase(opnum=six.integer_types)
def op_read(opnum):
    '''Return whether the operand `opnum` belonging to the current instruction is only being read from.'''
    return op_read(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_read(reference):
    '''Return whether the operand pointed to by `reference` is only being read from.'''
    address, opnum, _ = reference
    return op_read(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_read(ea, opnum):
    '''Return whether the operand `opnum` belonging to the instruction at the address `ea` is only being read from.'''
    return 'r' in op_state(ea, opnum)
op_used = utils.alias(op_read)          # XXX: read/modified or used/modified?

@utils.multicase(opnum=six.integer_types)
def op_modified(opnum):
    '''Return whether the operand `opnum` belonging to the current instruction is being modified (written to).'''
    return op_modified(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_modified(reference):
    '''Return whether the operand pointed to by `reference` is being modified (written to).'''
    address, opnum, _ = reference
    return op_modified(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_modified(ea, opnum):
    '''Return whether the operand `opnum` belonging to the instruction at the address `ea` is being modified (written to).'''
    return 'w' in op_state(ea, opnum)
op_written = op_write = utils.alias(op_modified)        # XXX: these aliases are needed because our opposite is `op_read`

@utils.multicase(opnum=six.integer_types)
def op_size(opnum):
    '''Returns the size for the operand `opnum` belonging to the current instruction.'''
    return op_size(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_size(reference):
    '''Returns the size for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_size(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_size(ea, opnum):
    '''Returns the size for the operand `opnum` belonging to the instruction at the address `ea`.'''
    get_dtype_attribute = operator.attrgetter('dtyp' if idaapi.__version__ < 7.0 else 'dtype')
    get_dtype_size = idaapi.get_dtyp_size if idaapi.__version__ < 7.0 else idaapi.get_dtype_size

    res = operand(ea, opnum)
    return 0 if res.type == idaapi.o_void else get_dtype_size(get_dtype_attribute(res))
@utils.multicase(opnum=six.integer_types)
def op_bits(opnum):
    '''Returns the size (in bits) for the operand `opnum` belonging to the current instruction.'''
    return 8 * op_size(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_bits(reference):
    '''Returns the size (in bits) for the operand pointed to by `reference`.'''
    return 8 * op_size(reference)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_bits(ea, opnum):
    '''Returns the size (in bits) for the operand `opnum` belonging to the instruction at the address `ea`.'''
    return 8 * op_size(ea, opnum)

@utils.multicase(opnum=six.integer_types)
def op_decoder(opnum):
    '''Returns the name of the decoder that will be used when decoding the operand `opnum` belonging to the current instruction.'''
    return op_decoder(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_decoder(reference):
    '''Returns the name of the decoder that will be used when decoding the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_decoder(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_decoder(ea, opnum):
    """Returns the name of the decoder that will be used when decoding the operand `opnum` belonging to the instruction at the address `ea`.

    The string that is returned is dependent on the processor module used by the database.
    """
    res = operand(ea, opnum)
    return __optype__.type(res)

@utils.multicase(opnum=six.integer_types)
def op_type(opnum):
    '''Returns the pythonic type of the operand `opnum` belonging to the current instruction.'''
    return op_type(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_type(reference):
    '''Returns the pythonic type of the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_type(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_type(ea, opnum):
    '''Returns the pythonic type of the operand `opnum` belonging to the instruction at the address `ea`.'''
    op, opsize = operand(ea, opnum), op_size(ea, opnum)

    # if our operand is not a register, then we can use the operand type.
    if op.type not in {idaapi.o_reg}:
        return __optype__.ptype(op), opsize

    # now we have the register and we only decode the instruction with its
    # operand and then we can verify that its operand size matches.
    insn = at(ea)
    regtype, size = __optype__.decode(insn, op).type
    if size != opsize:
        logging.info(u"{:s}.op_type({:#x}, {:d}) : Returning the operand size ({:d}) as it is different from the register size ({:d}).".format(__name__, ea, opnum, opsize, size))
    return regtype, opsize

opt = utils.alias(op_type)

@utils.multicase(opnum=six.integer_types)
def op(opnum):
    '''Decodes the operand `opnum` for the current instruction.'''
    return op(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op(reference):
    '''Decodes the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op(ea, opnum):
    '''Decodes the operand `opnum` for the instruction at the address `ea`.'''
    insn, res = at(ea), operand(ea, opnum)
    return __optype__.decode(insn, res)
op_value = op_decode = utils.alias(op)

## older typeinfo stuff
# idaapi.set_typeinfo(ea, opnum, flags, ti)
# idaapi.get_typeinfo(ea, opnum, &flags, &buf)
# idaapi.typeflag(ea, &oldflag, type, opnum)

## XXX: maybe figure out if there's some way to do this generically
# idaapi.set_op_type(ea, type, opnum)

## XXX: figure out a useful name to implement the following to apply a data offset to an operand
# def? op_offset(ea, opnum, type, target = BADADDR, base = 0, tdelta = 0) -> int

## old method for applying a complex type to an operand
# def op_type(ea, opnum)
#    '''Apply the specified type to a stack variable'''
#    py_op = operand(ea, opnum)
#    py_v = py_op.addr
#    py_t = idc.parse_decl("type string", flags)[1]
#    py_name = "stack variable name"
#    idaapi.apply_type_to_stkarg(py_op, py_v, py_t, py_name)

## XXX: deprecate this, and somehow associate the segment register with the operand for the intel arch
@utils.multicase(opnum=six.integer_types)
def op_segment(opnum):
    '''Returns the segment register used by the operand `opnum` for the instruction at the current address.'''
    return op_segment(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_segment(reference):
    '''Returns the segment register used by the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_segment(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_segment(ea, opnum):
    '''Returns the segment register used by the operand `opnum` for the instruction at the address `ea`.'''
    op = operand(ea, opnum)
    segrg  = (op.specval & 0xffff0000) >> 16
    segsel = (op.specval & 0x0000ffff) >> 0
    if segrg:
        global architecture
        return architecture.by_index(segrg)
    #raise NotImplementedError("{:s}.op_segment({:#x}, {:d}) : Unable to determine the segment register for the specified operand number. {!r} was returned.".format(__name__, ea, opnum, segrg))
    return None
# FIXME: maybe use idaapi.op_seg(*args) to apply a segment to an operand?

@utils.multicase(opnum=six.integer_types)
def op_number(opnum):
    '''Set the type for operand `opnum` at the current instruction to a number and return it.'''
    return op_number(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_number(reference):
    '''Set the type for the operand pointed to by `reference` to a number and return it.'''
    address, opnum, _ = reference
    return op_number(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_number(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to a number and return it.'''
    t = idaapi.num_flag()
    ok, signed = idaapi.set_op_type(ea, t, opnum), idaapi.is_invsign(ea, database.type.flags(ea), opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_number({:#x}, {:d}) : Unable to restore the type of operand {:d} to a number.".format(__name__, ea, opnum, opnum))

    # Extract the operand's op_t and its maximum value, as we'll use this to
    # transform the value if necessary.
    res, max = operand(ea, opnum), pow(2, op_bits(ea, opnum))

    # If this is an immediate value, then we can treat it normally.
    if res.type in {idaapi.o_imm}:
        integer = res.value & (max - 1)
        return 0 if integer == 0 else (integer - max) if signed else integer

    # If the signed-flag is set in our operand, then convert it into its actual
    # signed value.
    bits = utils.string.digits(idaapi.BADADDR, 2)
    maximum, flag = pow(2, bits), pow(2, bits - 1)
    integer = (res.addr - maximum) if res.addr & flag else res.addr

    # Now we can return the value transformed if the operand has an inverted sign
    return 0 if integer == 0 else (maximum + integer) if signed and integer < 0 else (integer - maximum) if signed else integer
op_num = utils.alias(op_number)

@utils.multicase(opnum=six.integer_types)
def op_character(opnum):
    '''Set the type for operand `opnum` at the current instruction to a character and return it.'''
    return op_character(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_character(reference):
    '''Set the type for the operand pointed to by `reference` to a character and return it.'''
    address, opnum, _ = reference
    return op_character(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_character(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to a character and return it.'''
    t = idaapi.char_flag()
    ok, signed = idaapi.set_op_type(ea, t, opnum), idaapi.is_invsign(ea, database.type.flags(ea), opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_character({:#x}, {:d}) : Unable to set the type of operand {:d} to a character.".format(__name__, ea, opnum, opnum))

    # Extract the operand's op_t and its maximum value, as we'll use this to
    # transform the value if necessary.
    res, max = operand(ea, opnum), pow(2, op_bits(ea, opnum))

    # If this is an immediate value, then we can treat it normally.
    if res.type in {idaapi.o_imm}:
        integer = res.value & (max - 1)
        result = 0 if integer == 0 else (integer - max) if signed else integer

    # If the signed-flag is set in our operand, then convert it into its actual
    # signed value.
    else:
        bits = utils.string.digits(idaapi.BADADDR, 2)
        maximum, flag = pow(2, bits), pow(2, bits - 1)
        integer = (res.addr - maximum) if res.addr & flag else res.addr

        # Now we can use the value transformed if the operand has an inverted sign
        result = 0 if integer == 0 else (maximum + integer) if signed and integer < 0 else (integer - maximum) if signed else integer

    # There's no such thing as a signed character, so if we do get a signed
    # value back from our above logic, then we need to figure out its absolute
    # value so we can return it properly.
    absolute = abs(result)

    # IDA actually returns integers larger than a byte as a string, so we'll
    # first chunk our integer into octets.
    octets = []
    while absolute > 0:
        octets.append(absolute & 0xff)
        absolute //= 0x100

    # Last thing to do is to join each octet together back into some bytes
    return bytes(bytearray(reversed(bytearray(octets))))
op_chr = op_char = utils.alias(op_character)

@utils.multicase(opnum=six.integer_types)
def op_binary(opnum):
    '''Set the type for operand `opnum` at the current instruction to binary and return it.'''
    return op_binary(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_binary(reference):
    '''Set the type for the operand pointed to by `reference` to binary and return it.'''
    address, opnum, _ = reference
    return op_binary(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_binary(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to binary and return it.'''
    t = idaapi.bin_flag()
    ok, signed = idaapi.set_op_type(ea, t, opnum), idaapi.is_invsign(ea, database.type.flags(ea), opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_binary({:#x}, {:d}) : Unable to set the type of operand {:d} to binary.".format(__name__, ea, opnum, opnum))

    # Extract the operand's op_t and its maximum value, as we'll use this to
    # transform the value if necessary.
    res, max = operand(ea, opnum), pow(2, op_bits(ea, opnum))

    # If this is an immediate value, then we can treat it normally.
    if res.type in {idaapi.o_imm}:
        integer = res.value & (max - 1)
        return 0 if integer == 0 else (integer - max) if signed else integer

    # If the signed-flag is set in our operand, then convert it into its actual
    # signed value.
    bits = utils.string.digits(idaapi.BADADDR, 2)
    maximum, flag = pow(2, bits), pow(2, bits - 1)
    integer = (res.addr - maximum) if res.addr & flag else res.addr

    # Now we can return the value transformed if the operand has an inverted sign
    return 0 if integer == 0 else (maximum + integer) if signed and integer < 0 else (integer - maximum) if signed else integer
op_bin = utils.alias(op_binary)

@utils.multicase(opnum=six.integer_types)
def op_octal(opnum):
    '''Set the type for operand `opnum` at the current instruction to octal and return it.'''
    return op_octal(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_octal(reference):
    '''Set the type for the operand pointed to by `reference` to octal and return it.'''
    address, opnum, _ = reference
    return op_octal(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_octal(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to octal and return it.'''
    t = idaapi.oct_flag()
    ok, signed = idaapi.set_op_type(ea, t, opnum), idaapi.is_invsign(ea, database.type.flags(ea), opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_octal({:#x}, {:d}) : Unable to set the type of operand {:d} to octal.".format(__name__, ea, opnum, opnum))

    # Extract the operand's op_t and its maximum value, as we'll use this to
    # transform the value if necessary.
    res, max = operand(ea, opnum), pow(2, op_bits(ea, opnum))

    # If this is an immediate value, then we can treat it normally.
    if res.type in {idaapi.o_imm}:
        integer = res.value & (max - 1)
        return 0 if integer == 0 else (integer - max) if signed else integer

    # If the signed-flag is set in our operand, then convert it into its actual
    # signed value.
    bits = utils.string.digits(idaapi.BADADDR, 2)
    maximum, flag = pow(2, bits), pow(2, bits - 1)
    integer = (res.addr - maximum) if res.addr & flag else res.addr

    # Now we can return the value transformed if the operand has an inverted sign
    return 0 if integer == 0 else (maximum + integer) if signed and integer < 0 else (integer - maximum) if signed else integer
op_oct = utils.alias(op_octal)

@utils.multicase(opnum=six.integer_types)
def op_decimal(opnum):
    '''Set the type for operand `opnum` at the current instruction to decimal and return it.'''
    return op_decimal(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_decimal(reference):
    '''Set the type for the operand pointed to by `reference` to decimal and return it.'''
    address, opnum, _ = reference
    return op_decimal(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_decimal(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to decimal and return it.'''
    t = idaapi.dec_flag()
    ok, signed = idaapi.set_op_type(ea, t, opnum), idaapi.is_invsign(ea, database.type.flags(ea), opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_decimal({:#x}, {:d}) : Unable to set the type of operand {:d} to decimal.".format(__name__, ea, opnum, opnum))

    # Extract the operand's op_t and its maximum value, as we'll use this to
    # transform the value if necessary.
    res, max = operand(ea, opnum), pow(2, op_bits(ea, opnum))

    # If this is an immediate value, then we can treat it normally.
    if res.type in {idaapi.o_imm}:
        integer = res.value & (max - 1)
        return 0 if integer == 0 else (integer - max) if signed else integer

    # If the signed-flag is set in our operand, then convert it into its actual
    # signed value.
    bits = utils.string.digits(idaapi.BADADDR, 2)
    maximum, flag = pow(2, bits), pow(2, bits - 1)
    integer = (res.addr - maximum) if res.addr & flag else res.addr

    # Now we can return the value transformed if the operand has an inverted sign
    return 0 if integer == 0 else (maximum + integer) if signed and integer < 0 else (integer - maximum) if signed else integer
op_dec = utils.alias(op_decimal)

@utils.multicase(opnum=six.integer_types)
def op_hexadecimal(opnum):
    '''Set the type for operand `opnum` at the current instruction to hexadecimal and return it.'''
    return op_hexadecimal(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_hexadecimal(reference):
    '''Set the type for the operand pointed to by `reference` to hexadecimal and return it.'''
    address, opnum, _ = reference
    return op_hexadecimal(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_hexadecimal(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to hexadecimal and return it.'''
    t = idaapi.hex_flag()
    ok, signed = idaapi.set_op_type(ea, t, opnum), idaapi.is_invsign(ea, database.type.flags(ea), opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_hexadecimal({:#x}, {:d}) : Unable to set the type of operand {:d} to hexadecimal.".format(__name__, ea, opnum, opnum))

    # Extract the operand's op_t and its maximum value, as we'll use this to
    # transform the value if necessary.
    res, max = operand(ea, opnum), pow(2, op_bits(ea, opnum))

    # If this is an immediate value, then we can treat it normally.
    if res.type in {idaapi.o_imm}:
        integer = res.value & (max - 1)
        return 0 if integer == 0 else (integer - max) if signed else integer

    # If the signed-flag is set in our operand, then convert it into its actual
    # signed value.
    bits = utils.string.digits(idaapi.BADADDR, 2)
    maximum, flag = pow(2, bits), pow(2, bits - 1)
    integer = (res.addr - maximum) if res.addr & flag else res.addr

    # Now we can return the value transformed if the operand has an inverted sign
    return 0 if integer == 0 else (maximum + integer) if signed and integer < 0 else (integer - maximum) if signed else integer
op_hex = utils.alias(op_hexadecimal)

@utils.multicase(opnum=six.integer_types)
def op_float(opnum):
    '''Set the type for operand `opnum` at the current instruction to floating-point and return it.'''
    return op_float(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_float(reference):
    '''Set the type for the operand pointed to by `reference` to floating-point and return it.'''
    address, opnum, _ = reference
    return op_float(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_float(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to floating-point and return it.'''
    t = idaapi.flt_flag()

    # Explicitly set the operand type using idaapi.
    ok = idaapi.set_op_type(ea, t, opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_float({:#x}, {:d}) : Unable to set the type of operand {:d} to floating-point.".format(__name__, ea, opnum, opnum))

    # Read the number of bits for the operand so we can figure out how to properly
    # decode this integer.
    res, bits = operand(ea, opnum), op_bits(ea, opnum)
    integer = res.value if res.type in {idaapi.o_imm} else res.addr

    # Figure out which floating-point components to use for decoding
    if bits == 64:
        fraction, exponent, sign = 52, 11, 1

    elif bits == 32:
        fraction, exponent, sign = 23, 8, 1

    elif bits == 16:
        fraction, exponent, sign = 10, 5, 1

    # If we couldn't find a valid encoding, then raise an exception.
    else:
        raise E.UnsupportedCapability(u"{:s}.op_float({:#x}, {:d}) : Unable to decode operand {:d} for instruction due to an unsupported number of bits ({:d}).".format(__name__, ea, opnum, opnum, bits))

    # Now we can decode the floating-point operand and return it.
    try:
        res = utils.float_of_integer(integer, fraction, exponent, sign)

    # If an exception was raised, then re-raise it with our parameters prefixed.
    except ValueError as message:
        raise ValueError(u"{:s}.op_float({:#x}, {:d}) : {!s}".format(__name__, ea, opnum, message))

    # That's all, folks.
    return res
op_flt = utils.alias(op_float)

@utils.multicase(opnum=six.integer_types)
def op_stackvar(opnum):
    '''Set the type for operand `opnum` at the current instruction to a stack variable and return it.'''
    return op_stackvar(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_stackvar(reference):
    '''Set the type for the operand pointed to by `reference` to a stack variable and return it.'''
    address, opnum, _ = reference
    return op_stackvar(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_stackvar(ea, opnum):
    '''Set the type for operand `opnum` belonging to the instruction at `ea` to a stack variable and return it.'''
    if not function.within(ea):
        raise E.FunctionNotFoundError(u"{:s}.op_stackvar({:#x}, {:d}) : The specified address ({:#x}) is not within a function.".format(__name__, ea, opnum, ea))

    ok = idaapi.op_stkvar(ea, opnum)
    if not ok:
        raise E.DisassemblerError(u"{:s}.op_stackvar({:#x}, {:d}) : Unable to set operand {:d} to a stack variable.".format(__name__, ea, opnum, opnum))

    # Now that it's set, call into op_structure to return it.
    return op_structure(ea, opnum)
op_stack = op_stkvar = utils.alias(op_stackvar)

@utils.multicase(opnum=six.integer_types)
def op_structure(opnum):
    '''Return the structure and members for operand `opnum` at the current instruction.'''
    return op_structure(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_structure(reference):
    '''Return the structure and members for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_structure(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_structure(ea, opnum):
    '''Return the structure and members for the operand `opnum` at the instruction `ea`.'''
    F, insn, op, ri = database.type.flags(ea), at(ea), operand(ea, opnum), interface.address.refinfo(ea, opnum)

    # Start out by checking if the operand is a stack variable, because
    # we'll need to handle it differently if so.
    if idaapi.is_stkvar(F, opnum) and function.within(insn.ea):
        fn = function.by(insn.ea)

        # Now we can ask IDA what's up with it.
        res = idaapi.get_stkvar(insn, op, op.addr)
        if not res:
            raise E.DisassemblerError(u"{:s}.op_structure({:#x}, {:d}) : The call to `idaapi.get_stkvar({!r}, {!r}, {:+#x})` returned an invalid stack variable.".format(__name__, ea, opnum, insn, op, value))
        mptr, actval = res

        # First we grab our frame, and then find the starting member by its id.
        frame = function.frame(fn)
        member = frame.members.by_identifier(mptr.id)

        # Use the real offset of the member so that we can figure out which
        # members of the structure are actually part of the path.
        path, delta = member.parent.members.__walk_to_realoffset__(actval)

        # If we got a list as a result, then we encountered an array which
        # requires us to return a list and include the offset.
        if isinstance(path, builtins.list):
            return path + [delta]

        # Otherwise it's just a regular path, and we need to determine whether
        # to include the offset in the result or not.
        results = tuple(path)
        if delta > 0:
            return results + (delta,)
        return tuple(results) if len(results) > 1 else results[0]

    # Otherwise, we check if our operand is not a structure offset, but pointing
    # to memory by having a reference. If it is then we'll need to figure the field
    # being referenced by calculating the offset into structure ourselves.
    elif not idaapi.is_stroff(F, opnum) and ri:
        value = op_reference(ea, opnum)
        address = database.address.head(value)
        t, count = database.type.array(address)
        offset = value - address

        # Verify that the type as the given address is a structure
        if not isinstance(t, structure.structure_t):
            raise E.MissingTypeOrAttribute(u"{:s}.op_structure({:#x}, {:d}) : Operand {:d} is not pointing to a structure.".format(__name__, ea, opnum, opnum))

        # FIXME: check if the operand contains any member xrefs, because
        #        if it doesn't then we don't actually need a path.

        # Figure out the index and the real offset into the structure,
        # and then hand them off to the walk_to_realoffset method. From
        # this value, we calculate the array member offset and then
        # process it to get the actual path to return.
        index, byte = divmod(offset, t.size)
        path, realdelta = t.members.__walk_to_realoffset__(byte)
        delta = index * t.size + realdelta

        # If we received a list, then we can just return it with the delta.
        if isinstance(path, builtins.list) or count > 1:
            return [item for item in path] + [delta]

        # Figure out whether we need to include the offset in the result.
        results = tuple(path)
        if delta > 0:
            return results + (delta,)
        return tuple(results) if len(results) > 1 else results[0]

    # If it doesn't have a reference, then there's absolutely nothing we can do.
    elif not idaapi.is_stroff(F, opnum):
        raise E.MissingTypeOrAttribute(u"{:s}.op_structure({:#x}, {:d}) : Unable to identify the structure referenced by operand {:d} with flags ({:#x}).".format(__name__, ea, opnum, opnum, F))

    # First we'll get the operand value and then collect all of the IDs in
    # our path along with the delta that was applied. This way we can calculate
    # exactly which members were used for the path that we plan on returning.
    value = idaapi.as_signed(op.value if op.type in {idaapi.o_imm} else op.addr)

    # FIXME: inverted or negated operands are currently not being supported.

    delta, tids = interface.node.get_stroff_path(insn.ea, opnum)
    logging.debug(u"{:s}.op_structure({:#x}, {:d}) : Processing {:d} members ({:s}) from path that was returned from `{:s}`.".format(__name__, ea, opnum, len(tids), ', '.join("{:#x}".format(mid) for mid in tids), "{!s}({:#x}, {:d})".format('.'.join(getattr(interface.node.get_stroff_path, attribute) for attribute in ['__module__', '__name__']), insn.ea, opnum)))

    # If we're a single tid, and the sum of the offset and the delta is
    # the same as the size, then the operand is using sizeof and we can leave.
    if len(tids) == 1 and sum([value, delta]) == structure.__instance__(tids[0]).size:
        return structure.__instance__(tids[0])

    # Next we'll gather the data references for the operand and key them
    # by their sptr id. This is because I can't figure out any other way
    # to get _exactly_ what's being displayed.
    displayed = {}
    for mid in filter(interface.node.is_identifier, interface.xiterate(insn.ea, idaapi.get_first_dref_from, idaapi.get_next_dref_from)):

        # Simple enough. If it's not a member identifier, then skip it.
        item = idaapi.get_member_by_id(mid)
        if item is None:
            continue

        # Okay, we should now have the member and its owner. We'll only be
        # looking them up by the sptr identifier, so that's all we want.
        mptr, _, sptr = item
        if operator.contains(displayed, sptr.id):
            logging.debug(u"{:s}.op_structure({:#x}, {:d}) : Found more than one reference for a member ({:#x}) belonging to the same structure ({:#x}).".format(__name__, ea, opnum, mptr.id, sptr.id))
        displayed[sptr.id] = mptr

    # Now we can grab our path from the tids that we extracted from the
    # operand. For the sake of debugging, we'll just log the full path.
    path = interface.strpath.of_tids(value + delta, tids)
    logging.info(u"{:s}.op_structure({:#x}, {:d}) : Resolved the path ({:d} elements) for the instruction operand to {:s}.".format(__name__, ea, opnum, len(path), interface.strpath.fullname(path)))

    # Now we can create a calculator for the starting offset from the
    # operand, and proceed to convert the path into a list of results.
    calculator = interface.strpath.calculate(0)
    result, position, leftover = [], builtins.next(calculator), 0
    for sptr, mptr, offset in path:

        # Start out by finding the exact structure that was resolved,
        # and then use it to find the exact member being referenced.
        st = structure.__instance__(sptr.id, offset=position)
        if mptr:
            member = st.members.by_identifier(mptr.id)
            offset = member.realoffset

        # If there wasn't a member, then there's at least a member
        # that's being displayed. So, we can figure out which one is
        # being displayed by the operand (via dref) and use that one.
        elif operator.contains(displayed, sptr.id):
            mptr = displayed[sptr.id]
            member, offset = st.members.by_identifier(mptr.id), offset

        # If it's not referenced at all, then we're in a very weird
        # situation and it absolutely has got to be the structure size.
        else:
            member, offset = st, 0

        # Now that we figured out the right item that's being displayed,
        # update our position using its realoffset, keep track of our
        # carried value, and then add them member before continuing.
        position, leftover = calculator.send((sptr, None, member.realoffset)), sum([leftover, offset])
        result.append(member)

    # Now that we have the carried bytes (leftover) of the path, we can
    # just subtract it from the operand value to get the displayed one.
    realoffset = value - leftover

    # Now we need to do one last tricky thing to remain backwards compatible
    # with the previous implementation. That is that we need to figure out
    # whether there's an array being referenced in one of our elements.
    if any(isinstance(member.type, builtins.list) for member in result if isinstance(member, structure.member_t)):
        return result + [realoffset]

    # Otherwise we've just collected a regular member path. So we need to
    # determine whether to include the offset in the result or not.
    results = tuple(result)
    if realoffset:
        return results + (realoffset,)
    return results if len(results) > 1 else results[0]

## current address and opnum with variable-length path
@utils.multicase(opnum=six.integer_types, structure=(structure.structure_t, idaapi.struc_t, six.string_types))
def op_structure(opnum, structure, *path):
    '''Apply the specified `structure` along with any members in `path` to the instruction operand `opnum` at the current address.'''
    return op_structure(ui.current.address(), opnum, [item for item in itertools.chain([structure], path)])
@utils.multicase(opnum=six.integer_types, member=(structure.member_t, idaapi.member_t))
def op_structure(opnum, member, *path):
    '''Apply the specified `member` along with any members in `path` to the instruction operand `opnum` at the current address.'''
    return op_structure(ui.current.address(), opnum, [item for item in itertools.chain([member], path)])

## address and opnum with variable-length path
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, structure=(structure.structure_t, idaapi.struc_t, six.string_types))
def op_structure(ea, opnum, structure, *path):
    '''Apply the specified `structure` along with the members in `path` to the instruction operand `opnum` at the address `ea`.'''
    return op_structure(ea, opnum, [item for item in itertools.chain([structure], path)])
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, member=(structure.member_t, idaapi.member_t))
def op_structure(ea, opnum, member, *path):
    '''Apply the specified `member` to the instruction operand `opnum` at the address `ea`.'''
    return op_structure(ea, opnum, [item for item in itertools.chain([member], path)])

## operand reference with variable-length path
@utils.multicase(reference=interface.opref_t, structure=(structure.structure_t, idaapi.struc_t, six.string_types))
def op_structure(reference, structure, *path):
    '''Apply the specified `structure` along with the members in `path` to the operand pointed to by `reference`.'''
    return op_structure(reference, [item for item in itertools.chain([structure], path)])
@utils.multicase(reference=interface.opref_t, member=(structure.member_t, idaapi.member_t))
def op_structure(reference, member, *path):
    '''Apply the specified `member` along with the members in `path` to the instruction operand pointed to by `reference`.'''
    return op_structure(reference, [item for item in itertools.chain([member], path)])

## all variations that take a tuple/list to apply to a given operand.
@utils.multicase(reference=interface.opref_t, path=(builtins.tuple, builtins.list))
def op_structure(reference, path):
    '''Apply the structure members in `path` to the instruction operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_structure(address, opnum, path)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, path=(builtins.tuple, builtins.list))
def op_structure(ea, opnum, path):
    '''Apply the structure members in `path` to the instruction operand `opnum` at the address `ea`.'''
    items = [item for item in path]
    member = items.pop(0) if len(items) else ''
    if isinstance(member, six.string_types):
        sptr, fullpath = structure.by(member).ptr, items
    elif isinstance(member, idaapi.struc_t):
        sptr, fullpath = structure.by(member.id), items
    elif isinstance(member, structure.structure_t):
        sptr, fullpath = member.ptr, items
    elif isinstance(member, idaapi.member_t):
        _,_, sptr = idaapi.get_member_by_id(member.id)
        if not interface.node.is_identifier(sptr.id):
            sptr = idaapi.get_member_struc(idaapi.get_member_fullname(member.id))
        fullpath = itertools.chain([member], items)
    elif isinstance(member, structure.member_t):
        sptr, fullpath = member.parent.ptr, itertools.chain([member], items)
    else:
        raise E.InvalidParameterError(u"{:s}.op_structure({:#x}, {:d}, {!r}) : Unable to determine the structure from the provided path due to the first item being of an unsupported type ({!s}).".format(__name__, ea, opnum, path, member.__class__))
    return op_structure(ea, opnum, sptr, [item for item in fullpath])
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, sptr=idaapi.struc_t, path=(builtins.tuple, builtins.list))
def op_structure(ea, opnum, sptr, path):
    '''Apply the structure identified by `sptr` along with the members in `path` to the instruction operand `opnum` at the address `ea`.'''
    ea = interface.address.inside(ea)
    if not database.type.is_code(ea):
        raise E.InvalidTypeOrValueError(u"{:s}.op_structure({:#x}, {:d}, {:#x}, {!r}) : The requested address ({:#x}) is not defined as a code type.".format(__name__, ea, opnum, sptr.id, path, ea))

    # Convert the path to a list, and then validate it before we use it.
    path, accepted = [item for item in path], (idaapi.member_t, structure.member_t, six.string_types, six.integer_types)
    if any(not isinstance(item, accepted) for item in path):
        index, item = next((index, item) for index, item in enumerate(path) if not isinstance(item, accepted))
        raise E.InvalidParameterError(u"{:s}.op_structure({:#x}, {:d}, {:#x}, {!r}) : The path member at index {:d} has a type ({!s}) that is not supported.".format(__name__, ea, opnum, sptr.id, path, index, item.__class__))

    # Grab information about our instruction and operand so that we can decode
    # it to get the structure offset to use.
    insn, op = at(ea), operand(ea, opnum)

    # If the operand type is not a valid type, then raise an exception so that
    # we don't accidentally apply a structure to an invalid operand type.
    if op.type not in {idaapi.o_mem, idaapi.o_phrase, idaapi.o_displ, idaapi.o_imm}:
        raise E.MissingTypeOrAttribute(u"{:s}.op_structure({:#x}, {:d}, {:#x}, {!r}) : Unable to apply structure path to the operand ({:d}) for the instruction at {:#x} due to its type ({:d}).".format(__name__, ea, opnum, sptr.id, path, opnum, insn.ea, op.type))

    # Now we need to decode our operand and stash it so that we can later
    # use it to calculate the delta between it and the actual member offset
    # to use when traversing the structure path. We try every possible attribute
    # from our decoders until we find one. Otherwise, we bail.
    res = __optype__.decode(insn, op)
    if isinstance(res, six.integer_types):
        value = res
    elif any(hasattr(res, attribute) for attribute in ['offset', 'Offset', 'address']):
        value = res.offset if hasattr(res, 'offset') else res.Offset if hasattr(res, 'Offset') else res.address
    else:
        raise E.UnsupportedCapability(u"{:s}.op_structure({:#x}, {:d}, {:#x}, {!r}) : An unexpected type ({!s}) was decoded from the operand ({:d}) for the instruction at {:#x}).".format(__name__, ea, opnum, sptr.id, path, value.__class__, opnum, insn.ea))

    # First we use the path the user gave us to figure out the suggested path. This
    # should give us the suggestion and its expected delta that we can use for warnings.
    st = structure.__instance__(sptr.id)
    userdelta, userpath = interface.strpath.suggest(sptr, path)

    # Precalculate a description of the path to make our error messages look good.
    path_description = []
    for sptr, mptr, offset in userpath:
        sname = utils.string.of(idaapi.get_struc_name(sptr.id))
        mname = utils.string.of(idaapi.get_member_name(mptr.id)) if mptr else ''
        fullname = '.'.join([sname, mname] if mname else [sname])
        path_description.append("{:s}{:+#x}".format(fullname, offset) if offset or mname else fullname)

    logging.info(u"{:s}.op_structure({:#x}, {:d}, {:#x}, [{:s}]) : The user suggested the path {:s} with a delta of {:+#x} for the given value ({:#x}).".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), interface.strpath.fullname(userpath), userdelta, value))

    # If the suggested path has only 1 element, no members, and the sum of the delta
    # and the value matches the structure size, then this is simply the structure size.
    if len(userpath) == 1 and all(mptr is None for _, mptr, _ in userpath) and userdelta + value == st.size:
        realdelta, realpath = 0, userpath

    # Now we can calculate the path to the value that the user is trying to suggest
    # a path for. We don't really need the delta, but we can use it to determine
    # the path that the user stopped at with the path that we'll actually apply.
    else:
        realdelta, realpath = interface.strpath.guide(value, st.ptr, userpath)

    logging.info(u"{:s}.op_structure({:#x}, {:d}, {:#x}, [{:s}]) : The determined (real) path was {:s} with a delta of {:+#x} for the given value ({:#x}).".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), interface.strpath.fullname(realpath), realdelta, value))

    # Now if the userdelta and realdelta are different, then either the path they
    # suggested to us is wrong (user > real) or we ended up having to complete
    # their path for them (user < real).
    if userdelta != realdelta:
        delta = realdelta - userdelta
        Flogging = logging.debug if userdelta < realdelta else logging.info
        Fdescription = "incomplete ({:#x} < {:#x})".format if userdelta < realdelta else "incorrect ({:#x} > {:#x})".format
        action = 'resolving additional members' if userdelta < realdelta else 'adjusting suggested members'

        # FIXME: We should probably refactor the previous logic so that way we can
        #        render the suggested members that were ignored or the any of the
        #        members that needed to be resolved.
        Flogging(u"{:s}.op_structure({:#x}, {:d}, {:#x}, [{:s}]) : The suggested path was {:s} and required {:+#x} bytes ({:s}) to reach the operand target value ({:#x}).".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), Fdescription(userdelta, realdelta), delta, action, value))

    # Finally we can convert our realpath into a tid_array that we will apply.
    items = interface.strpath.to_tids(realpath)
    tid, length = idaapi.tid_array(len(items)), len(items)
    for index in builtins.range(length):
        tid[index] = items[index]

    # Now we can apply our tid_array to the operand and then return what
    # we just applied to the user using the other op_structure case.
    if not idaapi.op_stroff(insn.ea if idaapi.__version__ < 7.0 else insn, opnum, tid.cast(), length, 0):
        raise E.DisassemblerError(u"{:s}.op_structure({:#x}, {:d}, {:#x}, {!r}) : Unable to apply the resolved structure path ({:s}) to the operand ({:d}) at the specified address ({:#x}).".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), ', '.join(map("{:#x}".format, items)), opnum, insn.ea))
    return op_structure(insn.ea, opnum)
op_struc = op_struct = utils.alias(op_structure)

# Just some aliases for reading from the current location
@utils.multicase(opnum=six.integer_types)
def op_structurepath(opnum):
    '''Return the structure and members for operand `opnum` at the current instruction.'''
    return op_structurepath(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_structurepath(reference):
    '''Return the structure and members for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_structurepath(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_structurepath(ea, opnum):
    '''Return the structure and members for the operand `opnum` at the instruction `ea`.'''
    F, insn, op, ri = database.type.flags(ea), at(ea), operand(ea, opnum), interface.address.refinfo(ea, opnum)

    # If it's a stack variable, then this is also the wrong API and we should be
    # using the op_structure function. Log it and continue onto the right one.
    if idaapi.is_stkvar(F, opnum) and function.within(insn.ea):
        logging.info(u"{:s}.op_structurepath({:#x}, {:d}) : Using the `{:s}` function instead to return the path for a stack variable operand.".format(__name__, ea, opnum, '.'.join([getattr(op_structure, attribute) for attribute in ['__module__', '__name__'] if hasattr(op_structure, attribute)])))
        return op_structure(ea, opnum)

    # If it's a memory address, then this is the wrong API and we should be using
    # the op_structure function. Log something, and then chain to the correct one.
    elif not idaapi.is_stroff(F, opnum) and ri:
        logging.info(u"{:s}.op_structurepath({:#x}, {:d}) : Using the `{:s}` function instead to return the path for a reference.".format(__name__, ea, opnum, '.'.join([getattr(op_structure, attribute) for attribute in ['__module__', '__name__'] if hasattr(op_structure, attribute)])))
        return op_structure(ea, opnum)

    # If it wasn't a stack variable, then check that the operand is actually a
    # structure offset. If it isn't, then bail because we have no idea what to do.
    elif not idaapi.is_stroff(F, opnum):
        raise E.MissingTypeOrAttribute(u"{:s}.op_structurepath({:#x}, {:d}) : Unable to identify the structure referenced by operand {:d} with flags ({:#x}).".format(__name__, ea, opnum, opnum, F))

    # Start out by collecting the operand value, the delta and the tids from the
    # chosen operand and grab its sptr so that we can figure out what path was applied.
    value = idaapi.as_signed(op.value if op.type in {idaapi.o_imm} else op.addr)

    delta, tids = interface.node.get_stroff_path(insn.ea, opnum)
    logging.debug(u"{:s}.op_structurepath({:#x}, {:d}) : Processing {:d} members ({:s}) from path that was returned from `{:s}`.".format(__name__, ea, opnum, len(tids), ', '.join("{:#x}".format(mid) for mid in tids), "{!s}({:#x}, {:d})".format('.'.join(getattr(interface.node.get_stroff_path, attribute) for attribute in ['__module__', '__name__']), insn.ea, opnum)))

    sid, target = tids[0], value + delta
    sptr = idaapi.get_struc(sid)

    # Before we do anything, we need to figure out exactly what the leftover
    # bytes are after properly resolving our path for the operand and delta.
    # To do this, we resolve for our target address using strpath.of_tids to
    # resolve each individual member and store it in our path.
    path = []
    calculator = interface.strpath.calculate(0)
    resolver = interface.strpath.resolve(path.append, sptr, target)

    position = builtins.next(calculator)
    try:
        sptr, candidates, carry = builtins.next(resolver)
        for owner, mptr, offset in interface.strpath.of_tids(target, tids):
            assert owner.id == sptr.id
            position = calculator.send((owner, mptr, offset))
            sptr, candidates, carry = resolver.send((mptr, carry))

        resolver.send((None, None))
        raise E.DisassemblerError(u"{:s}.op_structurepath({:#x}, {:d}) : Expected path to have been resolved at offset {:#x} of index {:d} with {:s}.".format(__name__, ea, opnum, builtins.next(calculator), len(path), interface.strpath.format(owner, mptr)))

    # If we're done resolving, then save our position for calculating the delta later.
    except (StopIteration, E.MemberNotFoundError):
        position = builtins.next(calculator)

    finally:
        resolver.close(), calculator.close()
        logging.info(u"{:s}.op_structurepath({:#x}, {:d}) : Resolved the path ({:d} elements) for the specified instruction operand to {:s}.".format(__name__, ea, opnum, len(path), interface.strpath.fullname(path)))

    # Now we have the correct resolved path with each offset in it being correct. We
    # need to translate it by our carried value and then we can determine the correct
    # offset for each member of the path that we'll return.
    calculator = interface.strpath.calculate(value + (carry - target))
    result, position = [], builtins.next(calculator)
    for sptr, mptr, offset in path:
        st = structure.__instance__(sptr.id, offset=position)
        item = st.members.by_identifier(mptr.id) if mptr else st
        result.append(item)
        position = calculator.send((sptr, mptr, offset))

    # If we did not figure out any path, then this is likely a sizeof(structure)
    # operand. So, we return the structure and whatever value was carried.
    if not result:
        return structure.__instance__(sptr.id), carry

    # Just like the op_structure implementation, we need to figure out if
    # there's an array being referenced to convert our result to a list.
    elif any(isinstance(member.type, builtins.list) for member in result if isinstance(member, structure.member_t)):
        return result + [carry]

    # Otherwise it's just a path with the carried offset, so we check the
    # carryied offset for non-zero in case we need to return it.
    results = tuple(result)
    if carry:
        return results + (carry,)
    return results if len(results) > 1 else results[0]

## current address and opnum with variable-length path
@utils.multicase(opnum=six.integer_types, structure=(structure.structure_t, idaapi.struc_t, six.string_types))
def op_structurepath(opnum, structure, *path, **delta):
    '''Apply the specified `structure` along with any members in `path` to the instruction operand `opnum` at the current address.'''
    deltapath = [delta.pop('delta', 0)] if delta else []
    return op_structurepath(ui.current.address(), opnum, [item for item in itertools.chain([structure], path, deltapath)])
@utils.multicase(opnum=six.integer_types, member=(structure.member_t, idaapi.member_t))
def op_structurepath(opnum, member, *path, **delta):
    '''Apply the specified `member` along with any members in `path` to the instruction operand `opnum` at the current address.'''
    deltapath = [delta.pop('delta', 0)] if delta else []
    return op_structurepath(ui.current.address(), opnum, [item for item in itertools.chain([member], path, deltapath)])

## address and opnum with variable-length path
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, structure=(structure.structure_t, idaapi.struc_t, six.string_types))
def op_structurepath(ea, opnum, structure, *path, **delta):
    '''Apply the specified `structure` along with the members in `path` to the instruction operand `opnum` at the address `ea`.'''
    deltapath = [delta.pop('delta', 0)] if delta else []
    return op_structurepath(ea, opnum, [item for item in itertools.chain([structure], path, deltapath)])
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, member=(structure.member_t, idaapi.member_t))
def op_structurepath(ea, opnum, member, *path, **delta):
    '''Apply the specified `member` to the instruction operand `opnum` at the address `ea`.'''
    deltapath = [delta.pop('delta', 0)] if delta else []
    return op_structurepath(ea, opnum, [item for item in itertools.chain([member], path, deltapath)])

## operand reference with variable-length path
@utils.multicase(reference=interface.opref_t, structure=(structure.structure_t, idaapi.struc_t, six.string_types))
def op_structurepath(reference, structure, *path, **delta):
    '''Apply the specified `structure` along with the members in `path` to the operand pointed to by `reference`.'''
    deltapath = [delta.pop('delta', 0)] if delta else []
    return op_structurepath(reference, [item for item in itertools.chain([structure], path, deltapath)])
@utils.multicase(reference=interface.opref_t, member=(structure.member_t, idaapi.member_t))
def op_structurepath(reference, member, *path, **delta):
    '''Apply the specified `member` along with the members in `path` to the instruction operand pointed to by `reference`.'''
    deltapath = [delta.pop('delta', 0)] if delta else []
    return op_structurepath(reference, [item for item in itertools.chain([member], path, deltapath)])

## all variations that take a tuple/list to apply to a given operand.
@utils.multicase(reference=interface.opref_t, path=(builtins.tuple, builtins.list))
def op_structurepath(reference, path):
    '''Apply the structure members in `path` to the instruction operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_structurepath(address, opnum, path)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, path=(builtins.tuple, builtins.list))
def op_structurepath(ea, opnum, path):
    '''Apply the structure members in `path` to the instruction operand `opnum` at the address `ea`.'''
    items = [item for item in path]
    member = items.pop(0) if len(items) else ''
    if isinstance(member, six.string_types):
        sptr, fullpath = structure.by(member).ptr, items
    elif isinstance(member, idaapi.struc_t):
        sptr, fullpath = structure.by(member.id), items
    elif isinstance(member, structure.structure_t):
        sptr, fullpath = member.ptr, items
    elif isinstance(member, idaapi.member_t):
        _,_, sptr = idaapi.get_member_by_id(member.id)
        if not interface.node.is_identifier(sptr.id):
            sptr = idaapi.get_member_struc(idaapi.get_member_fullname(member.id))
        fullpath = itertools.chain([member], items)
    elif isinstance(member, structure.member_t):
        sptr, fullpath = member.parent.ptr, itertools.chain([member], items)
    else:
        raise E.InvalidParameterError(u"{:s}.op_structurepath({:#x}, {:d}, {!r}) : Unable to determine the structure from the provided path due to the first item being of an unsupported type ({!s}).".format(__name__, ea, opnum, path, member.__class__))
    return op_structurepath(ea, opnum, sptr, [item for item in fullpath])

@utils.multicase(ea=six.integer_types, opnum=six.integer_types, structure=structure.structure_t, path=(builtins.tuple, builtins.list))
def op_structurepath(ea, opnum, structure, path):
    '''Apply the specified `structure` along with the members in `path` to the to the instruction operand `opnum` at the address `ea`.'''
    return op_structurepath(ea, opnum, structure.ptr, path)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, sptr=idaapi.struc_t, path=(builtins.tuple, builtins.list))
def op_structurepath(ea, opnum, sptr, path):
    '''Apply the structure identified by `sptr` along with the members in `path` to the instruction operand `opnum` at the address `ea`.'''
    ea = interface.address.inside(ea)
    if not database.type.is_code(ea):
        raise E.InvalidTypeOrValueError(u"{:s}.op_structurepath({:#x}, {:d}, {:#x}, {!r}) : The requested address ({:#x}) is not defined as a code type.".format(__name__, ea, opnum, sptr.id, path, ea))

    # Convert the path to a list, and then validate it before we use it.
    path, accepted = [item for item in path], (idaapi.member_t, structure.member_t, six.string_types, six.integer_types)
    if any(not isinstance(item, accepted) for item in path):
        index, item = next((index, item) for index, item in enumerate(path) if not isinstance(item, accepted))
        raise E.InvalidParameterError(u"{:s}.op_structurepath({:#x}, {:d}, {:#x}, {!r}) : The path member at index {:d} has a type ({!s}) that is not supported.".format(__name__, ea, opnum, sptr.id, path, index, item.__class__))

    # Grab information about our instruction and operand so that we can decode
    # it to get the structure offset to use.
    insn, op = at(ea), operand(ea, opnum)

    # If the operand type is not a valid type, then raise an exception so that
    # we don't accidentally apply a structure to an invalid operand type.
    if op.type not in {idaapi.o_mem, idaapi.o_phrase, idaapi.o_displ, idaapi.o_imm}:
        raise E.MissingTypeOrAttribute(u"{:s}.op_structurepath({:#x}, {:d}, {:#x}, {!r}) : Unable to apply structure path to the operand ({:d}) for the instruction at {:#x} due to its type ({:d}).".format(__name__, ea, opnum, sptr.id, path, opnum, insn.ea, op.type))

    # Similar to op_structure, we first need to figure out the path that the user
    # has suggested to us to apply to the operand and we calculate our goal.
    st = structure.__instance__(sptr.id)
    usergoal, userpath = interface.strpath.suggest(st.ptr, path)

    # Precalculate a description of the path to make our logging events look good.
    path_description = []
    for sptr, mptr, offset in userpath:
        sname = utils.string.of(idaapi.get_struc_name(sptr.id))
        mname = utils.string.of(idaapi.get_member_name(mptr.id)) if mptr else ''
        fullname = '.'.join([sname, mname] if mname else [sname])
        path_description.append("{:s}{:+#x}".format(fullname, offset) if offset or mname else fullname)

    # We're looking for the "exact" path which should always be within the bounds
    # of the structure so we'll simply flail around for its value.
    calculator = interface.strpath.calculate(0, operator.truth)
    resolver = interface.strpath.resolve(calculator.send, st.ptr, usergoal)
    flailer = interface.strpath.flail(userpath)
    builtins.next(calculator), builtins.next(flailer)

    sptr, candidates, carry = builtins.next(resolver)
    try:
        while candidates:
            owner, choice, offset = flailer.send((sptr, candidates, carry))
            sptr, candidates, carry = resolver.send((choice, offset))

    except (StopIteration, E.MemberNotFoundError):
        pass

    finally:
        flailer.close()

    # Now we can simply choose the default members and at the end we should have both
    # the goal delta that we'll be able to traverse the suggestions with.
    try:
        while True:
            sptr, candidates, carry = resolver.send((None, carry))

    except (StopIteration, E.MemberNotFoundError):
        pass

    finally:
        resolver.close()
        goaldelta = builtins.next(calculator)
        calculator.close()

    # If our realdelta is different from our userdelta, then the user's path
    # didn't actually resolve completely and we need to let them know.
    if usergoal != goaldelta:
        Flogging = logging.debug if usergoal < goaldelta else logging.warning
        Fdescription = "incomplete ({:#x} < {:#x})".format if usergoal < goaldelta else "incorrect ({:#x} > {:#x})".format
        action = 'of members were added' if usergoal < goaldelta else 'of the last members were temporarily removed'
        Flogging(u"{:s}.op_structurepath({:#x}, {:d}, {:#x}, [{:s}]) : The suggested path was {:s} and {:+#x} bytes {:s} before calculating the real path.".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), Fdescription(usergoal, goaldelta), goaldelta - usergoal, action))

    # Finally we can really flail for the exact member the user wanted using the
    # delta that we're using as our goal and then choose the defaults for the rest.
    realpath = []
    calculator = interface.strpath.calculate(0, realpath.append)
    resolver = interface.strpath.resolve(calculator.send, st.ptr, goaldelta)
    flailer = interface.strpath.flail(userpath)
    realdelta, _ = builtins.next(calculator), builtins.next(flailer)

    sptr, candidates, carry = builtins.next(resolver)
    try:
        while True:
            owner, choice, offset = flailer.send((sptr, candidates, carry))
            sptr, candidates, carry = resolver.send((choice, carry))

    except (StopIteration, E.MemberNotFoundError):
        pass

    finally:
        flailer.close()

    try:
        while True:
            sptr, candidates, carry = resolver.send((None, carry))

    except (StopIteration, E.MemberNotFoundError):
        pass

    finally:
        resolver.close()
        realdelta = builtins.next(calculator)
        calculator.close()

    # If there was no path that we were able to calculate, then the user gave us
    # a single-element path that doesn't point to the first member they requested.
    # So, we deal by using the busted path that they gave us because it should have
    # a structure with the member + offset that they're aiming for anyways.
    if not realpath and len(userpath) == 1:
        realpath[:] = userpath

    # If we hit this case, then the logic described in the previous comment is
    # completely busted and I have no idea what this is supposed to be doing.
    elif not realpath:
        raise E.InvalidParameterError(u"{:s}.op_structurepath({:#x}, {:d}, {:#x}, [{:s}]) : Unable to apply the path to the operand ({:d}) of the specified address ({:#x}) as the given path does not point to a specific member.".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), opnum, insn.ea))

    # Very last thing to do is to calculate the delta for the path with our
    # value, and then we can apply the whole thing to the operand.
    base = usergoal - goaldelta
    delta = realdelta - idaapi.as_signed(op.value if op.type in {idaapi.o_imm} else op.addr)
    items = interface.strpath.to_tids(realpath)
    tid, length = idaapi.tid_array(len(items)), len(items)
    for index in builtins.range(length):
        tid[index] = items[index]

    # Only thing that's left to do is apply the tids that we collected along with
    # the delta that we calculated from the user's input to the desired operand.
    if not idaapi.op_stroff(insn.ea if idaapi.__version__ < 7.0 else insn, opnum, tid.cast(), length, base + delta):
        raise E.DisassemblerError(u"{:s}.op_structurepath({:#x}, {:d}, {:#x}, [{:s}]) : Unable to apply the resolved structure path ({:s}) and delta ({:+#x}) to the operand ({:d}) at the specified address ({:#x}).".format(__name__, ea, opnum, st.ptr.id, ', '.join(path_description), ', '.join(map("{:#x}".format, items)), base + delta, opnum, insn.ea))

    # And then we can call into our other case to return what we just applied.
    return op_structurepath(insn.ea, opnum)
op_strucpath = op_strpath = utils.alias(op_structurepath)

@utils.multicase(opnum=six.integer_types)
def op_enumeration(opnum):
    '''Return the enumeration member id for the operand `opnum` belonging to the current instruction.'''
    return op_enumeration(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_enumeration(reference):
    '''Return the enumeration member id for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_enumeration(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_enumeration(ea, opnum):
    '''Return the enumeration member id for the operand `opnum` belonging to the instruction at `ea`.'''

    # If our operand number is actually an enumeration identifier, then shift
    # our parameters, and try again with the current address.
    if enumeration.has(opnum):
        ea, opnum, id = ui.current.address(), ea, opnum
        return op_enumeration(ea, opnum, id)

    # Ensure that the operand number is within our available operands.
    if opnum >= len(operands(ea)):
        raise E.InvalidTypeOrValueError(u"{:s}.op_enumeration({:#x}, {:d}) : The specified operand number ({:d}) is larger than the number of operands ({:d}) for the instruction at address {:#x}.".format(__name__, ea, opnum, opnum, len(operands(ea)), ea))

    # Check the flags for the given address to ensure there's actually an
    # enumeration defined as one of the operands.
    F = database.type.flags(ea)
    if all(F & item == 0 for item in [idaapi.FF_0ENUM, idaapi.FF_1ENUM]):
        raise E.MissingTypeOrAttribute(u"{:s}.op_enumeration({:#x}, {:d}) : Operand {:d} does not contain an enumeration.".format(__name__, ea, opnum, opnum))

    # After verifying that there's definitely an enumeration at the address, we
    # can ask for the enumeration identifier to figure out the actual member.
    eid, cid = idaapi.get_enum_id(ea, opnum)
    if eid == idaapi.BADNODE:
        raise E.DisassemblerError(u"{:s}.op_enumeration({:#x}, {:d}) : Unable to get enumeration identifier for operand {:d} with flags {:#x}.".format(__name__, ea, opnum, opnum, F))

    # After grabbing the member, lets grab the actual value that we're going to
    # need to process the member identifier out of.
    op = operand(ea, opnum)
    value, bits, signed = op.value if op.type in {idaapi.o_imm} else op.addr, op_bits(ea, opnum), interface.node.alt_opinverted(ea, opnum)

    # FIXME: recalculate the operand value if the operand is negated (~)

    # If this enumeration is a bitfield, then we need to figure out all the masks
    # that this operand uses. If it's not, then we have a single mask which is
    # idaapi.DEFMASK.
    if enumeration.bitfield(eid):
        masks = [mask for mask in enumeration.masks.iterate(eid)]
    else:
        masks = [idaapi.DEFMASK]

    # Now we iterate through all of the masks and attempt to get the enumeration
    # member. We need to figure out whether our value is signed so that we can
    # invert it and then apply the mask to our value for bitfield support.
    res, ok = [], True
    for mask in masks:
        item = (~value + 1 if signed else value) & mask

        # Attempt to get the member using the value that we masked away. We first
        # try fetching it with the value we masked, and if that fails then we try
        # again using the signed value. This is due to how IDA applies an enumeration
        # to an operand in that it seems to discard the OP_REPR altval which forces
        # us to have to figure out how the value is stored in the enumeration
        # ourselves.
        mid = idaapi.get_enum_member(eid, item, cid, mask)
        if mid == idaapi.BADNODE:
            mid = idaapi.get_enum_member(eid, idaapi.as_signed(item, bits), cid, mask)

        # If that still didn't work, then this is an error and we need to warn the
        # user about it.
        if mid == idaapi.BADNODE:
            ok, width = False, 2 * enumeration.size(eid) if enumeration.size(eid) else utils.string.digits(max(masks), 16)
            logging.warn(u"{:s}.op_enumeration({:#x}, {:d}) : No enumeration member was found for the mask ({:s}) in the enumeration ({:#x}) at operand {:d}.".format(__name__, ea, opnum, "{:#0{:d}x} & {:#0{:d}x}".format(item, 3 + width if item < 0 else 2 + width, mask, 3 + width if mask < 0 else 2 + width) if enumeration.bitfield(eid) else "{:#0{:d}x}".format(item, 3 + width if item < 0 else 2 + width), eid, opnum))

        # Otherwise, add it to our results and continue onto the next mask.
        else:
            res.append(mid)
        continue

    # If we found everything without any errors, then return our results to
    # the caller. If it was a bitfield, then we need to check if there's
    # a single result, otherwise we return a tuple. If it was not a bitfield
    # then the enumeration member identifier should be more than enough.
    if ok and res:
        if enumeration.bitfield(eid):
            return builtins.tuple(res) if len(res) > 1 else res[0]
        return res[0]

    # If we did get something but we missed a value for one of the masks,
    # then this result is incomplete, but still okay to return.
    elif res:
        if enumeration.bitfield(eid):
            return builtins.tuple(res) if len(res) > 1 else res[0]
        return res[0]

    # Otherwise, we didn't find anything and there was an error trying to
    # get an enumeration member. This is worth an exception for the caller
    # to figure out what to do with.
    raise E.DisassemblerError(u"{:s}.op_enumeration({:#x}, {:d}) : Unable to get any members for the enumeration ({:#x}) at operand {:d}.".format(__name__, ea, opnum, eid, opnum))
@utils.multicase(opnum=six.integer_types, name=six.string_types)
@utils.string.decorate_arguments('name')
def op_enumeration(opnum, name):
    '''Apply the enumeration `name` to operand `opnum` for the current instruction.'''
    return op_enumeration(ui.current.address(), opnum, enumeration.by(name))
@utils.multicase(reference=interface.opref_t)
def op_enumeration(reference, name_or_id):
    '''Apply the enumeration `name_or_id` to the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_enumeration(address, opnum, name_or_id)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, name=six.string_types)
@utils.string.decorate_arguments('name')
def op_enumeration(ea, opnum, name):
    '''Apply the enumeration `name` to operand `opnum` for the instruction at `ea`.'''
    return op_enumeration(ea, opnum, enumeration.by(name))
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, id=(six.integer_types, builtins.tuple, builtins.list))
def op_enumeration(ea, opnum, id):
    '''Apply the enumeration `id` to operand `opnum` of the instruction at `ea`.'''
    if opnum >= len(operands(ea)):
        raise E.InvalidTypeOrValueError(u"{:s}.op_enumeration({:#x}, {:d}) : The specified operand number ({:d}) is larger than the number of operands ({:d}) for the instruction at address {:#x}.".format(__name__, ea, opnum, opnum, len(operands(ea)), ea))

    ok = idaapi.op_enum(ea, opnum, *id) if isinstance(id, (builtins.tuple, builtins.tuple)) else idaapi.op_enum(ea, opnum, id, 0)
    if not ok:
        eid, serial = id if isinstance(id, (builtins.tuple, builtins.list)) else (id, 0)
        raise E.DisassemblerError(u"{:s}.op_enumeration({:#x}, {:d}, {:#x}) : Unable to set operand {:d} for instruction ({:#x}) to enumeration {:#x} (serial {:d}).".format(__name__, ea, opnum, eid, opnum, ea, eid, serial))
    return op_enumeration(ea, opnum)
op_enum = utils.alias(op_enumeration)

@utils.multicase(opnum=six.integer_types)
def op_string(opnum):
    '''Return the string type of operand `opnum` for the current instruction.'''
    return op_string(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_string(reference):
    '''Return the string type (``idaapi.STRTYPE_``) of the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_string(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_string(ea, opnum):
    '''Return the string type (``idaapi.STRTYPE_``) of operand `opnum` for the instruction at `ea`.'''
    F = database.type.flags(ea)
    if F & (idaapi.FF_STRLIT if hasattr(idaapi, 'FF_STRLIT') else idaapi.FF_ASCI) == 0:
        raise E.MissingTypeOrAttribute(u"{:s}.op_string({:#x}, {:d}) : Operand {:d} does not contain a literate string.".format(__name__, ea, opnum, opnum))

    res = opinfo(ea, opnum)
    if res is None:
        raise E.DisassemblerError(u"{:s}.op_string({:#x}, {:d}) : Unable to get `idaapi.opinfo_t` for operand {:d} with flags {:#x}.".format(__name__, ea, opnum, opnum, F))

    return res.strtype
@utils.multicase(reference=interface.opref_t, strtype=six.integer_types)
def op_string(reference, strtype):
    '''Set the string type used by operand pointed to by `reference` to `strtype`.'''
    address, opnum, _ = reference
    return op_string(address, opnum, strtype)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types, strtype=six.integer_types)
def op_string(ea, opnum, strtype):
    '''Set the string type used by operand `opnum` for the instruction at `ea` to `strtype`.'''
    info, F = idaapi.opinfo_t(), database.type.flags(ea)

    # Update our flags for the instruction to include the string definition.
    F |= idaapi.FF_STRLIT if hasattr(idaapi, 'FF_STRLIT') else idaapi.FF_ASCI
    info.strtype = strtype

    # Now we can actually apply the opinfo_t to the specified operand, and then
    # cross-check that the operand info's string type matches what we set it to.
    res = opinfo(ea, opnum, info, flags=F)
    return True if res.strtype == strtype else False

# XXX: these functions are pretty much deprecated in favor of interface.address.refinfo.
@utils.multicase()
def ops_refinfo():
    '''Returns the ``idaapi.refinfo_t`` for the instruction at the current address.'''
    return interface.address.refinfo(ui.current.address())
@utils.multicase(ea=six.integer_types)
def ops_refinfo(ea):
    '''Returns the ``idaapi.refinfo_t`` for the instruction at the address `ea`.'''
    return interface.address.refinfo(ea)
@utils.multicase(opnum=six.integer_types)
def op_refinfo(opnum):
    '''Return the ``idaapi.refinfo_t`` for the operand `opnum` belonging to the instruction at the current address.'''
    return interface.address.refinfo(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_refinfo(reference):
    '''Return the ``idaapi.refinfo_t`` for the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return interface.address.refinfo(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_refinfo(ea, opnum):
    '''Return the ``idaapi.refinfo_t`` for the operand `opnum` belonging to the instruction at the address `ea`.'''
    return interface.address.refinfo(ea, opnum)

@utils.multicase(opnum=six.integer_types)
def op_reference(opnum):
    '''Return the address being referenced by the operand `opnum` belonging to the instruction at the current address.'''
    return op_reference(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_reference(reference):
    '''Return the address being referenced by the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_reference(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_reference(ea, opnum):
    '''Return the address being referenced by the operand `opnum` belonging to the instruction at the address `ea`.'''
    insn, ops = at(ea), operands(ea)
    if not(opnum < len(ops)):
        raise E.InvalidTypeOrValueError(u"{:s}.op_reference({:#x}, {:d}) : The specified operand number ({:d}) is larger than the number of operands ({:d}) for the instruction at address {:#x}.".format(__name__, ea, opnum, opnum, len(operands(ea)), ea))

    # Grab the operand and its reference if it it actually has one. We'll use this
    # to figure out exactly what address is being referenced by the operand.
    op, ri = ops[opnum], interface.address.refinfo(ea, opnum)
    if ri:
        target, base, value = idaapi.ea_pointer(), idaapi.ea_pointer(), op.value if op.type in {idaapi.o_imm} else op.addr

        # Try and calculate the reference for the operand value. If we couldn't, then we simply treat the value as-is.
        if not idaapi.calc_reference_data(target.cast(), base.cast(), ea, ri, value):
            logging.debug(u"{:s}.op_reference({:#x}, {:d}) : The disassembler could not calculate the target for the reference ({:d}) at address {:#x}.".format(__name__, ea, opnum, ri.flags & idaapi.REFINFO_TYPE, ea))
            return value
        return target.value()

        # If we actually wanted to, we could use the reference information to figure
        # out the actual offset to the data that is being referenced.
        base, target = (item.value() for item in [base, target])
        if base:
            base, offset = base, target - base
            return base + offset

        # If we weren't given the base address, then we're supposed to figure it out ourselves.
        seg = idaapi.getseg(ea)
        if seg is None:
            raise E.SegmentNotFoundError(u"{:s}.op_reference({:#x}, {:d}) : Unable to locate segment containing the specified instruction address ({:#x}).".format(__name__, ea, ea))

        imagebase, segbase = idaapi.get_imagebase(), idaapi.get_segm_base(seg)
        base, offset = imagebase, seg.start_ea - imagebase
        return base + offset

    # Otherwise, we need to use the default reference type. Unless the user changed
    # the default reference type, this should always result in returning the immediate.
    ri = idaapi.refinfo_t()
    ri.set_type(idaapi.get_default_reftype(ea))
    if op.type not in {idaapi.o_mem, idaapi.o_near, idaapi.o_far}:
        raise E.DisassemblerError(u"{:s}.op_reference({:#x}, {:d}) : Unable to get the reference information from the operand type ({:d}) at the specified operand ({:d}) belonging to the address {:#x}.".format(__name__, ea, opnum, op.type, opnum, ea))

    # If the target base can't be calculated, then we need to use the imagebase.
    res = idaapi.calc_target(ea, op.addr, ri)
    return op.addr if res == idaapi.BADADDR else res
op_ref = utils.alias(op_reference)

@utils.multicase(opnum=six.integer_types)
def op_references(opnum):
    '''Returns the `(address, opnum, type)` of all the instructions that reference the operand `opnum` for the current instruction.'''
    return op_references(ui.current.address(), opnum)
@utils.multicase(reference=interface.opref_t)
def op_references(reference):
    '''Returns the `(address, opnum, type)` of all the instructions that reference the operand pointed to by `reference`.'''
    address, opnum, _ = reference
    return op_references(address, opnum)
@utils.multicase(ea=six.integer_types, opnum=six.integer_types)
def op_references(ea, opnum):
    '''Returns the `(address, opnum, type)` of all the instructions that reference the operand `opnum` for the instruction at `ea`.'''
    insn, ops = at(ea), operands(ea)
    if not(opnum < len(ops)):
        raise E.InvalidTypeOrValueError(u"{:s}.op_references({:#x}, {:d}) : The specified operand number ({:d}) is larger than the number of operands ({:d}) for the instruction at address {:#x}.".format(__name__, ea, opnum, opnum, len(operands(ea)), ea))

    # Start out by doing sanity check so that we can determine whether
    # the operand is referencing a local or a global. We grab both the
    # operand info any the result from idaapi.op_adds_xrefs in order to
    # distinguish the "type" of xrefs that are associated with an operand.
    # This way we can distinguish structure members, enumeration members,
    # locals, globals, etc.
    F = database.type.flags(insn.ea)
    info, has_xrefs = opinfo(insn.ea, opnum), idaapi.op_adds_xrefs(F, opnum)

    # If we have xrefs but no type information, then this operand has to
    # be pointing to a local stack variable that is stored in the frame.
    # This means that we need to be inside a function so that we can
    # grab its frame and search through it.
    if has_xrefs and info is None:
        fn = idaapi.get_func(insn.ea)
        if fn is None:
            raise E.FunctionNotFoundError(u"{:s}.op_references({:#x}, {:d}) : Unable to locate function for address {:#x}.".format(__name__, ea, opnum, insn.ea))

        # Use IDAPython's api to calculate the structure offset into the
        # function's frame using the instruction operand.
        stkofs_ = idaapi.calc_stkvar_struc_offset(fn, insn.ea if idaapi.__version__ < 7.0 else insn, opnum)

        # For sanity, we're going to grab the actual value of the operand
        # and use it to verify that the result from IDAPython is correct.
        op = operand(insn.ea, opnum)
        sval = interface.sval_t(op.addr).value

        # Now that we have the instruction operand's value, we can use
        # it with IDAPython to check if it's actually a frame member.
        res = idaapi.get_stkvar(op, sval) if idaapi.__version__ < 7.0 else idaapi.get_stkvar(insn, op, sval)
        if res is None:
            raise E.DisassemblerError(u"{:s}.op_references({:#x}, {:d}) : The instruction operand's value ({:#x}) does not appear to point to a frame variable at the same offset ({:#x}).".format(__name__, ea, opnum, sval.value, stkofs_))

        # Now we have the actual frame member and the offset into the
        # frame, and we can use it to validate against our expectation.
        member, stkofs = res
        if stkofs != stkofs_:
            logging.warning(u"{:s}.op_references({:#x}, {:d}) : The stack variable offset ({:#x}) for the instruction operand does not match what was expected ({:#x}).".format(__name__, ea, opnum, stkofs, stkofs_))

        # Finally we can instantiate an idaapi.xreflist_t, and call directly
        # into the IDAPython api in order to let it build all of the
        # xrefs for the operand.
        xl = idaapi.xreflist_t()
        idaapi.build_stkvar_xrefs(xl, fn, member)

        # That should've created our xref list, so we can simply transform
        # it directly into a list of interface.opref_t and return it.
        # FIXME: the type for an LEA instruction should include an '&' in the
        #        reftype_t, but in this case we explicitly trust the type.
        return [ interface.opref_t(x.ea, int(x.opnum), interface.reftype_t.of(x.type)) for x in xl ]

    # If we have xrefs and the operand has information associated with it, then
    # we need to check if the type-id is an enumeration. If so, then the user is
    # looking for references to an enumeration member. We start by grabbing both
    # id for the enumeration and its member.
    elif has_xrefs and info and enumeration.has(info.tid):
        eid, mid = info.tid, op_enumeration(insn.ea, opnum)
        NALT_ENUM0, NALT_ENUM1 = (getattr(idaapi, name, 0xb + idx) for idx, name in enumerate(['NALT_ENUM0', 'NALT_ENUM1']))

        # Now we check to see if it has any xrefs that point directly to the id
        # of the member. If not, then there's nothing to do here.
        X = idaapi.xrefblk_t()
        if not X.first_to(mid, idaapi.XREF_ALL):
            fullname = '.'.join([enumeration.name(eid), enumeration.member.name(mid)])
            logging.warning(u"{:s}.op_references({:#x}, {:d}) : No references were found for the enumeration member {:s} ({:#x}) at operand {:d} of the instruction at {:#x}.".format(__name__, ea, opnum, fullname, mid, opnum, insn.ea))
            return []

        # As we were able to find one, we can just continue to iterate through
        # the xrefblk_t while gathering all of the necessary properties into
        # our list of references.
        refs = [(X.frm, X.iscode, X.type)]
        while X.next_to():
            refs.append((X.frm, X.iscode, X.type))

        # After gathering all the xrefs into a list, we'll need to transform
        # it into a list of internal.opref_t. In order to do that, we need to
        # figure out which operand the member is in for each address. During
        # this process, we also verify that the member is actually owned by
        # the enumeration we extracted from our original operand information.
        res, Fnetnode = [], idaapi.ea2node if hasattr(idaapi, 'ea2node') else utils.fidentity
        for ea, _, t in refs:
            ops = ((opnum, internal.netnode.alt.get(Fnetnode(ea), altidx)) for opnum, altidx in enumerate([NALT_ENUM0, NALT_ENUM1]) if internal.netnode.alt.has(Fnetnode(ea), altidx))
            ops = (opnum for opnum, mid in ops if enumeration.member.parent(mid) == eid)
            res.extend(interface.opref_t(ea, int(opnum), interface.reftype_t.of(t)) for opnum in ops)
        return res

    # If the operand adds xrefs, there's operand information, and the operand's
    # type identifier is defined, then this is a structure. We don't actually
    # have to test the operand information in detail because for some reason
    # there's absolutely nothing in it.
    elif has_xrefs and info and info.tid != idaapi.BADADDR:
        NSUP_STROFF0, NSUP_STROFF1 = (getattr(idaapi, name, 0xf + idx) for idx, name in enumerate(['NSUP_STROFF0', 'NSUP_STROFF1']))
        op = ops[opnum]

        # First we need to get the structure path that IDA has stored at the
        # operand, and then get the operand's value. This is because IDA
        # isn't always guaranteed to return a proper path, and so we'll need
        # to calculate the offset ourselves.
        delta, items = interface.node.get_stroff_path(insn.ea, opnum)

        # Now we should have the path and delta that IDA is suggesting is
        # at the given operand, so we'll need to decode the operand's value
        # so that we can use it to find the proper path through the structure.
        res = __optype__.decode(insn, op)
        if isinstance(res, six.integer_types):
            offset = res
        elif any(hasattr(res, attribute) for attribute in ['offset', 'Offset', 'address']):
            offset = res.offset if hasattr(res, 'offset') else res.Offset if hasattr(res, 'Offset') else res.address
        else:
            raise E.UnsupportedCapability(u"{:s}.op_references({:#x}, {:d}) : An unexpected type ({!s}) was decoded from the operand ({:d}) for the instruction at {:#x}.".format(__name__, ea, opnum, res.__class__, opnum, insn.ea))

        # Hopefully that was it, now we should be able to figure out our path.
        _, items = interface.node.calculate_stroff_path(offset, items)

        # If we actually got some items, then we can assign it to members.
        if items:
            members = items

        # If we couldn't figure out the path, then we'll just fall back
        # to the op_structure implementation. This should give us the
        # members that are being used at the operand.
        else:
            res = op_structure(insn.ea, opnum)
            items = [item for item in res] if isinstance(res, (builtins.list, builtins.tuple)) else [res]
            items.pop(-1) if isinstance(items[-1], six.integer_types) else items

            # If the result is a structure, then this is either a reference
            # or a size. The easiest way to resolve this is to just grab
            # all the code references from the structure_t itself, and filter
            # them for any tuples.
            if len(items) == 1 and isinstance(items[0], structure.structure_t):
                return [item for item in items[0].refs() if isinstance(item, builtins.tuple)]

            # So, now we should have a list of structure.member_t and all
            # we need to do is grab their idaapi.struc_t and idaapi.member_t.
            members = [(item.parent.ptr, item.ptr) for item in items]

        # Now we need to iterate through all of the members and collect their
        # xref'd targets. These will all get filtered later, so we shouldn't
        # have to worry about it too much.
        refs = {item for item in []}
        for sptr, mptr in members:

            # Now we check to see if it has any xrefs that point directly to
            # the id of the member. If not, then there's nothing to do here.
            # First we need to check the first xref of the member. If there
            # isn't anything, then we continue onto the next one.
            X = idaapi.xrefblk_t()
            if not X.first_to(mptr.id, idaapi.XREF_ALL):
                fullname = idaapi.get_member_fullname(mptr.id)
                logging.info(u"{:s}.op_references({:#x}, {:d}) : No references were found for structure member \"{:s}\".".format(__name__, ea, opnum, utils.string.escape(utils.string.of(fullname), '"')))
                continue

            # If we were able to get an xref, then we can gather the rest of
            # them into our list which we'll verify later.
            items = [(X.frm, X.iscode, X.type)]
            while X.next_to():
                items.append((X.frm, X.iscode, X.type))

            # Update our set with all of the references that we found for the
            # current member, and then continue onto the next one.
            refs.update(items)

        # To verify that an xref is definitely referencing the path we care
        # about, we'll need to check the path for each operand belonging to
        # every xref. We're going to use the structure in our path along with
        # all of its members as a required constraint when filtering them.
        sptr, _ = members[0]
        required = {mptr.id for _, mptr in members}

        # Now we can iterate through all our references and gather any operands
        # as potential candidates that we'll filter later.
        result, Fnetnode = [], idaapi.ea2node if hasattr(idaapi, 'ea2node') else utils.fidentity
        for ea, _, t in sorted(refs, key=operator.itemgetter(0)):
            candidates = []

            # Start by gathering any structure candidates that may be referenced
            # by our structure path.
            for refopnum, supidx in enumerate([NSUP_STROFF0, NSUP_STROFF1]):
                if internal.netnode.sup.has(Fnetnode(ea), supidx):
                    delta, identifiers = interface.node.get_stroff_path(ea, refopnum)

                    # We'll need to rebuild the path to this member because again
                    # IDA does not guarantee the full path will be stored. So,
                    # extract the operand's value and use it to calculate all of
                    # the ids for the operand.
                    op = operand(ea, refopnum)
                    offset = idaapi.as_signed(op.value if op.type in {idaapi.o_imm} else op.addr, 8 * op_size(ea, refopnum))
                    _, items = interface.node.calculate_stroff_path(offset + delta, identifiers)

                    # If this path does not even include our structure inside it,
                    # then we can just exclude it from our list of candidates.
                    if sptr.id not in {sptr.id for sptr, _ in items}:
                        continue

                    # Now we have the items, we need to grab their identifiers
                    # and then we can later test for them.
                    ids = [sptr.id for sptr, _ in items[:1]] + [mptr.id for _, mptr in items[:]]
                    candidates.append((refopnum, {id for id in ids}))
                continue

            # Next we need to check if there were any operands that actually
            # point to stack variables so we can figure out their path and
            # add them to our candidates list if necessary.
            for refopnum, op in enumerate(operands(ea)):
                if not idaapi.is_stkvar(database.type.flags(ea), refopnum):
                    continue

                # Use the instruction and the operand to figure out the
                # member id of the frame that we need to descend into.
                item = idaapi.get_stkvar(at(ea), op, op.value if op.type in {idaapi.o_imm} else op.addr)
                if item is None:
                    logging.warning(u"{:s}.op_references({:#x}, {:d}) : Error trying to get frame variable for the referenced operand ({:d}) of the instruction at {:#x}.".format(__name__, insn.ea, opnum, refopnum, ea))
                    continue
                mptr, actval = item
                offset = actval - mptr.soff

                # We have the mptr for the frame variable, so next we just need
                # to get the sptr for it, and use it get its members_t. This way
                # we can use the actual value to compose a path through it.
                msptr = idaapi.get_sptr(mptr)
                if msptr is None:
                    logging.warning(u"{:s}.op_references({:#x}, {:d}) : The frame variable for the operand ({:d}) in the instruction at {:#x} is not a structure.".format(__name__, insn.ea, opnum, refopnum, ea))
                    continue

                # Instantiate a structure_t in order to grab its members_t. From
                # this we can then use the actual value to carve a path straight
                # through the member.
                st = structure.__instance__(msptr.id)
                path, delta = st.members.__walk_to_realoffset__(offset)
                ids = [msptr.id] + [member.ptr.id for member in path]
                candidates.append((refopnum, {id for id in ids}))

            # If we didn't find any candidates, then that means this is a global
            # so we need to figure out which operand it is. We'll iterate through
            # all of them for this xref and filter it in one shot.
            if not candidates:
                for refopnum, op in enumerate(operands(ea)):
                    if op.type not in {idaapi.o_mem}:
                        continue

                    # Make sure that the operand is actually pointing to a
                    # structure. If it isn't, then this operand is not anything
                    # that we really care about.
                    if not database.type.is_structure(database.address.head(op.addr)):
                        continue

                    # Now we can trust the op_structure function to get all the
                    # members for the given operand. We'll need to homogenize the
                    # returned path, though, to a list of member_t.
                    path = op_structure(ea, refopnum)
                    items = [item for item in path] if isinstance(path, (builtins.list, builtins.tuple)) else [path]
                    items.pop(-1) if isinstance(items[-1], six.integer_types) else items

                    # Now we can grab all of the operand's ids and check them
                    # against our required ids before adding them to our results.
                    ids = {item.ptr.id for item in items}
                    if ids & required == required:
                        result.append(interface.opref_t(ea, int(refopnum), op_state(ea, refopnum)))
                    continue
                continue

            # Now that we've gathered all of the relevant operand numbers
            # and the structure ids for their paths, we need to do a final
            # pass of them to filter the operands to include references for.
            filtered = []
            for refopnum, ids in candidates:

                # Check that the list of required identifiers is within our
                # candidate identifiers. As each id is unique, this should
                # support the case where IDA doesn't store the full structure
                # offset path within the database.
                if ids & required == required:
                    filtered.append(refopnum)
                continue
            result.extend(interface.opref_t(ea, int(op), interface.reftype_t.of(t)) for op in filtered)
        return result

    # Anything else should be just a regular global reference or an immediate,
    # and to figure this out we just grab the operand's value and work it out
    # from there. The value at the supidx has some format which is documented
    # as "complex reference information". In some cases, I've seen the byte
    # 0x02 used to describe a pointer to a global that is within the second
    # segment. This might be worth noting in case we have to dig in there.

    # XXX: verify whether globals are supposed to add xrefs (has_xrefs) or not.

    attributes = ['NSUP_REF0', 'NSUP_REF1', 'NSUP_REF2', 'NSUP_REF3', 'NSUP_REF4', 'NSUP_REF5', 'NSUP_REF6', 'NSUP_REF7']
    indices = [9, 10, 11, 21, 22, 23, 33, 34]
    NSUP_REF0, NSUP_REF1, NSUP_REF2, NSUP_REF3, NSUP_REF4, NSUP_REF5, NSUP_REF6, NSUP_REF7 = (getattr(idaapi, name, supidx) for name, supidx in zip(attributes, indices))

    # We start by decoding the operand's value from the instruction. From
    # this, we should be able to get an immediate address, an offset, or
    # whatever. Once we get the right type, then we can start looking for
    # xrefs to it.
    res = __optype__.decode(insn, ops[opnum])
    if isinstance(res, six.integer_types):
        value = res
    elif any(hasattr(res, attribute) for attribute in ['offset', 'Offset', 'address']):
        value = res.offset if hasattr(res, 'offset') else res.Offset if hasattr(res, 'Offset') else res.address
    else:
        raise E.UnsupportedCapability(u"{:s}.op_references({:#x}, {:d}) : An unexpected type ({!s}) was decoded from the operand ({:d}) for the instruction at {:#x}.".format(__name__, ea, opnum, res.__class__, opnum, insn.ea))

    # Now we can try to get all the xrefs from the address or value that
    # we extracted. If we couldn't grab anything, then just warn the user
    # about it and return an empty list.
    X = idaapi.xrefblk_t()
    if not X.first_to(value, idaapi.XREF_ALL):
        logging.warning(u"{:s}.op_references({:#x}, {:d}) : The operand ({:d}) at the specified address ({:#x}) does not have any references.".format(__name__, insn.ea, opnum, opnum, insn.ea))
        return []

    # However, if we were able to find the first value, then we can
    # proceed to gather the rest of them into a list of references.
    refs = [(X.frm, X.iscode, X.type)]
    while X.next_to():
        refs.append((X.frm, X.iscode, X.type))

    # After gathering all of the references into our list, we need
    # to iterate through all of them to figure out exactly what kind
    # of data each reference is targetting.
    res = []
    for ea, _, t in refs:

        # If we got a bad address, then simply skip over it because
        # it's entirely not relevant.
        if ea == idaapi.BADADDR:
            continue

        # Grab the flags for the address of the reference, and mask
        # out everything but its type. If it's type tells us that
        # it's pointing to something defined as code, then we'll
        # need to figure out what operand is referencing it.
        if database.type.flags(ea, idaapi.MS_CLS) == idaapi.FF_CODE:

            # We iterate through all of the operands in order to extract
            # the value from each operand. This way we can verify that it's
            # s actually the same value in our original instruction operand.
            ops = ((opnum, operand(ea, opnum).value if operand(ea, opnum).type in {idaapi.o_imm} else operand(ea, opnum).addr) for opnum in range(ops_count(ea)))
            ops = (opnum for opnum, val in ops if val == value)

            # As that's been confirmed, we can now create the interface.opref_t
            # with any of the instruction operands that we've determined.
            iterable = (interface.opref_t(ea, int(op), interface.reftype_t.of(t)) for op in ops)

        # If the address of the reference wasn't actually a code
        # type, then this is a data global which doesn't have an
        # operand for us to search through.
        else:
            ref = interface.ref_t(ea, None, interface.reftype_t.of(t))
            iterable = (item for item in [ref])
        res.extend(iterable)
    return res
op_refs = utils.alias(op_references)

## types of instructions
class type(object):
    """
    This namespace is for fetching information about the instruction
    type at a given address within the database. The functions within
    this namespace return a boolean based on whether the instruction at
    the given address fits a particular type.

    It is prudent to note that the information that these functions
    expose are essentially flags for the instruction and is provided
    in order to allow a user to infer how IDA has processed the
    instruction. These flags are used by IDA in order to determine
    things such as whether or not it should continue disassembling,
    or if it should add the instruction's operand to its queue in
    order to recursively disassemble code witin the database.

    This namespace is also aliased as ``instruction.t``.

    Some examples of using this namespace are::

        > print( instruction.type.is_return(ea) )
        > print( instruction.type.is_jxx(ea) )
        > print( instruction.type.is_call(ea) )
        > print( instruction.type.is_branch(ea) )

    """
    @utils.multicase()
    @classmethod
    def feature(cls):
        '''Returns the feature bitmask of the instruction at the current address.'''
        return cls.feature(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def feature(cls, ea):
        '''Return the feature bitmask for the instruction at the address `ea`.'''
        if database.type.is_code(ea):
            return at(ea).get_canon_feature()
        return None
    @utils.multicase(ea=six.integer_types, mask=six.integer_types)
    @classmethod
    def feature(cls, ea, mask):
        '''Return the feature bitmask for the instruction at the address `ea` masked with `mask`.'''
        if database.type.is_code(ea):
            return at(ea).get_canon_feature() & idaapi.as_uint32(mask)
        return None

    @utils.multicase()
    @classmethod
    def is_sentinel(cls):
        '''Returns true if the current instruction is a sentinel-type instruction.'''
        return cls.is_sentinel(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_sentinel(cls, ea):
        '''Returns true if the instruction at `ea` is a sentinel-type instruction.'''
        ea = interface.address.inside(ea)
        return database.type.is_code(ea) and all([cls.feature(ea, idaapi.CF_STOP)])
    sentinel = issentinel = sentinelQ = utils.alias(is_sentinel, 'type')

    @utils.multicase()
    @classmethod
    def is_return(cls):
        '''Returns true if the current instruction is a return-type instruction.'''
        return cls.is_return(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_return(cls, ea):
        '''Returns true if the instruction at `ea` is a return-type instruction.'''
        ea, Xcfilter = interface.address.inside(ea), {idaapi.get_item_end(ea)}
        F, (Xci, Xdi) = cls.feature(ea), (interface.xiterate(ea, ffirst, fnext) for ffirst, fnext in [(idaapi.get_first_cref_from, idaapi.get_next_cref_from), (idaapi.get_first_dref_from, idaapi.get_next_dref_from)])
        Xc, Xd = ([item for item in X] for X in [(item for item in Xci if item not in Xcfilter), Xdi])
        return cls.is_sentinel(ea) and not any([F & idaapi.CF_JUMP, Xc, Xd])
    ret = isreturn = returnQ = retQ = utils.alias(is_return, 'type')

    @utils.multicase()
    @classmethod
    def is_shift(cls):
        '''Returns true if the current instruction is a bit-shifting instruction.'''
        return cls.is_shift(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_shift(cls, ea):
        '''Returns true if the instruction at `ea` is a bit-shifting instruction.'''
        ea = interface.address.inside(ea)
        return database.type.is_code(ea) and all([cls.feature(ea, idaapi.CF_SHFT)])
    shift = isshift = shiftQ = utils.alias(is_shift, 'type')

    @utils.multicase()
    @classmethod
    def is_branch(cls):
        '''Returns true if the current instruction is any kind of branch.'''
        return cls.is_branch(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_branch(cls, ea):
        '''Returns true if the instruction at `ea` is any kind of branch.'''
        ea, Xcfilter = interface.address.inside(ea), {idaapi.get_item_end(ea)}
        F, (Xci, Xdi) = cls.feature(ea), (interface.xiterate(ea, ffirst, fnext) for ffirst, fnext in [(idaapi.get_first_cref_from, idaapi.get_next_cref_from), (idaapi.get_first_dref_from, idaapi.get_next_dref_from)])
        Xc, Xd = ([item for item in X] for X in [(item for item in Xci if item not in Xcfilter), Xdi])
        return database.type.is_code(ea) and all([not any([F & idaapi.CF_CALL, F & idaapi.CF_SHFT]), any([F & idaapi.CF_JUMP, Xc])])
    branch = isbranch = branchQ = utils.alias(is_branch, 'type')

    @utils.multicase()
    @classmethod
    def is_jmp(cls):
        '''Returns true if the current instruction is an immediate and indirect branch.'''
        return cls.is_jmp(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_jmp(cls, ea):
        '''Returns true if the instruction at `ea` is an immediate and indirect branch.'''
        ea = interface.address.inside(ea)
        return cls.is_branch(ea) and all([cls.feature(ea, idaapi.CF_STOP)])
    jmp = isjmp = jmpQ = utils.alias(is_jmp, 'type')

    @utils.multicase()
    @classmethod
    def is_jxx(cls):
        '''Returns true if the current instruction is a conditional branch.'''
        return cls.is_jxx(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_jxx(cls, ea):
        '''Returns true if the instruction at `ea` is a conditional branch.'''
        ea = interface.address.inside(ea)
        return cls.is_branch(ea) and not all([cls.feature(ea, idaapi.CF_STOP)])
    jxx = isjxx = jxxQ = utils.alias(is_jxx, 'type')

    @utils.multicase()
    @classmethod
    def is_jmpi(cls):
        '''Returns true if the instruction at the current address is an indirect branch.'''
        return cls.is_jmpi(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_jmpi(cls, ea):
        '''Returns true if the instruction at `ea` is an indirect branch.'''
        ea = interface.address.inside(ea)
        return cls.is_branch(ea) and all([cls.feature(ea, idaapi.CF_JUMP)])
    jmpi = isjmpi = jmpiQ = utils.alias(is_jmpi, 'type')

    @utils.multicase()
    @classmethod
    def is_call(cls):
        '''Returns true if the current instruction is a call.'''
        return cls.is_call(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_call(cls, ea):
        '''Returns true if the instruction at `ea` is a call.'''
        ea = interface.address.inside(ea)
        if idaapi.__version__ < 7.0 and hasattr(idaapi, 'is_call_insn'):
            idaapi.decode_insn(ea)
            return idaapi.is_call_insn(ea)
        return database.type.is_code(ea) and all([cls.feature(ea, idaapi.CF_CALL)])
    call = iscall = callQ = utils.alias(is_call, 'type')

    @utils.multicase()
    @classmethod
    def is_calli(cls):
        '''Return true if the current instruction is an indirect call.'''
        return cls.is_calli(ui.current.address())
    @utils.multicase(ea=six.integer_types)
    @classmethod
    def is_calli(cls, ea):
        '''Returns true if the instruction at `ea` is an indirect call.'''
        ea = interface.address.inside(ea)
        F = cls.feature(ea)
        return database.type.is_code(ea) and all([F & idaapi.CF_CALL, F & idaapi.CF_JUMP])
    calli = iscalli = calliQ = utils.alias(is_calli, 'type')

t = type    # XXX: ns alias

feature = utils.alias(type.feature, 'type')
is_return = returnQ = retQ = utils.alias(type.is_return, 'type')
is_shift = shiftQ = utils.alias(type.is_shift, 'type')
is_branch = branchQ = utils.alias(type.is_branch, 'type')
is_jmp = jmpQ = utils.alias(type.is_jmp, 'type')
is_jxx = jxxQ = utils.alias(type.is_jxx, 'type')
is_jmpi = jmpiQ = utils.alias(type.is_jmpi, 'type')
is_call = callQ = utils.alias(type.is_call, 'type')
is_calli = calliQ = utils.alias(type.is_calli, 'type')

## operand type registration
## XXX: This namespace is deleted after each method has been assigned to their lookup table
class operand_types:
    """
    This internal namespace is responsible for registering the operand
    type handlers for each architecture inside ``__optype__`` and is
    deleted after they are registered.
    """
    @__optype__.define(idaapi.PLFM_386, idaapi.o_void)
    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_void)
    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_void)
    def void(insn, op):
        '''Operand type decoder for ``idaapi.o_void``.'''
        return ()

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_reg, int)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_reg, int)
    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_reg, int)
    def register(insn, op):
        '''Operand type decoder for ``idaapi.o_reg`` which returns a ``register_t``.'''
        get_dtype_attribute = operator.attrgetter('dtyp' if idaapi.__version__ < 7.0 else 'dtype')

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # On PLFM_ARM, op.specflag1 specifies the SIMD vector element size (0=scalar, 1=8 bits, 2=16 bits, 3=32 bits, 4=64 bits, 5=128 bits)
        # On PLFM_ARM, op.specflag3 specifies the SIMD scalar index + 1 (Vn.H[i])
        # On PLFM_ARM, if the APSR register is specified, then op.specflag1 contains flags (1=APSR_nzcv, 2=APSR_q, 4=APSR_g)
        # On PLFM_ARM, if the SPSR/CPSR register is specified, then op.specflag1 contains flags (1=CPSR_c, 2=CPSR_x, 4=CPSR_s, 8=CPSR_f)
        # On PLFM_ARM, if a banked register is specified, then op.specflag1 has its high bit (0x80) set

        global architecture
        return architecture.by_indextype(op.reg, get_dtype_attribute(op))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_imm, int)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_imm, int)
    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_imm, int)
    def immediate(insn, op):
        '''Operand type decoder for ``idaapi.o_imm`` which returns an immediate integer.'''
        get_dtype_attribute = operator.attrgetter('dtyp' if idaapi.__version__ < 7.0 else 'dtype')
        get_dtype_size = idaapi.get_dtyp_size if idaapi.__version__ < 7.0 else idaapi.get_dtype_size

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # On PLFM_ARM, op.specflag2 specifies a shift type
        # On PLFM_ARM, op.specval specifies a shift counter

        bits = 8 * get_dtype_size(get_dtype_attribute(op))

        # Figure out the maximum operand size using the operand's type,
        # and convert the value that was returned by IDAPython into its
        # signed format so that we can figure out what to return.
        maximum, value = pow(2, bits), op.value
        res = idaapi.as_signed(value, bits)

        # Immediates appear to be handled differently from phrases, so if
        # our operand is in regular form, then we always return it unsigned
        # by masking it within the maximum operand value. If the operand is
        # inverted, then we take the signed variation if it's less than 0.
        # If it isn't, then we take the difference form the maximum in
        # order to ensure it's signed.
        regular = value & (maximum - 1)
        inverted = res if res < 0 else value - maximum
        return res and inverted if interface.node.alt_opinverted(insn.ea, op.n) else regular

    @__optype__.define(idaapi.PLFM_386, idaapi.o_far, builtins.type)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_near, builtins.type)
    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_mem, builtins.type)
    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_near, builtins.type)
    def address(insn, op):
        '''Operand type decoder for address operands which return just an immediate address.'''
        segrg, segsel = (op.specval & 0xffff0000) >> 16, (op.specval & 0x0000ffff) >> 0
        return op.addr

    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec0, int)
    def trregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec0`` which returns a trap register on the Intel architecture.'''
        global architecture
        raise E.UnsupportedCapability(u"{:s}.trregister({:#x}, ...) : Trap registers (`%trX`) are not implemented for the Intel platform.".format('.'.join([__name__, 'operand_types']), insn.ea))
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec1, int)
    def dbregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec1`` which returns a Db register on the Intel architecture.'''
        global architecture
        raise E.UnsupportedCapability(u"{:s}.dbregister({:#x}, ...) : Db registers (`%dbX`) are not implemented for the Intel platform.".format('.'.join([__name__, 'operand_types']), insn.ea))
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec2, int)
    def crregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec2`` which returns a control register on the Intel architecture.'''
        global architecture
        regnum = op.reg
        return architecture.by_control(regnum)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec3, float)
    def fpregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec3`` which returns an FPU register on the Intel architecture.'''
        global architecture
        regnum = op.reg
        return architecture.by_float(regnum)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec4, int)
    def mmxregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec4`` which returns an MMX register on the Intel architecture.'''
        global architecture
        regnum = op.reg
        return architecture.by_mmx(regnum)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec5, float)
    def xmmregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec5`` which returns an XMM register on the Intel architecture.'''
        global architecture
        regnum = op.reg
        return architecture.by_xmm(regnum)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec5+1, float)
    def ymmregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec5+1`` which returns an YMM register on the Intel architecture.'''
        global architecture
        regnum = op.reg
        return architecture.by_ymm(regnum)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_idpspec5+2, float)
    def zmmregister(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec5+2`` which returns an ZMM register on the Intel architecture.'''
        raise E.UnsupportedCapability(u"{:s}.zmmregister({:#x}, ...) : ZMM registers (`%zmmX`) are not implemented for the Intel platform.".format('.'.join([__name__, 'operand_types']), insn.ea))

        global architecture
        regnum = op.reg
        return architecture.by_zmm(regnum)

    @__optype__.define(idaapi.PLFM_386, idaapi.o_mem, builtins.type)
    def memory(insn, op):
        '''Operand type decoder for returning a memory address including a segment on the Intel architecture.'''
        global architecture
        REX_B, REX_X, REX_R, REX_W, VEX_L, SEGREG_IMM = 1, 2, 4, 8, 0x80, 0xffff
        INDEX_NONE, aux_use32, aux_use64, aux_natad = 0x4, 0x8, 0x10, 0x1000

        # First we'll extract the necessary attributes from the operand and its instruction.
        hasSIB, sib, insnpref = op.specflag1, op.specflag2, insn.insnpref
        auxpref, segrg, segsel = insn.auxpref, (op.specval & 0xffff0000) >> 16, (op.specval & 0x0000ffff) >> 0
        bits = 64 if auxpref & aux_use64 else 32 if auxpref & aux_use32 else 16
        rex, = bytearray(insnpref) if isinstance(insnpref, bytes) else [insnpref]

        # FIXME: verify that support for 16-bit addressing actually works if we're 32-bit
        #        and the prefix has been toggled.

        # If there's no SIB, then all we need to do is to clamp our operand address
        # using the number of bits for the instruction's segment type.
        if not hasSIB:
            maximum = pow(2, bits)
            address = op.addr & (maximum - 1)

            # We've figured out all that we've needed, so just determine whether
            # we're using a segment register or a selector and return it.
            sel = segsel if segrg == SEGREG_IMM else architecture.by_index(segrg)
            return intelops.SegmentOffset(sel, address)

        # Otherwise we have to figure out the specifics about the operand type. The
        # base register doesn't actually exist in o_mem types, so we label it as unknown.
        unknown, index = (sib & 0x07) >> 0, (sib & 0x38) >> 3

        # If the index register is INDEX_NONE, then there there's nothing here and we'll
        # eventually be returning a SegmentOffset. We still process our unknown index though
        # so that it follows rules for o_phrase.
        if index in {INDEX_NONE}:
            index = None
            unknown |= 8 if rex & REX_B else 0

        # Otherwise, we're good and all we need to do is to add the 64-bit
        # flag to the index registers if it's relevant.
        else:
            index |= 8 if rex & REX_X else 0
            unknown |= 8 if rex & REX_B else 0

        # Now we need to figure out what the displacement actually is for the operand.
        offset = op.addr
        dtype_by_size = utils.fcompose(idaapi.get_dtyp_by_size, six.byte2int) if idaapi.__version__ < 7.0 else idaapi.get_dtype_by_size
        maximum, dtype = pow(2, bits), dtype_by_size(bits // 8)
        res = idaapi.as_signed(offset, bits)

        # We do this using the exact same methodology implemented by o_phrase and o_displ.
        regular = res if res < 0 else offset & (maximum - 1)
        inverted = offset & (maximum - 1) if res < 0 else offset - maximum

        # Figure out the selector and the offset. If our index is None, then we don't
        # need to return a phrase and can return the segment and its offset.
        sel = segsel if segrg == SEGREG_IMM else architecture.by_index(segrg)
        offset_ = res and inverted if interface.node.alt_opinverted(insn.ea, op.n) else regular
        if index is None:
            return intelops.SegmentOffset(sel, offset_)

        # Otherwise we calculate the index register and scale and return our tuple.
        index_ = architecture.by_indextype(index, dtype)
        scale_ = [1, 2, 4, 8][(sib & 0xc0) // 0x40]
        return intelops.SegmentOffsetBaseIndexScale(sel, offset_, None, index_, scale_)

    @__optype__.define(idaapi.PLFM_386, idaapi.o_displ, builtins.type)
    @__optype__.define(idaapi.PLFM_386, idaapi.o_phrase, builtins.type)
    def phrase(insn, op):
        '''Operand type decoder for returning a phrase or displacement on the Intel architecture.'''
        global architecture
        REX_B, REX_X, REX_R, REX_W, VEX_L, SEGREG_IMM = 1, 2, 4, 8, 0x80, 0xffff
        INDEX_NONE, aux_use32, aux_use64, aux_natad = 0x4, 0x8, 0x10, 0x1000

        # First we'll extract the necessary attributes from the operand and its instruction.
        hasSIB, sib, insnpref = op.specflag1, op.specflag2, insn.insnpref
        auxpref, segrg, segsel = insn.auxpref, (op.specval & 0xffff0000) >> 16, (op.specval & 0x0000ffff) >> 0
        bits = 64 if auxpref & aux_use64 else 32 if auxpref & aux_use32 else 16
        rex, = bytearray(insnpref) if isinstance(insnpref, bytes) else [insnpref]

        # Now we can figure out the operand's specifics.
        if hasSIB:
            base = (sib & 0x07) >> 0
            index = (sib & 0x38) >> 3

            # If the index register is INDEX_NONE, then there isn't an index
            # register and we need to clear it. The base register might still
            # need to be promoted however, so we check it.
            if index in {INDEX_NONE}:
                base |= 8 if rex & REX_B else 0
                index = None

            # Otherwise, we're good and all we need to do is to add the 64-bit
            # flag to the base and index registers if it's relevant.
            else:
                base |= 8 if rex & REX_B else 0
                index |= 8 if rex & REX_X else 0

                # FIXME: we need to check insn.itype to support the VSIB variant of
                #        SIB which requires we promote the index to xmm, ymm, or zmm.

        # If this is a 16-bit addressing scheme, then we need to explicitly
        # figure out what phrase type is being used.
        elif not (auxpref & (aux_use32 | aux_use64)):

            # FIXME: Test this thing out whenever a user complains about it.
            R_bx, R_bp, R_si, R_di, R_sp = (architecture.by_index(name).id for name in ['bx', 'bp', 'si', 'di', 'sp'])
            phrase_table = {
                0: (R_bx, R_si), 1: (R_bx, R_di), 2: (R_bx, None),
                2: (R_bp, R_si), 3: (R_bp, R_di), 6: (R_bp, None),
                4: (R_si, None), 5: (R_di, None),-1: (R_sp, None),
            }
            base, index = phrase_table[op.phrase]
            logging.warning(u"{:s}.phrase({:#x}, {!r}) : {:d}-bit phrases are implemented but untested. If the registers in the phrase (`{:s}`) does not match the operand, please open a new issue.".format('.'.join([__name__, 'operand_types']), insn.ea, op, 16, "[{:s}]".format(architecture.by_index(base).name) if index is None else "[{:s}+{:s}]".format(architecture.by_index(base).name, architecture.by_index(index).name)))

        # If there isn't an SIB, then the base register is in op_t.phrase.
        else:
            base = op.phrase
            index = None

        # Figure out which property contains our offset depending on the type.
        if op.type in {idaapi.o_displ, idaapi.o_mem}:
            offset = op.addr
        elif op.type in {idaapi.o_phrase}:
            offset = op.value
        else:
            raise E.InvalidTypeOrValueError(u"{:s}.phrase({:#x}, {!r}) : Unable to determine the offset for op.type ({:d}).".format('.'.join([__name__, 'operand_types']), insn.ea, op, op.type))

        # Figure out the maximum value for the offset part of the phrase from
        # the number of bits for the instruction's segment type in order to
        # clamp it. Then, we can convert the value that we get from IDAPython
        # into both its signed and unsigned form. This way we can calculate the
        # correct value for whatever variation we need to actually return.
        dtype_by_size = utils.fcompose(idaapi.get_dtyp_by_size, six.byte2int) if idaapi.__version__ < 7.0 else idaapi.get_dtype_by_size
        maximum, dtype = pow(2, bits), dtype_by_size(bits // 8)
        res = idaapi.as_signed(offset, bits)

        # If our operand is defined as its regular form, then we either
        # clamp it or take its signed value. This is because IDA appears to
        # treat all SIB-encoded operands as a signed value. Likewise, if the
        # operand is inverted, then we essentially swap these values.
        regular = res if res < 0 else offset & (maximum - 1)
        inverted = offset & (maximum - 1) if res < 0 else offset - maximum

        # Finally we can calculate all of the components for the operand, and
        # then return them to the user.
        sel = segsel if segrg == SEGREG_IMM else architecture.by_index(segrg)
        offset_ = res and inverted if interface.node.alt_opinverted(insn.ea, op.n) else regular
        base_ = None if base is None else architecture.by_indextype(base, dtype)
        index_ = None if index is None else architecture.by_indextype(index, dtype)
        scale_ = [1, 2, 4, 8][(sib & 0xc0) // 0x40]
        return intelops.SegmentOffsetBaseIndexScale(sel, offset_, base_, index_, scale_)

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_phrase, builtins.type)
    def phrase(insn, op):
        '''Operand type decoder for returning a memory phrase on either the AArch32 or AArch64 architectures.'''
        global architecture

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # op.specflag3 specifies the NEON alignment by power-of-two

        Rn, Rm = architecture.by_index(op.reg), architecture.by_index(op.specflag1)
        return armops.registerphrase(Rn, Rm)

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_displ, builtins.type)
    def phrase(insn, op):
        '''Operand type decoder for returning a memory displacement on either the AArch32 or AArch64 architectures.'''
        global architecture
        Rn = architecture.by_index(op.reg)
        return armops.immediatephrase(Rn, idaapi.as_signed(op.addr))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_mem, builtins.type)
    def memory(insn, op):
        '''Operand type decoder for returning a memory reference on either the AArch32 or AArch64 architectures.'''
        get_dtype_attribute = operator.attrgetter('dtyp' if idaapi.__version__ < 7.0 else 'dtype')
        get_dtype_size = idaapi.get_dtyp_size if idaapi.__version__ < 7.0 else idaapi.get_dtype_size
        get_bytes = idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes

        # get the address and the operand size
        addr, size = op.addr, get_dtype_size(get_dtype_attribute(op))
        maxval = 1 << size * 8

        # dereference the address and return its integer.
        res = get_bytes(addr, size) or b''
        res = res[::-1] if database.config.byteorder() in {'little'} else res[:]
        res = functools.reduce(lambda agg, item: (agg * 0x100) | item, bytearray(res), 0)
        sf = bool(res & maxval >> 1)

        return armops.memory(addr, res - maxval if sf else res)

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec0, int)
    def flex(insn, op):
        '''Operand type decoder for returning a flexible operand (shift-op) on either the AArch32 or AArch64 architectures.'''
        global architecture

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # op.specflag2 = shift-type
        # op.specflag1 = shift register to use
        # op.value = shift count

        Rn = architecture.by_index(op.reg)
        shift = 0                                           # XXX: This should be implemented using the above information
        return armops.flex(Rn, int(shift), int(op.value))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec1)
    def list(insn, op):
        '''Operand type decoder for returning a register list on either the AArch32 or AArch64 architectures.'''
        global architecture
        res = set()

        # FIXME: op.specflag1 specifies the PSR and force-user bit, which has the ^ suffix

        # op.specval represents a bitmask specifying which registers are included
        specval = op.specval
        for index in range(16):
            if specval & 1:
                res.add(architecture.by_index(index))
            specval >>= 1
        return armops.list(res)

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec2)
    def coprocessorlist(insn, op):
        '''Operand type decoder for the coprocessor register list (CDP) on either the AArch32 or AArch64 architectures.'''

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # op.reg == CRd
        # op.specflag1 == CRn
        # op.specflag2 == CRm

        raise E.UnsupportedCapability(u"{:s}.coprocessorlist({:#x}, {:d}) : An undocumented operand type ({:d}) was found at the specified address.".format('.'.join([__name__, 'operand_types']), insn.ea, op.type, op.type))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec3)
    def coprocessorlist(insn, op):
        '''Operand type decoder for the coprocessor register list (LDC/STC) on either the AArch32 or AArch64 architectures.'''

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # op.reg == register number
        # op.specflag1 == processor number

        raise E.UnsupportedCapability(u"{:s}.coprocessorlist({:#x}, {:d}) : An undocumented operand type ({:d}) was found at the specified address.".format('.'.join([__name__, 'operand_types']), insn.ea, op.type, op.type))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec4, float)
    def extensionlist(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec4`` which returns a floating-point register list on either the AArch32 or AArch64 architectures.'''

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # op.reg == first floating-point register
        # op.value == number of floating-point registers
        # op.specflag2 == spacing between registers (0: {Dd, Dd+1,... }, 1: {Dd, Dd+2, ...} etc)
        # op.specflag3 == neon scalar index + 1 (Dd[x]). if index is 254, then this represents the entire set (Dd[...])

        raise E.UnsupportedCapability(u"{:s}.extensionlist({:#x}, {:d}) : An undocumented operand type ({:d}) was found at the specified address.".format('.'.join([__name__, 'operand_types']), insn.ea, op.type, op.type))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec5, builtins.type)
    def text(insn, op):
        '''Operand type decoder for ``idaapi.o_idpspec5`` which returns arbitrary text on either the AArch32 or AArch64 architectures.'''

        # FIXME: This information was found in the sdk by @BrunoPujos.
        # The entire op_t structure contains the designated text starting at op.value

        raise E.UnsupportedCapability(u"{:s}.text({:#x}, {:d}) : An undocumented operand type ({:d}) was found at the specified address.".format('.'.join([__name__, 'operand_types']), insn.ea, op.type, op.type))

    @__optype__.define(idaapi.PLFM_ARM, idaapi.o_idpspec5 + 1)
    def condition(insn, op):
        '''Operand type decoder for dealing with an undocumented operand type found on AArch64.'''
        global architecture

        # FIXME: There's a couple of attributes here that seem relevant: op.value, op.reg, op.n
        # op.value == condition
        cc = op.value & 0x0f
        return architecture.by_condition(cc)

    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_displ, builtins.type)
    def phrase(insn, op):
        '''Operand type decoder for memory phrases on MIPS architecturs.'''
        global architecture

        rt, imm = architecture.by_index(op.reg), op.addr
        return mipsops.phrase(rt, imm)

    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_idpspec0, int)
    def code(insn, op):
        '''Operand type decoder for trap codes on MIPS architectures.'''
        res = op.value
        return mipsops.trap(int(res))

    @__optype__.define(idaapi.PLFM_MIPS, idaapi.o_idpspec1, float)
    def float(insn, op):
        '''Operand type decoder for floating-point registers on MIPS architectures.'''
        index = op.reg
        return mipsops.float(index)
del(operand_types)

## intel operands
class intelops:
    """
    This internal namespace contains the different operand types that
    can be returned for the Intel architecture.
    """
    class SegmentOffset(interface.phrase_t):
        """
        A tuple representing an address with a segment register attached on the Intel architecture.

        Has the format `(segment, offset)` where `segment` is a segment register.
        """
        _fields = ('segment', 'offset')
        _types = (
            (None.__class__, interface.register_t, six.integer_types),
            six.integer_types,
        )

        @property
        def symbols(self):
            '''Yield the `segment` register from the tuple if it is defined.'''
            segment, _ = self
            if segment:
                yield segment
            return

        def __int__(self):
            _, offset = self
            return offset

        def __same__(self, other):
            segment, _ = self
            osegment, _ = other
            return any([segment is None, osegment is None, segment == osegment])

    class SegmentOffsetBaseIndexScale(interface.integerish, interface.symbol_t):
        """
        A tuple representing a memory phrase operand on the Intel architecture.

        Has the format `(segment, offset, base, index, scale)` where `segment`
        includes the segment register and both the `base` and `index` registers
        are both optional.
        """
        _fields = ('segment', 'offset', 'base', 'index', 'scale')
        _types = (
            (None.__class__, interface.register_t, six.integer_types),
            six.integer_types,
            (None.__class__, interface.register_t),
            (None.__class__, interface.register_t),
            six.integer_types,
        )
        _operands = (internal.utils.fconstant, internal.utils.fcurry, internal.utils.fconstant, internal.utils.fconstant, internal.utils.fconstant)
        _formats = "{!s}".format, "{:#x}".format, "{!s}".format, "{!s}".format, "{!s}".format

        @property
        def symbols(self):
            '''Yield the `segment`, `base`, and the `index` registers from the tuple if they are defined.'''
            segment, _, base, index, _ = self
            if segment:
                yield segment
            if base:
                yield base
            if index:
                yield index
            return

        def __int__(self):
            _, offset, _, _, _ = self
            return offset

        def __same__(self, other):
            segment, _, base, index, scale = self
            osegment, _, obase, oindex, oscale = other
            return all(any([this == that, this is None, that is None]) for this, that in [(segment, osegment), (base, obase), (index, oindex)])

        def __repr__(self):
            cls, fields = self.__class__, {'offset'}
            res = ("{!s}={:s}".format(internal.utils.string.escape(name, ''), ("{:#x}" if name in fields else "{!s}").format(value)) for name, value in zip(self._fields, self))
            return "{:s}({:s})".format(cls.__name__, ', '.join(res))

    class OffsetBaseIndexScale(interface.integerish, interface.symbol_t):
        """
        A tuple representing a memory phrase for the Intel architecture.

        Has the format `(offset, base, index, scale)` where both
        `base` and `index` are both optional registers.
        """
        _fields = ('offset', 'base', 'index', 'scale')
        _types = (
            six.integer_types,
            (None.__class__, interface.register_t),
            (None.__class__, interface.register_t),
            six.integer_types,
        )
        _formats = "{:#x}".format, "{!s}".format, "{!s}".format, "{!s}".format

        @property
        def symbols(self):
            '''Yield the `base`, and the `index` registers from the tuple if they are defined.'''
            _, base, index, _ = self
            if base:
                yield base
            if index:
                yield index
            return

        def __int__(self):
            offset, _, _, _ = self
            return offset

        def __same__(self, other):
            _, base, index, scale = self
            _, obase, oindex, oscale = other
            return all(any([this == that, this is None, that is None]) for this, that in [(base, obase), (index, oindex), (scale, oscale)])

## arm operands
class armops:
    """
    This internal namespace contains the different operand types that
    can be returned for the AArch32 and AArch64 architectures.
    """

    class flex(interface.namedtypedtuple, interface.symbol_t):
        """
        A tuple representing a flexible operand type that can be decoded on either the AArch32 or AArch64 architectures.

        Has the format `(Rn, shift, n)` which allows the architecture to apply
        a binary shift or rotation to the value of a register `Rn`.
        """
        _fields = ('Rn', 'shift', 'n')
        _types = (
            interface.register_t,
            six.integer_types,
            six.integer_types
        )

        register = property(fget=operator.itemgetter(0))
        t = type = property(fget=operator.itemgetter(1))
        imm = immediate = property(fget=operator.itemgetter(2))

        @property
        def symbols(self):
            '''Yield the `Rn` register from the tuple.'''
            register, _, _ = self
            yield register

    class list(interface.namedtypedtuple, interface.symbol_t):
        """
        A tuple representing a register list operand on either the AArch32 or AArch64 architectures.

        Has the simple format `(reglist)` where `reglist` is a set of registers
        that can be explicitly tested as a set for membership.
        """
        _fields = ('reglist', )
        _types = (set, )

        @property
        def symbols(self):
            '''Yield any of the registers within the `reglist` field belonging to the tuple.'''
            list, = self
            for regster in list:
                yield register
            return

    class immediatephrase(interface.phrase_t):
        """
        A tuple representing a memory displacement operand on either the AArch32 or AArch64 architectures.

        Has the format `(Rn, Offset)` where `Rn` is a register and `Offset` is
        the integer that is added to the register.
        """
        _fields = ('Rn', 'offset')

        register = property(fget=operator.itemgetter(0))
        offset = property(fget=operator.itemgetter(1))

    class registerphrase(interface.namedtypedtuple, interface.symbol_t):
        """
        A tuple for representing a memory phrase on either the AArch32 or AArch64 architectures.

        Has the format `(Rn, Rm)` where both values are registers that compose
        the phrase.
        """
        _fields = ('Rn', 'Rm')
        _types = (
            interface.register_t,
            interface.register_t,
        )

        first = property(fget=operator.itemgetter(0))
        second = property(fget=operator.itemgetter(1))

        @property
        def symbols(self):
            '''Yield the `Rn` and `Rm` registers from the tuple.'''
            register_n, register_m = self
            yield register_n
            yield register_m

    class memory(interface.namedtypedtuple, interface.symbol_t):
        """
        A tuple for representing a memory operand on either the AArch32 or AArch64 architectures.

        Has the format `(address, value)` where `address` is the actual value
        stored in the operand and `value` is the value that would be dereferenced.
        """
        _fields = ('address', 'value')
        _types = (six.integer_types, six.integer_types)
        _formats = "{:#x}".format, "{:#x}".format

        @property
        def symbols(self):
            '''This operand type is not composed of any symbols.'''
            raise StopIteration
            yield   # so that this function is still treated as a generator

        # we need to write some really stupid code here...like seriously dumb.
        # since we're not storing any operand information other than the address
        # and its dereferenced value, we have no idea of the length of the
        # deref'd operand or if it's signed...so, we actually have to guess it.

        @classmethod
        def __consume_integer(cls, ea):
            get_bytes = idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes

            # depending on the byteorder, we shift either the aggregate or the multiplier.
            shifts = [1, 0x100] if database.config.byteorder() in {'little'} else [0x100, 1]
            Fs = [functools.partial(operator.mul, item) for item in shifts]

            # we need extra vars here, because of for-loops and not having pre or post.
            result, shift, position = 0, 1, 0
            for size in map(functools.partial(operator.pow, 2), builtins.range(4)):
                for item in bytearray(get_bytes(ea + position, size - position) or b''):
                    res = item * shift
                    result, shift = (F(item) for F, item in zip(Fs, [result, shift]))
                    result |= res
                yield size, result
                position = size
            return

        @classmethod
        def __guess_size(cls, address, goal):
            '''Return the number of bytes to read at the specified `address` in order to return the specified value.'''
            for size, integer in cls.__consume_integer(address):
                result = {integer : +size, integer - pow(2, 8 * size) : -size}
                if goal in result:
                    return result[goal]
                continue
            return 0

        def __remake(self, address):
            '''Use the guessed size of the current instance to create another one pointing to a different address.'''
            cls, get_bytes = self.__class__, idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes

            # Re-read the old address and figure out what our size could be. If we
            # figure it out, then we read from the new address and reconstruct.
            size = self.__guess_size(*self)
            res, maximum = get_bytes(address, abs(size)) or b'', pow(2, 8 * size)

            # Handle the byteorder and reduce it to an integer before we signify it.
            res = res[::-1] if database.config.byteorder() in {'little'} else res[:]
            res = functools.reduce(lambda agg, item: (agg * 0x100) | item, bytearray(res), 0)

            # Now we "calculate" the sign flag if our previous value allowed us to
            # sign it, and then we can use it to reconstruct this thing.
            SF = maximum // 2 if size < 0 else 0
            return cls(address, res - maximum if res & SF else res)

        def __int__(self):
            result, _ = self
            return result

        def __operator__(self, operation, other):
            address, _ = self
            if isinstance(other, six.integer_types):
                return self.__remake(operation(address, other))
            elif isinstance(other, self.__class__):
                return self.__operator__(operation, int(other))
            elif hasattr(other, '__int__'):
                logging.warning(u"{:s}.__operator__({!s}, {!r}) : Coercing the instance of type `{:s}` to an integer due to a dissimilarity with type `{:s}`.".format('.'.join([__name__, cls.__name__]), operation, other, other.__class__.__name__, self.__class__.__name__))
                return self.__operator__(operation, int(other))
            raise TypeError(u"{:s}.__operator__({!s}, {!r}) : Unable to perform {:s} operation with type `{:s}` due to a dissimilarity with type `{:s}`.".format('.'.join([__name__, cls.__name__]), operation, other, operation.__name__, other.__class__.__name__, cls.__name__))

        def __operation__(self, operation):
            return self.__remake(operation(int(self)))

        def __add__(self, other):
            return self.__operator__(operator.add, other)
        def __sub__(self, other):
            return self.__operator__(operator.sub, other)
        def __and__(self, other):
            return self.__operator__(operator.and_, other)
        def __or__(self, other):
            return self.__operator__(operator.or_, other)
        def __xor__(self, other):
            return self.__operator__(operator.xor_, other)

        __radd__ = __add__
        __rsub__ = __sub__
        __rand__ = __and__
        __ror__ = __or__
        __rxor__ = __xor__

    class condition_t(interface.symbol_t):
        """
        A symbol for representing a condition operand on either the AArch32 or AArch64 architectures.
        """
        __flags__ = {
            0x0 : {'Z': 1}, 0x1 : {'Z': 0},
            0x2 : {'C': 1}, 0x3 : {'C': 0},
            0x4 : {'N': 1}, 0x5 : {'N': 0},
            0x6 : {'V': 1}, 0x7 : {'V': 0},
        }

        # FIXME: define the required flag state needed to satisfy the specified condition.
        __cflags__ = {}

        def __init__(self, index):
            cc = {
                0x0 : 'EQ', 0x1 : 'NE', 0x2 : 'CS', 0x3 : 'CC',
                0x4 : 'MI', 0x5 : 'PL', 0x6 : 'VS', 0x7 : 'VC',
                0x8 : 'HI', 0x9 : 'LS', 0xa : 'GE', 0xb : 'LT',
                0xc : 'GT', 0xd : 'LE', 0xe : 'AL', 0xf : 'NV',
            }
            self.__cond__, self.__name__ = index, cc[index]

        def __hash__(self):
            items = armops.condition_t, self.__cond__
            return hash(items)

        @property
        def flags(self):
            '''Return the required flags for the current condition to be true.'''
            cc, flags = self.__cond__, self.__flags__
            if cc < 8:
                flag, value = next(item for item in flags[cc].items())
                return [(flag, True if value else False)]
            raise NotImplementedError("{:s}.condition_t({:#x}) : Unable to return the flags needed to satisfy condition ({:s}) due to its code ({:d} being unimplemented.".format(__name__, cc, self.name, cc))

        @property
        def symbols(self):
            '''A condition_t is actually a symbol that yields itself.'''
            yield self

        @property
        def name(self):
            return self.__name__

        def __str__(self):
            return self.__name__

        def __repr__(self):
            cls, cc = armops.condition_t, self.__cond__
            if cc < 8:
                description = ','.join("{:s}={:d}".format(*item) for item in self.flags)
                return "<class '{:s}' name='{!s}' flags='{:s}'>".format(cls.__name__, internal.utils.string.escape(self.name, '\''), description)
            return "<class '{:s}' name='{!s}'>".format(cls.__name__, internal.utils.string.escape(self.name, '\''))

        def __eq__(self, other):
            if isinstance(other, six.string_types):
                return self.name.lower() == other.lower()
            elif isinstance(other, armops.condition_t):
                return self.__cond__ == other.__cond__
            return other is self

        def __ne__(self, other):
            return not (self == other)

## mips operands
class mipsops:
    """
    This internal namespace contains the different operand types that
    are used by the MIPS architectures.
    """

    class phrase(interface.phrase_t):
        """
        A tuple for representing a memory phrase operand on the MIPS architectures.

        Has the format `(Rn, Offset)` where `Rn` is the register and
        `Offset` is the immediate that is added to the `Rn` register.
        """
        _fields = ('Rn', 'Offset')
        _types = (interface.register_t, six.integer_types)
        _operands = (internal.utils.fconstant, internal.utils.fcurry)
        _formats = "{!s}".format, "{:#x}".format

        register = property(fget=operator.itemgetter(0))
        immediate = property(fget=operator.itemgetter(1))

    class trap(interface.namedtypedtuple, interface.symbol_t):
        """
        A tuple for representing a trap code that can be encoded within
        certain instructions on the MIPS architectures.

        Simply wraps the encoded integer in a single-element tuple with
        the format of `(code)`.
        """
        _fields = ('code',)
        _types = (six.integer_types,)

        code = property(fget=operator.itemgetter(0))

        @property
        def symbols(self):
            '''This operand type is not composed of any symbols.'''
            raise StopIteration
            yield   # so that this function is still treated as a generator

    @staticmethod
    def coprocessor(index):
        """
        A callable that returns a coprocessor register on the MIPS architectures.

        Takes an integer argument which returns the coprocessor register for
        the requested `index`.
        """
        global architecture
        return architecture.by_coprocessor(index)

    @staticmethod
    def float(index):
        """
        A callable that returns a floating-point register on the MIPS architectures.

        Takes an integer representing the `index` of the desired floating-point
        register to return.
        """
        global architecture
        return architecture.by_float(index)

## architecture registers
class Intel(interface.architecture_t):
    """
    An implementation of all the registers available on the Intel architecture.

    This keeps track of the relationships between registers to allow one to
    promote or demote a register to the different sizes that are available.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is Intel.
    """
    prefix = '%'
    def __init__(self):
        super(Intel, self).__init__()
        getitem, setitem = self.__register__.__getattr__, self.__register__.__setattr__
        i2s = "{:d}".format

        [ setitem('r'+_, self.new('r'+_, 64, _)) for _ in ('ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'ip') ]
        [ setitem('r'+_, self.new('r'+_, 64)) for _ in map(i2s, range(8, 16)) ]
        [ setitem('e'+_, self.child(self.by_name('r'+_), 'e'+_, 0, 32, _)) for _ in ('ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'ip') ]
        [ setitem('r'+_+'d', self.child(self.by_name('r'+_), 'r'+_+'d', 0, 32, idaname='r'+_)) for _ in map(i2s, range(8, 16)) ]
        [ setitem('r'+_+'w', self.child(self.by_name('r'+_+'d'), 'r'+_+'w', 0, 16, idaname='r'+_)) for _ in map(i2s, range(8, 16)) ]
        [ setitem('r'+_+'b', self.child(self.by_name('r'+_+'w'), 'r'+_+'b', 0, 8, idaname='r'+_)) for _ in map(i2s, range(8, 16)) ]
        [ setitem(    _, self.child(self.by_name('e'+_), _, 0, 16)) for _ in ('ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'ip') ]
        [ setitem(_+'h', self.child(self.by_name(_+'x'), _+'h', 8, 8)) for _ in ('a', 'c', 'd', 'b') ]
        [ setitem(_+'l', self.child(self.by_name(_+'x'), _+'l', 0, 8)) for _ in ('a', 'c', 'd', 'b') ]
        [ setitem(_+'l', self.child(self.by_name(_), _+'l', 0, 8)) for _ in ('sp', 'bp', 'si', 'di') ]
        [ setitem(    _, self.new(_, 16)) for _ in ('es', 'cs', 'ss', 'ds', 'fs', 'gs') ]

        # FIXME: rex-prefixed 32-bit registers are implicitly extended to the 64-bit regs which implies that 64-bit are children of 32-bit
        for _ in ['ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'ip']:
            r32, r64 = getitem('e'+_), getitem('r'+_)
            r32.alias, r64.alias = { r64 }, { r32 }
        for _ in map(i2s, range(8, 16)):
            r32, r64 = getitem('r'+_+'d'), getitem('r'+_)
            r32.alias, r64.alias = { r64 }, { r32 }

        # explicitly set the lookups for (word-register, idaapi.dt_byte) which exist due to ida's love for the inconsistent
        [ self.__cache__.setdefault((_+'x', self.by_name(_+'l').dtype), self.by_name(_+'l').__name__) for _ in ('a', 'c', 'd', 'b') ]

        setitem('fpstack', self.new('fpstack', 80*8, dtype=None))
        # single precision
        [ setitem("st{:d}f".format(_), self.child(self.by_name('fpstack'), "st{:d}f".format(_), _*80, 80, "st{:d}".format(_), dtype=idaapi.dt_float, ptype=float)) for _ in range(8) ]
        # double precision
        [ setitem("st{:d}d".format(_), self.child(self.by_name('fpstack'), "st{:d}d".format(_), _*80, 80, "st{:d}".format(_), dtype=idaapi.dt_double, ptype=float)) for _ in range(8) ]
        # umm..80-bit precision? i've seen op_t's in ida for fsubp with the implied st(0) using idaapi.dt_tbyte
        [ setitem("st{:d}".format(_), self.child(self.by_name('fpstack'), "st{:d}".format(_), _*80, 80, "st{:d}".format(_), dtype=idaapi.dt_tbyte, ptype=float)) for _ in range(8) ]

        # not sure if the mmx registers trash the other 16 bits of an fp register
        [ setitem("mm{:d}".format(_), self.child(self.by_name('fpstack'), "mm{:d}".format(_), _*80, 64, dtype=idaapi.dt_qword)) for _ in range(8) ]

        # sse1/sse2 simd registers
        [ setitem("zmm{:d}".format(_), self.new("zmm{:d}".format(_), 512, dtype=idaapi.dt_byte64, ptype=float)) for _ in range(32) ]
        [ setitem("ymm{:d}".format(_), self.child(self.by_name("zmm{:d}".format(_)), "ymm{:d}".format(_), 0, 256, dtype=idaapi.dt_byte32, ptype=float)) for _ in range(32) ]
        [ setitem("xmm{:d}".format(_), self.child(self.by_name("ymm{:d}".format(_)), "xmm{:d}".format(_), 0, 128, dtype=idaapi.dt_byte16, ptype=float)) for _ in range(32) ]

        # control registers (32-bit and 64-bit)
        [ setitem("cr{:d}".format(_), self.new("cr{:d}".format(_), database.config.bits())) for _ in range(0, 8) ]
        [ setitem("cr{:d}".format(_), self.new("cr{:d}".format(_), database.config.bits())) for _ in range(8, 16) ]

        # kr registers
        [ setitem("k{:d}".format(_), self.new("k{:d}".format(_), database.config.bits())) for _ in range(8) ]

        # flags
        setitem('rflags', self.new('rflags', 64))
        setitem('eflags', self.child(self.by_name('rflags'), 'eflags', 0, 32, idaname='efl'))
        setitem('cf', self.child(self.by_name('eflags'), 'cf',  0, 1))
        setitem('pf', self.child(self.by_name('eflags'), 'pf',  2, 1))
        setitem('af', self.child(self.by_name('eflags'), 'af',  4, 1))
        setitem('zf', self.child(self.by_name('eflags'), 'zf',  6, 1))
        setitem('sf', self.child(self.by_name('eflags'), 'sf',  7, 1))
        setitem('tf', self.child(self.by_name('eflags'), 'tf',  8, 1))
        setitem('if', self.child(self.by_name('eflags'), 'if',  9, 1))
        setitem('df', self.child(self.by_name('eflags'), 'df', 10, 1))
        setitem('of', self.child(self.by_name('eflags'), 'of', 11, 1))

        # fpstat (fpsr)
        setitem('fpsw', self.new('fpsw', 16, idaname='fpstat'))
        setitem('fpsw_ie',  self.child(self.by_name('fpsw'), 'fpsw.ie',  0,  1))    # invalid exception
        setitem('fpsw_de',  self.child(self.by_name('fpsw'), 'fpsw.de',  1,  1))    # denormalized exception
        setitem('fpsw_ze',  self.child(self.by_name('fpsw'), 'fpsw.ze',  2,  1))    # zero-divide exception
        setitem('fpsw_oe',  self.child(self.by_name('fpsw'), 'fpsw.oe',  3,  1))    # overflow exception
        setitem('fpsw_ue',  self.child(self.by_name('fpsw'), 'fpsw.ue',  4,  1))    # underflow exception
        setitem('fpsw_pe',  self.child(self.by_name('fpsw'), 'fpsw.pe',  5,  1))    # precision exception
        setitem('fpsw_sf',  self.child(self.by_name('fpsw'), 'fpsw.sf',  6,  1))    # stack fault
        setitem('fpsw_es',  self.child(self.by_name('fpsw'), 'fpsw.es',  7,  1))    # error status
        setitem('fpsw_c0',  self.child(self.by_name('fpsw'), 'fpsw.c0',  8,  1))    # cc 0
        setitem('fpsw_c1',  self.child(self.by_name('fpsw'), 'fpsw.c1',  9,  1))    # cc 1
        setitem('fpsw_c2',  self.child(self.by_name('fpsw'), 'fpsw.c2',  10, 1))    # cc 2
        setitem('fpsw_top', self.child(self.by_name('fpsw'), 'fpsw.top', 11, 3))    # top of register stack
        setitem('fpsw_c3',  self.child(self.by_name('fpsw'), 'fpsw.c3',  14, 1))    # cc 3
        setitem('fpsw_b',   self.child(self.by_name('fpsw'), 'fpsw.b',   15, 1))    # busy

        # fpstat aliases (because of hexrays)
        setitem('c0', self.by_name('fpsw.c0'))
        setitem('c1', self.by_name('fpsw.c1'))
        setitem('c2', self.by_name('fpsw.c2'))
        setitem('c3', self.by_name('fpsw.c3'))

        # fpctrl (fpcr)
        setitem('fpcr', self.new('fpcr', 16, idaname='fpctrl'))
        setitem('fpcr_im',  self.child(self.by_name('fpcr'), 'fpcr.im',  0,  1))    # invalid mask
        setitem('fpcr_dm',  self.child(self.by_name('fpcr'), 'fpcr.dm',  1,  1))    # denormal mask
        setitem('fpcr_zm',  self.child(self.by_name('fpcr'), 'fpcr.zm',  2,  1))    # zero-divide mask
        setitem('fpcr_om',  self.child(self.by_name('fpcr'), 'fpcr.om',  3,  1))    # overflow mask
        setitem('fpcr_um',  self.child(self.by_name('fpcr'), 'fpcr.um',  4,  1))    # underflow mask
        setitem('fpcr_pm',  self.child(self.by_name('fpcr'), 'fpcr.pm',  5,  1))    # precision mask
        setitem('fpcr_ext', self.child(self.by_name('fpcr'), 'fpcr.ext', 6,  2))
        setitem('fpcr_pc',  self.child(self.by_name('fpcr'), 'fpcr.pc',  8,  2))    # precision control
        setitem('fpcr_rc',  self.child(self.by_name('fpcr'), 'fpcr.rc',  10, 2))    # rounding control
        setitem('fpcr_ic',  self.child(self.by_name('fpcr'), 'fpcr.ic',  12, 1))    # infinity control

        # fptags (fptw)
        setitem('fptw', self.new('fptw', 16, idaname='fptags'))
        [ setitem("fptw.t{:d}".format(_), self.child(self.by_name('fptw'), "fptw.t{:d}".format(_), 2*_, 2)) for _ in range(8) ]

        #mxcsr
        setitem('mxcsr', self.new('mxcsr', 32, idaname='mxcsr'))
        setitem('mxcsr_ie',  self.child(self.by_name('fpcr'), 'mxcsr.ie',  0,  1))  # invalid exception
        setitem('mxcsr_de',  self.child(self.by_name('fpcr'), 'mxcsr.de',  1,  1))  # denormalized exception
        setitem('mxcsr_ze',  self.child(self.by_name('fpcr'), 'mxcsr.ze',  2,  1))  # zero-divide exception
        setitem('mxcsr_oe',  self.child(self.by_name('fpcr'), 'mxcsr.oe',  3,  1))  # overflow exception
        setitem('mxcsr_ue',  self.child(self.by_name('fpcr'), 'mxcsr.ue',  4,  1))  # underflow exception
        setitem('mxcsr_pe',  self.child(self.by_name('fpcr'), 'mxcsr.pe',  5,  1))  # precision exception
        setitem('mxcsr_daz', self.child(self.by_name('fpcr'), 'mxcsr.daz', 6,  1))  # denormals are zeros
        setitem('mxcsr_im',  self.child(self.by_name('fpcr'), 'mxcsr.im',  7,  1))  # invalid mask
        setitem('mxcsr_dm',  self.child(self.by_name('fpcr'), 'mxcsr.dm',  8,  1))  # denormal mask
        setitem('mxcsr_zm',  self.child(self.by_name('fpcr'), 'mxcsr.zm',  9,  1))  # zero-divide mask
        setitem('mxcsr_om',  self.child(self.by_name('fpcr'), 'mxcsr.om', 10,  1))  # overflow mask
        setitem('mxcsr_um',  self.child(self.by_name('fpcr'), 'mxcsr.um', 11,  1))  # underflow mask
        setitem('mxcsr_pm',  self.child(self.by_name('fpcr'), 'mxcsr.pm', 12,  1))  # precision mask
        setitem('mxcsr_rc',  self.child(self.by_name('fpcr'), 'mxcsr.rc', 13,  2))  # rounding control
        setitem('mxcsr_fz',  self.child(self.by_name('fpcr'), 'mxcsr.fz', 15,  1))  # flush-zero

        [ setitem("bnd{:d}".format(_), self.new("bnd{:d}".format(_), 128)) for _ in range(4) ]

    def by_float(self, index):
        '''Return the desired floating-point stack register by the specified `index`.'''
        return self.by_name("st{:d}".format(index))

    def by_control(self, index):
        '''Return the desired control register by the specified `index`.'''
        return self.by_name("cr{:d}".format(index))

    def by_mmx(self, index):
        '''Return the desired MultiMedia eXtension register of the specified `index`.'''
        return self.by_name("mm{:d}".format(index))

    def by_xmm(self, index):
        '''Return the desired SSE vector register of the specified `index`.'''
        return self.by_name("xmm{:d}".format(index))

    def by_ymm(self, index):
        '''Return the desired 256-bit Advanced Vector Extensions register of the specified `index`.'''
        return self.by_name("ymm{:d}".format(index))

    def by_zmm(self, index):
        '''Return the desired 512-bit Advanced Vector Extensions register of the specified `index`.'''
        return self.by_name("zmm{:d}".format(index))

class AArch(interface.architecture_t):
    """
    An implementation of all the registers available on the AArch32 (ARM) architecture.

    This is used to locate or manage the different registers that are available.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is either
    AArch32 or AArch64.
    """
    prefix = '%'
    def __init__(self, BITS):
        super(AArch, self).__init__()
        getitem, setitem = self.__register__.__getattr__, self.__register__.__setattr__

        [ setitem("v{:d}".format(_), self.new("v{:d}".format(_), 128, idaname="V{:d}".format(_))) for _ in range(32) ]
        [ setitem("q{:d}".format(_), self.new("q{:d}".format(_), 128, idaname="Q{:d}".format(_))) for _ in range(32) ]

        for _ in range(32):
            rv, rq = getitem("v{:d}".format(_)), getitem("q{:d}".format(_))
            rv.alias, rq.alias = { rq }, { rv }

        [ setitem("r{:d}".format(_), self.new("r{:d}".format(_), 32, idaname="R{:d}".format(_))) for _ in range(13) ]
        [ setitem("r{:d}h".format(_), self.child(getitem("r{:d}".format(_)), "r{:d}h".format(_), 0, 16, idaname="R{:d}".format(_))) for _ in range(13) ]
        [ setitem("r{:d}b".format(_), self.child(getitem("r{:d}".format(_)), "r{:d}b".format(_), 0, 8, idaname="R{:d}".format(_))) for _ in range(13) ]

        # Sub-registers that compose the V register (floating-point)
        if BITS > 32:
            [ setitem("d{:d}".format(_), self.child(getitem("v{:d}".format(_)), "d{:d}".format(_), 0, 64, idaname="V{:d}".format(_), dtype=idaapi.dt_double, ptype=float)) for _ in range(32) ]
        else:
            [ setitem("d{:d}".format(_), self.child(getitem("v{:d}".format(_)), "d{:d}".format(_), 0, 64, idaname="D{:d}".format(_), dtype=idaapi.dt_double, ptype=float)) for _ in range(32) ]
        [ setitem("s{:d}".format(_), self.child(getitem("d{:d}".format(_)), "s{:d}".format(_), 0, 32, idaname="S{:d}".format(_), dtype=idaapi.dt_float, ptype=float)) for _ in range(32) ]
        [ setitem("h{:d}".format(_), self.child(getitem("s{:d}".format(_)), "h{:d}".format(_), 0, 16, idaname="X{:d}".format(_), dtype=getattr(idaapi, 'dt_half', idaapi.dt_word), ptype=float)) for _ in range(32) ]
        [ setitem("b{:d}".format(_), self.child(getitem("h{:d}".format(_)), "b{:d}".format(_), 0, 8, idaname="X{:d}".format(_), ptype=float)) for _ in range(32) ]

        # General-purpose registers
        [ setitem("x{:d}".format(_), self.new("x{:d}".format(_), BITS, idaname="X{:d}".format(_))) for _ in range(31) ]
        if BITS > 32:
            [ setitem("w{:d}".format(_), self.child(self.by_name("x{:d}".format(_)), "w{:d}".format(_), 0, 32, idaname="X{:d}".format(_))) for _ in range(31) ]
        setitem('lr', self.new('lr', BITS, idaname='LR', alias={'x31'}))

        # Zero registers and special regs
        setitem('xzr', self.new('xzr', BITS, idaname='XZR'))
        if BITS > 32:
            setitem('wzr', self.new('wzr', 32, idaname='XZR'))
        setitem('sp', self.new('sp', BITS, idaname='SP', alias={'r13'}))
        if BITS > 32:
            setitem('wsp', self.child(getitem('sp'), 'wsp', 0, 32))
        setitem('pc', self.new('pc', BITS, idaname='PC'))
        setitem('msp', self.child(getitem('sp'), 'msp', 0, BITS, idaname='MSP'))
        setitem('psp', self.child(getitem('sp'), 'psp', 0, BITS, idaname='PSP'))

        # Status registers (all)
        # XXX: These registers are busted because they're actually individual
        #      combinations of 3 registers.
        setitem('xpsr', self.new('xpsr', 96, idaname='XPSR', alias={'psr'}))
        setitem('iepsr', self.child(getitem('xpsr'), 'iepsr', 0, 96, idaname='IEPSR'))
        setitem('iapsr', self.child(getitem('xpsr'), 'iapsr', 0, 96, idaname='IAPSR'))
        setitem('eapsr', self.child(getitem('xpsr'), 'eapsr', 0, 96, idaname='EAPSR'))

        # Status registers (application)
        # XXX: We only define these registers as children of the parent
        #      registers that can be written to.
        setitem('apsr', self.child(getitem('xpsr'), 'apsr', 0, 32, idaname='APSR'))
        setitem('q', self.child(getitem('apsr'), 'q', 27, 1))
        setitem('vf', self.child(getitem('apsr'), 'vf', 28, 1, idaname='VF'))
        setitem('cf', self.child(getitem('apsr'), 'cf', 29, 1, idaname='CF'))
        setitem('zf', self.child(getitem('apsr'), 'zf', 30, 1, idaname='ZF'))
        setitem('nf', self.child(getitem('apsr'), 'nf', 31, 1, idaname='NF'))

        # Status registers (execution)
        setitem('epsr', self.child(getitem('xpsr'), 'epsr', 32, 32, idaname='EPSR'))
        setitem('ts', self.child(getitem('epsr'), 'Ts', 24, 1, idaname='T'))

        # Status registers (interrupt)
        setitem('ipsr', self.child(getitem('xpsr'), 'ipsr', 64, 32, idaname='IPSR'))

        # Status registers (current program)
        setitem('cpsr', self.new('cpsr', 32, idaname='CPSR'))
        setitem('m', self.child(getitem('cpsr'), 'm', 0, 4))
        setitem('res1', self.child(getitem('cpsr'), 'res1', 4, 1))
        setitem('res0', self.child(getitem('cpsr'), 'res0', 5, 1))
        setitem('f', self.child(getitem('cpsr'), 'f', 6, 1))
        setitem('i', self.child(getitem('cpsr'), 'i', 7, 1))
        setitem('a', self.child(getitem('cpsr'), 'a', 8, 1))
        setitem('e', self.child(getitem('cpsr'), 'e', 9, 1))
        [ setitem("it{:d}".format(2 + _), self.child(getitem('cpsr'), "it{:d}".format(2 + _), 10 + _, 1)) for _ in range(6) ]
        setitem('ge', self.child(getitem('cpsr'), 'ge', 16, 3))
        setitem('dit', self.child(getitem('cpsr'), 'dit', 21, 1))
        setitem('pan', self.child(getitem('cpsr'), 'pan', 22, 1))
        setitem('ssbs', self.child(getitem('cpsr'), 'ssbs', 23, 1))
        setitem('j', self.child(getitem('cpsr'), 'j', 24, 1))
        setitem('it0', self.child(getitem('cpsr'), 'it0', 25, 1))
        setitem('it1', self.child(getitem('cpsr'), 'it1', 26, 1))
        setitem('q', self.child(getitem('cpsr'), 'q', 27, 1))
        setitem('v', self.child(getitem('cpsr'), 'v', 28, 1))
        setitem('c', self.child(getitem('cpsr'), 'c', 29, 1))
        setitem('z', self.child(getitem('cpsr'), 'z', 30, 1))
        setitem('n', self.child(getitem('cpsr'), 'n', 31, 1))

        setitem('spsr', self.child(getitem('cpsr'), 'spsr', 0, 32, idaname='SPSR'))
        setitem('cpsr_flag', self.child(getitem('cpsr'), 'cpsr_flag', 27, 5, idaname='CPSR_flg'))
        setitem('spsr_flag', self.child(getitem('spsr'), 'spsr_flag', 27, 5, idaname='SPSR_flg'))

        # Status registers (floating point)
        setitem('fpscr', self.new('fpscr', 32, idaname='FPSCR'))
        setitem('ioc', self.child(getitem('fpscr'), 'ioc', 0, 1))
        setitem('dzc', self.child(getitem('fpscr'), 'dzc', 1, 1))
        setitem('ofc', self.child(getitem('fpscr'), 'ofc', 2, 1))
        setitem('ufc', self.child(getitem('fpscr'), 'ufc', 3, 1))
        setitem('ixc', self.child(getitem('fpscr'), 'ixc', 4, 1))
        setitem('idc', self.child(getitem('fpscr'), 'idc', 7, 1))
        setitem('ioe', self.child(getitem('fpscr'), 'ioe', 8, 1))
        setitem('dze', self.child(getitem('fpscr'), 'dze', 9, 1))
        setitem('ofe', self.child(getitem('fpscr'), 'ofe', 10, 1))
        setitem('ufe', self.child(getitem('fpscr'), 'ufe', 11, 1))
        setitem('ixe', self.child(getitem('fpscr'), 'ixe', 12, 1))
        setitem('ide', self.child(getitem('fpscr'), 'ide', 15, 1))
        setitem('len', self.child(getitem('fpscr'), 'Len', 16, 3))
        setitem('stride', self.child(getitem('fpscr'), 'Stride', 20, 2))
        setitem('rmode', self.child(getitem('fpscr'), 'Rmode', 22, 2))
        setitem('fz', self.child(getitem('fpscr'), 'fz', 24, 1))
        setitem('dn', self.child(getitem('fpscr'), 'dn', 25, 1))
        setitem('ahp', self.child(getitem('fpscr'), 'ahp', 26, 1))
        setitem('qc', self.child(getitem('fpscr'), 'qc', 27, 1))
        setitem('Fv', self.child(getitem('fpscr'), 'Fv', 28, 1))
        setitem('Fc', self.child(getitem('fpscr'), 'Fc', 29, 1))
        setitem('Fz', self.child(getitem('fpscr'), 'Fz', 30, 1))
        setitem('Fn', self.child(getitem('fpscr'), 'Fn', 31, 1))

        # Media registers
        setitem('mvfr0', self.new('mvfr0', 32, idaname='MVFR0'))
        setitem('mvrb', self.child(getitem('mvfr0'), 'MVrb', 0, 4))
        setitem('mvsp', self.child(getitem('mvfr0'), 'MVsp', 4, 4))
        setitem('mvdp', self.child(getitem('mvfr0'), 'MVdp', 8, 4))
        setitem('mvte', self.child(getitem('mvfr0'), 'MVte', 12, 4))
        setitem('mvd', self.child(getitem('mvfr0'), 'MVd', 16, 4))
        setitem('mvsr', self.child(getitem('mvfr0'), 'MVsr', 20, 4))
        setitem('mvsv', self.child(getitem('mvfr0'), 'MVsv', 24, 4))
        setitem('mvrm', self.child(getitem('mvfr0'), 'MVrm', 28, 4))

        setitem('mvfr1', self.new('mvfr1', 32, idaname='MVFR1'))
        setitem('mvfz', self.child(getitem('mvfr1'), 'MVfz', 0, 4))
        setitem('mvdn', self.child(getitem('mvfr1'), 'MVdn', 0, 4))
        setitem('mnls', self.child(getitem('mvfr1'), 'MNls', 0, 4))
        setitem('mni', self.child(getitem('mvfr1'), 'MNi', 0, 4))
        setitem('mnsp', self.child(getitem('mvfr1'), 'MNsp', 0, 4))

        # Opaque registers
        setitem('fpsid', self.new('fpsid', 32, idaname='FPSID'))
        setitem('fpexc', self.new('fpexc', 32, idaname='FPEXC'))
        setitem('fpinst', self.new('fpinst', 32, idaname='FPINST'))
        setitem('fpinst2', self.new('fpinst2', 32, idaname='FPINST2'))
        setitem('primask', self.new('primask', 32, idaname='PRIMASK'))
        setitem('basepri', self.new('basepri', 32, idaname='BASEPRI'))
        setitem('faultmask', self.new('faultmask', 32, idaname='FAULTMASK'))
        setitem('control', self.new('control', 32, idaname='CONTROL'))
        setitem('basepri_max', self.new('basepri_max', 32, idaname='BASEPRI_MAX'))

        # XScale register(s?)
        setitem('acc0', self.new('acc0', 32, idaname='acc0'))

        # XXX: for some reason IDA defines the CS and DS registers??

        # Conditions (not really registers, but armops.condition_t)
        [ setitem(_, armops.condition_t(index)) for index, _ in enumerate(['EQ', 'NE', 'CS', 'CC', 'MI', 'PL', 'VS', 'VC', 'HI', 'LS', 'GE', 'LT', 'GT', 'LE', 'AL', 'NV']) ]

    def by_condition(self, index):
        '''Return the condition type for the specified `index`.'''
        cc = ['EQ', 'NE', 'CS', 'CC', 'MI', 'PL', 'VS', 'VC', 'HI', 'LS', 'GE', 'LT', 'GT', 'LE', 'AL', 'NV']
        return self.by_name(cc[index])

class AArch32(AArch):
    """
    An implementation of all the registers available on the AArch32 (ARM) architecture.

    This is used to locate or manage the different registers that are available.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is AArch32.
    """

    def __init__(self):
        return super(AArch32, self).__init__(32)

class AArch64(AArch):
    """
    An implementation of all the registers available on the AArch64 (ARM) architecture.

    This is used to locate or manage the different registers that are available.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is AArch64.
    """

    def __init__(self):
        return super(AArch64, self).__init__(64)

class MIPS(interface.architecture_t):
    """
    An implementation of all the registers available on the MIPS architectures.

    This includes the different coprocessor registers that are also available
    but are treated as special instructions by IDA.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is MIPS.
    """
    prefix = '$'
    def __init__(self, BITS):
        super(MIPS, self).__init__()
        getitem, setitem = self.__register__.__getattr__, self.__register__.__setattr__

        setitem('zero', self.new('zero', BITS, idaname='$zero'))
        setitem('at', self.new('at', BITS, idaname='$at'))

        setitem('gp', self.new('gp', BITS, idaname='$gp'))
        setitem('sp', self.new('sp', BITS, idaname='$sp'))
        setitem('fp', self.new('fp', BITS, idaname='$fp'))
        setitem('ra', self.new('ra', BITS, idaname='$ra'))
        setitem('pc', self.new('pc', BITS))

        [ setitem("v{:d}".format(_), self.new("v{:d}".format(_), BITS, idaname="$v{:d}".format(_))) for _ in range(2) ]
        [ setitem("a{:d}".format(_), self.new("a{:d}".format(_), BITS, idaname="$a{:d}".format(_))) for _ in range(8) ]
        [ setitem("t{:d}".format(_), self.new("t{:d}".format(_), BITS, idaname="$t{:d}".format(_))) for _ in range(0, 10) ]
        [ setitem("s{:d}".format(_), self.new("s{:d}".format(_), BITS, idaname="$s{:d}".format(_))) for _ in range(8) ]
        [ setitem("k{:d}".format(_), self.new("k{:d}".format(_), BITS, idaname="$k{:d}".format(_))) for _ in range(2) ]

        # FIXME: add the register definitions for : cs, ds, mips16

        # floating-point registers
        if BITS > 32:
            [ setitem("f{:d}".format(_), self.new("f{:d}".format(_), BITS, idaname="$f{:d}".format(_), dtype=idaapi.dt_double, ptype=float)) for _ in range(32) ]
        else:
            [ setitem("f{:d}".format(_), self.new("f{:d}".format(_), BITS, idaname="$f{:d}".format(_), dtype=idaapi.dt_float, ptype=float)) for _ in range(32) ]

        # FIXME: we should probably include all of the selector versions for the
        #        coprocessor registers too...
        i2s = "{:d}".format

        # coprocessor registers (0 - 31)
        setitem('Index', self.new('Index', BITS, id=0))         # 0
        setitem('Random', self.new('Random', BITS, id=0))       # 1
        setitem('EntryLo0', self.new('EntryLo0', BITS, id=0))   # 2
        setitem('EntryLo1', self.new('EntryLo1', BITS, id=0))   # 3
        setitem('Context', self.new('Context', BITS, id=0))     # 4
        setitem('PageMask', self.new('PageMask', BITS, id=0))   # 5
        setitem('Wired', self.new('Wired', BITS, id=0))         # 6
        setitem('HWREna', self.new('HWREna', BITS, id=0))       # 7
        setitem('BadVAddr', self.new('BadVAddr', BITS, id=0))   # 8
        setitem('Count', self.new('Count', BITS, id=0))         # 9
        setitem('EntryHi', self.new('EntryHi', BITS, id=0))     # 10
        setitem('Compare', self.new('Compare', BITS, id=0))     # 11
        setitem('SR', self.new('SR', BITS, id=0))               # 12.0
        setitem('IntCtl', self.new('IntCtl', BITS, id=0))       # 12.1
        setitem('SRSCtl', self.new('STSCtl', BITS, id=0))       # 12.2
        setitem('SRSMap', self.new('STSMap', BITS, id=0))       # 12.3
        setitem('Cause', self.new('Cause', BITS, id=0))         # 13
        setitem('EPC', self.new('EPC', BITS, id=0))             # 14
        setitem('PRId', self.new('PRId', BITS, id=0))           # 15.0
        setitem('EBase', self.new('EBase', BITS, id=0))         # 15.1
        setitem('Config', self.new('Config', BITS, id=0))       # 16.0
        setitem('Config1', self.new('Config1', BITS, id=0))     # 16.1
        setitem('Config2', self.new('Config2', BITS, id=0))     # 16.2
        setitem('Config3', self.new('Config3', BITS, id=0))     # 16.3
        setitem('LLAddr', self.new('LLAddr', BITS, id=0))       # 17
        setitem('WatchLo', self.new('WatchLo', BITS, id=0))     # 18
        setitem('WatchHi', self.new('WatchHi', BITS, id=0))     # 19
        setitem('XContext', self.new('XContext', BITS, id=0))   # 20
        setitem(i2s(21), self.new(i2s(21), BITS, id=0))         # 21
        setitem(i2s(22), self.new(i2s(22), BITS, id=0))         # 22
        setitem('Debug', self.new('Debug', BITS, id=0))         # 23
        setitem('DEPC', self.new('DEPC', BITS, id=0))           # 24
        setitem('PerfCtl', self.new('PerfCtl', BITS, id=0))     # 25.0
        setitem('PerfCnt', self.new('PerfCnt', BITS, id=0))     # 25.1
        setitem('ECC', self.new('ECC', BITS, id=0))             # 26
        setitem('CacheErr', self.new('CacheErr', BITS, id=0))   # 27
        setitem('TagLo', self.new('TagLo', BITS, id=0))         # 28.0
        setitem('DataLo', self.new('TagLo', BITS, id=0))        # 28.1
        setitem('TagHi', self.new('TagHi', BITS, id=0))         # 29.0
        setitem('DataHi', self.new('DataHi', BITS, id=0))       # 29.1
        setitem('ErrorEPC', self.new('ErrorEPC', BITS, id=0))   # 30
        setitem('DESAVE', self.new('DESAVE', BITS, id=0))       # 31

    def by_coprocessor(self, index, selector=0):
        '''Return the coprocessor register by the selected `index` and `selector`.'''
        file = self.register

        # FIXME: Should include _all_ of the coprocessor registers with their
        #        selector versions too..
        registers = {
            0x00 : file.Index,      0x01 : file.Random,     0x02 : file.EntryLo0,   0x03 : file.EntryLo1,
            0x04 : file.Context,    0x05 : file.PageMask,   0x06 : file.Wired,      0x07 : file.HWREna,
            0x08 : file.BadVAddr,   0x09 : file.Count,      0x0a : file.EntryHi,    0x0b : file.Compare,
            0x0c : file.SR,         0x0d : file.Cause,      0x0e : file.EPC,        0x0f : file.PRId,
            0x10 : file.Config,     0x11 : file.LLAddr,     0x12 : file.WatchLo,    0x13 : file.WatchHi,
            0x14 : file.XContext,

            0x17 : file.Debug,      0x18 : file.DEPC,       0x19 : file.PerfCtl,    0x1a : file.ECC,
            0x1b : file.CacheErr,   0x1c : file.TagLo,      0x1d : file.TagHi,      0x1e : file.ErrorEPC,
            0x1f : file.DESAVE,
        }

        if index in registers:
            return registers[index]
        return self.by_name("{:d}".format(index))

    def by_float(self, index):
        '''Return the floating-point register by the selected `index`.'''
        return self.by_name("$f{:d}".format(index))

class MIPS32(MIPS):
    """
    An implementation of all the registers available on the MIPS32 architecture.

    This includes the different coprocessor registers that are also available
    but are treated as special instructions by IDA.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is MIPS.
    """

    def __init__(self):
        return super(MIPS32, self).__init__(32)

class MIPS64(MIPS):
    """
    An implementation of all the registers available on the MIPS64 architecture.

    This includes the different coprocessor registers that are also available
    but are treated as special instructions by IDA.

    An instance of this class can be accessed as ``instruction.architecture``
    (or ``instruction.arch``) when the current architecture of the database is MIPS.
    """

    def __init__(self):
        return super(MIPS64, self).__init__(64)

## global initialization
def __nw_newprc__(nw_code, is_old_database):
    pnum = idaapi.ph_get_id()
    return __newprc__(pnum)
def __ev_newprc__(pnum, keep_cfg):
    return __newprc__(pnum)
def __newprc__(id):
    """
    Determine the architecture from the current processor and use it to initialize
    the globals (``architecture`` and ``register``) within this module.
    """
    if not hasattr(database, 'config'):
        # XXX: If this module hasn't been loaded properly, then this is because IDA hasn't actually started yet.
        return

    plfm, m = idaapi.ph.id, __import__('sys').modules[__name__]
    if plfm == idaapi.PLFM_386:     # id == 15
        res, description = Intel(), "Intel architecture {:d}-bit".format(database.config.bits())
    elif plfm == idaapi.PLFM_ARM:   # id == 1
        res, description = AArch64() if database.config.bits() > 32 else AArch32(), "AArch{:d}".format(database.config.bits())
    elif plfm == idaapi.PLFM_MIPS:  # id == 12
        res, description = MIPS64() if database.config.bits() > 32 else MIPS32(), "MIPS{:d}".format(database.config.bits())
    else:
        logging.warning("{:s} : IDP_Hooks.newprc({:d}) : Unsupported processor type {:d} was specified. Tools that use the instruction module might not work properly.".format(__name__, id, plfm))
        return

    logging.warning("Detected processor module : {:s} ({:d})".format(description, plfm))

    # assign our required globals
    m.architecture, m.register = res, res.r

    # assign some aliases so that its much shorter to type
    m.arch, m.reg = m.architecture, m.register

# initialize with a default processor on the initial import but not on reload()
if 'architecture' not in locals() or 'register' not in locals():
    __newprc__(0)

```

`base/segment.py`:

```py
r"""
Segment module

This module provides a number of tools that can be used to enumerate
or work with segments within a database.

The base argument type for some of the utilities within this module
is the ``idaapi.segment_t``. This type is interchangeable with the
address or the segment name and so either can be used to identify a
segment.

When listing or enumerating segments there are different types that
one can use in order to filter or match them. These types are as
follows:

    `name` - Match according to the exact segment name
    `like` - Filter the segment names according to a glob
    `regex` - Filter the function names according to a regular-expression
    `index` - Match the segment by its index
    `identifier` - Match the segment by its identifier
    `selector` - Match the segment by its selector
    `greater` or `ge` - Filter the segments for any after the specified address (inclusive)
    `gt` - Filter the segments for any after the specified address (exclusive)
    `less` or `le` - Filter the segments for any before the specified address (inclusive)
    `lt` - Filter the segments for any before the specified address (exclusive)
    `predicate` - Filter the segments by passing their ``idaapi.segment_t`` to a callable

Some examples of using these keywords are as follows::

    > for l, r in database.segments(): ...
    > database.segments.list(regex=r'\.r?data')
    > iterable = database.segments.iterate(like='*text*')
    > result = database.segments.search(greater=0x401000)

"""

import six, builtins

import functools, operator, itertools, types
import os, logging
import math, re, fnmatch

import database
import ui, internal
from internal import utils, interface, exceptions as E

import idaapi

## enumerating
__matcher__ = utils.matcher()
__matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name, utils.string.of)
__matcher__.attribute('index', 'index')
__matcher__.attribute('identifier', 'name'), __matcher__.attribute('id', 'name')
__matcher__.attribute('selector', 'sel')
__matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name, utils.string.of)
__matcher__.boolean('name', lambda name, item: name.lower() == item.lower(), idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name, utils.string.of)
if idaapi.__version__ < 7.0:
    __matcher__.boolean('greater', operator.le, 'endEA')
    __matcher__.boolean('gt', operator.lt, 'endEA')
    __matcher__.boolean('less', operator.ge, 'startEA')
    __matcher__.boolean('lt', operator.gt, 'startEA')
else:
    __matcher__.boolean('greater', operator.le, 'end_ea')
    __matcher__.boolean('gt', operator.lt, 'end_ea')
    __matcher__.boolean('less', operator.ge, 'start_ea')
    __matcher__.boolean('lt', operator.gt, 'start_ea')
__matcher__.predicate('predicate'), __matcher__.predicate('pred')

@utils.string.decorate_arguments('regex', 'like', 'name')
def __iterate__(**type):
    '''Iterate through each segment defined in the database that match the keywords specified by `type`.'''
    def newsegment(index):
        seg = idaapi.getnseg(index)
        seg.index, _ = index, ui.navigation.set(interface.range.start(seg))
        return seg
    iterable = (newsegment(index) for index in builtins.range(idaapi.get_segm_qty()))
    for key, value in (type or {'predicate': utils.fconstant(True)}).items():
        iterable = (item for item in __matcher__.match(key, value, iterable))
    for item in iterable: yield item

@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string')
def list(string):
    '''List all of the segments whose name matches the glob specified by `string`.'''
    return list(like=string)
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def list(**type):
    '''List all of the segments in the database that match the keyword specified by `type`.'''
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name

    listable = []

    # Set some reasonable defaults
    maxindex = maxaddr = maxsize = maxname = 0

    # First pass through our segments to grab lengths of displayed fields
    for seg in __iterate__(**type):
        maxindex = max(seg.index, maxindex)
        maxaddr = max(interface.range.end(seg), maxaddr)
        maxsize = max(seg.size(), maxsize)
        maxname = max(len(get_segment_name(seg)), maxname)

        listable.append(seg)

    # Collect the maximum sizes for everything from the first pass. We have
    # to use different algorithms as due to Python's issues with imprecision,
    # the resulting number of digits will vary depending on what base is
    # actually being used when calculating the logarithm.
    cindex = utils.string.digits(maxindex, 10)
    caddr, csize = (utils.string.digits(item, 10) for item in [maxaddr, maxsize])

    # List all the fields for each segment that we've aggregated
    for seg in listable:
        comment, _ = idaapi.get_segment_cmt(seg, 0) or idaapi.get_segment_cmt(seg, 1), ui.navigation.set(interface.range.start(seg))
        six.print_(u"[{:{:d}d}] {:#0{:d}x}<>{:#0{:d}x} : {:<+#{:d}x} : {:>{:d}s} : sel:{:04x} flags:{:02x}{:s}".format(seg.index, math.trunc(cindex), interface.range.start(seg), 2 + math.trunc(caddr), interface.range.end(seg), 2 + math.trunc(caddr), seg.size(), 3 + math.trunc(csize), utils.string.of(get_segment_name(seg)), maxname, seg.sel, seg.flags, u"// {:s}".format(utils.string.of(comment)) if comment else ''))
    return

## searching
@utils.string.decorate_arguments('name')
def by_name(name):
    '''Return the segment with the given `name`.'''
    res = utils.string.to(name)
    seg = idaapi.get_segm_by_name(res)
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.by_name({!r}) : Unable to locate the segment with the specified name.".format(__name__, name))
    return seg
byname = utils.alias(by_name)
def by_selector(selector):
    '''Return the segment associated with `selector`.'''
    seg = idaapi.get_segm_by_sel(selector)
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.by_selector({:#x}) : Unable to locate the segment with the specified selector.".format(__name__, selector))
    return seg
byselector = utils.alias(by_selector)
def by_address(ea):
    '''Return the segment that contains the specified `ea`.'''
    seg = idaapi.getseg(interface.address.within(ea))
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.by_address({:#x}) : Unable to locate segment containing the specified address.".format(__name__, ea))
    return seg
byaddress = utils.alias(by_address)
@utils.multicase(segment=idaapi.segment_t)
def by(segment):
    '''Return a segment by its ``idaapi.segment_t``.'''
    return segment
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name')
def by(name):
    '''Return the segment by its `name`.'''
    return by_name(name)
@utils.multicase(ea=six.integer_types)
def by(ea):
    '''Return the segment containing the address `ea`.'''
    return by_address(ea)
@utils.multicase()
def by():
    '''Return the current segment.'''
    return ui.current.segment()
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def by(**type):
    '''Return the segment matching the specified keywords in `type`.'''
    searchstring = utils.string.kwargs(type)
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name

    listable = [item for item in __iterate__(**type)]
    if len(listable) > 1:
        maxaddr = max(builtins.map(interface.range.end, listable) if listable else [1])
        caddr = utils.string.digits(maxaddr, 16)
        messages = ((u"[{:d}] {:0{:d}x}:{:0{:d}x} {:s} {:+#x} sel:{:04x} flags:{:02x}".format(seg.index, interface.range.start(seg), math.trunc(caddr), interface.range.end(seg), math.trunc(caddr), utils.string.of(get_segment_name(seg)), seg.size(), seg.sel, seg.flags)) for seg in listable)
        [ logging.info(msg) for msg in messages ]
        logging.warning(u"{:s}.by({:s}) : Found {:d} matching results. Returning the first segment at index {:d} from {:0{:d}x}<>{:0{:d}x} with the name {:s} and size {:+#x}.".format(__name__, searchstring, len(listable), listable[0].index, interface.range.start(listable[0]), math.trunc(caddr), interface.range.end(listable[0]), math.trunc(caddr), utils.string.of(get_segment_name(listable[0])), listable[0].size()))

    iterable = (item for item in listable)
    res = builtins.next(iterable, None)
    if res is None:
        raise E.SearchResultsError(u"{:s}.by({:s}) : Found 0 matching results.".format(__name__, searchstring))
    return res

@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name')
def search(name):
    '''Search through all the segments and return the first one matching the glob `name`.'''
    return by(like=name)
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def search(**type):
    '''Search through all the segments and return the first one that matches the keyword specified by `type`.'''
    return by(**type)

## properties
@utils.multicase()
def bounds():
    '''Return the bounds of the current segment.'''
    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.bounds() : Unable to locate the current segment.".format(__name__))
    return interface.range.bounds(seg)
@utils.multicase()
def bounds(segment):
    '''Return the bounds of the segment specified by `segment`.'''
    seg = by(segment)
    return interface.range.bounds(seg)
range = utils.alias(bounds)

@utils.multicase()
def iterate():
    '''Iterate through all of the addresses within the current segment.'''
    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.iterate() : Unable to locate the current segment.".format(__name__))
    return iterate(seg)
@utils.multicase()
def iterate(segment):
    '''Iterate through all of the addresses within the specified `segment`.'''
    seg = by(segment)
    return iterate(seg)
@utils.multicase(segment=idaapi.segment_t)
def iterate(segment):
    '''Iterate through all of the addresses within the ``idaapi.segment_t`` represented by `segment`.'''
    left, right = interface.range.unpack(segment)
    for ea in database.address.iterate(left, right):
        yield ea
    return

@utils.multicase()
def size():
    '''Return the size of the current segment.'''
    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.size() : Unable to locate the current segment.".format(__name__))
    return interface.range.size(seg)
@utils.multicase()
def size(segment):
    '''Return the size of the segment specified by `segment`.'''
    seg = by(segment)
    return interface.range.size(seg)

@utils.multicase()
def offset():
    '''Return the offset of the current address from the beginning of the current segment.'''
    return offset(ui.current.segment(), ui.current.address())
@utils.multicase(ea=six.integer_types)
def offset(ea):
    '''Return the offset of the address `ea` from the beginning of the current segment.'''
    return offset(ui.current.segment(), ea)
@utils.multicase(ea=six.integer_types)
def offset(segment, ea):
    '''Return the offset of the address `ea` from the beginning of `segment`.'''
    seg = by(segment)
    return ea - interface.range.start(seg)

@utils.multicase(offset=six.integer_types)
def by_offset(offset):
    '''Return the specified `offset` translated to the beginning of the current segment.'''
    return by_offset(ui.current.segment(), offset)
@utils.multicase(offset=six.integer_types)
def by_offset(segment, offset):
    '''Return the specified `offset` translated to the beginning of `segment`.'''
    seg = by(segment)
    return interface.range.start(seg) + offset
byoffset = utils.alias(by_offset)

@utils.multicase(offset=six.integer_types)
def go_offset(offset):
    '''Go to the `offset` of the current segment.'''
    return go_offset(ui.current.segment(), offset)
@utils.multicase(offset=six.integer_types)
def go_offset(segment, offset):
    '''Go to the `offset` of the specified `segment`.'''
    seg = by(segment)
    return database.go(offset + interface.range.start(seg))
goof = gooffset = gotooffset = goto_offset = utils.alias(go_offset)

@utils.multicase()
def read():
    '''Return the contents of the current segment.'''
    get_bytes = idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes

    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.read() : Unable to locate the current segment.".format(__name__))
    return get_bytes(interface.range.start(seg), interface.range.size(seg))
@utils.multicase()
def read(segment):
    '''Return the contents of the segment identified by `segment`.'''
    get_bytes = idaapi.get_many_bytes if idaapi.__version__ < 7.0 else idaapi.get_bytes

    seg = by(segment)
    return get_bytes(interface.range.start(seg), interface.range.size(seg))
string = utils.alias(read)

@utils.multicase()
def repr():
    '''Return the current segment in a printable form.'''
    segment = ui.current.segment()
    if segment is None:
        raise E.SegmentNotFoundError(u"{:s}.repr() : Unable to locate the current segment.".format(__name__))
    return repr(segment)
@utils.multicase()
def repr(segment):
    '''Return the specified `segment` in a printable form.'''
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name

    seg = by(segment)
    return "{:s} {:s} {:#x}-{:#x} ({:+#x})".format(object.__repr__(seg), get_segment_name(seg), interface.range.start(seg), interface.range.end(seg), interface.range.size(seg))

@utils.multicase()
def top():
    '''Return the top address of the current segment.'''
    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.top() : Unable to locate the current segment.".format(__name__))
    return interface.range.start(seg)
@utils.multicase()
def top(segment):
    '''Return the top address of the segment identified by `segment`.'''
    seg = by(segment)
    return interface.range.start(seg)

@utils.multicase()
def bottom():
    '''Return the bottom address of the current segment.'''
    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.bottom() : Unable to locate the current segment.".format(__name__))
    return interface.range.end(seg)
@utils.multicase()
def bottom(segment):
    '''Return the bottom address of the segment identified by `segment`.'''
    seg = by(segment)
    return interface.range.end(seg)

@utils.multicase()
def name():
    '''Return the name of the current segment.'''
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name

    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.name() : Unable to locate the current segment.".format(__name__))
    res = get_segment_name(seg)
    return utils.string.of(res)
@utils.multicase()
def name(segment):
    '''Return the name of the segment identified by `segment`.'''
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name

    seg = by(segment)
    res = get_segment_name(seg)
    return utils.string.of(res)

@utils.multicase()
def color():
    '''Return the color of the current segment.'''
    seg = ui.current.segment()
    if seg is None:
        raise E.SegmentNotFoundError(u"{:s}.color() : Unable to locate the current segment.".format(__name__))
    b,r = (seg.color&0xff0000)>>16, seg.color&0x0000ff
    return None if seg.color == 0xffffffff else (r<<16)|(seg.color&0x00ff00)|b
@utils.multicase()
def color(segment):
    '''Return the color of the segment identified by `segment`.'''
    seg = by(segment)
    b,r = (seg.color&0xff0000)>>16, seg.color&0x0000ff
    return None if seg.color == 0xffffffff else (r<<16)|(seg.color&0x00ff00)|b
@utils.multicase(none=None.__class__)
def color(none):
    '''Clear the color of the current segment.'''
    return color(ui.current.segment(), None)
@utils.multicase(none=None.__class__)
def color(segment, none):
    '''Clear the color of the segment identified by `segment`.'''
    seg = by(segment)
    seg.color = 0xffffffff
    return bool(seg.update())
@utils.multicase(rgb=six.integer_types)
def color(segment, rgb):
    '''Sets the color of the segment identified by `segment` to `rgb`.'''
    r,b = (rgb&0xff0000) >> 16, rgb&0x0000ff
    seg = by(segment)
    seg.color = (b<<16)|(rgb&0x00ff00)|r
    return bool(seg.update())

@utils.multicase()
def within():
    '''Returns true if the current address is within any segment.'''
    return within(ui.current.address())
@utils.multicase(ea=six.integer_types)
def within(ea):
    '''Returns true if the address `ea` is within any segment.'''
    return any(interface.range.within(ea, seg) for seg in __iterate__())

@utils.multicase(ea=six.integer_types)
def contains(ea):
    '''Returns true if the address `ea` is contained within the current segment.'''
    return contains(ui.current.segment(), ea)
@utils.multicase(address=six.integer_types, ea=six.integer_types)
def contains(address, ea):
    '''Returns true if the address `ea` is contained within the segment belonging to the specified `address`.'''
    seg = by_address(address)
    return contains(seg, ea)
@utils.multicase(name=six.string_types, ea=six.integer_types)
@utils.string.decorate_arguments('name')
def contains(name, ea):
    '''Returns true if the address `ea` is contained within the segment with the specified `name`.'''
    seg = by_name(name)
    return contains(seg, ea)
@utils.multicase(segment=idaapi.segment_t, ea=six.integer_types)
def contains(segment, ea):
    '''Returns true if the address `ea` is contained within the ``idaapi.segment_t`` specified by `segment`.'''
    return interface.range.within(ea, segment)

@utils.multicase()
def type():
    '''Return the type of the current segment.'''
    return type(ui.current.segment())
@utils.multicase(ea=six.integer_types)
def type(ea):
    '''Return the type of the segment containing the address `ea`.'''
    result = idaapi.segtype(ea)
    if result == idaapi.SEG_UNDF and not database.within(ea):
        bounds, results = "{:#x}<>{:#x}".format(*database.config.bounds()), {getattr(idaapi, name) : name for name in dir(idaapi) if name.startswith('SEG_')}
        logging.warning(u"{:s}.type({:#x}) : Returning {:s}({:d}) for the segment type due to the given address ({:#x}) not being within the boundaries of the database ({:s}).".format(__name__, ea, results[result], result, ea, bounds))
    return result
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name')
def type(name):
    '''Return the type of the segment with the specified `name`.'''
    seg = by_name(name)
    return type(seg)
@utils.multicase(segment=idaapi.segment_t)
def type(segment):
    '''Return the type of the ``idaapi.segment_t`` specified by `segment`.'''
    return segment.type
@utils.multicase(segtype=six.integer_types)
def type(segment, segtype):
    '''Return whether the given `segment` is of the provided `segtype`.'''
    return type(segment) == segtype

## functions
# shamefully ripped from idc.py
def __load_file(filename, ea, size, offset=0):
    path = os.path.abspath(filename)

    # use IDA to open up the file contents
    # XXX: does IDA support unicode file paths?
    res = idaapi.open_linput(path, False)
    if not res:
        raise E.DisassemblerError(u"{:s}.load_file({!r}, {:#x}, {:+#x}) : Unable to create an `idaapi.loader_input_t` from path \"{:s}\".".format(__name__, filename, ea, size, path))

    # now we can write the file into the specified address as a segment
    ok = idaapi.file2base(res, offset, ea, ea+size, False)
    idaapi.close_linput(res)
    return ok

def __save_file(filename, ea, size, offset=0):
    path = os.path.abspath(filename)

    # use IDA to open up a file to write to
    # XXX: does IDA support unicode file paths?
    of = idaapi.fopenWB(path)
    if not of:
        raise E.DisassemblerError(u"{:s}.save_file({!r}, {:#x}, {:+#x}) : Unable to open target file \"{:s}\".".format(__name__, filename, ea, size, utils.string.escape(path, '"')))

    # now we can write the segment into the file we opened
    res = idaapi.base2file(of, offset, ea, ea+size)
    idaapi.eclose(of)
    return res

@utils.string.decorate_arguments('filename')
def load(filename, ea, size=None, offset=0, **kwds):
    """Load the specified `filename` to the address `ea` as a segment.

    If `size` is not specified, use the length of the file.
    The keyword `offset` represents the offset into the file to use.
    The keyword `name` can be used to name the segment.
    """
    filesize = os.stat(filename).st_size

    cb = filesize - offset if size is None else size
    res = __load_file(utils.string.to(filename), ea, cb, offset)
    if not res:
        raise E.ReadOrWriteError(u"{:s}.load({!r}, {:#x}, {:+#x}, {:#x}{:s}) : Unable to load file into {:#x}{:+#x} from \"{:s}\".".format(__name__, filename, ea, cb, offset, u", {:s}".format(utils.string.kwargs(kwds)) if kwds else '', ea, cb, utils.string.escape(os.path.relpath(filename), '"')))
    return new(ea, cb, kwds.get('name', os.path.split(filename)[1]))

def map(ea, size, newea, **kwds):
    """Map `size` bytes of data from `ea` into a new segment at `newea`.

    The keyword `name` can be used to name the segment.
    """

    # grab the file offset and the data we want
    fpos, data = idaapi.get_fileregion_offset(ea), database.read(ea, size)
    if len(data) != size:
        raise E.ReadOrWriteError(u"{:s}.map({:#x}, {:+#x}, {:#x}{:s}) : Unable to read {:#x} bytes from {:#x}.".format(__name__, ea, size, newea, u", {:s}".format(utils.string.kwargs(kwds)) if kwds else '', size, ea))

    # rebase the data to the new address
    res = idaapi.mem2base(data, newea, fpos)
    if not res:
        raise E.DisassemblerError(u"{:s}.map({:#x}, {:+#x}, {:#x}{:s}) : Unable to remap {:#x}:{:+#x} to {:#x}.".format(__name__, ea, size, newea, u", {:s}".format(utils.string.kwargs(kwds)) if kwds else '', ea, size, newea))

    # now we can create the new segment
    return new(newea, size, kwds.get("name", "map_{:x}".format(ea)))
    #return create(newea, size, kwds.get("name", "map_{:s}".format(newea>>4)))

# creation/destruction
@utils.string.decorate_arguments('name')
def new(offset, size, name, **kwds):
    """Create a segment at `offset` with `size` and name it according to `name`.

    The keyword `bits` can be used to specify the bit size of the segment
    The keyword `comb` can be used to specify any flags (idaapi.sc*)
    The keyword `align` can be used to specify paragraph alignment (idaapi.sa*)
    The keyword `org` specifies the origin of the segment (must be paragraph aligned due to ida)
    """
    res = utils.string.to(name)

    # find the segment according to the name specified by the user
    seg = idaapi.get_segm_by_name(res)
    if seg is not None:
        raise E.DuplicateItemError(u"{:s}.new({:#x}, {:+#x}, \"{:s}\"{:s}) : A segment with the specified name (\"{:s}\") already exists.".format(__name__, offset, size, utils.string.escape(name, '"'), u", {:s}".format(utils.string.kwargs(kwds)) if kwds else '', utils.string.escape(name, '"')))

    # FIXME: use disassembler default bit length instead of 32
    bits = kwds.get( 'bits', 32 if idaapi.getseg(offset) is None else idaapi.getseg(offset).abits())

    ## create a selector with the requested origin
    if bits == 16:
        org = kwds.get('org',0)
        if org & 0xf > 0:
            raise E.InvalidTypeOrValueError(u"{:s}.new({:#x}, {:+#x}, {!r}{:s}) : The specified origin ({:#x}) is not aligned to the size of a paragraph (0x10).".format(__name__, offset, size, name, u", {:s}".format(utils.string.kwargs(kwds)) if kwds else '', org))

        para = offset // 16
        sel = idaapi.allocate_selector(para)
        idaapi.set_selector(sel, (para - kwds.get('org', 0) // 16) & 0xffffffff)

    ## if the user specified a selector, then use it
    elif 'sel' in kwds or 'selector' in kwds:
        sel = kwds.get('sel', kwds.get('selector', idaapi.find_free_selector()))

    ## choose the paragraph size defined by the user
    elif 'para' in kwds or 'paragraphs' in kwds:
        para = kwds.get('paragraph', kwds.get('para', 1))
        sel = idaapi.setup_selector(para)

    ## find a selector that is 1 paragraph size,
    elif idaapi.get_selector_qty():
        sel = idaapi.find_selector(1)

    # otherwise find a free one and set it.
    else:
        sel = idaapi.find_free_selector()
        idaapi.set_selector(sel, 1)

    # populate the segment_t for versions of IDA prior to 7.0
    if idaapi.__version__ < 7.0:
        seg = idaapi.segment_t()
        seg.startEA, seg.endEA = offset, offset + size

    # now for versions of IDA 7.0 and newer
    else:
        seg = idaapi.segment_t()
        seg.start_ea, seg.end_ea = offset, offset + size

    # assign the rest of the necessary attributes
    seg.sel = sel
    seg.bitness = {16:0,32:1,64:2}[bits]
    seg.comb = kwds.get('comb', idaapi.scPub)       # public
    seg.align = kwds.get('align', idaapi.saRelByte)  # paragraphs

    # now we can add our segment_t to the database
    res = utils.string.to(name)
    ok = idaapi.add_segm_ex(seg, res, "", idaapi.ADDSEG_NOSREG|idaapi.ADDSEG_SPARSE)
    if not ok:
        ok = idaapi.del_selector(sel)
        if not ok:
            logging.warning(u"{:s}.new({:#x}, {:+#x}, {!r}{:s}) : Unable to delete the created selector ({:#x}) for the new segment.".format(__name__, offset, size, name, u", {:s}".format(utils.string.kwargs(kwds)) if kwds else '', sel))
        raise E.DisassemblerError(u"{:s}.new({:#x}, {:+#x}, {!r}{:s}) : Unable to add a new segment.".format(__name__, offset, size, name, u", {:s}".format(utils.string.kwargs(kwds)) if kwds else ''))
    return seg
create = utils.alias(new)

def remove(segment, contents=False):
    """Remove the specified `segment`.

    If the bool `contents` is specified, then remove the contents of the segment from the database.
    """
    if not isinstance(segment, idaapi.segment_t):
        cls = segment.__class__
        raise E.InvalidParameterError(u"{:s}.remove({!r}) : Expected a `{:s}`, but received a {!s}.".format(__name__, segment, idaapi.segment_t.__name__, cls))

    # delete the selector defined by the segment_t
    res = idaapi.del_selector(segment.sel)
    if res == 0:
        logging.warning(u"{:s}.remove({!r}) : Unable to delete the selector {:#x}.".format(__name__, segment, segment.sel))

    # remove the actual segment using the address in the segment_t
    res = idaapi.del_segm(interface.range.start(segment), idaapi.SEGMOD_KILL if contents else idaapi.SEGMOD_KEEP)
    if res == 0:
        logging.warning(u"{:s}.remove({!r}) : Unable to delete the segment {:s} with the selector {:s}.".format(__name__, segment, segment.name, segment.sel))
    return res
delete = utils.alias(remove)

@utils.string.decorate_arguments('filename')
def save(filename, segment, offset=0):
    """Export the segment identified by `segment` to the file named `filename`.

    If the int `offset` is specified, then begin writing into the file at the specified offset.
    """
    if isinstance(segment, idaapi.segment_t):
        return __save_file(utils.string.to(filename), interface.range.start(segment), size(segment), offset)
    return save(filename, by(segment))
export = utils.alias(save)

#res = idaapi.add_segment_translation(ea, selector)
#res = idaapi.del_segment_translation(ea)


```

`base/structure.py`:

```py
"""
Structure module

This module exposes a number of tools and defines some classes that
can be used to interacting with the structures defined in the database.
The classes defined by this module wrap IDAPython's structure API and expose
a simpler interface that can be used to perform various operations
against a structure such as renaming or enumerating the structure's
members.

The base argument type for getting a ``structure_t`` can be either a name,
an identifier, or an index. Typically one will call ``structure.by``
with either identifier type which will then return an instance of their
``structure_t``.

To list the different structures available in the database, one can use
``structure.list`` with their chosen method of filtering. This will
list all of the available structures at which point the user can then
request it by passing an identifer to ``structure.by``. The chosen
methods of filtering are:

    `name` - Match the structures to a structure name
    `like` - Filter the structure names according to a glob
    `regex` - Filter the structure names according to a regular-expression
    `index` - Match the structures by its index
    `identifier` or `id` - Match the structure by its id which is a ``idaapi.uval_t``
    `size` - Filter the structures for any matching the specified size
    `greater` or `ge` - Match structures that are larger (inclusive) than the specified size
    `gt` - Match structures that are larger (exclusive) than the specified size
    `less` or `le` - Match structures that are smaller (inclusive) than the specified size
    `lt` - Match structures that are smaller (exclusive) than the specified size
    `predicate` - Filter the structures by passing the id (``idaapi.uval_t``) to a callable

Some examples of using these keywords are as follows::

    > structure.list('my*')
    > iterable = structure.iterate(regex='__.*')
    > result = structure.search(index=42)

"""

import six, builtins

import functools, operator, itertools, types
import sys, logging
import re, fnmatch

import database, instruction
import ui, internal
from internal import utils, interface, exceptions as E

import idaapi

def __instance__(identifier, **options):
    '''Create a new instance of the structure identified by `identifier`.'''
    return structure_t(identifier, **options)

__matcher__ = utils.matcher()
__matcher__.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), 'name')
__matcher__.mapping('index', idaapi.get_struc_idx, 'id')
__matcher__.attribute('identifier', 'id'), __matcher__.attribute('id', 'id')
__matcher__.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), 'name')
__matcher__.boolean('name', lambda name, item: item.lower() == name.lower(), 'name')
__matcher__.attribute('size', 'size')
__matcher__.boolean('greater', operator.le, 'size'), __matcher__.boolean('ge', operator.le, 'size')
__matcher__.boolean('gt', operator.lt, 'size')
__matcher__.boolean('less', operator.ge, 'size'), __matcher__.boolean('le', operator.ge, 'size')
__matcher__.boolean('lt', operator.gt, 'size')
__matcher__.predicate('predicate')
__matcher__.predicate('pred')

def __iterate__():
    '''Iterate through all structures defined in the database.'''
    res = idaapi.get_first_struc_idx()
    if res == idaapi.BADADDR: return

    while res not in { idaapi.get_last_struc_idx(), idaapi.BADADDR }:
        id = idaapi.get_struc_by_idx(res)
        yield __instance__(id)
        res = idaapi.get_next_struc_idx(res)

    res = idaapi.get_last_struc_idx()
    if res != idaapi.BADADDR:
        yield __instance__(idaapi.get_struc_by_idx(res))
    return

@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def iterate(string, *suffix):
    '''Iterate through all of the structures in the database with a glob that matches `string`.'''
    res = string if isinstance(string, tuple) else (string,)
    return iterate(like=interface.tuplename(*(res + suffix)))
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def iterate(**type):
    '''Iterate through all of the structures that match the keyword specified by `type`.'''
    if not type: type = {'predicate': lambda item: True}
    listable = [item for item in __iterate__()]
    for key, value in type.items():
        listable = [item for item in __matcher__.match(key, value, listable)]
    for item in listable: yield item

@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def list(string, *suffix):
    '''List any structures that match the glob in `string`.'''
    res = string if isinstance(string, tuple) else (string,)
    return list(like=interface.tuplename(*(res + suffix)))
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def list(**type):
    '''List all the structures within the database that match the keyword specified by `type`.'''
    res = [item for item in iterate(**type)]

    maxindex = max(builtins.map(utils.fcompose(operator.attrgetter('index'), "{:d}".format, len), res) if res else [1])
    maxname = max(builtins.map(utils.fcompose(operator.attrgetter('name'), utils.fdefault(''), len), res) if res else [1])
    maxsize = max(builtins.map(utils.fcompose(operator.attrgetter('size'), "{:+#x}".format, len), res) if res else [1])

    for st in res:
        six.print_(u"[{:{:d}d}] {:>{:d}s} {:<+#{:d}x} ({:d} members){:s}".format(idaapi.get_struc_idx(st.id), maxindex, st.name, maxname, st.size, maxsize, len(st.members), u" // {!s}".format(st.tag() if '\n' in st.comment else st.comment) if st.comment else ''))
    return

@utils.multicase(tag=six.string_types)
@utils.string.decorate_arguments('And', 'Or')
def select(tag, *And, **boolean):
    '''Query all of the structure tags for the specified `tag` and any others specified as `And`.'''
    res = {tag} | {item for item in And}
    boolean['And'] = {item for item in boolean.get('And', [])} | res
    return select(**boolean)
@utils.multicase()
@utils.string.decorate_arguments('And', 'Or')
def select(**boolean):
    """Query all the structures (linearly) for any tags specified by `boolean`. Yields each address found along with the matching tags as a dictionary.

    If `And` contains an iterable then require the returned structure contains them.
    If `Or` contains an iterable then include any other tags that are specified.
    """
    containers = (builtins.tuple, builtins.set, builtins.list)
    boolean = {key : {item for item in value} if isinstance(value, containers) else {value} for key, value in boolean.items()}

    # User is not asking for anything specifically, so just yield all the
    # structures that are available.
    if not boolean:
        for st in __iterate__():
            content = st.tag()

            # If we have any content, then the structure and its content
            # can be yielded to the user.
            if content:
                yield st, content
            continue
        return

    # Collect the tags we're supposed to look for in the typical lame way.
    Or, And = ({item for item in boolean.get(B, [])} for B in ['Or', 'And'])

    # Now we slowly iterate through our structures looking for matches,
    # while ensuring that we pop off any typeinfo since its not relevant.
    for st in __iterate__():
        collected, content = {}, st.tag()

        # Simply collect all tagnames being queried with Or(|).
        collected.update({key : value for key, value in content.items() if key in Or})

        # And(&) is a little more specific...
        if And:
            if And & six.viewkeys(content) == And:
                collected.update({key : value for key, value in content.items() if key in And})
            else: continue

        # That's all folks. Yield it if you got it.
        if collected: yield st, collected
    return

@utils.multicase(string=(six.string_types, tuple))
@utils.string.decorate_arguments('string', 'suffix')
def new(string, *suffix, **offset):
    """Return a new structure or union using the name specified by `string`.

    If the boolean `union` is provided, then create a union instead of a structure.
    If the integer `offset` is provided, then use it as the base offset for the newly created structure.
    """
    res = string if isinstance(string, tuple) else (string,)
    name = interface.tuplename(*(res + suffix))

    # add a structure with the specified name
    realname = utils.string.to(name)
    id = idaapi.add_struc(idaapi.BADADDR, realname, offset.get('union', False))
    if id == idaapi.BADADDR:
        raise E.DisassemblerError(u"{:s}.new({:s}{:s}) : Unable to add a new {:s} to the database with the specified name ({!r}).".format(__name__, ', '.join(map("{!r}".format, res + suffix)), u", {:s}".format(utils.string.kwargs(offset)) if offset else '', 'union' if offset.get('union', False) else 'structure', name))

    # return a new instance using the specified identifier
    return __instance__(id, **offset)

@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def search(string, *suffix):
    '''Search through all the structure names matching the glob `string`.'''
    res = string if isinstance(string, tuple) else (string,)
    return by(like=interface.tuplename(*(res + suffix)))
@utils.multicase()
def search(**type):
    '''Search through all of the structures and return the first result matching the keyword specified by `type`.'''
    return by(**type)

@utils.string.decorate_arguments('name', 'suffix')
def by_name(name, *suffix, **options):
    '''Return a structure by its name.'''
    string = name if isinstance(name, tuple) else (name,)
    res = utils.string.to(interface.tuplename(*(string + suffix)))

    # try and find the structure id according to its name
    id = idaapi.get_struc_id(res)
    if id == idaapi.BADADDR:
        raise E.StructureNotFoundError(u"{:s}.by_name(\"{:s}\"{:s}) : Unable to locate structure with given name.".format(__name__, utils.string.escape(name, '"'), u", {:s}".format(utils.string.kwargs(options)) if options else ''))

    # grab an instance of the structure by its id that we found
    return __instance__(id, **options)
byname = utils.alias(by_name)

def by_index(index, **options):
    '''Return a structure by its index.'''
    id = idaapi.get_struc_by_idx(index)
    if id == idaapi.BADADDR:
        raise E.StructureNotFoundError(u"{:s}.by_index({:d}{:s}) : Unable to locate structure at given index.".format(__name__, index, u", {:s}".format(utils.string.kwargs(options)) if options else ''))

    # grab an instance of the structure by the id we found
    return __instance__(id, **options)
byindex = utils.alias(by_index)

def by_identifier(identifier, **options):
    '''Return the structure identified by `identifier`.'''
    return __instance__(identifier, **options)

by_id = byidentifier = byId = utils.alias(by_identifier)

### structure_t abstraction
class structure_t(object):
    """
    This object is an abstraction around an IDA structure type. This
    allows for one to treat an IDA structure as a regular python object.
    A number of methods and properties are provided in order to access
    certain attributes of the structure.

    To access the members belonging to the structure, one can use the
    ``.members`` property. This property is intended to be treated as an
    array in order to access the different elements available. This
    property also allows a user to create a new member or remove an
    already existing one.
    """
    __slots__ = ('__ptr__', '__name__', '__members__')

    def __init__(self, sptr, offset=0):
        if not isinstance(sptr, (idaapi.struc_t, six.integer_types)):
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({!s}, offset={:+#x}) : Unable to instantiate a structure using the provided type ({!s}).".format('.'.join([__name__, cls.__name__]), sptr, offset, sptr))

        # Use the type of our parameter in order to get a proper
        # struc_t. If we didn't get one, then we likely got an identifier
        # that we need to use with idaapi.get_struc to get our sptr.
        ptr = sptr if isinstance(sptr, idaapi.struc_t) else idaapi.get_struc(sptr)
        if ptr is None:
            cls = self.__class__
            raise E.StructureNotFoundError(u"{:s}({!s}, offset={:+#x}) : Unable to locate the structure with the specified parameter ({!s}).".format('.'.join([__name__, cls.__name__]), sptr, offset, sptr))

        # After we verified our parameter and got a proper type, then
        # grab the name using its id. We cache both the sptr and the
        # structure's name in case one of them changes. This way we
        # can figure out the other one in that situation.
        name = idaapi.get_struc_name(ptr.id)
        self.__ptr__, self.__name__ = ptr, name

        # The final thing to do is instantiate the members property
        # so that users can interact with the structure members.
        self.__members__ = members_t(self, baseoffset=offset)

    @utils.multicase()
    def tag(self):
        '''Return the tags associated with the structure.'''
        repeatable = True

        # grab the repeatable and non-repeatable comment for the structure
        res = utils.string.of(idaapi.get_struc_cmt(self.id, False))
        d1 = internal.comment.decode(res)
        res = utils.string.of(idaapi.get_struc_cmt(self.id, True))
        d2 = internal.comment.decode(res)

        # check for duplicate keys
        if six.viewkeys(d1) & six.viewkeys(d2):
            cls = self.__class__
            logging.info(u"{:s}({:#x}).tag() : The repeatable and non-repeatable comment for structure {:s} use the same tags ({!r}). Giving priority to the {:s} comment.".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(self.name), ', '.join(six.viewkeys(d1) & six.viewkeys(d2)), 'repeatable' if repeatable else 'non-repeatable'))

        # merge the dictionaries into one and return it (XXX: return a dictionary that automatically updates the comment when it's updated)
        res = {}
        [res.update(d) for d in ([d1, d2] if repeatable else [d2, d1])]

        # Now we need to add implicit tags which are related to the structure.
        sptr = self.ptr

        # If we're a frame or we're unlisted, then we don't add the implicit
        # "__name__" tag. This way the user can select for "__name__" and use
        # it to distinguish local types and ghost types (which always have a name).
        excluded = ['SF_FRAME', 'SF_NOLIST']
        name = utils.string.of(idaapi.get_struc_name(sptr.id))
        if name and not any([sptr.props & getattr(idaapi, attribute) for attribute in excluded if hasattr(idaapi, attribute)]):
            res.setdefault('__name__', name)

        # Now we need to do the '__typeinfo__' tag. This is going to be a little
        # bit different than how we usually determine it, because we're going to
        # use it to determine whether the user created this type themselves or it
        # was created automatically. So, if it was copied from the type library
        # (SF_TYPLIB), from the local types (SF_GHOST), or the user chose not to
        # list it (SF_NOLIST), then we don't assign '__typeinfo__'.
        excluded = ['SF_FRAME', 'SF_GHOST', 'SF_TYPLIB', 'SF_NOLIST']
        if any([sptr.props & getattr(idaapi, attribute) for attribute in excluded if hasattr(idaapi, attribute)]):
            pass

        # SF_NOLIST is justified because if the user didn't want the structure to
        # be listed, then we're just doing as we're told. Everything else should
        # be justifiable because if the user did anything with the type, then
        # the other flags should've been cleared.
        else:
            ti = self.typeinfo
            ti_s = idaapi.print_tinfo('', 0, 0, 0, ti, '', '')
            res.setdefault('__typeinfo__', ti_s)
        return res
    @utils.multicase(key=six.string_types)
    @utils.string.decorate_arguments('key')
    def tag(self, key):
        '''Return the tag identified by `key` belonging to the structure.'''
        res = self.tag()
        if key in res:
            return res[key]
        cls = self.__class__
        raise E.MissingTagError(u"{:s}({:#x}).tag({!r}) : Unable to read the non-existing tag named \"{:s}\" from the structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, utils.string.escape(key, '"'), utils.string.repr(self.name)))
    @utils.multicase(key=six.string_types)
    @utils.string.decorate_arguments('key', 'value')
    def tag(self, key, value):
        '''Set the tag identified by `key` to `value` for the structure.'''
        repeatable = True

        # Guard against a bunk type being used to set the value.
        if value is None:
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({:#x}).tag({!r}, {!r}) : Tried to set the tag named \"{:s}\" with an unsupported type {!r}.".format('.'.join([__name__, cls.__name__]), self.id, key, value, utils.string.escape(key, '"'), value))

        # First we need to read both comments to figure out what the user is trying to say.
        comment_right = utils.string.of(idaapi.get_struc_cmt(self.id, repeatable))
        comment_wrong = utils.string.of(idaapi.get_struc_cmt(self.id, not repeatable))

        # Decode the tags that are written to both comment types to figure out which
        # comment type the user actually means. The logic here reads weird because the
        # "repeatable" variable toggles which comment to give priority. We explicitly
        # check the "wrong" place but fall back to the "right" one.
        state_right, state_wrong = map(internal.comment.decode, [comment_right, comment_wrong])
        state, where = (state_right, repeatable) if key in state_right else (state_wrong, not repeatable) if key in state_wrong else (state_right, repeatable)

        # If there were any duplicate keys in any of the dicts, then warn the user about it.
        duplicates = six.viewkeys(state_right) & six.viewkeys(state_wrong)
        if key in duplicates:
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).tag({!r}, {!r}) : The repeatable and non-repeatable comment for structure {:s} use the same tags ({!r}). Giving priority to the {:s} comment.".format('.'.join([__name__, cls.__name__]), self.id, key, value, utils.string.repr(self.name), ', '.join(duplicates), 'repeatable' if where else 'non-repeatable'))

        # Now we can just update the dict and re-encode to the proper comment location.
        res, state[key] = state.get(key, None), value
        if not idaapi.set_struc_cmt(self.id, utils.string.to(internal.comment.encode(state)), where):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to update the {:s} comment for the structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, value, 'repeatable' if where else 'non-repeatable', utils.string.repr(self.name)))
        return res
    @utils.multicase(key=six.string_types, none=None.__class__)
    @utils.string.decorate_arguments('key')
    def tag(self, key, none):
        '''Removes the tag specified by `key` from the structure.'''
        repeatable = True

        # First we check if the key is one of the implicit tags that we support. These
        # aren't we can modify since they only exist in special circumstances.
        if key in {'__name__', '__typeinfo__'} and key in self.tag():
            message_typeinfo = 'modified by the user from the default type library'
            message_name = 'flagged as listed by the user'

            # The characteristics aren't actually documented anywhere, so we'll raise an
            # exception that attempts to describe what causes them to exist. Hopefully
            # the user figures out that they can use them to find structures they created.
            cls, message = self.__class__, message_typeinfo if key == '__typeinfo__' else message_name
            raise E.InvalidParameterError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to remove the implicit tag \"{:s}\" due to the structure being {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, none, utils.string.escape(key, '"'), message))

        # We need to read both comments to figure out where the tag is that we're trying to remove.
        comment_right = utils.string.of(idaapi.get_struc_cmt(self.id, repeatable))
        comment_wrong = utils.string.of(idaapi.get_struc_cmt(self.id, not repeatable))

        # Decode the tags that are written to both comment types, and then test them
        # to figure out which comment the key is encoded in. In this, we want
        # "repeatable" to be a toggle and we want to default to the selected comment.
        state_right, state_wrong = map(internal.comment.decode, [comment_right, comment_wrong])
        state, where = (state_right, repeatable) if key in state_right else (state_wrong, not repeatable) if key in state_wrong else (state_right, repeatable)

        # If the key isn't where we expect it, then raise an exception since we can't
        # remove it if it doesn't actually exist.
        if key not in state:
            cls = self.__class__
            raise E.MissingTagError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to remove non-existing tag \"{:s}\" from the structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, none, utils.string.escape(key, '"'), utils.string.repr(self.name)))

        # If the key is in both dictionaries, then be kind and warn the user about it
        # so that they'll know that their key will still be part of the dict.
        duplicates = six.viewkeys(state_right) & six.viewkeys(state_wrong)
        if key in (six.viewkeys(state_right) & six.viewkeys(state_wrong)):
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).tag({!r}, {!r}) : The repeatable and non-repeatable comment for structure {:s} use the same tags ({!r}). Giving priority to the {:s} comment.".format('.'.join([__name__, cls.__name__]), self.id, key, none, utils.string.repr(self.name), ', '.join(duplicates), 'repeatable' if where else 'non-repeatable'))

        # Now we can just pop the value out of the dict and re-encode back into the comment.
        res = state.pop(key)
        if not idaapi.set_struc_cmt(self.id, utils.string.to(internal.comment.encode(state)), where):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to update the {:s} comment for the structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, none, 'repeatable' if repeatable else 'non-repeatable', utils.string.repr(self.name)))
        return res

    def destroy(self):
        '''Remove the structure from the database.'''
        return idaapi.del_struc(self.ptr)

    def field(self, offset):
        '''Return the member at the specified offset.'''
        return self.members.by_offset(offset + self.members.baseoffset)

    def copy(self, name):
        '''Copy members into the structure `name`.'''
        raise NotImplementedError

    def contains(self, offset):
        '''Return whether the specified `offset` is contained by the structure.'''
        res, cb = self.members.baseoffset, idaapi.get_struc_size(self.ptr)
        return res <= offset < res + cb

    def refs(self):
        '''Return all the structure members and operand references which reference this specific structure.'''
        Fnetnode = getattr(idaapi, 'ea2node', utils.fidentity)
        FF_STRUCT = idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU

        # First collect all of our identifiers referenced by this structure,
        # whilst making sure to include all the members too.
        iterable = itertools.chain([self.id], map(Fnetnode, map(operator.attrgetter('id'), self.members)))
        items = [identifier for identifier in iterable]

        # Now we need to iterate through all of our members and grab references
        # to those identifiers too.
        refs = []
        for identifier in items:
            X = idaapi.xrefblk_t()

            # Grab the very first reference for the given identifier.
            if not X.first_to(identifier, idaapi.XREF_ALL) or X.frm == idaapi.BADADDR:
                continue
            refs.append((X.frm, X.iscode, X.type))

            # Continue and grab the rest of the references too.
            while X.next_to():
                refs.append((X.frm, X.iscode, X.type))
            continue

        # That should've given us absolutely every reference related to this
        # structure, so the last thing to do is to filter our list for references
        # to addresses within the database.
        results, matches = {item for item in []}, {identifier for identifier in items}
        for xrfrom, xriscode, xrtype in refs:

            # If the reference is an identifier, then it's not what we're looking
            # for as this method only cares about database addresses.
            if interface.node.is_identifier(xrfrom):
                continue

            # We need to figure out whether this is code or not, because if so
            # then this'll be ref'd by an operand and we'll need to figure it out.
            if database.type.is_code(xrfrom):

                # Iterate through all of its operands and only care about the
                # ones that have operand information for it. We also keep track
                # of any operands that have a refinfo_t so we can add those too.
                references = {item for item in []}
                for opnum, _ in enumerate(instruction.operands(xrfrom)):

                    # Collect the operand information into a proper path in case
                    # the opinfo_t is damaged...which happens sometimes.
                    ofs, path = interface.node.get_stroff_path(xrfrom, opnum)

                    # If we grabbed a path, then we can use it to grab the
                    # structure and all of its member identifiers.
                    if path:
                        _, members = interface.node.calculate_stroff_path(ofs, path)

                        # Now we need to convert these pairs into a set so that we can
                        # test their membership.
                        iterable = itertools.chain(*(map(operator.attrgetter('id'), pair) for pair in members))
                        candidates = {identifier for identifier in iterable}

                        # Verify that one of our ids is contained within it.
                        if candidates & matches:
                            state = instruction.op_state(xrfrom, opnum)
                            item = interface.opref_t(xrfrom, opnum, interface.reftype_t.of_action(state))
                            results.add(item)
                        continue

                    # Otherwise this is likely a refinfo, and we need to follow
                    # the reference in order to grab _all_ of its references.
                    drefs = [ea for ea in database.xref.down(xrfrom) if not interface.node.is_identifier(ea)]
                    references |= {ea for ea in itertools.chain(*map(database.xref.up, drefs))}

                # Last thing to do is to add the references that we collected while
                # searching through the operands.
                for ea in references:
                    for opnum in range(instruction.ops_count(ea)):
                        if interface.address.refinfo(ea, opnum):
                            state = instruction.op_state(ea, opnum)
                            results.add(interface.opref_t(ea, opnum, interface.reftype_t.of_action(state)))
                            continue

                        # Do a final check to see if we can resolve a structure member.
                        try:
                            instruction.op_structure(ea, opnum)
                        except Exception:
                            pass

                        # And if so, then we can add the opref_t.
                        else:
                            state = instruction.op_state(ea, opnum)
                            results.add(interface.opref_t(ea, opnum, interface.reftype_t.of_action(state)))
                        continue
                    continue

            # Anything else is data which doesn't have an operand associated with
            # it, so we can just use the regular ref_t for this case. We use '*'
            # for the reference type since this is being applied to an address.
            else:
                item = interface.ref_t(xrfrom, None, interface.reftype_t.of_action('*'))
                results.add(item)
            continue
        return sorted(results)

    def up(self):
        '''Return all structure or frame members within the database that reference this particular structure.'''
        X, sid = idaapi.xrefblk_t(), self.id

        # Grab the first reference to the structure.
        if not X.first_to(sid, idaapi.XREF_ALL):
            return []

        # Continue to grab all the rest of its references.
        refs = [(X.frm, X.iscode, X.type)]
        while X.next_to():
            refs.append((X.frm, X.iscode, X.type))

        # Iterate through each reference figuring out if our structure's id is
        # applied to another structure type.
        res = []
        for ref, _, _ in refs:

            # If the reference is not an identifier, then we don't care about it because
            # it's pointing to code and the structure_t.refs method is for those refs.
            if not interface.node.is_identifier(ref):
                continue

            # Get mptr, full member name, and sptr for the reference (which should
            # totally be an identifier due to the previous conditional).
            mpack = idaapi.get_member_by_id(ref)
            if mpack is None:
                cls = self.__class__
                raise E.MemberNotFoundError(u"{:s}({:#x}).refs() : Unable to locate the member identified by {:#x}.".format('.'.join([__name__, cls.__name__]), self.id, ref))

            mptr, name, sptr = mpack
            if not interface.node.is_identifier(sptr.id):
                sptr = idaapi.get_member_struc(idaapi.get_member_fullname(mptr.id))

            # Validate that the type of the mptr is what we're expecting.
            if not isinstance(mptr, idaapi.member_t):
                cls, name = self.__class__, idaapi.get_member_fullname(ref)
                raise E.InvalidTypeOrValueError(u"{:s}({:#x}).refs() : Unexpected type {!s} returned for member \"{:s}\".".format('.'.join([__name__, cls.__name__]), self.id, mptr.__class__, internal.utils.string.escape(name, '"')))

            # Figure out from mptr identifier if we're referencing a function frame.
            frname, _ = name.split('.', 1)
            frid = internal.netnode.get(frname)
            ea = idaapi.get_func_by_frame(frid)

            # If we were unable to get the function frame, then we must be
            # referencing the member of another structure.
            if ea == idaapi.BADADDR:
                st = by_identifier(sptr.id)
                mem = st.members.by_identifier(mptr.id)
                res.append(mem)
                continue

            # Otherwise we're referencing a frame member, and we need to grab
            # the frame for that function.
            fr = idaapi.get_frame(ea)
            if fr is None:
                cls = self.__class__
                raise E.MissingTypeOrAttribute(u"{:s}({:#x}).refs() : The function at {:#x} for frame member {:#x} does not have a frame.".format('.'.join([__name__, cls.__name__]), self.id, ea, mptr.id))

            # We'll also need the idaapi.func_t for the function.
            f = idaapi.get_func(ea)
            if f is None:
                cls = self.__class__
                raise E.FunctionNotFoundError(u"{:s}({:#x}).refs() : Unable to locate the function for frame member {:#x} by address {:#x}.".format('.'.join([__name__, cls.__name__]), self.id, mptr.id, ea))

            # So we can instantiate the structure with the correct offset
            # and then grab the member that was being referenced.
            st = by_identifier(fr.id, offset=-idaapi.frame_off_args(f))
            mem = st.members.by_identifier(mptr.id)
            res.append(mem)
        return res

    ### Properties
    @property
    def ptr(self):
        '''Return the pointer of the ``idaapi.struc_t``.'''
        ptr, name = self.__ptr__, self.__name__

        # If the pointer has been deleted out from underneath us,
        # then we need to raise an exception to inform the user.
        if ptr is None:
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({!r}).ptr : The structure with the name (\"{:s}\") is currently unavailable and was likely removed from the database.".format('.'.join([__name__, cls.__name__]), name, utils.string.escape(name, '"')))

        # Verify if our ptr is still within scope by verifying
        # that its identifier is valid. Otherwise we need to use
        # the name that we've cached to fetch it.
        identifier = ptr.id if interface.node.is_identifier(ptr.id) else idaapi.get_struc_id(name)

        # Now we can check if we okay with returning the ptr. We also
        # update our cached name with whatever the current name is.
        if identifier == ptr.id:
            result, self.__name__ = ptr, idaapi.get_struc_name(identifier)

        # Otherwise we need to use the identifier to grab the
        # sptr from the identifier we just grabbed.
        else:
            result = self.__ptr__ = idaapi.get_struc(identifier)

        # Do one final check on our result to make sure that we actually
        # got something in case we're racing against SWIG's removal of it.
        if result:
            return result

        # This means that we lost the race against SWIG, and it scoped
        # out our result before we got a chance to actually use it...
        cls = self.__class__
        raise E.DisassemblerError(u"{:s}({!r}).ptr : The structure with the name (\"{:s}\") is currently unavailable and was likely removed from the database.".format('.'.join([__name__, cls.__name__]), name, utils.string.escape(name, '"')))

    @property
    def id(self):
        '''Return the identifier of the structure.'''
        return self.ptr.id
    @property
    def properties(self):
        '''Return the properties for the current structure.'''
        return self.ptr.props
    @property
    def members(self):
        '''Return the members belonging to the structure.'''
        return self.__members__

    @property
    def name(self):
        '''Return the name of the structure.'''
        ptr = self.__ptr__

        # if there's no pointer, then use the name that we have cached, but
        # make sure we log a critical message for the user to freak out about.
        if ptr is None:
            cls, name = self.__class__, self.__name__
            logging.critical(u"{:s}({!r}).name : Returning the cached name (\"{:s}\") for a structure that is unavailable and was likely removed from the database.".format('.'.join([__name__, cls.__name__]), name, utils.string.escape(name, '"')))
            return name

        # otherwise we can extract the identifier and get the actual name, but
        # go figure that sometimes IDAPython will return None when the structure
        # was deleted, so we need to check what it actually gave us.
        res = idaapi.get_struc_name(ptr.id)
        if res is not None:
            return utils.string.of(res)

        # if the name is undefined, then we actually have to raise an exception.
        cls, name = self.__class__, self.__name__
        if name is None:
            raise E.DisassemblerError(u"{:s}({:#x}).name : The structure with the identifier ({:#x}) is currently unavailable and was likely removed from the database.".format('.'.join([__name__, cls.__name__]), ptr.id, ptr.id))

        # otherwise, we can return the one that's cached while logging a message.
        logging.critical(u"{:s}({!r}).name : Returning the cached name (\"{:s}\") for a structure that is unavailable and was likely removed from the database.".format('.'.join([__name__, cls.__name__]), name, utils.string.escape(name, '"')))
        return name

    @name.setter
    @utils.string.decorate_arguments('string')
    def name(self, string):
        '''Set the name of the structure to `string`.'''
        if isinstance(string, tuple):
            string = interface.tuplename(*string)

        # convert the specified string into a form that IDA can handle
        ida_string = utils.string.to(string)

        # validate the name
        res = idaapi.validate_name2(ida_string[:]) if idaapi.__version__ < 7.0 else idaapi.validate_name(ida_string[:], idaapi.VNT_VISIBLE)
        if ida_string and ida_string != res:
            cls = self.__class__
            logging.info(u"{:s}({:#x}).name({!r}) : Stripping invalid chars from structure name \"{:s}\" resulted in \"{:s}\".".format('.'.join([__name__, cls.__name__]), self.id, string, utils.string.escape(string, '"'), utils.string.escape(utils.string.of(res), '"')))
            ida_string = res

        # now we can set the name of the structure
        oldname = idaapi.get_struc_name(self.id)
        if not idaapi.set_struc_name(self.id, ida_string):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).name({!r}) : Unable to assign the specified name ({:s}) to the structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, string, utils.string.repr(ida_string), utils.string.repr(oldname)))

        # verify that the name was actually assigned properly
        assigned = idaapi.get_struc_name(self.id) or ''
        if utils.string.of(assigned) != utils.string.of(ida_string):
            cls = self.__class__
            logging.info(u"{:s}({:#x}).name({!r}) : The name ({:s}) that was assigned to the structure does not match what was requested ({:s}).".format('.'.join([__name__, cls.__name__]), self.id, string, utils.string.repr(utils.string.of(assigned)), utils.string.repr(ida_string)))
        return assigned

    @property
    def comment(self, repeatable=True):
        '''Return the repeatable comment for the structure.'''
        res = idaapi.get_struc_cmt(self.id, repeatable) or idaapi.get_struc_cmt(self.id, not repeatable)
        return utils.string.of(res)
    @comment.setter
    @utils.string.decorate_arguments('value')
    def comment(self, value, repeatable=True):
        '''Set the repeatable comment for the structure to `value`.'''
        res = utils.string.to(value or '')
        if not idaapi.set_struc_cmt(self.id, res, repeatable):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).comment(..., repeatable={!s}) : Unable to assign the provided comment to the structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, repeatable, utils.string.repr(self.name)))

        # verify that the comment was actually assigned
        assigned = idaapi.get_struc_cmt(self.id, repeatable)
        if utils.string.of(assigned) != utils.string.of(res):
            cls = self.__class__
            logging.info(u"{:s}({:#x}).comment(..., repeatable={!s}) : The comment ({:s}) that was assigned to the structure does not match what was requested ({:s}).".format('.'.join([__name__, cls.__name__]), self.id, repeatable, utils.string.repr(utils.string.of(assigned)), utils.string.repr(res)))
        return assigned

    @property
    def size(self):
        '''Return the size of the structure.'''
        return idaapi.get_struc_size(self.ptr)
    @size.setter
    def size(self, size):
        '''Expand the structure to the new `size` that is specified.'''
        res = idaapi.get_struc_size(self.ptr)
        if not idaapi.expand_struc(self.ptr, 0, size - res, True):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).size({:+d}) : Unable to resize structure \"{:s}\" from {:#x} bytes to {:#x} bytes.".format('.'.join([__name__, cls.__name__]), self.id, size, utils.string.escape(self.name, '"'), res, size))

        res = idaapi.get_struc_size(self.ptr)
        if res != size:
            cls = self.__class__
            logging.info(u"{:s}({:#x}).size({:+d}) : The size that was assigned to the structure ({:+d}) does not match what was requested ({:+d}).".format('.'.join([__name__, cls.__name__]), self.id, size, res, size))
        return res

    @property
    def offset(self):
        '''Return the base offset of the structure.'''
        return self.members.baseoffset
    @offset.setter
    def offset(self, offset):
        '''Set the base offset of the structure to `offset`.'''
        res, self.members.baseoffset = self.members.baseoffset, offset
        return res
    @property
    def index(self):
        '''Return the index of the structure.'''
        return idaapi.get_struc_idx(self.id)
    @index.setter
    def index(self, index):
        '''Set the index of the structure to `idx`.'''
        res = idaapi.get_struc_idx(self.id)
        if not idaapi.set_struc_idx(self.ptr, index):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).index({:+d}) : Unable to modify the index of structure \"{:s}\" from {:d} to index {:d}.".format('.'.join([__name__, cls.__name__]), self.id, index, utils.string.escape(self.name, '"'), res, index))

        res = idaapi.get_struc_idx(self.id)
        if res != index:
            logging.info(u"{:s}({:#x}).index({:+d}) : The index that the structure was moved to ({:#x}) does not match what was requested ({:d}).".format('.'.join([__name__, cls.__name__]), self.id, index, res, index))
        return res
    @property
    def ordinal(self):
        '''Return the ordinal number of the structure within the current type library.'''
        sptr = self.ptr
        return max(0, sptr.ordinal)

    @property
    def typeinfo(self):
        '''Return the type information of the current structure.'''
        ti = database.type(self.id)

        # If there was no type information found for the member, then raise
        # an exception to the caller because structures _are_ types and thus
        # this should never fail.
        if ti is None:
            cls = self.__class__
            raise E.MissingTypeOrAttribute(u"{:s}({:#x}).typeinfo : Unable to determine the type information for structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, self.name))

        # Otherwise it worked and we can return it to the caller.
        return ti
    @typeinfo.setter
    def typeinfo(self, info):
        '''Sets the type information of the current structure to `info`.'''
        try:
            ti = database.type(self.id, info)

        # If we caught a TypeError, then we received a parsing error that
        # we should re-raise for the user.
        except E.InvalidTypeOrValueError:
            cls = self.__class__
            raise E.InvalidTypeOrValueError(u"{:s}({:#x}).typeinfo({!s}) : Unable to parse the specified type declaration ({!s}).".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(info), info))

        # If we caught an exception trying to get the typeinfo for the
        # structure, then port it to our class and re-raise.
        except E.DisassemblerError:
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).typeinfo({!s}) : Unable to apply `idaapi.tinfo_t()` to structure {:s}.".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(info), self.name))
        return

    @property
    def realbounds(self):
        sptr = self.ptr
        return interface.bounds_t(0, idaapi.get_struc_size(self.ptr))

    @property
    def bounds(self):
        bounds, base = self.realbounds, self.members.baseoffset
        return operator.add(bounds, base)

    ### Private methods
    def __str__(self):
        '''Render the current structure in a readable format.'''
        sptr, name, offset, size, comment, tag = self.ptr, self.name, self.offset, self.size, self.comment or '', self.tag()
        return "<class '{:s}' name={!s}{:s} size={:#x}>{:s}".format('union' if is_union(sptr) else 'structure', utils.string.repr(name), (" offset={:#x}".format(offset) if offset != 0 else ''), size, " // {!s}".format(utils.string.repr(tag) if '\n' in comment else utils.string.to(comment)) if comment else '')

    def __unicode__(self):
        '''Render the current structure in a readable format.'''
        sptr, name, offset, size, comment, tag = self.ptr, self.name, self.offset, self.size, self.comment or '', self.tag()
        return u"<class '{:s}' name={!s}{:s} size={:#x}>{:s}".format('union' if is_union(sptr) else 'structure', utils.string.repr(name), (" offset={:#x}".format(offset) if offset != 0 else ''), size, " // {!s}".format(utils.string.repr(tag) if '\n' in comment else utils.string.to(comment)) if comment else '')

    def __repr__(self):
        return u"{!s}".format(self)

    def __getattr__(self, name):
        return getattr(self.members, name)

    def __contains__(self, member):
        '''Return whether the specified `member` is contained by this structure.'''
        if not isinstance(member, member_t):
            raise TypeError(member)
        return member in self.members

    ## Hashable
    def __hash__(self):
        return self.ptr.id

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if isinstance(other, idaapi.struc_t):
            return self.ptr.id == other.id
        elif isinstance(other, structure_t):
            return self.ptr.id == other.ptr.id
        return False

    ## Serialization
    def __getstate__(self):
        sptr = self.ptr

        # grab the index
        idx = idaapi.get_struc_idx(sptr.id)

        # then its name
        name = utils.string.of(idaapi.get_struc_name(sptr.id) or '')

        # decode the comments that we found in the structure
        cmtt, cmtf = map(functools.partial(idaapi.get_struc_cmt, self.id), [True, False])
        comments = tuple(utils.string.of(cmt) for cmt in [cmtt, cmtf])

        # pack our state into a tuple.
        state = idx, sptr.props, name, comments

        # FIXME: is there anything other attributes that we might need?
        return state, self.members
    def __setstate__(self, state):

        # Restore the index (discarded), properties, name, and comments.
        if len(state) == 2:
            state, members = state
            idx, props, name, (cmtt, cmtf) = state

        # For backwards compatibility...
        else:
            name, (cmtt, cmtf), members = state
            idx, props = -1, 0

        # try and find the structure in the database by its name
        res = utils.string.to(name)
        identifier = idaapi.get_struc_id(res)

        # if we didn't find it, then just add it and notify the user
        if identifier == idaapi.BADADDR:
            cls = self.__class__
            logging.info(u"{:s}({:#x}) : Creating structure \"{:s}\" with {:d} fields and the comment \"{:s}\".".format('.'.join([__name__, cls.__name__]), self.id, utils.string.escape(name, '"'), len(members), utils.string.escape(cmtf or cmtt or '', '"')))
            res = utils.string.to(name)
            identifier = idaapi.add_struc(idaapi.BADADDR, res, True if props & idaapi.SF_UNION else False)

        # now we can apply the comments to it
        idaapi.set_struc_cmt(identifier, utils.string.to(cmtt), True)
        idaapi.set_struc_cmt(identifier, utils.string.to(cmtf), False)

        # set its individual properties (ignoring SF_FRAME and SF_GHOST of course)
        sptr = idaapi.get_struc(identifier)
        idaapi.set_struc_listed(sptr, False if props & idaapi.SF_NOLIST else True)
        idaapi.set_struc_hidden(sptr, True if props & idaapi.SF_HIDDEN else False)
        idaapi.set_struc_align(sptr, (props & idaapi.SF_ALIGN) >> 7)

        # we don't really bother with changing the index, because we
        # want to be able to preserve the order when they're added.
        if False and 0 <= idx < idaapi.get_struc_qty():
            if idaapi.get_struc_by_idx(idx) == idaapi.BADADDR:
                idaapi.set_struc_idx(sptr, idx)

        # and set its attributes properly
        self.__ptr__, self.__name__ = idaapi.get_struc(sptr.id), name
        self.__members__ = members
        return

### Functions that are related to finding and using a structure_t.
@utils.multicase(id=six.integer_types)
def has(id):
    '''Return whether a structure with the specified `id` exists within the database.'''
    return True if interface.node.is_identifier(id) and idaapi.get_struc(id) else False
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name', 'suffix')
def has(name, *suffix):
    '''Return if a structure with the specified `name` exists within the database.'''
    string = name if isinstance(name, tuple) else (name,)
    res = utils.string.to(interface.tuplename(*(string + suffix)))
    return has(idaapi.get_struc_id(res))
@utils.multicase(structure=(idaapi.struc_t, structure_t))
def has(structure):
    '''Return whether the database includes the provided `structure`.'''
    return has(structure.id)
@utils.multicase(tinfo=idaapi.tinfo_t)
def has(tinfo):
    '''Return whether the database includes a structure for the specified `tinfo`.'''
    if tinfo.is_struct():
        return has(tinfo.get_type_name())

    # If the type information we were given is a pointer, then dereference it
    # and recurse until we get to a structure type of some sort.
    pi = idaapi.ptr_type_data_t()
    if tinfo.is_ptr() and tinfo.has_details() and tinfo.get_ptr_details(pi):
        return has(pi.obj_type)
    return False

@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name', 'suffix')
def by(name, *suffix, **options):
    '''Return the structure with the given `name`.'''
    return by_name(name, *suffix, **options)
@utils.multicase(id=six.integer_types)
def by(id, **options):
    '''Return the structure with the specified `id` or index.'''
    if interface.node.is_identifier(id):
        return __instance__(id, **options)
    return by_index(id, **options)
@utils.multicase(sptr=(idaapi.struc_t, structure_t))
def by(sptr, **options):
    '''Return the structure for the specified `sptr`.'''
    return __instance__(sptr.id, **options)
@utils.multicase(tinfo=idaapi.tinfo_t)
def by(tinfo, **options):
    '''Return the structure for the specified `tinfo`.'''
    if tinfo.is_struct():
        return by_name(tinfo.get_type_name(), **options)

    # If the type information is not a pointer, then we really don't know what
    # to do with this and so we raise an exception.
    elif not tinfo.is_ptr():
        raise E.InvalidTypeOrValueError(u"{:s}.by(\"{:s}\"{:s}) : Unable to locate structure for the provided type information ({!r}).".format(__name__, utils.string.escape("{!s}".format(tinfo), '"'), u", {:s}".format(utils.string.kwargs(options)) if options else '', "{!s}".format(tinfo)))

    # If there are no details, then raise an exception because we need to
    # dereference the pointer to get the real name.
    if not tinfo.has_details():
        raise E.DisassemblerError(u"{:s}.by(\"{:s}\"{:s}) : The provided type information ({!r}) does not contain any details.".format(__name__, utils.string.escape("{!s}".format(tinfo), '"'), u", {:s}".format(utils.string.kwargs(options)) if options else '', "{!s}".format(tinfo)))

    # Now we can grab our pointer and extract the object from it, At this
    # point we continue by recursing back into ourselves. This way we can
    # repeatedly dereference a pointer until we get to a structure.
    pi = idaapi.ptr_type_data_t()
    if not tinfo.get_ptr_details(pi):
        raise E.DisassemblerError(u"{:s}.by(\"{:s}\"{:s}) : Unable to get the pointer target from the provided type information ({!r}).".format(__name__, utils.string.escape("{!s}".format(tinfo), '"'), u", {:s}".format(utils.string.kwargs(options)) if options else '', "{!s}".format(tinfo)))
    return by(pi.obj_type, **options)
@utils.multicase()
@utils.string.decorate_arguments('regex', 'like', 'name')
def by(**type):
    '''Return the structure matching the keyword specified by `type`.'''
    searchstring = utils.string.kwargs(type)

    listable = [item for item in iterate(**type)]
    if len(listable) > 1:
        messages = ((u"[{:d}] {:s}".format(idaapi.get_struc_idx(st.id), st.name)) for i, st in enumerate(listable))
        [ logging.info(msg) for msg in messages ]
        logging.warning(u"{:s}.search({:s}) : Found {:d} matching results, returning the first one {!s}.".format(__name__, searchstring, len(listable), listable[0]))

    iterable = (item for item in listable)
    res = next(iterable, None)
    if res is None:
        raise E.SearchResultsError(u"{:s}.search({:s}) : Found 0 matching results.".format(__name__, searchstring))
    return res

@utils.multicase()
def name(id):
    '''Return the name of the structure identified by `id`.'''
    res = idaapi.get_struc_name(id)
    return utils.string.of(res)
@utils.multicase(structure=structure_t)
def name(structure):
    return name(structure.id)
@utils.multicase(string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def name(id, string, *suffix):
    '''Set the name of the structure identified by `id` to `string`.'''
    res = (string,) + suffix
    string = interface.tuplename(*res)

    # convert the specified string into a form that IDA can handle
    ida_string = utils.string.to(string)

    # validate the name
    res = idaapi.validate_name2(ida_string[:]) if idaapi.__version__ < 7.0 else idaapi.validate_name(ida_string[:], idaapi.VNT_VISIBLE)
    if ida_string and ida_string != res:
        logging.info(u"{:s}.name({!r}, {!r}) : Stripping invalid chars from the structure name \"{:s}\" resulted in \"{:s}\".".format(__name__, id, string, utils.string.escape(string, '"'), utils.string.escape(utils.string.of(res), '"')))
        ida_string = res

    # now we can set the name of the structure
    return idaapi.set_struc_name(id, ida_string)
@utils.multicase(structure=structure_t, string=six.string_types)
@utils.string.decorate_arguments('string', 'suffix')
def name(structure, string, *suffix):
    '''Set the name of the specified `structure` to `string`.'''
    return name(structure.id, string, *suffix)

@utils.multicase(id=six.integer_types)
def comment(id, **repeatable):
    """Return the comment of the structure identified by `id`.

    If the bool `repeatable` is specified, return the repeatable comment.
    """
    res = idaapi.get_struc_cmt(id, repeatable.get('repeatable', True))
    return utils.string.of(res)
@utils.multicase(structure=structure_t)
def comment(structure, **repeatable):
    '''Return the comment for the specified `structure`.'''
    return comment(structure.id, **repeatable)
@utils.multicase(structure=structure_t, cmt=six.string_types)
@utils.string.decorate_arguments('cmt')
def comment(structure, cmt, **repeatable):
    '''Set the comment to `cmt` for the specified `structure`.'''
    return comment(structure.id, cmt, **repeatable)
@utils.multicase(structure=structure_t, none=None.__class__)
def comment(structure, none, **repeatable):
    '''Remove the comment from the specified `structure`.'''
    return comment(structure.id, none or '', **repeatable)
@utils.multicase(id=six.integer_types, cmt=six.string_types)
@utils.string.decorate_arguments('cmt')
def comment(id, cmt, **repeatable):
    """Set the comment of the structure identified by `id` to `cmt`.

    If the bool `repeatable` is specified, set the repeatable comment.
    """
    res = utils.string.to(cmt)
    return idaapi.set_struc_cmt(id, res, repeatable.get('repeatable', True))
@utils.multicase(id=six.integer_types, none=None.__class__)
def comment(id, none, **repeatable):
    '''Remove the comment from the structure identified by `id`.'''
    return comment(id, none or '', **repeatable)

@utils.multicase(id=six.integer_types)
def index(id):
    '''Return the index of the structure identified by `id`.'''
    return idaapi.get_struc_idx(id)
@utils.multicase(structure=structure_t)
def index(structure):
    '''Return the index of the specified `structure`.'''
    return index(structure.id)
@utils.multicase(id=six.integer_types, index=six.integer_types)
def index(id, index):
    '''Move the structure identified by `id` to the specified `index` in the structure list.'''
    return idaapi.set_struc_idx(id, index)
@utils.multicase(structure=structure_t, index=six.integer_types)
def index(structure, index):
    '''Move the specified `structure` to the specified `index` in the structure list.'''
    return index(structure.id, index)

@utils.multicase(structure=structure_t)
def size(structure):
    '''Return the size of the specified `structure`.'''
    return size(structure.id)
@utils.multicase(id=six.integer_types)
def size(id):
    '''Return the size of the structure identified by `id`.'''
    return idaapi.get_struc_size(id)

@utils.multicase(id=six.integer_types)
def is_union(id):
    '''Return whether the structure identified by `id` is a union or not.'''
    sptr = idaapi.get_struc(id)
    if sptr:
        return is_union(sptr)
    raise E.StructureNotFoundError(u"{:s}.is_union({:#x}) : Unable to find the requested structure ({:#x}).".format(__name__, id, id))
@utils.multicase(structure=(idaapi.struc_t, structure_t))
def is_union(structure):
    '''Return whether the provided `structure` is defined as a union.'''
    SF_UNION = getattr(idaapi, 'SF_UNION', 0x2)
    sptr = structure if isinstance(structure, idaapi.struc_t) else structure.ptr
    return True if sptr.props & SF_UNION else False
unionQ = isunion = utils.alias(is_union)

@utils.multicase(id=six.integer_types)
def is_frame(id):
    '''Return whether the structure identified by `id` is a frame or not.'''
    sptr = idaapi.get_struc(id)
    return is_frame(sptr)
@utils.multicase(structure=(idaapi.struc_t, structure_t))
def is_frame(structure):
    '''Return whether the provided `structure` is a frame or not.'''
    SF_FRAME = getattr(idaapi, 'SF_FRAME', 0x40)
    sptr = structure if isinstance(structure, idaapi.struc_t) else structure.ptr
    return True if sptr.props & SF_FRAME else False
frameQ = isframe = utils.alias(is_frame)

@utils.multicase()
def members(structure, **base):
    '''Yield each member of the given `structure` as a tuple containing its attributes.'''
    st = by(structure)
    return members(st.id, **base)
@utils.multicase(id=six.integer_types)
def members(id, **base):
    """Yield each member of the structure with the specified `id` as a tuple of containing its `(offset, size, tags)`.

    If the integer `base` is defined, then the offset of each member will be translated by the given value.
    """
    st, struc = (F(id) for F in [idaapi.get_struc, by])

    # If we couldn't get the structure, then blow up in the user's face.
    if st is None:
        raise E.StructureNotFoundError(u"{:s}.members({:#x}) : Unable to find the requested structure ({:#x}).".format(__name__, id, id))

    # Grab some attributes like the structure's size, and whether or not
    # it's a union so that we can figure out each member's offset.
    size, unionQ = idaapi.get_struc_size(st), is_union(st)

    # Iterate through all of the member in the structure.
    offset, translated = 0, next((base[key] for key in ['offset', 'base', 'baseoffset'] if key in base), 0)
    for i in range(st.memqty):
        m, mem = st.get_member(i), struc.members[i]

        # Grab the member and its properties.
        msize, munionQ = idaapi.get_member_size(m), m.props & idaapi.MF_UNIMEM

        # Figure out the boundaries of the member. If our structure is a union,
        # then the starting offset never changes since IDA dual-uses it as the
        # member index.
        left, right = offset if unionQ else m.soff, m.eoff

        # If our current offset does not match the member's starting offset,
        # then this is an empty field, or undefined. We yield this to the caller
        # so that they know that there's some padding they need to know about.
        if offset < left:
            yield translated + offset, left - offset, {}
            offset = left

        # Grab the attributes about the member that we plan on yielding.
        # However, we need to force any critical implicit tags (like the name).
        items = mem.tag()
        items.setdefault('__name__', idaapi.get_member_name(m.id))

        # That was everything that our caller should care about, so we can
        # just yield it and continue onto the next member.
        yield translated + offset, msize, items

        # If we're a union, then the offset just never changes. Continue onto
        # the next member without updating it.
        if unionQ:
            continue

        # Otherwise we're a regular member and we need to move onto the next
        # offset in our structure.
        offset += msize
    return

@utils.multicase(offset=six.integer_types)
def fragment(structure, offset, **base):
    '''Yield each member of the given `structure` from the specified `offset` as a tuple containing its attributes.'''
    st = by(structure)
    return fragment(st.id, offset, st.size, **base)
@utils.multicase(offset=six.integer_types, size=six.integer_types)
def fragment(structure, offset, size, **base):
    '''Yield each member of the given `structure` from the specified `offset` up to `size` as a tuple containing its attributes.'''
    st = by(structure)
    return fragment(st.id, offset, size, **base)
@utils.multicase(id=six.integer_types, offset=six.integer_types, size=six.integer_types)
def fragment(id, offset, size, **base):
    """Yield each member of the structure with the specified `id` from the given `offset` up to `size` as a tuple containing its `(offset, size, tags)`.

    If the integer `base` is defined, then the offset of each member will be translated by the given value.
    """
    iterable, unionQ = members(id, **base), is_union(id)

    # seek
    for item in iterable:
        m_offset, m_size, state = item

        left, right = m_offset, m_offset + m_size
        if (offset >= left) and (offset < right):
            delta = max(m_offset, offset) - m_offset
            yield m_offset + delta, m_size - delta, state
            size -= 0 if unionQ else m_size
            break
        continue

    # return
    for item in iterable:
        if size > 0:
            m_offset, m_size, state = item
            yield m_offset, m_size, state
            size -= 0 if unionQ else m_size
        continue
    return

@utils.multicase(structure=structure_t)
def remove(structure):
    '''Remove the specified `structure` from the database.'''
    if not idaapi.del_struc(structure.ptr):
        raise E.StructureNotFoundError(u"{:s}.remove({!r}) : Unable to remove structure {:#x}.".format(__name__, structure, structure.id))
    return True
@utils.multicase(name=six.string_types)
@utils.string.decorate_arguments('name', 'suffix')
def remove(name, *suffix):
    '''Remove the structure with the specified `name`.'''
    res = by_name(name, *suffix)
    return remove(res)
@utils.multicase(id=six.integer_types)
def remove(id):
    '''Remove a structure by its index or `id`.'''
    res = by(id)
    return remove(res)
@utils.multicase()
def remove(**type):
    '''Remove the first structure that matches the result described by `type`.'''
    res = by(**type)
    return remove(res)
delete = utils.alias(remove)

class members_t(object):
    """
    This object is an abstraction around all the members belonging to
    a specific IDA structure. This object is implicitly part of a
    ``structure_t`` and allows one to access each member of the structure
    by its index as well as create new members and remove existing ones
    from the structure.

    To list the different members available in the structure, one can
    use ``structure.list`` with a chosen method of filtering. This will
    list all of the available members that match the keyword that they
    specified. The keywords that are available to filter members are:

        `name` - Match the structure member by a name
        `offset` - Match the structure member by its offset
        `like` - Filter the structure members according to a glob
        `regex` - Filter the structure members according to a regular-expression
        `index` - Match the structure member by its index
        `fullname` - Filter the structure members by matching its full name according to a glob
        `comment` or `comments` - Filter the structure members by applying a glob to its comment
        `identifier` or `id` - Match the structure member by its identifier
        `greater` or `ge` - Filter the structure members for any after the specified offset (inclusive)
        `gt` - Filter the structure members for any after the specified offset (exclusive)
        `less` or `le` - Filter the structure members for any before the specified offset (inclusive)
        `lt` - Filter the structure members for any before the specified offset (exclusive)
        `predicate` - Filter the structure members by passing the ``member_t`` to a callable

    Some examples of using these keywords are as follows::

        > st.members.list('field_4*')
        > iterable = st.members.iterate(like='p_*')
        > result = st.members.by(offset=0x2a)

    """
    __slots__ = ('__owner__', 'baseoffset')

    def __init__(self, owner, baseoffset=0):
        self.__owner__ = owner
        self.baseoffset = baseoffset

    @utils.multicase()
    def iterate(self, **type):
        '''Iterate through all of the members in the structure that match the keyword specified by `type`.'''
        if not type: type = {'predicate': lambda item: True}
        listable = [item for item in self.__iterate__()]
        for key, value in type.items():
            listable = [item for item in self.__members_matcher.match(key, value, listable)]
        for item in listable: yield item
    @utils.multicase(string=six.string_types)
    @utils.string.decorate_arguments('string', 'suffix')
    def iterate(self, string, *suffix):
        '''Iterate through all of the members in the structure with a name that matches the glob in `string`.'''
        res = string if isinstance(string, tuple) else (string,)
        return self.iterate(like=interface.tuplename(*(res + suffix)))

    @utils.multicase(string=six.string_types)
    @utils.string.decorate_arguments('string', 'suffix')
    def list(self, string, *suffix):
        '''List any members that match the glob in `string`.'''
        res = string if isinstance(string, tuple) else (string,)
        return self.list(like=interface.tuplename(*(res + suffix)))
    @utils.multicase()
    @utils.string.decorate_arguments('regex', 'name', 'like', 'fullname', 'comment', 'comments')
    def list(self, **type):
        '''List all the members within the structure that match the keyword specified by `type`.'''
        res = [item for item in self.iterate(**type)]

        maxindex = max(builtins.map(utils.fcompose(operator.attrgetter('index'), "{:d}".format, len), res) if res else [1])
        maxoffset = max(builtins.map(utils.fcompose(operator.attrgetter('offset'), "{:x}".format, len), res) if res else [1])
        maxsize = max(builtins.map(utils.fcompose(operator.attrgetter('size'), "{:+#x}".format, len), res) if res else [1])
        maxname = max(builtins.map(utils.fcompose(operator.attrgetter('name'), utils.string.repr, len), res) if res else [1])
        maxtype = max(builtins.map(utils.fcompose(operator.attrgetter('type'), utils.string.repr, len), res) if res else [1])
        maxtypeinfo = max(builtins.map(utils.fcompose(operator.attrgetter('typeinfo'), "{!s}".format, operator.methodcaller('replace', ' *', '*'), len), res) if res else [0])

        for m in res:
            six.print_(u"[{:{:d}d}] {:>{:d}x}:{:<+#{:d}x} {:>{:d}s} {:<{:d}s} {:<{:d}s} (flag={:x},dt_type={:x}{:s}){:s}".format(m.index, maxindex, m.offset, int(maxoffset), m.size, maxsize, "{!s}".format(m.typeinfo.dstr()).replace(' *', '*'), int(maxtypeinfo), utils.string.repr(m.name), int(maxname), utils.string.repr(m.type), int(maxtype), m.flag, m.dt_type, '' if m.typeid is None else ",typeid={:x}".format(m.typeid), u" // {!s}".format(m.tag() if '\n' in m.comment else m.comment) if m.comment else ''))
        return

    @utils.multicase()
    @utils.string.decorate_arguments('regex', 'name', 'like', 'fullname', 'comment', 'comments')
    def by(self, **type):
        '''Return the member that matches the keyword specified by `type`.'''
        searchstring = utils.string.kwargs(type)
        owner = self.owner

        listable = [item for item in self.iterate(**type)]
        if len(listable) > 1:
            cls = self.__class__
            messages = ((u"[{:d}] {:x}{:+#x} {:s} '{:s}' {!r}".format(m.index, m.offset, m.size, "{!s}".format(m.typeinfo.dstr()).replace(' *', '*'), utils.string.escape(m.name, '\''), utils.string.repr(m.type))) for m in listable)
            [ logging.info(msg) for msg in messages ]
            logging.warning(u"{:s}({:#x}).members.by({:s}) : Found {:d} matching results. Returning the member at index {:d} offset {:x}{:+#x} with the name \"{:s}\" and typeinfo \"{:s}\".".format('.'.join([__name__, cls.__name__]), owner.ptr.id, searchstring, len(listable), listable[0].index, listable[0].offset, listable[0].size, utils.string.escape(listable[0].fullname, '"'), utils.string.escape("{!s}".format(listable[0].typeinfo.dstr()).replace(' *', '*'), '"')))

        iterable = (item for item in listable)
        res = next(iterable, None)
        if res is None:
            cls = self.__class__
            raise E.SearchResultsError(u"{:s}({:#x}).members.by({:s}) : Found 0 matching results.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, searchstring))
        return res
    @utils.multicase(name=six.string_types)
    @utils.string.decorate_arguments('name', 'suffix')
    def by(self, name, *suffix):
        '''Return the member with the specified `name`.'''
        return self.by_name(name, *suffix)
    @utils.multicase(offset=six.integer_types)
    def by(self, offset):
        '''Return the member at the specified `offset`.'''
        return self.by_offset(offset)
    @utils.multicase(location=tuple)
    def by(self, location):
        '''Return the member at the specified `location`.'''
        offset, size = location
        if isinstance(offset, interface.symbol_t):
            offset, = (int(item) for item in offset)
        member = self.by_offset(offset)
        if (offset, size) != (member.offset, member.size):
            cls = self.__class__
            message = "is a different size ({:d}) than requested".format(size) if member.offset == offset else "is not at the exact offset ({:#x}) as requested".format(offset)
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.by({!s}) : The member ({:s}) at the given location ({:#x}<->{:#x}) {:s}.".format('.'.join([__name__, cls.__name__]), self.owner.ptr.id, location, member.name, member.left, member.right, message))
        return member

    @utils.string.decorate_arguments('name', 'suffix')
    def by_name(self, name, *suffix):
        '''Return the member with the specified `name`.'''
        string = name if isinstance(name, tuple) else (name,)
        res = utils.string.to(interface.tuplename(*(string + suffix)))
        owner = self.owner

        # grab the member_t of the structure by its name
        mem = idaapi.get_member_by_name(owner.ptr, res)
        if mem is None:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.by_name({!r}) : Unable to find member with requested name.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, name))

        # figure out the index of the member so we can return the member_t we've cached
        index = self.index(mem)
        return self[index]
    byname = utils.alias(by_name, 'members_t')

    @utils.string.decorate_arguments('fullname', 'suffix')
    def by_fullname(self, fullname, *suffix):
        '''Return the member with the specified `fullname`.'''
        string = fullname if isinstance(fullname, tuple) else (fullname,)
        res = utils.string.to(interface.tuplename(*(string + suffix)))
        owner = self.owner

        # grab the member_t of the structure by its fullname
        member = idaapi.get_member_by_fullname(res)
        mem, _ = (None, None) if member is None else member
        if mem is None:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.by_fullname({!r}) : Unable to find member with full name.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, fullname))

        # figure out the index of the member so we can return the member_t we've cached
        index = self.index(mem)
        return self[index]
    byfullname = utils.alias(by_fullname, 'members_t')

    def by_offset(self, offset):
        '''Return the member at the specified `offset` from the base offset of the structure.'''
        cls, owner = self.__class__, self.owner

        # Chain to the realoffset implementation.. This is just a wrapper.
        try:
            result = self.by_realoffset(offset - self.baseoffset)

        # Pivot any expected exceptions so that we can output the parameter the user gave us.
        except (E.MemberNotFoundError, E.OutOfBoundsError):
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.by_offset({:+#x}) : Unable to locate a member at the specified offset ({:+#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, offset))
        return result
    byoffset = utils.alias(by_offset, 'members_t')

    def index(self, member):
        '''Return the index of the specified `member`.'''
        owner = self.owner
        if not hasattr(member, 'id'):
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({:#x}).members.index({!r}) : An invalid type ({!s}) was specified for the member to search for.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, member, member.__class__))

        for i in range(owner.ptr.memqty):
            if member.id == self[i].id:
                return i
            continue
        cls, Fnetnode = self.__class__, getattr(idaapi, 'ea2node', utils.fidentity)
        raise E.MemberNotFoundError(u"{:s}({:#x}).members.index({!s}) : The requested member ({!s}) is not in the members list.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, "{:#x}".format(member.id) if isinstance(member, (member_t, idaapi.member_t)) else "{!r}".format(member), internal.netnode.name.get(Fnetnode(member.id))))

    def by_realoffset(self, offset):
        '''Return the member at the specified `offset` of the structure.'''
        owner = self.owner
        FF_STRUCT = idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU

        # Start by getting our bounds which only requires us to know the structure's size
        # regardless of whether or not it's a union. Just to be safe, we guard this against
        # a potential OverflowError that would be raised by SWIG's type-checker.
        minimum, maximum = 0, idaapi.get_struc_size(owner.ptr)
        if maximum < minimum:
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).members.by_realoffset({:+#x}) : Received an unexpected size ({:#x}) for the given structure ({:#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, maximum, owner.ptr.id))

        if not (minimum <= offset < maximum):
            cls = self.__class__
            raise E.OutOfBoundsError(u"{:s}({:#x}).members.by_realoffset({:+#x}) : Requested offset ({:#x}) is not within the structure's boundaries ({:#x}<>{:#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, offset, minimum, minimum + maximum))

        # Now we call our members_t.__members_at__ helper-method so that we can check the
        # members that are returned to verify that they're within our search boundaries.
        items, unionQ = [], is_union(owner.ptr)
        for mptr in self.__members_at__(offset):
            mleft, mright = 0 if unionQ else mptr.soff, mptr.eoff

            # Check the offset is within our current member's boundaries, and add it to
            # our list if it is so that we can count our results later.
            if mleft <= offset < mright:
                items.append(mptr)
            continue

        # If we didn't find any items, then we need to throw up an exception because
        # we're unable to proceed any farther without any members to search through.
        if not items:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.by_realoffset({:+#x}) : Unable to find member at the specified offset ({:+#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, offset))

        # If we found more than one result, then we need to warn the user about it
        # because we're going to have to make a decision on their behalf. This really
        # should only be happening when we're a union type.
        if len(items) > 1:
            cls = self.__class__
            iterable = (idaapi.get_member_fullname(mptr.id) for mptr in items)
            logging.warning(u"{:s}({:#x}).members.by_realoffset({:+#x}) : The specified offset ({:#x}) is currently occupied by more than one member ({:s}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, offset, ', '.join(map(utils.string.to, iterable))))

            # Grab the type information for each member so we can determine if the
            # requested offset points at an array or a structure. We also grab
            # the operand information via the idaapi.retrieve_member_info api.
            # If there's no operand information available, we use None as a
            # placeholder. Fortunately, the api also returns None as failure so
            # we can just blindly add its result to our list of candidates.
            candidates = []
            for mptr in items:
                opinfo = idaapi.opinfo_t()
                res = idaapi.retrieve_member_info(mptr, opinfo) if idaapi.__version__ < 7.0 else idaapi.retrieve_member_info(opinfo, mptr)
                candidates.append((mptr, mptr.flag, res and res.tid, idaapi.get_member_size(mptr)))

            # Now iterate through all of our candidates to see how we can narrow
            # them down into the ones we want to select.
            selected = []
            for mptr, flags, tid, size in candidates:
                dt = idaapi.as_uint32(flags & idaapi.DT_TYPE)
                res = interface.typemap.dissolve(flags, tid, size)

                # Adjust the offset so it points directly into the member.
                realoffset = offset - (0 if unionQ else mptr.soff)

                # First we need to check to see if it's an array, because this
                # might actually be an array of structures which we'll need to
                # check the requested offset against.
                if isinstance(res, builtins.list):
                    type, length = res

                    # If we received a tuple, then we can extract the member size
                    # directly to see if it aligns properly.
                    if isinstance(type, builtins.tuple):
                        _, msize = type
                        index, byte = divmod(realoffset, msize)

                    # Otherwise this must be an array of structures, and we need
                    # to extract its size to see if it aligns.
                    elif isinstance(type, structure_t):
                        msize = idaapi.get_struc_size(type.id)
                        index, byte = divmod(realoffset, msize)

                    # We have no idea what this is, which is a very unexpected
                    # situation. So, we'll just raise an exception here so that
                    # it can be debugged later.
                    else:
                        raise NotImplementedError(mptr.id, type, length)

                    # Now that we have our index and byte offset, we can check
                    # and see if it divided evenly into the member size. If so,
                    # then we can push it to the front of the list. Otherwise,
                    # it goes to the very very back.
                    selected.append(mptr) if byte else selected.insert(0, mptr)

                # Next we need to check if it's a structure, because if so then
                # we need to find out if it directly aligns with a particular
                # member.
                elif isinstance(res, structure_t) and is_union(res.ptr):
                    selected.append(mptr) if realoffset else selected.insert(0, mptr)

                # Finally, check if it's a structure and our real offset points
                # directly to a particular member. If it does, then this is
                # a legitimate candidate.
                elif isinstance(res, structure_t):
                    mem = idaapi.get_member(res.ptr, realoffset)
                    selected.append(mptr) if mem and realoffset - mem.soff else selected.insert(0, mptr)

                # If it's a tuple, then this only matches if we're pointing
                # directly to the member.
                elif isinstance(res, builtins.tuple):
                    selected.append(mptr) if realoffset else selected.insert(0, mptr)

                # Anything else and we have no idea what this is, so simply
                # raise an exception so it can be debugger later.
                else:
                    raise NotImplementedError(mptr, res)
                continue

            # Now log the order of members that we've sorted out just in case
            # this "algorithm" is totally busted and we want to figure out
            # where it's busted.
            iterable = ((mptr, idaapi.get_member_fullname(mptr.id)) for mptr in selected)
            messages = (u"[{:d}] {:s} {:#x}{:+#x}".format(1 + i, fullname, 0 if unionQ else mptr.soff, mptr.eoff) for i, (mptr, fullname) in enumerate(iterable))
            [ logging.info(msg) for msg in messages ]

            # Grab the first element from our sorted list, as that's the one
            # that we're going to actually use.
            items = selected[:1]

        # Now we can extract the member from our list of results, and then
        # figure out its index so that we can return it. Hopefully we found
        # what the user was expecting.
        member, = items
        index = self.index(member)
        return self[index]
    byrealoffset = utils.alias(by_realoffset, 'members_t')

    def by_identifier(self, id):
        '''Return the member in the structure that has the specified `id`.'''
        owner = self.owner

        # get the member from the id we were given
        res = idaapi.get_member_by_id(id)
        if res is None:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.by_id({:#x}) : Unable to find member with specified identifier ({:#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, id, id))

        # unpack the member out of the result
        mptr, fullname, sptr = res
        if not interface.node.is_identifier(sptr.id):
            sptr = idaapi.get_member_struc(idaapi.get_member_fullname(mptr.id))

        # search through our members for the specified member
        index = self.index(mptr)
        return self[index]
    by_id = byid = byidentifier = utils.alias(by_identifier, 'members_t')

    def near_offset(self, offset):
        '''Return the member nearest to the specified `offset` from the base offset of the structure.'''
        owner = self.owner

        # This was just a wrapper anyways...
        return self.near_realoffset(offset - self.baseoffset)
    near = nearoffset = utils.alias(near_offset, 'members_t')

    def near_realoffset(self, offset):
        '''Return the member nearest to the specified `offset`.'''
        owner = self.owner

        # Start by getting our bounds.
        minimum, maximum = owner.realbounds
        if not (minimum <= offset < maximum):
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).members.near_realoffset({:+#x}) : Requested offset ({:#x}) is not within the bounds ({:#x}<->{:#x}) of the structure and will result in returning the nearest member.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, offset, minimum, maximum))

        # If there aren't any elements in the structure, then there's no members
        # to search through in here. So just raise an exception and bail.
        if not len(self):
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.near_realoffset({:+#x}) : Unable to find member near offset.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset))

        # Grab all of the members at the specified offset so we can determine
        # if there's an exact member that can be found.
        members = [mptr for mptr in self.__members_at__(offset)]

        # If we found more than one member, then try and filter the exact one
        # using the members_t.by_realoffset method.
        if len(members):
            return self.by_realoffset(offset)

        # We couldn't find any members, so now we'll try and search for the
        # member that is nearest to the offset that was requested.
        def recurse(offset, available):
            if len(available) == 1:
                return available[0]
            index = len(available) // 2
            return recurse(offset, available[:index]) if offset <= available[index].realoffset else recurse(offset, available[index:])

        # This should already be sorted for us, so descend into it looking
        # for the nearest member.
        mem = recurse(offset, [item for item in self])

        # Now we can return the exact member that was found.
        index = self.index(mem)
        return self[index]

    # adding/removing members
    @utils.multicase(name=(six.string_types, tuple))
    @utils.string.decorate_arguments('name')
    def add(self, name):
        '''Append the specified member `name` with the default type at the end of the structure.'''
        return self.add(name, int)
    @utils.multicase(name=(six.string_types, tuple))
    @utils.string.decorate_arguments('name')
    def add(self, name, type):
        '''Append the specified member `name` with the given `type` at the end of the structure.'''
        owner = self.owner

        # If this structure is a union, then the offset should always be 0.
        # This means that when translated to our baseoffset, will always
        # result in the baseoffset itself.
        if is_union(owner.ptr):
            return self.add(name, type, self.baseoffset)

        # Otherwise, it's not a union and so we'll just calculate
        # the offset to add the member at, and proceed as asked.
        offset = owner.size + self.baseoffset
        return self.add(name, type, offset)
    @utils.multicase(name=(six.string_types, tuple), offset=six.integer_types)
    @utils.string.decorate_arguments('name')
    def add(self, name, type, offset):
        """Add a member at `offset` with the given `name` and `type`.

        To specify a particular size, `type` can be a tuple with the second element referring to the size.
        """
        owner = self.owner
        flag, typeid, nbytes = interface.typemap.resolve(type)

        # If the member is being added to a union, then the offset doesn't
        # matter because it's always zero. We need to check this however because
        # we're aiming to be an "intuitive" piece of software.
        if is_union(owner.ptr):

            # If the offset is zero, then maybe the user does know what they're
            # doing, but they don't know that they need to use the base offset.
            if offset == 0:
                pass

            # If the user really is trying to add a member with a non-zero offset
            # to our union, then we need to warn the user so that they know not
            # to do it again in the future.
            elif offset != self.baseoffset:
                cls = self.__class__
                logging.warning(u"{:s}({:#x}).members.add({!r}, {!s}, {:+#x}) : Corrected the invalid offset ({:#x}) being used when adding member ({!s}) to union \"{:s}\", and changed it to {:+#x}.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, name, type, offset, offset, name, owner.name, self.baseoffset))

            # Now we can actually correct the offset they gave us.
            offset = self.baseoffset

        # FIXME: handle .strtype (strings), .ec (enums), .cd (custom)
        opinfo = idaapi.opinfo_t()
        opinfo.tid = typeid
        realoffset = offset - self.baseoffset

        # If they didn't give us a name, then we figure out a default name
        # using a sort-of hungarian notation as the prefix, and the field's
        # offset as the suffix.
        if name is None:
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).members.add({!r}, {!s}, {:+#x}) : Name is undefined, defaulting to offset {:+#x}.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, name, type, offset, realoffset))
            name = 'field', realoffset

        # If we were given a tuple, then we need to concatenate it into a string.
        if isinstance(name, builtins.tuple):
            name = interface.tuplename(*name)

        # Finally we can use IDAPython to add the structure member with the
        # parameters that we were given and/or figured out.
        res = idaapi.add_struc_member(owner.ptr, utils.string.to(name), realoffset, flag, opinfo, nbytes)

        # If we received a failure error code, then we convert the error code to
        # an error message so that we can raise an exception that actually means
        # something and enables the user to correct it.
        if res != idaapi.STRUC_ERROR_MEMBER_OK:
            error = {
                idaapi.STRUC_ERROR_MEMBER_NAME : 'Duplicate field name',
                idaapi.STRUC_ERROR_MEMBER_OFFSET : 'Invalid offset',
                idaapi.STRUC_ERROR_MEMBER_SIZE : 'Invalid size',
            }
            e = E.DuplicateItemError if res == idaapi.STRUC_ERROR_MEMBER_NAME else E.DisassemblerError
            callee = u"idaapi.add_struc_member(sptr=\"{:s}\", fieldname=\"{:s}\", offset={:+#x}, flag={:#x}, mt={:#x}, nbytes={:#x})".format(utils.string.escape(owner.name, '"'), utils.string.escape(name, '"'), realoffset, flag, typeid, nbytes)
            cls = self.__class__
            raise e(u"{:s}({:#x}).members.add({!r}, {!s}, {:+#x}) : The api call to `{:s}` returned {:s}".format('.'.join([__name__, cls.__name__]), owner.ptr.id, name, type, offset, callee, error.get(res, u"Error code {:#x}".format(res))))

        # Now we need to return the newly created member to the caller. Since
        # all we get is an error code from IDAPython's api, we try and fetch the
        # member that was just added by the offset it's supposed to be at.
        mptr = idaapi.get_member(owner.ptr, realoffset)
        if mptr is None:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.add({!r}, {!s}, {:+#x}) : Unable to locate recently created member \"{:s}\" at offset {:s}{:+#x}.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, name, type, offset, utils.string.escape(name, '"'), realoffset, nbytes))

        # We can now log our small success and update the member's refinfo if it
        # was actually necessary.
        cls, refcount = self.__class__, interface.address.update_refinfo(mptr.id, flag)
        logging.debug(u"{:s}({:#x}).members.add({!r}, {!s}, {:+#x}) : The api call to `idaapi.add_struc_member(sptr=\"{:s}\", fieldname=\"{:s}\", offset={:+#x}, flag={:#x}, mt={:#x}, nbytes={:#x})` returned success{:s}.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, name, type, offset, utils.string.escape(owner.name, '"'), utils.string.escape(name, '"'), realoffset, flag, typeid, nbytes, " ({:d} references)".format(refcount) if refcount > 0 else ''))

        # If we successfully grabbed the member, then we need to figure out its
        # actual index in our structure. Then we can use the index to instantiate
        # a member_t that we'll return back to the caller.
        idx = self.index(mptr)
        return member_t(owner, idx)

    def pop(self, index):
        '''Remove the member at the specified `index`.'''
        item = self[index]
        return self.remove(item.offset)

    @utils.multicase()
    def remove(self, offset):
        '''Remove the member at `offset` from the structure.'''
        cls, owner, items = self.__class__, self.owner, [mptr for mptr in self.__members_at__(offset - self.baseoffset)] if offset >= self.baseoffset else []

        # If there are no items at the requested offset, then we bail.
        if not items:
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.remove({:+#x}) : Unable to find a member at the specified offset ({:#x}) of the structure ({:s}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, offset, self.owner.bounds))

        # If more than one item was found, then we also need to bail.
        elif len(items) > 1:
            raise E.InvalidTypeOrValueError(u"{:s}({:#x}).members.remove({:+#x}) : Refusing to remove more than {:d} member{:s} ({:d}) at offset {:#x}.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, 1, '' if len(items) == 1 else 's', len(items), offset))

        # Now we know exactly what we can remove.
        mptr, = items
        results = self.remove(self.baseoffset + mptr.soff, mptr.eoff - mptr.soff)
        if not results:
            raise E.DisassemblerError(u"{:s}({:#x}).members.remove({:+#x}) : Unable to remove the member at the specified offset ({:#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, offset, self.baseoffset + mptr.soff))
        result, = results
        return result
    @utils.multicase()
    def remove(self, offset, size):
        '''Remove all the members from the structure from the specified `offset` up to `size` bytes.'''
        cls, sptr, soffset = self.__class__, self.owner.ptr, offset - self.baseoffset
        if not sptr.memqty:
            logging.warning(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : The structure has no members that are able to be removed.".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size))
            return []

        # If we're a union, then we need to raise an exception because
        # there's a likely chance that the user might empty out the
        # union entirely.
        if is_union(sptr):
            raise E.InvalidParameterError(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : Refusing to remove members from the specified union by the specified offset ({:+#x}).".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size, offset))

        # We need to calculate range that we're actually going to be removing, so
        # that we can clamp it to the boundaries of the structure. If the range
        # doesn't overlap, then we simply abort here with a warning.
        (left, right), (sleft, sright) = sorted([soffset, soffset + size]), (0, idaapi.get_struc_size(sptr))
        if not all([left <= sright - 1, right - 1  >= sleft]):
            logging.warning(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : The specified range ({:#x}..{:#x}) is outside the range of the structure ({:#x}..{:#x}).".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size, *map(functools.partial(operator.add, self.baseoffset), [left, right - 1, sleft, sright - 1])))
            return []

        # Now that we know the range overlaps, we just need to clamp our values
        # to the overlapping part and recalculate the size.
        else:
            soffset, ssize = max(left, sleft), min(right, sright) - max(left, sleft)

        # First we'll need to figure out the index of the member that we will
        # start removing things at so we can collect the members to remove.
        previndex, nextindex = idaapi.get_prev_member_idx(sptr, soffset), idaapi.get_next_member_idx(sptr, soffset)
        index = previndex if nextindex < 0 else nextindex - 1
        if not (0 <= index < sptr.memqty):
            logging.warning(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : Unable to determine the index of the member at the specified offset ({:#x}).".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size, soffset + self.baseoffset))
            return []

        # Next we need to collect each member that will be removed so
        # that we can return them back to the caller after removal.
        items = []
        while index < sptr.memqty and sptr.members[index].soff < soffset + ssize:
            mptr = sptr.members[index]
            items.append(mptr)
            index += 1

        # Now we know what will need to be removed, so we'll need to
        # collect their attributes so that the user can recreate them
        # if necessary.
        result = []
        for mptr in items:
            name = utils.string.of(idaapi.get_member_name(mptr.id) or '')
            moffset, msize = mptr.soff + self.baseoffset, idaapi.get_member_size(mptr)

            # now we need to grab the type information in order to pythonify
            # our type before we remove it.
            opinfo = idaapi.opinfo_t()
            if idaapi.retrieve_member_info(mptr, opinfo) if idaapi.__version__ < 7.0 else idaapi.retrieve_member_info(opinfo, mptr):
                tid = opinfo.tid
            else:
                tid = idaapi.BADADDR

            # now we can dissolve it, and than append things to our results.
            type, location = interface.typemap.dissolve(mptr.flag, tid, msize, offset=moffset), interface.location_t(moffset, msize)
            result.append((mptr.id, name, type, location))

        # Figure out whether we're just going to remove one element, or
        # multiple elements so that we can call the correct api and figure
        # out how to compare the number of successfully removed members.
        if len(items) > 1:
            count = idaapi.del_struc_members(sptr, soffset, soffset + ssize)
        elif len(items):
            count = 1 if idaapi.del_struc_member(sptr, soffset) else 0
        else:
            count = 0

        # If we didn't remove anything and we were supposed to, then let
        # the user know that it didn't happen.
        if result and not count:
            start, stop = result[0], result[-1]
            bounds = interface.bounds_t(start[3].bounds.left, stop[3].bounds.right)
            logging.fatal(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : Unable to remove the requested elements ({:s}) from the structure.".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size, bounds))
            return []

        # If our count matches what was expected, then we're good and can
        # just return our results to the user.
        if len(result) == count:
            items = [(name, type, location) for _, name, type, location in result]
            return items[::-1] if size < 0 else items

        # Otherwise, we only removed some of the elements and we need to
        # figure out what happened so we can let the user know.
        removed, expected = {id for id in []}, {id : (name, type, location) for id, name, type, location in result}
        for id, name, _, location in result:
            moffset, _ = location
            if idaapi.get_member(sptr, moffset - self.baseoffset):
                logging.debug(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : Unable to remove member {:s} at offset {:+#x} with the specified id ({:#x}).".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size, name, moffset, id))
                continue
            removed.add(id)

        # We have the list of identities that were removed. So let's proceed
        # with our warnings and return whatever we successfully removed.
        start, stop = result[0], result[-1]
        bounds = interface.bounds_t(start[3].bounds.left, stop[3].bounds.right)
        logging.warning(u"{:s}({:#x}).members.remove({:+#x}, {:+#x}) : Unable to remove {:d} members out of an expected {:d} members within the specified range ({:s}) of the structure.".format('.'.join([__name__, cls.__name__]), sptr.id, offset, size, len(expected) - len(removed), len(expected), bounds))
        items = [(name, type, location) for id, name, type, location in result if id in removed]
        return items[::-1] if size < 0 else items

    ### Properties
    @property
    def owner(self):
        '''Return the owner ``structure_t`` for this ``members_t``.'''
        return self.__owner__

    @property
    def ptr(self):
        '''Return the pointer to the ``idaapi.member_t`` that contains all the members.'''
        owner = self.owner
        return owner.ptr.members

    ### Private methods containing internal utilities
    def __members_at__(self, realoffset):
        """Yield all the members at the specified `realoffset` of the current structure.

        This returns members whilst keeping in mind whether the structure is a union and may have more than one field at the same offset.
        """
        owner = self.owner

        # If this structure is not a union, then this is simple because there'll
        # be only one member at any given offset. It appears that IDAPython's api
        # seems to figure everything out for us and so we can just use it to
        # fetch the things we need to yield, and then return immediately after.
        if not is_union(owner.ptr):
            mptr = idaapi.get_member(owner.ptr, realoffset)
            if mptr:
                yield mptr
            return

        # Otherwise, start at the very first member index, and check that we actually
        # have some members that we can iterate through.
        index = idaapi.get_struc_first_offset(owner.ptr)
        if index == idaapi.BADADDR:
            return

        # Now we can iterate through the union from the very first index while grabbing
        # each member so that we can filter it according to its bounds and then discard
        # anything that doesn't match.
        while index != -1 and index <= idaapi.get_struc_last_offset(owner.ptr):
            mptr = idaapi.get_member(owner.ptr, index)
            if mptr is None:
                cls = self.__class__
                raise E.MemberNotFoundError(u"{:s}({:#x}).members.by_realoffset({:+#x}) : Unable to find union member at the specified index ({:+#x}).".format('.'.join([__name__, cls.__name__]), owner.ptr.id, realoffset, index))

            # If the request offset is within the boundaries of our union member,
            # then we're good and this matches what we were looking for.
            if realoffset < mptr.eoff:
                yield mptr

            # Proceed to the next union member by asking IDAPython for the next index.
            index = idaapi.get_struc_next_offset(owner.ptr, mptr.soff)
        return

    def __walk_to_realoffset__(self, offset, filter=lambda sptr, items: items):
        """Descend into the structure collecting the fields to get to the specified `offset`.

        If a closure is passed as the `filter` parameter, then use the function to filter the members to use when descending into a structure.
        """
        owner = self.owner

        # Define a closure that grabs the type information for a particular
        # member, and converts it to a pythonic-type. This way it's easier
        # for us to determine both the member's type and its size.
        def dissolve(mptr, offset):
            opinfo = idaapi.opinfo_t()
            res = idaapi.retrieve_member_info(mptr, opinfo) if idaapi.__version__ < 7.0 else idaapi.retrieve_member_info(opinfo, mptr)
            tid = res.tid if res else idaapi.BADADDR
            return interface.typemap.dissolve(mptr.flag, tid, idaapi.get_member_size(mptr), offset=offset)

        # Start out by finding all of the members at our current offset.
        items = []
        for mptr in self.__members_at__(offset):
            mleft, mright = 0 if is_union(owner.ptr) else mptr.soff, mptr.eoff

            # Check the offset is within our current member's boundaries, and
            # add it to our list if it is so that we can count our results later.
            if mleft <= offset < mright:
                items.append(mptr)
            continue
        members = items

        # If we received multiple members for this specific offset, which
        # should only happen if we're in a union, then we need to do some
        # special processing in order to figure out which member we should
        # use. We do this by using our filter parameter when we find more
        # than one member in order to allow the caller to explicitly filter
        # our discovered candidates.
        F = filter or (lambda structure, items: items)
        filtered = F(owner.ptr, members) if len(members) > 1 else members

        # If we didn't get exactly one member after filtering our path,
        # then either we hit a union (multiple members) or an undefined
        # field.
        if len(filtered) != 1:

            # If it's a union, then we just return an offset relative to
            # the structure itself. Generally, the caller needs to tell
            # us which union member to choose using the filter parameter.
            if is_union(owner.ptr):
                return (), offset

            # Otherwise, grab the nearest member to the offset and check
            # if the member can be used to describe the offset by verifying
            # that the member is located in front of the offset. This way
            # we can use the nearest member to adjust the offset, and then
            # return it along with the adjusted offset to the caller.
            nearest = self.near_realoffset(offset)
            if offset >= nearest.realoffset:
                return (nearest,), offset - nearest.realoffset

            # Otherwise, our offset is going to be relative to the
            # structure itself and we need to return an empty path.
            return (), offset

        # Otherwise we found a single item, then we just need to know if
        # we need to continue recursing into something and what exactly
        # we're recursing into.
        mptr, = filtered
        moffset = 0 if is_union(owner.ptr) else mptr.soff
        mtype = dissolve(mptr, self.baseoffset + moffset)

        # If our member type is an array, then we need to do some things
        # to try and figure out which index we're actually going to be
        # at. Before that, we need to take our dissolved type and unpack it.
        if isinstance(mtype, builtins.list):
            item, length = mtype
            _, size = (item, item.size) if isinstance(item, structure_t) else item
            prefix = [self.by_identifier(item.id) for item in [mptr]]

            # We now need to do some calculations to figure out which index
            # and byte offset that our requested offset is pointing to, and
            # then we can actually calculate our real distance.
            index, bytes = divmod(offset - moffset, size or 1)
            res = index * size

            # If it's just an atomic type, then we can return the difference
            # between our target offset and the member offset since it's up
            # to the caller to figure out what the index actually means.
            if isinstance(item, builtins.tuple):
                return prefix, offset - moffset

            # If our array type is a structure, we will need to recurse in
            # order to figure out what the next field will be, and then we
            # can adjust the returned offset so that it corresponds to the
            # offset into the array.
            sptr = idaapi.get_sptr(mptr)
            if sptr:
                st = __instance__(sptr.id, offset=self.baseoffset + moffset + res)
                suffix, nextoffset = st.members.__walk_to_realoffset__(bytes, filter=filter)
                return prefix + [item for item in suffix], offset - (moffset + res + bytes - nextoffset)

            # We have no idea what type this is, so just bail.
            raise TypeError(mptr, item)

        # Otherwise this is just a single type, and we need to check whether
        # we handle it as a structure which requires us to recurse, or not
        # which means we just return the offset relative to our member.)
        sptr = idaapi.get_sptr(mptr)
        if not sptr:
            prefix = (self.by_identifier(item.id) for item in [mptr])
            return builtins.tuple(prefix), offset - moffset

        # Otherwise, the member type is a structure, and we'll need
        # to recurse in order to figure out which field should be at
        # the relative offset from the member.
        st = __instance__(sptr.id, offset=self.baseoffset + moffset)
        result, nextoffset = st.members.__walk_to_realoffset__(offset - moffset, filter=filter)

        # If we haven't encountered a list yet, then our prefix will
        # still be a tuple and we need to ensure it's the correct type.
        iterable = (self.by_identifier(item.id) for item in [mptr])
        if isinstance(result, builtins.tuple):
            prefix = builtins.tuple(iterable)

        # If our result was a list, then we've encountered an array
        # and we need to preserve its type.
        elif isinstance(result, builtins.list):
            prefix = builtins.list(iterable)

        # Bail if we don't know what the type is.
        else:
            raise TypeError(result)

        # Now we can concatenate our prefix to our current results,
        # and then return what we've aggregated back to our caller.
        return prefix + result, nextoffset

    ## Matching
    __members_matcher = utils.matcher()
    __members_matcher.combinator('regex', utils.fcompose(utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), 'name')
    __members_matcher.attribute('index', 'index')
    __members_matcher.attribute('identifier', 'id'), __matcher__.attribute('id', 'id')
    __members_matcher.attribute('offset', 'offset')
    __members_matcher.boolean('name', lambda name, item: item.lower() == name.lower(), 'name')
    __members_matcher.combinator('like', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), 'name')
    __members_matcher.combinator('fullname', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match')), 'fullname')
    __members_matcher.combinator('comment', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match'), utils.fpartial(utils.fcompose, utils.fdefault(''))), 'comment')
    __members_matcher.combinator('comments', utils.fcompose(fnmatch.translate, utils.fpartial(re.compile, flags=re.IGNORECASE), operator.attrgetter('match'), utils.fpartial(utils.fcompose, utils.fdefault(''))), 'comment')
    __members_matcher.boolean('greater', operator.le, lambda member: member.offset + member.size)
    __members_matcher.boolean('ge', operator.le, lambda member: member.offset + member.size)
    __members_matcher.boolean('gt', operator.lt, lambda member: member.offset + member.size)
    __members_matcher.boolean('less', operator.ge, 'offset')
    __members_matcher.boolean('le', operator.ge, 'offset')
    __members_matcher.boolean('lt', operator.gt, 'offset')
    __members_matcher.predicate('predicate'), __members_matcher.predicate('pred')

    def __iterate__(self):
        '''Yield each of the members within the structure.'''
        for idx in range(len(self)):
            yield member_t(self.owner, idx)
        return

    @utils.multicase(tag=six.string_types)
    @utils.string.decorate_arguments('And', 'Or')
    def select(self, tag, *And, **boolean):
        '''Query all of the members for the specified `tag` and any others specified as `And`.'''
        res = {tag} | {item for item in And}
        boolean['And'] = {item for item in boolean.get('And', [])} | res
        return self.select(**boolean)
    @utils.multicase()
    @utils.string.decorate_arguments('And', 'Or')
    def select(self, **boolean):
        """Query all of the members (linearly) for any tags specified by `boolean`. Yields each member found along with the matching tags as a dictionary.

        If `And` contains an iterable then require the returned members contains them.
        If `Or` contains an iterable then include any other tags that are specified.
        """
        containers = (builtins.tuple, builtins.set, builtins.list)
        boolean = {key : {item for item in value} if isinstance(value, containers) else {value} for key, value in boolean.items()}

        # For some reason the user wants to iterate through everything, so
        # we'll try and do as we're told but only if they have tags.
        if not boolean:
            for m in self.__iterate__():
                content = m.tag()
                if content:
                    yield m, content
                continue
            return

        # Do the same thing we've always done to consoldate our parameters
        # into a form that we can do basic set arithmetic with.
        Or, And = ({item for item in boolean.get(B, [])} for B in ['Or', 'And'])

        # All that's left to do is to slowly iterate through all of our
        # members while looking for the matches requested by the user.
        for m in self.__iterate__():
            collected, content = {}, m.tag()

            # Start out by collecting any tagnames specified by Or(|).
            collected.update({key : value for key, value in content.items() if key in Or})

            # Then we need to include any specific tags that come from And(&).
            if And:
                if And & six.viewkeys(content) == And:
                    collected.update({key : value for key, value in content.items() if key in And})
                else: continue

            # Easy to do and easy to yield.
            if collected: yield m, collected
        return

    ### Private methods
    def __str__(self):
        '''Render all of the fields within the current structure.'''
        res = []
        mn, ms, mti = 0, 0, 0
        for i in range(len(self)):
            m = self[i]
            name, t, ti, ofs, size, comment, tag = m.name, m.type, m.typeinfo, m.offset, m.size, m.comment, m.tag()
            res.append((i, name, t, ti, ofs, size, comment or '', tag))
            mn = max(mn, len(name))
            ms = max(ms, len("{:+#x}".format(size)))
            mti = max(mti, len("{!s}".format(ti.dstr()).replace(' *', '*')))

        mi = len("{:d}".format(len(self) - 1)) if len(self) else 1

        if len(self):
            mo = max(map(len, map("{:x}".format, [self.baseoffset, self[-1].offset + self[-1].size])))
            return "{!r}\n{:s}".format(self.owner, '\n'.join("[{:{:d}d}] {:>{:d}x}{:<+#{:d}x} {:>{:d}s} {:<{:d}s} {!s} {:s}".format(i, mi, o, mo, s, ms, "{!s}".format(ti.dstr()).replace(' *','*'), mti, utils.string.repr(n), mn+2, utils.string.repr(t), " // {!s}".format(utils.string.repr(T) if '\n' in c else utils.string.to(c)) if c else '') for i, n, t, ti, o, s, c, T in res))
        return "{!r}".format(self.owner)

    def __unicode__(self):
        '''Render all of the fields within the current structure.'''
        res = []
        mn, ms, mti = 0, 0, 0
        for i in range(len(self)):
            m = self[i]
            name, t, ti, ofs, size, comment, tag = m.name, m.type, m.typeinfo, m.offset, m.size, m.comment, m.tag()
            res.append((i, name, t, ti, ofs, size, comment or '', tag))
            mn = max(mn, len(name))
            ms = max(ms, len("{:+#x}".format(size)))
            mti = max(mti, len("{!s}".format(ti.dstr()).replace(' *', '*')))

        mi = len("{:d}".format(len(self) - 1)) if len(self) else 1

        if len(self):
            mo = max(map(len, map("{:x}".format, (self.baseoffset, self[-1].offset + self[-1].size))))
            return u"{!r}\n{:s}".format(self.owner, '\n'.join("[{:{:d}d}] {:>{:d}x}{:<+#{:d}x} {:>{:d}s} {:<{:d}s} {!s} {:s}".format(i, mi, o, mo, s, ms, "{!s}".format(ti.dstr()).replace(' *','*'), mti, utils.string.repr(n), mn+2, utils.string.repr(t), " // {!s}".format(utils.string.repr(T) if '\n' in c else utils.string.to(c)) if c else '') for i, n, t, ti, o, s, c, T in res))
        return u"{!r}".format(self.owner)

    def __repr__(self):
        return u"{!s}".format(self)

    def __len__(self):
        '''Return the number of members within the structure.'''
        owner = self.owner
        return 0 if owner.ptr is None else owner.ptr.memqty

    def __getitem__(self, index):
        '''Return the member at the specified `index`.'''
        owner = self.owner
        if isinstance(index, six.integer_types):
            index = owner.ptr.memqty + index if index < 0 else index
            res = member_t(owner, index) if 0 <= index < owner.ptr.memqty else None
        elif isinstance(index, six.string_types):
            res = self.by_name(index)
        elif isinstance(index, slice):
            sliceable = [self[idx] for idx in range(owner.ptr.memqty)]
            res = sliceable[index]
        else:
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({:#x}).members.__getitem__({!r}) : An invalid type ({!s}) was specified for the index.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, index, index.__class__))

        if res is None:
            cls = self.__class__
            raise E.MemberNotFoundError(u"{:s}({:#x}).members.__getitem__({!r}) : Unable to find the member that was requested.".format('.'.join([__name__, cls.__name__]), owner.ptr.id, index))
        return res

    def __delitem__(self, index):
        '''Remove the member at the specified `index`.'''
        return self.pop(index)

    def __iter__(self):
        '''Yield all the members within the structure.'''
        for idx in range(len(self)):
            yield member_t(self.owner, idx)
        return

    def __contains__(self, member):
        '''Return whether the specified `member` is contained by this structure.'''
        if not isinstance(member, member_t):
            raise TypeError(member)

        # Just use members_t.by_identifier to see if it raises an exception.
        try:
            self.by_identifier(member.id)

        # It raised an exception, so the member wasn't found.
        except E.MemberNotFoundError:
            return False
        return True

    ## Serialization
    def __getstate__(self):
        sptr, items = self.owner.ptr, [self[idx] for idx in range(len(self))]
        parent = sptr.props, utils.string.of(idaapi.get_struc_name(sptr.id))
        return (parent, self.baseoffset, items)
    def __setstate__(self, state):
        owner, baseoffset, _ = state

        # figure out our parent here.
        if isinstance(owner, tuple) and len(owner) == 2:
            sprops, ownername = owner

        # backwards compatibility
        elif isinstance(owner, six.string_types):
            sprops, ownername = 0, owner

        # grab the structure containing our members so we can instantiate it
        res = utils.string.to(ownername)
        identifier = idaapi.get_struc_id(res)
        if identifier == idaapi.BADADDR:
            cls = self.__class__
            logging.info(u"{:s}({:#x}) : Creating `members_t` for `structure_t` \"{:s}\" with no members.".format('.'.join([__name__, cls.__name__]), identifier, utils.string.escape(ownername, '"')))
            identifier = idaapi.add_struc(idaapi.BADADDR, res, True if sprops & idaapi.SF_UNION else False)

        # assign the properties for our new member using the instance we figured out
        self.baseoffset = baseoffset
        self.__owner__ = __instance__(identifier, offset=baseoffset)
        return

class member_t(object):
    """
    This object is an abstraction around a single member belonging to
    a structure. A member within a structue contains a number of
    properties which this object will expose. Some of these properties
    allow for a user to modify the member's ``type`` or ``name``. The
    ``tag`` method is also provided to allow for a user to annotate the
    member similar to the database or a function's contents. Another
    method, ``refs`` will allow one to enumerate everything in the
    database that references said member.
    """
    __slots__ = ('__parent__', '__index__')

    def __init__(self, parent, index):
        '''Create a member_t for the field in the structure `parent` at `index`.'''
        self.__index__ = index
        self.__parent__ = parent

    @utils.multicase()
    def tag(self):
        '''Return the tags associated with the member.'''
        repeatable = True

        # grab the repeatable and non-repeatable comment
        res = utils.string.of(idaapi.get_member_cmt(self.id, False))
        d1 = internal.comment.decode(res)
        res = utils.string.of(idaapi.get_member_cmt(self.id, True))
        d2 = internal.comment.decode(res)

        # check for duplicate keys
        if six.viewkeys(d1) & six.viewkeys(d2):
            cls = self.__class__
            logging.info(u"{:s}({:#x}).tag() : The repeatable and non-repeatable comment for {:s} use the same tags ({!r}). Giving priority to the {:s} comment.".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(self.fullname), ', '.join(six.viewkeys(d1) & six.viewkeys(d2)), 'repeatable' if repeatable else 'non-repeatable'))

        # merge the dictionaries into one before adding implicit tags.
        res = {}
        [res.update(d) for d in ([d1, d2] if repeatable else [d2, d1])]

        # the format of the implicit tags depend on the type of the member, which
        # we actually extract from a combination of the name, and is_special_member.
        specialQ = True if idaapi.is_special_member(self.id) else False

        # now we need to check the name via is_dummy_member_name, and explicitly
        # check to see if the name begins with field_ so that we don't use it if so.
        idaname = idaapi.get_member_name(self.id) or ''
        anonymousQ = True if any(F(idaname) for F in [idaapi.is_dummy_member_name, idaapi.is_anonymous_member_name, operator.methodcaller('startswith', 'field_')]) else False
        name = utils.string.of(idaname)

        # if the name is defined and not special in any way, then its a tag.
        aname = '' if any([specialQ, anonymousQ]) else name
        if aname:
            res.setdefault('__name__', aname)

        # The next tag is the type information that we'll need to explicitly check for
        # because IDA will always figure it out and only want to include it iff the
        # user has created the type through some explicit action.

        # The documentation says that we should be checking the NALT_AFLAGS(8) or really
        # the aflags_t of the member which works on structures (since the user will always
        # be creating them). However, for frames we miss out on types that are applied by
        # prototypes or ones that have been propagated to the member by Hex-Rays. So for
        # frames it definitely seems like NSUP_TYPEINFO(0x3000) is the way to go here.
        user_tinfoQ = idaapi.get_aflags(self.id) & idaapi.AFL_USERTI == idaapi.AFL_USERTI
        sup_tinfoQ = internal.netnode.sup.has(self.id, idaapi.NSUP_TYPEINFO)
        has_typeinfo = sup_tinfoQ if is_frame(self.parent) else user_tinfoQ
        if has_typeinfo:
            ti = self.typeinfo

            # Now we need to attach the member name to our type. Hopefully it's not
            # mangled in some way that will need consideration if it's re-applied.
            ti_s = idaapi.print_tinfo('', 0, 0, 0, ti, utils.string.to(aname), '')
            res.setdefault('__typeinfo__', ti_s)
        return res
    @utils.multicase(key=six.string_types)
    @utils.string.decorate_arguments('key')
    def tag(self, key):
        '''Return the tag identified by `key` belonging to the member.'''
        res = self.tag()
        if key in res:
            return res[key]
        cls = self.__class__
        raise E.MissingTagError(u"{:s}({:#x}).tag({!r}) : Unable to read the non-existing tag named \"{:s}\" from the member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, utils.string.escape(key, '"'), utils.string.repr(self.fullname)))
    @utils.multicase(key=six.string_types)
    @utils.string.decorate_arguments('key', 'value')
    def tag(self, key, value):
        '''Set the tag identified by `key` to `value` for the member.'''
        repeatable = True

        # Guard against a bunk type being used to set the value.
        if value is None:
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({:#x}).tag({!r}, {!r}) : Tried to set the tag named \"{:s}\" with an unsupported type {!r}.".format('.'.join([__name__, cls.__name__]), self.id, key, value, utils.string.escape(key, '"'), value))

        # Before we do absolutely anything, we need to check if the user is updating
        # one of the implicit tags and act on them by assigning their new value.
        if key == '__name__':
            tags = self.tag()
            result, self.name = tags.pop(key, None), value
            return result

        elif key == '__typeinfo__':
            tags = self.tag()
            result, self.typeinfo = tags.pop(key, None), value
            return result

        # We need to grab both types of comments so that we can figure out
        # where the one that we're modifying is going to be located at.
        comment_right = utils.string.of(idaapi.get_member_cmt(self.id, repeatable))
        comment_wrong = utils.string.of(idaapi.get_member_cmt(self.id, not repeatable))

        # Now we'll decode both comments and figure out which one contains the key
        # that the user is attempting to modify. The "repeatable" variable is used
        # to toggle which comment gets priority which modifying the member's tags.
        state_right, state_wrong = map(internal.comment.decode, [comment_right, comment_wrong])
        state, where = (state_right, repeatable) if key in state_right else (state_wrong, not repeatable) if key in state_wrong else (state_right, repeatable)

        # Check if the key is a dupe so that we can warn the user about it.
        duplicates = six.viewkeys(state_right) & six.viewkeys(state_wrong)
        if key in duplicates:
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).tag({!r}, {!r}) : The repeatable and non-repeatable comment for member {:s} use the same tags ({!r}). Giving priority to the {:s} comment.".format('.'.join([__name__, cls.__name__]), self.id, key, value, utils.string.repr(self.fullname), ', '.join(duplicates), 'repeatable' if where else 'non-repeatable'))

        # Now we just need to modify the state with the new value and re-encode it.
        res, state[key] = state.get(key, None), value
        if not idaapi.set_member_cmt(self.ptr, utils.string.to(internal.comment.encode(state)), where):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to update the {:s} comment for the member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, value, 'repeatable' if where else 'non-repeatable', utils.string.repr(self.fullname)))
        return res
    @utils.multicase(key=six.string_types, none=None.__class__)
    @utils.string.decorate_arguments('key')
    def tag(self, key, none):
        '''Removes the tag specified by `key` from the member.'''
        repeatable = True

        # Check if the key is an implicit tag that we're being asked to
        # remove so that we can remove it from whatever it represents.
        if key == '__name__':
            tags = self.tag()
            result, self.name = tags.pop(key, None), None
            return result

        elif key == '__typeinfo__':
            tags = self.tag()
            result, self.typeinfo = tags.pop(key, None), None
            return result

        # Read both the comment types to figure out where the tag we want to remove is located at.
        comment_right = utils.string.of(idaapi.get_member_cmt(self.id, repeatable))
        comment_wrong = utils.string.of(idaapi.get_member_cmt(self.id, not repeatable))

        # Now we need to decode them and figure out which comment the tag we need
        # to remove is located in. This reads weird because "repeatable" is intended
        # to toggle which comment type we give priority to during removal.
        state_right, state_wrong = map(internal.comment.decode, [comment_right, comment_wrong])
        state, where = (state_right, repeatable) if key in state_right else (state_wrong, not repeatable) if key in state_wrong else (state_right, repeatable)

        # If the key is not in the dictionary that we determined, then it's missing
        # and so we need to bail with an exception since it doesn't exist.
        if key not in state:
            cls = self.__class__
            raise E.MissingTagError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to remove non-existing tag \"{:s}\" from the member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, none, utils.string.escape(key, '"'), utils.string.repr(self.fullname)))

        # If there's any duplicate keys and the user's key is one of them, then warn
        # the user about it so they'll know that they'll need to remove it twice.
        duplicates = six.viewkeys(state_right) & six.viewkeys(state_wrong)
        if key in duplicates:
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).tag({!r}, {!r}) : The repeatable and non-repeatable comment for member {:s} use the same tags ({!r}). Giving priority to the {:s} comment.".format('.'.join([__name__, cls.__name__]), self.id, key, none, utils.string.repr(self.fullname), ', '.join(duplicates), 'repeatable' if where else 'non-repeatable'))

        # The very last thing to do is to remove the key from the dictionary
        # and then encode our updated state into the member's comment.
        res = state.pop(key)
        if not idaapi.set_member_cmt(self.ptr, utils.string.to(internal.comment.encode(state)), where):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).tag({!r}, {!r}) : Unable to update the {:s} comment for the member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, key, none, 'repeatable' if repeatable else 'non-repeatable', utils.string.repr(self.fullname)))
        return res

    def refs(self):
        """Return the `(address, opnum, type)` of all the code and data references to this member within the database.

        If `opnum` is ``None``, then the returned `address` has the structure applied to it.
        If `opnum` is defined, then the instruction at the returned `address` references a field that contains the specified structure.
        """
        cls, FF_STRUCT = self.__class__, idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU
        Fnetnode, Fidentifier = (getattr(idaapi, api, utils.fidentity) for api in ['ea2node', 'node2ea'])
        FF_STROFF = idaapi.stroff_flag() if hasattr(idaapi, 'stroff_flag') else idaapi.stroffflag()

        # if structure is a frame..
        if interface.node.is_identifier(self.parent.id) and internal.netnode.name.get(Fnetnode(self.parent.id)).startswith('$ '):
            name, mptr = self.fullname, self.ptr
            sptr = idaapi.get_sptr(mptr)

            # get frame, func_t
            frname, _ = name.split('.', 1)
            frid = Fidentifier(internal.netnode.get(frname))
            ea = idaapi.get_func_by_frame(frid)
            f = idaapi.get_func(ea)

            # now find all xrefs to member within function
            xl = idaapi.xreflist_t()
            idaapi.build_stkvar_xrefs(xl, f, mptr)

            # now we can add it
            res = []
            for xr in xl:
                ea, opnum = xr.ea, int(xr.opnum)
                ref = interface.opref_t(ea, opnum, interface.reftype_t(xr.type, instruction.op_state(ea, opnum)))
                res.append(ref)
            return res

        # otherwise, it's a structure..which means we need to specify the member to get refs for
        X, mid = idaapi.xrefblk_t(), self.id
        if not X.first_to(mid, idaapi.XREF_ALL):
            return []

        # collect all references available
        refs = [(X.frm, X.iscode, X.type)]
        while X.next_to():
            refs.append((X.frm, X.iscode, X.type))

        # collect the identifiers of all of the members that can possibly
        # refer to this same one which means we track unions as well. this
        # requires us to recursively walk through all of the references
        # for each parent until we've collected everything.
        parents, members, queue = {self.parent}, {self}, {self.parent}
        while True:
            work = {item for item in []}

            # now that we have our work, we can add it to our list. however, we also
            # need to check if our parent is a union so that we can descend through
            # its members for ones at the same offset of our referring member.
            for item in itertools.chain(*map(operator.methodcaller('up'), queue)):
                if is_union(item.parent):
                    members |= {member for member in item.parent.members if member.realbounds.contains(item.realoffset)}
                    work |= {member.type for member in item.parent.members if isinstance(member.type, structure_t)}
                work |= {item.parent}
                members |= {item}

            # If all of our work is already in our results (parents), then exit our loop.
            if work & parents == work:
                break

            # Otherwise we merge it, reload the queue with our new work, and try..try...again.
            parents, queue = parents | work, work - parents

        # okay, now we can convert this set into a set of structures and members to look for
        candidates = { item.parent.id for item in members } | { item.id for item in members }

        # now figure out which operand has the structure member applied to it
        results = []
        for ea, _, t in refs:
            flags = database.type.flags(ea, idaapi.MS_0TYPE|idaapi.MS_1TYPE)
            listable = [(opnum, instruction.opinfo(ea, opnum)) for opnum in range(instruction.ops_count(ea)) if instruction.opinfo(ea, opnum)]

            # If our list of operand information is empty, then we can skip this reference.
            if not listable:
                cls = self.__class__
                logging.info(u"{:s}.refs() : Skipping reference to member ({:#x}) at {:#x} with flags ({:#x}) due to no operand information.".format('.'.join([__name__, cls.__name__]), self.id, ea, database.type.flags(ea)))

            # If our flags mention a structure offset, then we can just get the structure path.
            elif flags & FF_STROFF:
                logging.info(u"{:s}.refs() : Found strpath_t to member ({:#x}) at {:#x} with flags ({:#x}).".format('.'.join([__name__, cls.__name__]), self.id, ea, database.type.flags(ea)))
                iterable = [(opnum, {identifier for identifier in interface.node.get_stroff_path(ea, opnum)[1]}) for opnum, _ in listable]
                iterable = (opnum for opnum, identifiers in iterable if operator.contains(identifiers, self.parent.id))
                results.extend(interface.opref_t(ea, int(opnum), interface.reftype_t.of(t)) for opnum in iterable)

            # Otherwise, we need to extract the information from the operand's refinfo_t. We
            # filter these by only taking the ones which we can use to calculate the target.
            else:
                logging.info(u"{:s}.refs() : Found refinfo_t to member ({:#x}) at {:#x} with flags ({:#x}).".format('.'.join([__name__, cls.__name__]), self.id, ea, database.type.flags(ea)))
                iterable = ((opnum, info.ri, instruction.op(ea, opnum)) for opnum, info in listable if info.ri.is_target_optional())

                # now we can do some math to determine if the operands really
                # are pointing to our structure member.
                for opnum, ri, value in iterable:
                    offset = value if isinstance(value, six.integer_types) else builtins.next((getattr(value, attribute) for attribute in {'offset', 'address'} if hasattr(value, attribute)), None)

                    # check if we got a valid offset and align it if so, because if
                    # not then we can't calculate the target and need to move on.
                    if offset is None or not database.within(offset):
                        continue
                    offset = interface.address.head(offset, silent=True)

                    # all that's left to do is verify that the structure is in our
                    # list of candidates. although we could do a better job and
                    # check that the offset is actually pointing at the right
                    # member after calculating the base address of the structure.
                    if database.type.flags(offset, idaapi.DT_TYPE) == FF_STRUCT and database.type.structure.id(offset) in candidates:
                        results.append(interface.opref_t(ea, opnum, interface.reftype_t.of(t)))
                    continue
                continue
            continue
        return results

    ### Properties
    @property
    def ptr(self):
        '''Return the pointer of the ``idaapi.member_t``.'''
        parent = self.parent
        return parent.ptr.get_member(self.__index__)
    @property
    def id(self):
        '''Return the identifier of the member.'''
        return self.ptr.id
    @property
    def properties(self):
        '''Return the properties for the current member.'''
        return self.ptr.props
    @property
    def size(self):
        '''Return the size of the member.'''
        return idaapi.get_member_size(self.ptr)
    @property
    def realoffset(self):
        '''Return the real offset of the member.'''
        parent = self.parent.ptr
        return 0 if is_union(parent) else self.ptr.get_soff()
    @property
    def offset(self):
        '''Return the offset of the member.'''
        parent = self.parent
        return self.realoffset + parent.members.baseoffset
    @property
    def flag(self):
        '''Return the "flag" attribute of the member.'''
        res = self.ptr.flag
        return idaapi.as_uint32(res)
    @property
    def fullname(self):
        '''Return the fullname of the member.'''
        res = idaapi.get_member_fullname(self.id)
        return utils.string.of(res)
    @property
    def typeid(self):
        '''Return the identifier of the type of the member.'''
        opinfo = idaapi.opinfo_t()
        res = idaapi.retrieve_member_info(self.ptr, opinfo) if idaapi.__version__ < 7.0 else idaapi.retrieve_member_info(opinfo, self.ptr)
        if res:
            return None if res.tid == idaapi.BADADDR else res.tid
        return None
    @property
    def index(self):
        '''Return the index of the member.'''
        return self.__index__
    @property
    def left(self):
        '''Return the beginning offset of the member.'''
        left, _ = self.bounds
        return left
    @property
    def right(self):
        '''Return the ending offset of the member.'''
        _, right = self.bounds
        return right
    @property
    def realbounds(self):
        '''Return the real boundaries of the member.'''
        sptr, mptr = self.parent.ptr, self.ptr
        return interface.bounds_t(0 if is_union(sptr) else mptr.soff, mptr.eoff)
    @property
    def bounds(self):
        '''Return the boundaries of the member.'''
        parent = self.parent
        bounds, base = self.realbounds, parent.members.baseoffset
        return operator.add(bounds, base)
    @property
    def parent(self):
        '''Return the structure_t that owns the member.'''
        return self.__parent__
    @property
    def dt_type(self):
        '''Return the `dt_type` attribute of the member.'''
        res = self.ptr.flag & idaapi.DT_TYPE
        return idaapi.as_uint32(res)
    dtype = dt_type

    ## Readable/Writeable Properties
    @property
    def name(self):
        '''Return the name of the member.'''
        res = idaapi.get_member_name(self.id) or ''
        return utils.string.of(res)
    @name.setter
    @utils.string.decorate_arguments('string')
    def name(self, string):
        '''Set the name of the member to `string`.'''
        if isinstance(string, tuple):
            string = interface.tuplename(*string)

        # Type safety is fucking valuable.
        if not isinstance(string, (None.__class__, six.string_types)):
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({:#x}).name({!r}) : Unable to assign the provided type ({!s}) as the name for the member.".format('.'.join([__name__, cls.__name__]), self.id, string, string.__class__))

        # If our string is empty, then we need to actually clear the name. This
        # is actually a little tricky because the default name for a field is
        # (field_%X) and two different ones for a frame (var_%X, arg_%X).
        if not string:
            sptr, mptr = self.parent.ptr, self.ptr

            # Define our name formatters that we will eventually use.
            fmtField = "field_{:X}".format
            fmtVar = "var_{:X}".format
            fmtArg = "arg_{:X}".format

            # If it's not a function frame, then this is easy as we can just
            # use mptr.get_soff() to get the correct offset exactly.
            if not is_frame(sptr):
                result, self.name = self.name, fmtField(mptr.get_soff())
                return result

            # To process the frame, we first need the address of the function
            # to get the func_t and the actual member offset to calculate with.
            ea = idaapi.get_func_by_frame(sptr.id)
            if ea == idaapi.BADADDR:
                cls = self.__class__
                raise E.DisassemblerError(u"{:s}({:#x}).name({!s}) : Unable to get the function for the frame ({:#x}) containing the structure member.".format('.'.join([__name__, cls.__name__]), self.id, string, sptr.id))

            # We need to figure out all of the attributes we need in order to
            # calculate the position within a frame this includes the integer size.
            fn, soff = idaapi.get_func(ea), mptr.get_soff()
            if fn is None:
                cls = self.__class__
                raise E.FunctionNotFoundError(u"{:s}({:#x}).name({!s}) : Unable to get the function at the specified address ({:#x}) which owns the frame ({:#x}).".format('.'.join([__name__, cls.__name__]), self.id, string, ea, sptr.id))

            # Now we need to figure out whether where our member is. If it's
            # within the func_t.frsize, then we're a var_.
            if soff < fn.frsize:
                fmt, offset = fmtVar, fn.frsize - soff

            # If it's within func_t.frregs, then we're a special ' s' name.
            elif soff < idaapi.frame_off_retaddr(fn):
                fmt, offset = (lambda _: ' s'), None

            # If it's at the saved register, then we're a special ' r' name.
            elif soff < idaapi.frame_off_args(fn):
                fmt, offset = (lambda _: ' r'), None

            # Anything else should be an argument so we will use 'arg_'
            elif soff < idaapi.frame_off_args(fn) + fn.argsize:
                fmt, offset = fmtArg, soff - idaapi.frame_off_args(fn)

            # Anything else though...is a bug, it shouldn't happen unless IDA is not
            # actually populating the fields correctly (looking at you x64). So, lets
            # just be silently pedantic here.
            else:
                fmt, offset = fmtArg, soff - idaapi.frame_off_args(fn)
                cls = self.__class__
                logging.debug(u"{:s}({:#x}).name({!s}) : Treating the name for the member at offset ({:#x}) as an argument due being located outside of the frame ({:#x}).".format('.'.join([__name__, cls.__name__]), self.id, string, soff, sum([idaapi.frame_off_args(fn), fn.argsize])))

            # Okay, now the last thing to do is to format our name and assign it..weeee, that was fun.
            result, self.name = self.name, fmt(offset)
            return result

        # for the sake of being pedantic here too, we check to see if this is a special
        # member, because if we touch it...it becomes non-special for some reason.
        if idaapi.is_special_member(self.id):
            cls = self.__class__
            logging.warning(u"{:s}({:#x}).name({!r}) : Modifying the name for the special member at offset ({:#x}) will unfortunately demote its special properties.".format('.'.join([__name__, cls.__name__]), self.id, string, self.ptr.get_soff()))

        # convert the specified string into a form that IDA can handle
        ida_string = utils.string.to(string)

        # validate the name
        res = idaapi.validate_name2(ida_string[:]) if idaapi.__version__ < 7.0 else idaapi.validate_name(ida_string[:], idaapi.VNT_VISIBLE)
        if ida_string and ida_string != res:
            cls = self.__class__
            logging.info(u"{:s}({:#x}).name({!r}) : Stripping invalid chars from structure member name (\"{:s}\") resulted in \"{:s}\".".format('.'.join([__name__, cls.__name__]), self.id, string, utils.string.escape(string, '"'), utils.string.escape(utils.string.of(res), '"')))
            ida_string = res

        # now we can set the name of the member at the specified offset
        oldname = self.name
        if not idaapi.set_member_name(self.parent.ptr, self.offset - self.parent.members.baseoffset, ida_string):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).name({!r}) : Unable to assign the specified name ({:s}) to the structure member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, string, utils.string.repr(ida_string), utils.string.repr(oldname)))

        # verify that the name was actually assigned properly
        assigned = idaapi.get_member_name(self.id) or ''
        if utils.string.of(assigned) != utils.string.of(ida_string):
            cls = self.__class__
            logging.info(u"{:s}({:#x}).name({!r}) : The name ({:s}) that was assigned to the structure member does not match what was requested ({:s}).".format('.'.join([__name__, cls.__name__]), self.id, string, utils.string.repr(utils.string.of(assigned)), utils.string.repr(ida_string)))
        return oldname

    @property
    def comment(self, repeatable=True):
        '''Return the repeatable comment of the member.'''
        res = idaapi.get_member_cmt(self.id, repeatable) or idaapi.get_member_cmt(self.id, not repeatable)
        return utils.string.of(res)
    @comment.setter
    @utils.string.decorate_arguments('value')
    def comment(self, value, repeatable=True):
        '''Set the repeatable comment of the member to `value`.'''
        res = utils.string.to(value or '')
        if not idaapi.set_member_cmt(self.ptr, res, repeatable):
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).comment(..., repeatable={!s}) : Unable to assign the provided comment to the structure member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, repeatable, utils.string.repr(self.name)))

        # verify that the comment was actually assigned properly
        assigned = idaapi.get_member_cmt(self.id, repeatable)
        if utils.string.of(assigned) != utils.string.of(res):
            cls = self.__class__
            logging.info(u"{:s}({:#x}).comment(..., repeatable={!s}) : The comment ({:s}) that was assigned to the structure member does not match what was requested ({:s}).".format('.'.join([__name__, cls.__name__]), self.id, repeatable, utils.string.repr(utils.string.of(assigned)), utils.string.repr(res)))
        return assigned

    @property
    def type(self):
        '''Return the type of the member in its pythonic form.'''
        res = interface.typemap.dissolve(self.flag, self.typeid, self.size, offset=self.offset)
        if isinstance(res, structure_t):
            res = __instance__(res.id, offset=self.offset)
        elif isinstance(res, tuple):
            iterable = (item for item in res)
            t = next(iterable)
            if isinstance(t, structure_t):
                t = __instance__(t.id, offset=self.offset)
            elif isinstance(t, builtins.list) and isinstance(t[0], structure_t):
                t[0] = __instance__(t[0].id, offset=self.offset)
            res = builtins.tuple(itertools.chain([t], iterable))
        return res
    @type.setter
    def type(self, type):
        '''Set the type of the member to the provided `type`.'''
        cls, set_member_tinfo = self.__class__, idaapi.set_member_tinfo2 if idaapi.__version__ < 7.0 else idaapi.set_member_tinfo

        # if we were given a tinfo_t or a string to use, then we pretty much use
        # it with the typeinfo api, but allow it the ability to destroy other members.
        if isinstance(type, (six.string_types, idaapi.tinfo_t)):
            info = type if isinstance(type, idaapi.tinfo_t) else internal.declaration.parse(type)
            res = set_member_tinfo(self.parent.ptr, self.ptr, self.ptr.get_soff(), info, idaapi.SET_MEMTI_MAY_DESTROY)
            if res in {idaapi.SMT_OK, idaapi.SMT_KEEP}:
                return

            elif res == idaapi.SMT_FAILED:
                raise E.DisassemblerError(u"{:s}({:#x}).type({!s}) : Unable to assign the type information ({!s}) to structure member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr("{!s}".format(info)), utils.string.escape("{!s}".format(info), '"'), utils.string.repr(self.name)))

            errtable = {
                idaapi.SMT_BADARG: 'invalid parameters', idaapi.SMT_NOCOMPAT: 'incompatible type', idaapi.SMT_WORSE: 'worse type',
                idaapi.SMT_SIZE: 'invalid type for member size', idaapi.SMT_ARRAY: 'setting function argument as an array is illegal',
                idaapi.SMT_OVERLAP: 'the specified type would result in member overlap', idaapi.SMT_KEEP: 'the specified type is not ideal',
            }
            message = errtable.get(res, "unknown error {:#x}".format(res))
            raise E.DisassemblerError(u"{:s}({:#x}).typeinfo({!s}) : Unable to assign the type information ({!s}) to structure member {:s} ({:s}).".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr("{!s}".format(info)), utils.string.escape("{!s}".format(info), '"'), utils.string.repr(self.name), message))

        # decompose the pythonic type into the actual information to apply.
        flag, typeid, nbytes = interface.typemap.resolve(type)

        opinfo = idaapi.opinfo_t()
        opinfo.tid = typeid
        if not idaapi.set_member_type(self.parent.ptr, self.offset - self.parent.members.baseoffset, flag, opinfo, nbytes):
            raise E.DisassemblerError(u"{:s}({:#x}).type({!s}) : Unable to assign the provided type ({!s}) to the structure member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, type, type, utils.string.repr(self.name)))

        # verify that our type has been applied before we update its refinfo,
        # because if it hasn't then we need to warn the user about it so that
        # they know what's up and why didn't do what we were asked.
        expected, expected_tid = (flag, nbytes), typeid
        resulting, resulting_tid = (self.flag, self.size), self.typeid

        if expected == resulting:
            interface.address.update_refinfo(self.id, flag)
        else:
            logging.warning(u"{:s}({:#x}).type({!s}) : Applying the given flags and size ({:#x}, {:d}) resulted in different flags and size being assigned ({:#x}, {:d}).".format('.'.join([__name__, cls.__name__]), self.id, type, *itertools.chain(expected, resulting)))

        # smoke-test that we actually updated the type identifier and log it if it
        # didn't actually work. this is based on my ancient logic which assumed
        # that opinfo.tid should be BADADDR which isn't actually the truth when
        # you're working with a refinfo. hence we try to be quiet about it.
        if expected_tid != (resulting_tid or idaapi.BADADDR):
            logging.info(u"{:s}({:#x}).type({!s}) : The provided typeid ({:#x}) was incorrectly assigned as {:#x}.".format('.'.join([__name__, cls.__name__]), self.id, type, expected_tid, resulting_tid or idaapi.BADADDR))

        # return the stuff that actually applied.
        flag, size = resulting
        return flag, resulting_tid, size

    @property
    def typeinfo(self):
        '''Return the type information of the current member.'''
        ti = idaapi.tinfo_t()

        # Guess the typeinfo for the current member. If we're unable to get the
        # typeinfo then we just raise whatever we have. Let IDA figure it out.
        ok = idaapi.get_or_guess_member_tinfo2(self.ptr, ti) if idaapi.__version__ < 7.0 else idaapi.get_or_guess_member_tinfo(ti, self.ptr)
        if not ok:
            cls = self.__class__
            logging.debug(u"{:s}({:#x}).typeinfo : Returning the guessed type that was determined for member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, self.name))
        return ti
    @typeinfo.setter
    def typeinfo(self, info):
        '''Set the type information of the current member to `info`.'''
        set_member_tinfo = idaapi.set_member_tinfo2 if idaapi.__version__ < 7.0 else idaapi.set_member_tinfo

        # Type safety is fucking valuable, and anything that doesn't match gives you an exception.
        if not isinstance(info, (idaapi.tinfo_t, None.__class__, six.string_types)):
            cls = self.__class__
            raise E.InvalidParameterError(u"{:s}({:#x}).typeinfo({!s}) : Unable to assign the provided type ({!s}) to the type information for the member.".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(info), info.__class__))

        # If our parameter is empty, then we need to re-assign an empty type to clear it.
        if not info:
            ti = idaapi.tinfo_t()

            # FIXME: clearing the type is probably not the semantics the user would expect,
            #        and so we should probably transform the current type to remove any
            #        array or other weird attributes as long as it retains the same size.
            ti.clear()

        # Otherwise if it's a string, then we'll need to parse our info parameter into a
        # tinfo_t, so that we can assign it to the typeinfo for the member.
        elif isinstance(info, six.string_types):
            ti = internal.declaration.parse(info)
            if ti is None:
                cls = self.__class__
                raise E.InvalidTypeOrValueError(u"{:s}({:#x}).typeinfo({!s}) : Unable to parse the specified type declaration ({!s}).".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(info), utils.string.repr(info)))
            info_description = info

        # If it's a tinfo_t, then we can just use it as-is.
        elif isinstance(info, idaapi.tinfo_t):
            ti, info_description = info, "{!s}".format(info)

        # Now we can pass our tinfo_t along with the member information to IDA.
        res = set_member_tinfo(self.parent.ptr, self.ptr, self.ptr.get_soff(), ti, idaapi.SET_MEMTI_COMPATIBLE)
        if res == idaapi.SMT_OK:
            return

        # We failed, so just raise an exception for the user to handle.
        elif res == idaapi.SMT_FAILED:
            cls = self.__class__
            raise E.DisassemblerError(u"{:s}({:#x}).typeinfo({!s}) : Unable to assign the provided type information to structure member {:s}.".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(info_description), utils.string.repr(self.name)))

        # If we received an alternative return code, then build a relevant
        # message that we can raise with our exception.
        if res == idaapi.SMT_BADARG:
            message = 'invalid parameters'
        elif res == idaapi.SMT_NOCOMPAT:
            message = 'incompatible type'
        elif res == idaapi.SMT_WORSE:
            message = 'worse type'
        elif res == idaapi.SMT_SIZE:
            message = 'invalid type for member size'
        elif res == idaapi.SMT_ARRAY:
            message = 'setting function argument as an array is illegal'
        elif res == idaapi.SMT_OVERLAP:
            message = 'the specified type would result in member overlap'
        elif res == idaapi.SMT_KEEP:
            message = 'the specified type is not ideal'
        else:
            message = "unknown error {:#x}".format(res)

        # Finally we can raise our exception so that the user knows whats up.
        cls = self.__class__
        raise E.DisassemblerError(u"{:s}({:#x}).typeinfo({!s}) : Unable to assign the provided type information to structure member {:s} ({:s}).".format('.'.join([__name__, cls.__name__]), self.id, utils.string.repr(info_description), utils.string.repr(self.name), message))

    ### Private methods
    def __str__(self):
        '''Render the current member in a readable format.'''
        id, name, typ, comment, tag, typeinfo = self.id, self.fullname, self.type, self.comment or '', self.tag(), "{!s}".format(self.typeinfo.dstr()).replace(' *', '*')
        return "<member '{:s}' index={:d} offset={:-#x} size={:+#x}{:s}>{:s}".format(utils.string.escape(name, '\''), self.index, self.offset, self.size, " typeinfo='{:s}'".format(typeinfo) if typeinfo else '', " // {!s}".format(utils.string.repr(tag) if '\n' in comment else utils.string.to(comment)) if comment else '')

    def __unicode__(self):
        '''Render the current member in a readable format.'''
        id, name, typ, comment, tag, typeinfo = self.id, self.fullname, self.type, self.comment or '', self.tag(), "{!s}".format(self.typeinfo.dstr()).replace(' *', '*')
        return u"<member '{:s}' index={:d} offset={:-#x} size={:+#x}{:s}>{:s}".format(utils.string.escape(name, '\''), self.index, self.offset, self.size, " typeinfo='{:s}'".format(typeinfo) if typeinfo else '', " // {!s}".format(utils.string.repr(tag) if '\n' in comment else utils.string.to(comment)) if comment else '')

    def __repr__(self):
        return u"{!s}".format(self)

    ## Hashable
    def __hash__(self):
        return self.ptr.id
    def __ne__(self, other):
        return not self.__eq__(other)
    def __eq__(self, other):
        if isinstance(other, idaapi.member_t):
            return self.ptr.id == other.id
        elif isinstance(other, member_t):
            return self.ptr.id == other.ptr.id
        return False

    ## Serialization
    def __getstate__(self):
        parentbase = self.__parent__.members.baseoffset
        mptr, fullname, sptr = idaapi.get_member_by_id(self.ptr.id)

        # grab its typeinfo and serialize it
        tid = self.typeid
        tid = None if tid is None else __instance__(tid) if has(tid) else tid
        flag, size = mptr.flag, idaapi.get_member_size(mptr)
        ty = mptr.flag, tid, size

        # if the user applied some type information to the member, then we make sure
        # to serialize it (print_tinfo) so we can parse it back into the member.
        ti = self.typeinfo
        if '__typeinfo__' in self.tag():
            res = idaapi.PRTYPE_1LINE | idaapi.PRTYPE_SEMI | idaapi.PRTYPE_NOARRS | idaapi.PRTYPE_RESTORE
            tname = idaapi.print_tinfo('', 0, 0, res, ti, '', '')
            tinfo = idaapi.print_tinfo('', 0, 0, res | idaapi.PRTYPE_DEF, ti, tname, '')

            # use a list so we can differentiate older version from newer
            typeinfo = ty, [tname, tinfo]

        # otherwise, we serialize the type into the older version. this shouldn't
        # get applied because there's a chance the type doesn't exist.
        else:
            typeinfo = ty, ti.serialize()

        # grab its comments
        cmtt = idaapi.get_member_cmt(mptr.id, True)
        cmtf = idaapi.get_member_cmt(mptr.id, False)
        comments = tuple(utils.string.of(cmt) for cmt in [cmtt, cmtf])

        # grab its parent name along with its name, and then we can
        # pack the information about its parent into a tuple.
        pname, name = fullname.split('.', 1)
        parent = pname, sptr.props, parentbase

        # pack up our state
        state = mptr.props, mptr.soff, typeinfo, name, comments

        # combine parent state with our location (index) and state
        return parent, self.__index__, state
    def __setstate__(self, state):
        FF_STRUCT = idaapi.FF_STRUCT if hasattr(idaapi, 'FF_STRUCT') else idaapi.FF_STRU

        # Restore all the attributes we need to deserialize.
        if len(state) == 3:
            parent, index, state = state
            parentname, parentprops, parentbase = parent
            props, soff, typeinfo, name, (cmtt, cmtf) = state

        # In order to remain backwards compatible...
        else:
            parentname, index, name, (cmtt, cmtf), soff, typeinfo = state
            parentprops = props = 0
            parentbase = 0
        cls, fullname = self.__class__, '.'.join([parentname, name])

        # get the structure owning the member by the name we stored
        # creating it if necessary.
        res = utils.string.to(parentname)
        identifier = idaapi.get_struc_id(res)
        if identifier == idaapi.BADADDR:
            logging.info(u"{:s}({:#x}, index={:d}) : Creating structure ({:s}) for member named \"{:s}\" with the comment {!r}.".format('.'.join([__name__, cls.__name__]), identifier, index, parentname, utils.string.escape(name, '"'), cmtt or cmtf or ''))
            identifier = idaapi.add_struc(idaapi.BADADDR, res, True if parentprops & idaapi.SF_UNION else False)

        if identifier == idaapi.BADADDR:
            raise E.DisassemblerError(u"{:s}({:#x}, {:s}) : Unable to get structure ({:s}) for member named \"{:s}\" with the comment {!r}.".format('.'.join([__name__, cls.__name__]), identifier, index, parentname, utils.string.escape(name, '"'), cmtt or cmtf or ''))

        # now we can get our structure and run with it
        sptr = idaapi.get_struc(identifier)
        count = sptr.memqty

        # extract the type information of the member so that we can
        # construct the opinfo_t and later apply the tinfo_t.
        t, ti = typeinfo
        flag, mytype, nbytes = t

        opinfo = idaapi.opinfo_t()
        if mytype is None:
            if flag & idaapi.DT_TYPE == FF_STRUCT:
                logging.warning(u"{:s}({:#x}, index={:d}): Unexpected DT_TYPE was found in flags ({:#x}) for the untyped member \"{:s}\" of structure ({:s}).".format('.'.join([__name__, cls.__name__]), sptr.id, index, flag, utils.string.escape(name, '"'), parentname))

        # if we have an integer or a structure_t, then assign it as the identifier for the opinfo.
        else:
            opinfo.tid = mytype if isinstance(mytype, six.integer_types) else mytype.id

        # add the member to the database, and then check whether there was a naming
        # issue of some sort so that we can warn the user or resolve it.
        res = utils.string.to(name)
        mem = idaapi.add_struc_member(sptr, res, 0 if sptr.props & idaapi.SF_UNION else soff, flag, opinfo, nbytes)

        # FIXME: handle these naming errors properly
        # duplicate name
        if mem == idaapi.STRUC_ERROR_MEMBER_NAME:
            if idaapi.get_member_by_name(sptr, res).soff != soff:
                newname = u"{:s}_{:x}".format(res, soff)
                logging.warning(u"{:s}({:#x}, index={:d}): Duplicate name found for member \"{:s}\" of structure ({:s}), renaming it to \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, utils.string.escape(name, '"'), parentname, utils.string.escape(newname, '"')))
                idaapi.set_member_name(sptr, soff, utils.string.to(newname))
            else:
                logging.info(u"{:s}({:#x}, index={:d}): Ignoring field at index {:d} of structure ({:s}) with the same name (\"{:s}\") and position ({:#x}).".format('.'.join([__name__, cls.__name__]), sptr.id, index, index, parentname, utils.string.escape(name, '"'), soff))

        # duplicate field (same offset)
        elif mem == idaapi.STRUC_ERROR_MEMBER_OFFSET:
            mptr = idaapi.get_member(sptr, soff)
            if (utils.string.of(idaapi.get_member_name(mptr.id)), mptr.flag, idaapi.get_member_size(mptr)) != (res, flag, nbytes):
                logging.warning(u"{:s}({:#x}, index={:d}): Already existing field found at offset {:+#x} of structure ({:s}), overwriting it with \"{:s}\" of size ({:#x}) and flags ({:#x}).".format('.'.join([__name__, cls.__name__]), sptr.id, index, soff, parentname, utils.string.escape(name, '"'), nbytes, flag))
                idaapi.set_member_type(sptr, soff, flag, opinfo, nbytes)
                idaapi.set_member_name(sptr, soff, res)

        # unknown
        elif mem != idaapi.STRUC_ERROR_MEMBER_OK:
            errors = {getattr(idaapi, name): name for name in dir(idaapi) if name.startswith('STRUC_ERROR_')}
            logging.warning(u"{:s}({:#x}, index={:d}): Error {:s} returned while trying to create member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, "{:s}({:#x})".format(errors[mem], mem) if mem in errors else "code ({:#x})".format(mem), utils.string.escape(fullname, '"')))

        # check the index and count, as we've already added it properly (STRUC_ERROR_MEMBER_OK)
        elif index != count:
            logging.warning(u"{:s}({:#x}, index={:d}): The member that was created (\"{:s}\") was expected at index {:d} but was created at index {:d}.".format('.'.join([__name__, cls.__name__]), sptr.id, index, utils.string.escape(fullname, '"'), index, count))
            index = count

        # now that we know our parent exists and th member has been added
        # we can use the soff to grab the the member's mptr.
        mptr = idaapi.get_member(sptr, soff)
        parent = __instance__(sptr.id, offset=parentbase)
        self.__parent__, self.__index__ = parent, index

        # update both of the member's comments prior to fixing its type.
        idaapi.set_member_cmt(mptr, utils.string.to(cmtt), True)
        idaapi.set_member_cmt(mptr, utils.string.to(cmtf), False)

        # if we're using the new tinfo version (a list), then try our hardest
        # to parse it. if we succeed, then we likely can apply it later.
        if isinstance(ti, builtins.list) and len(ti) == 2:
            tname, tinfo = ti
            typeinfo = internal.declaration.parse(tname) if tname else None
            typeinfo = typeinfo if typeinfo else internal.declaration.parse(tinfo)
            None if typeinfo is None else logging.info(u"{:s}({:#x}, index={:d}): Successfully parsed type information for member \"{:s}\" as \"{!s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, utils.string.escape(fullname, '"'), typeinfo))

        # otherwise it's the old version (a tuple), and it shouldn't need to
        # exist... but, if we can actually deserialize it then later we can
        # likely apply it...unless it has an ordinal.
        else:
            typeinfo = idaapi.tinfo_t()
            if typeinfo.deserialize(None, *ti):
                logging.info(u"{:s}({:#x}, index={:d}): Successfully deserialized type information for member \"{:s}\" as \"{!s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, utils.string.escape(fullname, '"'), typeinfo))
            else:
                logging.info(u"{:s}({:#x}, index={:d}): Skipping application of corrupted type information ({!r}) for member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, ti, utils.string.escape(fullname, '"')))
                typeinfo = None

        # if tinfo was defined and it doesn't use an ordinal, then we can apply it.
        # FIXME: we are likely going to need to traverse this to determine if it's using an ordinal or not
        if typeinfo and not any([typeinfo.get_ordinal(), typeinfo.is_array() and typeinfo.get_array_element().get_ordinal()]):
            try:
                self.typeinfo = typeinfo

            # if the type is not ideal, then we can pretty much ignore this because
            # the type is already there and IDA thinks that it's okay.
            except E.DisassemblerError as exc:
                if 'type is not ideal' in "{!s}".format(exc):
                    logging.info(u"{:s}({:#x}, index={:d}): The disassembler refused to apply the type information \"{!s}\" to the member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, typeinfo, utils.string.escape(fullname, '"')))
                    logging.debug(u"{!s}".format(exc))

                # otherwise, we need to warn the user about what happened.
                else:
                    logging.warning(u"{:s}({:#x}, index={:d}): The disassembler was unable to apply the type information \"{!s}\" to the member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, typeinfo, utils.string.escape(fullname, '"')))
                    logging.warning(u"{!s}".format(exc))

            # we're good, it was applied.
            else:
                logging.info(u"{:s}({:#x}, index={:d}): Applied the type information \"{!s}\" to the member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, typeinfo, utils.string.escape(fullname, '"')))

        # otherwise, we had type information that was an ordinal which might not
        # exist in our database...so we ask IDA to make a guess at what it is.
        elif typeinfo:
            ti = idaapi.tinfo_t()
            ok = idaapi.get_or_guess_member_tinfo2(mptr, ti) if idaapi.__version__ < 7.0 else idaapi.get_or_guess_member_tinfo(ti, mptr)
            try:
                if ok:
                    self.typeinfo = ti

            # if the type was not ideal, then this can be ignored because IDA
            # really knows best, and if it says we're wrong..then we're wrong.
            except E.DisassemblerError as exc:
                if 'type is not ideal' in "{!s}".format(exc):
                    logging.info(u"{:s}({:#x}, index={:d}): The disassembler refused to apply the guessed type information \"{!s}\" to the member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, typeinfo, utils.string.escape(fullname, '"')))
                    logging.debug(u"{!s}".format(exc))

                else:
                    logging.warning(u"{:s}({:#x}, index={:d}): The disassembler was unable to apply the guesed type information \"{!s}\" to the member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, typeinfo, utils.string.escape(fullname, '"')))
                    logging.warning(u"{!s}".format(exc))

            # if we applied it, then we're good.
            else:
                ok and logging.info(u"{:s}({:#x}, index={:d}): Applied the type information \"{!s}\" to the member \"{:s}\".".format('.'.join([__name__, cls.__name__]), sptr.id, index, typeinfo, utils.string.escape(fullname, '"')))
        return

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "ida-minsc",
    "entryPoint": "idapythonrc.py",
    "categories": ["python", "library", "dwim", "hamsters", "portable", "indexed-comments", "API-scripting-and-automation", "vulnerability-research-and-exploit-development", "collaboration-and-productivity", "other"],
    "logoPath": "http://arizvisa.github.io/ida-minsc/_images/hamster.svg",
    "idaVersions": "<8.5",
    "description": "IDA-minsc wraps IDAPython to provide a higher-level context-sensitive pattern-matching api that simplifies many annotation tasks. This augments things like decoding structured data from the database, adds support for indexing, tags, and python types to comments, and allows for arithmetic with things such as structures, bitmasks/enumerations, and much more.",
    "version": "0.0.0"
  }
}

```

`idapythonrc.py`:

```py
"""
Internal initialization script

This is an internal script that is executed when IDA starts. Things
such as meta_path hooks, replacing the namespace with the contents
of the __root__ module, and implementing a work-around for the hack
that IDAPython does with saving the contents of sys.modules. After
initializing everything, this script will then hand off execution
to the user's idapythonrc.py in their home directory.
"""

# output the IDAPython banner when IDA starts
print_banner()

# some general python modules that we use for meta_path
import sys, os, imp
import idaapi

# grab ida's user directory and remove from it from the path since we use
# python's meta_path to locate all of our modules. we also use this path
# to find out where our loader logic is actually located.
root = idaapi.get_user_idadir()
sys.path[:] = [item for item in sys.path if os.path.realpath(item) not in {os.path.realpath(root)}]

# grab the loader, and then use it to seed python's meta_path.
loader = imp.load_source('__loader__', os.path.join(root, 'plugins', 'minsc.py'))
sys.meta_path.extend(loader.finders())

# then we need to patch the version into "idaapi" so that we can
# access it when figuring out which logic we need to use.
loader.patch_version(idaapi)

# IDA 6.95 obnoxiously replaces the displayhook with their own
# version which makes it so that we can't hook it with ours.
if idaapi.__version__ >= 6.95 and hasattr(ida_idaapi, '_IDAPython_displayhook') and hasattr(ida_idaapi._IDAPython_displayhook, 'orig_displayhook'):
    sys.displayhook = ida_idaapi._IDAPython_displayhook.orig_displayhook
    del(ida_idaapi._IDAPython_displayhook)

# replace sys.displayhook with our own so that IDAPython can't
# tamper with our __repr__ implementations.
sys.displayhook = loader.DisplayHook(sys.stdout.write, sys.displayhook).displayhook

# now we can just load it into the globals() namespace, but we still
# need to preserve it as we'll need one more function after transition.
loader.load(globals(), preserve={'loader', '_orig_stdout', '_orig_stderr'})

# now we can start everything up within our namespace and then we can
# just delete the loader afterwards.
loader.startup(globals())
del(loader)

## stupid fucking idapython hax

# prevent idapython from trying to write its banner to the message window since we called it up above.
print_banner = lambda: None

# find the frame that fucks with our sys.modules, and save it for later
frame = __import__('sys')._getframe()
while frame.f_code.co_name != 'IDAPython_ExecScript':
    frame = frame.f_back

# inject our current sys.modules state into IDAPython_ExecScript's state if it's the broken version
if 'basemodules' in frame.f_locals:
    frame.f_locals['basemodules'].update(__import__('sys').modules)
del(frame)

```

`misc/hooks.py`:

```py
"""
Internal module (hooks)

This is an internal module that contains implementations of all the hooks
that are used. Some of the things that are hooked are things such as
comment creation, function and segment scoping, etc. This is not intended
to be used by the average user.
"""

import six
import sys, logging
import functools, operator, itertools, types

import database, function, instruction, ui
import internal
from internal import comment, utils, interface, exceptions as E

import idaapi

def greeting():
    barrier = 86

    loaders, loader_suffix = {}, '__loader__'
    for item in sys.meta_path:
        if item.__module__.endswith(loader_suffix):
            if hasattr(item, '__iter__'):
                name = getattr(item, '__name__', None)
            else:
                name, item = None, [item.__name__]
            loaders.setdefault(name, []).append(item)
        continue

    # iterate through our loaders to try and find the one that actually contains
    # our plugin state. we abuse each loader's __module__ attribute and consolidate
    # them into a set so that we can take the first.
    items = {item.__module__ for item in itertools.chain(*(items for _, items in loaders.items())) if hasattr(item, '__module__')}
    module_name = next((name for name in items), loader_suffix)

    # next we trim out the module suffix and use it to find the actual module
    # that should contain our plugin so we can extract our plugin state. if the
    # module name is empty, then we assume we've been loaded persistently.
    module_name = module_name[:-len(loader_suffix)] if module_name.endswith(loader_suffix) else module_name
    load_state = sys.modules[module_name].MINSC.state if module_name and module_name in sys.modules else 'persistent'

    # now we iterate through all of the loaders that do not have a module name
    # while ignoring the hooks module because that it should really be internal.
    items = itertools.chain(*(items for name, items in loaders.items() if name is None))
    available = sorted(item for item in itertools.chain(*items) if item != 'hooks')

    # hide the internal module from our display.
    loaders.pop('internal', None)

    # grab all the loaders that represent a submodule.
    submodules = ((name, itertools.chain(*map(sorted, items))) for name, items in loaders.items() if name)
    loaded = {name: ['.'.join([name, item]) for item in items if not item.startswith('_')] for name, items in submodules}
    maximum = 1 + max(map(len, loaded))
    submodules = (' '.join(["{:<{:d}s}".format(name + ':', maximum), ', '.join(loaded[name])] if loaded[name] else ["{:<{:d}s}".format(name + ':', maximum)]) for name in sorted(loaded, key=len))

    six.print_("Welcome to the ida-minsc plugin!")
    six.print_("")
    six.print_("The plugin is {:s} and is currently using python {:s} in IDA {:.1f} ({:s}).".format(load_state, '.'.join("{:d}".format(getattr(sys.version_info, field, 0)) for field in ['major', 'minor', 'micro']), idaapi.__version__, sys.platform))
    six.print_("")

    if available:
        six.print_("The following namespaces have been introduced into IDAPython:")
        six.print_("    {:s}".format(', '.join(available)))
        six.print_("")

    if submodules:
        six.print_("The following modules are available and may also be imported:")
        [six.print_("    {:s}".format(submodule)) for submodule in submodules]
        six.print_("")

    useful_modules = [
        ('ida_hexrays', 'https://hex-rays.com/decompiler/', 'for a freaking decompiler'),
        ('networkx', 'https://pypi.org/project/networkx/', 'for a real graph api'),
        ('dill', 'https://pypi.org/project/dill/', 'to save (and load) your game'),
    ]

    results, find_loader = [], __import__('imp').find_module if sys.version_info.major < 3 else __import__('importlib').find_loader
    for name, url, description in useful_modules:
        try:
            if find_loader(name) is None:
                raise ImportError
        except ImportError:
            results.append((name, url, description))
        continue

    if results:
        for name, url, description in results:
            six.print_("You should consider installing the `{:s}` module ({:s}){:s}.".format(name, url, " {:s}".format(description) if description else ''))
        six.print_("")

    six.print_("Your globals have been cleaned, use `dir()` to see your work.")
    six.print_("")
    six.print_("Please use `help(namespace)` or `help(modulename)` for general usage.")
    six.print_("You may also visit {:s} for html-based help.".format('https://arizvisa.github.io/ida-minsc'))
    six.print_('-' * barrier)

### comment hooks
class changingchanged(object):
    """
    This base class is for dealing with 2-part events where one part is the
    "changing" event which is dispatched before any changes are made, and the
    second part is the "changed" event which happens after they've been completed.
    """
    @classmethod
    def database_init(cls, idp_modname):
        return cls.initialize()

    @classmethod
    def nw_database_init(cls, nw_code, is_old_database):
        idp_modname = idaapi.get_idp_name()
        return cls.database_init(idp_modname)

    @classmethod
    def is_ready(cls):
        '''This is just a utility method for determining if a database is ready or not.'''
        global State
        return State in {state.ready}

    @classmethod
    def initialize(cls):
        """
        This method just initializes our states dictionary and should be
        called prior to a database being loaded. This way any changing/changed
        events will be able to be stored according to the address that they're
        acting upon.
        """
        states = getattr(cls, '__states__', {})
        if states:
            logging.info(u"{:s}.init() : Removing {:d} incomplete states due to re-initialization of database.".format('.'.join([__name__, cls.__name__]), len(states)))
        cls.__states__ = {}

    @classmethod
    def new(cls, ea):
        '''This registers a new state for a given address that can later be fetched.'''
        states = cls.__states__

        # If we're being asked to recreate the state for an address that is still
        # incomplete, then warn the user about it. This will only happen when the
        # "changing" event is called for the same address more than once without
        # the "changed" event being used to complete it.
        if ea in states:
            res = states.pop(ea)
            logging.info(u"{:s}.new({:#x}) : Forcefully closing the state for address {:#x} by request.".format('.'.join([__name__, cls.__name__]), ea, ea))
            res.close()

        # Define a closure that is responsible for keeping track
        # of a subclass' updater so that when it completes its
        # execution it can be removed from our states dictionary.
        def consumer(ea, states, handler):
            next(handler)

            # Consume our handler until it's finished. When we
            # leave this handler it should be safe to close.
            try:
                while True:
                    handler.send((yield))
            except StopIteration:
                pass
            finally:
                handler.close()

            # Consume anything and discard it until we're
            # being closed and need to perform cleanup.
            try:
                while True:
                    yield
            except GeneratorExit:
                states.pop(ea)
            return

        # Initialize a new consumer based on the class updater method,
        # and then set off prior to storing it in our state dictionary.
        coroutine = consumer(ea, states, cls.updater())
        next(coroutine)
        return states.setdefault(ea, coroutine)

    @classmethod
    def resume(cls, ea):
        '''This will return the currently state that is stored for a particular address.'''
        states = cls.__states__
        if ea in states:
            return states[ea]
        raise E.AddressNotFoundError(u"{:s}.resume({:#x}) : Unable to locate a currently available state for address {:#x}.".format('.'.join([__name__, cls.__name__]), ea, ea))

    @classmethod
    def updater(cls):
        '''This coroutine is intended to be implemented by a user and is responsible for keeping track of the changes for a particular address.'''
        raise NotImplementedError
        (yield)

class address(changingchanged):
    """
    This class handles 2-part events that are used to modify comments at an arbitrary
    address. This address will either be a contents tag if it's within the boundaries
    of a function, or a globals tag if it's just some arbitrary address.
    """
    @classmethod
    def get_func_extern(cls, ea):
        """Return the function at the given address and whether the address is a function populated by the rtld (an external).

        This is necessary to determine whether this is an actual function, or is really
        just an address to an import.
        """
        get_flags = idaapi.getFlags if idaapi.__version__ < 7.0 else idaapi.get_full_flags

        # If there's a function defined at our address, then return True (we're an rtld)
        # if we're in an external segment, otherwise we return True if we're not pointing to data.
        f, seg = idaapi.get_func(ea), idaapi.getseg(ea)
        return f, seg.type in {idaapi.SEG_XTRN} if f else (get_flags(ea) & idaapi.as_uint32(idaapi.MS_CLS) == idaapi.FF_DATA)

    @classmethod
    def _update_refs(cls, ea, old, new):
        f, rt = cls.get_func_extern(ea)

        oldkeys, newkeys = ({item for item in content.keys()} for content in [old, new])
        logging.debug(u"{:s}.update_refs({:#x}) : Updating old keys ({!s}) to new keys ({!s}){:s}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(oldkeys), utils.string.repr(newkeys), ' for runtime-linked function' if rt else ''))
        for key in oldkeys ^ newkeys:
            if key not in new:
                logging.debug(u"{:s}.update_refs({:#x}) : Decreasing reference count for {!s} at {:s}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(key), 'address', ea))
                if f and not rt: internal.comment.contents.dec(ea, key)
                else: internal.comment.globals.dec(ea, key)
            if key not in old:
                logging.debug(u"{:s}.update_refs({:#x}) : Increasing reference count for {!s} at {:s}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(key), 'address', ea))
                if f and not rt: internal.comment.contents.inc(ea, key)
                else: internal.comment.globals.inc(ea, key)
            continue
        return

    @classmethod
    def _create_refs(cls, ea, content):
        f, rt = cls.get_func_extern(ea)

        contentkeys = {item for item in content.keys()}
        logging.debug(u"{:s}.create_refs({:#x}) : Creating keys ({!s}){:s}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(contentkeys), ' for runtime-linked function' if rt else ''))
        for key in contentkeys:
            logging.debug(u"{:s}.create_refs({:#x}) : Increasing reference count for {!s} at {:s} {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(key), 'address', ea))
            if f and not rt: internal.comment.contents.inc(ea, key)
            else: internal.comment.globals.inc(ea, key)
        return

    @classmethod
    def _delete_refs(cls, ea, content):
        f, rt = cls.get_func_extern(ea)

        contentkeys = {item for item in content.keys()}
        logging.debug(u"{:s}.delete_refs({:#x}) : Deleting keys ({!s}){:s}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(contentkeys), ' from runtime-linked function' if rt else ''))
        for key in contentkeys:
            logging.debug(u"{:s}.delete_refs({:#x}) : Decreasing reference count for {!s} at {:s} {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(key), 'address', ea))
            if f and not rt: internal.comment.contents.dec(ea, key)
            else: internal.comment.globals.dec(ea, key)
        return

    @classmethod
    def updater(cls):
        # Receive the new comment and its type from the cmt_changing
        # event. After receiving it, then we can use the address to
        # figure out what the old comment was.
        ea, rpt, new = (yield)
        old = utils.string.of(idaapi.get_cmt(ea, rpt))

        # Decode the comments into their tags (dictionaries), and
        # then update their references before we update the comment.
        f, o, n = idaapi.get_func(ea), internal.comment.decode(old), internal.comment.decode(new)
        cls._update_refs(ea, o, n)

        # Wait for cmt_changed event...
        try:
            newea, nrpt, none = (yield)

        # If we end up catching a GeneratorExit then that's because
        # this event is being violently closed due to receiving a
        # changing event more than once for the very same address.
        except GeneratorExit:
            logging.debug(u"{:s}.event() : Terminating state due to explicit request from owner while the {:s} comment at {:#x} was being changed from {!s} to {!s}.".format('.'.join([__name__, cls.__name__]), 'repeatable' if rpt else 'non-repeatable', ea, utils.string.repr(old), utils.string.repr(new)))
            return

        # Now to fix the comment the user typed.
        if (newea, nrpt, none) == (ea, rpt, None):
            ncmt = utils.string.of(idaapi.get_cmt(ea, rpt))

            if (ncmt or '') != new:
                logging.warning(u"{:s}.event() : Comment from event at address {:#x} is different from database. Expected comment ({!s}) is different from current comment ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new), utils.string.repr(ncmt)))

            # If the comment is of the correct format, then we can simply
            # write the comment to the given address.
            if internal.comment.check(new):
                idaapi.set_cmt(ea, utils.string.to(new), rpt)

            # If there's a comment to set, then assign it to the requested
            # address.
            elif new:
                idaapi.set_cmt(ea, utils.string.to(new), rpt)

            # Otherwise, we can just delete all the references at the address.
            else:
                cls._delete_refs(ea, n)
            return

        # If the changed event doesn't happen in the right order.
        logging.fatal(u"{:s}.event() : Comment events are out of sync at address {:#x}, updating tags from previous comment. Expected comment ({!s}) is different from current comment ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(o), utils.string.repr(n)))

        # Delete the old comment and its references.
        cls._delete_refs(ea, o)
        idaapi.set_cmt(ea, '', rpt)
        logging.warning(u"{:s}.event() : Deleted comment at address {:#x} was {!s}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(o)))

        # Create the references for the new comment.
        new = utils.string.of(idaapi.get_cmt(newea, nrpt))
        n = internal.comment.decode(new)
        cls._create_refs(newea, n)

    @classmethod
    def changing(cls, ea, repeatable_cmt, newcmt):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changing({:#x}, {:d}, {!s}) : Ignoring comment.changing event (database not ready) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, utils.string.repr(newcmt), 'repeatable' if repeatable_cmt else 'non-repeatable', ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changing({:#x}, {:d}, {!s}) : Ignoring comment.changing event (not an address) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, utils.string.repr(newcmt), 'repeatable' if repeatable_cmt else 'non-repeatable', ea))

        # Construct our new state, and then grab our old comment. This is because
        # we're going to submit this to the state that we've constructed after we've
        # disabled the necessary events.
        logging.debug(u"{:s}.changing({:#x}, {:d}, {!s}) : Received comment.changing event for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, utils.string.repr(newcmt), 'repeatable' if repeatable_cmt else 'non-repeatable', ea))
        event, oldcmt = cls.new(ea), utils.string.of(idaapi.get_cmt(ea, repeatable_cmt))

        # First disable our hooks so that we can prevent re-entrancy issues
        [ ui.hook.idb.disable(item) for item in ['changing_cmt', 'cmt_changed'] ]

        # Now we can use our coroutine to begin the comment update, so that
        # later, the "changed" event can do the actual update.
        try:
            event.send((ea, bool(repeatable_cmt), utils.string.of(newcmt)))

        # If a StopIteration was raised when submitting the comment to the coroutine,
        # then something failed and we need to let the user know about it.
        except StopIteration:
            logging.fatal(u"{:s}.changing({:#x}, {:d}, {!s}) : Abandoning {:s} comment at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, utils.string.repr(newcmt), 'repeatable' if repeatable_cmt else 'non-repeatable', ea), exc_info=True)

        # Last thing to do is to re-enable the hooks that we disabled
        finally:
            [ ui.hook.idb.enable(item) for item in ['changing_cmt', 'cmt_changed'] ]

        # And then we can leave..
        return

    @classmethod
    def changed(cls, ea, repeatable_cmt):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changed({:#x}, {:d}) : Ignoring comment.changed event (database not ready) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changed({:#x}, {:d}) : Ignoring comment.changed event (not an address) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea))

        # Resume the state that was created by the changing event, and then grab
        # our new comment that we will later submit to it.
        logging.debug(u"{:s}.changed({:#x}, {:d}) : Received comment.changed event for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea))
        event, newcmt = cls.resume(ea), utils.string.of(idaapi.get_cmt(ea, repeatable_cmt))

        # First disable our hooks so that we can prevent re-entrancy issues
        [ ui.hook.idb.disable(item) for item in ['changing_cmt', 'cmt_changed'] ]

        # Now we can use our coroutine to update the comment state, so that the
        # coroutine will perform the final update.
        try:
            event.send((ea, bool(repeatable_cmt), None))

        # If a StopIteration was raised when submitting the comment to the
        # coroutine, then we something bugged out and we need to let the user
        # know about it.
        except StopIteration:
            logging.fatal(u"{:s}.changed({:#x}, {:d}) : Abandoning update of {:s} comment at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea), exc_info=True)

        # Re-enable our hooks that we had prior disabled
        finally:
            [ ui.hook.idb.enable(item) for item in ['changing_cmt', 'cmt_changed'] ]

        # Updating the comment was complete, that should've been it and so we can
        # just close our event since we're done.
        event.close()

    @classmethod
    def old_changed(cls, ea, repeatable_cmt):
        if not cls.is_ready():
            return logging.debug(u"{:s}.old_changed({:#x}, {:d}) : Ignoring comment.changed event (database not ready) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.old_changed({:#x}, {:d}) : Ignoring comment.changed event (not an address) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea))

        # first we'll grab our comment that the user updated
        logging.debug(u"{:s}.old_changed({:#x}, {:d}) : Received comment.changed event for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, repeatable_cmt, 'repeatable' if repeatable_cmt else 'non-repeatable', ea))
        cmt = utils.string.of(idaapi.get_cmt(ea, repeatable_cmt))
        fn, rt = cls.get_func_extern(ea)

        # if we're in a function but not a runtime-linked one, then we need to
        # to clear our contents here.
        if fn and not rt:
            internal.comment.contents.set_address(ea, 0)

        # otherwise, we can simply clear the tags globally
        else:
            internal.comment.globals.set_address(ea, 0)

        # grab the comment and then re-create its references.
        res = internal.comment.decode(cmt)
        if res:
            cls._create_refs(ea, res)

        # otherwise, there's nothing to do since it's empty.
        else:
            return

        # re-encode the comment back to its address, but not before disabling
        # our hooks that brought us here so that we can avoid any re-entrancy issues.
        ui.hook.idb.disable('cmt_changed')
        try:
            idaapi.set_cmt(ea, utils.string.to(internal.comment.encode(res)), repeatable_cmt)

        # now we can "finally" re-enable our hook
        finally:
            ui.hook.idb.enable('cmt_changed')

        # and then leave because this should've updated things properly.
        return

class globals(changingchanged):
    """
    This class handles 2-part events that are used to modify comments for a particular
    range. In most cases this should be a function comment, or a chunk associated
    with a function, but just to be certain we check the start_ea of the range
    to determine whether we update the global or content tag cache.
    """
    @classmethod
    def _update_refs(cls, fn, old, new):
        oldkeys, newkeys = ({item for item in content.keys()} for content in [old, new])
        logging.debug(u"{:s}.update_refs({:#x}) : Updating old keys ({!s}) to new keys ({!s}).".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(oldkeys), utils.string.repr(newkeys)))
        for key in oldkeys ^ newkeys:
            if key not in new:
                logging.debug(u"{:s}.update_refs({:#x}) : Decreasing reference count for {!s} at {:s} {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(key), 'function' if fn else 'global', interface.range.start(fn)))
                internal.comment.globals.dec(interface.range.start(fn), key)
            if key not in old:
                logging.debug(u"{:s}.update_refs({:#x}) : Increasing reference count for {!s} at {:s} {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(key), 'function' if fn else 'global', interface.range.start(fn)))
                internal.comment.globals.inc(interface.range.start(fn), key)
            continue
        return

    @classmethod
    def _create_refs(cls, fn, content):
        contentkeys = {item for item in content.keys()}
        logging.debug(u"{:s}.create_refs({:#x}) : Creating keys ({!s}).".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(contentkeys)))
        for key in contentkeys:
            logging.debug(u"{:s}.create_refs({:#x}) : Increasing reference count for {!s} at {:s} {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(key), 'function' if fn else 'global', interface.range.start(fn)))
            internal.comment.globals.inc(interface.range.start(fn), key)
        return

    @classmethod
    def _delete_refs(cls, fn, content):
        contentkeys = {item for item in content.keys()}
        logging.debug(u"{:s}.delete_refs({:#x}) : Deleting keys ({!s}).".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(contentkeys)))
        for key in contentkeys:
            logging.debug(u"{:s}.delete_refs({:#x}) : Decreasing reference count for {!s} at {:s} {:#x}.".format('.'.join([__name__, cls.__name__]), interface.range.start(fn) if fn else idaapi.BADADDR, utils.string.repr(key), 'function' if fn else 'global', interface.range.start(fn)))
            internal.comment.globals.dec(interface.range.start(fn), key)
        return

    @classmethod
    def updater(cls):
        # Receive the new comment and its type from the cmt_changing
        # event. After receiving it, then we can determine what function
        # it's for and then get the function's comment.
        ea, rpt, new = (yield)
        fn = idaapi.get_func(ea)
        old = utils.string.of(idaapi.get_func_cmt(fn, rpt))

        # Decode the old and new function comment into their tags so
        # that we can update their references before the comment.
        o, n = internal.comment.decode(old), internal.comment.decode(new)
        cls._update_refs(fn, o, n)

        # Wait for cmt_changed event...
        try:
            newea, nrpt, none = (yield)

        except GeneratorExit:
            logging.debug(u"{:s}.event() : Terminating state due to explicit request from owner while the {:s} function comment at {:#x} was being changed from {!s} to {!s}.".format('.'.join([__name__, cls.__name__]), 'repeatable' if rpt else 'non-repeatable', ea, utils.string.repr(old), utils.string.repr(new)))
            return

        # Now we can fix the user's new comment.
        if (newea, nrpt, none) == (ea, rpt, None):
            ncmt = utils.string.of(idaapi.get_func_cmt(fn, rpt))

            if (ncmt or '') != new:
                logging.warning(u"{:s}.event() : Comment from event for function {:#x} is different from database. Expected comment ({!s}) is different from current comment ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new), utils.string.repr(ncmt)))

            # If the comment is correctly formatted as a tag, then we
            # can simply write the comment at the given address.
            if internal.comment.check(new):
                idaapi.set_func_cmt(fn, utils.string.to(new), rpt)

            # If there's a comment to set, then assign it to the requested
            # function address.
            elif new:
                idaapi.set_func_cmt(fn, utils.string.to(new), rpt)

            # Otherwise, there's no comment there and we need to delete
            # all references at the address.
            else:
                cls._delete_refs(fn, n)
            return

        # If the changed event doesn't happen in the right order.
        logging.fatal(u"{:s}.event() : Comment events are out of sync for function {:#x}, updating tags from previous comment. Expected comment ({!s}) is different from current comment ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(o), utils.string.repr(n)))

        # Delete the old function comment and its references.
        cls._delete_refs(fn, o)
        idaapi.set_func_cmt(fn, '', rpt)
        logging.warning(u"{:s}.event() : Deleted comment for function {:#x} was ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(o)))

        # Create the references for the new function comment.
        newfn = idaapi.get_func(newea)
        new = utils.string.of(idaapi.get_func_cmt(newfn, nrpt))
        n = internal.comment.decode(new)
        cls._create_refs(newfn, n)

    @classmethod
    def changing(cls, cb, a, cmt, repeatable):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changing({!s}, {:#x}, {!s}, {:d}) : Ignoring comment.changing event (database not ready) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))
        if interface.node.is_identifier(interface.range.start(a)):
            return logging.debug(u"{:s}.changing({!s}, {:#x}, {!s}, {:d}) : Ignoring comment.changing event (not an address) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))

        # First we'll check to see if this is an actual function comment by confirming
        # that we're in a function, and that our comment is not empty.
        logging.debug(u"{:s}.changing({!s}, {:#x}, {!s}, {:d}) : Received comment.changing event for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))
        fn = idaapi.get_func(interface.range.start(a))
        if fn is None and not cmt:
            return

        # Construct our new state and grab our old comment so that we can send the
        # old comment to the state after we've disabled the necessary events.
        event, oldcmt = cls.new(interface.range.start(a)), utils.string.of(idaapi.get_func_cmt(fn, repeatable))

        # We need to disable our hooks so that we can prevent re-entrancy issues
        hooks = ['changing_area_cmt', 'area_cmt_changed'] if idaapi.__version__ < 7.0 else ['changing_range_cmt', 'range_cmt_changed']
        [ ui.hook.idb.disable(item) for item in hooks ]

        # Now we can use our coroutine to begin the comment update, so that
        # later, the "changed" event can do the actual update.
        try:
            event.send((interface.range.start(fn), bool(repeatable), utils.string.of(cmt)))

        # If a StopIteration was raised when submitting the comment to the
        # coroutine, then something terrible has happened and we need to let
        # the user know what's up.
        except StopIteration:
            logging.fatal(u"{:s}.changing({!s}, {:#x}, {!s}, {:d}) : Abandoning {:s} function comment at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', ea), exc_info=True)

        # Last thing to do is to re-enable the hooks that we disabled
        finally:
            [ ui.hook.idb.enable(item) for item in hooks ]

        # And then we're ready for the "changed" event
        return

    @classmethod
    def changed(cls, cb, a, cmt, repeatable):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changed({!s}, {:#x}, {!s}, {:d}) : Ignoring comment.changed event (database not ready) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))
        if interface.node.is_identifier(interface.range.start(a)):
            return logging.debug(u"{:s}.changed({!s}, {:#x}, {!s}, {:d}) : Ignoring comment.changed event (not an address) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))

        # First we'll check to see if this is an actual function comment by confirming
        # that we're in a function, and that our comment is not empty.
        logging.debug(u"{:s}.changed({!s}, {:#x}, {!s}, {:d}) : Received comment.changed event for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))
        fn = idaapi.get_func(interface.range.start(a))
        if fn is None and not cmt:
            return

        # Resume the state that was prior created by the changing event, and grab
        # our new comment. As the state keeps track of the old comment and the new
        # one we're going to send to it once we disable some events, it will know
        # what to do.
        event, newcmt = cls.resume(interface.range.start(a)), utils.string.of(idaapi.get_func_cmt(fn, repeatable))

        # We need to disable our hooks so that we can prevent re-entrancy issues
        hooks = ['changing_area_cmt', 'area_cmt_changed'] if idaapi.__version__ < 7.0 else ['changing_range_cmt', 'range_cmt_changed']
        [ ui.hook.idb.disable(item) for item in hooks ]

        # Now we can use our coroutine to update the comment state, so that the
        # coroutine will perform the final update.
        try:
            event.send((interface.range.start(fn), bool(repeatable), None))

        # If a StopIteration was raised when submitting the comment to the
        # coroutine, then we something terrible has happend that the user will
        # likely need to know about.
        except StopIteration:
            logging.fatal(u"{:s}.changed({!s}, {:#x}, {!s}, {:d}) : Abandoning update of {:s} function comment at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', ea), exc_info=True)

        # Last thing to do is to re-enable the hooks that we disabled
        finally:
            [ ui.hook.idb.enable(item) for item in hooks ]

        # We're done updating the comment and our state is done, so we can
        # close it to release it from existence.
        event.close()

    @classmethod
    def old_changed(cls, cb, a, cmt, repeatable):
        if not cls.is_ready():
            return logging.debug(u"{:s}.old_changed({!s}, {:#x}, {!s}, {:d}) : Ignoring comment.changed event (database not ready) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))
        if interface.node.is_identifier(interface.range.start(a)):
            return logging.debug(u"{:s}.old_changed({!s}, {:#x}, {!s}, {:d}) : Ignoring comment.changed event (not an address) for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))

        # first thing to do is to identify whether we're in a function or not,
        # so we first grab the address from the area_t...
        logging.debug(u"{:s}.old_changed({!s}, {:#x}, {!s}, {:d}) : Received comment.changed event for a {:s} comment at {:#x}.".format('.'.join([__name__, cls.__name__]), utils.string.repr(cb), interface.range.start(a), utils.string.repr(cmt), repeatable, 'repeatable' if repeatable else 'non-repeatable', interface.range.start(a)))
        ea = interface.range.start(a)

        # then we can use it to verify that we're in a function. if not, then
        # this is a false alarm and we can leave.
        fn = idaapi.get_func(ea)
        if fn is None:
            return

        # we're using an old version of ida here, so start out empty
        internal.comment.globals.set_address(ea, 0)

        # grab our comment here and re-create its refs
        res = internal.comment.decode(utils.string.of(cmt))
        if res:
            cls._create_refs(fn, res)

        # if it's empty, then there's nothing to do and we can leave
        else:
            return

        # now we can simply re-write it it, but not before disabling our hooks
        # that got us here, so that we can avoid any re-entrancy issues.
        ui.hook.idb.disable('area_cmt_changed')
        try:
            idaapi.set_func_cmt(fn, utils.string.to(internal.comment.encode(res)), repeatable)

        # now we can "finally" re-enable our hook
        finally:
            ui.hook.idb.enable('area_cmt_changed')

        # that should've been it, so we can now just leave
        return

class typeinfo(changingchanged):
    @classmethod
    def updater(cls):
        # All typeinfo are global tags unless they're being applied to an
        # operand...which is never handled by this class.
        ctx = internal.comment.globals

        # Receive the changing_ti event...
        ea, original, expected = (yield)

        # First check if we need to remove the typeinfo that's stored at the
        # given address. Afterwards we can unpack our original values.
        if any(original):
            ctx.dec(ea, '__typeinfo__')
        old_type, old_fname = original

        # Wait until we get the ti_changed event...
        try:
            new_ea, tidata = (yield)

        # If we end up catching a GeneratorExit then that's because
        # this event is being violently closed due to receiving a
        # changing event more than once for the very same address.
        except GeneratorExit:
            logging.debug(u"{:s}.event() : Terminating state due to explicit request from owner while the type information at {:#x} was being changed from {!r} to {!r}.".format('.'.join([__name__, cls.__name__]), ea, bytes().join(original), bytes().join(expected)))
            return

        # Verify that the typeinfo we're changing to is the exact same as given
        # to use by both events. If they're not the same, then we need to make
        # an assumption and that assumption is to take the values given to us
        # by the changing_ti event.
        if (ea, expected) != (new_ea, tidata):
            logging.warning(u"{:s}.event() : The {:s} event has a different address ({:#x} != {:#x}) and type information ({!r} != {!r}) than what was given by the {:s} event. Using the values from the {:s} event.".format('.'.join([__name__, cls.__name__]), 'ti_changed', ea, new_ea, bytes().join(expected), bytes().join(tidata), 'changing_ti', 'ti_changed'))
        elif ea != new_ea:
            logging.warning(u"{:s}.event() : The {:s} event has a different address ({:#x} != {:#x}) than what was given by the {:s} event. Using the address {:#x} from the {:s} event.".format('.'.join([__name__, cls.__name__]), 'changing_ti', ea, new_ea, 'ti_changed', ea, 'changing_ti'))
            new_ea = ea
        elif expected != tidata:
            logging.warning(u"{:s}.event() : The {:s} event for address {:#x} has different type information ({!r} != {!r}) than what was received by the {:s} event. Re-fetching the type information for the address at {:#x}.".format('.'.join([__name__, cls.__name__]), 'changing_ti', ea, bytes().join(expected), bytes().join(tidata), 'ti_changed', new_ea))
            tidata, _, _ = database.type(ea)

        # Okay, we now have the data that we need to compare in order to determine
        # if we're removing typeinfo, adding it, or updating it. Since we
        # already decremented the tag from the previous address, we really
        # only need to determine if we need to add its reference back.
        if any(tidata):
            ctx.inc(new_ea, '__typeinfo__')
            logging.debug(u"{:s}.event() : Updated the type information at address {:#x} and {:s} its reference ({!r} -> {!r}).".format('.'.join([__name__, cls.__name__]), new_ea, 'kept' if original == tidata else 'increased', bytes().join(original), bytes().join(tidata)))

        # For the sake of debugging, log that we just removed the typeinfo
        # from the current address. We don't need to decrease our reference
        # here because we did it already when we git our "changing" event.
        else:
            logging.debug(u"{:s}.event() : Removed the type information from address {:#x} and its reference ({!r} -> {!r}).".format('.'.join([__name__, cls.__name__]), new_ea, bytes().join(original), bytes().join(tidata)))
        return

    @classmethod
    def changing(cls, ea, new_type, new_fname):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changing({:#x}, {!s}, {!s}) : Ignoring typeinfo.changing event (database not ready) with new type ({!s}) and new name ({!s}) at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new_type), utils.string.repr(new_fname), utils.string.repr(new_type), new_fname, ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changing({:#x}, {!s}, {!s}) : Ignoring typeinfo.changing event (not an address) with new type ({!s}) and new name ({!s}) at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new_type), utils.string.repr(new_fname), utils.string.repr(new_type), new_fname, ea))

        # Verify that the address is within our database boundaries because IDA
        # can actually create "extra" comments outside of the database.
        try:
            ea = interface.address.within(ea)
        except E.OutOfBoundsError:
            return logging.debug(u"{:s}.changing({:#x}, {!s}, {!s}) : Ignoring typeinfo.changing event (not a valid address) with new type ({!s}) and new name ({!s}) at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new_type), utils.string.repr(new_fname), utils.string.repr(new_type), new_fname, ea))

        # Extract the previous type information from the given address. If none
        # was found, then just use empty strings because these are compared to the
        # new values by the event.
        logging.debug(u"{:s}.changing({:#x}, {!s}, {!s}) : Received typeinfo.changing for new_type ({!s}) and new_fname ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new_type), utils.string.repr(new_fname), utils.string.repr(new_type), new_fname))

        ti = database.type(ea)
        old_type, old_fname, _ = (b'', b'', None) if ti is None else ti.serialize()

        # Construct a new state for this address, and pre-pack both our tuple
        # containing the original type information and the new type information so
        # that we can submit both of them to the state once we disable the events.
        event = cls.new(ea)
        original, new = (old_type, old_fname or b''), (new_type or b'', new_fname or b'')

        # First disable our hooks so that we can prevent re-entrancy issues.
        [ ui.hook.idb.disable(item) for item in ['changing_ti', 'ti_changed'] ]

        # Now we can use our coroutine to begin updating the typeinfo tag. We
        # submit the previous values (prior to the typeinfo being changed) because
        # the "changed" event (which will be dispatched afterwards) is responsible
        # for performing the actual update of the cache.
        try:
            event.send((ea, original, new))

        # If we encounter a StopIteration while submitting the comment, then the
        # coroutine has gone out of control and we need to let the user know.
        except StopIteration:
            logging.fatal(u"{:s}.changed({:#x}, {!s}, {!s}) : Abandoning type information at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(new_type), utils.string.repr(new_fname), ea), exc_info=True)

        # Last thing to do is to re-enable the hooks that we disabled and then leave.
        finally:
            [ ui.hook.idb.enable(item) for item in ['changing_ti', 'ti_changed'] ]
        return

    @classmethod
    def changed(cls, ea, type, fnames):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changed({:#x}, {!s}, {!s}) : Ignoring typeinfo.changed event (database not ready) with type ({!s}) and name ({!s}) at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(type), utils.string.repr(fnames), utils.string.repr(type), fnames, ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changed({:#x}, {!s}, {!s}) : Ignoring typeinfo.changed event (not an address) with type ({!s}) and name ({!s}) at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(type), utils.string.repr(fnames), utils.string.repr(type), fnames, ea))

        # Verify that the address is within our database boundaries because IDA
        # can actually create "extra" comments outside of the database.
        try:
            ea = interface.address.within(ea)
        except E.OutOfBoundsError:
            return logging.debug(u"{:s}.changed({:#x}, {!s}, {!s}) : Ignoring typeinfo.changed event (not a valid address) with type ({!s}) and name ({!s}) at {:#x}.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(type), utils.string.repr(fnames), utils.string.repr(type), fnames, ea))

        # Resume the state for the current address, and then take the data from
        # our parameters (which IDA is telling us was just written) and pack
        # them into a tuple. This way we can send them to the state after we
        # disable the necessary hooks to prevent re-entrancy.
        logging.debug(u"{:s}.changed({:#x}, {!s}, {!s}) : Received typeinfo.changed event with type ({!s}) and name ({!s}).".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(type), utils.string.repr(fnames), utils.string.repr(type), fnames))
        event, new = cls.resume(ea), (type or b'', fnames or b'')

        # First disable our hooks so that we can prevent re-entrancy issues.
        [ ui.hook.idb.disable(item) for item in ['changing_ti', 'ti_changed'] ]

        # Now we can use our coroutine to update the typeinfo tag. As IDA was
        # kind enough to provide the new values, we can just submit them to the
        # coroutine.
        try:
            event.send((ea, new))

        # If we encounter a StopIteration while submitting the comment, then the
        # coroutine has terminated unexpectedly which is a pretty critical issue.
        except StopIteration:
            logging.fatal(u"{:s}.changed({:#x}, {!s}, {!s}) : Abandoning update of type information at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), ea, utils.string.repr(type), utils.string.repr(fnames), ea), exc_info=True)

        # Last thing to do is to re-enable the hooks that we disabled and then
        # close our state since we're done with it and there shouldn't be
        # anything left to do for this address.
        finally:
            [ ui.hook.idb.enable(item) for item in ['changing_ti', 'ti_changed'] ]
        event.close()

### database scope
class state(object):
    '''database notification state'''
    init = type('init', (object,), {})()
    loaded = type('loaded', (object,), {})()
    ready = type('ready', (object,), {})()

State = None

def on_close():
    '''IDB_Hooks.closebase'''

    # Database was closed, so we need to reset our state.
    global State
    if state:
        logging.debug(u"{:s}.on_close() : Received unexpected state transition from state ({!s}).".format(__name__, utils.string.repr(State)))
    State = None

def on_init(idp_modname):
    '''IDP_Hooks.init'''

    # Database has just been opened, setup the initial state.
    global State
    if State == None:
        State = state.init
    else:
        logging.debug(u"{:s}.on_init({!s}) : Received unexpected state transition from state ({!s}).".format(__name__, utils.string.repr(idp_modname), utils.string.repr(State)))

def nw_on_init(nw_code, is_old_database):
    idp_modname = idaapi.get_idp_name()
    return on_init(idp_modname)

def on_newfile(fname):
    '''IDP_Hooks.newfile'''

    # Database has been created, switch the state to loaded.
    global State
    if State == state.init:
        State = state.loaded
    else:
        logging.debug(u"{:s}.on_newfile({!s}) : Received unexpected state transition from state ({!s}).".format(__name__, utils.string.repr(fname), utils.string.repr(State)))

    # FIXME: save current state like base addresses and such
    __execute_rcfile()

def nw_on_newfile(nw_code, is_old_database):
    if is_old_database:
        return
    fname = idaapi.cvar.database_idb
    return on_newfile(fname)

def on_oldfile(fname):
    '''IDP_Hooks.oldfile'''

    # Database has been loaded, switch the state to ready.
    global State
    if State == state.init:
        State = state.ready

        __check_functions()
    else:
        logging.debug(u"{:s}.on_oldfile({!s}) : Received unexpected state transition from state ({!s}).".format(__name__, utils.string.repr(fname), utils.string.repr(State)))

    # FIXME: save current state like base addresses and such
    __execute_rcfile()

def nw_on_oldfile(nw_code, is_old_database):
    if not is_old_database:
        return
    fname = idaapi.cvar.database_idb
    return on_oldfile(fname)

def __check_functions():
    # FIXME: check if tagcache needs to be created
    return

def on_ready():
    '''IDP_Hooks.auto_empty'''
    global State

    # Queues have just been emptied, so now we can transition
    if State == state.loaded:
        State = state.ready

        # update tagcache using function state
        __process_functions()

    elif State == state.ready:
        logging.debug(u"{:s}.on_ready() : Database is already ready ({!s}).".format(__name__, utils.string.repr(State)))

    else:
        logging.debug(u"{:s}.on_ready() : Received unexpected transition from state ({!s}).".format(__name__, utils.string.repr(State)))

def auto_queue_empty(type):
    """This waits for the analysis queue to be empty.

    If the database is ready to be tampered with, then we proceed by executing
    the `on_ready` function which will perform any tasks required to be done
    on the database at startup.
    """
    if type == idaapi.AU_FINAL:
        on_ready()

def __process_functions(percentage=0.10):
    """This prebuilds the tag cache and index for the entire database so that we can differentiate tags made by the user and the application.

    It's intended to be called once the database is ready to be tampered with.
    """
    implicit = {'__typeinfo__', '__name__'}
    P, globals = ui.Progress(), {ea : count for ea, count in internal.comment.globals.iterate()}

    # Now we need to gather all of our imports so that we can clean up any functions
    # that are runtime-linked addresses. This is because IDA seems to create a
    # func_t for certain imports.
    imports = {item for item in []}
    for idx in range(idaapi.get_import_module_qty()):
        idaapi.enum_import_names(idx, lambda address, name, ordinal: imports.add(address) or True)

    # Now that we have our imports, we can iterate through all of the functions.
    total, funcs = 0, [ea for ea in database.functions()]
    P.update(current=0, max=len(funcs), title=u"Pre-building the tag cache and its index...")
    P.open()
    six.print_(u"Indexing the tags for {:d} functions.".format(len(funcs)))
    for i, fn in enumerate(funcs):
        chunks = [item for item in function.chunks(fn)]

        # Check to see if the progress bar was cancelled for "some reason". If
        # so, we double-check if that's what the user really wanted.
        if P.canceled:
            six.print_(u"User opted to cancel building the tag cache at function {:#x} ({:d} of {:d}) after having indexed {:d} tag{:s}.".format(fn, 1 + i, len(funcs), total, '' if total == 1 else 's'))

            # Confirm with the user that they really don't care for indexing.
            message = []
            start, stop = database.config.bounds()
            message.append(u"We are {:.02f}% complete at function {:#x} ({:d} of {:d}) having indexed only {:d} tag{:s} for the range {:#x}<>{:#x}.".format(100. * i / float(len(funcs)), fn, 1 + i, len(funcs),  total, '' if total == 1 else 's', start, stop))
            message.append(u"If you cancel now, some of the notations made by the application prior to this process will be non-queryable via select.")
            message.append(u'Are you sure?')
            if ui.ask.yn('\n'.join(message), no=True):
                six.print_(u"User aborted the build of the tag cache at function {:#x} ({:d} of {:d}) and has indexed only {:d} tag{:s}.".format(fn, 1 + i, len(funcs), total, '' if total == 1 else 's'))
                break

            # Okay, so they changed their mind...
            six.print_(u"Resuming build of tag cache at function {:#x} ({:d} of {:d}) with {:d} tag{:s} having been indexed.".format(fn, 1 + i, len(funcs), total, '' if total == 1 else 's'))
            P.canceled = False

        # If the current function is in our imports, then we skip it because
        # it's a runtime-linked address and shouldn't have been cached anyways.
        if fn in imports:
            continue

        # Update the progress bar with the current function we're working on.
        text = functools.partial(u"Processing function {:#x} ({chunks:d} chunk{plural:s}) -> {:d} of {:d}".format, fn, 1 + i, len(funcs))
        P.update(current=i)
        ui.navigation.procedure(fn)
        if i % (int(len(funcs) * percentage) or 1) == 0:
            six.print_(u"Processing function {:#x} -> {:d} of {:d} ({:.02f}%)".format(fn, 1 + i, len(funcs), i / float(len(funcs)) * 100.0))

        # If the current function is not in our globals, but it has a name tag, then
        # we need to include it. IDA seems to name some addresses before promoting
        # them to a function.
        if fn not in globals and function.tag(fn):
            [ internal.comment.globals.inc(fn, k) for k in implicit if k in function.tag(fn) ]

        # Grab the currently existing cache for the current function, and use
        # it to tally up all of the reference counts for the tags.
        contents = {item for item in internal.comment.contents.address(fn, target=fn)}
        for ci, (l, r) in enumerate(chunks):
            P.update(text=text(chunks=len(chunks), plural='' if len(chunks) == 1 else 's'), tooltip="Chunk #{:d} : {:#x} - {:#x}".format(ci, l, r))

            # Iterate through each address in the function, only updating the
            # references for tags that are not in our set of implicit ones.
            for ea in database.address.iterate(ui.navigation.analyze(l), r):
                available = {k for k in database.tag(ea)}
                for k in available - implicit:
                    if ea in globals: internal.comment.globals.dec(ea, k)
                    if ea not in contents: internal.comment.contents.inc(ea, k, target=fn)
                    total += 1
                continue
            continue
        continue
    else:
        six.print_(u"Successfully seeded the tag cache with its index which was composed of {:d} tag{:s}.".format(total, '' if total == 1 else 's'))
    P.close()

def __execute_rcfile():
    '''Look in the current IDB directory for an rcfile that might need to be executed.'''
    ns, filename = sys.modules['__main__'].__dict__ if '__main__' in sys.modules else globals(), 'idapythonrc.py'
    path = database.config.path(filename)

    try:
        with open(path) as infile:
            logging.warning(u"{:s}.execute_rcfile() : Found a `{:s}` file to execute in the database directory at `{:s}`.".format(__name__, filename, path))
            exec(infile.read(), ns, ns)

    except IOError:
        logging.info(u"{:s}.execute_rcfile() : Skipping execution of `{:s}` file as it does not exist at `{:s}`.".format(__name__, filename, path))
    except Exception:
        logging.warning(u"{:s}.execute_rcfile() : Unexpected exception raised while trying to execute `{:s}`.".format(__name__, path), exc_info=True)
    return

def relocate(info):
    """This is for when the user relocates a number of segments in newer versions of IDA.

    We update the entire database in two parts. First we iterate through all
    the functions, and transform its cache to its new address. Next we iterate
    through all of the known global tags and then transform those. As we don't
    receive the "changed_netmap" parameter, we don't know whether IDA has actually
    relocated the netnodes or not.
    """
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name
    functions, globals = map(utils.fcompose(sorted, list), [database.functions(), internal.comment.globals.iterate()])

    # First we need to sanity check what we've been asked to do and then we
    # disable the auto-analysis so that IDA doesn't change anything as we're
    # modifying the netnodes. We preserve this for restoration later.
    if info.size() == 0:
        return logging.warning(u"{:s}.relocate({!s}) : Ignoring request to relocate {:d} segments.".format(__name__, [], info.size()))

    # Output the amount of work (number of segments) that we'll need to perform.
    scount, segmap = info.size(), {info[si].to : info[si]._from for si in range(info.size())}
    listable = sorted(segmap)
    logging.info(u"{:s}.relocate({:#x}, {:#x}) : Relocating the tag cache and index for {:d} segment{:s}.".format(__name__, segmap[listable[0]], listable[0], scount, '' if scount == 1 else 's'))

    # Now we'll need to iterate through our functions and globals in order to filter
    # them and calculate the number of items we'll be expecting to process.
    count = sum(1 for ea in functions if any(info[si].to <= ea <= info[si].to + info[si].size for si in range(info.size())))
    count+= sum(1 for ea, _ in globals if any(info[si]._from <= ea <= info[si]._from + info[si].size for si in range(info.size())))

    # Create our progress bar that we'll continuously update using the number of
    # items that we just calculated from filtering our functions and globals.
    P = ui.Progress()
    P.update(current=0, min=0, max=count, title=u"Relocating the tag cache and index for {:d} segment{:s}...".format(scount, '' if scount == 1 else 's'))
    fcount = gcount = 0

    # Iterate through each work item (segment) in order to process them.
    P.open()
    for si in range(scount):
        seg = idaapi.getseg(info[si].to)

        # If the user canceled this process, then really confirm things. Because if they
        # abort this process, then the index will be desynchronized. Or really, it'll be
        # completely out-of-sync and should likely be removed since it's corrupt.
        if P.canceled:
            message = []
            message.append(u'If you abort this process, the tag cache and its index will become desynchronized (corrupt) which will result in spectacular failures when querying.')
            message.append(u"We are currently relocating segment {:d} of {:d} from {:#x} to {:#x}.".format(1 + si, scount, info[si]._from, info[si].to))
            message.append(u'Are you REALLY sure?')
            if ui.ask.yn('\n'.join(message), no=True):
                six.print_(u"User aborted relocating the tag cache and its index at segment {:d} of {:d} from {:#x} to {:#x}.".format(1 + si, scount, info[si]._from, info[si].to))
                break
            P.canceled = False

        # Format the description for the current work item (segment) that we're processing.
        description = "{:d} of {:d}{:s}".format(1 + si, scount, " ({:s})".format(get_segment_name(seg)) if seg else '') if scount > 1 else "{:s}".format(get_segment_name(seg) if seg else '')
        msg = u"Relocating the tag cache and index for segment{:s}: {:#x} ({:+#x}) -> {:#x}".format(" {:s}".format(description) if description else '', info[si]._from, info[si].size, info[si].to)
        P.update(title=msg), six.print_(msg)

        # Iterate through each function that was moved and relocate its contents. If we're
        # using a version of IDA prior to 7.3, then when our event has been dispatched
        # the netnodes have already been moved.
        listable = [ea for ea in functions if info[si].to <= ea < info[si].to + info[si].size]
        for i, offset in __relocate_function(info[si]._from, info[si].to, info[si].size, (item for item in listable), moved=True if idaapi.__version__ < 7.3 else False):
            name = database.name(info[si].to + offset)
            text = u"Relocating function {:d} of {:d}{:s}: {:#x} -> {:#x}".format(1 + i, len(listable), " ({:s})".format(name) if name else '', info[si]._from + offset, info[si].to + offset)
            P.update(value=sum([fcount, gcount, i]), text=text)
            ui.navigation.procedure(info[si].to + offset)
        fcount += len(listable)

        # Iterate through all of the globals that were moved.
        listable = [(ea, count) for ea, count in globals if info[si]._from <= ea < info[si]._from + info[si].size]
        for i, offset in __relocate_globals(info[si]._from, info[si].to, info[si].size, (item for item in listable)):
            name = database.name(info[si].to + offset)
            text = u"Relocating global {:d} of {:d}{:s}: {:#x} -> {:#x}".format(1 + i, len(listable), " ({:s})".format(name) if name else '', info[si]._from + offset, info[si].to + offset)
            P.update(value=sum([fcount, gcount, i]), text=text)
            ui.navigation.analyze(info[si].to + offset)
        gcount += len(listable)
    P.close()

def __relocate_function(old, new, size, iterable, moved=False):
    """Relocate the function addresses in `iterable` from address `old` to `new` adjusting them by the specified `size`.

    If `moved` is specified as true, then the netnodes are already at their target
    as per "Move Segment(s)". Otherwise they're still at their original address
    which happens when the database has been relocated via "Rebase Program".
    """
    key = internal.comment.tagging.__address__
    failure, total, index = [], [item for item in iterable], {ea : keys for ea, keys in internal.comment.contents.iterate() if old <= ea < old + size}

    for i, fn in enumerate(total):
        offset = fn - new
        source, target = offset + old, offset + new

        # Grab the contents tags from the former function's netnode. If the netnode has
        # already been moved, then use the function we were given. Otherwise we can just
        # use the old offset.
        try:
            state = internal.comment.contents._read(target if moved else source, offset + old)

        except E.FunctionNotFoundError:
            logging.fatal(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Unable to locate the original function address ({:#x}) while trying to transform to {:#x}.".format(__name__, old, new, size, iterable, offset + old, offset + new), exc_info=True)
            state = None

        # If there was no read state then there's nothing to do. So we just
        # continue to the next iteration (without yielding) for performance.
        if state is None:
            logging.info(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Skipping contents of function {:#x} due to no state being stored at {:#x}.".format(__name__, old, new, size, iterable, fn, fn if moved else (offset + old)))
            continue

        # Erase the old contents tags since we've already loaded its state.
        internal.comment.contents._write(source, offset + old, None)
        logging.info(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Cleared contents of function {:#x} at old address {:#x}.".format(__name__, old, new, size, iterable, fn, offset + old))

        # If there wasn't a value in our contents index, then warn the user
        # before we remove it. We use this later to figure out any strays.
        if not operator.contains(index, source):
            logging.warning(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Found contents for function {:#x} at old address {:#x} that wasn't in index.".format(__name__, old, new, size, iterable, fn, source))
        index.pop(source, None)

        # Ensure that the function key is available in the loaded state.
        if key not in state:
            state.setdefault(key, {})
            # FIXME: We should completely rebuild the contents here instead of
            #        logging a warning and initializing it with an empty dict.
            logging.warning(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Missing address cache while translating address {:#x} -> {:#x}.".format(__name__, old, new, size, iterable, offset + old, offset + new))

        # Update the state containing the old addresses with the newly transformed ones.
        res, state[key] = state[key], {ea - old + new : ref for ea, ref in state[key].items()}

        # And then we can write the modified state back to the function's netnode.
        ok = internal.comment.contents._write(fn, fn, state)
        if not ok:
            logging.fatal(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Failure trying to write reference count for function {:#x} while trying to update old reference count ({!s}) to new one ({!s}).".format(__name__, old, new, size, iterable, fn, utils.string.repr(res), utils.string.repr(state[key])))
            failure.append((fn, res, state[key]))

        # We successfully processed this function, so yield its index and offset.
        logging.debug(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Relocated {:d} content locations for function {:#x} using delta {:+#x}.".format(__name__, old, new, size, iterable, len(state[key]), fn, new - old))
        yield i, offset

    # Now we need to gather all of our imports so that we can clean up any functions
    # that are runtime-linked addresses. This is because IDA seems to create a
    # func_t for certain imports.
    imports = {item for item in []}
    for idx in range(idaapi.get_import_module_qty()):
        idaapi.enum_import_names(idx, lambda address, name, ordinal: imports.add(address) or True)

    # Iterate through our index grabbing anything that's in our imports.
    items = {ea - old + new for ea in index}
    for ea in items & imports:
        offset = ea - new
        source, target = offset + old, offset + new
        logging.info(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Removing contents of runtime-linked function ({:#x}) from index at {:#x}.".format(__name__, old, new, size, iterable, target, source))
        internal.comment.contents._write(source, offset + old, None)
        index.pop(source)

    # Last thing to do is to clean up the stray contents from the index that weren't
    # pointing to a function anyways.
    for ea, keys in index.items():
        offset = ea - old
        source, target = offset + old, offset + new
        fn, ch = idaapi.get_func(target), idaapi.get_fchunk(target)

        # Check that this stray isn't pointing to an actual function before we
        # continue to remove it from the netnode. If it is, then we skip processing.
        if fn is None:
            logging.info(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Discarding cache at {:#x} should've been relocated to {:#x} but is not part of a function anymore.".format(__name__, old, new, size, iterable, ea, target))
        elif interface.range.start(ch) == interface.range.start(fn) == target:
            logging.critical(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Refusing to clean up index for {:#x} as it has been relocated to {:#x} which is in use by function ({:#x}).".format(__name__, old, new, size, iterable, ea, offset + new, interface.range.start(ch)))
            continue
        elif ch.flags & idaapi.FUNC_TAIL:
            owners = [item for item in function.chunk.owners(target)]
            logging.info(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Cache at {:#x} should've been relocated to {:#x} but is a tail associated with more than one function ({:s}).".format(__name__, old, new, size, iterable, ea, target, ', '.join(map("{:#x}".format, owners))))
        else:
            logging.info(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Cache at {:#x} should've been relocated to {:#x} but its boundaries ({:#x}<>{:#x}) do not correspond with a function ({:#x}).".format(__name__, old, new, size, iterable, ea, target, interface.range.start(ch), interface.range.end(ch), interface.range.start(fn)))

        # Now we know why this address is within our index, so all that
        # we really need to do is to remove it.
        internal.comment.contents._write(ea, ea, None)
        logging.debug(u"{:s}.relocate_function({:#x}, {:#x}, {:+#x}, {!r}) : Cleared stray contents for {:#x} at old address {:#x}.".format(__name__, old, new, size, iterable, offset + new, offset + old))
    return

def __relocate_globals(old, new, size, iterable):
    '''Relocate the global tuples (address, count) in `iterable` from address `old` to `new` adjusting them by the specified `size`.'''
    node = internal.comment.tagging.node()
    failure, total = [], [item for item in iterable]
    for i, (ea, count) in enumerate(total):
        offset = ea - old

        # Remove the old address from the netnode cache (altval) with our global.
        ok = internal.netnode.alt.remove(node, ea)
        if not ok:
            logging.fatal(u"{:s}.relocate_globals({:#x}, {:#x}, {:+#x}, {!r}) : Failure trying to remove reference count ({!r}) for global {:#x}.".format(__name__, old, new, size, iterable, count, ea))

        # Now we can re-add the new address to the netnode cache (altval).
        ok = internal.netnode.alt.set(node, new + offset, count)
        if not ok:
            logging.fatal(u"{:s}.relocate_globals({:#x}, {:#x}, {:+#x}, {!r}) : Failure trying to store reference count ({!r}) from {:#x} to {:#x}.".format(__name__, old, new, size, iterable, count, ea, new + offset))
            failure.append((ea, new + offset, count))

        # Yield the offset to the global that we just processed.
        logging.debug(u"{:s}.relocate_globals({:#x}, {:#x}, {:+#x}, {!r}) : Relocated count ({:d}) for global {:#x} from {:#x} to {:#x}.".format(__name__, old, new, size, iterable, count, ea, old + offset, new + offset))
        yield i, offset
    return

def segm_start_changed(s, *oldstart):
    # XXX: since changing the segment boundaries shouldn't really modify the
    #      types of any tags, this doesn't need to do anything.
    return

def segm_end_changed(s, *oldend):
    # XXX: since changing the segment boundaries shouldn't really modify the
    #      types of any tags, this doesn't need to do anything.
    return

def segm_moved(source, destination, size, changed_netmap):
    """This is for when the user relocates an individual segment on older versions of IDA (6.9 and earlier).

    The segment is updated in two parts. First we itreate through the functions
    and relocate their cache to the destination address. Afterwards, we iterate
    through all the global tags and relocate those.
    """
    get_segment_name = idaapi.get_segm_name if hasattr(idaapi, 'get_segm_name') else idaapi.get_true_segm_name
    seg = idaapi.getseg(destination)

    # Pre-calculate our search boundaries, collect all of the functions and globals,
    # and then total the number of items that we expect to process.
    functions = sorted(ea for ea in database.functions() if destination <= ea < destination + size)
    globals = sorted((ea, count) for ea, count in internal.comment.globals.iterate() if source <= ea < source + size)
    logging.info(u"{:s}.segm_moved({:#x}, {:#x}, {:+#x}) : Relocating tagcache for segment {:s}.".format(__name__, source, destination, size, get_segment_name(seg)))
    count = sum(map(len, [functions, globals]))

    # Create our progress bar that includes a title describing what's going on and
    # output it to the console so the user can see it.
    P, msg = ui.Progress(), u"Relocating tagcache for segment {:s}: {:#x} ({:+#x}) -> {:#x}".format(get_segment_name(seg), source, size, destination)
    P.update(current=0, min=0, max=count, title=msg), six.print_(msg)
    P.open()

    # Iterate through each function that we're moving and relocate its contents.
    for i, offset in __relocate_function(source, destination, size, (item for item in functions), moved=not changed_netmap):
        name = database.name(destination + offset)
        text = u"Relocating function {:d} of {:d}{:s}: {:#x} -> {:#x}".format(1 + i, len(functions), " ({:s})".format(name) if name else '', source + offset, destination + offset)
        P.update(value=i, text=text)
        ui.navigation.procedure(destination + offset)

    # Iterate through each global that we're moving (we use the target address, because IDA moved everything already).
    for i, offset in __relocate_globals(source, destination, size, (item for item in globals)):
        name = database.name(destination + offset)
        text = u"Relocating global {:d} of {:d}{:s}: {:#x} -> {:#x}".format(1 + i, len(globals), " ({:s})".format(name) if name else '', source + offset, destination + offset)
        P.update(value=len(functions) + i, text=text)
        ui.navigation.analyze(destination + offset)
    P.close()

# address naming
class naming(changingchanged):
    @classmethod
    def updater(cls):
        get_flags = idaapi.getFlags if idaapi.__version__ < 7.0 else idaapi.get_full_flags

        # We first just need to grab the address, the new name, and the old one.
        ea, expected = (yield)
        original = idaapi.get_ea_name(ea, idaapi.GN_LOCAL)

        # Now that we have the names, we need to figure out how
        # the name is going to change. For this we use the flags
        # to check if we're changing from a label to a custom name.
        flags = get_flags(ea)
        labelQ, customQ = (flags & item == item for item in [idaapi.FF_LABL, idaapi.FF_NAME])

        # Next we just need to grab the changes.
        try:
            new_ea, new_name, local_name = (yield)

        except GeneratorExit:
            logging.debug(u"{:s}.event() : Terminating state due to explicit request from owner while the name at {:#x} was being changed from {!r} to {!r}.".format('.'.join([__name__, cls.__name__]), ea, original, expected))
            return

        # And then we double-check that everything matches. If expected is
        # cleared, but new_name holds some value then it's likely because
        # IDA chose some automatic name and so we have to make an assumption.
        if (ea, expected) != (new_ea, expected and new_name):
            prefix = expected.split('_', 1)

            # If the prefix is in one of our known names, then demote the loglevel.
            Flogging = logging.info if prefix[0] in {'sub', 'byte', 'loc'} else logging.fatal
            Flogging(u"{:s}.event() : Rename is at address {:#x} has desynchronized. Target address at {:#x} should have been renamed from {!r} to {!r} but {!r} was received instead.".format('.'.join([__name__, cls.__name__]), ea, new_ea, original, expected, new_name))
            return

        # Now we use the address to figure out which context that we'll
        # need to update. If we're not in a function or the address is an
        # external segment, then we're in the global context.
        fn = idaapi.get_func(ea)
        if fn is None or idaapi.segtype(ea) in {idaapi.SEG_XTRN}:
            if local_name and fn is None:
                logging.warning(u"{:s}.event() : Received rename for address {:#x} where \"{:s}\" is set ({!s}) but the address is not within a function.".format('.'.join([__name__, cls.__name__]), ea, 'local_name', local_name))
            context, target = internal.comment.globals, None

        # If we're renaming the beginning of a function, then we're also
        # in the global context unless it's considered a "local_name".
        elif interface.range.start(fn) == ea and not local_name:
            context, target = internal.comment.globals, None

        # Otherwise, we're inside a function and we should be good.
        else:
            context, target = internal.comment.contents, interface.range.start(fn)

        # Next thing to do is to verify whether we're adding a new name,
        # removing one, or adding one. If the names are the same, then skip.
        if expected == original:
            pass

        # If our new_name is cleared, then we're removing it.
        elif not expected:
            context.dec(new_ea, '__name__') if target is None else context.dec(new_ea, '__name__', target=target)
            logging.info(u"{:s}.event() : Decremented {:s} reference for rename at {:#x} from {!r} to {!r}.".format('.'.join([__name__, cls.__name__]), 'global' if target is None else 'content', ea, original, expected))

        # If our previous name nonexistent, or is a label (and not custom) then we add the reference.
        elif not original or (labelQ and not customQ):
            context.inc(new_ea, '__name__') if target is None else context.inc(new_ea, '__name__', target=target)
            logging.info(u"{:s}.event() : Incremented {:s} reference for rename at {:#x} from {!r} to {!r}.".format('.'.join([__name__, cls.__name__]), 'global' if target is None else 'content', ea, original, expected))

        # If it was both a label and it was custom, then log a warning because we have no idea.
        elif labelQ and customQ:
            logging.debug(u"{:s}.event() : Ignoring existing symbol rename ({:s}) received as a {:s} reference for at {:#x} from {!r} to {!r}.".format('.'.join([__name__, cls.__name__]), ', '.join(itertools.chain(['FF_LABL'] if labelQ else [], ['FF_NAME'] if customQ else [])), 'global' if target is None else 'content', ea, original, expected))

        # Debug log showing that we didn't have to do anything.
        else:
            logging.debug(u"{:s}.event() : Skipping rename at {:#x} from {!r} to {!r}.".format('.'.join([__name__, cls.__name__]), ea, original, expected))
        return

    @classmethod
    def changing(cls, ea, new_name):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changing({:#x}, {!r}) : Ignoring naming.changing event (database not ready) for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, new_name, ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changing({:#x}, {!r}) : Ignoring naming.changing event (not an address) for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, new_name, ea))

        # If we're not an identifier, then construct our new state.
        event = cls.new(ea)
        try:
            event.send((ea, new_name))
        except StopIteration:
            logging.fatal(u"{:s}.changing({:#x}, {!r}) : Abandoning rename at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), ea, new_name, ea), exc_info=True)
        return

    @classmethod
    def changed(cls, ea, new_name, local_name):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changed({:#x}, {!r}, {!s}) : Ignoring naming.changed event (database not ready) for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, new_name, local_name, ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changed({:#x}, {!r}, {!s}) : Ignoring naming.changed event (not an address) for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, new_name, local_name, ea))

        # If we're not changing an identifier, then resume where we left off.
        event = cls.resume(ea)
        try:
            event.send((ea, new_name, local_name))

        # If we get a StopIteration, then the coroutine has terminated unexpected
        # and we need to warn the user about what happened.
        except StopIteration:
            logging.fatal(u"{:s}.changed({:#x}, {!r}, {!s}) : Abandoning update of name at {:#x} due to unexpected termination of event handler.".format('.'.join([__name__, cls.__name__]), ea, new_name, local_name, ea), exc_info=True)
        event.close()

    @classmethod
    def rename(cls, ea, new_name):
        """This hook is when a user adds a name or removes it from the database.

        We simply increase the reference count for the "__name__" key, or decrease it
        if the name is being removed.
        """
        if not cls.is_ready():
            return logging.debug(u"{:s}.rename({:#x}, {!r}) : Ignoring rename event (database not ready) for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, new_name, ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.rename({:#x}, {!r}) : Ignoring rename event (not an address) for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, new_name, ea))

        fl = idaapi.getFlags(ea) if idaapi.__version__ < 7.0 else idaapi.get_full_flags(ea)
        labelQ, customQ = (fl & item == item for item in [idaapi.FF_LABL, idaapi.FF_NAME])
        fn = idaapi.get_func(ea)

        # figure out whether a global or function name is being changed, otherwise it's the function's contents
        ctx = internal.comment.globals if not fn or (interface.range.start(fn) == ea) else internal.comment.contents

        # if a name is being removed
        if not new_name:
            # if it's a custom name
            if (not labelQ and customQ):
                ctx.dec(ea, '__name__')
                logging.debug(u"{:s}.rename({:#x}, {!r}) : Decreasing reference count for tag {!r} at address due to an empty name.".format('.'.join([__name__, cls.__name__]), ea, new_name, '__name__'))
            return

        # if it's currently a label or is unnamed
        if (labelQ and not customQ) or all(not q for q in {labelQ, customQ}):
            ctx.inc(ea, '__name__')
            logging.debug(u"{:s}.rename({:#x}, {!r}) : Increasing reference count for tag {!r} at address due to a new name.".format('.'.join([__name__, cls.__name__]), ea, new_name, '__name__'))
        return

class extra_cmt(changingchanged):
    """
    This class is pretty much just a namespace for finding information about the
    extra comments in order to distinguish whether the comment is being added or
    removed.

    FIXME: This has an issue in that the tag cache is not properly cleaned up as
           we're unable to distinguish whether an extra comment is being created
           or just updated. Because of this, any update of an extra comment will
           result in its reference being increased more than once which then makes
           it impossible to remove without either completely removing and reapplying
           the tags for the address or keeping track of all the extra comments in
           a dictionary of some kind. If the latter is chosen, then we'd need to
           query the entire database for both types of extra comments. If the
           prior is chosen, then we'd need to implement the logic for all of the
           implicit tags in order to zero them entirely prior to re-applying them
           which would result in us losing track of the "__name__" tag.
    """
    MAX_ITEM_LINES = (idaapi.E_NEXT - idaapi.E_PREV) if idaapi.E_NEXT > idaapi.E_PREV else idaapi.E_PREV - idaapi.E_NEXT

    @classmethod
    def Fcount(cls, ea, base):
        sup = internal.netnode.sup
        for index in range(cls.MAX_ITEM_LINES):
            row = sup.get(ea, base + index, type=memoryview)
            if row is None: break
        return index or None

    @classmethod
    def is_prefix(cls, line_idx):
        return idaapi.E_PREV <= line_idx < idaapi.E_PREV + cls.MAX_ITEM_LINES

    @classmethod
    def is_suffix(cls, line_idx):
        return idaapi.E_NEXT <= line_idx < idaapi.E_NEXT + cls.MAX_ITEM_LINES

    @classmethod
    def changed(cls, ea, line_idx, cmt):
        if not cls.is_ready():
            return logging.debug(u"{:s}.changed({:#x}, {:d}, {!r}) : Ignoring extra_cmt.changed event (database not ready) for extra comment at index {:d} for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, line_idx, ea))
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changed({:#x}, {:d}, {!r}) : Ignoring extra_cmt.changed event (not an address) for extra comment at index {:d} for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, line_idx, ea))

        # Verify that the address is within our database boundaries because IDA
        # can actually create "extra" comments outside of the database.
        try:
            ea = interface.address.within(ea)
        except E.OutOfBoundsError:
            return logging.debug(u"{:s}.changed({:#x}, {:d}, {!r}) : Ignoring comment.changed event (not a valid address) for extra comment at index {:d} for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, line_idx, ea))

        # Determine whether we'll be updating the contents or a global.
        logging.debug(u"{:s}.changed({:#x}, {:d}, {!r}) : Processing event at address {:#x} for index {:d}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, utils.string.repr(cmt), ea, line_idx))
        ctx = internal.comment.contents if idaapi.get_func(ea) else internal.comment.globals

        # Figure out what the line_idx boundaries are so that we can use it to check
        # whether there's an "extra" comment at the given address, or not.
        if cls.is_prefix(line_idx):
            base_idx, tag = idaapi.E_PREV, '__extra_prefix__'
        elif cls.is_suffix(line_idx):
            base_idx, tag = idaapi.E_NEXT, '__extra_suffix__'
        else:
            return logging.fatal(u"{:s}.changed({:#x}, {:d}, {!r}) : Unable to determine type of extra comment at index {:d} for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, line_idx, ea))

        # Check if this is not the first line_idx. If it isn't, then we can simply leave
        # because all we care about is whether there's a comment here or not.
        if line_idx not in {base_idx}:
            return logging.debug(u"{:s}.changed({:#x}, {:d}, {!r}) : Exiting event for address {:#x} due to the index ({:d}) not pointing to the comment start ({:d}).".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, ea, line_idx, base_idx))

        # Now we need to figure out whether we've added an extra_cmt, or removed it.
        if cmt is None:
            return ctx.dec(ea, tag)

        # XXX: If an "extra" comment is updated more than once, then we unfortunately
        #      lose track of the reference and it's permanently cached. There's nothing
        #      we can really do here except for keep a complete state of all of the
        #      extra comments that the user has created.
        return ctx.inc(ea, tag)

    @classmethod
    def changed_multiple(cls, ea, line_idx, cmt):
        """
        This implementation is deprecated, but is being preserved as the logic that
        it uses can be reused if the workaround methodology of zero'ing the refcount
        for the entire address is applied.
        """

        # First check that we're not an identifier, because we don't care about
        # caching these.
        if interface.node.is_identifier(ea):
            return logging.debug(u"{:s}.changed_multiple({:#x}, {:d}, {!r}) : Ignoring comment.changed event (not an address) for extra comment at index {:d} for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, line_idx, ea))

        # Verify that the address is within our database boundaries because IDA
        # can actually create "extra" comments outside of the database.
        try:
            ea = interface.address.within(ea)
        except E.OutOfBoundsError:
            return logging.debug(u"{:s}.changed_multiple({:#x}, {:d}, {!r}) : Ignoring comment.changed event (not a valid address) for extra comment at index {:d} for {:#x}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, line_idx, ea))

        # XXX: this function is now busted in later versions of IDA because for some
        #      reason, Ilfak, is now updating the extra comment prior to dispatching
        #      this event. unfortunately, our tag cache doesn't allow us to identify
        #      the actual number of tags that are at an address, so there's no way
        #      to identify the actual change to the extra comment that the user made,
        #      which totally fucks up the reference count. with the current
        #      implementation, if we can't distinguish between the old and new extra
        #      comments, then it's simply a no-op. this is okay for now...

        oldcmt = internal.netnode.sup.get(ea, line_idx, type=memoryview)
        if oldcmt is not None: oldcmt = oldcmt.tobytes().rstrip(b'\0')
        logging.debug(u"{:s}.changed_multiple({:#x}, {:d}, {!r}) : Processing event at address {:#x} for line {:d} with previous comment set to {!r}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, ea, line_idx, oldcmt))
        ctx = internal.comment.contents if idaapi.get_func(ea) else internal.comment.globals

        MAX_ITEM_LINES = (idaapi.E_NEXT - idaapi.E_PREV) if idaapi.E_NEXT > idaapi.E_PREV else idaapi.E_PREV - idaapi.E_NEXT
        prefix = (idaapi.E_PREV, idaapi.E_PREV + MAX_ITEM_LINES, '__extra_prefix__')
        suffix = (idaapi.E_NEXT, idaapi.E_NEXT + MAX_ITEM_LINES, '__extra_suffix__')

        for l, r, key in [prefix, suffix]:
            if l <= line_idx < r:
                if oldcmt is None and cmt is not None: ctx.inc(ea, key)
                elif oldcmt is not None and cmt is None: ctx.dec(ea, key)
                logging.debug(u"{:s}.changed_multiple({:#x}, {:d}, {!r}, oldcmt={!r}) : {:s} reference count at address for tag {!r}.".format('.'.join([__name__, cls.__name__]), ea, line_idx, cmt, oldcmt, 'Increasing' if oldcmt is None and cmt is not None else 'Decreasing' if oldcmt is not None and cmt is None else 'Doing nothing to', key))
            continue
        return

### individual tags
def item_color_changed(ea, color):
    '''This hook is for when a color is applied to an address.'''

    # First make sure it's not an identifier, as if it is then we
    # need to terminate early because the tag cache doesn't care
    # about this stuff.
    if interface.node.is_identifier(ea):
        return

    # Now we need to distinguish between a content or global tag so
    # that we can look it up to see if we need to remove it or add it.
    ctx = internal.comment.contents if idaapi.get_func(ea) else internal.comment.globals

    # FIXME: we need to figure out if the color is being changed,
    #        updated, or removed. since there's no way to determine
    #        this accurately, we just assume that any color is going
    #        to increase the reference count.

    # If the color was restored, then we need to decrease its ref.
    if color in {idaapi.COLOR_DEFAULT}:
        ctx.dec(ea, '__color__')

    # The color is being applied, so we can just increase its reference.
    else:
        ctx.inc(ea, '__color__')
    return

### function scope
def thunk_func_created(pfn):
    pass

def func_tail_appended(pfn, tail):
    """This hook is for when a chunk is appended to a function.

    If the tail we were given only has one owner, then that means we need to
    demote the tags for the tail from globals to contents tags. If there's more
    than one, then we simply add the references in the tail to the function.
    """
    bounds = interface.range.bounds(tail)
    referrers = [fn for fn in function.chunk.owners(bounds.left)]

    # If the number of referrers is larger than just 1, then the tail is
    # owned by more than one function. We still doublecheck, though, to
    # ensure that our pfn is still in the list.
    if len(referrers) > 1:
        if not operator.contains(referrers, interface.range.start(pfn)):
            logging.warning(u"{:s}.func_tail_appended({:#x}, {!s}) : Adjusting contents of function ({:#x}) but function was not found in the owners ({:s}) of chunk {!s}.".format(__name__, interface.range.start(pfn), bounds, interface.range.start(pfn), ', '.join(map("{:#x}".format, referrers)), bounds))

        # Now we just need to iterate through the tail, and tally up
        # the tags for the function in pfn.
        for ea in database.address.iterate(bounds):
            for k in database.tag(ea):
                internal.comment.contents.inc(ea, k, target=interface.range.start(pfn))
                logging.debug(u"{:s}.func_tail_appended({:#x}, {!s}) : Adding reference for tag ({:s}) at {:#x} to cache for function {:#x}.".format(__name__, interface.range.start(pfn), bounds, utils.string.repr(k), ea, interface.range.start(pfn)))
            continue
        return

    # Otherwise if there was only one referrer, then that means this
    # tail is being demoted from globals tags to contents that are
    # owned by the function in pfn.
    if not operator.contains(referrers, interface.range.start(pfn)):
        logging.warning(u"{:s}.func_tail_appended({:#x}, {!s}) : Demoting globals in {!s} and adding them to the cache for function {:#x} but function was not found in the owners ({:s}) of chunk {!s}.".format(__name__, interface.range.start(pfn), bounds, bounds, interface.range.start(pfn), ', '.join(map("{:#x}".format, referrers)), bounds))

    # All we need to do is to iterate through the tail, and adjust
    # any references by exchanging them with the cache for pfn.
    for ea in database.address.iterate(bounds):
        for k in database.tag(ea):
            internal.comment.globals.dec(ea, k)
            internal.comment.contents.inc(ea, k, target=interface.range.start(pfn))
            logging.debug(u"{:s}.func_tail_appended({:#x}, {!s}) : Exchanging (decreasing) reference count for global tag ({:s}) at {:#x} and (increasing) reference count for contents tag in the cache for function {:#x}.".format(__name__, interface.range.start(pfn), bounds, utils.string.repr(k), ea, interface.range.start(pfn)))
        continue
    return

def removing_func_tail(pfn, tail):
    """This hook is for when a chunk is removed from a function.

    If the tail we were given only has one owner, then we promote the tags in
    the tail to globals tags. Otherwise, we just decrease the reference count
    in the cache for the function that the tail was removed from.
    """
    bounds = interface.range.bounds(tail)
    referrers = [fn for fn in function.chunk.owners(bounds.left)]

    # Before we do anything, we need to make sure we can iterate through the
    # boundaries in the database that we're supposed to act upon.
    try:
        iterable = database.address.iterate(bounds)

    # If the address is out of bounds, then IDA removed this tail completely from
    # the database and we need to manually delete the tail's contents. Since we
    # can't trust anything, we use the entire contents index filtered by bounds.
    except E.OutOfBoundsError:
        iterable = (ea for ea, _ in internal.comment.contents.iterate() if bounds.contains(ea))

        results = remove_contents(pfn, iterable)
        for tag, items in results.items():
            logging.debug(u"{:s}.removing_func_tail({:#x}, {!s}) : Removed {:d} instances of tag ({:s}) that were associated with a removed tail.".format(__name__, interface.range.start(pfn), bounds, len(items), utils.string.repr(tag)))
        return

    # If the number of referrers is larger than 1, then the tail was just removed
    # from the pfn function. We verify that the pfn is still in the list of
    # referrers and warn the user if it isn't.
    if len(referrers) > 1:
        if not operator.contains(referrers, interface.range.start(pfn)):
            logging.warning(u"{:s}.removing_func_tail({:#x}, {!s}) : Adjusting contents of function ({:#x}) but function was not found in the owners ({:s}) of chunk {!s}.".format(__name__, interface.range.start(pfn), bounds, interface.range.start(pfn), ', '.join(map("{:#x}".format, referrers)), bounds))

        # So there's no promotion from a contents tag to a global tag, but
        # there is a removal from the cache for pfn.
        for ea in iterable:
            for k in database.tag(ea):
                internal.comment.contents.dec(ea, k, target=interface.range.start(pfn))
                logging.debug(u"{:s}.removing_func_tail({:#x}, {!s}) : Decreasing reference for tag ({:s}) at {:#x} in cache for function {:#x}.".format(__name__, interface.range.start(pfn), bounds, utils.string.repr(k), ea, interface.range.start(pfn)))
            continue
        return

    # Otherwise, there's just one referrer and it should be pointing to pfn.
    if not operator.contains(referrers, interface.range.start(pfn)):
        logging.warning(u"{:s}.removing_func_tail({:#x}, {!s}) : Promoting contents for function ({:#x}) but function was not found in the owners ({:s}) of chunk {!s}.".format(__name__, interface.range.start(pfn), bounds, interface.range.start(pfn), ', '.join(map("{:#x}".format, referrers)), bounds))

    # If there's just one referrer, then the referrer should be pfn and we should
    # be promoting the relevant addresses in the cache from contents to globals.
    for ea in iterable:
        for k in database.tag(ea):
            internal.comment.contents.dec(ea, k, target=interface.range.start(pfn))
            internal.comment.globals.inc(ea, k)
            logging.debug(u"{:s}.removing_func_tail({:#x}, {!s}) : Exchanging (increasing) reference count for global tag ({:s}) at {:#x} and (decreasing) reference count for contents tag in the cache for function {:#x}.".format(__name__, interface.range.start(pfn), bounds, utils.string.repr(k), ea, interface.range.start(pfn)))
        continue
    return

def func_tail_removed(pfn, ea):
    """This hook is for when a chunk is removed from a function in older versions of IDA.

    We simply iterate through the old chunk, decrease all of its tags in the
    function context, and increase their reference within the global context.
    """
    start, stop = interface.range.unpack(pfn)

    # first we'll grab the addresses from our refs
    listable = internal.comment.contents.address(ea, target=start)

    # these should already be sorted, so our first step is to filter out what
    # doesn't belong. in order to work around one of the issues posed in the
    # issue arizvisa/ida-minsc#61, we need to explicitly check that each item is
    # not None prior to their comparison against `pfn`. this is needed in order
    # to work around a null-pointer exception raised by SWIG when it calls the
    # area_t.__ne__ method to do the comparison.
    tail, missing = ea, [ item for item in listable if not idaapi.get_func(item) or idaapi.get_func(item) != pfn ]

    # if there was nothing found, then we can simply exit the hook early
    if not missing:
        return

    logging.debug(u"{:s}.func_tail_removed({:#x}..{:#x}, {:#x}) : Updating the tags for the function tail being removed at address {:#x} to {:#x}.".format(__name__, start, stop, tail, start, stop))

    # now iterate through the min/max of the list as hopefully this is
    # our event.
    for ea in database.address.iterate(min(missing), max(missing)):
        for k in database.tag(ea):
            internal.comment.contents.dec(ea, k, target=start)
            internal.comment.globals.inc(ea, k)
            logging.debug(u"{:s}.func_tail_removed({:#x}..{:#x}, {:#x}) : Exchanging (increasing) reference count at {:#x} for global tag {!s} and (decreasing) reference count for contents tag {!s}.".format(__name__, start, stop, tail, ea, utils.string.repr(k), utils.string.repr(k)))
        continue
    return

def tail_owner_changed(tail, owner_func):
    """This hook is for when a chunk is moved to another function and is for older versions of IDA.

    We simply iterate through the new chunk, decrease all of its tags in its
    previous function's context, and increase their reference within the new
    function's context.
    """
    # XXX: this is for older versions of IDA

    # this is easy as we just need to walk through tail and add it
    # to owner_func
    for ea in database.address.iterate(interface.range.bounds(tail)):
        for k in database.tag(ea):
            internal.comment.contents.dec(ea, k)
            internal.comment.contents.inc(ea, k, target=owner_func)
            logging.debug(u"{:s}.tail_owner_changed({:#x}, {:#x}) : Exchanging (increasing) reference count for contents tag {!s} and (decreasing) reference count for contents tag {!s}.".format(__name__, interface.range.start(tail), owner_func, utils.string.repr(k), utils.string.repr(k)))
        continue
    return

def add_func(pfn):
    """This is called when a new function is created.

    When a new function is created, its entire area needs its tags transformed
    from global tags to function tags. This iterates through each chunk belonging
    to the function and does exactly that.
    """
    implicit = {'__typeinfo__', '__name__'}
    start, stop = interface.range.unpack(pfn)

    # check that we're not adding an import as a function. if this happens,
    # then this is because IDA's ELF loader seems to be loading this.
    if idaapi.segtype(start) == idaapi.SEG_XTRN:
        return

    logging.debug(u"{:s}.add_func({:#x}..{:#x}) : Updating the tags for the new function being added at address {:#x} to {:#x}.".format(__name__, start, stop, start, stop))

    # if the database is ready then we can trust the changingchanged-based classes
    # to add all the implicit tags and thus we can exclude them here. otherwise,
    # we'll do it ourselves because the functions get post-processed after building
    # in order to deal with the events that we didn't receive.
    exclude = implicit if changingchanged.is_ready() else {item for item in []}
    available = {k for k in function.tag(start)}
    [ internal.comment.globals.inc(start, k) for k in available - exclude ]

    # convert all globals into contents whilst making sure that we don't
    # add any of the implicit tags that are handled by other events.
    for l, r in function.chunks(start):
        for ea in database.address.iterate(l, r):
            available = {item for item in database.tag(ea)}
            for k in available - implicit:
                internal.comment.globals.dec(ea, k)
                internal.comment.contents.inc(ea, k, target=start)
                logging.debug(u"{:s}.add_func({:#x}..{:#x}) : Exchanging (decreasing) reference count at {:#x} for global tag {!s} and (increasing) reference count for contents tag {!s}.".format(__name__, start, stop, ea, utils.string.repr(k), utils.string.repr(k)))
            continue
        continue
    return

def remove_contents(fn, iterable):
    '''This is just a utility that manually removes the contents from a function using an iterator of addresses.'''
    func, results = interface.range.start(fn), {}

    # Iterate through each address we were given and decode the contents tags directly
    # using IDAPython, since none of these addresses are accessible via our api.
    for index, ea in enumerate(iterable):
        items = idaapi.get_cmt(ea, True), idaapi.get_cmt(ea, False)
        repeatable, nonrepeatable = (internal.comment.decode(item) for item in items)

        logging.debug(u"{:s}.remove_contents({:#x}) : Removing both repeatable references ({:d}) and non-repeatable references ({:d}) from {:s} ({:#x}).".format(__name__, func, len(repeatable), len(nonrepeatable), 'contents', ea))

        # After decoding it, we can now decrease their refcount and remove them.
        [ internal.comment.contents.dec(ea, k, target=func) for k in repeatable ]
        [ internal.comment.contents.dec(ea, k, target=func) for k in nonrepeatable ]

        # Update our results with the keys at whatever address we just removed.
        [ results.setdefault(k, []).append(ea) for k in itertools.chain(repeatable, nonrepeatable) ]

        # Now we need to do a couple of the implicit tags which means we need to
        # check the name, type information, and color.
        if idaapi.get_item_color(ea) == idaapi.COLOR_DEFAULT:
            internal.comment.contents.dec(ea, '__color__', target=func)
        if database.extra.__get_prefix__(ea) is not None:
            internal.comment.contents.dec(ea, '__extra_prefix__', target=func)
        if database.extra.__get_suffix__(ea) is not None:
            internal.comment.contents.dec(ea, '__extra_suffix__', target=func)

        get_flags = idaapi.getFlags if idaapi.__version__ < 7.0 else idaapi.get_full_flags
        if get_flags(ea) & idaapi.FF_NAME:
            internal.comment.contents.dec(ea, '__name__', target=func)
        continue
    return results

def del_func(pfn):
    """This is called when a function is removed/deleted.

    When a function is removed, all of its tags get moved from the function back
    into the database as global tags. We iterate through the entire function and
    transform its tags by decreasing its reference count within the function,
    and then increasing it for the database. Afterwards we simply remove the
    reference count cache for the function.
    """
    start, stop = interface.range.unpack(pfn)

    try:
        rt, fn = interface.addressOfRuntimeOrStatic(pfn)

    # If IDA told us a function was there, but it actually isn't, then this
    # function was completely removed out from underneath us.
    except E.FunctionNotFoundError:
        exc_info = sys.exc_info()

        # We sanity check what we're being told by checking if it's outside
        # the bounds of the db. If it isn't, then reraise the exception.
        bounds = interface.range.bounds(pfn)
        if any(map(database.within, bounds)):
            six.reraise(*exc_info)

        # Okay, so our function bounds are not within the database whatsoever but
        # we know which function it's in and we know it's boundaries. So at the
        # very least we can manually remove its contents from our storage.
        fn, _ = bounds
        iterable = (ea for ea in internal.comment.contents.address(fn, target=fn) if bounds.contains(ea))

        results = remove_contents(pfn, iterable)
        for tag, items in results.items():
            logging.debug(u"{:s}.del_func({:#x}..{:#x}) : Removed {:d} instances of tag ({:s}) that were associated with a removed function.".format(__name__, start, stop, len(items), utils.string.repr(tag)))

        # Now we need to remove the global tags associated with this function.
        items = idaapi.get_func_cmt(pfn, True), idaapi.get_func_cmt(pfn, False)
        repeatable, nonrepeatable = (internal.comment.decode(item) for item in items)

        logging.debug(u"{:s}.del_func({:#x}..{:#x}) : Removing both repeatable references ({:d}) and non-repeatable references ({:d}) from {:s} ({:#x}).".format(__name__, start, stop, len(repeatable), len(nonrepeatable), 'globals', fn))

        # After decoding them, we can try to decrease our reference count.
        [ internal.comment.globals.dec(fn, k) for k in repeatable ]
        [ internal.comment.globals.dec(fn, k) for k in nonrepeatable ]

        # We also need to handle any implicit tags as well to be properly done.
        if pfn.color == idaapi.COLOR_DEFAULT:
            internal.comment.globals.dec(fn, '__color__')

        get_flags = idaapi.getFlags if idaapi.__version__ < 7.0 else idaapi.get_full_flags
        if get_flags(fn) & idaapi.FF_NAME:
            internal.comment.globals.dec(fn, '__name__')

        get_tinfo = (lambda ti, ea: idaapi.get_tinfo2(ea, ti)) if idaapi.__version__ < 7.0 else idaapi.get_tinfo
        if get_tinfo(idaapi.tinfo_t(), fn):
            internal.comment.globals.dec(fn, '__typeinfo__')
        return

    # convert all contents into globals
    for ea in internal.comment.contents.address(fn, target=fn):
        for k in database.tag(ea):
            internal.comment.contents.dec(ea, k, target=fn)
            internal.comment.globals.inc(ea, k)
            logging.debug(u"{:s}.del_func({:#x}..{:#x}) : Exchanging (increasing) reference count at {:#x} for global tag {!s} and (decreasing) reference count for contents tag {!s}.".format(__name__, start, stop, ea, utils.string.repr(k), utils.string.repr(k)))
        continue

    # remove all function tags depending on whether our address
    # is part of a function, runtime-linked, or neither.
    Ftags = database.tag if rt else function.tag
    for k in Ftags(fn):
        internal.comment.globals.dec(fn, k)
        logging.debug(u"{:s}.del_func({:#x}..{:#x}) : Removing (global) tag {!s} from function at {:#x}.".format(__name__, start, stop, utils.string.repr(k), fn))
    return

def set_func_start(pfn, new_start):
    """This is called when the user changes the beginning of the function to another address.

    If this happens, we simply walk from the new address to the old address of
    the function that was changed. Then we can update the reference count for
    any globals that were tagged by moving them into the function's tagcache.
    """
    start, stop = interface.range.unpack(pfn)

    # if new_start has removed addresses from function, then we need to transform
    # all contents tags into globals tags
    if start > new_start:
        for ea in database.address.iterate(new_start, start):
            for k in database.tag(ea):
                internal.comment.contents.dec(ea, k, target=start)
                internal.comment.globals.inc(ea, k)
                logging.debug(u"{:s}.set_func_start({:#x}..{:#x}, {:#x}) : Exchanging (increasing) reference count at {:#x} for global tag {!s} and (decreasing) reference count for contents tag {!s}.".format(__name__, start, stop, new_start, ea, utils.string.repr(k), utils.string.repr(k)))
            continue
        return

    # if new_start has added addresses to function, then we need to transform all
    # its global tags into contents tags
    elif start < new_start:
        for ea in database.address.iterate(start, new_start):
            for k in database.tag(ea):
                internal.comment.globals.dec(ea, k)
                internal.comment.contents.inc(ea, k, target=start)
                logging.debug(u"{:s}.set_func_start({:#x}..{:#x}, {:#x}) : Exchanging (decreasing) reference count at {:#x} for global tag {!s} and (increasing) reference count for contents tag {!s}.".format(__name__, start, stop, new_start, ea, utils.string.repr(k), utils.string.repr(k)))
            continue
        return
    return

def set_func_end(pfn, new_end):
    """This is called when the user changes the ending of the function to another address.

    If this happens, we simply walk from the old end of the function to the new
    end of the function that was changed. Then we can update the reference count
    for any globals that were tagged by moving them into the function's tagcache.
    """
    start, stop = interface.range.unpack(pfn)

    # if new_end has added addresses to function, then we need to transform
    # all globals tags into contents tags
    if new_end > stop:
        for ea in database.address.iterate(stop, new_end):
            for k in database.tag(ea):
                internal.comment.globals.dec(ea, k)
                internal.comment.contents.inc(ea, k, target=start)
                logging.debug(u"{:s}.set_func_end({:#x}..{:#x}, {:#x}) : Exchanging (decreasing) reference count at {:#x} for global tag {!s} and (increasing) reference count for contents tag {!s}.".format(__name__, start, stop, new_end, ea, utils.string.repr(k), utils.string.repr(k)))
            continue
        return

    # if new_end has removed addresses from function, then we need to transform
    # all contents tags into globals tags
    elif new_end < stop:
        for ea in database.address.iterate(new_end, stop):
            for k in database.tag(ea):
                internal.comment.contents.dec(ea, k, target=start)
                internal.comment.globals.inc(ea, k)
                logging.debug(u"{:s}.set_func_end({:#x}..{:#x}, {:#x}) : Exchanging (increasing) reference count at {:#x} for global tag {!s} and (decreasing) reference count for contents tag {!s}.".format(__name__, start, stop, new_end, ea, utils.string.repr(k), utils.string.repr(k)))
            continue
        return
    return

class supermethods(object):
    """
    Define all of the functions that will be used as supermethods for
    the situation when the original hook supermethod does not take the
    same parameters as listed in IDAPython's documentation. This is
    used when setting up the hooks via the priorityhook class during
    the initialization of them by the ui.hook namepsace.
    """

    class IDP_Hooks(object):
        """
        This is just a namespace for the the list of supermethods that
        we need to override with when using the IDP_Hooks object.
        """
        mapping = {}

        # idaapi.__version__ >= 7.5
        def ev_set_idp_options(self, keyword, value_type, value, idb_loaded):
            '''This patch is needed as the supermethod wants a vector type for its value.'''
            cls = self.__class__
            if value_type == idaapi.IDPOPT_STR:     # string constant (char*)
                res = idaapi.uchar_array(1 + len(value))
                for index, item in enumerate(bytearray(value + b'\0')):
                    res[index] = item
                pvalue = res
            elif value_type == idaapi.IDPOPT_NUM:   # number (uval_t*)
                res = idaapi.uvalvec_t()
                res.push_back(value)
                pvalue = res
            elif value_type == idaapi.IDPOPT_BIT:   # bit, yes/no (int*)
                res = idaapi.intvec_t()
                res.push_back(value)
                pvalue = res
            elif value_type == idaapi.IDPOPT_FLT:   # float, yes/no (double*)
                # FIXME: is there a proper way to get a double* type?
                res = idaapi.uint64vec_t()
                res.push_back(internal.utils.float_to_integer(value, 52, 11, 1))
                pvalue = res
            elif value_type == idaapi.IDPOPT_I64:   # 64bit number (int64*)
                res = idaapi.int64vec_t()
                res.push_back(value)
                pvalue = res
            else:
                raise ValueError(u"ev_set_idp_options_hook({!r}, {:d}, {:d}, {!s}) : Unknown value_type ({:d}) passed to ev_set_idp_options hook".format(keyword, value_type, value, idb_loaded, value_type))

            # We need to figure out the original supermethod to call into
            # ourselves because we don't have the method name as a cellvar.
            supercls = super(cls, self)
            supermethod = getattr(supercls, 'ev_set_idp_options')
            return supermethod(keyword, value_type, pvalue, idb_loaded)

        # Populate the dictionary with each of the supermethods that need
        # to be patched for the IDB_Hooks class by checking the version
        # in order to determine whether it should be assigned or not.
        idaapi.__version__ >= 7.5 and mapping.setdefault('ev_set_idp_options', ev_set_idp_options)

    class IDB_Hooks(object):
        """
        This is just a namespace for the the list of supermethods that
        we need to override with when using the IDB_Hooks object.
        """
        mapping = {}

        # idaapi.__version__ >= 7.6
        def compiler_changed(self, adjust_inf_fields):
            '''This patch is needed due to the supermethod not wanting *this as its first parameter.'''
            cls = self.__class__
            supercls = super(cls, self)
            supermethod = getattr(supercls, 'compiler_changed')
            return supermethod(adjust_inf_fields)

        # idaapi.__version__ >= 7.6
        def renamed(self, ea, new_name, local_name):
            '''This patch is needed due to the supermethod wanting a different number of parameters.'''
            cls = self.__class__
            supercls = super(cls, self)
            supermethod = getattr(supercls, 'renamed')
            return supermethod(ea, new_name, local_name or None, '')

        # idaapi.__version__ >= 7.6
        def bookmark_changed(self, index, pos, desc, operation):
            '''This patch is needed due to the supermethod not wanting *this as its first parameter.'''
            cls = self.__class__
            supercls = super(cls, self)
            supermethod = getattr(supercls, 'bookmark_changed')
            return supermethod(index, pos, desc, operation)

        # idaapi.__version__ >= 7.7
        def segm_deleted(self, start_ea, end_ea, flags):
            '''This patch is needed due to the supermethod not wanting *this as its first parameter.'''
            cls = self.__class__
            supercls = super(cls, self)
            supermethod = getattr(supercls, 'segm_deleted')
            return supermethod(start_ea, end_ea, flags)

        # Populate the dictionary with each of the supermethods that need
        # to be patched for the IDB_Hooks class by checking the version
        # in order to determine whether it should be assigned or not.
        idaapi.__version__ >= 7.6 and mapping.setdefault('compiler_changed', compiler_changed)
        idaapi.__version__ >= 7.6 and mapping.setdefault('renamed', renamed)
        idaapi.__version__ >= 7.6 and mapping.setdefault('bookmark_changed', bookmark_changed)
        idaapi.__version__ >= 7.7 and mapping.setdefault('segm_deleted', segm_deleted)

    class UI_Hooks(object):
        """
        This is just a namespace for the the list of supermethods that
        we need to override with when using the UI_Hooks object.
        """
        mapping = {}

        # idaapi.__version__ >= 7.6
        def saved(self, path):
            '''This patch is needed due to the supermethod not wanting *this as its first parameter.'''
            cls = self.__class__
            supercls = super(cls, self)
            supermethod = getattr(supercls, 'saved')
            return supermethod(path)

        # Populate the dictionary with each of the supermethods that need
        # to be patched for the IDB_Hooks class by checking the version
        # in order to determine whether it should be assigned or not.
        idaapi.__version__ >= 7.6 and mapping.setdefault('saved', saved)

def make_ida_not_suck_cocks(nw_code):
    '''Start hooking all of IDA's API.'''

    ## initialize the priorityhook api for all three of IDA's interfaces
    ui.hook.__start_ida__()

    ## setup default integer types for the typemapper once the loader figures everything out
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_newprc', interface.typemap.__ev_newprc__, 0)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idp.add('newprc', interface.typemap.__newprc__, 0)

    else:
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, interface.typemap.__nw_newprc__, -40)

    ## monitor when ida enters its various states so we can pre-build the tag cache
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_init', on_init, -100)
        ui.hook.idp.add('ev_newfile', on_newfile, -100)
        ui.hook.idp.add('ev_oldfile', on_oldfile, -100)
        ui.hook.idp.add('ev_auto_queue_empty', auto_queue_empty, -100)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idp.add('init', on_init, -100)
        ui.hook.idp.add('newfile', on_newfile, -100)
        ui.hook.idp.add('oldfile', on_oldfile, -100)
        ui.hook.idp.add('auto_empty', on_ready, -100)

    else:
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, nw_on_init, -50)
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, nw_on_newfile, -20)
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, nw_on_oldfile, -20)
        ui.hook.idp.add('auto_empty', on_ready, 0)

    ui.hook.idb.add('closebase', on_close, 10000) if 'closebase' in ui.hook.idb.available else ui.hook.idp.add('closebase', on_close, 10000)

    ## create the tagcache netnode when a database is created
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_init', comment.tagging.__init_tagcache__, -1)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idp.add('init', comment.tagging.__init_tagcache__, -1)

    else:
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, comment.tagging.__nw_init_tagcache__, -40)

    ## hook any user-entered comments so that they will also update the tagcache
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_init', address.database_init, 0)
        ui.hook.idp.add('ev_init', globals.database_init, 0)
        ui.hook.idb.add('changing_range_cmt', globals.changing, 0)
        ui.hook.idb.add('range_cmt_changed', globals.changed, 0)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idp.add('init', address.database_init, 0)
        ui.hook.idp.add('init', globals.database_init, 0)
        ui.hook.idb.add('changing_area_cmt', globals.changing, 0)
        ui.hook.idb.add('area_cmt_changed', globals.changed, 0)

    else:
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, address.nw_database_init, -30)
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, globals.nw_database_init, -30)
        ui.hook.idb.add('area_cmt_changed', globals.old_changed, 0)

    # hook the changing of a comment
    if idaapi.__version__ >= 6.9:
        ui.hook.idb.add('changing_cmt', address.changing, 0)
        ui.hook.idb.add('cmt_changed', address.changed, 0)

    else:
        ui.hook.idb.add('cmt_changed', address.old_changed, 0)

    ## hook renames to support updating the "__name__" implicit tag
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_init', naming.database_init, 0)
        ui.hook.idp.add('ev_rename', naming.changing, 0)
        ui.hook.idb.add('renamed', naming.changed, 0)

    else:
        ui.hook.idp.add('rename', naming.rename, 0)

    ## hook function transformations so we can shuffle their tags between types
    if idaapi.__version__ >= 7.0:
        ui.hook.idb.add('deleting_func_tail', removing_func_tail, 0)
        ui.hook.idb.add('func_added', add_func, 0)
        ui.hook.idb.add('deleting_func', del_func, 0)
        ui.hook.idb.add('set_func_start', set_func_start, 0)
        ui.hook.idb.add('set_func_end', set_func_end, 0)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idb.add('removing_func_tail', removing_func_tail, 0)
        [ ui.hook.idp.add(item.__name__, item, 0) for item in [add_func, del_func, set_func_start, set_func_end] ]

    else:
        ui.hook.idb.add('func_tail_removed', func_tail_removed, 0)
        ui.hook.idp.add('add_func', add_func, 0)
        ui.hook.idp.add('del_func', del_func, 0)
        ui.hook.idb.add('tail_owner_changed', tail_owner_changed, 0)

    [ ui.hook.idb.add(item.__name__, item, 0) for item in [thunk_func_created, func_tail_appended] ]

    ## Relocate the tagcache for an individual segment if that segment is moved.
    ui.hook.idb.add('segm_start_changed', segm_start_changed, 0)
    ui.hook.idb.add('segm_end_changed', segm_end_changed, 0)
    ui.hook.idb.add('segm_moved', segm_moved, 0)

    ## switch the instruction set when the processor is switched
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_newprc', instruction.__ev_newprc__, 0)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idp.add('newprc', instruction.__newprc__, 0)

    else:
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, instruction.__nw_newprc__, -10)

    ## ensure the database.config namespace is initialized as it's
    ## necessary and used by the processor detection.
    if idaapi.__version__ >= 7.0:
        ui.hook.idp.add('ev_init', database.config.__init_info_structure__, -100)

    elif idaapi.__version__ >= 6.9:
        ui.hook.idp.add('init', database.config.__init_info_structure__, -100)

    else:
        hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_OPENIDB, database.config.__nw_init_info_structure__, -30)

    ## keep track of individual tags like colors and type info
    if idaapi.__version__ >= 7.2:
        ui.hook.idb.add('item_color_changed', item_color_changed, 0)

    # anything earlier than v7.0 doesn't expose the "changing_ti" and "ti_changed"
    # hooks... plus, v7.1 doesn't pass us the correct type (idaapi.tinfo_t) as its
    # parameter, instead opting for an idaapi.comp_t (compiler type) which is
    # completely fucking useless to us. so if we're using 7.1 or earlier, then
    # we completely skip the addition of the typeinfo hooks.
    if idaapi.__version__ >= 7.2:
        ui.hook.idp.add('ev_init', typeinfo.database_init, 0)
        ui.hook.idb.add('changing_ti', typeinfo.changing, 0)
        ui.hook.idb.add('ti_changed', typeinfo.changed, 0)

    # earlier versions of IDAPython don't expose anything about "extra" comments
    # so we can't do anything here.
    if idaapi.__version__ >= 6.9:
        ui.hook.idb.add('extra_cmt_changed', extra_cmt.changed, 0)

    ## just some debugging notification hooks
    #[ ui.hook.ui.add(item, notify(item), -100) for item in ['range','idcstop','idcstart','suspend','resume','term','ready_to_run'] ]
    #[ ui.hook.idp.add(item, notify(item), -100) for item in ['ev_newfile','ev_oldfile','ev_init','ev_term','ev_newprc','ev_newasm','ev_auto_queue_empty'] ]
    #[ ui.hook.idb.add(item, notify(item), -100) for item in ['closebase','savebase','loader_finished', 'auto_empty', 'thunk_func_created','func_tail_appended'] ]
    #[ ui.hook.idp.add(item, notify(item), -100) for item in ['add_func','del_func','set_func_start','set_func_end'] ]
    #ui.hook.idb.add('allsegs_moved', notify('allsegs_moved'), -100)
    #[ ui.hook.idb.add(item, notify(item), -100) for item in ['cmt_changed', 'changing_cmt', 'range_cmt_changed', 'changing_range_cmt'] ]
    #[ ui.hook.idb.add(item, notify(item), -100) for item in ['changing_ti', 'ti_changed', 'changing_op_type', 'op_type_changed'] ]
    #[ ui.hook.idb.add(item, notify(item), -100) for item in ['changing_op_ti', 'op_ti_changed'] ]
    #ui.hook.idb.add('item_color_changed', notify(item), -100)
    #ui.hook.idb.add('extra_cmt_changed', notify(item), -100)

    ### ...and that's it for all the hooks, so give out our greeting
    return greeting()

def make_ida_suck_cocks(nw_code):
    '''Unhook all of IDA's API.'''
    hasattr(idaapi, '__notification__') and idaapi.__notification__.close()
    ui.hook.__stop_ida__()

def ida_is_busy_sucking_cocks(*args, **kwargs):
    make_ida_not_suck_cocks(idaapi.NW_INITIDA)
    hasattr(idaapi, '__notification__') and idaapi.__notification__.add(idaapi.NW_TERMIDA, make_ida_suck_cocks, +1000)
    return -1

```

`misc/ui.py`:

```py
"""
User Interface module

This module exposes a number of tools and class definitions for
interacting with IDA's user interface. This includes things such
as getting the current state of user input, information about
windows that are in use as well as utilities for simplifying the
customization of the interface.

There are a few namespaces that are provided in order to get the
current state. The ``ui.current`` namespace allows for one to get
the current address, function, segment, window, as well as a number
of other things.

A number of namespaces defined within this module also allows a
user to interact with the different windows that are currently
in use. This can allow for one to automatically show or hide a
window that they wish to expose to the user.
"""

import six, builtins
import sys, os, operator, math, threading, time, functools, inspect, itertools
import logging, ctypes

import idaapi, internal
import database as _database, segment as _segment

## TODO:
# locate window under current cursor position
# pop-up a menu item
# pop-up a form/messagebox
# another item menu to toolbar
# find the QAction associated with a command (or keypress)

class application(object):
    """
    This namespace is for getting information about the application user-interface.
    """
    def __new__(cls):
        '''Return the current instance of the application.'''
        raise internal.exceptions.MissingMethodError

    @classmethod
    def window(cls):
        '''Return the current window for the application.'''
        raise internal.exceptions.MissingMethodError

    @classmethod
    def windows(cls):
        '''Return all of the top-level windows for the application.'''
        raise internal.exceptions.MissingMethodError

    @classmethod
    def beep(cls):
        '''Beep using the application interface.'''
        return idaapi.beep()
beep = internal.utils.alias(application.beep, 'application')

class ask(object):
    """
    This namespace contains utilities for asking the user for some
    particular type of information. These will typically require a
    user-interface of some sort and will block while waiting for the
    user to respond.

    If the `default` parameter is specified to any of the functions
    within this namespace, then its value will be used by default
    in the inbox that is displayed to the user.
    """
    @internal.utils.multicase()
    def __new__(cls, **default):
        '''Request the user choose from the options "yes", "no", or "cancel".'''
        return cls(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    def __new__(cls, message, **default):
        '''Request the user choose from the options "yes", "no", or "cancel" using the specified `message` as the prompt.'''
        return cls.yn(message, **default)

    @internal.utils.multicase()
    @classmethod
    def yn(cls, **default):
        '''Request the user choose from the options "yes", "no", or "cancel".'''
        return cls.yn(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('message')
    def yn(cls, message, **default):
        """Request the user choose from the options "yes", "no", or "cancel" using the specified `message` as the prompt.

        If any of the options are specified as a boolean, then it is
        assumed that this option will be the default. If the user
        chooses "cancel", then this value will be returned instead of
        the value ``None``.
        """
        state = {'no': getattr(idaapi, 'ASKBTN_NO', 0), 'yes': getattr(idaapi, 'ASKBTN_YES', 1), 'cancel': getattr(idaapi, 'ASKBTN_CANCEL', -1)}
        results = {state['no']: False, state['yes']: True}
        if default:
            keys = {item for item in default.keys()}
            keys = {item.lower() for item in keys if default.get(item, False)}
            dflt = next((item for item in keys), 'cancel')
        else:
            dflt = 'cancel'
        res = idaapi.ask_yn(state[dflt], internal.utils.string.to(message))
        return results.get(res, None)

    @internal.utils.multicase()
    @classmethod
    def address(cls, **default):
        '''Request the user provide an address.'''
        return cls.address(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('message')
    def address(cls, message, **default):
        """Request the user provide an address using the specified `message` as the prompt.

        If the `valid` parameter is specified, then verify that the
        address is within the bounds of the database. If the `bounds`
        parameter is specified, then verify that the address chosen
        by the user is within the provided bounds.
        """
        dflt = next((default[k] for k in ['default', 'address', 'ea', 'addr'] if k in default), current.address())

        # Ask the user for an address...
        ea = idaapi.ask_addr(dflt, internal.utils.string.to(message))

        # If we received idaapi.BADADDR, then the user gave us a bogus
        # value that we need to return None for.
        if ea == idaapi.BADADDR:
            return None

        # Grab the bounds that we'll need to compare the address to from
        # the parameters or the database configuration.
        bounds = next((default[k] for k in ['bounds'] if k in default), _database.config.bounds())

        # If we were asked to verify the address, or we were given some
        # boundaries to check it against..then do that here.
        if default.get('verify', 'bounds' in default):
            l, r = bounds
            return ea if l <= ea < r else None

        # Otherwise, we can just return the address here.
        return ea

    @internal.utils.multicase()
    @classmethod
    def integer(cls, **default):
        '''Request the user provide an integer.'''
        return cls.integer(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('message')
    def integer(cls, message, **default):
        '''Request the user provide an integer using the specified `message` as the prompt.'''
        dflt = next((default[k] for k in ['default', 'integer', 'long', 'int'] if k in default), getattr(cls, '__last_integer__', 0))

        # Ask the user for some kind of integer...
        integer = idaapi.ask_long(dflt, internal.utils.string.to(message))

        # If we actually received an integer, then cache it so that we can
        # reuse it as the default the next time this function gets called.
        if integer is not None:
            cls.__last_integer__ = integer

        return integer

    @internal.utils.multicase()
    @classmethod
    def segment(cls, **default):
        '''Request the user provide a segment.'''
        return cls.segment(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('message')
    def segment(cls, message, **default):
        '''Request the user provide a segment using the specified `message` as the prompt.'''
        res = current.segment()
        dflt = next((default[k] for k in ['default', 'segment', 'seg'] if k in default), internal.interface.range.start(res) if res else idaapi.BADADDR)
        ea = idaapi.ask_seg(dflt, internal.utils.string.to(message))

        # Try and convert whatever it was that we were given into an actual segment.
        try:
            seg = _segment.by(ea)

        # If we got an exception, then just set our result to None so that we can
        # let the caller figure out how much they really want it.
        except Exception:
            return None

        # Return the segment_t back to the caller.
        return seg

    @internal.utils.multicase()
    @classmethod
    def string(cls, **default):
        '''Request the user provide a string.'''
        return cls.string(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('message', 'default', 'text', 'string')
    def string(cls, message, **default):
        '''Request the user provide a string using the specified `message` as the prompt.'''
        dflt = next((default[k] for k in ['default', 'text', 'string'] if k in default), None) or u''

        # FIXME: we should totally expose the history id to the caller in some
        #        way.. but after some fiddling around with it, I can't seem to
        #        make it actually do anything.

        result = idaapi.ask_str(internal.utils.string.to(dflt), idaapi.HIST_IDENT, internal.utils.string.to(message))
        return internal.utils.string.of(result)

    @internal.utils.multicase()
    @classmethod
    def note(cls, **default):
        '''Request the user provide a multi-lined string.'''
        return cls.note(u'', **default)
    @internal.utils.multicase(message=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('message', 'default', 'text', 'string')
    def note(cls, message, **default):
        """Request the user provide a multi-lined string using the specified `message` as the prompt.

        If the `length` parameter is provided as an integer, then constrain
        the length of the user's input to the integer that was specified.
        """
        dflt = next((default[k] for k in ['default', 'text', 'string'] if k in default), None) or u''
        length = next((default[k] for k in ['length', 'max', 'maxlength'] if k in default), 0)
        result = idaapi.ask_text(length, internal.utils.string.to(dflt), internal.utils.string.to(message))
        return internal.utils.string.of(result)

class current(object):
    """
    This namespace contains tools for fetching information about the
    current selection state. This can be used to get the state of
    thigns that are currently selected such as the address, function,
    segment, clipboard, widget, or even the current window in use.
    """
    @classmethod
    def address(cls):
        '''Return the current address.'''
        return idaapi.get_screen_ea()
    @classmethod
    def color(cls):
        '''Return the color of the current item.'''
        ea = cls.address()
        return idaapi.get_item_color(ea)
    @classmethod
    def function(cls):
        '''Return the current function.'''
        ea = cls.address()
        res = idaapi.get_func(ea)
        if res is None:
            raise internal.exceptions.FunctionNotFoundError(u"{:s}.function() : Unable to find a function at the current location.".format('.'.join([__name__, cls.__name__])))
        return res
    @classmethod
    def segment(cls):
        '''Return the current segment.'''
        ea = cls.address()
        return idaapi.getseg(ea)
    @classmethod
    def status(cls):
        '''Return the IDA status.'''
        # TODO: grab the current status and return it in some form
        raise internal.exceptions.UnsupportedCapability(u"{:s}.status() : Unable to get the current disassembler status.".format('.'.join([__name__, cls.__name__])))
    @classmethod
    def symbol(cls):
        '''Return the current highlighted symbol name or register.'''
        if idaapi.__version__ < 7.0:
            return idaapi.get_highlighted_identifier()

        HIF_IDENTIFIER, HIF_REGISTER = getattr(idaapi, 'HIF_IDENTIFIER', 1), getattr(idaapi, 'HIF_REGISTER', 2)

        # IDA 7.0 way of getting the currently selected text
        viewer = idaapi.get_current_viewer()
        identifier_and_flags = idaapi.get_highlight(viewer)
        if identifier_and_flags is None:
            return None
        identifier, flags = identifier_and_flags

        # If it wasn't a register, then we can just return the identifier as a string.
        if flags & HIF_REGISTER == 0:
            return identifier

        # Otherwise we need to lookup our identifier in the current architecture.
        import instruction
        try:
            res = instruction.architecture.by_name(identifier)

        # If we got an exception, then only log a warning if the architecture is known.
        except Exception as E:
            if hasattr(instruction, 'architecture'):
                architecture = instruction.architecture.__class__
                logging.warning(u"{:s}.symbol(): Returning a string due to the returned identifier (\"{:s}\") not being available within the current architecture ({:s}).".format('.'.join([__name__, cls.__name__]), identifier, architecture.__name__))
            return identifier
        return res
    @classmethod
    def selection(cls):
        '''Return the current address range of whatever is selected'''
        view = idaapi.get_current_viewer()
        ok, left, right = False, idaapi.twinpos_t(), idaapi.twinpos_t()

        # If we were able to grab a selection, then return it.
        newer = hasattr(idaapi.place_t, 'toea')
        if newer and idaapi.read_selection(view, left, right):
            pl_l, pl_r = left.place(view), right.place(view)
            ok, ea_l, ea_r = True, pl_l.toea(), pl_r.toea()

        # Older versions of the disassembler pack it all into the "read_selection" result.
        elif not newer:
            ok, ea_l, ea_r = idaapi.read_selection(view, left, right)

        # If we successfully grabbed the selection, then return its boundaries.
        if ok:
            l, r = internal.interface.address.inside(ea_l, ea_r)
            return internal.interface.bounds_t(l, r + 1)

        # Otherwise we just use the current address for both sides.
        ea = idaapi.get_screen_ea()
        ea_l, ea_r = ea, ea
        return internal.interface.bounds_t(ea_l, ea_r)
    selected = internal.utils.alias(selection, 'current')
    @classmethod
    def operand(cls):
        '''Return the currently selected operand number.'''
        return idaapi.get_opnum()
    opnum = internal.utils.alias(operand, 'current')
    @classmethod
    def widget(cls):
        '''Return the current widget that is being used.'''
        if hasattr(idaapi, 'get_current_widget'):
            return idaapi.get_current_widget()

        # XXX: there's probably a better way to do this rather than looking
        #      at the mouse cursor position
        x, y = mouse.position()
        return widget.at((x, y))
    @classmethod
    def window(cls):
        '''Return the current window that is being used.'''
        return application.window()
    @classmethod
    def viewer(cls):
        '''Return the current viewer that is being used.'''
        return idaapi.get_current_viewer()

class state(object):
    """
    This namespace is for fetching or interacting with the current
    state of IDA's interface. These are things such as waiting for
    IDA's analysis queue, or determining whether the function is
    being viewed in graph view or not.
    """
    @classmethod
    def graphview(cls):
        '''Returns true if the current function is being viewed in graph view mode.'''
        res = idaapi.get_inf_structure()
        if idaapi.__version__ < 7.0:
            return res.graph_view != 0
        return res.is_graph_view()

    @classmethod
    def wait(cls):
        '''Wait until IDA's autoanalysis queues are empty.'''
        return idaapi.autoWait() if idaapi.__version__ < 7.0 else idaapi.auto_wait()
wait = internal.utils.alias(state.wait, 'state')

class message(object):
    """
    This namespace is for displaying a modal dialog box with the different
    icons that are available from IDA's user interface. The functions within
    will block IDA from being interacted with while their dialog is displayed.
    """
    def __new__(cls, message, **icon):
        '''Display a modal information dialog box using the provided `message`.'''
        if not idaapi.is_msg_inited():
            raise internal.exceptions.DisassemblerError(u"{:s}({!r}{:s}) : Unable to display the requested modal dialog due to the user interface not yet being initialized.".format('.'.join([__name__, cls.__name__]), message, ", {:s}".format(internal.utils.string.kwargs(icon)) if icon else ''))

        # because ida is fucking hil-ar-ious...
        def why(F, *args):
            name = '.'.join([F.__module__, F.__name__] if hasattr(F, '__module__') else [F.__name__])
            raise internal.exceptions.DisassemblerError(u"{:s}({!r}{:s}) : Refusing to display the requested modal dialog with `{:s}` due it explicitly terminating the host application.".format('.'.join([__name__, cls.__name__]), message, ", {:s}".format(internal.utils.string.kwargs(icon)) if icon else '', name))

        # these are all of the ones that seem to be available.
        mapping = {
            'information': idaapi.info, 'info': idaapi.info,
            'warning': idaapi.warning, 'warn': idaapi.warning,
            'error': functools.partial(why, idaapi.error), 'fatal': functools.partial(why, idaapi.error),
            'nomem': functools.partial(why, idaapi.nomem), 'fuckyou': functools.partial(why, idaapi.nomem),
        }
        F = builtins.next((mapping[k] for k in icon if mapping.get(k, False)), idaapi.info)

        # format it and give a warning if it's not the right type.
        formatted = message if isinstance(message, six.string_types) else "{!s}".format(message)
        if not isinstance(message, six.string_types):
            logging.warning(u"{:s}({!r}{:s}) : Formatted the given message ({!r}) as a string ({!r}) prior to displaying it.".format('.'.join([__name__, cls.__name__]), message, ", {:s}".format(internal.utils.string.kwargs(icon)) if icon else '', message, formatted))

        # set it off...
        return F(internal.utils.string.to(formatted))

    @classmethod
    def information(cls, message):
        '''Display a modal information dialog box using the provided `message`.'''
        return cls(message, information=True)
    info = internal.utils.alias(information, 'message')

    @classmethod
    def warning(cls, message):
        '''Display a modal warning dialog box using the provided `message`.'''
        return cls(message, warning=True)
    warn = internal.utils.alias(warning, 'message')

    @classmethod
    def error(cls, message):
        '''Display a modal error dialog box using the provided `message`.'''
        return cls(message, error=True)

class appwindow(object):
    """
    Base namespace used for interacting with the windows provided by IDA.
    """
    @classmethod
    def open(cls, *args):
        '''Open or show the window belonging to the namespace.'''
        global widget
        res = cls.__open__(*args) if args else cls.__open__(*getattr(cls, '__open_defaults__', ()))
        return widget.of(res)

    @classmethod
    def close(cls):
        '''Close or hide the window belonging to the namespace.'''
        res = cls.open()
        return res.deleteLater()

class breakpoints(appwindow):
    """
    This namespace is for interacting with the Breakpoints window.
    """
    __open__ = staticmethod(idaapi.open_bpts_window)
    __open_defaults__ = (idaapi.BADADDR, 0)

class calls(appwindow):
    """
    This namespace is for interacting with the (Function) Calls window.
    """
    __open__ = staticmethod(idaapi.open_calls_window)
    __open_defaults__ = (idaapi.BADADDR, 0)

class disassembly(appwindow):
    """
    This namespace is for interacting with the Disassembly window.
    """
    __open__ = staticmethod(idaapi.open_disasm_window)
    __open_defaults__ = ('Disassembly', )

    @classmethod
    def refresh(cls):
        '''Refresh the main IDA disassembly view.'''
        return idaapi.refresh_idaview_anyway()
disassembler = disassembly

class dump(appwindow):
    """
    This namespace is for interacting with the (Hex) Dump window.
    """
    __open__ = staticmethod(idaapi.open_hexdump_window)
    __open_defaults__ = (idaapi.BADADDR, 0)
hexdump = dump

class enumerations(appwindow):
    """
    This namespace is for interacting with the Enumerations window.
    """
    __open__ = staticmethod(idaapi.open_enums_window)
    __open_defaults__ = (idaapi.BADADDR, 0)

class exports(appwindow):
    """
    This namespace is for interacting with the Exports window.
    """
    __open__ = staticmethod(idaapi.open_exports_window)
    __open_defaults__ = (idaapi.BADADDR, )

class frame(appwindow):
    """
    This namespace is for interacting with the (Function) Frame window.
    """
    __open__ = staticmethod(idaapi.open_frame_window)
    __open_defaults__ = (idaapi.BADADDR, )

class functions(appwindow):
    """
    This namespace is for interacting with the Functions window.
    """
    __open__ = staticmethod(idaapi.open_funcs_window)
    __open_defaults__ = (idaapi.BADADDR, )

class imports(appwindow):
    """
    This namespace is for interacting with the Imports window.
    """
    __open__ = staticmethod(idaapi.open_imports_window)
    __open_defaults__ = (idaapi.BADADDR, )

class libraries(appwindow):
    """
    This namespace is for interacting with the (Type) Libraries window.
    """
    __open__ = staticmethod(idaapi.open_tils_window)
    __open_defaults__ = (idaapi.BADADDR, )
tils = typelibraries = libraries

class modules(appwindow):
    """
    This namespace is for interacting with the Modules window.
    """
    __open__ = staticmethod(idaapi.open_modules_window)
    __open_defaults__ = (idaapi.BADADDR, )

class names(appwindow):
    """
    This namespace is for interacting with the Names window.
    """
    __open__ = staticmethod(idaapi.open_names_window)
    __open_defaults__ = (idaapi.BADADDR, )

    @classmethod
    def refresh(cls):
        '''Refresh the names list.'''
        return idaapi.refresh_lists() if idaapi.__version__ < 7.0 else idaapi.refresh_choosers()
    @classmethod
    def size(cls):
        '''Return the number of elements in the names list.'''
        return idaapi.get_nlist_size()
    @classmethod
    def contains(cls, ea):
        '''Return whether the address `ea` is referenced in the names list.'''
        return idaapi.is_in_nlist(ea)
    @classmethod
    def search(cls, ea):
        '''Return the index of the address `ea` in the names list.'''
        return idaapi.get_nlist_idx(ea)

    @classmethod
    def at(cls, index):
        '''Return the address and the symbol name of the specified `index`.'''
        ea, name = idaapi.get_nlist_ea(index), idaapi.get_nlist_name(index)
        return ea, internal.utils.string.of(name)
    @classmethod
    def name(cls, index):
        '''Return the name at the specified `index`.'''
        res = idaapi.get_nlist_name(index)
        return internal.utils.string.of(res)
    @classmethod
    def ea(cls, index):
        '''Return the address at the specified `index`.'''
        return idaapi.get_nlist_ea(index)

    @classmethod
    def iterate(cls):
        '''Iterate through all of the address and symbols in the names list.'''
        for idx in range(cls.size()):
            yield cls.at(idx)
        return

class notepad(appwindow):
    """
    This namespace is for interacting with the Notepad window.
    """
    __open__ = staticmethod(idaapi.open_notepad_window)
    __open_defaults__ = ()

    @classmethod
    def open(cls, *args):
        '''Open or show the notepad window and return its UI widget that can be used to modify it.'''
        widget = super(notepad, cls).open(*args)
        if isinstance(widget, PyQt5.QtWidgets.QPlainTextEdit):
            return widget

        elif hasattr(idaapi, 'is_idaq') and not idaapi.is_idaq():
            if not widget:
                raise internal.exceptions.UnsupportedCapability(u"{:s}.open({!s}) : Unable to open or interact with the notepad window when not running the Qt user-interface.".format('.'.join([__name__, cls.__name__]), ', '.join(map(internal.utils.string.repr, args))))
            return widget

        # We're running the PyQt UI, so we need to descend until we get to the text widget.
        children = (item for item in widget.children() if isinstance(item, PyQt5.QtWidgets.QPlainTextEdit))
        result = builtins.next(children, None)
        if result is None:
            raise internal.exceptions.ItemNotFoundError(u"{:s}.open({!s}) : Unable to locate the QtWidgets.QPlainTextEdit widget.".format('.'.join([__name__, cls.__name__]), ', '.join(map(internal.utils.string.repr, args))))
        return result

    @classmethod
    def close(cls):
        '''Close or hide the notepad window.'''
        editor = cls.open()
        widget = editor.parent()
        return widget.deleteLater()

    @classmethod
    def get(cls):
        '''Return the string that is currently stored within the notepad window.'''
        editor = cls.open()
        return editor.toPlainText()

    @classmethod
    def count(cls):
        '''Return the number of lines that are currently stored within the notepad window.'''
        editor = cls.open()
        result = editor.toPlainText()
        return result.count('\n') + (0 if result.endswith('\n') else 1)

    @classmethod
    def size(cls):
        '''Return the number of characters that are currently stored within the notepad window.'''
        editor = cls.open()
        result = editor.toPlainText()
        return len(result)

    @internal.utils.multicase(string=six.string_types)
    @classmethod
    def set(cls, string):
        '''Set the text that is currently stored within the notepad window to `string`.'''
        editor = cls.open()
        result, none = editor.toPlainText(), editor.setPlainText(string)
        return result

    @internal.utils.multicase(items=(builtins.list, builtins.tuple))
    @classmethod
    def set(cls, items):
        '''Set each line that is currently stored within the notepad window to `items`.'''
        return cls.set('\n'.join(items))

    @internal.utils.multicase(string=six.string_types)
    @classmethod
    def append(cls, string):
        '''Append the provided `string` to the current text that is stored within the notepad window.'''
        editor = cls.open()
        result, none = editor.toPlainText(), editor.appendPlainText(string)
        return result.count('\n') + (0 if result.endswith('\n') else 1)

    @internal.utils.multicase()
    @classmethod
    def cursor(cls):
        '''Return the ``QtGui.QTextCursor`` used by the notepad window.'''
        editor = cls.open()
        return editor.textCursor()

    @internal.utils.multicase()
    @classmethod
    def cursor(cls, cursor):
        '''Set the ``QtGui.QTextCursor`` for the notepad window to `cursor`.'''
        editor = cls.open()
        return editor.setTextCursor(cursor)

class problems(appwindow):
    """
    This namespace is for interacting with the Problems window.
    """
    __open__ = staticmethod(idaapi.open_problems_window)
    __open_defaults__ = (idaapi.BADADDR, )

class references(appwindow):
    """
    This namespace is for interacting with the Cross-References window.
    """
    __open__ = staticmethod(idaapi.open_xrefs_window)
    __open_defaults__ = (idaapi.BADADDR, )
xrefs = references

class segments(appwindow):
    """
    This namespace is for interacting with the Segments window.
    """
    __open__ = staticmethod(idaapi.open_segments_window)
    __open_defaults__ = (idaapi.BADADDR, )

class segmentregisters(appwindow):
    """
    This namespace is for interacting with the Segments window.
    """
    __open__ = staticmethod(idaapi.open_segments_window)
    __open_defaults__ = (idaapi.BADADDR, )
segregs = segmentregisters

class selectors(appwindow):
    """
    This namespace is for interacting with the Selectors window.
    """
    __open__ = staticmethod(idaapi.open_selectors_window)
    __open_defaults__ = (idaapi.BADADDR, )

class signatures(appwindow):
    """
    This namespace is for interacting with the Signatures window.
    """
    __open__ = staticmethod(idaapi.open_signatures_window)
    __open_defaults__ = (idaapi.BADADDR, )

class stack(appwindow):
    """
    This namespace is for interacting with the (Call) Stack window.
    """
    __open__ = staticmethod(idaapi.open_stack_window)
    __open_defaults__ = (idaapi.BADADDR, )
callstack = stack

class strings(appwindow):
    """
    This namespace is for interacting with the Strings window.
    """
    __open__ = staticmethod(idaapi.open_strings_window)
    __open_defaults__ = (idaapi.BADADDR, idaapi.BADADDR, idaapi.BADADDR)

    @classmethod
    def __on_openidb__(cls, code, is_old_database):
        if code != idaapi.NW_OPENIDB or is_old_database:
            raise internal.exceptions.InvalidParameterError(u"{:s}.__on_openidb__({:#x}, {:b}) : Hook was called with an unexpected code or an old database.".format('.'.join([__name__, cls.__name__]), code, is_old_database))
        config = idaapi.strwinsetup_t()
        config.minlen = 3
        config.ea1, config.ea2 = idaapi.cvar.inf.minEA, idaapi.cvar.inf.maxEA
        config.display_only_existing_strings = True
        config.only_7bit = True
        config.ignore_heads = False

        # aggregate all the string types for IDA 6.95x
        if idaapi.__version__ < 7.0:
            res = [idaapi.ASCSTR_TERMCHR, idaapi.ASCSTR_PASCAL, idaapi.ASCSTR_LEN2, idaapi.ASCSTR_UNICODE, idaapi.ASCSTR_LEN4, idaapi.ASCSTR_ULEN2, idaapi.ASCSTR_ULEN4]

        # otherwise use IDA 7.x's naming scheme
        else:
            res = [idaapi.STRTYPE_TERMCHR, idaapi.STRTYPE_PASCAL, idaapi.STRTYPE_LEN2, idaapi.STRTYPE_C_16, idaapi.STRTYPE_LEN4, idaapi.STRTYPE_LEN2_16, idaapi.STRTYPE_LEN4_16]

        config.strtypes = functools.reduce(lambda result, item: result | pow(2, item), res, 0)
        if not idaapi.set_strlist_options(config):
            raise internal.exceptions.DisassemblerError(u"{:s}.__on_openidb__({:#x}, {:b}) : Unable to set the default options for the string list.".format('.'.join([__name__, cls.__name__]), code, is_old_database))
        return
        #assert idaapi.build_strlist(config.ea1, config.ea2), "{:#x}:{:#x}".format(config.ea1, config.ea2)

    @classmethod
    def refresh(cls):
        '''Refresh the strings list.'''
        return idaapi.refresh_lists() if idaapi.__version__ < 7.0 else idaapi.refresh_choosers()
    @classmethod
    def size(cls):
        '''Return the number of items available in the strings list.'''
        return idaapi.get_strlist_qty()
    @classmethod
    def at(cls, index):
        '''Return the ``idaapi.string_info_t`` for the specified `index` in the strings list.'''
        si = idaapi.string_info_t()
        if not idaapi.get_strlist_item(si, index):
            raise internal.exceptions.DisassemblerError(u"{:s}.at({:d}) : The call to `idaapi.get_strlist_item({:d})` did not return successfully.".format('.'.join([__name__, cls.__name__]), index, index))
        return si
    @classmethod
    def get(cls, index):
        '''Return the address and its bytes representing the string at the specified `index`.'''
        si = cls.at(index)
        get_contents = idaapi.get_strlit_contents if hasattr(idaapi, 'get_strlit_contents') else idaapi.get_ascii_contents
        string = get_contents(si.ea, si.length, si.type)
        return si.ea, internal.utils.string.of(string)
    @classmethod
    def __iterate__(cls):
        '''Iterate through all of the items in the strings list yielding the `(index, address, bytes)`.'''
        for index in range(cls.size()):
            ea, item = cls.get(index)
            yield index, ea, item
        return
    @classmethod
    def iterate(cls):
        '''Iterate through all of the addresses and items in the strings list.'''
        for _, ea, item in cls.__iterate__():
            yield ea, item
        return

class structures(appwindow):
    """
    This namespace is for interacting with the Structures window.
    """
    __open__ = staticmethod(idaapi.open_structs_window)
    __open_defaults__ = (idaapi.BADADDR, 0)

class threads(appwindow):
    """
    This namespace is for interacting with the Threads window.
    """
    __open__ = staticmethod(idaapi.open_threads_window)
    __open_defaults__ = (idaapi.BADADDR, )

class tracing(appwindow):
    """
    This namespace is for interacting with the Tracing window.
    """
    __open__ = staticmethod(idaapi.open_trace_window)
    __open_defaults__ = (idaapi.BADADDR, )
trace = tracing

class types(appwindow):
    """
    This namespace is for interacting with the Types window.
    """
    __open__ = staticmethod(idaapi.open_loctypes_window)
    __open_defaults__ = (idaapi.BADADDR, )

class timer(object):
    """
    This namespace is for registering a python callable to a timer in IDA.
    """
    clock = {}
    @classmethod
    def register(cls, id, interval, callable):
        '''Register the specified `callable` with the requested `id` to be called at every `interval`.'''
        if id in cls.clock:
            idaapi.unregister_timer(cls.clock[id])

        # XXX: need to create a closure that can terminate when signalled
        cls.clock[id] = res = idaapi.register_timer(interval, callable)
        return res
    @classmethod
    def unregister(cls, id):
        '''Unregister the specified `id`.'''
        raise internal.exceptions.UnsupportedCapability(u"{:s}.unregister({!s}) : A lock or a signal is needed here in order to unregister this timer safely.".format('.'.join([__name__, cls.__name__]), id))
        idaapi.unregister_timer(cls.clock[id])
        del(cls.clock[id])
    @classmethod
    def reset(cls):
        '''Remove all the registered timers.'''
        for id, clk in cls.clock.items():
            idaapi.unregister_timer(clk)
            del(cls.clock[id])
        return

### updating the state of the colored navigation band
class navigation(object):
    """
    This namespace is for updating the state of the colored navigation band.
    """
    if all(not hasattr(idaapi, name) for name in ['show_addr', 'showAddr']):
        __set__ = staticmethod(lambda ea: None)
    else:
        __set__ = staticmethod(idaapi.showAddr if idaapi.__version__ < 7.0 else idaapi.show_addr)

    if all(not hasattr(idaapi, name) for name in ['show_auto', 'showAuto']):
        __auto__ = staticmethod(lambda ea, t: None)
    else:
        __auto__ = staticmethod(idaapi.showAuto if idaapi.__version__ < 7.0 else idaapi.show_auto)

    @classmethod
    def set(cls, ea):
        '''Set the auto-analysis address on the navigation bar to `ea`.'''
        result, _ = ea, cls.__set__(ea)
        return result

    @classmethod
    def auto(cls, ea, **type):
        """Set the auto-analysis address and type on the navigation bar to `ea`.

        If `type` is specified, then update using the specified auto-analysis type.
        """
        result, _ = ea, cls.__auto__(ea, type.get('type', idaapi.AU_NONE))
        return result

    @classmethod
    def unknown(cls, ea): return cls.auto(ea, type=idaapi.AU_UNK)
    @classmethod
    def code(cls, ea): return cls.auto(ea, type=idaapi.AU_CODE)
    @classmethod
    def weak(cls, ea): return cls.auto(ea, type=idaapi.AU_WEAK)
    @classmethod
    def procedure(cls, ea): return cls.auto(ea, type=idaapi.AU_PROC)
    @classmethod
    def tail(cls, ea): return cls.auto(ea, type=idaapi.AU_TAIL)
    @classmethod
    def stackpointer(cls, ea): return cls.auto(ea, type=idaapi.AU_TRSP)
    @classmethod
    def analyze(cls, ea): return cls.auto(ea, type=idaapi.AU_USED)
    @classmethod
    def type(cls, ea): return cls.auto(ea, type=idaapi.AU_TYPE)
    @classmethod
    def signature(cls, ea): return cls.auto(ea, type=idaapi.AU_LIBF)
    @classmethod
    def final(cls, ea): return cls.auto(ea, type=idaapi.AU_FINAL)

### interfacing with IDA's menu system
# FIXME: add some support for actually manipulating menus
class menu(object):
    """
    This namespace is for registering items in IDA's menu system.
    """
    state = {}
    @classmethod
    def add(cls, path, name, callable, hotkey='', flags=0, args=()):
        '''Register a `callable` as a menu item at the specified `path` with the provided `name`.'''

        # check to see if our menu item is in our cache and remove it if so
        if (path, name) in cls.state:
            cls.rm(path, name)

        # now we can add the menu item since everything is ok
        # XXX: I'm not sure if the path needs to be utf8 encoded or not
        res = internal.utils.string.to(name)
        ctx = idaapi.add_menu_item(path, res, hotkey, flags, callable, args)
        cls.state[path, name] = ctx
    @classmethod
    def rm(cls, path, name):
        '''Remove the menu item at the specified `path` with the provided `name`.'''
        res = cls.state[path, name]
        idaapi.del_menu_item(res)
        del cls.state[path, name]
    @classmethod
    def reset(cls):
        '''Remove all currently registered menu items.'''
        for path, name in cls.state.keys():
            cls.rm(path, name)
        return

### Qt wrappers and namespaces
class window(object):
    """
    This namespace is for interacting with a specific window.
    """
    def __new__(cls):
        '''Return the currently active window.'''
        # FIXME: should probably traverse the application windows to figure out the
        #        exact one that is in use so that we can cast it to a QWindow.
        return application.window()

    @internal.utils.multicase(xy=tuple)
    def at(cls, xy):
        '''Return the widget at the specified (`x`, `y`) coordinate within the `xy` tuple.'''
        x, y = xy
        return application.window(x, y)

class windows(object):
    """
    This namespace is for interacting with any or all of the windows for the application.
    """
    def __new__(cls):
        '''Return all of the top-level windows.'''
        return application.windows()

    @classmethod
    def refresh(cls):
        '''Refresh all of lists and choosers within the application.'''
        global disassembly
        ok = idaapi.refresh_lists() if idaapi.__version__ < 7.0 else idaapi.refresh_choosers()
        return ok and disassembly.refresh()
refresh = internal.utils.alias(windows.refresh, 'windows')

class widget(object):
    """
    This namespace is for interacting with any of the widgets
    associated with the native user-interface.
    """
    @internal.utils.multicase()
    def __new__(cls):
        '''Return the widget that is currently being used.'''
        return cls.of(current.widget())
    @internal.utils.multicase(xy=tuple)
    def __new__(cls, xy):
        '''Return the widget at the specified (`x`, `y`) coordinate within the `xy` tuple.'''
        res = x, y = xy
        return cls.at(res)
    @internal.utils.multicase(title=six.string_types)
    def __new__(cls, title):
        '''Return the widget that is using the specified `title`.'''
        return cls.by(title)

    @classmethod
    def at(cls, xy):
        '''Return the widget at the specified (`x`, `y`) coordinate within the `xy` tuple.'''
        res = x, y = xy
        global application
        q = application()
        return q.widgetAt(x, y)

    @classmethod
    def open(cls, widget, flags, **target):
        '''Open the `widget` using the specified ``idaapi.WOPN_`` flags.'''
        twidget = cls.form(widget) if cls.isinstance(widget) else widget
        ok = idaapi.display_widget(twidget, flags)
        # FIXME: rather than returning whether it succeeded or not, we should
        #        return what the widget was attached to in order to locate it.
        return ok
    @classmethod
    def close(cls, widget, flags):
        '''Close the `widget` using the specified ``idaapi.WCLS_`` flags.'''
        twidget = cls.form(widget) if cls.isinstance(widget) else widget
        ok = idaapi.close_widget(twidget, flags)
        # FIXME: rather than returning whether it succeeded or not, we should
        #        return what the widget was attached to before we closed it.
        return ok

    @classmethod
    def show(cls, widget):
        '''Display the specified `widget` without putting it in focus.'''
        twidget = cls.form(widget) if cls.isinstance(widget) else widget
        res, ok = idaapi.get_current_widget(), idaapi.activate_widget(twidget, False)
        return cls.of(res) if ok else None
    @classmethod
    def focus(cls, widget):
        '''Activate the specified `widget` and put it in focus.'''
        twidget = cls.form(widget) if cls.isinstance(widget) else widget
        res, ok = idaapi.get_current_widget(), idaapi.activate_widget(twidget, True)
        return cls.of(res) if ok else None

    @classmethod
    def type(cls, widget):
        '''Return the ``idaapi.twidget_type_t`` for the given `widget`.'''
        twidget = cls.form(widget) if cls.isinstance(widget) else widget
        return idaapi.get_widget_type(twidget)
    @classmethod
    def title(cls, widget):
        '''Return the window title for the given `widget`.'''
        twidget = cls.form(widget) if cls.isinstance(widget) else widget
        return idaapi.get_widget_title(twidget)

    @internal.utils.multicase(title=six.string_types)
    @classmethod
    @internal.utils.string.decorate_arguments('title')
    def by(cls, title):
        '''Return the widget associated with the given window `title`.'''
        res = idaapi.find_widget(internal.utils.string.to(title))
        if res is None:
            raise internal.exceptions.ItemNotFoundError(u"{:s}.by({!r}) : Unable to locate a widget with the specified title ({!r}).".format('.'.join([__name__, cls.__name__]), title, title))
        return cls.of(res)

    @classmethod
    def of(cls, form):
        '''Return the UI widget for the IDA `form` that is provided.'''
        if hasattr(idaapi, 'is_idaq') and not idaapi.is_idaq():
            return form
        raise internal.exceptions.MissingMethodError
    @classmethod
    def form(cls, widget):
        '''Return the IDA form for the UI `widget` that is provided.'''
        if hasattr(idaapi, 'is_idaq') and not idaapi.is_idaq():
            return widget
        raise internal.exceptions.MissingMethodError
    @classmethod
    def isinstance(cls, object):
        '''Return whether the given `object` is of the correct type for the UI.'''
        if hasattr(idaapi, 'is_idaq') and not idaapi.is_idaq():
            return True
        raise internal.exceptions.MissingMethodError

class clipboard(object):
    """
    This namespace is for interacting with the current clipboard state.
    """
    def __new__(cls):
        '''Return the current clipboard.'''
        global application
        clp = application()
        return clp.clipboard()

class mouse(object):
    """
    Base namespace for interacting with the mouse input.
    """
    @classmethod
    def buttons(cls):
        '''Return the current mouse buttons that are being clicked.'''
        global application
        q = application()
        return q.mouseButtons()

    @classmethod
    def position(cls):
        '''Return the current `(x, y)` position of the cursor.'''
        raise internal.exceptions.MissingMethodError

class keyboard(object):
    """
    Base namespace for interacting with the keyboard input.
    """
    @classmethod
    def modifiers(cls):
        '''Return the current keyboard modifiers that are being used.'''
        global application
        q = application()
        return q.keyboardModifiers()

    @classmethod
    def __of_key__(cls, key):
        '''Convert the normalized hotkey tuple in `key` into a format that IDA can comprehend.'''
        Separators = {'-', '+'}
        Modifiers = {'ctrl', 'shift', 'alt'}

        # Validate the type of our parameter
        if not isinstance(key, tuple):
            raise internal.exceptions.InvalidParameterError(u"{:s}.of_key({!r}) : A key combination of an invalid type was provided as a parameter.".format('.'.join([__name__, cls.__name__]), key))

        # Find a separator that we can use, and use it to join our tuple into a
        # string with each element capitalized. That way it looks good for the user.
        separator = next(item for item in Separators)
        modifiers, hotkey = key

        components = [item.capitalize() for item in modifiers] + [hotkey.capitalize()]
        return separator.join(components)

    @classmethod
    def __normalize_key__(cls, hotkey):
        '''Normalize the string `key` to a tuple that can be used to lookup keymappings.'''
        Separators = {'-', '+', '_'}
        Modifiers = {'ctrl', 'shift', 'alt'}

        # First check to see if we were given a tuple or list. If so, then we might
        # have been given a valid hotkey. However, we still need to validate this.
        # So, to do that we'll concatenate each component together back into a string
        # and then recurse so we can validate using the same logic.
        if isinstance(hotkey, (tuple, list, set)):
            try:
                # If we were mistakenly given a set, then we need to reformat it.
                if isinstance(hotkey, set):
                    raise ValueError

                modifiers, key = hotkey

                # If modifiers is not of the correct type, then still need to reformat.
                if not isinstance(modifiers, (tuple, list, set)):
                    raise ValueError

            # If the tuple we received was of an invalid format, then extract the
            # modifiers that we can from it, and try again.
            except ValueError:
                modifiers = tuple(item for item in hotkey if item.lower() in Modifiers)
                key = ''.join(item for item in hotkey if item.lower() not in Modifiers)

            # Grab a separator, and join all our components together with it.
            separator = next(item for item in Separators)
            components = [item for item in modifiers] + [key]
            return cls.__normalize_key__(separator.join(components))

        # Next we need to normalize the separator used throughout the string by
        # simply converting any characters we might consider a separator into
        # a null-byte so we can split on it.
        normalized = functools.reduce(lambda agg, item: agg.replace(item, '\0'), Separators, hotkey)

        # Now we can split the normalized string so we can convert it into a
        # set. We will then iterate through this set collecting all of our known
        # key modifiers. Anything left must be a single key, so we can then
        # validate the hotkey we were given.
        components = { item.lower() for item in normalized.split('\0') }

        modifiers = { item for item in components if item in Modifiers }
        key = components ^ modifiers

        # Now we need to verify that we were given just one key. If we were
        # given any more, then this isn't a valid hotkey combination and we need
        # to bitch about it.
        if len(key) != 1:
            raise internal.exceptions.InvalidParameterError(u"{:s}.normalize_key({!s}) : An invalid hotkey combination ({!s}) was provided as a parameter.".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(hotkey), internal.utils.string.repr(hotkey)))

        res = next(item for item in key)
        if len(res) != 1:
            raise internal.exceptions.InvalidParameterError(u"{:s}.normalize_key({!s}) : The hotkey combination {!s} contains the wrong number of keys ({:d}).".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(hotkey), internal.utils.string.repr(res), len(res)))

        # That was it. Now to do the actual normalization, we need to sort our
        # modifiers into a tuple, and return the single hotkey that we extracted.
        res, = key
        return tuple(sorted(modifiers)), res

    # Create a cache to store the hotkey context, and the callable that was mapped to it
    __cache__ = {}

    @classmethod
    def list(cls):
        '''Display the current list of keyboard combinations that are mapped along with the callable each one is attached to.'''
        maxkey, maxtype, maxinfo = 0, 0, 0

        results = []
        for mapping, (capsule, closure) in cls.__cache__.items():
            key = cls.__of_key__(mapping)

            # Check if we were passed a class so we can figure out how to
            # extract the signature.
            cons = ['__init__', '__new__']
            if inspect.isclass(closure):
                available = (item for item in cons if hasattr(closure, item))
                attribute = next((item for item in available if inspect.ismethod(getattr(closure, item))), None)
                callable = getattr(closure, attribute) if attribute else None
                information = '.'.join([closure.__name__, internal.utils.multicase.prototype(callable)]) if attribute else "{:s}(...)".format(closure.__name__)
            else:
                information = internal.utils.multicase.prototype(closure)

            # Figure out the type of the callable that is mapped.
            if inspect.isclass(closure):
                ftype = 'class'
            elif inspect.ismethod(closure):
                ftype = 'method'
            elif inspect.isbuiltin(closure):
                ftype = 'builtin'
            elif inspect.isfunction(closure):
                ftype = 'anonymous' if closure.__name__ in {'<lambda>'} else 'function'
            else:
                ftype = 'callable'

            # Figure out if there's any class-information associated with the closure
            if inspect.ismethod(closure):
                klass = closure.im_self.__class__ if closure.im_self else closure.im_class
                clsinfo = klass.__name__ if getattr(klass, '__module__', '__main__') in {'__main__'} else '.'.join([klass.__module__, klass.__name__])
            elif inspect.isclass(closure) or isinstance(closure, object):
                clsinfo = '' if getattr(closure, '__module__', '__main__') in {'__main__'} else closure.__module__
            else:
                clsinfo = None if getattr(closure, '__module__', '__main__') in {'__main__'} else closure.__module__

            # Now we can figure out the documentation for the closure that was stored.
            documentation = closure.__doc__ or ''
            if documentation:
                filtered = [item.strip() for item in documentation.split('\n') if item.strip()]
                header = next((item for item in filtered), '')
                comment = "{:s}...".format(header) if header and len(filtered) > 1 else header
            else:
                comment = ''

            # Calculate our maximum column widths inline
            maxkey = max(maxkey, len(key))
            maxinfo = max(maxinfo, len('.'.join([clsinfo, information]) if clsinfo else information))
            maxtype = max(maxtype, len(ftype))

            # Append each column to our results
            results.append((key, ftype, clsinfo, information, comment))

        # If we didn't aggregate any results, then raise an exception as there's nothing to do.
        if not results:
            raise internal.exceptions.SearchResultsError(u"{:s}.list() : Found 0 key combinations mapped.".format('.'.join([__name__, cls.__name__])))

        # Now we can output what was mapped to the user.
        six.print_(u"Found the following{:s} key combination{:s}:".format(" {:d}".format(len(results)) if len(results) > 1 else '', '' if len(results) == 1 else 's'))
        for key, ftype, clsinfo, info, comment in results:
            six.print_(u"Key: {:>{:d}s} -> {:<{:d}s}{:s}".format(key, maxkey, "{:s}:{:s}".format(ftype, '.'.join([clsinfo, info]) if clsinfo else info), maxtype + 1 + maxinfo, " // {:s}".format(comment) if comment else ''))
        return

    @classmethod
    def map(cls, key, callable):
        """Map the specified `key` combination to a python `callable` in IDA.

        If the provided `key` is being re-mapped due to the mapping already existing, then return the previous callable that it was assigned to.
        """

        # First we'll normalize the hotkey that we were given, and convert it
        # back into a format that IDA can understand. This way we can prevent
        # users from giving us a sloppy hotkey combination that we won't be
        # able to search for in our cache.
        hotkey = cls.__normalize_key__(key)
        keystring = cls.__of_key__(hotkey)

        # The hotkey we normalized is now a tuple, so check to see if it's
        # already within our cache. If it is, then we need to unmap it prior to
        # re-creating the mapping.
        if hotkey in cls.__cache__:
            logging.warning(u"{:s}.map({!s}, {!r}) : Remapping the hotkey combination {!s} with the callable {!r}.".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(key), callable, internal.utils.string.repr(keystring), callable))
            ctx, _ = cls.__cache__[hotkey]

            ok = idaapi.del_hotkey(ctx)
            if not ok:
                raise internal.exceptions.DisassemblerError(u"{:s}.map({!s}, {!r}) : Unable to remove the hotkey combination {!s} from the list of current keyboard mappings.".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(key), callable, internal.utils.string.repr(keystring)))

            # Pop the callable that was mapped out of the cache so that we can
            # return it to the user.
            _, res = cls.__cache__.pop(hotkey)

        # If the user is mapping a new key, then there's no callable to return.
        else:
            res = None

        # Verify that the user gave us a callable to use to avoid mapping a
        # useless type to the specified keyboard combination.
        if not builtins.callable(callable):
            raise internal.exceptions.InvalidTypeOrValueError(u"{:s}.map({!s}, {!r}) : Unable to map the non-callable value {!r} to the hotkey combination {!s}.".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(key), callable, callable, internal.utils.string.repr(keystring)))

        # Define a closure that calls the user's callable as it seems that IDA's
        # hotkey functionality doesn't deal too well when the same callable is
        # mapped to different hotkeys.
        def closure(*args, **kwargs):
            return callable(*args, **kwargs)

        # Now we can add the hotkey to IDA using the closure that we generated.
        # XXX: I'm not sure if the key needs to be utf8 encoded or not
        ctx = idaapi.add_hotkey(keystring, closure)
        if not ctx:
            raise internal.exceptions.DisassemblerError(u"{:s}.map({!s}, {!r}) : Unable to map the callable {!r} to the hotkey combination {!s}.".format('.'.join([__name__, cls.__name__]), internal.utils.string.repr(key), callable, callable, internal.utils.string.repr(keystring)))

        # Last thing to do is to stash it in our cache with the user's callable
        # in order to keep track of it for removal.
        cls.__cache__[hotkey] = ctx, callable
        return res

    @classmethod
    def unmap(cls, key):
        '''Unmap the specified `key` from IDA and return the callable that it was assigned to.'''
        frepr = lambda hotkey: internal.utils.string.repr(cls.__of_key__(hotkey))

        # First check to see whether we were given a callable or a hotkey. If
        # we were given a callable, then we need to look through our cache for
        # the actual key that it was. Once found, then we normalize it like usual.
        if callable(key):
            try:
                hotkey = cls.__normalize_key__(next(item for item, (_, fcallback) in cls.__cache__.items() if fcallback == key))

            except StopIteration:
                raise internal.exceptions.InvalidParameterError(u"{:s}.unmap({:s}) : Unable to locate the callable {!r} in the current list of keyboard mappings.".format('.'.join([__name__, cls.__name__]), "{!r}".format(key) if callable(key) else "{!s}".format(internal.utils.string.repr(key)), key))

            else:
                logging.warning(u"{:s}.unmap({:s}) : Discovered the hotkey {!s} being currently mapped to the callable {!r}.".format('.'.join([__name__, cls.__name__]), "{!r}".format(key) if callable(key) else "{!s}".format(internal.utils.string.repr(key)), frepr(hotkey), key))

        # We need to normalize the hotkey we were given, and convert it back
        # into IDA's format. This way we can locate it in our cache, and prevent
        # sloppy user input from interfering.
        else:
            hotkey = cls.__normalize_key__(key)

        # Check to see if the hotkey is cached and warn the user if it isn't.
        if hotkey not in cls.__cache__:
            logging.warning(u"{:s}.unmap({:s}) : Refusing to unmap the hotkey {!s} as it is not currently mapped to anything.".format('.'.join([__name__, cls.__name__]), "{!r}".format(key) if callable(key) else "{!s}".format(internal.utils.string.repr(key)), frepr(hotkey)))
            return

        # Grab the keymapping context from our cache, and then ask IDA to remove
        # it for us. If we weren't successful, then raise an exception so the
        # user knows what's up.
        ctx, _ = cls.__cache__[hotkey]
        ok = idaapi.del_hotkey(ctx)
        if not ok:
            raise internal.exceptions.DisassemblerError(u"{:s}.unmap({:s}) : Unable to unmap the specified hotkey ({!s}) from the current list of keyboard mappings.".format('.'.join([__name__, cls.__name__]), "{!r}".format(key) if callable(key) else "{!s}".format(internal.utils.string.repr(key)), frepr(hotkey)))

        # Now we can pop off the callable that was mapped to the hotkey context
        # in order to return it, and remove the hotkey from our cache.
        _, res = cls.__cache__.pop(hotkey)
        return res

    add, rm = internal.utils.alias(map, 'keyboard'), internal.utils.alias(unmap, 'keyboard')

    @classmethod
    def input(cls):
        '''Return the current keyboard input context.'''
        raise internal.exceptions.MissingMethodError

### PyQt5-specific functions and namespaces
## these can overwrite any of the classes defined above
try:
    import PyQt5.Qt
    from PyQt5.Qt import QObject, QWidget

    class application(application):
        """
        This namespace is for getting information about the application user-interface
        that is based on PyQt.
        """
        def __new__(cls):
            '''Return the current instance of the PyQt Application.'''
            q = PyQt5.Qt.qApp
            return q.instance()

        @internal.utils.multicase()
        @classmethod
        def window(cls):
            '''Return the active main window for the PyQt application.'''
            q = cls()
            widgets = q.topLevelWidgets()
            return next(widget for widget in widgets if isinstance(widget, PyQt5.QtWidgets.QMainWindow))
        @internal.utils.multicase(x=six.integer_types, y=six.integer_types)
        @classmethod
        def window(cls, x, y):
            '''Return the window at the specified `x` and `y` coordinate.'''
            q = cls()
            return q.topLevelAt(x, y)

        @classmethod
        def windows(cls):
            '''Return all of the available windows for the application.'''
            q = cls()
            return q.topLevelWindows()

    class mouse(mouse):
        """
        This namespace is for interacting with the mouse input.
        """
        @classmethod
        def position(cls):
            '''Return the current `(x, y)` position of the cursor.'''
            qt = PyQt5.QtGui.QCursor
            res = qt.pos()
            return res.x(), res.y()

    class keyboard(keyboard):
        """
        This namespace is for interacting with the keyboard input.
        """
        @classmethod
        def input(cls):
            '''Return the current keyboard input context.'''
            raise internal.exceptions.MissingMethodError

    class UIProgress(object):
        """
        Helper class used to simplify the showing of a progress bar in IDA's UI.
        """
        timeout = 5.0

        def __init__(self, blocking=True):
            self.object = res = PyQt5.Qt.QProgressDialog()
            res.setVisible(False)
            res.setWindowModality(blocking)
            res.setAutoClose(True)

            self.__evrunning = event = threading.Event()
            res.canceled.connect(event.set)

            pwd = _database.config.path() or os.getcwd()
            path = os.path.join(pwd, _database.config.filename()) if _database.config.filename() else pwd

            self.update(current=0, min=0, max=0, text=u'Processing...', tooltip=u'...', title=path)

        # properties
        canceled = property(fget=lambda self: self.object.wasCanceled(), fset=lambda self, value: self.object.canceled.connect(value))
        maximum = property(fget=lambda self: self.object.maximum())
        minimum = property(fget=lambda self: self.object.minimum())
        current = property(fget=lambda self: self.object.value())

        @property
        def canceled(self):
            return self.__evrunning.is_set()
        @canceled.setter
        def canceled(self, set):
            event = self.__evrunning
            event.set() if set else event.clear()

        # methods
        def open(self, width=0.8, height=0.1):
            '''Open a progress bar with the specified `width` and `height` relative to the dimensions of IDA's window.'''
            cls, app = self.__class__, application()

            # XXX: spin for a second until main is defined because IDA seems to be racy with this api
            ts, main = time.time(), getattr(self, '__appwindow__', None)
            while time.time() - ts < self.timeout and main is None:
                _, main = app.processEvents(), application.window()

            if main is None:
                logging.warning(u"{:s}.open({!s}, {!s}) : Unable to find main application window. Falling back to default screen dimensions to calculate size.".format('.'.join([__name__, cls.__name__]), width, height))

            # figure out the dimensions of the window
            if main is None:
                # if there's no window, then assume some screen dimensions
                w, h = 1024, 768
            else:
                w, h = main.width(), main.height()

            # now we can calculate the dimensions of the progress bar
            logging.info(u"{:s}.open({!s}, {!s}) : Using dimensions ({:d}, {:d}) for progress bar.".format('.'.join([__name__, cls.__name__]), width, height, int(w*width), int(h*height)))
            fixedWidth, fixedHeight = map(math.trunc, [w * width, h * height])
            self.object.setFixedWidth(fixedWidth), self.object.setFixedHeight(fixedHeight)

            # calculate the center
            if main is None:
                # no window, so use the center of the screen
                cx, cy = w * 0.5, h * 0.5
            else:
                center = main.geometry().center()
                cx, cy = center.x(), center.y()

            # ...and center it.
            x, y = map(math.trunc, [cx - (w * width * 0.5), cy - (h * height * 1.0)])
            logging.info(u"{:s}.open({!s}, {!s}) : Centering progress bar at ({:d}, {:d}).".format('.'.join([__name__, cls.__name__]), width, height, int(x), int(y)))
            self.object.move(x, y)

            # now everything should look good.
            self.object.show(), app.processEvents()

        def close(self):
            '''Close the current progress bar.'''
            event, app = self.__evrunning, application()
            self.object.canceled.disconnect(event.set)
            self.object.close(), app.processEvents()

        def update(self, **options):
            '''Update the current state of the progress bar.'''
            application().processEvents()

            minimum, maximum = options.get('min', None), options.get('max', None)
            text, title, tooltip = (options.get(item, None) for item in ['text', 'title', 'tooltip'])

            if minimum is not None:
                self.object.setMinimum(minimum)
            if maximum is not None:
                self.object.setMaximum(maximum)
            if title is not None:
                self.object.setWindowTitle(internal.utils.string.to(title))
            if tooltip is not None:
                self.object.setToolTip(internal.utils.string.to(tooltip))
            if text is not None:
                self.object.setLabelText(internal.utils.string.to(text))

            res = self.object.value()
            if 'current' in options:
                self.object.setValue(options['current'])
            elif 'value' in options:
                self.object.setValue(options['value'])
            return res

    if hasattr(idaapi, 'is_idaq') and not idaapi.is_idaq():
        raise StopIteration

    class widget(widget):
        """
        This namespace is for interacting with any of the widgets
        associated with the native PyQT5 user-interface.
        """
        __cache__ = {}
        @classmethod
        def of(cls, form):
            '''Return the PyQt widget for the IDA `form` that is provided.'''
            ns = idaapi.PluginForm
            iterable = (getattr(ns, attribute) for attribute in ['TWidgetToPyQtWidget', 'FormToPyQtWidget'] if hasattr(ns, attribute))
            F = next(iterable, None)
            if F is None:
                raise internal.exceptions.UnsupportedVersion(u"{:s}.of({!s}) : Unable to return the PyQT widget from a plugin form due to it being unsupported by the current version of IDA.".format('.'.join([__name__, cls.__name__]), form))
            result = F(form)
            cls.__cache__[result] = form
            return result
        @classmethod
        def form(cls, widget):
            '''Return the IDA form for the PyQt `widget` that is provided.'''
            ns = idaapi.PluginForm
            if hasattr(ns, 'QtWidgetToTWidget'):
                return ns.QtWidgetToTWidget(widget)
            elif widget in cls.__cache__:
                return cls.__cache__[widget]
            raise internal.exceptions.UnsupportedVersion(u"{:s}.of({!s}) : Unable to return the plugin form from a PyQT widget due to it being unsupported by the current version of IDA.".format('.'.join([__name__, cls.__name__]), widget))
        @classmethod
        def isinstance(cls, widget):
            '''Return whether the given `object` is a PyQt widget.'''
            return isinstance(widget, QWidget)

except StopIteration:
    pass

except ImportError:
    logging.info(u"{:s}:Unable to locate `PyQt5.Qt` module.".format(__name__))

### PySide-specific functions and namespaces
try:
    import PySide
    import PySide.QtCore, PySide.QtGui

    class application(application):
        """
        This namespace is for getting information about the application user-interface
        that is based on PySide.
        """
        def __new__(cls):
            '''Return the current PySide instance of the application.'''
            res = PySide.QtCore.QCoreApplication
            return res.instance()

        @internal.utils.multicase()
        @classmethod
        def window(cls):
            '''Return the active main window for the PySide application.'''

            # Apparently PySide.QtCore.QCoreApplication is actually considered
            # the main window for the application. Go figure...
            return cls()
        @internal.utils.multicase(x=six.integer_types, y=six.integer_types)
        @classmethod
        def window(cls, x, y):
            '''Return the window at the specified `x` and `y` coordinate.'''
            q = cls()
            return q.topLevelAt(x, y)

        @classmethod
        def windows(cls):
            '''Return all of the available windows for the application.'''
            app = cls()
            items = app.topLevelWidgets()
            return [item for item in items if top.isWindow()]

    class mouse(mouse):
        """
        This namespace is for interacting with the mouse input.
        """
        @classmethod
        def position(cls):
            '''Return the current `(x, y)` position of the cursor.'''
            qt = PySide.QtGui.QCursor
            res = qt.pos()
            return res.x(), res.y()

    class keyboard(keyboard):
        """
        PySide keyboard interface.
        """
        @classmethod
        def input(cls):
            '''Return the current keyboard input context.'''
            return q.inputContext()

    if hasattr(idaapi, 'is_idaq') and not idaapi.is_idaq():
        raise StopIteration

    class widget(widget):
        """
        This namespace is for interacting with any of the widgets
        associated with the native PySide user-interface.
        """
        __cache__ = {}
        @classmethod
        def of(cls, form):
            '''Return the PySide widget for the IDA `form` that is provided.'''
            ns = idaapi.PluginForm
            iterable = (getattr(ns, attribute) for attribute in ['TWidgetToPySideWidget', 'FormToPySideWidget'] if hasattr(ns, attribute))
            F = next(iterable, None)
            if F is None:
                raise internal.exceptions.UnsupportedVersion(u"{:s}.of({!s}) : Unable to return the PySide widget from a plugin form due to it being unsupported by the current version of IDA.".format('.'.join([__name__, cls.__name__]), form))
            result = F(form)
            cls.__cache__[result] = form
            return result

        @classmethod
        def form(cls, widget):
            '''Return the IDA form for the PySide `widget` that is provided.'''
            if widget in cls.__cache__:
                return cls.__cache__[widget]
            raise internal.exceptions.UnsupportedCapability(u"{:s}.of({!s}) : Unable to return the plugin form from a PySide widget due to it being unsupported by the current version of IDA.".format('.'.join([__name__, cls.__name__]), widget))

        @classmethod
        def isinstance(cls, object):
            '''Return whether the given `object` is a PySide widget.'''
            return isinstance(object, PySide.QtCore.QObject)

except StopIteration:
    pass

except ImportError:
    logging.info(u"{:s}:Unable to locate `PySide` module.".format(__name__))

### wrapper that uses a priorityhook around IDA's hooking capabilities.
class hook(object):
    """
    This namespace exposes the ability to hook different parts of IDA.

    There are 4 different event types in IDA that can be hooked. These
    are available under the ``hook.idp``, ``hook.idb``, ``hook.ui``,
    and ``hook.notification`` objects.

    To add a hook for any of these event types, one can use
    the `add(target, callable, priority)` method to associate a python
    callable with the desired event. After the callable has been
    attached, the `enable(target)` or `disable(target)` methods can be
    used to temporarily enable or disable the hook.

    Please refer to the documentation for the ``idaapi.IDP_Hooks``,
    ``idaapi.IDB_Hooks``, and ``idaapi.UI_Hooks`` classes for
    identifying what event targets are available to hook. Similarly,
    the documentation for ``idaapi.notify_when`` can be used to list
    the targets available for notification hooks.
    """

    @classmethod
    def __start_ida__(ns):
        import hooks

        # Create an alias to save some typing and a table of the attribute
        # name, the base hook class, and the supermethods we need to patch.
        priorityhook, api = internal.interface.priorityhook, {
            'idp':  (idaapi.IDP_Hooks,  hooks.supermethods.IDP_Hooks.mapping),
            'idb':  (idaapi.IDB_Hooks,  hooks.supermethods.IDB_Hooks.mapping),
            'ui':   (idaapi.UI_Hooks,   hooks.supermethods.UI_Hooks.mapping),
        }

        # Iterate through our table and use it to instantiate the necessary
        # objects for each hook type whilst attaching the patched supermethods.
        for attribute, (klass, supermethods) in api.items():

            # If there's an instance already attached to us, then use it.
            if hasattr(ns, attribute):
                instance = getattr(ns, attribute)

            # Otherwise instantiate the priority hooks for each hook type,
            # and assign it directly into our class. We attach a supermethod
            # mapping to patch the original supermethods of each hook where
            # it can either have a completely different number of parameters
            # or different types than what is listed within the documentation.
            else:
                instance = priorityhook(klass, supermethods)
                setattr(ns, attribute, instance)

            # Log some information about what we've just done.
            logging.info(u"{:s} : Attached an instance of `{:s}` to `{:s}` which is now available at `{:s}`.".format('.'.join([__name__, ns.__name__]), instance.__class__.__name__, klass.__name__, '.'.join([__name__, ns.__name__, attribute])))

        # If the idaapi.__notification__ object exists, then also
        # assign it directly into our namespace.
        if not hasattr(ns, 'notification') and hasattr(idaapi, '__notification__'):
            instance = idaapi.__notification__
            setattr(ns, 'notification', instance)
            logging.info(u"{:s} : Attached an instance of `{:s}` to {:s} which is now accessible at `{:s}`.".format('.'.join([__name__, ns.__name__]), instance.__class__.__name__, 'notifications', '.'.join([__name__, ns.__name__, 'notification'])))
        return

    @classmethod
    def __stop_ida__(ns):
        for api in ['idp', 'idb', 'ui']:

            # grab the individual class that was used to hook things
            instance = getattr(ns, api)

            # and then unhook it completely, because IDA on linux
            # seems to still dispatch to those hooks...even when
            # the language extension is unloaded.
            instance.close()
        return

    # if there's a __notification__ attribute attached to IDA, then
    # assign it to our namespace so it can be used.
    if hasattr(idaapi, '__notification__'):
        notification = idaapi.__notification__

hooks = hook    # XXX: ns alias

### Helper classes to use or inherit from
# XXX: why was this base class implemented again??
class InputBox(idaapi.PluginForm):
    """
    A class designed to be inherited from that can be used
    to interact with the user.
    """
    def OnCreate(self, form):
        '''A method to overload to be notified when the plugin form is created.'''
        self.parent = self.FormToPyQtWidget(form)

    def OnClose(self, form):
        '''A method to overload to be notified when the plugin form is destroyed.'''
        pass

    def Show(self, caption, options=0):
        '''Show the form with the specified `caption` and `options`.'''
        res = internal.utils.string.to(caption)
        return super(InputBox, self).Show(res, options)

### Console-only progress bar
class ConsoleProgress(object):
    """
    Helper class used to simplify the showing of a progress bar in IDA's console.
    """
    def __init__(self, blocking=True):
        self.__path__ = os.path.join(_database.config.path(), _database.config.filename())
        self.__value__ = 0
        self.__min__, self.__max__ = 0, 0
        return

    canceled = property(fget=operator.not_, fset=operator.eq)
    maximum = property(fget=lambda self: self.__max__)
    minimum = property(fget=lambda self: self.__min__)
    current = property(fget=lambda self: self.__value__)

    def open(self, width=0.8, height=0.1):
        '''Open a progress bar with the specified `width` and `height` relative to the dimensions of IDA's window.'''
        return

    def close(self):
        '''Close the current progress bar.'''
        return

    def update(self, **options):
        '''Update the current state of the progress bar.'''
        minimum, maximum = options.get('min', None), options.get('max', None)
        text, title, tooltip = (options.get(item, None) for item in ['text', 'title', 'tooltip'])

        if minimum is not None:
            self.__min__ = minimum
        if maximum is not None:
            self.__max__ = maximum

        res = self.__value__
        if 'current' in options:
            self.__value__ = options['current']
        if 'value' in options:
            self.__value__ = options['value']

        if text is not None:
            six.print_(internal.utils.string.of(text))

        return res

### Fake progress bar class that instantiates whichever one is available
class Progress(object):
    """
    The default progress bar in with which to show progress. This class will
    automatically determine which progress bar (Console or UI) to instantiate
    based on what is presently available.
    """

    timeout = 5.0

    def __new__(cls, *args, **kwargs):
        '''Figure out which progress bar to use and instantiate it with the provided parameters `args` and `kwargs`.'''
        if not all([idaapi.is_idaq(), 'UIProgress' in globals()]):
            logging.warning(u"{:s}(...) : Using console-only implementation of the `ui.Progress` class.".format('.'.join([__name__, cls.__name__])))
            return ConsoleProgress(*args, **kwargs)

        # XXX: spin for a bit looking for the application window as IDA seems to be racy with this for some reason
        ts, main = time.time(), getattr(cls, '__appwindow__', None)
        while time.time() - ts < cls.timeout and main is None:
            main = application.window()

        # If no main window was found, then fall back to the console-only progress bar
        if main is None:
            logging.warning(u"{:s}(...) : Unable to find main application window. Falling back to console-only implementation of the `ui.Progress` class.".format('.'.join([__name__, cls.__name__])))
            return ConsoleProgress(*args, **kwargs)

        cls.__appwindow__ = main
        return UIProgress(*args, **kwargs)

```

`plugins/minsc.py`:

```py
"""
IDA-Minsc plugin -- https://arizvisa.github.io/ida-minsc

This file contains the entirety of the logic that is used to load the
plugin. The plugin is (mostly) a library that aims to simplify IDAPython.
However, it utilizes hooks and keyboard shortcuts in a variety of ways in
order to keep track of the changes that the user may make within their
database. Essentially the goal of this plugin is to make absolutely
_everything_ that's useful in the database serializeable and queryable
so that it can be exchanged with things outside of the database.

If you wish to change the directory that the plugin is loaded from, specify the
location of the plugin's git repository in the variable that is marked below.
"""
import sys, os, logging
import builtins, six, imp, fnmatch, ctypes, types
import idaapi

# :: Point this variable at the directory containing the repository of the plugin ::
root = idaapi.get_user_idadir()

# The following classes contain the pretty much all of the loader logic used by the
# plugin. This is being defined here so that this file can also be used as a module.
class internal_api(object):
    """
    Loader base-class for any api that's based on files contained within a directory.
    """
    os, imp, fnmatch = os, imp, fnmatch
    def __init__(self, directory, **attributes):
        '''Initialize the api using the contents within the specified `directory`.'''
        self.path = self.os.path.realpath(directory)
        [ setattr(self, name, attribute) for name, attribute in attributes.items() ]

    ### Api operations
    def load_api(self, path):
        '''Load the specified `path` into a module that can be used.'''
        path, filename = self.os.path.split(path)
        name, _ = self.os.path.splitext(filename)
        return self.imp.find_module(name, [path])

    def iterate_api(self, include='*.py', exclude=None, **attributes):
        """Iterate through all of the files in the directory specified when initializing the loader.

        The `include` string is a glob that specifies which files are part of the loader's api.
        If the `exclude` glob is specified, then exclude files that match it from the loader api.
        """
        result = []
        for filename in self.fnmatch.filter(self.os.listdir(self.path), include):
            if exclude and self.fnmatch.fnmatch(filename, exclude):
                continue

            path = self.os.path.join(self.path, filename)
            _, ext = self.os.path.splitext(filename)

            left, right = (None, None) if include == '*' else (include.index('*'), len(include) - include.rindex('*'))
            modulename = filename[left : -right + 1]
            yield modulename, path
        return

    def new_api(self, modulename, path):
        '''Load the file found at `path` into the specified `modulename`.'''
        file, path, description = self.load_api(path)
        try:
            return self.imp.load_module(modulename, file, path, description)
        finally: file.close()

    ### Module operations
    def new_module(self, fullname, documentation=None):
        '''Create a new module (empty) with the specified `fullname` and the provided `documentation`.'''
        res = self.imp.new_module(fullname)
        res.__package__ = fullname
        res.__doc__ = documentation or ''
        return res

    def find_module(self, fullname, path=None):
        raise NotImplementedError

    def load_module(self, fullname):
        raise NotImplementedError

    def __iter__(self):
        '''Yield the full path of each module that is provided by this class.'''
        return
        yield

class internal_path(internal_api):
    """
    Loader class which provides all api composed of all of the files within a directory
    as modules that can always be imported from anywhere.
    """
    def __init__(self, path, **attrs):
        '''Initialize the loader using the files from the directory specified by `path`.'''
        super(internal_path, self).__init__(path)
        attrs.setdefault('include', '*.py')
        self.attrs, self.cache = attrs, { name : path for name, path in self.iterate_api(**attrs) }

    def find_module(self, fullname, path=None):
        '''If the module with the name `fullname` matches one of the files handled by our api, then act as their loader.'''
        return self if path is None and fullname in self.cache else None

    def load_module(self, fullname):
        '''Iterate through all of the modules that we can handle, and then load it if we've been asked.'''
        self.cache = { name : path for name, path in self.iterate_api(**self.attrs) }
        if fullname not in self.cache:
            raise ImportError("path-loader ({:s}) was not able to find a module named `{:s}`".format(self.path, fullname))
        return self.new_api(fullname, self.cache[fullname])

    def __iter__(self):
        '''Yield each of the available modules.'''
        for name, _ in self.iterate_api(**self.attrs):
            yield name
        return

class internal_submodule(internal_api):
    """
    Loader class which provides an api composed of all of the files within a
    directory, and binds them to a module which is used to access them.
    """
    sys = sys
    def __init__(self, __name__, path, **attrs):
        '''Initialize the loader using `__name__` as the name of the submodule using the files underneath the directory `path`.'''
        super(internal_submodule, self).__init__(path)
        attrs.setdefault('include', '*.py')
        self.__name__, self.attrs = __name__, attrs

    def find_module(self, fullname, path=None):
        '''If the module with the name `fullname` matches our submodule name, then act as its loader.'''
        return self if path is None and fullname == self.__name__ else None

    def new_api(self, modulename, path):
        '''Load the file found at the specified `path` as a submodule with the specified `modulename`.'''
        cls, fullname = self.__class__, '.'.join([self.__name__, modulename])
        res = super(cls, self).new_api(fullname, path)
        res.__package__ = self.__name__
        return res

    def load_module(self, fullname):
        '''Iterate through all of the modules that we can handle, load the submodule with them, and return it.'''
        module = self.sys.modules[fullname] = self.new_module(fullname)
        # FIXME: make module a lazy-loaded object for fetching module-code on-demand

        # Build a temporary cache for the module names and paths to load the api,
        # and use them to build their documentation.
        cache = { name : path for name, path in self.iterate_api(**self.attrs) }
        maximum = max(map(len, cache)) if cache else 0
        documentation = '\n'.join("{:<{:d}s} : {:s}".format(name, maximum, path) for name, path in sorted(cache.items()))
        documentation = '\n\n'.join([self.attrs['__doc__'], documentation]) if '__doc__' in self.attrs else documentation
        module.__doc__ = documentation

        # Load each submodule that composes the api, and attach it to the returned submodule.
        stack, count, result = [item for item in cache.items()], len(cache), {}
        while stack and count > 0:
            name, path = stack.pop(0)

            # Take the submodule name we popped off of the cache, and try and load it.
            # If we were able to load it successfully, then we just need to attach the
            # loaded code as a submodule of the object we're going to return.
            try:
                res = self.new_api(name, path)
                modulename = '.'.join([res.__package__, name])

            # If an exception was raised, then remember it so that we can let the user
            # know after we've completely loaded the module.
            except Exception as E:
                import logging
                logging.info("{:s} : Error trying to import module `{:s}` from {!s}. Queuing it until later.".format(self.__name__, name, path), exc_info=True)

                # If we caught an exception while trying to import the module, then stash
                # our exception info state into a dictionary and decrease a counter. This
                # is strictly to deal with module recursion issues in Python3.
                result[name], count = sys.exc_info(), count - 1
                stack.append((name, path))

            # Add the submodule that we loaded into the module that we're going to return.
            else:
                setattr(module, name, res)
            continue

        # If we weren't able to load one of the submodules that should've been in our cache,
        # then go through all of our backtraces and log the exception that was raised.
        if stack:
            import logging, traceback
            for name, path in stack:
                logging.fatal("{:s} : Error trying to import module `{:s}` from {!s}.".format(self.__name__, name, path), exc_info=result[name])
            return module

        # If we caught an exception despite our stack being empty, then this is because of a
        # recursion issue. In case someone wants to track these situations down, we go through
        # our caught exceptions and create some logging events with the backtrace. These errors
        # are non-fatal because importing another sub-module helped resolve it.
        import logging
        for name, exc_info in result.items():
            logging.info("{!s} : Encountered a non-fatal exception while trying to import recursive module `{:s}` from {!s}".format(self.__name__, name, cache[name]), exc_info=result[name])

        # Return the module that we just created.
        return module

    def __iter__(self):
        '''Yield each of the available modules.'''
        for name, _ in self.iterate_api(**self.attrs):
            yield name
        return

class internal_object(object):
    """
    Loader class which will simply expose an object instance as the module.
    """
    sys = sys
    def __init__(self, __name__, object, **attributes):
        '''Initialize the loader with the specified `__name__` and returning the provided `object` as its module.'''
        self.__name__, self.object = __name__, object
        for name, value in attributes.items():
            try: setattr(object, name, value)
            except: continue

    def find_module(self, fullname, path=None):
        '''If the module being searched for matches our `fullname`, then act as its loader.'''
        return self if path is None and fullname == self.__name__ else None

    def load_module(self, fullname):
        '''Return the specific object for the module specified by `fullname`.'''
        if fullname != self.__name__:
            raise ImportError("object-loader ({:s}) was not able to find a module named `{:s}`".format(self.__name__, fullname))
        module = self.sys.modules[fullname] = self.object
        return module

class plugin_module(object):
    """
    Loader class which iterates through all of the files in a directory, and
    manually initializes each plugin similar to the way `idaapi.plugin_t` is
    supposed to be initialized.
    """
    def __init__(self, path, **attrs):
        # FIXME: go through all files in plugin/ and call PLUGIN_ENTRY() on each module
        #        this should return an idaapi.plugin_t.

        # idaapi.plugin_t will contain an init, run, and term method.
        # also, are some attributes to process:
        # 'wanted_name' which is for idc.
        # 'wanted_hotkey', which should be mapped to a keypress.
        # 'comment' self-explanatory
        # 'help' self-explanatory

        # hotkey can be done by:
        # idaapi.CompileLine('static myname() { RunPythonStateMent("CallSomePython()") }')
        # idc.AddHotKey(module.wanted_hotkey, "myname")

        # idaapi.require
        pass

# The following logic is responsible for replacing a namespace with
# the contents namespace that represents the entirety of the plugin.
def load(namespace, preserve=()):
    module = imp.load_source('__root__', os.path.join(root, '__root__.py'))

    # save certain things within the namespace
    preserved = {symbol : value for symbol, value in namespace.items() if symbol in preserve}

    # empty out the entire namespace so that we can replace it
    [namespace.pop(symbol) for symbol in namespace.copy() if not symbol.startswith('__')]

    # re-populate with the root namespace while restoring any symbols
    # that needed to be preserved.
    namespace.update({symbol : value for symbol, value in module.__dict__.items() if not symbol.startswith('__')})
    namespace.update({symbol : value for symbol, value in preserved.items()})

# Just a ctypes wrapper so that we can access the internal IDA api.
library = ctypes.WinDLL if os.name == 'nt' else ctypes.CDLL

# The following code is responsible for seeding Python's loader by
# yielding each of the objects that need to be added to its meta_path.
def finders():
    '''Yield each finder that will be used by the plugin to locate its modules.'''

    documentation = 'This is a ctypes-library to the shared object that is exposed to the IDA SDK.'

    # IDA's native lower-level api
    if sys.platform in {'darwin'}:
        yield internal_object('ida', library(idaapi.idadir("libida{:s}.dylib".format('' if idaapi.BADADDR < 0x100000000 else '64'))), __doc__=documentation)

    elif sys.platform in {'linux', 'linux2'}:
        yield internal_object('ida', library(idaapi.idadir("libida{:s}.so".format('' if idaapi.BADADDR < 0x100000000 else '64'))), __doc__=documentation)

    elif sys.platform in {'win32'}:
        if os.path.exists(idaapi.idadir('ida.wll')):
            yield internal_object('ida', library(idaapi.idadir('ida.wll')))
        else:
            yield internal_object('ida', library(idaapi.idadir("ida{:s}.dll".format('' if idaapi.BADADDR < 0x100000000 else '64'))), __doc__=documentation)

    else:
        logging.warning("{:s} : Unable to load IDA's native api via ctypes. Ignoring...".format(__name__))

    # private (internal) api
    documentation = 'This virtual module contains a number of internal submodules.'
    yield internal_submodule('internal', os.path.join(root, 'base'), include='_*.py', __doc__=documentation)

    # public api
    yield internal_path(os.path.join(root, 'base'), exclude='_*.py')
    yield internal_path(os.path.join(root, 'misc'))

    # tools and application api
    documentation = 'This virtual module contains a number of different files as submodules.'
    for directory in ['tools', 'application']:
        yield internal_submodule(directory, os.path.join(root, directory), __doc__=documentation)
    return

# The following logic is simply for detecting the version of IDA and
# for stashing it directly into the "idaapi" module.

# needed because IDA 6.95 is fucking stupid and sets the result of idaapi.get_kernel_version() to a string
def host_version():
    '''Return the version of the host application as the major, minor, and a floating-point variation.'''

    # if the api doesn't exist, then go back to some crazy version.
    if not hasattr(idaapi, 'get_kernel_version'):
        return 6, 0, 6.0

    import math
    res = str(idaapi.get_kernel_version())      # force it to a str because IDA 7.0 "fixed" it
    major, minor = map(int, res.split('.', 2))
    minor = int("{:<02d}".format(minor))
    if minor > 0:
        count = 1 + math.floor(math.log10(minor))
        return major, minor, float(major) + minor * pow(10, -count)
    return major, minor, float(major)

def patch_version(module):
    '''Patch the version of the host application into a given module.'''
    version = host_version()
    module.__version_major__, module.__version_minor__, module.__version__ = version
    return version

# The following logic is the display hook that we install in order to
# control how all of our output renders in the REPL.
class DisplayHook(object):
    """
    Re-implementation of IDAPython's displayhook that doesn't tamper with
    classes that inherit from base classes
    """
    def __init__(self, output, displayhook):
        self.orig_displayhook = displayhook or sys.displayhook

        # Save our output callable so we can use it to write raw
        # and unprocessed information to it.
        self.output = output

    def format_seq(self, num_printer, storage, item, open, close):
        storage.append(open)
        for idx, el in enumerate(item):
            if idx > 0:
                storage.append(', ')
            self.format_item(num_printer, storage, el)
        storage.append(close)

    def format_basestring(self, string):
        # FIXME: rather than automatically evaluating the string as we're
        #        currently doing, it'd be much cleaner if we just format the
        #        result from a function with some sort of wrapper object. This
        #        way we can check its type, and then choose whether to unwrap it
        #        or not. This can be done with a decorator of some sort that
        #        communicates to this implementation that it will need to
        #        distinguish between printable strings that we can output and
        #        strings that should be processed by the user.
        # XXX: maybe we can even use this wrapper object to allow this class to
        #      handle aligning columns in a table automatically such as when
        #      more than one element in a row is being returned.
        try:
            result = u"{!r}".format(string)
        except UnicodeDecodeError:
            import codecs
            encoded, _ = codecs.escape_encode(string)
            result = u"'{!s}'".format(encoded)
        return result

    def format_ctypes(self, num_printer, storage, item):
        cls, size = item.__class__, ctypes.sizeof(item)
        if isinstance(item, ctypes._SimpleCData):
            contents = "{:#0{:d}x}".format(item.value, 2 + 2 * size) if isinstance(item.value, six.integer_types) else "{!s}".format(item.value)
            storage.append("{:s}({:s})".format(cls.__name__, contents))

        # if it's anything else (or an unknown), then use the default formatter.
        else:
            storage.append("{!r}".format(item))
        return

    def format_item(self, num_printer, storage, item):
        if item is None or isinstance(item, bool):
            storage.append("{!s}".format(item))
        elif isinstance(item, six.string_types):
            storage.append(self.format_basestring(item))
        elif isinstance(item, six.integer_types):
            storage.append(num_printer(item))
        elif isinstance(item, idaapi.tinfo_t):
            storage.append("{!s}".format(item.dstr()))
        elif isinstance(item, (ctypes._SimpleCData, ctypes._Pointer, ctypes._CFuncPtr, ctypes.Array, ctypes.Structure)):
            self.format_ctypes(num_printer, storage, item)
        elif item.__class__ is list:
            self.format_seq(num_printer, storage, item, '[', ']')
        elif item.__class__ is tuple:
            self.format_seq(num_printer, storage, item, '(', ')')
        elif item.__class__ is set:
            self.format_seq(num_printer, storage, item, 'set([', '])')
        elif item.__class__ is dict:
            storage.append('{')
            for idx, pair in enumerate(item.items()):
                if idx > 0:
                    storage.append(', ')
                self.format_item(num_printer, storage, pair[0])
                storage.append(": ")
                self.format_item(num_printer, storage, pair[1])
            storage.append('}')
        else:
            storage.append("{!r}".format(item))

    def _print_hex(self, x):
        return "{:#x}".format(x)

    def displayhook(self, item):
        builtins._ = item
        if item is None or not hasattr(item, '__class__') or item.__class__ is bool:
            self.orig_displayhook(item)
            return
        try:
            storage = []
            if idaapi.__version__ < 7.0:
                import idaapi as ida_idp
            else:
                import ida_idp
            num_printer = self._print_hex
            dn = ida_idp.ph_get_flag() & ida_idp.PR_DEFNUM
            if dn == ida_idp.PRN_OCT:
                num_printer = oct
            elif dn == ida_idp.PRN_DEC:
                num_printer = str
            elif dn == ida_idp.PRN_BIN:
                num_printer = bin
            self.format_item(num_printer, storage, item)
            self.output("%s\n" % "".join(storage))
        except Exception:
            import traceback
            traceback.print_exc()
            self.orig_displayhook(item)

# Locate the user's dotfile and execute it within the specified namespace.
def dotfile(namespace, filename=u'.idapythonrc.py'):
    '''Execute the user's dotfile within the specified namespace.'''
    path = None

    # A closure that just consumes paths until it finds one that
    # it can read and execute it within the specified namespace.
    def read_and_execute(filename, namespace):
        path = (yield)
        while True:
            fp = os.path.join(path, filename)
            try:
                with open(fp, 'r') as infile:
                    content = infile.read()
            except IOError:
                logging.debug("{:s} : Error reading the dotfile at `{!s}`.".format(__name__, fp), exc_info=True)
            else:
                break
            path = (yield)

        exec(content, namespace)

    # Another closure that just tries to determine the user's home
    # directory from the environment variables it receives.
    def find_home(*variables):
        iterable = (var for var in variables if os.getenv(var, default=None) is not None)
        path = next(iterable, None)
        if path is None:
            raise OSError("{:s} : Unable to determine the user's home directory from the environment.".format(__name__))
        return path, os.getenv(path)

    # Create our coroutine, initialize it, and then feed it some paths.
    tribulations = read_and_execute(filename, namespace); next(tribulations)

    try:
        path = os.path.expanduser('~')
        tribulations.send(path)

        var, path = find_home('HOME', 'USERPROFILE')
        tribulations.send(path)

    # If we stopped, then it was read and executed successfully.
    except StopIteration:
        logging.debug("{:s} : Successfully read and executed the dotfile at `{!s}`.".format(__name__, os.path.join(path, filename)))

    # If we received an OSError, then this likely happened while we
    # were trying to find the home directory. Pass it to the user.
    except OSError as E:
        print(E)

    # Any other exception is because of an issue in the user's script,
    # so we'll do our best to log the backtrace for them to debug.
    except Exception:
        logging.warning("{:s} : Unexpected exception raised while trying to execute the dotfile at `{!s}`.".format(__name__, os.path.join(path, filename)), exc_info=True)

    # If we didn't get an exception, then literally we couldn't find
    # any file that we were supposed to execute. Log it and move on.
    else:
        vowels, alpha = tuple('aeiou'), next((filename[index:] for index, item in enumerate(filename.lower()) if item in 'abcdefghijklmnopqrstuvwxyz'), filename)
        logging.warning("{:s} : Unable to locate a{:s} {:s} dotfile in the user's {:s} directory ({!s}).".format(__name__, 'n' if alpha.startswith(vowels) else '', filename, var, path))
    finally:
        tribulations.close()

    # Verify that executing the dotfile did not add the root directory
    # to the system path because the contents of the root directory is
    # explicitly handled by our loaders.
    busted = [(index, item) for index, item in enumerate(sys.path) if os.path.realpath(item) in {os.path.realpath(root)}]
    if busted:
        logging.warning("{:s} : Execution of `{!s}` has resulted in a conflict between the repository path ({!r}) and the system path.".format(__name__, filename, root))
        [ logging.warning("{:s} : The system path at index {:d} ({!r}) resolves to {!r} which conflicts with the plugin and may interfere with imports.".format(__name__, index, item, os.path.realpath(item))) for index, item in busted ]
    return

# The following logic is actually responsible for starting up the whole
# plugin. This is done with by trying with a notification, falling back
# to a timer, and then straight-up executing things if all else fails.
def startup(namespace=None):
    '''Patch in a notification hander and start up everything left in the plugin.'''

    # First check that we've installed the version patch and it's the
    # right type as everything literally revolves around that critical step.
    if not hasattr(idaapi, '__version__'):
        raise SystemError("{:s} : Unable to start up plugin due to the \"{:s}\" attribute not having been assigned.".format(__name__, '.'.join([idaapi.__module__, '__version_'])))

    if not isinstance(idaapi.__version__, float):
        raise SystemError("{:s} : Unable to start up plugin due to the \"{:s}\" attribute not being a valid type ({!r})".format(__name__, '.'.join([idaapi.__module__, '__version_']), idaapi.__version__))

    # Now we need to make sure we have access to our internal module.
    # We can simply trap for ImportError to ensure this works.
    try:
        import internal
        internal.interface

    except ImportError:
        logging.critical("{:s} : An error occured while trying to access the \"{:s}\" module.".format(__name__, 'internal'), exc_info=True)
        raise SystemError("{:s} : Unable to start up plugin without being able to access its \"{:s}\" modules.".format(__name__, 'internal'))

    except AttributeError:
        logging.critical("{:s} : An error occured while trying to access the \"{:s}\" module.".format(__name__, '.'.join(['internal', 'interface'])), exc_info=True)
        raise SystemError("{:s} : Unable to start up plugin due to an error while loading its \"{:s}\" modules.".format(__name__, 'internal'))

    # The next module we need to make sure we have access to is our
    # hooks module which contains all of our startup logic.
    try:
        import hooks

    except ImportError:
        logging.critical("{:s} : An error occured while trying to access the \"{:s}\" module.".format(__name__, 'hooks'), exc_info=True)
        raise SystemError("{:s} : Unable to start up plugin without being able to access its \"{:s}\" module.".format(__name__, 'hooks'))

    # Finally we can construct our priority notification class and inject it into
    # the IDAPython module. This object needs to exist in order for everything to
    # initialize and deinitialize properly.
    idaapi.__notification__ = notification = internal.interface.prioritynotification()

    # Now we can proceed to install our hooks that actually initialize and uninitialize
    # MINSC. We define two closures here (with documentation) because these are actually
    # accessible by the user if they navigate the hook interface that we expose to them.
    def execute_user_dotfile(*args, **kwargs):
        '''This function is responsible for executing the dotfile in the home directory of the user.'''
        return dotfile(namespace)

    # This second closure is meant to be called from a timer. To avoid having to register
    # multiple timers, we pack up our logic that loads the plugin and the user's dotfile
    # within a single function to register.
    def load_plugin_and_execute_user_dotfile(*args, **kwargs):
        '''This function is responsible for loading the plugin and executing the dotfile in the home directory of the user.'''
        result = hooks.ida_is_busy_sucking_cocks(*args, **kwargs)
        dotfile(namespace)
        return result

    # Finally we can register the functions that will actually be responsible for
    # initializing the plugin. If we were given a namespace, then we can register
    # our closure that loads the user's dotfile too.
    try:
        notification.add(idaapi.NW_INITIDA, hooks.make_ida_not_suck_cocks, -1000)
        namespace and notification.add(idaapi.NW_INITIDA, execute_user_dotfile, 0)

    # If installing that hook failed, then check if we're running in batch mode. If
    # we are, then just immediately register things and load the user dotfile.
    except Exception:
        TIMEOUT = 5
        if idaapi.cvar.batch:
            hooks.ida_is_busy_sucking_cocks()
            namespace and dotfile(namespace)

        # Otherwise warn the user about this and register our hook with a timer.
        elif namespace is None:
            logging.warning("{:s} : Unable to add a notification via `{:s}` for {:s}({:d}).".format(__name__, '.'.join(['idaapi', 'notify_when']), '.'.join(['idaapi', 'NW_INITIDA']), idaapi.NW_INITIDA))
            logging.warning("{:s} : Registering {:.1f} second timer with `{:s}` in an attempt to load plugin...".format(__name__, TIMEOUT, '.'.join(['idaapi', 'register_timer'])))
            idaapi.register_timer(TIMEOUT, hooks.ida_is_busy_sucking_cocks)
            six.print_('=' * 86)

        # If we were given a namespace to load into, then we register the closure
        # that we defined into the timer so that the user's dotfile gets executed.
        else:
            logging.warning("{:s} : Unable to add a notification via `{:s}` for {:s}({:d}).".format(__name__, '.'.join(['idaapi', 'notify_when']), '.'.join(['idaapi', 'NW_INITIDA']), idaapi.NW_INITIDA))
            logging.warning("{:s} : Registering {:.1f} second timer with `{:s}` in an attempt to load plugin...".format(__name__, TIMEOUT, '.'.join(['idaapi', 'register_timer'])))
            idaapi.register_timer(TIMEOUT, load_plugin_and_execute_user_dotfile)
            six.print_('=' * 86)
        del(TIMEOUT)

    # If we were able to hook NW_INITIDA, then the NW_TERMIDA hook should also work.
    else:
        try:
            notification.add(idaapi.NW_TERMIDA, hooks.make_ida_suck_cocks, +1000)

        # Installing the termination hook failed, but it's not really too important...
        except Exception:
            logging.warning("{:s} : Unable to add a notification for idaapi.NW_TERMIDA({:d}).".format(__name__, idaapi.NW_TERMIDA))
    return

# Now we can define our plugin_t that literally does nothing if we've already been
# loaded via the idapythonrc.py file and control the entire default namespace.

class MINSC(idaapi.plugin_t):
    wanted_name = 'About Minsc'
    comment = 'Makes IDAPython Not Suck Completely.'
    wanted_hotkey = ''

    flags = idaapi.PLUGIN_FIX
    state = None

    help = 'You should totally check out the `dill` Python module so you can save your game.'

    def get_loader(self):
        '''Return the loader containing all the components needed for loading and initializing the plugin'''
        import imp

        # We explicitly create our own version of the loader from the current
        # file. The functionality we need is actually within our current module,
        # but IDA was responsible for loading it. Most importantly, though, is
        # that the loader is intended to be completely thrown away after usage.
        try:
            filename = __file__ if os.path.exists(__file__) else os.path.join(root, 'plugins', 'minsc.py')
            module = imp.load_source("{:s}__loader__".format(__name__), filename)

        except IOError:
            logging.critical("{:s} : A critical error occurred while trying to read the plugin loader from the file: {:s}".format(__name__, filename), exc_info=True)

        except ImportError:
            logging.critical("{:s} : A critical error occurred while initializing the plugin loader in \"{:s}\"".format(__name__, filename), exc_info=True)

        except Exception:
            logging.critical("{:s} : A critical error occurred while initializing the plugin loader".format(__name__, filename), exc_info=True)

        return module

    def init(self):
        version = getattr(idaapi, '__version__', None)

        # Check our version.. but not really. We're only checking it to see
        # whether the plugin has been loaded yet. If our version if a float,
        # then our module finders have already been loaded and we just need
        # to persist ourselves.
        if isinstance(version, float):
            self.state = self.__class__.state = 'persistent'
            return idaapi.PLUGIN_KEEP

        # If our state is already initialized, then we've done this before.
        elif self.state:
            logging.critical("{:s} : Loading plugin again despite it already being initialized ({:s}).".format(__name__, self.state))

        # Now the version hasn't been assigned yet, then the user didn't
        # install this globally. This means that we don't control the primary
        # namespace. So we'll need to load ourselves still and then afterwards
        # we can uninstall ourselves whenever our plugin is asked to terminate.
        loader = self.get_loader()
        if not loader:
            raise SystemError("{:s} : Unable to get the loader required by the plugin.".format(__name__))

        # Iterate through all of the items in our system path in order to remove
        # any that reference our plugin root. This is because we're using our
        # own loaders to find modules instead of Python's file loaders.
        sys.path[:] = [item for item in sys.path if os.path.realpath(item) not in {os.path.realpath(root)}]

        # Seed the metapath, then patch the version into the idaapi module.
        sys.meta_path.extend(loader.finders())
        _, _, version = loader.patch_version(idaapi)

        # Check if IDAPython (6.95) has replaced the display hook with their
        # own version. We're going to undo exactly what they did, because
        # we're going to replace it with our own anyways.
        ida_idaapi = __import__('ida_idaapi') if version >= 6.95 else idaapi
        if hasattr(ida_idaapi, '_IDAPython_displayhook') and hasattr(ida_idaapi._IDAPython_displayhook, 'orig_displayhook'):
            orig_displayhook = ida_idaapi._IDAPython_displayhook.orig_displayhook
            del(ida_idaapi._IDAPython_displayhook.orig_displayhook)

            sys.displayhook = loader.DisplayHook(sys.stdout.write, orig_displayhook).displayhook

        # If it's the builtin displayhook then we can use it as-is.
        elif getattr(sys.displayhook, '__module__', '') == 'sys':
            sys.displayhook = loader.DisplayHook(sys.stdout.write, sys.displayhook).displayhook

        # Anything else means that some plugin or somebody else did something
        # crazy, and we have no idea how to recover from this.
        else:
            logging.warning("{:s} : Skipping installation of the display hook at \"{:s}\" due to a lack of awareness about the current one ({!r}).".format(__name__, '.'.join(['sys', 'displayhook']), sys.displayhook))

        # Now we'll try and tamper with the user's namespace. We'll search through
        # Python's module list, and if we find it we'll just swap it out for root.
        if '__main__' in sys.modules:
            ns, banner_required = sys.modules['__main__'], {'print_banner', 'IDAPYTHON_VERSION', 'sys'}
            loader.load(ns.__dict__, preserve={'_orig_stdout', '_orig_stderr'} | banner_required)
            hasattr(ns, 'print_banner') and ns.print_banner()
            [ns.__dict__.pop(item, None) for item in banner_required]

        else:
            logging.warning("{:s} : Skipping the reset of the primary namespace as \"{:s}\" was not found in Python's module list.".format(__name__, '__main__'))

        # We don't bother tampering with the user's namespace, since technically
        # we don't have access to it.. However, we'll still try to install the
        # necessary hooks or other features depending what we found available.
        ok = True
        try:
            import internal, hooks

        except (ImportError, Exception):
            logging.critical("{:s} : An error occurred while trying to import the necessary modules \"{:s}\", and \"{:s}\".".format(__name__, 'internal', 'hooks'), exc_info=True)
            ok = False

        try:
            ok and internal.interface

        except AttributeError:
            logging.critical("{:s} : One of the internal modules, \"{:s}\", is critical but was not properly loaded.".format(__name__, '.'.join(['internal', 'interface'])))

        # Check to see if our notification instance was assigned into idaapi. If
        # it wasn't then try to construct one and assign it for usage.
        try:
            if ok and not hasattr(idaapi, '__notification__'):
                idaapi.__notification__ = notification = internal.interface.prioritynotification()

        except Exception:
            logging.warning("{:s} : An error occurred while trying to instantiate the notifications interface. Notifications will be left as disabled.".format(__name__))

        # Check to see if all is well, and if it is then we can proceed to install
        # the necessary hooks to kick everything off.
        if ok:
            logging.info("{:s} : Plugin has been successfully initialized and will now start attaching to the necessary handlers.".format(__name__))
            self.state = self.__class__.state = 'local'
            hooks.make_ida_not_suck_cocks(idaapi.NW_INITIDA)

            # If there's an accessible "__main__" namespace, then dump the dotfile into it.
            '__main__' in sys.modules and dotfile(sys.modules['__main__'].__dict__)

        else:
            logging.warning("{:s} : Due to previous errors the plugin was not properly attached. Modules may still be imported, but a number of features will not be available.".format(__name__))
            self.state = self.__class__.state = 'disabled'

        return idaapi.PLUGIN_KEEP

    def term(self):
        if self.state is None:
            logging.warning("{:s} : Ignoring the host application request to terminate as the plugin has not yet been initialized.".format(__name__))
            return

        # Figure out how we were started so that we can slowly tear things down.
        if self.state in {'disabled', 'persistent'}:
            logging.debug("{:s} : Host application requested termination of {:s} plugin.".format(__name__, self.state))
            return

        # We were run locally, so we're only allowed to interact with the current
        # database. This means that we now will need to shut everything down.
        try:
            import internal, hooks

        except ImportError:
            logging.critical("{:s} : An error occurred while trying to import the necessary modules \"{:s}\", and \"{:s}\" during plugin termination.".format(__name__, 'internal', 'hooks'), exc_info=True)
            return

        # Now we can just remove our hooks and all should be well.
        try:
            logging.debug("{:s} : Detaching from the host application as requested.".format(__name__))
            hooks.make_ida_suck_cocks(idaapi.NW_TERMIDA)

        except Exception:
            logging.critical("{:s} : An error occurred while trying to detach from the host application during plugin termination. Application may become unstable.".format(__name__), exc_info=True)
        return

    def run(self, args):
        import ui

        # Shove some help down the user's throat.
        print("Python>{:<{:d}s} # Use `help({:s})` for usage".format('ui.keyboard.list()', 40, 'ui.keyboard'))
        try:
            ui.keyboard.list()
        except Exception as E:
            print(E)
        print('')

        # Have some more...
        hooks = [name for name in dir(ui.hook) if not name.startswith('__')]
        print('The following hook types are locked and loaded:' if hooks else 'Currently no hooks have been initialized.')
        for name in hooks:
            item = getattr(ui.hook, name)
            fullname = '.'.join(['ui.hook', name])
            print("Python>{:<{:d}s} # Use `help({:s})` for usage and `{:s}.list()` to see availability".format(fullname, 40, fullname, fullname))
            print(item)
            print('')

        # Dead leaves on the dirty ground...when I know you're not around. Shiny
        # tops and soda pops, when I hear you make a sound.

        noise = '''Welcome to the IDA-minsc plugin. My arrow keys are broken.

        This plugin is (mostly) a library that aims to simplify IDAPython. However,
        it utilizes hooks and keyboard shortcuts in a variety of ways in order to
        keep track of the changes that the user may make within their database.

        Essentially the goal of this plugin is to make absolutely _everything_
        that a user may notate in their database serializeable (into a python type)
        and queryable so that things can be exchanged with other Python interpreters.

        Use "." to jump to the command-line and Shift+F2 if you need multi-line.
        Don't forget `dir()` to look around, and `help(thing)` to inquire.
        '''

        # If you can hear a piano fall, you can hear me coming down the hall. If
        # I can just hear your pretty voice, I don't think I need to see at all.

        home = os.path.expanduser('~')
        dotfile = "On startup, the {:s} file will be executed within the primary namespace.".format(os.path.join(home, '.idapythonrc.py'))

        # Every breath that is in your lungs is a tiny little gift to me.

        import database
        path = os.path.join(database.config.path() or '$IDB_DIRECTORY', 'idapythonrc.py')
        rcfile = "Upon {:s} database, the {:s} file will be loaded.".format('opening up the current' if database.config.path() else 'opening up a', os.path.abspath(path))
        ui.message('\n'.join([noise, '\n'.join([dotfile, rcfile])]))
        return

def PLUGIN_ENTRY():
    return MINSC()

```

`requirements.txt`:

```txt
six>=1.10.0
networkx>=1.10
future>=0.16.0

```

`tools/general.py`:

```py
"""
General module

This module provides generalized tools that a user may find
useful in their reversing adventures. This includes classes
for performing address translations, coloring marks or tags,
recursively walking through basic blocks until a sentinel
block has been reached, or even recursively walking a
function's childrens until a particular sentinel function
is encountered.

The tools defined within here are unorganized and pretty
much unmaintained. Thus they may shift around during their
existence as they eventually find their place.
"""

import six, sys, logging, builtins
import functools, operator, itertools, types
import logging

import database, function as func, instruction, segment
import ui, internal

def map(F, **kwargs):
    """Execute the callback `F` on all functions in the database. Synonymous to `map(F, database.functions())` but with some extra logging to display the current progress.

    The `F` parameter is defined as a function taking either an
    `(address, **kwargs)` or a `(index, address, **kwargs)`. Any
    keyword arguments are passed to `F` unmodified.
    """
    f1 = lambda idx, ea, **kwargs: F(ea, **kwargs)
    f2 = lambda idx, ea, **kwargs: F(idx, ea, **kwargs)
    Ff = internal.utils.pycompat.method.function(F) if isinstance(F, types.MethodType) else F
    Fc = internal.utils.pycompat.function.code(Ff)
    f = f1 if internal.utils.pycompat.code.argcount(Fc) == 1 else f2

    result, all = [], database.functions()
    total = len(all)
    if len(all):
        ea = next(item for item in all)
        try:
            for i, ea in enumerate(all):
                ui.navigation.set(ea)
                six.print_("{:#x}: processing # {:d} of {:d} : {:s}".format(ea, 1 + i, total, func.name(ea)))
                result.append( f(i, ea, **kwargs) )
        except KeyboardInterrupt:
            six.print_("{:#x}: terminated at # {:d} of {:d} : {:s}".format(ea, 1 + i, total, func.name(ea)))
    return result

# For poor folk without a dbgeng
class remote(object):
    """
    An object that can be used to translate addresses to and from
    a debugging target so that one does not need to rebase their
    entire database, or come up with some other tricks to translate
    a binary address to its runtime address.
    """
    def __init__(self, remote, local=None):
        """Create a new instance with the specified `remote` base address.

        If `local` is not specified, then use the current database's base
        address for performing calculations.
        """
        if local is None:
            local = database.config.baseaddress()
        self.lbase = local
        self.rbase = remote

    def get(self, ea):
        '''Translate a remote address to the local database address.'''
        offset = ea - self.rbase
        return offset + self.lbase

    def put(self, ea):
        '''Translate a local database address to the remote address.'''
        offset = ea - self.lbase
        return offset + self.rbase

    def go(self, ea):
        '''Seek the database to the specified remote address.'''
        res = self.get(ea)
        database.go(res)

## XXX: would be useful to have a quick wrapper class for interacting with Ida's mark list
##          in the future, this would be abstracted into a arbitrarily sized tree.

def colormarks(color=0x7f007f):
    """Walk through the current list of marks whilst coloring them with the specified `color`.

    Each mark's address is tagged with its description, and if the
    address belongs to a function, the function is also tagged with the
    address of the marks that it contains.
    """
    # tag and color
    f = {item for item in []}
    for ea, m in database.marks():
        database.tag(ea, 'mark', m)
        if database.color(ea) is None:
            database.color(ea, color)
        try:
            f.add(func.top(ea))
        except internal.exceptions.FunctionNotFoundError:
            pass
        continue

    # tag the functions too
    for ea in f:
        m = func.marks(ea)
        func.tag(ea, 'marks', [ea for ea, _ in m])
    return

def recovermarks():
    """Walk through the tags made by ``colormarks`` and re-create the marks that were found.

    This is useful if any marks were accidentally deleted and can be used for
    recovering them as long as they were initally tagged properly.
    """
    # collect
    result = []
    for fn, l in database.select('marks'):
        m = {item for item in l['marks']} if hasattr(l['marks'], '__iter__') else {int(item, 16) for item in l['marks'].split(',')} if isinstance(l['marks'], six.string_types) else {l['marks']}
        res = [(ea, d['mark']) for ea, d in func.select(fn, 'mark')]
        if m != { ea for ea, _ in res }:
            logging.warning("{:s} : Ignoring the function tag \"{:s}\" for function {:#x} due to its value being out-of-sync with the contents values ({!s} <> {!s}).".format('.'.join([__name__, 'recovermarks']), fn, builtins.map("{:#x}".format, m), builtins.map("{:#x}".format, {ea for ea, _ in res})))
        result.extend(res)
    result.sort(key=lambda item: item[1])

    # discovered marks versus database marks
    result = {ea : item for ea, item in result.items()}
    current = {ea : descr for ea, descr in database.marks()}

    # create tags
    for x, y in result.items():
        if x in current:
            logging.warning("{:#x}: skipping already existing mark : {!r}".format(x, current[x]))
            continue

        # x not in current
        if x not in current:
            logging.info("{:#x}: adding missing mark due to tag : {!r}".format(x, result[x]))
        elif current[x] != result[x]:
            logging.info("{:#x}: database tag is different than mark description : {!r}".format(x, result[x]))
        else:
            assert current[x] == result[x]
        database.mark(x, y)

    # marks that aren't reachable in the database
    for ea in { item for item in current.keys() }.difference({item for item in result.keys()}):
        logging.warning("{:#x}: unreachable mark (global) : {!r}".format(ea, current[ea]))

    # color them
    colormarks()

def checkmarks():
    """Emit all functions that contain more than 1 mark within them.

    As an example, if marks are used to keep track of backtraces then
    this tool will emit where those backtraces intersect.
    """
    listable = []
    for a, m in database.marks():
        try:
            listable.append((func.top(a), a, m))
        except internal.exceptions.FunctionNotFoundError:
            pass
        continue

    d = listable[:]
    d.sort(key=lambda item: item[0])

    flookup = {}
    for fn, a, m in d:
        try:
            flookup[fn].append((a, m))
        except:
            flookup[fn] = [(a, m)]
        continue

    functions = [ (k, v) for k, v in flookup.items() if len(v) > 1 ]
    if not functions:
        logging.warning('There are no functions available containing multiple marks.')
        return

    for k, v in functions:
        six.print_("{:#x} : in function {:s}".format(k, func.name(func.by_address(k))), file=sys.stdout)
        six.print_('\n'.join(("- {:#x} : {:s}".format(a, m) for a, m in sorted(v))), file=sys.stdout)
    return

def collect(ea, sentinel):
    """Collect all the basic blocks starting at address `ea` and recurse until a terminating block is encountered.

    If the set `sentinel` is specified, then its addresses are used as
    sentinel blocks and collection will terminate when those blocks are
    reached.
    """
    if isinstance(sentinel, (list, tuple)):
        sentinel = {item for item in sentinel}
    if not all((sentinel, isinstance(sentinel, set))):
        raise AssertionError("{:s}.collect({:#x}, {!r}) : Sentinel is empty or not a set.".format(__name__, ea, sentinel))
    def _collect(addr, result):
        process = {item for item in []}
        for blk in builtins.map(func.block, func.block.after(addr)):
            if any(blk in coll for coll in [result, sentinel]):
                continue
            process.add(blk)
        for addr, _ in process:
            result |= _collect(addr, result | process)
        return result
    addr, _ = blk = func.block(ea)
    return _collect(addr, {blk})

def collectcall(ea, sentinel=set()):
    """Collect all of the function calls starting at function `ea` and recurse until a terminating function is encountered.

    If the set `sentinel` is specified, then its addresses are used as
    sentinel functions and collection will terminate when one of those
    functions are reached.
    """
    if isinstance(sentinel, (list, tuple)):
        sentinel = {item for item in sentinel}
    if not isinstance(sentinel, set):
        raise AssertionError("{:s}.collectcall({:#x}, {!r}) : Sentinel is not a set.".format(__name__, ea, sentinel))
    def _collectcall(addr, result):
        process = {item for item in []}
        for f in func.down(addr):
            if any(f in coll for coll in [result, sentinel]):
                continue
            if not func.within(f):
                logging.warning("{:s}.collectcall({:#x}, {!r}) : Adding non-function address {:#x} ({:s}).".format(__name__, ea, sentinel, f, database.name(f)))
                result.add(f)
                continue
            process.add(f)
        for addr in process:
            result |= _collectcall(addr, result | process)
        return result
    addr = func.top(ea)
    return _collectcall(addr, {addr})

# FIXME: Don't emit the +0 if offset is 0
def above(ea, includeSegment=False):
    '''Return all of the function names and their offset that calls the function at `ea`.'''
    tryhard = lambda ea: "{:s}{:+x}".format(func.name(func.top(ea)), ea - func.top(ea)) if func.within(ea) else "{:+x}".format(ea) if func.name(ea) is None else func.name(ea)
    return '\n'.join(':'.join([segment.name(ea), tryhard(ea)] if includeSegment else [tryhard(ea)]) for ea in func.up(ea))

# FIXME: Don't emit the +0 if offset is 0
def below(ea, includeSegment=False):
    '''Return all of the function names and their offset that are called by the function at `ea`.'''
    tryhard = lambda ea: "{:s}{:+x}".format(func.name(func.top(ea)), ea - func.top(ea)) if func.within(ea) else "{:+x}".format(ea) if func.name(ea) is None else func.name(ea)
    return '\n'.join(':'.join([segment.name(ea), tryhard(ea)] if includeSegment else [tryhard(ea)]) for ea in func.down(ea))

# FIXME: this only works on x86 where args are pushed via stack
def makecall(ea=None, target=None):
    """Output the function call at `ea` and its arguments with the address they originated from.

    If `target` is specified, then assume that the instruction is
    calling `target` instead of the target address that the call
    is referencing.
    """
    ea = current.address() if ea is None else ea
    if not func.contains(ea, ea):
        return None

    if database.config.bits() != 32:
        raise RuntimeError("{:s}.makecall({!r}, {!r}) : Unable to determine arguments for {:s} due to {:d}-bit calling convention.".format(__name__, ea, target, database.disasm(ea), database.config.bits()))

    if target is None:
        # scan down until we find a call that references something
        chunk, = ((l, r) for l, r in func.chunks(ea) if l <= ea <= r)
        result = []
        while (len(result) < 1) and ea < chunk[1]:
            # FIXME: it's probably not good to just scan for a call
            if not database.instruction(ea).startswith('call '):
                ea = database.next(ea)
                continue
            result = database.cxdown(ea)
            if len(result) == 0: raise TypeError("{:s}.makecall({!r}, {!r}) : Unable to determine number of arguments.".format(__name__, ea, target))

        if len(result) != 1:
            raise ValueError("{:s}.makecall({!r}, {!r}) : An invalid number of targets was returned for the call at {:#x}. The call targets that were returned are {!r}.".format(__name__, ea, result))
        fn, = result
    else:
        fn = target

    try:
        result = []
        for offset, name, size in func.arguments(fn):
            left = database.address.prevstack(ea, offset + database.config.bits() // 8)
            # FIXME: if left is not an assignment or a push, find last assignment
            result.append((name, left))
    except internal.exceptions.OutOfBoundsError:
        raise internal.exceptions.OutOfBoundserror("{:s}.makecall({!r}, {!r}) : Unable to get arguments for target function.".format(__name__, ea, target))

    # FIXME: replace these crazy list comprehensions with something more comprehensible.
#    result = ["{:s}={:s}".format(name, instruction.op_repr(ea, 0)) for name, ea in result]
    result = ["({:#x}){:s}={:s}".format(ea, name, ':'.join(instruction.op_repr(database.address.prevreg(ea, instruction.op_value(ea, 0), write=True), n) for n in instruction.opsi_read(database.address.prevreg(ea, instruction.op_value(ea, 0), write=True))) if instruction.op_type(ea, 0) == 'reg' else instruction.op_repr(ea, 0)) for name, ea in result]

    try:
        return "{:s}({:s})".format(internal.declaration.demangle(func.name(func.by_address(fn))), ','.join(result))
    except:
        pass
    return "{:s}({:s})".format(internal.declaration.demangle(database.name(fn)), ','.join(result))

```

`tools/tagfix.py`:

```py
"""
Tagfix module

This module is provided to a user to allow one to rebuild the
cache that is built when a database is finished processing. If
the cache is corrupted through some means, this module can be
used to rebuild the tag-cache by manually scanning the currently
defined tags and resetting its references in order to allow one
to query again.

To manually rebuild the cache for the database, use the following::

    > tools.tagfix.everything()

Likewise to rebuild the cache for just the globals or the contents::

    > tools.tagfix.globals()
    > tools.tagfix.contents()

"""

import six, sys, logging, builtins
import functools, operator, itertools, types

import database as db, function as func, ui
import internal

import idaapi
output = sys.stderr

def fetch_contents(fn):
    """Fetch the number of references for the contents of function `fn` from the database.

    Returns the tuple `(function, address, tags)` where the `address` and
    `tags` items are both dictionaries containing the number of references
    for the addresses and tag names. The `function` item contains the address
    of the function whose references were counted.
    """
    address, tags = {}, {}

    for ea in map(ui.navigation.analyze, func.iterate(fn)):
        items = db.tag(ea)

        # tally up all of the reference counts from the dictionary that we
        # fetched for the current address we're iterating through.
        for name in items:
            address[ea] = address.get(ea, 0) + 1
            tags[name] = tags.get(name, 0) + 1
        continue
    return func.address(fn), address, tags

def fetch_globals_functions():
    """Fetch the number of references for all of the global tags (functions) from the database.

    Returns the tuple `(address, tags)` where the `address` and `tags` items
    are both dictionaries containing the number of references for both
    addresses and tag names for each function from the database.
    """
    address, tags = {}, {}
    functions = [item for item in db.functions()]
    for i, ea in enumerate(map(ui.navigation.analyze, functions)):
        items = func.tag(ea)
        six.print_(u"globals: counting the tags assigned to function {:#x} : {:d} of {:d}".format(ea, 1 + i, len(functions)), file=output)

        # iterate through all of the items in the tags that we decoded, and
        # tally up their keys in order to return their reference count.
        # them. once decoded then we can just iterate through their keys and
        for name in items:
            address[ea] = address.get(ea, 0) + 1
            tags[name] = tags.get(name, 0) + 1
        continue
    return address, tags

def fetch_globals_data():
    """Fetch the number of references for all of the global tags (non-functions) from the database.

    Returns a tuple `(address, tags)` where the `address` and `tags` items
    are both dictionaries containing the number of references for both
    addresses and tag names for every non-function in the database.
    """
    address, tags = {}, {}
    left, right = db.config.bounds()
    six.print_(u'globals: counting any tags that are assigned to global data', file=output)
    for ea in map(ui.navigation.analyze, db.address.iterate(left, right)):
        if func.within(ea):
            continue
        items = db.tag(ea)

        # after grabbing the tags for the current address we're iterating
        # through, tally up the number of keys and their values.
        for name in items:
            address[ea] = address.get(ea, 0) + 1
            tags[name] = tags.get(name, 0) + 1
        continue
    return address, tags

def fetch_globals():
    """Fetch the number of references for all of the global tags associated with both functions and non-functions from the database.

    Returns the tuple `(address, tags)` where the `address` and `tags`
    items are both dictionaries containing the number of references
    for both addresses and tag names.
    """
    # Read both the address and tags from all functions and globals.
    faddr, ftags = fetch_globals_functions()
    daddr, dtags = fetch_globals_data()

    # Consolidate tags into individual dictionaries.
    six.print_(u'globals: tallying up the database tags for building the index', file=output)

    address, tags = {}, {}
    for results, item in itertools.chain(zip(2 * [address], [faddr, daddr]), zip(2 * [tags], [ftags, dtags])):
        matching = {ea for ea in results} & {ea for ea in item}
        missing = {ea for ea in item} - {ea for ea in results}

        # Update all of the keys that aren't in both our results
        # and our items, and add up the ones that are.
        results.update({ea : item[ea] for ea in missing})
        results.update({ea : results[ea] + item[ea] for ea in matching})

    # Output our results to the specified output.
    six.print_(u"globals: found {:d} addresses to include in index".format(len(address)), file=output)
    six.print_(u"globals: found {:d} tags to include in index".format(len(tags)), file=output)
    return address, tags

def contents(ea):
    '''Generate the cache for the contents of the function `ea`.'''
    try:
        func.address(ea)
    except internal.exceptions.FunctionNotFoundError:
        logging.warning(u"{:s}.contents({:#x}): Unable to fetch cache the for the address {:#x} as it is not a function.".format('.'.join([__name__]), ea, ea))
        return {}, {}

    # Read the addresses and tags from the contents of the function.
    logging.debug(u"{:s}.contents({:#x}): Fetching the cache for the function {:#x}.".format('.'.join([__name__]), ea, ea))
    f, address, tags = fetch_contents(ui.navigation.procedure(ea))

    # Update the addresses and tags for the contents of the function.
    ui.navigation.set(ea)
    logging.debug(u"{:s}.contents({:#x}): Updating the name references in the cache belonging to function {:#x}.".format('.'.join([__name__]), ea, ea))
    for k, v in tags.items():
        internal.comment.contents.set_name(f, k, v, target=f)

    logging.debug(u"{:s}.contents({:#x}): Updating the address references in the cache belonging to function {:#x}.".format('.'.join([__name__]), ea, ea))
    for k, v in address.items():
        if not func.within(k):
            continue
        internal.comment.contents.set_address(k, v, target=f)

    return address, tags

def globals():
    '''Build the index of references for all of the globals in the database.'''

    # Read all of the data tags for each function and address.
    address, tags = fetch_globals()

    # Update the the index containing the address and tags we counted.
    six.print_(u'globals: updating the name references in the index for the database', file=output)
    for k, v in tags.items():
        internal.comment.globals.set_name(k, v)

    six.print_(u'globals: updating the address references in the index for the database', file=output)
    for k, v in address.items():
        internal.comment.globals.set_address(k, v)

    return address, tags

def all():
    '''Build the index of references for all the globals and generate the caches for every function in the database.'''
    functions = [item for item in db.functions()]

    # process all function contents tags
    for i, ea in enumerate(functions):
        six.print_(u"updating the cache for the tags belonging to function ({:#x}) : {:d} of {:d}".format(ea, 1 + i, len(functions)), file=output)
        _, _ = contents(ea)

    # process all global tags
    six.print_(u'updating the index for the database with references for all globals', file=output)
    _, _ = globals()

def customnames():
    '''Iterate through all of the "custom" names within the database and update their references in either the index or their associated function cache.'''
    # FIXME: first delete all the custom names '__name__' tag
    left, right = db.config.bounds()
    for ea in db.address.iterate(left, right):
        ctx = internal.comment.contents if func.within(ea) and func.address(ea) != ea else internal.comment.globals
        if db.type.has_customname(ea):
            ctx.inc(ea, '__name__')
        continue
    return

def extracomments():
    '''Iterate through all of the "extra" comments within the database and update their references in either the index or their associated function cache.'''
    left, right = db.config.bounds()
    for ea in db.address.iterate(left, right):
        ctx = internal.comment.contents if func.within(ea) else internal.comment.globals

        count = db.extra.__count__(ea, idaapi.E_PREV)
        if count: [ ctx.inc(ea, '__extra_prefix__') for i in range(count) ]

        count = db.extra.__count__(ea, idaapi.E_NEXT)
        if count: [ ctx.inc(ea, '__extra_suffix__') for i in range(count) ]
    return

def everything():
    '''Rebuild the index for all of the globals and the cache for each function from the database.'''
    erase()
    all()

def erase_globals():
    '''Remove the contents of the index from the database which is used for storing information about the global tags.'''
    node = internal.comment.tagging.node()
    hashes, alts, sups = map(list, (iterator(node) for iterator in [internal.netnode.hash.fiter, internal.netnode.alt.fiter, internal.netnode.sup.fiter]))
    total = sum(map(len, [hashes, alts, sups]))

    yield total

    current = 0
    for idx, k in enumerate(hashes):
        internal.netnode.hash.remove(node, k)
        yield current + idx, k

    current += len(hashes)
    for idx, ea in enumerate(sups):
        internal.netnode.sup.remove(node, ea)
        yield current + idx, ea

    current += len(sups)
    for idx, ea in enumerate(alts):
        internal.netnode.alt.remove(node, ea)
        yield current + idx, ea
    return

def erase_contents():
    '''Remove the cache associated with each function from the database.'''
    functions = [item for item in db.functions()]
    total, tag = len(functions), internal.comment.contents.btag
    yield total

    for idx, ea in enumerate(map(ui.navigation.set, functions)):
        internal.netnode.blob.remove(ea, tag)
        yield idx, ea
    return

def erase():
    '''Erase the index of all the globals and the cache associated with each function from the database.'''
    iter1, iter2 = erase_contents(), erase_globals()
    total = sum(map(next, [iter1, iter2]))

    current = 0
    for idx, ea in iter1:
        six.print_(u"removing the cache for function {:#x} : {:d} of {:d}".format(ea, 1 + idx, total), file=output)

    res = idx + 1
    for idx, addressOrName in iter2:
        format = "address {:#x}".format if isinstance(addressOrName, six.integer_types) else "tagname {!r}".format
        six.print_(u"removing the global {:s} from the index : {:d} of {:d}".format(format(addressOrName), 1 + res + idx, total), file=output)
    return

def verify_index():
    '''Iterate through the index and verify that each contents entry is pointing at the right functions.'''
    cls, ok = internal.comment.contents, True

    # Iterate through the entire index of contents.
    for ea, available in cls.iterate():
        if not func.within(ea):
            ok, _ = False, six.print_(u"[{:#x}] the item in the index ({:#x}) has been orphaned and is not associated with a function".format(ea, ea), file=output)
            continue

        # Verify the owner of the address the cache is stored in
        # actually belongs to the correct function.
        f = ui.navigation.analyze(func.address(ea))
        if f != ea:
            ok, _ = False, six.print_(u"[{:#x}] the item has the wrong parent ({:#x}) and should be owned by {:#x}".format(ea, ea, f), file=output)
            continue

        # Verify the keys inside the cache are only ones that we know about.
        expected = {key for key in [cls.__tags__, cls.__address__]}
        keys = {key for key in available}
        if keys - expected:
            ok, _ = False, six.print_(u"[{:#x}] the index item for this function contains unsupported keys ({:s})".format(ea, ', '.join(sorted(keys - expected))), file=output)
            continue

        # Make sure that both keys are contained within the cache.
        if keys != expected:
            ok, _ = False, six.print_(u"[{:#x}] the index item for this function contains keys ({:s}) that do not match the requirements ({:s})".format(ea, ', '.join(keys), ', '.join(expected)), file=output)
        continue
    return ok

def verify_content(ea):
    '''Iterate through the contents cache for an individual function and verify that the addresses in its cache are correct.'''
    cls = internal.comment.contents
    try:
        cache = cls._read(ea, ea)

    # We should be within a function, otherwise this can't be verified.
    except internal.exceptions.FunctionNotFoundError:
        six.print_(u"[{:#x}] unable to read the cache for the requested address {:#x}".format(ea, ea), file=output)
        return False

    # If there was no cache, then we can just immediately return.
    if cache is None:
        six.print_(u"[{:#x}] the requested address ({:#x}) does not contain a cache".format(ea, ea), file=output)
        return False

    # Grab the keys from the cache in order to cross-check them.
    expected, available = {key for key in [cls.__tags__, cls.__address__]}, {key for key in cache}

    # Verify that the keys in our cache match what we expect.
    if available - expected:
        six.print_(u"[{:#x}] the cache at {:#x} contains unsupported keys ({:s})".format(ea, ea, ', '.join(sorted(available - expected))), file=output)
        return False

    # Ensure that the cache definitely contains the keys we expect.
    if available != expected:
        six.print_(u"[{:#x}] the cache at {:#x} contains keys ({:s}) that do not meet the requirements ({:s})".format(ea, ea, ', '.join(available), ', '.join(expected)), file=output)
        return False

    # If we're not within a function, then we need to bail because
    # the next tests can't possibly succeed.
    if not func.within(ea):
        six.print_(u"[{:#x}] the cache at {:#x} is not part of a function".format(ea, ea), file=output)
        return False
    f = func.address(ea)

    # If we verify that the addresses in the cache are all within the
    # function that the cache is associated with, then we're done.
    if not builtins.all(func.contains(f, item) for item in cache[cls.__address__]):
        missed = {item for item in cache[cls.__address__] if not func.contains(f, item)}
        six.print_(u"[{:#x}] the cache references {:d} address{:s} that are not owned by function {:#x}".format(ea, len(missed), '' if len(missed) == 1 else 'es', f), file=output)

        # Otherwise, some of the addresses are pointing to the wrong place.
        for index, item in enumerate(sorted(missed)):
            six.print_(u"[{:#x}] item {:d} of {:d} at {:#x} should be owned by {:#x} but {:s}".format(ea, 1 + index, len(missed), item, f, "is in {:#x}".format(func.address(item)) if func.within(item) else 'is not in a function'), file=output)
        return False

    # Iterate through the cache for a function and store all of the tags
    # that are available for each address. We also keep track of the implicit
    # tags because we're going to do some quirky things to adjust for them.
    results, implicit = {}, {key : [] for key in ['__typeinfo__', '__name__']}
    for ea in cache[cls.__address__]:
        items, empty = {key for key in db.tag(ea)}, {item for item in []}
        for name in items:
            results.setdefault(ea, empty).add(name)

        # Find the intersection of our tags with the keys for the implicit
        # tags so that we can remember their addresses and query them later.
        for name in {key for key in implicit} & items:
            implicit[name].append(ea)
        continue

    # Sanity check the addresses in our implicit collection as we convert
    # them into a set for a quick membership test. This shouldn't happen,
    # but when verifying things without having to worry about performance
    # cost I don't think it causes too much pain.
    for key in implicit:
        items = {item for item in implicit[key]}
        if len(items) != len(implicit[key]):
            counts = {ea : len([ea for ea in group]) for ea, group in itertools.groupby(implicit[key])}
            six.print_(u"[{:#x}] duplicate addresses were discovered for implicit tag {!r} at: {:s}".format(f, key, ', '.join(ea for ea, count in counts if count > 1)), file=output)
        implicit[key] = items

    # Now we need to do some quirky things to handle some of the implicit
    # tags that are associated with the first address.
    for key, locations in implicit.items():
        count = cache[cls.__tags__].get(key, 0)

        # If the number of locations does not match up to the reference
        # count in the cache, then we also discard as it doesn't match up.
        if operator.contains(locations, f) and len(locations) > count:
            results[f].discard(key)
            continue
        continue

    # Last thing to do is to convert the results that we fixed up into
    # actual counts so that we can check them individually.
    tags, address = {}, {}
    for ea, keys in results.items():
        count = 0
        for item in keys:
            tags[item] = tags.get(item, 0) + 1
            count += 1
        address[ea] = count

    # First we'll verify the address counts.
    expected, available = {ea for ea in cache[cls.__address__]}, {ea for ea in address}
    if expected != available:
        additional, missing = sorted(available - expected), sorted(expected - available)
        six.print_(u"[{:#x}] the address cache for {:#x} is desynchronized and {:s} addresses...".format(f, f, "contains {:d} additional and {:d} missing".format(len(additional), len(missing)) if additional and missing else "is missing {:d}".format(len(missing)) if missing else "has {:d} additional".format(len(additional))), file=output)
        if additional:
            six.print_(u"[{:#x}] ...the additional addresses are: {:s}".format(f, ', '.join(map("{:#x}".format, additional))), file=output)
        if missing:
            six.print_(u"[{:#x}] ...the addresses that are missing are: {:s}".format(f, ', '.join(map("{:#x}".format, missing))), file=output)
        return False

    # Then we'll verify the tag names.
    expected, available = {key for key in cache[cls.__tags__]}, {key for key in tags}
    if expected != available:
        additional, missing = sorted(available - expected), sorted(expected - available)
        six.print_(u"[{:#x}] the name cache for {:#x} is desynchronized and {:s} keys...".format(f, f, "contains {:d} additional and {:d} missing".format(len(additional), len(missing)) if additional and missing else "is missing {:d}".format(len(missing)) if missing else "has {:d} additional".format(len(additional))), file=output)
        if additional:
            six.print_(u"[{:#x}] ...the additional keys are: {:s}".format(f, ', '.join(map("{!r}".format, additional))), file=output)
        if missing:
            six.print_(u"[{:#x}] ...the keys that are missing are: {:s}".format(f, ', '.join(map("{!r}".format, missing))), file=output)
        return False

    # If those were all right, then all critical checks are complete and we
    # can check on the reference counts. Starting with the tag names...
    for key in expected & available:
        expected = cache[cls.__tags__]
        if expected[key] != tags[key]:
            six.print_(u"[{:#x}] expected to find {:d} reference{:s} to tag {!r}, whereas {:s} found within the function".format(f, expected[key], '' if expected[key] == 1 else 's', key, "{:d} was".format(tags[key]) if tags[key] == 1 else "{:d} were".format(tags[key])), file=output)
        continue

    # Now we can compare the address reference counts.
    expected, available = {ea for ea in cache[cls.__address__]}, {ea for ea in address}
    for ea in map(ui.navigation.analyze, expected & available):
        count, expected = address[ea], cache[cls.__address__]

        # This should compare exactly. So if the count doesn't match, let someone know.
        if count != expected[ea]:
            six.print_(u"[{:#x}] expected to find {:d} reference{:s} to address {:#x}, whereas {:s} found within the function".format(f, expected[ea], '' if expected[ea] == 1 else 's', ea, "{:d} was".format(count) if count == 1 else "{:d} were".format(count)), file=output)
        continue
    return True

def verify_globals():
    '''Verify the globals for every address from the database.'''
    cls = internal.comment.globals

    # Calculate all the possible combinations for the implicit tags so that
    # we can use them to figure out which variation will match.
    implicit = {item for item in ['__typeinfo__', '__name__', '__extra_prefix__', '__extra_suffix__']}
    combinations = [{item for item in combination} for combination in itertools.chain(*(itertools.combinations(implicit, length) for length in range(1 + len(implicit))))]
    unique = {item for item in map(tuple, combinations)}
    available = sorted({item for item in items} for items in unique)
    ok, counts, results = True, {}, {}

    # Iterate through the index for the globals and tally up the counts
    # of each tag at the given address. We default with db.tag to fetch
    # them and switch it up only if a function is detected.
    for ea, count in cls.iterate():
        Ftags = db.tag

        # First figure out how to validate the address. If it's a function,
        # then we can use func.address.
        if func.within(ea):
            f = func.address(ea)
            if f != ea:
                six.print_(u"[{:#x}] the item in the global index ({:#x}) is not at the beginning of a function ({:#x})".format(ea, ea, f), file=output)

            # We can now force the address to point to the actual function
            # address because func.tag will correct this anyways.
            ea, Ftags = f, func.tag

        # In this case we must be a global and we need to use a combination
        # of database.contains, and then interface.address.head.
        elif not db.within(ea):
            ok, _ = False, six.print_(u"[{:#x}] the item in the global index ({:#x}) is not within the boundaries of the database".format(ea, ea), file=output)
            continue

        # If we're in the bounds of the database, then we can always succeed
        # as db.tag will correct the address regardless of what we do.
        elif internal.interface.address.head(ea, silent=True) != ea:
            six.print_(u"[{:#x}] the item in the global index ({:#x}) is not pointing at the head of its address ({:#x})".format(ea, ea, internal.interface.address.head(ea, silent=True)), file=output)

        # Now we can align its address and count the number of tags.
        ea = internal.interface.address.head(ui.navigation.set(ea), silent=True)
        expected = {tag for tag in Ftags(ea)}

        # When we do this, we have to figure out whether the implicit tags
        # were actually indexed which we accomplish by generating all possible
        # combinations and figuring out which one is the right one.
        matches = [combination for combination in available if combination & expected == combination]
        if count in {len(expected - match) for match in matches}:
            candidates = [match for match in matches if len(expected - match) == count]
            logging.debug(u"{:s}.verify_globals(): Found {:d} candidate{:s} for the tags ({:s}) belonging to the {:s} at {:#x} that would result in a proper count of {:d} reference{:s}.".format('.'.join([__name__]), len(candidates), '' if len(candidates) == 1 else 's', ', '.join(map("{!r}".format, expected)), 'function' if func.within(ea) else 'address', ea, count, '' if count == 1 else 's'))
            format = functools.partial(u"{:s}.verify_globals(): ...Candidate #{:d} would remove {:s}{:s} resulting in: {:s}.".format, '.'.join([__name__]))
            [logging.debug(format(1 + index, "{:d} tag".format(len(listable)) if len(listable) == 1 else "{:d} tags".format(len(listable)), ", {:s}{:s}".format(', '.join(map("{!r}".format, listable[:-1])), ", and {!r},".format(*listable[-1:]) if len(listable) > 1 else ", {!r},".format(*listable)) if listable else '', ', '.join(map("{!r}".format, expected - candidate)))) for index, (candidate, listable) in enumerate(zip(candidates, map(sorted, candidates)))]

        # If the count wasn't in our list of possible matches, then this address
        # has a bunk reference count and we need to explain the to the user.
        else:
            # FIXME: Make sure this it outputting the results properly.
            smallest, largest = min(available, key=len) if available else {item for item in []}, max(available, key=len) if available else {item for item in []}
            if len(largest) == len(smallest):
                format = "{:d} reference".format if len(expected) == 1 else "{:d} references".format
            elif len(largest) > len(smallest):
                format = "{:d} to {:d} references".format if len(largest) - len(smallest) > 0 and len(expected) > 0 else "{:d} references".format
            else:
                format = "{:d} references".format
            ok, _ = False, six.print_(u"[{:#x}] expected to find {:d} reference{:s} at {:s} {:#x}, but found {:s} instead".format(ea, count, '' if count == 1 else 's', 'function' if func.within(ea) else 'address', ea, format(len(expected - largest), len(expected - smallest))))

        # First tally up all of the counts that aren't affected by implicit tags.
        for key in expected - implicit:
            counts[key] = counts.get(key, 0) + 1

        # Now we need to tally the implicit tags for the given address. We key
        # this by the index of the available combinations so that we have multiple
        # counts for each set of implicit tags that we can later compare.
        for index, choice in enumerate(available):
            for key in expected & choice:
                candidates = results.setdefault(key, {})
                candidates[index] = candidates.get(index, 0) + 1
            continue
        continue

    # That was everything, now we just got to verify our global number of
    # references for each specific tag that isn't implicit.
    references = {key : count for key, count in cls.counts()}
    tags = {tag for tag in references}
    for key in tags - implicit:
        count = references[key]
        if key not in counts:
            ok, _ = False, six.print_(u"[{:s}] unable to locate the referenced tag ({!r}) in the database index".format(key, key))
        elif count != counts[key]:
            ok, _ = False, six.print_(u"[{:s}] expected to find {:d} reference{:s} for the explicit tag {!r}, whereas {:s} found within the database.".format(key, count, '' if count == 1 else 's', key, "{:d} was".format(counts[key]) if counts[key] == 1 else "{:d} were".format(counts[key])), file=output)
        continue

    # The very last thing to do is to verify the tag counts for the implicit
    # tags. This requires us to go through the results and find an index that
    # matches what was written into the global index.
    for key in tags & implicit:
        count, candidates = references[key], {candidate for _, candidate in results.get(key, {}).items()}
        logging.debug(u"{:s}.verify_globals(): Found {:d} candidate{:s} ({:s}) for the implicit tag ({!r}) while searching for a count of {:d}.".format('.'.join([__name__]), len(candidates), '' if len(candidates) == 1 else 's', ', '.join(map("{:d}".format, sorted(candidates))), key, count))
        if not candidates:
            ok, _ = False, six.print_(u"[{:s}] unable to locate the referenced implicit tag ({!r}) in the database index".format(key, key))
        elif not operator.contains(candidates, count):
            ok, _ = False, six.print_(u"[{:s}] expected to find {:d} reference{:s} for the implicit tag ({!r}) in the list of candidates ({:s})".format(key, count, '' if count == 1 else 's', key, ', '.join(map("{:d}".format, candidates))), file=output)
        continue
    return ok

def verify_contents():
    '''Verify the contents of every single function in the index.'''
    index = sorted({ea for ea, _ in internal.comment.contents.iterate()})

    # Verify the index as the very first thing.
    ok = verify_index()
    if not ok:
        six.print_(u'some issues were found within the index... ignoring them and proceeding to verify each cache referenced by the index', file=output)

    # Now we can iterate through the index and process each function's contents.
    i = count = 0
    for i, ea in enumerate(index):
        ok = verify_content(ui.navigation.set(ea))
        count += 1 if ok else 0
    return count, len(index)

def verify():
    '''Use the index to verify the reference counts for the globals, functions, and the caches containing their contents.'''
    verified, available = verify_contents()
    ok = verify_globals()
    six.print_(u"Verification of globals has {:s}. Successfully verified{:s} {:d} of {:d} indexed functions.".format('succeeded' if ok else 'failed', ' only' if verified < available else '', verified, available))
    return ok and verified == available

__all__ = ['everything', 'globals', 'contents']

```

`tools/tags.py`:

```py
"""
Tags module

This module exposes tools for exporting the currently defined tags
within the database. Once exported, these tags can then be pickled
or then re-applied to the same or another database. Some options
are allowed which will let a user apply translations to the tags
before applying them to a target database.

To fetch all of the tags from the database::

    > res = tools.tags.read()

To export only specific tags from the database::

    > res = tools.tags.export('tag1', 'tag2', ...)

To apply previously read tags to the database::

    > tools.tags.apply(res)

To apply previously read tags with different names to the database::

    > tools.tags.apply(res, tag1='my_tag1', tag2='my_tag2', ...)

"""

import six, sys, logging, builtins
import functools, operator, itertools, types, string

import database as db, function as func, structure as struc, ui
import internal

output = sys.stderr

### miscellaneous tag utilities
def list():
    '''Return the tags for the all of the function contents within the database as a set.'''
    return {res for res in itertools.chain(*(res for _, res in db.selectcontents()))}

### internal utility functions and classes
def lvarNameQ(name):
    '''Determine whether a `name` is something that IDA named automatically.'''
    if any(name.startswith(item) for item in ['arg_', 'var_']):
        res = name.split('_', 1)[-1]
        return all(item in string.hexdigits for item in res)
    elif name.startswith(' '):
        return name[1:] in {'s', 'r'}
    return False

def locationToAddress(loc):
    '''Convert the function location `loc` back into an address.'''

    ## if location is a tuple, then convert it to an address
    if isinstance(loc, tuple):
        f, cid, ofs = loc
        base, _ = next(b for i, b in enumerate(func.chunks(f)) if i == cid)
        return base + ofs

    ## otherwise, it's already an address
    return loc

def addressToLocation(ea, chunks=None):
    """Convert the address `ea` to a `(function, id, offset)`.

    The fields `id` and `offset` represent the chunk index and the
    offset into the chunk for the function at `ea`. If the list
    `chunks` is specified as a parameter, then use it as a tuple
    of ranges in order to calculate the correct address.
    """
    F, chunks = func.by(ea), chunks or [ch for ch in func.chunks(ea)]
    cid, base = next((i, l) for i, (l, r) in enumerate(chunks) if l <= ea < r)
    return func.top(F), cid, ea - base

class dummy(object):
    """
    A dummy object that is guaranteed to return False whenever it is compared
    against anything.
    """
    def __eq__(self, other): return False
    def __cmp__(self, other): return -1
dummy = dummy()

### read without using the tag cache
class read(object):
    """
    This namespace contains tools that can be used to manually read
    tags out of the database without using the cache.

    If `location` is specified as true, then read each contents tag
    according to its location rather than an address. This allows one
    to perform a translation of the tags in case the function chunks
    are at different addresses than when the tags were read.
    """

    def __new__(cls, location=False):
        '''Read all of the tags defined within the database.'''
        return cls.everything(location=location)

    ## reading the content from a function
    @classmethod
    def content(cls, ea):
        '''Iterate through every tag belonging to the contents of the function at `ea`.'''
        F = func.by(ea)

        # iterate through every address in the function
        for ea in func.iterate(F):
            ui.navigation.set(ea)

            # yield the tags
            res = db.tag(ea)
            if res: yield ea, res
        return

    ## reading the tags from a frame
    @classmethod
    def frame(cls, ea):
        '''Iterate through each field within the frame belonging to the function `ea`.'''
        F = func.by(ea)

        # iterate through all of the frame's members
        try:
            res = func.frame(F)
        except internal.exceptions.MissingTypeOrAttribute:
            logging.info(u"{:s}.frame({:#x}) : Skipping function at {:#x} due to a missing frame.".format('.'.join([__name__, cls.__name__]), ea, ea))
            return

        for member in res.members:
            # if ida has named it and there's no comment, then skip
            if lvarNameQ(member.name) and not member.tag():
                continue

            # if it's a structure, then the type is the structure name
            if isinstance(member.type, struc.structure_t):
                logging.debug(u"{:s}.frame({:#x}) : Storing structure-based type as name for field {:+#x} with tne type {!s}.".format('.'.join([__name__, cls.__name__]), ea, member.offset, internal.utils.string.repr(member.type)))
                type = member.type.name

            # otherwise, the type is a tuple that we can serialize
            else:
                type = member.type

            # otherwise, it's just a regular field. so we can just save what's important.
            yield member.offset, (member.name, type, member.tag())
        return

    ## reading everything from the entire database
    @classmethod
    def everything(cls, location=False):
        """Read all of the tags defined within the database.

        Returns a tuple of the format `(Globals, Contents, Frames)`. Each field
        is a dictionary keyed by location or offset that retains the tags that
        were read. If the boolean `location` was specified then key each
        contents tag by location instead of address.
        """
        global read

        # read the globals and the contents
        six.print_(u'--> Grabbing globals...', file=output)
        Globals = { ea : res for ea, res in read.globals() }

        # read all content
        six.print_(u'--> Grabbing contents from all functions...', file=output)
        Contents = { loc : res for loc, res in read.contents(location=location) }

        # read the frames
        six.print_(u'--> Grabbing frames from all functions...', file=output)
        Frames = {ea : res for ea, res in read.frames()}

        # return everything back to the user
        return Globals, Contents, Frames

    ## reading the globals from the database
    @staticmethod
    def globals():
        '''Iterate through all of the tags defined globally witin the database.'''
        ea, sentinel = db.config.bounds()

        # loop till we hit the end of the database
        while ea < sentinel:
            ui.navigation.auto(ea)
            funcQ = func.within(ea)

            # figure out which tag function to use
            f = func.tag if funcQ else db.tag

            # grab the tag and yield it
            res = f(ea)
            if res: yield ea, res

            # if we're in a function, then seek to the next chunk
            if funcQ:
                _, ea = func.chunk(ea)
                continue

            # otherwise, try the next address till we hit a sentinel value
            try: ea = db.a.next(ea)
            except internal.exceptions.OutOfBoundsError: ea = sentinel
        return

    ## reading the contents from the entire database
    @staticmethod
    def contents(location=False):
        """Iterate through the contents tags for all the functions within the database.

        Each iteration yields a tuple of the format `(location, tags)` where
        `location` can be either an address or a chunk identifier and offset
        depending on whether `location` was specified as true or not.
        """
        global read

        # Iterate through each function in the database
        for ea in db.functions():

            # it's faster to precalculate the chunks here
            F, chunks = func.by(ea), [ch for ch in func.chunks(ea)]

            # Iterate through the function's contents yielding each tag
            for ea, res in read.content(ea):
                loc = addressToLocation(ea, chunks=chunks) if location else ea
                yield loc, res
            continue
        return

    ## reading the frames from the entire database
    @staticmethod
    def frames():
        '''Iterate through the fields of each frame for all the functions defined within the database.'''
        global read

        for ea in db.functions():
            ui.navigation.procedure(ea)
            res = dict(read.frame(ea))
            if res: yield ea, res
        return

### Applying tags to the database
class apply(object):
    """
    This namespace contains tools that can be used to apply tags that
    have been previously read back into the database.

    Various functions defined within this namespace take a variable number of
    keyword arguments which represent a mapping for the tag names. When a
    tag name was specified, this mapping will be used to rename the tags
    before actually writing them back into the database.
    """

    def __new__(cls, Globals_Contents_Frames, **tagmap):
        '''Apply the tags in the argument `(Globals, Contents, Frames)` from the `Globals_Contents_Frames` tuple back into the database.'''
        res = Globals, Contents, Frames = Globals_Contents_Frames
        return cls.everything(res, **tagmap)

    ## applying the content to a function
    @classmethod
    def content(cls, Contents, **tagmap):
        '''Apply `Contents` back into a function's contents within the database.'''
        global apply
        return apply.contents(Contents, **tagmap)

    ## applying a frame to a function
    @classmethod
    def frame(cls, ea, frame, **tagmap):
        '''Apply the fields from `frame` back into the function at `ea`.'''
        tagmap_output = u", {:s}".format(u', '.join(u"{:s}={:s}".format(internal.utils.string.escape(k), internal.utils.string.escape(v)) for k, v in tagmap.items())) if tagmap else ''

        # nothing to do here, so we gtfo
        if not frame:
            return

        # grab the function's frame
        try:
            F = func.frame(ea)

        # if no frame exists for the function, we'll need to create it
        except internal.exceptions.MissingTypeOrAttribute:

            # first we figure out the bounds of our members in order to figure out the the lvars and args sizes
            framekeys = {item for item in frame.keys()}
            minimum, maximum = min(framekeys), max(framekeys)

            # calculate the size of regs by first finding everything that begins at offset 0
            res = sorted(offset for offset in framekeys if offset >= 0)

            # now we look for anything near offset 0 that begins with a space (which should be a register)
            regs = 0
            for offset in res:
                name, type, _ = frame[offset]
                if not name.startswith(' '): break

                # if type is a string, then treat it as a structure so we can calculate a size
                if isinstance(type, six.string_types):
                    try:
                        st = struc.by(type)
                    except internal.exceptions.StructureNotFoundError:
                        logging.fatal(u"{:s}.frame({:#x}, ...{:s}): Unable to find structure \"{:s}\" for member {:+#x} in order to calculate register size for function at {:+#x}. Using register size of {:+#x}.".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, internal.utils.string.escape(type, '"'), offset, ea, regs))
                        break
                    type = [(int, 1), st.size]

                # extract the size components and calculate the total number of bytes
                realtype, reallength = type if isinstance(type, builtins.list) else [type, 1]
                _, realsize = realtype
                cb = realsize * reallength

                # add it to the current aggregate of the register size
                regs += cb

            # finally we can create the frame
            logging.warning(u"{:s}.frame({:#x}, ...{:s}) : Creating a new frame for function {:#x} with the parameters lvars={:+#x} regs={:+#x} args={:+#x}.".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, ea, abs(minimum), regs, abs(maximum)))
            F = func.frame.new(ea, abs(minimum), regs, abs(maximum) - regs)

        # iterate through our dictionary of members
        for offset, (name, type, saved) in frame.items():

            # first try and locate the member
            try:
                member = F.members.by_offset(offset)
            except:
                member = None

            # if we didn't find a member, then try and add it with what we currently know
            if member is None:
                logging.warning(u"{:s}.frame({:#x}, ...{:s}) : Unable to find frame member at {:+#x}. Attempting to create the member with the name (\"{:s}\"), type ({!s}), and tags (\"{:s}\").".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, offset, internal.utils.string.escape(name, '"'), internal.utils.string.repr(type), internal.utils.string.repr(saved)))
                try:
                    member = F.members.add(name, type, offset)
                except:
                    logging.fatal(u"{:s}.frame({:#x}, ...{:s}) : Unable to add frame member at {:+#x}. Skipping application of the name (\"{:s}\"), type ({!s}), and tags (\"{:s}\") to it.".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, offset, internal.utils.string.escape(name, '"'), internal.utils.string.repr(type), internal.utils.string.repr(saved)))
                    continue

            # check if the name has changed or is different in some way
            if member.name != name:
                log = logging.info if lvarNameQ(member.name) else logging.warning
                log(u"{:s}.frame({:#x}, ...{:s}) : Renaming frame member {:+#x} from the name \"{:s}\" to \"{:s}\".".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, offset, internal.utils.string.escape(member.name, '"'), internal.utils.string.escape(name, '"')))
                member.name = name

            # check what's going to be overwritten with different values prior to doing it
            state, res = member.tag(), saved

            # transform the new tag state using the tagmap
            new = { tagmap.get(name, name) : value for name, value in res.items() }

            # check if the tag mapping resulted in the deletion of a tag
            if len(new) != len(res):
                reskeys, newkeys = ({item for item in items.keys()} for items in [res, new])
                for name in reskeys - newkeys:
                    logging.warning(u"{:s}.frame({:#x}, ...{:s}) : Refusing requested tag mapping as it results in the tag \"{:s}\" overwriting tag \"{:s}\" for the frame member {:+#x}. The value {!s} would be overwritten by {!s}.".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, internal.utils.string.escape(name, '"'), internal.utils.string.escape(tagmap[name], '"'), offset, internal.utils.string.repr(res[name]), internal.utils.string.repr(res[tagmap[name]])))
                pass

            # warn the user about what's going to be overwritten prior to doing it
            statekeys, newkeys = ({item for item in items.keys()} for items in [state, new])
            for name in statekeys & newkeys:
                if state[name] == new[name]: continue
                logging.warning(u"{:s}.frame({:#x}, ...{:s}) : Overwriting tag \"{:s}\" for frame member {:+#x} with new value {!s}. The old value was {!s}.".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, internal.utils.string.escape(name, '"'), offset, internal.utils.string.repr(new[name]), internal.utils.string.repr(state[name])))

            # now we can update the current dictionary
            mapstate = { name : value for name, value in new.items() if state.get(name, dummy) != value }
            state.update(mapstate)

            # apply each tag directly to the field that it belongs to.
            [ member.tag(name, value) for name, value in state.items() ]

            # if the type is a string, then figure out which structure to use
            if isinstance(type, six.string_types):
                try:
                    member.type = struc.by(type)
                except internal.exceptions.StructureNotFoundError:
                    logging.warning(u"{:s}.frame({:#x}, ...{:s}): Unable to find structure \"{:s}\" for member at {:+#x}. Skipping it.".format('.'.join([__name__, cls.__name__]), ea, tagmap_output, internal.utils.string.escape(type, '"'), offset))

            # otherwise, it's a pythonic tuple that we can just assign
            else:
                member.type = type
            continue
        return

    ## apply everything to the entire database
    @classmethod
    def everything(cls, Globals_Contents_Frames, **tagmap):
        '''Apply the tags in the argument `(Globals, Contents, Frames)` from the `Globals_Contents_Frames` tuple back into the database.'''
        global apply
        Globals, Contents, Frames = Globals_Contents_Frames

        ## convert a sorted list keyed by an address into something that updates ida's navigation pointer
        def update_navigation(xs, setter):
            '''Call `setter` on ea for each iteration of list `xs`.'''
            for x in xs:
                ea, _ = x
                setter(ea)
                yield x
            return

        ## convert a sorted list keyed by a location into something that updates ida's navigation pointer
        def update_navigation_contents(xs, setter):
            '''Call `setter` on location for each iteration of list `xs`.'''
            for x in xs:
                loc, _ = x
                ea = locationToAddress(loc)
                setter(ea)
                yield x
            return

        ## handle globals
        six.print_(u"--> Writing globals... ({:d} entr{:s})".format(len(Globals), 'y' if len(Globals) == 1 else 'ies'), file=output)
        iterable = sorted(Globals.items(), key=operator.itemgetter(0))
        res = apply.globals(update_navigation(iterable, ui.navigation.auto), **tagmap)
        # FIXME: verify that res matches number of Globals

        ## handle contents
        six.print_(u"--> Writing function contents... ({:d} entr{:s})".format(len(Contents), 'y' if len(Contents) == 1 else 'ies'), file=output)
        iterable = sorted(Contents.items(), key=operator.itemgetter(0))
        res = apply.contents(update_navigation_contents(iterable, ui.navigation.set), **tagmap)
        # FIXME: verify that res matches number of Contents

        ## update any frames
        six.print_(u"--> Applying frames to each function... ({:d} entr{:s})".format(len(Frames), 'y' if len(Frames) == 1 else 'ies'), file=output)
        iterable = sorted(Frames.items(), key=operator.itemgetter(0))
        res = apply.frames(update_navigation(iterable, ui.navigation.procedure), **tagmap)
        # FIXME: verify that res matches number of Frames

        return

    ## applying tags to the globals
    @staticmethod
    def globals(Globals, **tagmap):
        '''Apply the tags in `Globals` back into the database.'''
        global apply
        cls, tagmap_output = apply.__class__, u", {:s}".format(u', '.join(u"{:s}={:s}".format(internal.utils.string.escape(oldtag), internal.utils.string.escape(newtag)) for oldtag, newtag in tagmap.items())) if tagmap else ''

        count = 0
        for ea, res in Globals:
            ns = func if func.within(ea) else db

            # grab the current (old) tag state
            state = ns.tag(ea)

            # transform the new tag state using the tagmap
            new = { tagmap.get(name, name) : value for name, value in res.items() }

            # check if the tag mapping resulted in the deletion of a tag
            if len(new) != len(res):
                reskeys, newkeys = ({item for item in items.keys()} for items in [res, new])
                for name in reskeys - newkeys:
                    logging.warning(u"{:s}.globals(...{:s}) : Refusing requested tag mapping as it results in the tag \"{:s}\" overwriting the tag \"{:s}\" in the global {:#x}. The value {!s} would be replaced with {!s}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.escape(name, '"'), internal.utils.string.escape(tagmap[name], '"'), ea, internal.utils.string.repr(res[name]), internal.utils.string.repr(res[tagmap[name]])))
                pass

            # check what's going to be overwritten with different values prior to doing it
            statekeys, newkeys = ({item for item in items.keys()} for items in [state, new])
            for name in statekeys & newkeys:
                if state[name] == new[name]: continue
                logging.warning(u"{:s}.globals(...{:s}) : Overwriting tag \"{:s}\" for global at {:#x} with new value {!s}. Old value was {!s}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.escape(name, '"'), ea, internal.utils.string.repr(new[name]), internal.utils.string.repr(state[name])))

            # now we can apply the tags to the global address
            try:
                [ ns.tag(ea, name, value) for name, value in new.items() if state.get(name, dummy) != value ]
            except:
                logging.warning(u"{:s}.globals(...{:s}) : Unable to apply tags ({!s}) to global {:#x}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.repr(new), ea), exc_info=True)

            # increase our counter
            count += 1
        return count

    ## applying contents tags to all the functions
    @staticmethod
    def contents(Contents, **tagmap):
        '''Apply the tags in `Contents` back into each function within the database.'''
        global apply
        cls, tagmap_output = apply.__class__, u", {:s}".format(u', '.join(u"{:s}={:s}".format(internal.utils.string.escape(oldtag), internal.utils.string.escape(newtag)) for oldtag, newtag in tagmap.items())) if tagmap else ''

        count = 0
        for loc, res in Contents:
            ea = locationToAddress(loc)

            # warn the user if this address is not within a function
            if not func.within(ea):
                logging.warning(u"{:s}.contents(...{:s}) : Address {:#x} is not within a function. Using a global tag.".format('.'.join([__name__, cls.__name__]), tagmap_output, ea))

            # grab the current (old) tag state
            state = db.tag(ea)

            # transform the new tag state using the tagmap
            new = { tagmap.get(name, name) : value for name, value in res.items() }

            # check if the tag mapping resulted in the deletion of a tag
            if len(new) != len(res):
                reskeys, newkeys = ({item for item in items.keys()} for items in [res, new])
                for name in reskeys - newkeys:
                    logging.warning(u"{:s}.contents(...{:s}) : Refusing requested tag mapping as it results in the tag \"{:s}\" overwriting tag \"{:s}\" for the contents at {:#x}. The value {!s} would be overwritten by {!s}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.escape(name, '"'), internal.utils.string.escape(tagmap[name], '"'), ea, internal.utils.string.repr(res[name]), internal.utils.string.repr(res[tagmap[name]])))
                pass

            # inform the user if any tags are being overwritten with different values
            statekeys, newkeys = ({item for item in items.keys()} for items in [state, new])
            for name in statekeys & newkeys:
                if state[name] == new[name]: continue
                logging.warning(u"{:s}.contents(...{:s}) : Overwriting contents tag \"{:s}\" for address {:#x} with new value {!s}. Old value was {!s}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.escape(name, '"'), ea, internal.utils.string.repr(new[name]), internal.utils.string.repr(state[name])))

            # write the tags to the contents address
            try:
                [ db.tag(ea, name, value) for name, value in new.items() if state.get(name, dummy) != value ]
            except:
                logging.warning(u"{:s}.contents(...{:s}) : Unable to apply tags {!s} to location {:#x}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.repr(new), ea), exc_info=True)

            # increase our counter
            count += 1
        return count

    ## applying frames to all the functions
    @staticmethod
    def frames(Frames, **tagmap):
        '''Apply the fields from `Frames` back into each function's frame.'''
        global apply
        cls, tagmap_output = apply.__class__, u", {:s}".format(u', '.join(u"{:s}={:s}".format(internal.utils.string.escape(oldtag), internal.utils.string.escape(newtag)) for oldtag, newtag in tagmap.items())) if tagmap else ''

        count = 0
        for ea, res in Frames:
            try:
                apply.frame(ea, res, **tagmap)
            except:
                logging.warning(u"{:s}.frames(...{:s}) : Unable to apply tags ({!s}) to frame at {:#x}.".format('.'.join([__name__, cls.__name__]), tagmap_output, internal.utils.string.repr(res), ea), exc_info=True)

            # increase our counter
            count += 1
        return count

### Exporting tags from the database using the tag cache
class export(object):
    """
    This namespace contains tools that can be used to quickly
    export specific tags out of the database using the cache.

    If `location` is specified as true, then read each contents tag
    according to its location rather than an address. This allows one
    to perform a translation of the tags in case the function chunks
    are at different addresses than when the tags were read.
    """

    def __new__(cls, *tags, **location):
        '''Read the specified tags within the database using the cache.'''
        return cls.everything(*tags, **location)

    ## query the content from a function
    @classmethod
    def content(cls, F, *tags, **location):
        '''Iterate through the specified `tags` belonging to the contents of the function at `ea` using the cache.'''
        identity = lambda res: res
        translate = addressToLocation if location.get('location', False) else identity

        iterable = func.select(F, Or=tags) if tags else func.select(F)
        for ea, res in iterable:
            ui.navigation.set(ea)
            if res: yield translate(ea), res
        return

    ## query the frame from a function
    @classmethod
    def frame(cls, F, *tags):
        '''Iterate through each field containing the specified `tags` within the frame belonging to the function `ea`.'''
        global read, internal
        tags_ = { tag for tag in tags }

        for ofs, item in read.frame(F):
            field, type, state = item

            # if no tags were specified or the entire state is in the requested tags, then save the entire member
            if not tags_ or all(name in tags_ for name in state):
                yield ofs, (field, type, state)
                continue

            # otherwise, store the state in a dictionary using only the tags the user asked for.
            state_keys = {item for item in state}
            save = { name : state[name] for name in state_keys & tags_ }

            # if anything was found, then re-encode it and yield to the user
            if res: yield ofs, (field, type, save)
        return

    ## query the entire database for the specified tags
    @classmethod
    def everything(cls, *tags, **location):
        """Read all of the specified `tags` within the database using the cache.

        Returns a tuple of the format `(Globals, Contents, Frames)`. Each field
        is a dictionary keyed by location or offset that retains the tags that
        were read. If the boolean `location` was specified then key each
        contents tag by location instead of address.
        """
        global export

        # collect all the globals into a dictionary
        six.print_(u'--> Grabbing globals (cached)...', file=output)
        iterable = export.globals(*tags)
        Globals = {ea : res for ea, res in filter(None, iterable)}

        # grab all the contents into a dictionary
        six.print_(u'--> Grabbing contents from functions (cached)...', file=output)
        location = location.get('location', False)
        iterable = export.contents(*tags, location=location)
        Contents = {loc : res for loc, res in filter(None, iterable)}

        # grab any frames into a dictionary
        six.print_(u'--> Grabbing frames from functions (cached)...', file=output)
        iterable = export.frames(*tags)
        Frames = {ea : res for ea, res in filter(None, iterable)}

        # return it back to the user
        return Globals, Contents, Frames

    ## query all the globals matching the specified tags
    @staticmethod
    def globals(*tags):
        '''Iterate through all of the specified global `tags` within the database using the cache.'''
        iterable = db.select(Or=tags) if tags else db.select()
        for ea, res in iterable:
            ui.navigation.auto(ea)
            if res: yield ea, res
        return

    ## query all the contents in each function that match the specified tags
    @staticmethod
    def contents(*tags, **location):
        """Iterate through the specified contents `tags` within the database using the cache.

        Each iteration yields a tuple of the format `(location, tags)` where
        `location` can be either an address or a chunk identifier and offset
        depending on whether `location` was specified as true or not.
        """
        global export
        location = location.get('location', False)

        iterable = db.selectcontents(Or=tags) if tags else db.selectcontents()
        for F, res in iterable:
            for loc, res in export.content(F, *res, location=location):
                if res: yield loc, res
            continue
        return

    ## query all the frames that match the specified tags
    @staticmethod
    def frames(*tags):
        '''Iterate through the fields in each function's frame containing the specified `tags`.'''
        global export
        tags_ = {x for x in tags}

        for ea in db.functions():
            ui.navigation.procedure(ea)
            res = dict(export.frame(ea, *tags))
            if res: yield ea, res
        return

__all__ = ['list', 'read', 'export', 'apply']

```