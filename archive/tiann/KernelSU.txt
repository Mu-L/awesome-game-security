Project Path: arc_tiann_KernelSU__2hdmkjl

Source Tree:

```txt
arc_tiann_KernelSU__2hdmkjl
├── LICENSE
├── SECURITY.md
├── docs
│   ├── README.md
│   ├── README_CN.md
│   ├── README_ES.md
│   ├── README_ID.md
│   ├── README_IN.md
│   ├── README_IT.md
│   ├── README_IW.md
│   ├── README_JP.md
│   ├── README_KR.md
│   ├── README_PL.md
│   ├── README_PT-BR.md
│   ├── README_RU.md
│   ├── README_TR.md
│   ├── README_TW.md
│   └── README_VI.md
├── fastlane
│   └── metadata
│       └── android
│           └── en-US
│               ├── full_description.txt
│               ├── images
│               │   └── icon.png
│               └── short_description.txt
├── js
│   ├── README.md
│   ├── index.d.ts
│   ├── index.js
│   └── package.json
├── justfile
├── kernel
│   ├── Kbuild
│   ├── Kconfig
│   ├── LICENSE
│   ├── Makefile
│   ├── allowlist.c
│   ├── allowlist.h
│   ├── apk_sign.c
│   ├── apk_sign.h
│   ├── app_profile.c
│   ├── app_profile.h
│   ├── arch.h
│   ├── feature.c
│   ├── feature.h
│   ├── file_wrapper.c
│   ├── file_wrapper.h
│   ├── kernel_umount.c
│   ├── kernel_umount.h
│   ├── klog.h
│   ├── ksu.c
│   ├── ksu.h
│   ├── ksud.c
│   ├── ksud.h
│   ├── manager.h
│   ├── pkg_observer.c
│   ├── seccomp_cache.c
│   ├── seccomp_cache.h
│   ├── selinux
│   │   ├── rules.c
│   │   ├── selinux.c
│   │   ├── selinux.h
│   │   ├── sepolicy.c
│   │   └── sepolicy.h
│   ├── setuid_hook.c
│   ├── setuid_hook.h
│   ├── setup.sh
│   ├── su_mount_ns.c
│   ├── su_mount_ns.h
│   ├── sucompat.c
│   ├── sucompat.h
│   ├── supercalls.c
│   ├── supercalls.h
│   ├── syscall_hook_manager.c
│   ├── syscall_hook_manager.h
│   ├── throne_tracker.c
│   ├── throne_tracker.h
│   ├── tools
│   │   └── check_symbol.c
│   ├── util.c
│   └── util.h
├── manager
│   ├── app
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── aidl
│   │           │   └── me
│   │           │       └── weishu
│   │           │           └── kernelsu
│   │           │               └── IKsuInterface.aidl
│   │           ├── assets
│   │           │   └── github-markdown.css
│   │           ├── cpp
│   │           │   ├── CMakeLists.txt
│   │           │   ├── jni.cc
│   │           │   ├── ksu.cc
│   │           │   └── ksu.h
│   │           ├── java
│   │           │   └── me
│   │           │       └── weishu
│   │           │           └── kernelsu
│   │           │               ├── KernelSUApplication.kt
│   │           │               ├── Kernels.kt
│   │           │               ├── Natives.kt
│   │           │               ├── profile
│   │           │               │   ├── Capabilities.kt
│   │           │               │   └── Groups.kt
│   │           │               └── ui
│   │           │                   ├── KsuService.kt
│   │           │                   ├── MainActivity.kt
│   │           │                   ├── component
│   │           │                   │   ├── AppIconImage.kt
│   │           │                   │   ├── BottomBar.kt
│   │           │                   │   ├── ChooseKmiDialog.kt
│   │           │                   │   ├── Dialog.kt
│   │           │                   │   ├── DropdownItem.kt
│   │           │                   │   ├── EditText.kt
│   │           │                   │   ├── GithubMarkdown.kt
│   │           │                   │   ├── KeyEventBlocker.kt
│   │           │                   │   ├── KsuValidCheck.kt
│   │           │                   │   ├── Markdown.kt
│   │           │                   │   ├── ScaleDialog.kt
│   │           │                   │   ├── SendLogDialog.kt
│   │           │                   │   ├── SuperEditArrow.kt
│   │           │                   │   ├── SuperSearchBar.kt
│   │           │                   │   ├── UninstallDialog.kt
│   │           │                   │   ├── filter
│   │           │                   │   │   ├── BaseFieldFilter.kt
│   │           │                   │   │   └── FilterNumber.kt
│   │           │                   │   ├── profile
│   │           │                   │   │   ├── AppProfileConfig.kt
│   │           │                   │   │   ├── RootProfileConfig.kt
│   │           │                   │   │   └── TemplateConfig.kt
│   │           │                   │   └── rebootListPopup.kt
│   │           │                   ├── navigation3
│   │           │                   │   ├── DeepLinkResolver.kt
│   │           │                   │   ├── Navigator.kt
│   │           │                   │   └── Routes.kt
│   │           │                   ├── screen
│   │           │                   │   ├── About.kt
│   │           │                   │   ├── AppProfile.kt
│   │           │                   │   ├── ExecuteModuleAction.kt
│   │           │                   │   ├── Flash.kt
│   │           │                   │   ├── Home.kt
│   │           │                   │   ├── Install.kt
│   │           │                   │   ├── Module.kt
│   │           │                   │   ├── ModuleRepo.kt
│   │           │                   │   ├── Settings.kt
│   │           │                   │   ├── SuperUser.kt
│   │           │                   │   ├── Template.kt
│   │           │                   │   └── TemplateEditor.kt
│   │           │                   ├── theme
│   │           │                   │   └── Theme.kt
│   │           │                   ├── util
│   │           │                   │   ├── Colors.kt
│   │           │                   │   ├── Downloader.kt
│   │           │                   │   ├── HanziToPinyin.java
│   │           │                   │   ├── KsuCli.kt
│   │           │                   │   ├── LogEvent.kt
│   │           │                   │   ├── Network.kt
│   │           │                   │   ├── OemHelper.kt
│   │           │                   │   ├── SELinuxChecker.kt
│   │           │                   │   ├── Serialization.kt
│   │           │                   │   ├── UidGroupUtils.kt
│   │           │                   │   └── module
│   │           │                   │       ├── LatestVersionInfo.kt
│   │           │                   │       ├── ModuleRepoApi.kt
│   │           │                   │       └── Shortcut.kt
│   │           │                   ├── viewmodel
│   │           │                   │   ├── ModuleRepoViewModel.kt
│   │           │                   │   ├── ModuleViewModel.kt
│   │           │                   │   ├── SuperUserViewModel.kt
│   │           │                   │   └── TemplateViewModel.kt
│   │           │                   └── webui
│   │           │                       ├── AppIconUtil.kt
│   │           │                       ├── Insets.kt
│   │           │                       ├── MimeUtil.java
│   │           │                       ├── MonetColorsProvider.kt
│   │           │                       ├── SuFilePathHandler.java
│   │           │                       ├── WebUIActivity.kt
│   │           │                       ├── WebUIScreen.kt
│   │           │                       ├── WebUIState.kt
│   │           │                       ├── WebViewHelper.kt
│   │           │                       └── WebViewInterface.kt
│   │           ├── jniLibs
│   │           │   └── arm64-v8a
│   │           │       └── libmagiskboot.so
│   │           └── res
│   │               ├── drawable
│   │               │   ├── ic_launcher_foreground.xml
│   │               │   └── ic_launcher_monochrome.xml
│   │               ├── mipmap-anydpi
│   │               │   └── ic_launcher.xml
│   │               ├── mipmap-hdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-ldpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-mdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-xhdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-xxhdpi
│   │               │   └── ic_launcher.png
│   │               ├── mipmap-xxxhdpi
│   │               │   └── ic_launcher.png
│   │               ├── resources.properties
│   │               ├── values
│   │               │   ├── colors.xml
│   │               │   ├── strings.xml
│   │               │   └── themes.xml
│   │               ├── values-ar
│   │               │   └── strings.xml
│   │               ├── values-az
│   │               │   └── strings.xml
│   │               ├── values-bg
│   │               │   └── strings.xml
│   │               ├── values-bn
│   │               │   └── strings.xml
│   │               ├── values-bn-rBD
│   │               │   └── strings.xml
│   │               ├── values-bs
│   │               │   └── strings.xml
│   │               ├── values-da
│   │               │   └── strings.xml
│   │               ├── values-de
│   │               │   └── strings.xml
│   │               ├── values-es
│   │               │   └── strings.xml
│   │               ├── values-et
│   │               │   └── strings.xml
│   │               ├── values-fa
│   │               │   └── strings.xml
│   │               ├── values-fil
│   │               │   └── strings.xml
│   │               ├── values-fr
│   │               │   └── strings.xml
│   │               ├── values-gl
│   │               │   └── strings.xml
│   │               ├── values-hi
│   │               │   └── strings.xml
│   │               ├── values-hr
│   │               │   └── strings.xml
│   │               ├── values-hu
│   │               │   └── strings.xml
│   │               ├── values-in
│   │               │   └── strings.xml
│   │               ├── values-it
│   │               │   └── strings.xml
│   │               ├── values-iw
│   │               │   └── strings.xml
│   │               ├── values-ja
│   │               │   └── strings.xml
│   │               ├── values-km
│   │               │   └── strings.xml
│   │               ├── values-kn
│   │               │   └── strings.xml
│   │               ├── values-ko
│   │               │   └── strings.xml
│   │               ├── values-lt
│   │               │   └── strings.xml
│   │               ├── values-lv
│   │               │   └── strings.xml
│   │               ├── values-mr
│   │               │   └── strings.xml
│   │               ├── values-ms
│   │               │   └── strings.xml
│   │               ├── values-my
│   │               │   └── strings.xml
│   │               ├── values-night
│   │               │   └── themes.xml
│   │               ├── values-nl
│   │               │   └── strings.xml
│   │               ├── values-pl
│   │               │   └── strings.xml
│   │               ├── values-pt
│   │               │   └── strings.xml
│   │               ├── values-pt-rBR
│   │               │   └── strings.xml
│   │               ├── values-ro
│   │               │   └── strings.xml
│   │               ├── values-ru
│   │               │   └── strings.xml
│   │               ├── values-sl
│   │               │   └── strings.xml
│   │               ├── values-sr
│   │               │   └── strings.xml
│   │               ├── values-te
│   │               │   └── strings.xml
│   │               ├── values-th
│   │               │   └── strings.xml
│   │               ├── values-tr
│   │               │   └── strings.xml
│   │               ├── values-uk
│   │               │   └── strings.xml
│   │               ├── values-vi
│   │               │   └── strings.xml
│   │               ├── values-zh-rCN
│   │               │   └── strings.xml
│   │               ├── values-zh-rHK
│   │               │   └── strings.xml
│   │               ├── values-zh-rTW
│   │               │   └── strings.xml
│   │               └── xml
│   │                   ├── backup_rules.xml
│   │                   ├── data_extraction_rules.xml
│   │                   ├── filepaths.xml
│   │                   └── network_security_config.xml
│   ├── build.gradle.kts
│   ├── gradle
│   │   ├── libs.versions.toml
│   │   └── wrapper
│   │       ├── gradle-wrapper.jar
│   │       └── gradle-wrapper.properties
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   ├── settings.gradle.kts
│   └── sign.example.properties
├── scripts
│   ├── allowlist.bt
│   └── ksubot.py
├── userspace
│   ├── ksud
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   ├── bin
│   │   │   ├── aarch64
│   │   │   │   ├── bootctl
│   │   │   │   ├── busybox
│   │   │   │   └── resetprop
│   │   │   └── x86_64
│   │   │       ├── busybox
│   │   │       └── resetprop
│   │   ├── build.rs
│   │   └── src
│   │       ├── apk_sign.rs
│   │       ├── assets.rs
│   │       ├── banner
│   │       ├── boot_patch.rs
│   │       ├── cli.rs
│   │       ├── cli_non_android.rs
│   │       ├── debug.rs
│   │       ├── defs.rs
│   │       ├── feature.rs
│   │       ├── init_event.rs
│   │       ├── installer.sh
│   │       ├── ksucalls.rs
│   │       ├── main.rs
│   │       ├── metamodule.rs
│   │       ├── module.rs
│   │       ├── module_config.rs
│   │       ├── profile.rs
│   │       ├── restorecon.rs
│   │       ├── sepolicy.rs
│   │       ├── su.rs
│   │       └── utils.rs
│   └── ksuinit
│       ├── Cargo.lock
│       ├── Cargo.toml
│       ├── build.rs
│       └── src
│           ├── init.rs
│           ├── loader.rs
│           └── main.rs
└── website
    ├── docs
    │   ├── guide
    │   │   ├── app-profile.md
    │   │   ├── difference-with-magisk.md
    │   │   ├── faq.md
    │   │   ├── hidden-features.md
    │   │   ├── how-to-build.md
    │   │   ├── how-to-integrate-for-non-gki.md
    │   │   ├── installation.md
    │   │   ├── metamodule.md
    │   │   ├── module-config.md
    │   │   ├── module-webui.md
    │   │   ├── module.md
    │   │   ├── rescue-from-bootloop.md
    │   │   ├── unofficially-support-devices.md
    │   │   └── what-is-kernelsu.md
    │   ├── id_ID
    │   │   ├── guide
    │   │   │   ├── app-profile.md
    │   │   │   ├── difference-with-magisk.md
    │   │   │   ├── faq.md
    │   │   │   ├── hidden-features.md
    │   │   │   ├── how-to-build.md
    │   │   │   ├── how-to-integrate-for-non-gki.md
    │   │   │   ├── installation.md
    │   │   │   ├── metamodule.md
    │   │   │   ├── module-config.md
    │   │   │   ├── module-webui.md
    │   │   │   ├── module.md
    │   │   │   ├── rescue-from-bootloop.md
    │   │   │   ├── unofficially-support-devices.md
    │   │   │   └── what-is-kernelsu.md
    │   │   └── index.md
    │   ├── index.md
    │   ├── ja_JP
    │   │   ├── guide
    │   │   │   ├── app-profile.md
    │   │   │   ├── difference-with-magisk.md
    │   │   │   ├── faq.md
    │   │   │   ├── hidden-features.md
    │   │   │   ├── how-to-build.md
    │   │   │   ├── how-to-integrate-for-non-gki.md
    │   │   │   ├── installation.md
    │   │   │   ├── metamodule.md
    │   │   │   ├── module-config.md
    │   │   │   ├── module-webui.md
    │   │   │   ├── module.md
    │   │   │   ├── rescue-from-bootloop.md
    │   │   │   ├── unofficially-support-devices.md
    │   │   │   └── what-is-kernelsu.md
    │   │   └── index.md
    │   ├── pt_BR
    │   │   ├── guide
    │   │   │   ├── app-profile.md
    │   │   │   ├── difference-with-magisk.md
    │   │   │   ├── faq.md
    │   │   │   ├── hidden-features.md
    │   │   │   ├── how-to-build.md
    │   │   │   ├── how-to-integrate-for-non-gki.md
    │   │   │   ├── installation.md
    │   │   │   ├── metamodule.md
    │   │   │   ├── module-config.md
    │   │   │   ├── module-webui.md
    │   │   │   ├── module.md
    │   │   │   ├── rescue-from-bootloop.md
    │   │   │   ├── unofficially-support-devices.md
    │   │   │   └── what-is-kernelsu.md
    │   │   └── index.md
    │   ├── public
    │   │   ├── ads.txt
    │   │   ├── favicon.ico
    │   │   ├── logo.png
    │   │   └── templates
    │   │       ├── adaway.root
    │   │       ├── adb
    │   │       ├── cemiuiler.readproc
    │   │       ├── hyperceiler.root
    │   │       ├── incompetent.root
    │   │       ├── kernelmanager.root
    │   │       ├── nethunter.root
    │   │       ├── rootexploler.root
    │   │       ├── shizuku.root
    │   │       ├── system
    │   │       └── wireguard.root
    │   ├── repos.json
    │   ├── ru_RU
    │   │   ├── guide
    │   │   │   ├── app-profile.md
    │   │   │   ├── difference-with-magisk.md
    │   │   │   ├── faq.md
    │   │   │   ├── hidden-features.md
    │   │   │   ├── how-to-build.md
    │   │   │   ├── how-to-integrate-for-non-gki.md
    │   │   │   ├── installation.md
    │   │   │   ├── metamodule.md
    │   │   │   ├── module-config.md
    │   │   │   ├── module-webui.md
    │   │   │   ├── module.md
    │   │   │   ├── rescue-from-bootloop.md
    │   │   │   ├── unofficially-support-devices.md
    │   │   │   └── what-is-kernelsu.md
    │   │   └── index.md
    │   ├── vi_VN
    │   │   ├── guide
    │   │   │   ├── app-profile.md
    │   │   │   ├── difference-with-magisk.md
    │   │   │   ├── faq.md
    │   │   │   ├── hidden-features.md
    │   │   │   ├── how-to-build.md
    │   │   │   ├── how-to-integrate-for-non-gki.md
    │   │   │   ├── installation.md
    │   │   │   ├── metamodule.md
    │   │   │   ├── module-config.md
    │   │   │   ├── module-webui.md
    │   │   │   ├── module.md
    │   │   │   ├── rescue-from-bootloop.md
    │   │   │   ├── unofficially-support-devices.md
    │   │   │   └── what-is-kernelsu.md
    │   │   └── index.md
    │   ├── zh_CN
    │   │   ├── guide
    │   │   │   ├── app-profile.md
    │   │   │   ├── difference-with-magisk.md
    │   │   │   ├── faq.md
    │   │   │   ├── hidden-features.md
    │   │   │   ├── how-to-build.md
    │   │   │   ├── how-to-integrate-for-non-gki.md
    │   │   │   ├── installation.md
    │   │   │   ├── metamodule.md
    │   │   │   ├── module-config.md
    │   │   │   ├── module-webui.md
    │   │   │   ├── module.md
    │   │   │   ├── rescue-from-bootloop.md
    │   │   │   ├── unofficially-support-devices.md
    │   │   │   └── what-is-kernelsu.md
    │   │   └── index.md
    │   └── zh_TW
    │       ├── guide
    │       │   ├── app-profile.md
    │       │   ├── difference-with-magisk.md
    │       │   ├── faq.md
    │       │   ├── hidden-features.md
    │       │   ├── how-to-build.md
    │       │   ├── how-to-integrate-for-non-gki.md
    │       │   ├── installation.md
    │       │   ├── metamodule.md
    │       │   ├── module-config.md
    │       │   ├── module-webui.md
    │       │   ├── module.md
    │       │   ├── rescue-from-bootloop.md
    │       │   ├── unofficially-support-devices.md
    │       │   └── what-is-kernelsu.md
    │       └── index.md
    ├── package.json
    └── yarn.lock

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`SECURITY.md`:

```md
# Reporting Security Issues

The KernelSU team and community take security bugs in KernelSU seriously. We appreciate your efforts to responsibly disclose your findings, and will make every effort to acknowledge your contributions.

To report a security issue, please use the GitHub Security Advisory ["Report a Vulnerability"](https://github.com/tiann/KernelSU/security/advisories/new) tab, or you can mailto [weishu](mailto:twsxtd@gmail.com) directly.

The KernelSU team will send a response indicating the next steps in handling your report. After the initial reply to your report, the security team will keep you informed of the progress towards a fix and full announcement, and may ask for additional information or guidance.

```

`docs/README.md`:

```md
**English** | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

A kernel-based root solution for Android devices.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Features

1. Kernel-based `su` and root access management.
2. Module system based on [metamodules](https://kernelsu.org/guide/metamodule.html): Pluggable infrastructure for systemless modifications.
3. [App Profile](https://kernelsu.org/guide/app-profile.html): Lock up the root power in a cage.

## Compatibility state

KernelSU officially supports Android GKI 2.0 devices (kernel 5.10+). Older kernels (4.14+) are also supported, but the kernel will need to be built manually.

With this, WSA, ChromeOS, and container-based Android are all supported.

Currently, only the `arm64-v8a` and `x86_64` architectures are supported.

## Usage

- [Installation](https://kernelsu.org/guide/installation.html)
- [How to build](https://kernelsu.org/guide/how-to-build.html)
- [Official website](https://kernelsu.org/)

## Translation

To help translate KernelSU or improve existing translations, please use [Weblate](https://hosted.weblate.org/engage/kernelsu/). PR of Manager's translation is no longer accepted, because it will conflict with Weblate.

## Discussion

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Security

For information on reporting security vulnerabilities in KernelSU, see [SECURITY.md](/SECURITY.md).

## License

- Files under the `kernel` directory are [GPL-2.0-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- All other parts except the `kernel` directory are [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Credits

- [Kernel-Assisted Superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): The KernelSU idea.
- [Magisk](https://github.com/topjohnwu/Magisk): The powerful root tool.
- [genuine](https://github.com/brevent/genuine/): APK v2 signature validation.
- [Diamorphine](https://github.com/m0nad/Diamorphine): Some rootkit skills.

```

`docs/README_CN.md`:

```md
[English](README.md) | [Español](README_ES.md) | **简体中文** | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

一个 Android 上基于内核的 root 方案。

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## 特性

- 基于内核的 `su` 和权限管理。
- 基于 [metamodules](https://kernelsu.org/zh_CN/guide/metamodule.html) 的模块系统：可插拔的模块架构。
- [App Profile](https://kernelsu.org/zh_CN/guide/app-profile.html): 把 Root 权限关进笼子里。

## 兼容状态

KernelSU 官方支持 GKI 2.0 的设备（内核版本5.10以上）；旧内核也是兼容的（最低4.14+），不过需要自己编译内核。

WSA, ChromeOS 和运行在容器上的 Android 也可以与 KernelSU 一起工作。

目前支持架构 : `arm64-v8a` 和 `x86_64`。

## 使用方法

- [安装教程](https://kernelsu.org/zh_CN/guide/installation.html)
- [如何构建？](https://kernelsu.org/zh_CN/guide/how-to-build.html)
- [官方网站](https://kernelsu.org/zh_CN/)

## 参与翻译

要将 KernelSU 翻译成您的语言，或完善现有的翻译，请使用 [Weblate](https://hosted.weblate.org/engage/kernelsu/)。现已不再接受有关管理器翻译的PR，因为这会与Weblate冲突。

## 讨论

- Telegram: [@KernelSU](https://t.me/KernelSU)

## 安全性

有关报告 KernelSU 安全漏洞的信息，请参阅 [SECURITY.md](/SECURITY.md)。

## 许可证

- 目录 `kernel` 下所有文件为 [GPL-2.0-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)。
- 除 `kernel` 目录的其他部分均为 [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html)。

## 鸣谢

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/)：KernelSU 的灵感。
- [Magisk](https://github.com/topjohnwu/Magisk)：强大的 root 工具箱。
- [genuine](https://github.com/brevent/genuine/)：apk v2 签名验证。
- [Diamorphine](https://github.com/m0nad/Diamorphine)：一些 rootkit 技巧。

```

`docs/README_ES.md`:

```md
[English](README.md) | **Español** | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Una solución root basada en el kernel para dispositivos Android.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localización-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Seguir-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/Licencia-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Características

1. Binario `su` basado en el kernel y gestión de acceso root.
2. Sistema de módulos basado en [metamodules](https://kernelsu.org/guide/metamodule.html): Infraestructura conectable para modificaciones sin sistema.

## Estado de compatibilidad

**KernelSU** soporta de forma oficial dispositivos Android con **GKI 2.0** (a partir de la versión **5.10** del kernel). Los kernels antiguos (a partir de la versión **4.14**) también son compatibles, pero necesitas compilarlos por tu cuenta.

Con esto, WSA, ChromeOS y Android basado en contenedores están todos compatibles.

Actualmente, solo se admiten las arquitecturas `arm64-v8a` y `x86_64`.

## Uso

- [¿Cómo instalarlo?](https://kernelsu.org/guide/installation.html)
- [¿Cómo compilarlo?](https://kernelsu.org/guide/how-to-build.html)
- [Site oficial](https://kernelsu.org/)

## Traducción

Para ayudar a traducir KernelSU o mejorar las traducciones existentes, utilice [Weblate](https://hosted.weblate.org/engage/kernelsu/). Ya no se aceptan PR de la traducción de Manager porque entrará en conflicto con Weblate.

## Discusión

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Seguridad

Para obtener información sobre cómo informar vulnerabilidades de seguridad en KernelSU, consulte [SECURITY.md](/SECURITY.md).

##  Licencia

- Los archivos bajo el directorio `kernel` están licenciados bajo [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Todas las demás partes, a excepción del directorio `kernel`, están licenciados bajo [GPL-3-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Créditos

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): la idea de KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): la poderosa herramienta root.
- [genuine](https://github.com/brevent/genuine/): validación de firma apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): algunas habilidades de rootkit.

```

`docs/README_ID.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | **Indonesia** | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Solusi root berbasis Kernel untuk perangkat Android.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Fitur

1. Manajemen akses root dan `su` berbasis kernel.
2. Sistem modul berdasarkan [metamodules](https://kernelsu.org/id_ID/guide/metamodule.html): Infrastruktur pluggable untuk modifikasi systemless.
3. [Profil Aplikasi](https://kernelsu.org/guide/app-profile.html): Kunci daya root di dalam sangkar.

## Status Kompatibilitas

KernelSU secara resmi mendukung perangkat Android GKI 2.0 (dengan kernel 5.10+), kernel lama (4.14+) juga kompatibel, tetapi Anda perlu membuat kernel sendiri.

WSA, ChromeOS, dan Android berbasis wadah juga dapat bekerja dengan KernelSU terintegrasi.

Dan ABI yang didukung saat ini adalah: `arm64-v8a` dan `x86_64`

## Penggunaan

- [Petunjuk Instalasi](https://kernelsu.org/id_ID/guide/installation.html)
- [Bagaimana cara membuat?](https://kernelsu.org/id_ID/guide/how-to-build.html)
- [Situs Web Resmi](https://kernelsu.org/id_ID/)

## Terjemahan

Untuk menerjemahkan KernelSU ke dalam bahasa Anda atau menyempurnakan terjemahan yang sudah ada, harap gunakan [Weblat](https://hosted.weblate.org/engage/kernelsu/).

## Diskusi

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Lisensi

- File di bawah direktori `kernel` adalah [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Semua bagian lain kecuali direktori `kernel` adalah [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Kredit

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): ide KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): alat root yang ampuh.
- [genuine](https://github.com/brevent/genuine/): validasi tanda tangan apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): beberapa keterampilan rootkit.

```

`docs/README_IN.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) |  **हिंदी** | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Android उपकरणों के लिए कर्नेल-आधारित रूट समाधान।

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## विशेषताएँ

1. कर्नेल-आधारित `su` और रूट एक्सेस प्रबंधन।
2. [metamodules](https://kernelsu.org/guide/metamodule.html) पर आधारित मॉड्यूल प्रणाली: Systemless संशोधनों के लिए प्लगेबल इंफ्रास्ट्रक्चर।
3. [App Profile](https://kernelsu.org/guide/app-profile.html): Root शक्ति को पिंजरे में बंद कर दो।

## अनुकूलता अवस्था

KernelSU आधिकारिक तौर पर Android GKI 2.0 डिवाइस (कर्नेल 5.10+) का समर्थन करता है। पुराने कर्नेल (4.14+) भी संगत हैं, लेकिन कर्नेल को मैन्युअल रूप से बनाना होगा।

इसके साथ, WSA, ChromeOS और कंटेनर-आधारित Android सभी समर्थित हैं।

वर्तमान में, केवल `arm64-v8a` और `x86_64` समर्थित हैं।

## प्रयोग

- [स्थापना निर्देश](https://kernelsu.org/guide/installation.html)
- [कैसे बनाना है ?](https://kernelsu.org/guide/how-to-build.html)
- [आधिकारिक वेबसाइट](https://kernelsu.org/)

## अनुवाद करना

KernelSU का अनुवाद करने या मौजूदा अनुवादों को बेहतर बनाने में सहायता के लिए, कृपया इसका उपयोग करें [Weblate](https://hosted.weblate.org/engage/kernelsu/).

## बहस

- Telegram: [@KernelSU](https://t.me/KernelSU)

## लाइसेंस

- `Kernel` निर्देशिका के अंतर्गत फ़ाइलें हैं [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
- `Kernel` निर्देशिका को छोड़कर अन्य सभी भाग हैं [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html)

## आभार सूची

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): KernelSU विचार।
- [Magisk](https://github.com/topjohnwu/Magisk): शक्तिशाली root उपकरण।
- [genuine](https://github.com/brevent/genuine/): apk v2 हस्ताक्षर सत्यापन।
- [Diamorphine](https://github.com/m0nad/Diamorphine): कुछ रूटकिट कौशल।

```

`docs/README_IT.md`:

```md
[English](REAME.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | **Italiano**

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Una soluzione per il root basata sul kernel per i dispositivi Android. 

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Canale Telegraml](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![Licenza componenti kernel: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![Licenza elementi non kern](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Funzionalità

1. `su` e accesso root basato sul kernel.
2. Sistema di moduli basato su [metamodules](https://kernelsu.org/guide/metamodule.html): Infrastruttura modulare per modifiche systemless.
3. [App profile](https://kernelsu.org/guide/app-profile.html): Limita i poteri dell'accesso root a permessi specifici.

## Compatibilità

KernelSU supporta ufficialmente i dispositivi Android GKI 2.0 (kernel 5.10 o superiore). I kernel precedenti (kernel 4.14+) sono anche compatibili, ma il kernel deve essere compilato manualmente.

Questo implica che WSA, ChromeOS e tutti le varianti di Android basate su container e virtualizzazione sono supportate.

Allo stato attuale solo le architetture a 64-bit ARM (arm64-v8a) e x86 (x86_64) sono supportate.

## Utilizzo

- [Istruzioni per l'installazione](https://kernelsu.org/guide/installation.html)
- [Come compilare manualmente?](https://kernelsu.org/guide/how-to-build.html)
- [Sito web ufficiale](https://kernelsu.org/)

## Traduzioni

Per aiutare a tradurre KernelSU o migliorare le traduzioni esistenti, si è pregati di utilizzare 
To help translate KernelSU or improve existing translations, please use [Weblate](https://hosted.weblate.org/engage/kernelsu/). Le richieste di pull delle traduzioni del manager non saranno più accettate perché sarebbero in conflitto con Weblate.

## Discussione

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Securezza

Per informazioni riguardo la segnalazione di vulnerabilità di sicurezza per KernelSU, leggi [SECURITY.md](/SECURITY.md).

## Licenza

- I file nella cartella `kernel` sono forniti secondo la licenza [GPL-2.0-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Tutte le altre parti, ad eccezione della certella `kernel`, seguono la licenza [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Riconoscimenti e attribuzioni

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): l'idea alla base di KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): la potente utilità per il root.
- [genuine](https://github.com/brevent/genuine/): verifica della firma apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): alcune capacità di rootkit.

```

`docs/README_IW.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | **עברית** | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

פתרון לניהול root מבוסס על Kernel עבור מכשירי Android.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## תכונות

1. ניהול root ו־`su` מבוססים על Kernel.
2. מערכת מודולים מבוססת [metamodules](https://kernelsu.org/guide/metamodule.html): תשתית מודולרית לשינויים systemless.
3. [פרופיל אפליקציה](https://kernelsu.org/guide/app-profile.html): נעילת גישת root בכלוב.

## מצב תאימות

KernelSU תומך במכשירי Android GKI 2.0 (kernel 5.10+) באופן רשמי. לליבות ישנות (4.14+) יש גם תאימות, אך יידרש לבנות את הליבה באופן ידני.

באמצעות זה, תמיכה זמינה גם ל-WSA, ChromeOS ומכשירי Android המבוססים על מיכלים.

כרגע, רק `arm64-v8a` ו־`x86_64` נתמכים.

## שימוש

- [הוראות התקנה](https://kernelsu.org/guide/installation.html)
- [איך לבנות?](https://kernelsu.org/guide/how-to-build.html)
- [האתר רשמי](https://kernelsu.org/)

## תרגום

כדי לעזור בתרגום של KernelSU או לשפר תרגומים קיימים, יש להשתמש ב-[Weblate](https://hosted.weblate.org/engage/kernelsu/).

## דיון

- Telegram: [@KernelSU](https://t.me/KernelSU)

## רשיון

- קבצים תחת הספרייה `kernel` מוגנים על פי [GPL-2.0-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- כל החלקים האחרים, למעט הספרייה `kernel`, מוגנים על פי [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## קרדיטים

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): הרעיון של KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): הכלי הסופר חזק לניהול root.
- [genuine](https://github.com/brevent/genuine/): אימות חתימת apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): כמה יכולות רוט.

```

`docs/README_JP.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | **日本語** | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Android におけるカーネルベースの root ソリューションです。

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## 特徴

1. カーネルベースの `su` と権限管理。
2. [metamodules](https://kernelsu.org/ja_JP/guide/metamodule.html) に基づくモジュールシステム: プラグイン可能なシステムレス変更インフラストラクチャ。
3. [アプリのプロファイル](https://kernelsu.org/guide/app-profile.html): root の権限をケージ内に閉じ込めます。

## 対応状況

KernelSU は GKI 2.0 デバイス（カーネルバージョン 5.10 以上）を公式にサポートしています。古いカーネル（4.14以上）とも互換性がありますが、自分でカーネルをビルドする必要があります。

WSA 、ChromeOS とコンテナ上で動作する Android でも KernelSU を統合して動かせます。

現在サポートしているアーキテクチャは `arm64-v8a` および `x86_64` です。

## 使用方法

- [インストール方法はこちら](https://kernelsu.org/ja_JP/guide/installation.html)
- [ビルド方法はこちら](https://kernelsu.org/guide/how-to-build.html)
- [公式サイト](https://kernelsu.org/ja_JP/)

## 翻訳

KernelSU をあなたの言語に翻訳するか、既存の翻訳を改善するには、[Weblate](https://hosted.weblate.org/engage/kernelsu/) を使用してください。Manager翻訳した PR は、Weblate と競合するため受け入れられなくなりました。

## ディスカッション

- Telegram: [@KernelSU](https://t.me/KernelSU)

## ライセンス

- `kernel` ディレクトリの下にあるすべてのファイル： [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)。
- `kernel` ディレクトリ以外のすべてのファイル： [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html)。

## クレジット

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/)：KernelSU のアイデア元。
- [Magisk](https://github.com/topjohnwu/Magisk)：強力な root ツール。
- [genuine](https://github.com/brevent/genuine/)：apk v2 の署名検証。
- [Diamorphine](https://github.com/m0nad/Diamorphine): rootkit のスキル。

```

`docs/README_KR.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | **한국어** | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

안드로이드 기기에서 사용되는 커널 기반 루팅 솔루션입니다.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## 기능들

1. 커널 기반 `su` 및 루트 액세스 관리.
2. [metamodules](https://kernelsu.org/guide/metamodule.html) 기반 모듈 시스템: 플러그인 가능한 시스템리스 수정 인프라.
3. [App Profile](https://kernelsu.org/guide/app-profile.html): 루트 권한을 케이지에 가둡니다.

## 호환 상태

KernelSU는 공식적으로 안드로이드 GKI 2.0 디바이스(커널 5.10 이상)를 지원합니다. 오래된 커널(4.14 이상)도 사용할 수 있지만, 커널을 수동으로 빌드해야 합니다.

KernelSU는 WSA, ChromeOS, 컨테이너 기반 안드로이드 모두를 지원합니다.

현재는 `arm64-v8a`와 `x86_64`만 지원됩니다.

## 사용 방법

- [설치 방법](https://kernelsu.org/guide/installation.html)
- [어떻게 빌드하나요?](https://kernelsu.org/guide/how-to-build.html)
- [공식 웹사이트](https://kernelsu.org/)

## 번역

KernelSU 번역을 돕거나 기존 번역을 개선하려면 [Weblate](https://hosted.weblate.org/engage/kernelsu/)를 이용해 주세요. 매니저의 번역은 Weblate와 충돌할 수 있으므로 더 이상 허용되지 않습니다.

## 토론

- 텔레그램: [@KernelSU](https://t.me/KernelSU)

## 보안

KernelSU의 보안 취약점 보고에 대한 자세한 내용은 [SECURITY.md](/SECURITY.md)를 참조하세요.

## 저작권

- `kernel` 디렉터리 아래의 파일은 [GPL-2.0 전용](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)입니다.
- `kernel` 디렉토리를 제외한 다른 모든 부분은 [GPL-3.0-이상](https://www.gnu.org/licenses/gpl-3.0.html)입니다.

## 크래딧

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): KernelSU의 아이디어.
- [Magisk](https://github.com/topjohnwu/Magisk): 강력한 루팅 도구.
- [genuine](https://github.com/brevent/genuine/): apk v2 서명 유효성 검사.
- [Diamorphine](https://github.com/m0nad/Diamorphine): 일부 rootkit 스킬.

```

`docs/README_PL.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | **Polski** | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Rozwiązanie root oparte na jądrze dla urządzeń z systemem Android.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Cechy

1. Oparte na jądrze `su` i zarządzanie dostępem roota.
2. System modułów oparty na [metamodules](https://kernelsu.org/guide/metamodule.html): Wtykowa infrastruktura dla modyfikacji systemless.

## Kompatybilność

KernelSU oficjalnie obsługuje urządzenia z Androidem GKI 2.0 (z jądrem 5.10+), starsze jądra (4.14+) są również kompatybilne, ale musisz sam skompilować jądro.

WSA i Android oparty na kontenerach również powinny działać ze zintegrowanym KernelSU.

Aktualnie obsługiwane ABI to : `arm64-v8a` i `x86_64`.

## Użycie

- [Instalacja](https://kernelsu.org/guide/installation.html)
- [Jak skompilować?](https://kernelsu.org/guide/how-to-build.html)

## Tłumaczenie

Aby pomóc w tłumaczeniu KernelSU lub ulepszyć istniejące tłumaczenia, użyj [Weblate](https://hosted.weblate.org/engage/kernelsu/). PR tłumaczenia Managera nie jest już akceptowany, ponieważ będzie kolidował z Weblate.

## Dyskusja

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Bezpieczeństwo

Informacje na temat zgłaszania luk w zabezpieczeniach w KernelSU można znaleźć w pliku [SECURITY.md](/SECURITY.md).

## Licencja

- Pliki w katalogu `kernel` są na licencji [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Wszystkie inne części poza katalogiem `kernel` są na licencji [GPL-3-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Podziękowania

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): pomysłodawca KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): implementacja sepolicy.
- [genuine](https://github.com/brevent/genuine/): walidacja podpisu apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): cenna znajomość rootkitów.

```

`docs/README_PT-BR.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | **Português (Brasil)** | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Uma solução root baseada em kernel para dispositivos Android.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localização-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Seguir-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/Licença-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Características

1. `su` e gerenciamento de acesso root baseado em kernel.
2. Sistema de módulos baseado em [metamodules](https://kernelsu.org/pt_BR/guide/metamodule.html): Infraestrutura plugável para modificações systemless.
3. [Perfil do Aplicativo](https://kernelsu.org/pt_BR/guide/app-profile.html): Tranque o poder root em uma gaiola.

## Estado de compatibilidade

O KernelSU oferece suporte oficial a dispositivos Android GKI 2.0 (kernel 5.10+). Kernels mais antigos (4.14+) também são compatíveis, mas será necessário construir o kernel manualmente.

Com isso, WSA, ChromeOS e Android baseado em contêiner são todos suportados.

Atualmente, apenas as arquiteturas `arm64-v8a` e `x86_64` são compatíveis.

## Uso

 - [Instalação](https://kernelsu.org/pt_BR/guide/installation.html)
 - [Como compilar](https://kernelsu.org/pt_BR/guide/how-to-build.html)
 - [Site oficial](https://kernelsu.org/pt_BR/)

## Tradução

Para contribuir com a tradução do KernelSU ou aprimorar traduções existentes, por favor, use o [Weblate](https://hosted.weblate.org/engage/kernelsu/). PR para a tradução do Manager não são mais aceitas, pois podem entrar em conflito com o Weblate.

## Discussão

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Segurança

Para obter informações sobre como relatar vulnerabilidades de segurança do KernelSU, consulte [SECURITY.md](/SECURITY.md).

## Licença

- Os arquivos no diretório `kernel` são [GPL-2.0-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Todas as outras partes, exceto o diretório `kernel` são [GPL-3.0-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Créditos

- [Kernel-Assisted Superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): A ideia do KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): A poderosa ferramenta root.
- [genuine](https://github.com/brevent/genuine/): Validação de assinatura APK v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): Algumas habilidades de rootkit.

```

`docs/README_RU.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | **Русский** | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Решение на основе ядра root для Android-устройств.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Особенности

1. Управление `su` и root-доступом на основе ядра.
2. Система модулей на основе [metamodules](https://kernelsu.org/ru_RU/guide/metamodule.html): Подключаемая инфраструктура для безсистемных модификаций.
3. [Профиль приложений](https://kernelsu.org/ru_RU/guide/app-profile.html): Запри корневую силу в клетке.

## Совместимость

KernelSU официально поддерживает устройства на базе Android GKI 2.0 (с ядром 5.10+), старые ядра (4.14+) также совместимы, но для этого необходимо собрать ядро самостоятельно.

WSA и Android на основе контейнеров также должны работать с интегрированным KernelSU.

В настоящее время поддерживаются следующие ABI: `arm64-v8a` и `x86_64`.

## Использование

- [Установка](https://kernelsu.org/ru_RU/guide/installation.html)
- [Как собрать?](https://kernelsu.org/ru_RU/guide/how-to-build.html)
- [официальный сайт](https://kernelsu.org/ru_RU/)

## Обсуждение

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Лицензия

- Файлы в директории `kernel` [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Все остальные части, кроме директории `kernel` [GPL-3-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Благодарности

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): идея KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): реализация sepolicy.
- [genuine](https://github.com/brevent/genuine/): проверка подписи apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): некоторые навыки руткита.

```

`docs/README_TR.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | **Türkçe** | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Android cihazlar için kernel tabanlı root çözümü.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Özellikler

1. Kernel-tabanlı `su` ve root erişimi yönetimi.
2. [metamodules](https://kernelsu.org/guide/metamodule.html)'ye dayalı modül sistemi: Systemless modifikasyonlar için takılabilir altyapı.
3. [Uygulama profili](https://kernelsu.org/guide/app-profile.html): Root gücünü bir kafese kapatın.

## Uyumluluk Durumu

KernelSU resmi olarak Android GKI 2.0 cihazlarını (5.10+ kernelli) destekler, eski kernellerle de (4.14+) uyumludur, ancak kerneli kendinizin derlemeniz gerekir.

Bununla birlikte; WSA, ChromeOS ve konteyner tabanlı Android'in tamamı desteklenmektedir.

Şimdilik sadece `arm64-v8a` ve `x86_64` desteklenmektedir.

## Kullanım

- [Yükleme yönergeleri](https://kernelsu.org/guide/installation.html)
- [Nasıl derlenir?](https://kernelsu.org/guide/how-to-build.html)
- [Resmi WEB sitesi](https://kernelsu.org/)

## Çeviri

KernelSU'nun başka dillere çevrilmesine veya mevcut çevirilerin iyileştirilmesine yardımcı olmak için lütfen [Weblate](https://hosted.weblate.org/engage/kernelsu/) kullanın. Yönetici uygulamasının PR ile çevirisi, Weblate ile çakışacağından artık kabul edilmeyecektir.

## Tartışma

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Güvenlik

KernelSU'daki güvenlik açıklarını bildirme hakkında bilgi için, bkz [SECURITY.md](/SECURITY.md).

## Lisans

- `kernel` klasöründeki dosyalar [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html) lisansı altındadır.
- `kernel` klasörü dışındaki bütün diğer bölümler [GPL-3-veya-sonraki](https://www.gnu.org/licenses/gpl-3.0.html) lisansı altındadır.

## Krediler

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): KernelSU fikri.
- [Magisk](https://github.com/topjohnwu/Magisk): güçlü root aracı.
- [genuine](https://github.com/brevent/genuine/): apk v2 imza doğrulaması.
- [Diamorphine](https://github.com/m0nad/Diamorphine): bazı rootkit becerileri.

```

`docs/README_TW.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | **繁體中文** | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | [Tiếng Việt](README_VI.md) | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="標誌">

一套基於 Android 裝置核心的 Root 解決方案。

[![最新版本](https://img.shields.io/github/v/release/tiann/KernelSU?label=%e7%99%bc%e8%a1%8c%e7%89%88%e6%9c%ac&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/%e6%9c%ac%e5%9c%9f%e5%8c%96%e7%bf%bb%e8%ad%af-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![頻道](https://img.shields.io/badge/%e8%bf%bd%e8%b9%a4-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![授權條款：《GPL v2》](https://img.shields.io/badge/%e6%8e%88%e6%ac%8a%e6%a2%9d%e6%ac%be-%E3%80%8AGPL%20v2%E3%80%8B-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub 授權條款](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## 特色功能

1. 以核心內 `su` 管理 Root 存取。
2. 以 [metamodules](https://kernelsu.org/zh_TW/guide/metamodule.html) 運作模組系統：可插拔的無系統修改基礎架構。
3. [App Profile](https://kernelsu.org/zh_TW/guide/app-profile.html)：使 Root 掌握的生殺大權受制於此。

## 相容事態

理論上採以 Android GKI 2.0 的裝置（核心版本 5.10+），皆受 KernelSU 支援；採以老舊核心版本（4.14+）的裝置在手動建置核心後，亦受支援。

另可在 WSA、ChromeOS 一類的容器式 Android 中運作。

目前僅適用 `arm64-v8a` 以及 `x86_64` 架構。

## 使用手冊

- [安裝教學](https://kernelsu.org/zh_TW/guide/installation.html)
- [如何建置 KernelSU？](https://kernelsu.org/zh_TW/guide/how-to-build.html)
- [官方網站](https://kernelsu.org/zh_TW/)

## 多語翻譯

欲要協助 KernelSU 邁向多語化，抑或改進翻譯品質，請前往 [Weblate](https://hosted.weblate.org/engage/kernelsu/) 進行翻譯。為避免與 Weblate 上的翻譯發生衝突，現已不再受理翻譯相關的管理工具 PR。

## 綜合討論

- Telegram：[@KernelSU](https://t.me/KernelSU)

## 安全政策

欲要得知、回報 KernelSU 的安全性漏洞，請參閱 [SECURITY.md](/SECURITY.md)。

## 授權條款

- 位於 `kernel` 資料夾的檔案以[《GPL-2.0-only》](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)規範。
- 非位於 `kernel` 資料夾的其他檔案以[《GPL-3.0-or-later》](https://www.gnu.org/licenses/gpl-3.0.html)規範。

## 致謝名單

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/)：KernelSU 的靈感來源。
- [Magisk](https://github.com/topjohnwu/Magisk)：強而有力的 Root 工具。
- [genuine](https://github.com/brevent/genuine/)：用於確效 Apk v2 簽章。
- [Diamorphine](https://github.com/m0nad/Diamorphine): 用於增進 Rootkit 技巧。

```

`docs/README_VI.md`:

```md
[English](README.md) | [Español](README_ES.md) | [简体中文](README_CN.md) | [繁體中文](README_TW.md) | [日本語](README_JP.md) | [한국어](README_KR.md) | [Polski](README_PL.md) | [Português (Brasil)](README_PT-BR.md) | [Türkçe](README_TR.md) | [Русский](README_RU.md) | **Tiếng Việt** | [Indonesia](README_ID.md) | [עברית](README_IW.md) | [हिंदी](README_IN.md) | [Italiano](README_IT.md)

# KernelSU

<img src="https://kernelsu.org/logo.png" style="width: 96px;" alt="logo">

Giải pháp root thông qua thay đổi trên Kernel hệ điều hành cho các thiết bị Android.

[![Latest release](https://img.shields.io/github/v/release/tiann/KernelSU?label=Release&logo=github)](https://github.com/tiann/KernelSU/releases/latest)
[![Weblate](https://img.shields.io/badge/Localization-Weblate-teal?logo=weblate)](https://hosted.weblate.org/engage/kernelsu)
[![Channel](https://img.shields.io/badge/Follow-Telegram-blue.svg?logo=telegram)](https://t.me/KernelSU)
[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-orange.svg?logo=gnu)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![GitHub License](https://img.shields.io/github/license/tiann/KernelSU?logo=gnu)](/LICENSE)

## Tính năng

1. Hỗ trợ gói thực thi `su` và quản lý quyền root.
2. Hệ thống mô-đun thông qua [metamodules](https://kernelsu.org/vi_VN/guide/metamodule.html): Cơ sở hạ tầng có thể cắm cho các sửa đổi systemless.
3. [App Profile](https://kernelsu.org/guide/app-profile.html): Hạn chế quyền root của ứng dụng.

## Tình trạng tương thích

KernelSU chính thức hỗ trợ các thiết bị Android với kernel GKI 2.0 (phiên bản kernel 5.10+), các phiên bản kernel cũ hơn (4.14+) cũng tương thích, nhưng bạn cần phải tự biên dịch.

WSA, ChromeOS và Android dựa trên container(container-based) cũng được hỗ trợ bởi KernelSU.

Hiên tại Giao diện nhị phân của ứng dụng (ABI) được hỗ trợ bao gồm `arm64-v8a` và `x86_64`.

## Sử dụng

- [Hướng dẫn cài đặt](https://kernelsu.org/vi_VN/guide/installation.html)
- [Cách để build?](https://kernelsu.org/vi_VN/guide/how-to-build.html)
- [Website Chính Thức](https://kernelsu.org/vi_VN/)

## Hỗ trợ dịch

Nếu bạn muốn hỗ trợ dịch KernelSU sang một ngôn ngữ khác hoặc cải thiện các bản dịch trước, vui lòng sử dụng [Weblate](https://hosted.weblate.org/engage/kernelsu/).

## Thảo luận

- Telegram: [@KernelSU](https://t.me/KernelSU)

## Giấy phép

- Tất cả các file trong thư mục `kernel` dùng giấy phép [GPL-2-only](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html).
- Tất cả các thành phần khác ngoại trừ thư mục `kernel` dùng giấy phép [GPL-3-or-later](https://www.gnu.org/licenses/gpl-3.0.html).

## Lời cảm ơn

- [kernel-assisted-superuser](https://git.zx2c4.com/kernel-assisted-superuser/about/): ý tưởng cho KernelSU.
- [Magisk](https://github.com/topjohnwu/Magisk): công cụ root mạnh mẽ.
- [genuine](https://github.com/brevent/genuine/): phương pháp xác thực apk v2.
- [Diamorphine](https://github.com/m0nad/Diamorphine): các phương pháp ẩn của rootkit.

```

`fastlane/metadata/android/en-US/full_description.txt`:

```txt
<p><i>KernelSU</i> is a Kernel based root solution for Android devices. It features kernel-based <code>su</code> and root access management as well as a Module system based on overlayfs (similar to Magisk). <i>KernelSU</i> works whitelist-based: Only App that is granted root permission can access <code>su</code>, other apps cannot perceive <code>su</code>.</p><p><i>KernelSU</i> officially supports Android GKI 2.0 devices(with kernel 5.10+), old kernels(4.14+) is also compatiable, but you need to build kernel yourself. WSA and containter-based Android should also work with <i>KernelSU</i> integrated.</p><p>Current supported ABIs are: <code>arm64-v8a</code> and <code>x86_64</code>.</p>
```

`fastlane/metadata/android/en-US/short_description.txt`:

```txt
Kernel based root solution for Android
```

`js/README.md`:

```md
# Library for KernelSU's module WebUI

## Install

```sh
yarn add kernelsu
```

## API

### exec

Spawns a **root** shell and runs a command within that shell, returning a Promise that resolves with the `stdout` and `stderr` outputs upon completion.

- `command` `<string>` The command to run, with space-separated arguments.
- `options` `<Object>`
  - `cwd` - Current working directory of the child process.
  - `env` - Environment key-value pairs.

```javascript
import { exec } from 'kernelsu';

const { errno, stdout, stderr } = await exec('ls -l', { cwd: '/tmp' });
if (errno === 0) {
    // success
    console.log(stdout);
}
```

### spawn

Spawns a new process using the given `command` in **root** shell, with command-line arguments in `args`. If omitted, `args` defaults to an empty array.

Returns a `ChildProcess` instance. Instances of `ChildProcess` represent spawned child processes.

- `command` `<string>` The command to run.
- `args` `<string[]>` List of string arguments.
- `options` `<Object>`:
  - `cwd` `<string>` - Current working directory of the child process.
  - `env` `<Object>` - Environment key-value pairs.

Example of running `ls -lh /data`, capturing `stdout`, `stderr`, and the exit code:

```javascript
import { spawn } from 'kernelsu';

const ls = spawn('ls', ['-lh', '/data']);

ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.log(`stderr: ${data}`);
});

ls.on('exit', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

#### ChildProcess

##### Event 'exit'

- `code` `<number>` The exit code if the child process exited on its own.

The `'exit'` event is emitted when the child process ends. If the process exits, `code` contains the final exit code; otherwise, it is null.

##### Event 'error'

- `err` `<Error>` The error.

The `'error'` event is emitted whenever:

- The process could not be spawned.
- The process could not be killed.

##### `stdout`

A `Readable Stream` that represents the child process's `stdout`.

```javascript
const subprocess = spawn('ls');

subprocess.stdout.on('data', (data) => {
  console.log(`Received chunk ${data}`);
});
```

#### `stderr`

A `Readable Stream` that represents the child process's `stderr`.

### fullScreen

Request the WebView enter/exit full screen.

```javascript
import { fullScreen } from 'kernelsu';
fullScreen(true);
```

### enableEdgeToEdge

Request the WebView to set padding to 0 or safeDrawing insets

- tips: this is disabled by default but if you request resource from `internal/insets.css`, this will be enabled automatically.
- To get insets value and enable this automatically, you can
  - add `@import "https://mui.kernelsu.org/internal/insets.css";` in css OR
  - add `<link rel="stylesheet" type="text/css" href="/internal/insets.css" />` in html.

```javascript
import { enableEdgeToEdge } from 'kernelsu';
enableEdgeToEdge(true);
```

### toast

Show a toast message.

```javascript
import { toast } from 'kernelsu';
toast('Hello, world!');
```

### moduleInfo

Get module info.

```javascript
import { moduleInfo } from 'kernelsu';
// print moduleId in console
console.log(moduleInfo());
```

### listPackages

List installed packages.

Returns an array of package names.

- `type` `<string>` The type of packages to list: "user", "system", or "all".

```javascript
import { listPackages } from 'kernelsu';
// list user packages
const packages = listPackages("user");
```

- tips: when `listPackages` api is available, you can use ksu://icon/{packageName} to get app icon.

``` javascript
img.src = "ksu://icon/" + packageName;
```

### getPackagesInfo

Get information for a list of packages.

Returns an array of `PackagesInfo` objects.

- `packages` `<string[]>` The list of package names.

```javascript
import { getPackagesInfo } from 'kernelsu';
const packages = getPackagesInfo(['com.android.settings', 'com.android.shell']);
```

#### PackagesInfo

An object contains:

- `packageName` `<string>` Package name of the application.
- `versionName` `<string>` Version of the application.
- `versionCode` `<number>` Version code of the application.
- `appLabel` `<string>` Display name of the application.
- `isSystem` `<boolean>` Whether the application is a system app.
- `uid` `<number>` UID of the application.

### exit

Exit the current WebUI activity.

```javascript
import { exit } from 'kernelsu';
exit();
```

```

`js/index.d.ts`:

```ts
interface ExecOptions {
    cwd?: string,
    env?: { [key: string]: string }
}

interface ExecResults {
    errno: number,
    stdout: string,
    stderr: string
}

declare function exec(command: string): Promise<ExecResults>;
declare function exec(command: string, options: ExecOptions): Promise<ExecResults>;

interface SpawnOptions {
    cwd?: string,
    env?: { [key: string]: string }
}

interface Stdio {
    on(event: 'data', callback: (data: string) => void)
}

interface ChildProcess {
    stdout: Stdio,
    stderr: Stdio,
    on(event: 'exit', callback: (code: number) => void)
    on(event: 'error', callback: (err: any) => void)
}

declare function spawn(command: string): ChildProcess;
declare function spawn(command: string, args: string[]): ChildProcess;
declare function spawn(command: string, options: SpawnOptions): ChildProcess;
declare function spawn(command: string, args: string[], options: SpawnOptions): ChildProcess;

declare function fullScreen(isFullScreen: boolean);

declare function enableEdgeToEdge(enable: boolean);

declare function toast(message: string);

declare function moduleInfo(): string;

interface PackagesInfo {
    packageName: string;
    versionName: string;
    versionCode: number;
    appLabel: string;
    isSystem: boolean;
    uid: number;
}

declare function listPackages(type: string): string[];

declare function getPackagesInfo(packages: string[]): PackagesInfo[];

declare function exit();

export {
    exec,
    spawn,
    fullScreen,
    enableEdgeToEdge,
    toast,
    moduleInfo,
    listPackages,
    getPackagesInfo,
    exit,
}

```

`js/index.js`:

```js
let callbackCounter = 0;
function getUniqueCallbackName(prefix) {
  return `${prefix}_callback_${Date.now()}_${callbackCounter++}`;
}

export function exec(command, options) {
  if (typeof options === "undefined") {
    options = {};
  }

  return new Promise((resolve, reject) => {
    // Generate a unique callback function name
    const callbackFuncName = getUniqueCallbackName("exec");

    // Define the success callback function
    window[callbackFuncName] = (errno, stdout, stderr) => {
      resolve({ errno, stdout, stderr });
      cleanup(callbackFuncName);
    };

    function cleanup(successName) {
      delete window[successName];
    }

    try {
      ksu.exec(command, JSON.stringify(options), callbackFuncName);
    } catch (error) {
      reject(error);
      cleanup(callbackFuncName);
    }
  });
}

function Stdio() {
    this.listeners = {};
  }
  
  Stdio.prototype.on = function (event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  };
  
  Stdio.prototype.emit = function (event, ...args) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((listener) => listener(...args));
    }
  };
  
  function ChildProcess() {
    this.listeners = {};
    this.stdin = new Stdio();
    this.stdout = new Stdio();
    this.stderr = new Stdio();
  }
  
  ChildProcess.prototype.on = function (event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  };
  
  ChildProcess.prototype.emit = function (event, ...args) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((listener) => listener(...args));
    }
  };
  
  export function spawn(command, args, options) {
    if (typeof args === "undefined") {
      args = [];
    } else if (!(args instanceof Array)) {
        // allow for (command, options) signature
        options = args;
    }
    
    if (typeof options === "undefined") {
      options = {};
    }
  
    const child = new ChildProcess();
    const childCallbackName = getUniqueCallbackName("spawn");
    window[childCallbackName] = child;
  
    function cleanup(name) {
      delete window[name];
    }

    child.on("exit", code => {
        cleanup(childCallbackName);
    });

    try {
      ksu.spawn(
        command,
        JSON.stringify(args),
        JSON.stringify(options),
        childCallbackName
      );
    } catch (error) {
      child.emit("error", error);
      cleanup(childCallbackName);
    }
    return child;
  }

export function fullScreen(isFullScreen) {
  ksu.fullScreen(isFullScreen);
}

export function enableEdgeToEdge(enable) {
  ksu.enableEdgeToEdge(enable);
}

export function toast(message) {
  ksu.toast(message);
}

export function moduleInfo() {
  return ksu.moduleInfo();
}

export function listPackages(type) {
  try {
    return JSON.parse(ksu.listPackages(type));
  } catch (error) {
    return [];
  }
}

export function getPackagesInfo(packages) {
  try {
    if (typeof packages !== "string") {
      packages = JSON.stringify(packages);
    }
    return JSON.parse(ksu.getPackagesInfo(packages));
  } catch (error) {
    return [];
  }
}

export function exit() {
  ksu.exit();
}

```

`js/package.json`:

```json
{
  "name": "kernelsu",
  "version": "3.0.2",
  "description": "Library for KernelSU's module WebUI",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "test": "npm run test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tiann/KernelSU.git"
  },
  "keywords": [
    "su",
    "kernelsu",
    "module",
    "webui"
  ],
  "author": "weishu",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/tiann/KernelSU/issues"
  },
  "homepage": "https://github.com/tiann/KernelSU#readme"
}

```

`justfile`:

```
alias bk := build_ksud
alias bm := build_manager

build_ksud:
    cross build --target aarch64-linux-android --release --manifest-path ./userspace/ksud/Cargo.toml

build_manager: build_ksud
    cp userspace/ksud/target/aarch64-linux-android/release/ksud manager/app/src/main/jniLibs/arm64-v8a/libksud.so
    cd manager && ./gradlew aDebug

clippy:
    cargo fmt --manifest-path ./userspace/ksud/Cargo.toml
    cross clippy --target x86_64-pc-windows-gnu --release --manifest-path ./userspace/ksud/Cargo.toml
    cross clippy --target aarch64-linux-android --release --manifest-path ./userspace/ksud/Cargo.toml

```

`kernel/Kbuild`:

```
kernelsu-objs := ksu.o
kernelsu-objs += allowlist.o
kernelsu-objs += app_profile.o
kernelsu-objs += apk_sign.o
kernelsu-objs += sucompat.o
kernelsu-objs += syscall_hook_manager.o
kernelsu-objs += throne_tracker.o
kernelsu-objs += pkg_observer.o
kernelsu-objs += setuid_hook.o
kernelsu-objs += kernel_umount.o
kernelsu-objs += supercalls.o
kernelsu-objs += su_mount_ns.o
kernelsu-objs += feature.o
kernelsu-objs += ksud.o
kernelsu-objs += seccomp_cache.o
kernelsu-objs += file_wrapper.o
kernelsu-objs += util.o

kernelsu-objs += selinux/selinux.o
kernelsu-objs += selinux/sepolicy.o
kernelsu-objs += selinux/rules.o
ccflags-y += -I$(srctree)/security/selinux -I$(srctree)/security/selinux/include
ccflags-y += -I$(objtree)/security/selinux -include $(srctree)/include/uapi/asm-generic/errno.h

obj-$(CONFIG_KSU) += kernelsu.o

MDIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

# Workaround bazel
# https://github.com/tiann/KernelSU/pull/316#issuecomment-1479043219
GIT := $(shell PATH="$$PATH":/usr/bin:/usr/local/bin which git)
ifneq ($(GIT),)
# Check if this is a git repository
# Try to detect Git repo intelligently
GIT_ROOT := $(shell cd $(MDIR) && $(GIT) rev-parse --show-toplevel 2>/dev/null)
ifneq ($(GIT_ROOT),)
KERNEL_GIT_ROOT := $(shell cd $(srctree) && $(GIT) rev-parse --show-toplevel 2>/dev/null)
ifneq ($(GIT_ROOT),$(KERNEL_GIT_ROOT))
# Only set version if it's a different repo from kernel
$(shell cd $(GIT_ROOT) && [ -f .git/shallow ] && $(GIT) fetch --unshallow 2>/dev/null || true)
KSU_GIT_VERSION := $(shell cd $(GIT_ROOT) && $(GIT) rev-list --count HEAD 2>/dev/null)
KSU_GIT_VERSION_VALID := 1
$(info -- KernelSU: Git repo detected at $(GIT_ROOT))
endif
endif
else
$(warning -- KernelSU: Git not detected, make sure git is installed in your PATH!)
endif


# Calculate version if git version is available
ifdef KSU_GIT_VERSION_VALID
# ksu_version: major * 10000 + git version + 200 for historical reasons
$(eval KSU_VERSION=$(shell expr 30000 + $(KSU_GIT_VERSION)))
$(info -- KernelSU version: $(KSU_VERSION))
ccflags-y += -DKSU_VERSION=$(KSU_VERSION)
else
# If there is no .git directory, use default version
$(warning "KSU_GIT_VERSION not defined! It is better to make KernelSU a git repository!")
ccflags-y += -DKSU_VERSION=16
endif

ifndef KSU_EXPECTED_SIZE
KSU_EXPECTED_SIZE := 0x033b
endif

ifndef KSU_EXPECTED_HASH
KSU_EXPECTED_HASH := c371061b19d8c7d7d6133c6a9bafe198fa944e50c1b31c9d8daa8d7f1fc2d2d6
endif

ifdef KSU_MANAGER_PACKAGE
ccflags-y += -DKSU_MANAGER_PACKAGE=\"$(KSU_MANAGER_PACKAGE)\"
$(info -- KernelSU Manager package name: $(KSU_MANAGER_PACKAGE))
endif

$(info -- KernelSU Manager signature size: $(KSU_EXPECTED_SIZE))
$(info -- KernelSU Manager signature hash: $(KSU_EXPECTED_HASH))

ccflags-y += -DEXPECTED_SIZE=$(KSU_EXPECTED_SIZE)
ccflags-y += -DEXPECTED_HASH=\"$(KSU_EXPECTED_HASH)\"

ccflags-y += -Wno-strict-prototypes -Wno-int-conversion -Wno-gcc-compat -Wno-missing-prototypes
ccflags-y += -Wno-declaration-after-statement -Wno-unused-function

# Keep a new line here!! Because someone may append config

```

`kernel/Kconfig`:

```
menu "KernelSU"

config KSU
	tristate "KernelSU function support"
	depends on KPROBES
	default y
	help
	  Enable kernel-level root privileges on Android System.
	  Requires CONFIG_KPROBES for kernel hooking support.
	  To compile as a module, choose M here: the
	  module will be called kernelsu.

config KSU_DEBUG
	bool "KernelSU debug mode"
	depends on KSU
	default n
	help
	  Enable KernelSU debug mode.

endmenu

```

`kernel/LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`kernel/Makefile`:

```
KDIR := $(KDIR)
MDIR := $(realpath $(dir $(abspath $(lastword $(MAKEFILE_LIST)))))

$(info -- KDIR: $(KDIR))
$(info -- MDIR: $(MDIR))

.PHONY: all compdb clean format check-format

all: check_symbol
	make -C $(KDIR) M=$(MDIR) modules
	./check_symbol kernelsu.ko $(KDIR)/vmlinux
compdb:
	python3 $(MDIR)/.vscode/generate_compdb.py -O $(KDIR) $(MDIR)
clean:
	make -C $(KDIR) M=$(MDIR) clean
	rm check_symbol
check_symbol: tools/check_symbol.c
	$(CC) tools/check_symbol.c -o check_symbol
format:
	find . \( -name "*.c" -o -name "*.h" \) -print0 | xargs -0 clang-format -i
check-format:
	find . \( -name "*.c" -o -name "*.h" \) -print0 | xargs -0 clang-format --dry-run --Werror

# Keep a new line here!! Because someone may append config

```

`kernel/allowlist.c`:

```c
#include <linux/rcupdate.h>
#include <linux/limits.h>
#include <linux/rculist.h>
#include <linux/mutex.h>
#include <linux/task_work.h>
#include <linux/capability.h>
#include <linux/compiler.h>
#include <linux/fs.h>
#include <linux/gfp.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/printk.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/version.h>
#include <linux/compiler_types.h>

#include "klog.h" // IWYU pragma: keep
#include "ksud.h"
#include "selinux/selinux.h"
#include "allowlist.h"
#include "manager.h"
#include "su_mount_ns.h"

#define FILE_MAGIC 0x7f4b5355 // ' KSU', u32
#define FILE_FORMAT_VERSION 3 // u32

#define KSU_APP_PROFILE_PRESERVE_UID 9999 // NOBODY_UID
#define KSU_DEFAULT_SELINUX_DOMAIN "u:r:" KERNEL_SU_DOMAIN ":s0"

static DEFINE_MUTEX(allowlist_mutex);

// default profiles, these may be used frequently, so we cache it
static struct root_profile default_root_profile;
static struct non_root_profile default_non_root_profile;

static int allow_list_arr[PAGE_SIZE / sizeof(int)] __read_mostly
    __aligned(PAGE_SIZE);
static int allow_list_pointer __read_mostly = 0;

static void remove_uid_from_arr(uid_t uid)
{
    int i;
    for (i = 0; i < allow_list_pointer; i++) {
        if (allow_list_arr[i] == uid) {
            int remaining = allow_list_pointer - 1 - i;
            if (remaining > 0) {
                memmove(&allow_list_arr[i], &allow_list_arr[i + 1],
                        remaining * sizeof(allow_list_arr[0]));
            }
            allow_list_pointer--;
            allow_list_arr[allow_list_pointer] = -1;
            return;
        }
    }
}

static void init_default_profiles()
{
    kernel_cap_t full_cap = CAP_FULL_SET;

    default_root_profile.uid = 0;
    default_root_profile.gid = 0;
    default_root_profile.groups_count = 1;
    default_root_profile.groups[0] = 0;
    memcpy(&default_root_profile.capabilities.effective, &full_cap,
           sizeof(default_root_profile.capabilities.effective));
    default_root_profile.namespaces = KSU_NS_INHERITED;
    strcpy(default_root_profile.selinux_domain, KSU_DEFAULT_SELINUX_DOMAIN);

    // This means that we will umount modules by default!
    default_non_root_profile.umount_modules = true;
}

struct perm_data {
    struct list_head list;
    struct rcu_head rcu;
    struct app_profile profile;
};

static struct list_head allow_list;

static uint8_t allow_list_bitmap[PAGE_SIZE] __read_mostly __aligned(PAGE_SIZE);
#define BITMAP_UID_MAX ((sizeof(allow_list_bitmap) * BITS_PER_BYTE) - 1)

#define KERNEL_SU_ALLOWLIST "/data/adb/ksu/.allowlist"

void ksu_persistent_allow_list(void);

void ksu_show_allow_list(void)
{
    struct perm_data *p = NULL;
    pr_info("ksu_show_allow_list\n");
    rcu_read_lock();
    list_for_each_entry_rcu (p, &allow_list, list) {
        pr_info("uid :%d, allow: %d\n", p->profile.current_uid,
                p->profile.allow_su);
    }
    rcu_read_unlock();
}

#ifdef CONFIG_KSU_DEBUG
static void ksu_grant_root_to_shell()
{
    struct app_profile profile = {
        .version = KSU_APP_PROFILE_VER,
        .allow_su = true,
        .current_uid = 2000,
    };
    strcpy(profile.key, "com.android.shell");
    strcpy(profile.rp_config.profile.selinux_domain,
           KSU_DEFAULT_SELINUX_DOMAIN);
    ksu_set_app_profile(&profile);
}
#endif

bool ksu_get_app_profile(struct app_profile *profile)
{
    struct perm_data *p = NULL;
    bool found = false;

    rcu_read_lock();
    list_for_each_entry_rcu (p, &allow_list, list) {
        bool uid_match = profile->current_uid == p->profile.current_uid;
        if (uid_match) {
            // found it, override it with ours
            memcpy(profile, &p->profile, sizeof(*profile));
            found = true;
            goto exit;
        }
    }

exit:
    rcu_read_unlock();
    return found;
}

static inline bool forbid_system_uid(uid_t uid)
{
#define SHELL_UID 2000
#define SYSTEM_UID 1000
    return uid < SHELL_UID && uid != SYSTEM_UID;
}

static bool profile_valid(struct app_profile *profile)
{
    if (!profile) {
        return false;
    }

    if (profile->version < KSU_APP_PROFILE_VER) {
        pr_info("Unsupported profile version: %d\n", profile->version);
        return false;
    }

    if (profile->allow_su) {
        if (profile->rp_config.profile.groups_count > KSU_MAX_GROUPS) {
            return false;
        }

        if (strlen(profile->rp_config.profile.selinux_domain) == 0) {
            return false;
        }
    }

    return true;
}

int ksu_set_app_profile(struct app_profile *profile)
{
    struct perm_data *p = NULL, *np;
    int result = 0;
    u16 count = 0;

    if (!profile_valid(profile)) {
        pr_err("Failed to set app profile: invalid profile!\n");
        return -EINVAL;
    }

    mutex_lock(&allowlist_mutex);

    list_for_each_entry (p, &allow_list, list) {
        ++count;
        // both uid and package must match, otherwise it will break multiple package with different user id
        if (profile->current_uid == p->profile.current_uid &&
            !strcmp(profile->key, p->profile.key)) {
            // found it, just override it all!
            np = (struct perm_data *)kzalloc(sizeof(struct perm_data),
                                             GFP_KERNEL);
            if (!np) {
                result = -ENOMEM;
                goto out_unlock;
            }
            memcpy(&np->profile, profile, sizeof(*profile));
            list_replace_rcu(&p->list, &np->list);
            kfree_rcu(p, rcu);
            goto out;
        }
    }

    if (unlikely(count == U16_MAX)) {
        pr_err("too many app profile\n");
        result = -E2BIG;
        goto out_unlock;
    }

    // not found, alloc a new node!
    p = (struct perm_data *)kzalloc(sizeof(struct perm_data), GFP_KERNEL);
    if (!p) {
        pr_err("ksu_set_app_profile alloc failed\n");
        result = -ENOMEM;
        goto out_unlock;
    }

    memcpy(&p->profile, profile, sizeof(*profile));
    if (profile->allow_su) {
        pr_info("set root profile, key: %s, uid: %d, gid: %d, context: %s\n",
                profile->key, profile->current_uid,
                profile->rp_config.profile.gid,
                profile->rp_config.profile.selinux_domain);
    } else {
        pr_info("set app profile, key: %s, uid: %d, umount modules: %d\n",
                profile->key, profile->current_uid,
                profile->nrp_config.profile.umount_modules);
    }

    list_add_tail_rcu(&p->list, &allow_list);

out:
    result = 0;

    // check if the default profiles is changed, cache it to a single struct to accelerate access.
    if (unlikely(!strcmp(profile->key, "$"))) {
        // set default non root profile
        memcpy(&default_non_root_profile, &profile->nrp_config.profile,
               sizeof(default_non_root_profile));
    } else if (unlikely(!strcmp(profile->key, "#"))) {
        // set default root profile
        // TODO: Do we really need this?
        memcpy(&default_root_profile, &profile->rp_config.profile,
               sizeof(default_root_profile));
    } else if (profile->current_uid <= BITMAP_UID_MAX) {
        if (profile->allow_su)
            allow_list_bitmap[profile->current_uid / BITS_PER_BYTE] |=
                1 << (profile->current_uid % BITS_PER_BYTE);
        else
            allow_list_bitmap[profile->current_uid / BITS_PER_BYTE] &=
                ~(1 << (profile->current_uid % BITS_PER_BYTE));
    } else {
        if (profile->allow_su) {
            /*
             * 1024 apps with uid higher than BITMAP_UID_MAX
             * registered to request superuser?
             */
            if (allow_list_pointer >= ARRAY_SIZE(allow_list_arr)) {
                pr_err("too many apps registered\n");
                WARN_ON(1);
            } else {
                allow_list_arr[allow_list_pointer++] = profile->current_uid;
            }
        } else {
            remove_uid_from_arr(profile->current_uid);
        }
    }

out_unlock:
    mutex_unlock(&allowlist_mutex);
    return result;
}

bool __ksu_is_allow_uid(uid_t uid)
{
    int i;

    if (forbid_system_uid(uid)) {
        // do not bother going through the list if it's system
        return false;
    }

    if (likely(ksu_is_manager_appid_valid()) &&
        unlikely(ksu_get_manager_appid() == uid % PER_USER_RANGE)) {
        // manager is always allowed!
        return true;
    }

    if (likely(uid <= BITMAP_UID_MAX)) {
        return !!(allow_list_bitmap[uid / BITS_PER_BYTE] &
                  (1 << (uid % BITS_PER_BYTE)));
    } else {
        for (i = 0; i < allow_list_pointer; i++) {
            if (allow_list_arr[i] == uid)
                return true;
        }
    }

    return false;
}

bool __ksu_is_allow_uid_for_current(uid_t uid)
{
    if (unlikely(uid == 0)) {
        // already root, but only allow our domain.
        return is_ksu_domain();
    }
    return __ksu_is_allow_uid(uid);
}

bool ksu_uid_should_umount(uid_t uid)
{
    struct app_profile profile = { .current_uid = uid };
    if (likely(ksu_is_manager_appid_valid()) &&
        unlikely(ksu_get_manager_appid() == uid % PER_USER_RANGE)) {
        // we should not umount on manager!
        return false;
    }
    bool found = ksu_get_app_profile(&profile);
    if (!found) {
        // no app profile found, it must be non root app
        return default_non_root_profile.umount_modules;
    }
    if (profile.allow_su) {
        // if found and it is granted to su, we shouldn't umount for it
        return false;
    } else {
        // found an app profile
        if (profile.nrp_config.use_default) {
            return default_non_root_profile.umount_modules;
        } else {
            return profile.nrp_config.profile.umount_modules;
        }
    }
}

void ksu_get_root_profile(uid_t uid, struct root_profile *profile)
{
    struct perm_data *p = NULL;

    if (is_uid_manager(uid)) {
        goto use_default;
    }

    rcu_read_lock();
    list_for_each_entry_rcu (p, &allow_list, list) {
        if (uid == p->profile.current_uid && p->profile.allow_su) {
            if (!p->profile.rp_config.use_default) {
                memcpy(profile, &p->profile.rp_config.profile,
                       sizeof(*profile));
                rcu_read_unlock();
                return;
            }
        }
    }
    rcu_read_unlock();

use_default:
    // use default profile
    memcpy(profile, &default_root_profile, sizeof(*profile));
}

bool ksu_get_allow_list(int *array, u16 length, u16 *out_length, u16 *out_total,
                        bool allow)
{
    struct perm_data *p = NULL;
    u16 i = 0, j = 0;
    rcu_read_lock();
    list_for_each_entry_rcu (p, &allow_list, list) {
        // pr_info("get_allow_list uid: %d allow: %d\n", p->uid, p->allow);
        if (p->profile.allow_su == allow &&
            !is_uid_manager(p->profile.current_uid)) {
            if (j < length) {
                array[j++] = p->profile.current_uid;
            }
            ++i;
        }
    }
    rcu_read_unlock();
    if (out_length) {
        *out_length = j;
    }
    if (out_total) {
        *out_total = i;
    }

    return true;
}

// TODO: move to kernel thread or work queue
static void do_persistent_allow_list(struct callback_head *_cb)
{
    u32 magic = FILE_MAGIC;
    u32 version = FILE_FORMAT_VERSION;
    struct perm_data *p = NULL;
    loff_t off = 0;

    struct file *fp =
        filp_open(KERNEL_SU_ALLOWLIST, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (IS_ERR(fp)) {
        pr_err("save_allow_list create file failed: %ld\n", PTR_ERR(fp));
        goto out;
    }

    // store magic and version
    if (kernel_write(fp, &magic, sizeof(magic), &off) != sizeof(magic)) {
        pr_err("save_allow_list write magic failed.\n");
        goto close_file;
    }

    if (kernel_write(fp, &version, sizeof(version), &off) != sizeof(version)) {
        pr_err("save_allow_list write version failed.\n");
        goto close_file;
    }

    mutex_lock(&allowlist_mutex);
    list_for_each_entry (p, &allow_list, list) {
        pr_info("save allow list, name: %s uid :%d, allow: %d\n",
                p->profile.key, p->profile.current_uid, p->profile.allow_su);

        kernel_write(fp, &p->profile, sizeof(p->profile), &off);
    }
    mutex_unlock(&allowlist_mutex);

close_file:
    filp_close(fp, 0);
out:
    kfree(_cb);
}

void ksu_persistent_allow_list()
{
    struct task_struct *tsk;

    tsk = get_pid_task(find_vpid(1), PIDTYPE_PID);
    if (!tsk) {
        pr_err("save_allow_list find init task err\n");
        return;
    }

    struct callback_head *cb =
        kzalloc(sizeof(struct callback_head), GFP_KERNEL);
    if (!cb) {
        pr_err("save_allow_list alloc cb err\b");
        goto put_task;
    }
    cb->func = do_persistent_allow_list;
    if (task_work_add(tsk, cb, TWA_RESUME)) {
        kfree(cb);
        pr_warn("save_allow_list add task_work failed\n");
    }

put_task:
    put_task_struct(tsk);
}

void ksu_load_allow_list()
{
    loff_t off = 0;
    ssize_t ret = 0;
    struct file *fp = NULL;
    u32 magic;
    u32 version;

#ifdef CONFIG_KSU_DEBUG
    // always allow adb shell by default
    ksu_grant_root_to_shell();
#endif

    // load allowlist now!
    fp = filp_open(KERNEL_SU_ALLOWLIST, O_RDONLY, 0);
    if (IS_ERR(fp)) {
        pr_err("load_allow_list open file failed: %ld\n", PTR_ERR(fp));
        return;
    }

    // verify magic
    if (kernel_read(fp, &magic, sizeof(magic), &off) != sizeof(magic) ||
        magic != FILE_MAGIC) {
        pr_err("allowlist file invalid: %d!\n", magic);
        goto exit;
    }

    if (kernel_read(fp, &version, sizeof(version), &off) != sizeof(version)) {
        pr_err("allowlist read version: %d failed\n", version);
        goto exit;
    }

    pr_info("allowlist version: %d\n", version);

    while (true) {
        struct app_profile profile;

        ret = kernel_read(fp, &profile, sizeof(profile), &off);

        if (ret <= 0) {
            pr_info("load_allow_list read err: %zd\n", ret);
            break;
        }

        pr_info("load_allow_uid, name: %s, uid: %d, allow: %d\n", profile.key,
                profile.current_uid, profile.allow_su);
        ksu_set_app_profile(&profile);
    }

exit:
    ksu_show_allow_list();
    filp_close(fp, 0);
}

void ksu_prune_allowlist(bool (*is_uid_valid)(uid_t, char *, void *),
                         void *data)
{
    struct perm_data *np = NULL;
    struct perm_data *n = NULL;

    if (!ksu_boot_completed) {
        pr_info("boot not completed, skip prune\n");
        return;
    }

    bool modified = false;
    mutex_lock(&allowlist_mutex);
    list_for_each_entry_safe (np, n, &allow_list, list) {
        uid_t uid = np->profile.current_uid;
        char *package = np->profile.key;
        // we use this uid for special cases, don't prune it!
        bool is_preserved_uid = uid == KSU_APP_PROFILE_PRESERVE_UID;
        if (!is_preserved_uid && !is_uid_valid(uid, package, data)) {
            modified = true;
            pr_info("prune uid: %d, package: %s\n", uid, package);
            list_del_rcu(&np->list);
            kfree_rcu(np, rcu);
            if (likely(uid <= BITMAP_UID_MAX)) {
                allow_list_bitmap[uid / BITS_PER_BYTE] &=
                    ~(1 << (uid % BITS_PER_BYTE));
            }
            remove_uid_from_arr(uid);
        }
    }
    mutex_unlock(&allowlist_mutex);

    if (modified) {
        smp_mb();
        ksu_persistent_allow_list();
    }
}

void ksu_allowlist_init(void)
{
    int i;

    BUILD_BUG_ON(sizeof(allow_list_bitmap) != PAGE_SIZE);
    BUILD_BUG_ON(sizeof(allow_list_arr) != PAGE_SIZE);

    for (i = 0; i < ARRAY_SIZE(allow_list_arr); i++)
        allow_list_arr[i] = -1;

    INIT_LIST_HEAD(&allow_list);

    init_default_profiles();
}

void ksu_allowlist_exit(void)
{
    struct perm_data *np = NULL;
    struct perm_data *n = NULL;

    // free allowlist
    mutex_lock(&allowlist_mutex);
    list_for_each_entry_safe (np, n, &allow_list, list) {
        list_del(&np->list);
        kfree(np);
    }
    mutex_unlock(&allowlist_mutex);
}

```

`kernel/allowlist.h`:

```h
#ifndef __KSU_H_ALLOWLIST
#define __KSU_H_ALLOWLIST

#include <linux/types.h>
#include <linux/uidgid.h>
#include "app_profile.h"

#define PER_USER_RANGE 100000
#define FIRST_APPLICATION_UID 10000
#define LAST_APPLICATION_UID 19999
#define FIRST_ISOLATED_UID 99000
#define LAST_ISOLATED_UID 99999

void ksu_allowlist_init(void);

void ksu_allowlist_exit(void);

void ksu_load_allow_list(void);

void ksu_show_allow_list(void);

// Check if the uid is in allow list
bool __ksu_is_allow_uid(uid_t uid);
#define ksu_is_allow_uid(uid) unlikely(__ksu_is_allow_uid(uid))

// Check if the uid is in allow list, or current is ksu domain root
bool __ksu_is_allow_uid_for_current(uid_t uid);
#define ksu_is_allow_uid_for_current(uid)                                      \
    unlikely(__ksu_is_allow_uid_for_current(uid))

bool ksu_get_allow_list(int *array, u16 length, u16 *out_length, u16 *out_total,
                        bool allow);

void ksu_prune_allowlist(bool (*is_uid_exist)(uid_t, char *, void *),
                         void *data);
void ksu_persistent_allow_list();

bool ksu_get_app_profile(struct app_profile *);
int ksu_set_app_profile(struct app_profile *);

bool ksu_uid_should_umount(uid_t uid);
void ksu_get_root_profile(uid_t uid, struct root_profile *);

static inline bool is_appuid(uid_t uid)
{
    uid_t appid = uid % PER_USER_RANGE;
    return appid >= FIRST_APPLICATION_UID && appid <= LAST_APPLICATION_UID;
}

static inline bool is_isolated_process(uid_t uid)
{
    uid_t appid = uid % PER_USER_RANGE;
    return appid >= FIRST_ISOLATED_UID && appid <= LAST_ISOLATED_UID;
}
#endif

```

`kernel/apk_sign.c`:

```c
#include <linux/err.h>
#include <linux/fs.h>
#include <linux/gfp.h>
#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/version.h>
#ifdef CONFIG_KSU_DEBUG
#include <linux/moduleparam.h>
#endif
#include <crypto/hash.h>
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
#include <crypto/sha2.h>
#else
#include <crypto/sha.h>
#endif

#include "apk_sign.h"
#include "app_profile.h"
#include "klog.h" // IWYU pragma: keep

struct sdesc {
    struct shash_desc shash;
    char ctx[];
};

static struct sdesc *init_sdesc(struct crypto_shash *alg)
{
    struct sdesc *sdesc;
    int size;

    size = sizeof(struct shash_desc) + crypto_shash_descsize(alg);
    sdesc = kzalloc(size, GFP_KERNEL);
    if (!sdesc)
        return ERR_PTR(-ENOMEM);
    sdesc->shash.tfm = alg;
    return sdesc;
}

static int calc_hash(struct crypto_shash *alg, const unsigned char *data,
                     unsigned int datalen, unsigned char *digest)
{
    struct sdesc *sdesc;
    int ret;

    sdesc = init_sdesc(alg);
    if (IS_ERR(sdesc)) {
        pr_info("can't alloc sdesc\n");
        return PTR_ERR(sdesc);
    }

    ret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);
    kfree(sdesc);
    return ret;
}

static int ksu_sha256(const unsigned char *data, unsigned int datalen,
                      unsigned char *digest)
{
    struct crypto_shash *alg;
    char *hash_alg_name = "sha256";
    int ret;

    alg = crypto_alloc_shash(hash_alg_name, 0, 0);
    if (IS_ERR(alg)) {
        pr_info("can't alloc alg %s\n", hash_alg_name);
        return PTR_ERR(alg);
    }
    ret = calc_hash(alg, data, datalen, digest);
    crypto_free_shash(alg);
    return ret;
}

static bool check_block(struct file *fp, u32 *size4, loff_t *pos, u32 *offset,
                        unsigned expected_size, const char *expected_sha256)
{
    kernel_read(fp, size4, 0x4, pos); // signer-sequence length
    kernel_read(fp, size4, 0x4, pos); // signer length
    kernel_read(fp, size4, 0x4, pos); // signed data length

    *offset += 0x4 * 3;

    kernel_read(fp, size4, 0x4, pos); // digests-sequence length

    *pos += *size4;
    *offset += 0x4 + *size4;

    kernel_read(fp, size4, 0x4, pos); // certificates length
    kernel_read(fp, size4, 0x4, pos); // certificate length
    *offset += 0x4 * 2;

    if (*size4 == expected_size) {
        *offset += *size4;

#define CERT_MAX_LENGTH 1024
        char cert[CERT_MAX_LENGTH];
        if (*size4 > CERT_MAX_LENGTH) {
            pr_info("cert length overlimit\n");
            return false;
        }
        kernel_read(fp, cert, *size4, pos);
        unsigned char digest[SHA256_DIGEST_SIZE];
        if (IS_ERR(ksu_sha256(cert, *size4, digest))) {
            pr_info("sha256 error\n");
            return false;
        }

        char hash_str[SHA256_DIGEST_SIZE * 2 + 1];
        hash_str[SHA256_DIGEST_SIZE * 2] = '\0';

        bin2hex(hash_str, digest, SHA256_DIGEST_SIZE);
        pr_info("sha256: %s, expected: %s\n", hash_str, expected_sha256);
        if (strcmp(expected_sha256, hash_str) == 0) {
            return true;
        }
    }
    return false;
}

struct zip_entry_header {
    uint32_t signature;
    uint16_t version;
    uint16_t flags;
    uint16_t compression;
    uint16_t mod_time;
    uint16_t mod_date;
    uint32_t crc32;
    uint32_t compressed_size;
    uint32_t uncompressed_size;
    uint16_t file_name_length;
    uint16_t extra_field_length;
} __attribute__((packed));

// This is a necessary but not sufficient condition, but it is enough for us
static bool has_v1_signature_file(struct file *fp)
{
    struct zip_entry_header header;
    const char MANIFEST[] = "META-INF/MANIFEST.MF";

    loff_t pos = 0;

    while (kernel_read(fp, &header, sizeof(struct zip_entry_header), &pos) ==
           sizeof(struct zip_entry_header)) {
        if (header.signature != 0x04034b50) {
            // ZIP magic: 'PK'
            return false;
        }
        // Read the entry file name
        if (header.file_name_length == sizeof(MANIFEST) - 1) {
            char fileName[sizeof(MANIFEST)];
            kernel_read(fp, fileName, header.file_name_length, &pos);
            fileName[header.file_name_length] = '\0';

            // Check if the entry matches META-INF/MANIFEST.MF
            if (strncmp(MANIFEST, fileName, sizeof(MANIFEST) - 1) == 0) {
                return true;
            }
        } else {
            // Skip the entry file name
            pos += header.file_name_length;
        }

        // Skip to the next entry
        pos += header.extra_field_length + header.compressed_size;
    }

    return false;
}

static __always_inline bool check_v2_signature(char *path,
                                               unsigned expected_size,
                                               const char *expected_sha256)
{
    unsigned char buffer[0x11] = { 0 };
    u32 size4;
    u64 size8, size_of_block;

    loff_t pos;

    bool v2_signing_valid = false;
    int v2_signing_blocks = 0;
    bool v3_signing_exist = false;
    bool v3_1_signing_exist = false;

    int i;
    struct file *fp = filp_open(path, O_RDONLY, 0);
    if (IS_ERR(fp)) {
        pr_err("open %s error.\n", path);
        return false;
    }

    // disable inotify for this file
    fp->f_mode |= FMODE_NONOTIFY;

    // https://en.wikipedia.org/wiki/Zip_(file_format)#End_of_central_directory_record_(EOCD)
    for (i = 0;; ++i) {
        unsigned short n;
        pos = generic_file_llseek(fp, -i - 2, SEEK_END);
        kernel_read(fp, &n, 2, &pos);
        if (n == i) {
            pos -= 22;
            kernel_read(fp, &size4, 4, &pos);
            if ((size4 ^ 0xcafebabeu) == 0xccfbf1eeu) {
                break;
            }
        }
        if (i == 0xffff) {
            pr_info("error: cannot find eocd\n");
            goto clean;
        }
    }

    pos += 12;
    // offset
    kernel_read(fp, &size4, 0x4, &pos);
    pos = size4 - 0x18;

    kernel_read(fp, &size8, 0x8, &pos);
    kernel_read(fp, buffer, 0x10, &pos);
    if (strcmp((char *)buffer, "APK Sig Block 42")) {
        goto clean;
    }

    pos = size4 - (size8 + 0x8);
    kernel_read(fp, &size_of_block, 0x8, &pos);
    if (size_of_block != size8) {
        goto clean;
    }

    int loop_count = 0;
    while (loop_count++ < 10) {
        uint32_t id;
        uint32_t offset;
        kernel_read(fp, &size8, 0x8,
                    &pos); // sequence length
        if (size8 == size_of_block) {
            break;
        }
        kernel_read(fp, &id, 0x4, &pos); // id
        offset = 4;
        if (id == 0x7109871au) {
            v2_signing_blocks++;
            v2_signing_valid = check_block(fp, &size4, &pos, &offset,
                                           expected_size, expected_sha256);
        } else if (id == 0xf05368c0u) {
            // http://aospxref.com/android-14.0.0_r2/xref/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV3Verifier.java#73
            v3_signing_exist = true;
        } else if (id == 0x1b93ad61u) {
            // http://aospxref.com/android-14.0.0_r2/xref/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV3Verifier.java#74
            v3_1_signing_exist = true;
        } else {
#ifdef CONFIG_KSU_DEBUG
            pr_info("Unknown id: 0x%08x\n", id);
#endif
        }
        pos += (size8 - offset);
    }

    if (v2_signing_blocks != 1) {
#ifdef CONFIG_KSU_DEBUG
        pr_err("Unexpected v2 signature count: %d\n", v2_signing_blocks);
#endif
        v2_signing_valid = false;
    }

    if (v2_signing_valid) {
        int has_v1_signing = has_v1_signature_file(fp);
        if (has_v1_signing) {
            pr_err("Unexpected v1 signature scheme found!\n");
            filp_close(fp, 0);
            return false;
        }
    }
clean:
    filp_close(fp, 0);

    if (v3_signing_exist || v3_1_signing_exist) {
#ifdef CONFIG_KSU_DEBUG
        pr_err("Unexpected v3 signature scheme found!\n");
#endif
        return false;
    }

    return v2_signing_valid;
}

#ifdef CONFIG_KSU_DEBUG

int ksu_debug_manager_appid = -1;

#include "manager.h"

static int set_expected_size(const char *val, const struct kernel_param *kp)
{
    int rv = param_set_uint(val, kp);
    ksu_set_manager_appid(ksu_debug_manager_appid);
    pr_info("ksu_manager_appid set to %d\n", ksu_debug_manager_appid);
    return rv;
}

static struct kernel_param_ops expected_size_ops = {
    .set = set_expected_size,
    .get = param_get_uint,
};

module_param_cb(ksu_debug_manager_appid, &expected_size_ops,
                &ksu_debug_manager_appid, S_IRUSR | S_IWUSR);

#endif

int get_pkg_from_apk_path(char *pkg, const char *path)
{
    int len = strlen(path);
    if (len >= KSU_MAX_PACKAGE_NAME || len < 1)
        return -1;

    const char *last_slash = NULL;
    const char *second_last_slash = NULL;

    int i;
    for (i = len - 1; i >= 0; i--) {
        if (path[i] == '/') {
            if (!last_slash) {
                last_slash = &path[i];
            } else {
                second_last_slash = &path[i];
                break;
            }
        }
    }

    if (!last_slash || !second_last_slash)
        return -1;

    const char *last_hyphen = strchr(second_last_slash, '-');
    if (!last_hyphen || last_hyphen > last_slash)
        return -1;

    int pkg_len = last_hyphen - second_last_slash - 1;
    if (pkg_len >= KSU_MAX_PACKAGE_NAME || pkg_len <= 0)
        return -1;

    // Copying the package name
    strncpy(pkg, second_last_slash + 1, pkg_len);
    pkg[pkg_len] = '\0';

    return 0;
}

bool is_manager_apk(char *path)
{
#ifdef KSU_MANAGER_PACKAGE
    char pkg[KSU_MAX_PACKAGE_NAME];
    if (get_pkg_from_apk_path(pkg, path) < 0) {
        pr_err("Failed to get package name from apk path: %s\n", path);
        return false;
    }

    // pkg is `<real package>`
    if (strncmp(pkg, KSU_MANAGER_PACKAGE, sizeof(KSU_MANAGER_PACKAGE))) {
        return false;
    }
#endif
    return check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH);
}
```

`kernel/apk_sign.h`:

```h
#ifndef __KSU_H_APK_V2_SIGN
#define __KSU_H_APK_V2_SIGN

#include <linux/types.h>

bool is_manager_apk(char *path);
int get_pkg_from_apk_path(char *pkg, const char *path);

#endif

```

`kernel/app_profile.c`:

```c
#include <linux/capability.h>
#include <linux/cred.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/seccomp.h>
#include <linux/slab.h>
#include <linux/thread_info.h>
#include <linux/uidgid.h>
#include <linux/version.h>

#include "allowlist.h"
#include "app_profile.h"
#include "klog.h" // IWYU pragma: keep
#include "selinux/selinux.h"
#include "su_mount_ns.h"
#include "syscall_hook_manager.h"

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
static struct group_info root_groups = { .usage = REFCOUNT_INIT(2) };
#else
static struct group_info root_groups = { .usage = ATOMIC_INIT(2) };
#endif

void setup_groups(struct root_profile *profile, struct cred *cred)
{
    if (profile->groups_count > KSU_MAX_GROUPS) {
        pr_warn("Failed to setgroups, too large group: %d!\n", profile->uid);
        return;
    }

    if (profile->groups_count == 1 && profile->groups[0] == 0) {
        // setgroup to root and return early.
        if (cred->group_info)
            put_group_info(cred->group_info);
        cred->group_info = get_group_info(&root_groups);
        return;
    }

    u32 ngroups = profile->groups_count;
    struct group_info *group_info = groups_alloc(ngroups);
    if (!group_info) {
        pr_warn("Failed to setgroups, ENOMEM for: %d\n", profile->uid);
        return;
    }

    int i;
    for (i = 0; i < ngroups; i++) {
        gid_t gid = profile->groups[i];
        kgid_t kgid = make_kgid(current_user_ns(), gid);
        if (!gid_valid(kgid)) {
            pr_warn("Failed to setgroups, invalid gid: %d\n", gid);
            put_group_info(group_info);
            return;
        }
        group_info->gid[i] = kgid;
    }

    groups_sort(group_info);
    set_groups(cred, group_info);
    put_group_info(group_info);
}

void seccomp_filter_release(struct task_struct *tsk);

static void disable_seccomp(void)
{
    struct task_struct *fake;

    fake = kmalloc(sizeof(*fake), GFP_ATOMIC);
    if (!fake) {
        pr_warn("failed to alloc fake task_struct\n");
        return;
    }

    // Refer to kernel/seccomp.c: seccomp_set_mode_strict
    // When disabling Seccomp, ensure that current->sighand->siglock is held during the operation.
    spin_lock_irq(&current->sighand->siglock);
    // disable seccomp
#if defined(CONFIG_GENERIC_ENTRY) &&                                           \
    LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
    clear_syscall_work(SECCOMP);
#else
    clear_thread_flag(TIF_SECCOMP);
#endif

    memcpy(fake, current, sizeof(*fake));

    current->seccomp.mode = 0;
    current->seccomp.filter = NULL;
    atomic_set(&current->seccomp.filter_count, 0);
    spin_unlock_irq(&current->sighand->siglock);

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
    // https://github.com/torvalds/linux/commit/bfafe5efa9754ebc991750da0bcca2a6694f3ed3#diff-45eb79a57536d8eccfc1436932f093eb5c0b60d9361c39edb46581ad313e8987R576-R577
    fake->flags |= PF_EXITING;
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
    // https://github.com/torvalds/linux/commit/0d8315dddd2899f519fe1ca3d4d5cdaf44ea421e#diff-45eb79a57536d8eccfc1436932f093eb5c0b60d9361c39edb46581ad313e8987R556-R558
    fake->sighand = NULL;
#endif

    seccomp_filter_release(fake);
    kfree(fake);
}

void escape_with_root_profile(void)
{
    struct cred *cred;
    struct task_struct *p = current;
    struct task_struct *t;
    struct root_profile profile;

    cred = prepare_creds();
    if (!cred) {
        pr_warn("prepare_creds failed!\n");
        return;
    }

    if (cred->euid.val == 0) {
        pr_warn("Already root, don't escape!\n");
        abort_creds(cred);
        return;
    }

    ksu_get_root_profile(cred->uid.val, &profile);

    cred->uid.val = profile.uid;
    cred->suid.val = profile.uid;
    cred->euid.val = profile.uid;
    cred->fsuid.val = profile.uid;

    cred->gid.val = profile.gid;
    cred->fsgid.val = profile.gid;
    cred->sgid.val = profile.gid;
    cred->egid.val = profile.gid;
    cred->securebits = 0;

    BUILD_BUG_ON(sizeof(profile.capabilities.effective) !=
                 sizeof(kernel_cap_t));

    // setup capabilities
    // we need CAP_DAC_READ_SEARCH becuase `/data/adb/ksud` is not accessible for non root process
    // we add it here but don't add it to cap_inhertiable, it would be dropped automaticly after exec!
    u64 cap_for_ksud = profile.capabilities.effective | CAP_DAC_READ_SEARCH;
    memcpy(&cred->cap_effective, &cap_for_ksud, sizeof(cred->cap_effective));
    memcpy(&cred->cap_permitted, &profile.capabilities.effective,
           sizeof(cred->cap_permitted));
    memcpy(&cred->cap_bset, &profile.capabilities.effective,
           sizeof(cred->cap_bset));

    setup_groups(&profile, cred);
    setup_selinux(profile.selinux_domain, cred);

    commit_creds(cred);

    disable_seccomp();

    for_each_thread (p, t) {
        ksu_set_task_tracepoint_flag(t);
    }

    setup_mount_ns(profile.namespaces);
}

void escape_to_root_for_init(void)
{
    struct cred *cred = prepare_creds();
    if (!cred) {
        pr_err("Failed to prepare init's creds!\n");
        return;
    }

    setup_selinux(KERNEL_SU_CONTEXT, cred);
    commit_creds(cred);
}

```

`kernel/app_profile.h`:

```h
#ifndef __KSU_H_APP_PROFILE
#define __KSU_H_APP_PROFILE

#include <linux/types.h>

// Forward declarations
struct cred;

#define KSU_APP_PROFILE_VER 2
#define KSU_MAX_PACKAGE_NAME 256
// NGROUPS_MAX for Linux is 65535 generally, but we only supports 32 groups.
#define KSU_MAX_GROUPS 32
#define KSU_SELINUX_DOMAIN 64

struct root_profile {
    int32_t uid;
    int32_t gid;

    int32_t groups_count;
    int32_t groups[KSU_MAX_GROUPS];

    // kernel_cap_t is u32[2] for capabilities v3
    struct {
        u64 effective;
        u64 permitted;
        u64 inheritable;
    } capabilities;

    char selinux_domain[KSU_SELINUX_DOMAIN];

    int32_t namespaces;
};

struct non_root_profile {
    bool umount_modules;
};

struct app_profile {
    // It may be utilized for backward compatibility, although we have never explicitly made any promises regarding this.
    u32 version;

    // this is usually the package of the app, but can be other value for special apps
    char key[KSU_MAX_PACKAGE_NAME];
    int32_t current_uid;
    bool allow_su;

    union {
        struct {
            bool use_default;
            char template_name[KSU_MAX_PACKAGE_NAME];

            struct root_profile profile;
        } rp_config;

        struct {
            bool use_default;

            struct non_root_profile profile;
        } nrp_config;
    };
};

// Escalate current process to root with the appropriate profile
void escape_with_root_profile(void);

void escape_to_root_for_init(void);

#endif

```

`kernel/arch.h`:

```h
#ifndef __KSU_H_ARCH
#define __KSU_H_ARCH

#include <linux/version.h>

#if defined(__aarch64__)

#define __PT_PARM1_REG regs[0]
#define __PT_PARM2_REG regs[1]
#define __PT_PARM3_REG regs[2]
#define __PT_SYSCALL_PARM4_REG regs[3]
#define __PT_CCALL_PARM4_REG regs[3]
#define __PT_PARM5_REG regs[4]
#define __PT_PARM6_REG regs[5]
#define __PT_RET_REG regs[30]
#define __PT_FP_REG regs[29] /* Works only with CONFIG_FRAME_POINTER */
#define __PT_RC_REG regs[0]
#define __PT_SP_REG sp
#define __PT_IP_REG pc

#define REBOOT_SYMBOL "__arm64_sys_reboot"
#define SYS_READ_SYMBOL "__arm64_sys_read"
#define SYS_EXECVE_SYMBOL "__arm64_sys_execve"
// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/scripts/syscalltbl.sh;l=57;drc=9142be9e6443fd641ca37f820efe00d9cd890eb1
// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/scripts/syscall.tbl;l=104;drc=b36d4b6aa88ef039647228b98c59a875e92f8c8e
#define SYS_FSTAT_SYMBOL "__arm64_sys_newfstat"

#elif defined(__x86_64__)

#define __PT_PARM1_REG di
#define __PT_PARM2_REG si
#define __PT_PARM3_REG dx
/* syscall uses r10 for PARM4 */
#define __PT_SYSCALL_PARM4_REG r10
#define __PT_CCALL_PARM4_REG cx
#define __PT_PARM5_REG r8
#define __PT_PARM6_REG r9
#define __PT_RET_REG sp
#define __PT_FP_REG bp
#define __PT_RC_REG ax
#define __PT_SP_REG sp
#define __PT_IP_REG ip
#define REBOOT_SYMBOL "__x64_sys_reboot"
#define SYS_READ_SYMBOL "__x64_sys_read"
#define SYS_EXECVE_SYMBOL "__x64_sys_execve"
#define SYS_FSTAT_SYMBOL "__x64_sys_newfstat"

#else
#error "Unsupported arch"
#endif

/* allow some architecutres to override `struct pt_regs` */
#ifndef __PT_REGS_CAST
#define __PT_REGS_CAST(x) (x)
#endif

#define PT_REGS_PARM1(x) (__PT_REGS_CAST(x)->__PT_PARM1_REG)
#define PT_REGS_PARM2(x) (__PT_REGS_CAST(x)->__PT_PARM2_REG)
#define PT_REGS_PARM3(x) (__PT_REGS_CAST(x)->__PT_PARM3_REG)
#define PT_REGS_SYSCALL_PARM4(x) (__PT_REGS_CAST(x)->__PT_SYSCALL_PARM4_REG)
#define PT_REGS_CCALL_PARM4(x) (__PT_REGS_CAST(x)->__PT_CCALL_PARM4_REG)
#define PT_REGS_PARM5(x) (__PT_REGS_CAST(x)->__PT_PARM5_REG)
#define PT_REGS_PARM6(x) (__PT_REGS_CAST(x)->__PT_PARM6_REG)
#define PT_REGS_RET(x) (__PT_REGS_CAST(x)->__PT_RET_REG)
#define PT_REGS_FP(x) (__PT_REGS_CAST(x)->__PT_FP_REG)
#define PT_REGS_RC(x) (__PT_REGS_CAST(x)->__PT_RC_REG)
#define PT_REGS_SP(x) (__PT_REGS_CAST(x)->__PT_SP_REG)
#define PT_REGS_IP(x) (__PT_REGS_CAST(x)->__PT_IP_REG)

#define PT_REAL_REGS(regs) ((struct pt_regs *)PT_REGS_PARM1(regs))

#endif

```

`kernel/feature.c`:

```c
#include "feature.h"
#include "klog.h" // IWYU pragma: keep

#include <linux/mutex.h>

static const struct ksu_feature_handler *feature_handlers[KSU_FEATURE_MAX];

static DEFINE_MUTEX(feature_mutex);

int ksu_register_feature_handler(const struct ksu_feature_handler *handler)
{
    if (!handler) {
        pr_err("feature: register handler is NULL\n");
        return -EINVAL;
    }

    if (handler->feature_id >= KSU_FEATURE_MAX) {
        pr_err("feature: invalid feature_id %u\n", handler->feature_id);
        return -EINVAL;
    }

    if (!handler->get_handler && !handler->set_handler) {
        pr_err("feature: no handler provided for feature %u\n",
               handler->feature_id);
        return -EINVAL;
    }

    mutex_lock(&feature_mutex);

    if (feature_handlers[handler->feature_id]) {
        pr_warn("feature: handler for %u already registered, overwriting\n",
                handler->feature_id);
    }

    feature_handlers[handler->feature_id] = handler;

    pr_info("feature: registered handler for %s (id=%u)\n",
            handler->name ? handler->name : "unknown", handler->feature_id);

    mutex_unlock(&feature_mutex);
    return 0;
}

int ksu_unregister_feature_handler(u32 feature_id)
{
    int ret = 0;

    if (feature_id >= KSU_FEATURE_MAX) {
        pr_err("feature: invalid feature_id %u\n", feature_id);
        return -EINVAL;
    }

    mutex_lock(&feature_mutex);

    if (!feature_handlers[feature_id]) {
        pr_warn("feature: no handler registered for %u\n", feature_id);
        ret = -ENOENT;
        goto out;
    }

    feature_handlers[feature_id] = NULL;

    pr_info("feature: unregistered handler for id=%u\n", feature_id);

out:
    mutex_unlock(&feature_mutex);
    return ret;
}

int ksu_get_feature(u32 feature_id, u64 *value, bool *supported)
{
    int ret = 0;
    const struct ksu_feature_handler *handler;

    if (feature_id >= KSU_FEATURE_MAX) {
        pr_err("feature: invalid feature_id %u\n", feature_id);
        return -EINVAL;
    }

    if (!value || !supported) {
        pr_err("feature: invalid parameters\n");
        return -EINVAL;
    }

    mutex_lock(&feature_mutex);

    handler = feature_handlers[feature_id];

    if (!handler) {
        *supported = false;
        *value = 0;
        pr_debug("feature: feature %u not supported\n", feature_id);
        goto out;
    }

    *supported = true;

    if (!handler->get_handler) {
        pr_warn("feature: no get_handler for feature %u\n", feature_id);
        ret = -EOPNOTSUPP;
        goto out;
    }

    ret = handler->get_handler(value);
    if (ret) {
        pr_err("feature: get_handler for %u failed: %d\n", feature_id, ret);
    }

out:
    mutex_unlock(&feature_mutex);
    return ret;
}

int ksu_set_feature(u32 feature_id, u64 value)
{
    int ret = 0;
    const struct ksu_feature_handler *handler;

    if (feature_id >= KSU_FEATURE_MAX) {
        pr_err("feature: invalid feature_id %u\n", feature_id);
        return -EINVAL;
    }

    mutex_lock(&feature_mutex);

    handler = feature_handlers[feature_id];

    if (!handler) {
        pr_err("feature: feature %u not registered\n", feature_id);
        ret = -EOPNOTSUPP;
        goto out;
    }

    if (!handler->set_handler) {
        pr_warn("feature: no set_handler for feature %u\n", feature_id);
        ret = -EOPNOTSUPP;
        goto out;
    }

    ret = handler->set_handler(value);
    if (ret) {
        pr_err("feature: set_handler for %u failed: %d\n", feature_id, ret);
    }

out:
    mutex_unlock(&feature_mutex);
    return ret;
}

void ksu_feature_init(void)
{
    int i;

    for (i = 0; i < KSU_FEATURE_MAX; i++) {
        feature_handlers[i] = NULL;
    }

    pr_info("feature: feature management initialized\n");
}

void ksu_feature_exit(void)
{
    int i;

    mutex_lock(&feature_mutex);

    for (i = 0; i < KSU_FEATURE_MAX; i++) {
        feature_handlers[i] = NULL;
    }

    mutex_unlock(&feature_mutex);

    pr_info("feature: feature management cleaned up\n");
}

```

`kernel/feature.h`:

```h
#ifndef __KSU_H_FEATURE
#define __KSU_H_FEATURE

#include <linux/types.h>

enum ksu_feature_id {
    KSU_FEATURE_SU_COMPAT = 0,
    KSU_FEATURE_KERNEL_UMOUNT = 1,

    KSU_FEATURE_MAX
};

typedef int (*ksu_feature_get_t)(u64 *value);
typedef int (*ksu_feature_set_t)(u64 value);

struct ksu_feature_handler {
    u32 feature_id;
    const char *name;
    ksu_feature_get_t get_handler;
    ksu_feature_set_t set_handler;
};

int ksu_register_feature_handler(const struct ksu_feature_handler *handler);

int ksu_unregister_feature_handler(u32 feature_id);

int ksu_get_feature(u32 feature_id, u64 *value, bool *supported);

int ksu_set_feature(u32 feature_id, u64 value);

void ksu_feature_init(void);

void ksu_feature_exit(void);

#endif // __KSU_H_FEATURE

```

`kernel/file_wrapper.c`:

```c
#include <linux/gfp.h>
#include <linux/fdtable.h>
#include <linux/export.h>
#include <linux/anon_inodes.h>
#include <linux/capability.h>
#include <linux/cred.h>
#include <linux/err.h>
#include <linux/file.h>
#include <linux/fs.h>
#include <linux/seq_file.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/mount.h>

#include "objsec.h"

#include "klog.h" // IWYU pragma: keep
#include "selinux/selinux.h"
#include "ksud.h"

#include "file_wrapper.h"

struct ksu_file_wrapper {
    struct file *orig;
    struct file_operations ops;
};

static struct ksu_file_wrapper *ksu_create_file_wrapper(struct file *fp);

static int ksu_wrapper_open(struct inode *ino, struct file *fp)
{
    struct path *orig_path = fp->f_path.dentry->d_fsdata;
    struct file *orig_file =
        dentry_open(orig_path, fp->f_flags, current_cred());
    if (IS_ERR(orig_file)) {
        return PTR_ERR(orig_file);
    }
    struct ksu_file_wrapper *wrapper = ksu_create_file_wrapper(orig_file);
    if (IS_ERR(wrapper)) {
        filp_close(orig_file, current->files);
        return PTR_ERR(wrapper);
    }
    fp->private_data = wrapper;
    const struct file_operations *new_fops = fops_get(&wrapper->ops);
    replace_fops(fp, new_fops);
    return 0;
}

static const struct file_operations ksu_file_wrapper_inode_fops = {
    .owner = THIS_MODULE,
    .open = ksu_wrapper_open
};

static loff_t ksu_wrapper_llseek(struct file *fp, loff_t off, int flags)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->llseek(data->orig, off, flags);
}

static ssize_t ksu_wrapper_read(struct file *fp, char __user *ptr, size_t sz,
                                loff_t *off)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->read(orig, ptr, sz, off);
}

static ssize_t ksu_wrapper_write(struct file *fp, const char __user *ptr,
                                 size_t sz, loff_t *off)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->write(orig, ptr, sz, off);
}

static ssize_t ksu_wrapper_read_iter(struct kiocb *iocb, struct iov_iter *iovi)
{
    struct ksu_file_wrapper *data = iocb->ki_filp->private_data;
    struct file *orig = data->orig;
    iocb->ki_filp = orig;
    return orig->f_op->read_iter(iocb, iovi);
}

static ssize_t ksu_wrapper_write_iter(struct kiocb *iocb, struct iov_iter *iovi)
{
    struct ksu_file_wrapper *data = iocb->ki_filp->private_data;
    struct file *orig = data->orig;
    iocb->ki_filp = orig;
    return orig->f_op->write_iter(iocb, iovi);
}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
static int ksu_wrapper_iopoll(struct kiocb *kiocb, struct io_comp_batch *icb,
                              unsigned int v)
{
    struct ksu_file_wrapper *data = kiocb->ki_filp->private_data;
    struct file *orig = data->orig;
    kiocb->ki_filp = orig;
    return orig->f_op->iopoll(kiocb, icb, v);
}
#else
static int ksu_wrapper_iopoll(struct kiocb *kiocb, bool spin)
{
    struct ksu_file_wrapper *data = kiocb->ki_filp->private_data;
    struct file *orig = data->orig;
    kiocb->ki_filp = orig;
    return orig->f_op->iopoll(kiocb, spin);
}
#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
static int ksu_wrapper_iterate(struct file *fp, struct dir_context *dc)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->iterate(orig, dc);
}
#endif

static int ksu_wrapper_iterate_shared(struct file *fp, struct dir_context *dc)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->iterate_shared(orig, dc);
}

static __poll_t ksu_wrapper_poll(struct file *fp, struct poll_table_struct *pts)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->poll(orig, pts);
}

static long ksu_wrapper_unlocked_ioctl(struct file *fp, unsigned int cmd,
                                       unsigned long arg)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->unlocked_ioctl(orig, cmd, arg);
}

static long ksu_wrapper_compat_ioctl(struct file *fp, unsigned int cmd,
                                     unsigned long arg)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->compat_ioctl(orig, cmd, arg);
}

static int ksu_wrapper_mmap(struct file *fp, struct vm_area_struct *vma)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->mmap(orig, vma);
}

static int ksu_wrapper_flush(struct file *fp, fl_owner_t id)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->flush(orig, id);
}

static int ksu_wrapper_fsync(struct file *fp, loff_t off1, loff_t off2,
                             int datasync)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->fsync(orig, off1, off2, datasync);
}

static int ksu_wrapper_fasync(int arg, struct file *fp, int arg2)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->fasync(arg, orig, arg2);
}

static int ksu_wrapper_lock(struct file *fp, int arg1, struct file_lock *fl)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    return orig->f_op->lock(orig, arg1, fl);
}

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
static ssize_t ksu_wrapper_sendpage(struct file *fp, struct page *pg, int arg1,
                                    size_t sz, loff_t *off, int arg2)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->sendpage) {
        return orig->f_op->sendpage(orig, pg, arg1, sz, off, arg2);
    }
    return -EINVAL;
}
#endif

static unsigned long ksu_wrapper_get_unmapped_area(struct file *fp,
                                                   unsigned long arg1,
                                                   unsigned long arg2,
                                                   unsigned long arg3,
                                                   unsigned long arg4)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->get_unmapped_area) {
        return orig->f_op->get_unmapped_area(orig, arg1, arg2, arg3, arg4);
    }
    return -EINVAL;
}

// static int ksu_wrapper_check_flags(int arg) {}

static int ksu_wrapper_flock(struct file *fp, int arg1, struct file_lock *fl)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->flock) {
        return orig->f_op->flock(orig, arg1, fl);
    }
    return -EINVAL;
}

static ssize_t ksu_wrapper_splice_write(struct pipe_inode_info *pii,
                                        struct file *fp, loff_t *off, size_t sz,
                                        unsigned int arg1)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->splice_write) {
        return orig->f_op->splice_write(pii, orig, off, sz, arg1);
    }
    return -EINVAL;
}

static ssize_t ksu_wrapper_splice_read(struct file *fp, loff_t *off,
                                       struct pipe_inode_info *pii, size_t sz,
                                       unsigned int arg1)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->splice_read) {
        return orig->f_op->splice_read(orig, off, pii, sz, arg1);
    }
    return -EINVAL;
}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
void ksu_wrapper_splice_eof(struct file *fp)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->splice_eof) {
        return orig->f_op->splice_eof(orig);
    }
}
#endif

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
static int ksu_wrapper_setlease(struct file *fp, int arg1,
                                struct file_lease **fl, void **p)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->setlease) {
        return orig->f_op->setlease(orig, arg1, fl, p);
    }
    return -EINVAL;
}
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
static int ksu_wrapper_setlease(struct file *fp, int arg1,
                                struct file_lock **fl, void **p)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->setlease) {
        return orig->f_op->setlease(orig, arg1, fl, p);
    }
    return -EINVAL;
}
#else
static int ksu_wrapper_setlease(struct file *fp, long arg1,
                                struct file_lock **fl, void **p)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->setlease) {
        return orig->f_op->setlease(orig, arg1, fl, p);
    }
    return -EINVAL;
}
#endif

static long ksu_wrapper_fallocate(struct file *fp, int mode, loff_t offset,
                                  loff_t len)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->fallocate) {
        return orig->f_op->fallocate(orig, mode, offset, len);
    }
    return -EINVAL;
}

static void ksu_wrapper_show_fdinfo(struct seq_file *m, struct file *f)
{
    struct ksu_file_wrapper *data = f->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->show_fdinfo) {
        orig->f_op->show_fdinfo(m, orig);
    }
}

// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/read_write.c;l=1593-1606;drc=398da7defe218d3e51b0f3bdff75147e28125b60
static ssize_t ksu_wrapper_copy_file_range(struct file *file_in, loff_t pos_in,
                                           struct file *file_out,
                                           loff_t pos_out, size_t len,
                                           unsigned int flags)
{
    struct ksu_file_wrapper *data = file_out->private_data;
    struct file *orig = data->orig;
    return orig->f_op->copy_file_range(file_in, pos_in, orig, pos_out, len,
                                       flags);
}

// no REMAP_FILE_DEDUP: use file_in
// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/read_write.c;l=1598-1599;drc=398da7defe218d3e51b0f3bdff75147e28125b60
// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/remap_range.c;l=403-404;drc=398da7defe218d3e51b0f3bdff75147e28125b60
// REMAP_FILE_DEDUP: use file_out
// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/remap_range.c;l=483-484;drc=398da7defe218d3e51b0f3bdff75147e28125b60
static loff_t ksu_wrapper_remap_file_range(struct file *file_in, loff_t pos_in,
                                           struct file *file_out,
                                           loff_t pos_out, loff_t len,
                                           unsigned int remap_flags)
{
    if (remap_flags & REMAP_FILE_DEDUP) {
        struct ksu_file_wrapper *data = file_out->private_data;
        struct file *orig = data->orig;
        return orig->f_op->remap_file_range(file_in, pos_in, orig, pos_out, len,
                                            remap_flags);
    } else {
        struct ksu_file_wrapper *data = file_in->private_data;
        struct file *orig = data->orig;
        return orig->f_op->remap_file_range(orig, pos_in, file_out, pos_out,
                                            len, remap_flags);
    }
}

static int ksu_wrapper_fadvise(struct file *fp, loff_t off1, loff_t off2,
                               int flags)
{
    struct ksu_file_wrapper *data = fp->private_data;
    struct file *orig = data->orig;
    if (orig->f_op->fadvise) {
        return orig->f_op->fadvise(orig, off1, off2, flags);
    }
    return -EINVAL;
}

static void ksu_release_file_wrapper(struct ksu_file_wrapper *data);

static int ksu_wrapper_release(struct inode *inode, struct file *filp)
{
    // https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/fs/file_table.c;l=467-473;drc=3be0b283b562eabbc2b1f3bb534dc8903079bbaa
    // f_op->release is called before fops_put(f_op), so we put it manually.
    fops_put(filp->f_op);
    // prevent it from being put again
    filp->f_op = NULL;
    ksu_release_file_wrapper(filp->private_data);
    return 0;
}

static struct ksu_file_wrapper *ksu_create_file_wrapper(struct file *fp)
{
    struct ksu_file_wrapper *p =
        kcalloc(1, sizeof(struct ksu_file_wrapper), GFP_KERNEL);
    if (!p) {
        return ERR_PTR(-ENOMEM);
    }

    get_file(fp);

    p->orig = fp;
    p->ops.owner = THIS_MODULE;
    p->ops.llseek = fp->f_op->llseek ? ksu_wrapper_llseek : NULL;
    p->ops.read = fp->f_op->read ? ksu_wrapper_read : NULL;
    p->ops.write = fp->f_op->write ? ksu_wrapper_write : NULL;
    p->ops.read_iter = fp->f_op->read_iter ? ksu_wrapper_read_iter : NULL;
    p->ops.write_iter = fp->f_op->write_iter ? ksu_wrapper_write_iter : NULL;
    p->ops.iopoll = fp->f_op->iopoll ? ksu_wrapper_iopoll : NULL;
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
    p->ops.iterate = fp->f_op->iterate ? ksu_wrapper_iterate : NULL;
#endif
    p->ops.iterate_shared =
        fp->f_op->iterate_shared ? ksu_wrapper_iterate_shared : NULL;
    p->ops.poll = fp->f_op->poll ? ksu_wrapper_poll : NULL;
    p->ops.unlocked_ioctl =
        fp->f_op->unlocked_ioctl ? ksu_wrapper_unlocked_ioctl : NULL;
    p->ops.compat_ioctl =
        fp->f_op->compat_ioctl ? ksu_wrapper_compat_ioctl : NULL;
    p->ops.mmap = fp->f_op->mmap ? ksu_wrapper_mmap : NULL;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
    p->ops.fop_flags = fp->f_op->fop_flags;
#else
    p->ops.mmap_supported_flags = fp->f_op->mmap_supported_flags;
#endif
    p->ops.flush = fp->f_op->flush ? ksu_wrapper_flush : NULL;
    p->ops.release = ksu_wrapper_release;
    p->ops.fsync = fp->f_op->fsync ? ksu_wrapper_fsync : NULL;
    p->ops.fasync = fp->f_op->fasync ? ksu_wrapper_fasync : NULL;
    p->ops.lock = fp->f_op->lock ? ksu_wrapper_lock : NULL;
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 6, 0)
    p->ops.sendpage = fp->f_op->sendpage ? ksu_wrapper_sendpage : NULL;
#endif
    p->ops.get_unmapped_area =
        fp->f_op->get_unmapped_area ? ksu_wrapper_get_unmapped_area : NULL;
    p->ops.check_flags = fp->f_op->check_flags;
    p->ops.flock = fp->f_op->flock ? ksu_wrapper_flock : NULL;
    p->ops.splice_write =
        fp->f_op->splice_write ? ksu_wrapper_splice_write : NULL;
    p->ops.splice_read = fp->f_op->splice_read ? ksu_wrapper_splice_read : NULL;
    p->ops.setlease = fp->f_op->setlease ? ksu_wrapper_setlease : NULL;
    p->ops.fallocate = fp->f_op->fallocate ? ksu_wrapper_fallocate : NULL;
    p->ops.show_fdinfo = fp->f_op->show_fdinfo ? ksu_wrapper_show_fdinfo : NULL;
    p->ops.copy_file_range =
        fp->f_op->copy_file_range ? ksu_wrapper_copy_file_range : NULL;
    p->ops.remap_file_range =
        fp->f_op->remap_file_range ? ksu_wrapper_remap_file_range : NULL;
    p->ops.fadvise = fp->f_op->fadvise ? ksu_wrapper_fadvise : NULL;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
    p->ops.splice_eof = fp->f_op->splice_eof ? ksu_wrapper_splice_eof : NULL;
#endif

    return p;
}

static void ksu_release_file_wrapper(struct ksu_file_wrapper *data)
{
    fput((struct file *)data->orig);
    kfree(data);
}

static char *ksu_wrapper_d_dname(struct dentry *dentry, char *buffer,
                                 int buflen)
{
    struct path *orig_path = dentry->d_fsdata;
    return d_path(orig_path, buffer, buflen);
}

static void ksu_wrapper_d_release(struct dentry *dentry)
{
    struct path *orig_path = dentry->d_fsdata;
    path_put(orig_path);
    kfree(orig_path);
}

static const struct dentry_operations ksu_file_wrapper_d_ops = {
    .d_dname = ksu_wrapper_d_dname,
    .d_release = ksu_wrapper_d_release
};

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 8, 0)
#define ksu_anon_inode_create_getfile_compat anon_inode_create_getfile
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
#define ksu_anon_inode_create_getfile_compat anon_inode_getfile_secure
#else
// There is no anon_inode_create_getfile before 5.16, but it's not difficult to implement it.
// https://cs.android.com/android/kernel/superproject/+/common-android12-5.10:common/fs/anon_inodes.c;l=58-125;drc=0d34ce8aa78e38affbb501690bcabec4df88620e

// Borrow kernel's anon_inode_mnt, so that we don't need to mount one by ourselves.
static struct vfsmount *anon_inode_mnt __read_mostly;

static struct inode *
ksu_anon_inode_make_secure_inode(const char *name,
                                 const struct inode *context_inode)
{
    struct inode *inode;
    const struct qstr qname = QSTR_INIT(name, strlen(name));
    int error;

    if (unlikely(!anon_inode_mnt)) {
        return ERR_PTR(-ENODEV);
    }

    inode = alloc_anon_inode(anon_inode_mnt->mnt_sb);
    if (IS_ERR(inode))
        return inode;
    inode->i_flags &= ~S_PRIVATE;
    error = security_inode_init_security_anon(inode, &qname, context_inode);
    if (error) {
        iput(inode);
        return ERR_PTR(error);
    }
    return inode;
}

static struct file *ksu_anon_inode_create_getfile_compat(
    const char *name, const struct file_operations *fops, void *priv, int flags,
    const struct inode *context_inode)
{
    struct inode *inode;
    struct file *file;

    if (fops->owner && !try_module_get(fops->owner))
        return ERR_PTR(-ENOENT);

    inode = ksu_anon_inode_make_secure_inode(name, context_inode);
    if (IS_ERR(inode)) {
        file = ERR_CAST(inode);
        goto err;
    }

    file = alloc_file_pseudo(inode, anon_inode_mnt, name,
                             flags & (O_ACCMODE | O_NONBLOCK), fops);
    if (IS_ERR(file))
        goto err_iput;

    file->f_mapping = inode->i_mapping;

    file->private_data = priv;

    return file;

err_iput:
    iput(inode);
err:
    module_put(fops->owner);
    return file;
}
#endif

int ksu_install_file_wrapper(int fd)
{
    int out_fd, ret;
    struct file *orig_file = fget(fd);
    if (!orig_file) {
        return -EBADF;
    }

    out_fd = get_unused_fd_flags(O_CLOEXEC);
    if (out_fd < 0) {
        ret = out_fd;
        goto done;
    }

    struct ksu_file_wrapper *file_wrapper_data =
        ksu_create_file_wrapper(orig_file);
    if (IS_ERR(file_wrapper_data)) {
        ret = PTR_ERR(file_wrapper_data);
        goto out_put_fd;
    }

    struct file *wrapper_file = ksu_anon_inode_create_getfile_compat(
        "[ksu_fdwrapper]", &file_wrapper_data->ops, file_wrapper_data,
        orig_file->f_flags, NULL);
    if (IS_ERR(wrapper_file)) {
        pr_err("ksu_fdwrapper: getfile failed: %ld\n", PTR_ERR(wrapper_file));
        ret = PTR_ERR(wrapper_file);
        goto out_release_wrapper;
    }

    // Now do magic on inode and dentry.
    // It should be safe to modify them since the file hasn't been published.

    struct inode *wrapper_inode = file_inode(wrapper_file);
    // libc's stdio relies on the fstat() result of the fd to determine its buffer type.
    wrapper_inode->i_mode = file_inode(orig_file)->i_mode;
    struct inode_security_struct *wrapper_sec = selinux_inode(wrapper_inode);
    // Use ksu_file_sid to bypass SELinux check.
    // When we call `su` from terminal app, this is useful.
    if (wrapper_sec) {
        wrapper_sec->sid = ksu_file_sid;
    }
    // Install open file operation for inode.
    wrapper_inode->i_fop = &ksu_file_wrapper_inode_fops;

    struct path *orig_path = kmalloc(sizeof(struct path), GFP_KERNEL);
    if (!orig_path) {
        ret = -ENOMEM;
        goto out_put_wrapper_file;
    }
    *orig_path = orig_file->f_path;
    path_get(orig_path);
    // Some applications (such as screen) won't work if the tty's path is weird,
    // Therefore, we use d_dname to spoof it to return the path to the original file.
    wrapper_file->f_path.dentry->d_fsdata = orig_path;
    wrapper_file->f_path.dentry->d_op = &ksu_file_wrapper_d_ops;

    fd_install(out_fd, wrapper_file);
    ret = out_fd;
    goto done;

out_put_wrapper_file:
    fput(wrapper_file);
    // file_wrapper will be released by fput
    goto out_put_fd;
out_release_wrapper:
    ksu_release_file_wrapper(file_wrapper_data);
out_put_fd:
    put_unused_fd(out_fd);
done:
    fput(orig_file);

    return ret;
}

void ksu_file_wrapper_init(void)
{
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0)
    static const struct file_operations tmp = { .owner = THIS_MODULE };
    struct file *dummy = anon_inode_getfile("dummy", &tmp, NULL, 0);
    if (IS_ERR(dummy)) {
        pr_err(
            "file_wrapper: initialize anon_inode_mnt failed, can't get file: %ld\n",
            PTR_ERR(dummy));
        return;
    }
    anon_inode_mnt = dummy->f_path.mnt;
    if (unlikely(!anon_inode_mnt)) {
        pr_err("file_wrapper: initialize anon_inode_mnt failed, got NULL\n");
    }
    fput(dummy);
#endif
}

```

`kernel/file_wrapper.h`:

```h
#ifndef KSU_FILE_WRAPPER_H
#define KSU_FILE_WRAPPER_H

#include <linux/file.h>
#include <linux/fs.h>

int ksu_install_file_wrapper(int fd);
void ksu_file_wrapper_init(void);

#endif // KSU_FILE_WRAPPER_H

```

`kernel/kernel_umount.c`:

```c
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/task_work.h>
#include <linux/cred.h>
#include <linux/fs.h>
#include <linux/mount.h>
#include <linux/namei.h>
#include <linux/nsproxy.h>
#include <linux/path.h>
#include <linux/printk.h>
#include <linux/types.h>

#include "kernel_umount.h"
#include "klog.h" // IWYU pragma: keep
#include "allowlist.h"
#include "selinux/selinux.h"
#include "feature.h"
#include "ksud.h"
#include "ksu.h"

static bool ksu_kernel_umount_enabled = true;

static int kernel_umount_feature_get(u64 *value)
{
    *value = ksu_kernel_umount_enabled ? 1 : 0;
    return 0;
}

static int kernel_umount_feature_set(u64 value)
{
    bool enable = value != 0;
    ksu_kernel_umount_enabled = enable;
    pr_info("kernel_umount: set to %d\n", enable);
    return 0;
}

static const struct ksu_feature_handler kernel_umount_handler = {
    .feature_id = KSU_FEATURE_KERNEL_UMOUNT,
    .name = "kernel_umount",
    .get_handler = kernel_umount_feature_get,
    .set_handler = kernel_umount_feature_set,
};

extern int path_umount(struct path *path, int flags);

static void ksu_umount_mnt(struct path *path, int flags)
{
    int err = path_umount(path, flags);
    if (err) {
        pr_info("umount %s failed: %d\n", path->dentry->d_iname, err);
    }
}

static void try_umount(const char *mnt, int flags)
{
    struct path path;
    int err = kern_path(mnt, 0, &path);
    if (err) {
        return;
    }

    if (path.dentry != path.mnt->mnt_root) {
        // it is not root mountpoint, maybe umounted by others already.
        path_put(&path);
        return;
    }

    ksu_umount_mnt(&path, flags);
}

struct umount_tw {
    struct callback_head cb;
};

static void umount_tw_func(struct callback_head *cb)
{
    struct umount_tw *tw = container_of(cb, struct umount_tw, cb);
    const struct cred *saved = override_creds(ksu_cred);

    struct mount_entry *entry;
    down_read(&mount_list_lock);
    list_for_each_entry (entry, &mount_list, list) {
        pr_info("%s: unmounting: %s flags 0x%x\n", __func__, entry->umountable,
                entry->flags);
        try_umount(entry->umountable, entry->flags);
    }
    up_read(&mount_list_lock);

    revert_creds(saved);

    kfree(tw);
}

int ksu_handle_umount(uid_t old_uid, uid_t new_uid)
{
    struct umount_tw *tw;

    // if there isn't any module mounted, just ignore it!
    if (!ksu_module_mounted) {
        return 0;
    }

    if (!ksu_kernel_umount_enabled) {
        return 0;
    }

    if (!ksu_cred) {
        return 0;
    }

    // There are 5 scenarios:
    // 1. Normal app: zygote -> appuid
    // 2. Isolated process forked from zygote: zygote -> isolated_process
    // 3. App zygote forked from zygote: zygote -> appuid
    // 4. Isolated process froked from app zygote: appuid -> isolated_process (already handled by 3)
    // 5. Isolated process froked from webview zygote (no need to handle, app cannot run custom code)
    if (!is_appuid(new_uid) && !is_isolated_process(new_uid)) {
        return 0;
    }

    if (!ksu_uid_should_umount(new_uid) && !is_isolated_process(new_uid)) {
        return 0;
    }

    // check old process's selinux context, if it is not zygote, ignore it!
    // because some su apps may setuid to untrusted_app but they are in global mount namespace
    // when we umount for such process, that is a disaster!
    // also handle case 4 and 5
    bool is_zygote_child = is_zygote(get_current_cred());
    if (!is_zygote_child) {
        pr_info("handle umount ignore non zygote child: %d\n", current->pid);
        return 0;
    }
    // umount the target mnt
    pr_info("handle umount for uid: %d, pid: %d\n", new_uid, current->pid);

    tw = kzalloc(sizeof(*tw), GFP_ATOMIC);
    if (!tw)
        return 0;

    tw->cb.func = umount_tw_func;

    int err = task_work_add(current, &tw->cb, TWA_RESUME);
    if (err) {
        kfree(tw);
        pr_warn("unmount add task_work failed\n");
    }

    return 0;
}

void ksu_kernel_umount_init(void)
{
    if (ksu_register_feature_handler(&kernel_umount_handler)) {
        pr_err("Failed to register kernel_umount feature handler\n");
    }
}

void ksu_kernel_umount_exit(void)
{
    ksu_unregister_feature_handler(KSU_FEATURE_KERNEL_UMOUNT);
}

```

`kernel/kernel_umount.h`:

```h
#ifndef __KSU_H_KERNEL_UMOUNT
#define __KSU_H_KERNEL_UMOUNT

#include <linux/types.h>
#include <linux/list.h>
#include <linux/rwsem.h>

void ksu_kernel_umount_init(void);
void ksu_kernel_umount_exit(void);

// Handler function to be called from setresuid hook
int ksu_handle_umount(uid_t old_uid, uid_t new_uid);

// for the umount list
struct mount_entry {
    char *umountable;
    unsigned int flags;
    struct list_head list;
};
extern struct list_head mount_list;
extern struct rw_semaphore mount_list_lock;

#endif

```

`kernel/klog.h`:

```h
#ifndef __KSU_H_KLOG
#define __KSU_H_KLOG

#include <linux/printk.h>

#ifdef pr_fmt
#undef pr_fmt
#define pr_fmt(fmt) "KernelSU: " fmt
#endif

#endif

```

`kernel/ksu.c`:

```c
#include <linux/export.h>
#include <linux/fs.h>
#include <linux/kobject.h>
#include <linux/module.h>
#include <linux/workqueue.h>

#include "allowlist.h"
#include "feature.h"
#include "klog.h" // IWYU pragma: keep
#include "throne_tracker.h"
#include "syscall_hook_manager.h"
#include "ksud.h"
#include "supercalls.h"
#include "ksu.h"
#include "file_wrapper.h"

struct cred *ksu_cred;

int __init kernelsu_init(void)
{
#ifdef CONFIG_KSU_DEBUG
    pr_alert("*************************************************************");
    pr_alert("**     NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE    **");
    pr_alert("**                                                         **");
    pr_alert("**         You are running KernelSU in DEBUG mode          **");
    pr_alert("**                                                         **");
    pr_alert("**     NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE    **");
    pr_alert("*************************************************************");
#endif

    ksu_cred = prepare_creds();
    if (!ksu_cred) {
        pr_err("prepare cred failed!\n");
    }

    ksu_feature_init();

    ksu_supercalls_init();

    ksu_syscall_hook_manager_init();

    ksu_allowlist_init();

    ksu_throne_tracker_init();

    ksu_ksud_init();

    ksu_file_wrapper_init();

#ifdef MODULE
#ifndef CONFIG_KSU_DEBUG
    kobject_del(&THIS_MODULE->mkobj.kobj);
#endif
#endif
    return 0;
}

extern void ksu_observer_exit(void);
void kernelsu_exit(void)
{
    ksu_allowlist_exit();

    ksu_throne_tracker_exit();

    ksu_observer_exit();

    ksu_ksud_exit();

    ksu_syscall_hook_manager_exit();

    ksu_supercalls_exit();

    ksu_feature_exit();

    if (ksu_cred) {
        put_cred(ksu_cred);
    }
}

module_init(kernelsu_init);
module_exit(kernelsu_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("weishu");
MODULE_DESCRIPTION("Android KernelSU");
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 13, 0)
MODULE_IMPORT_NS("VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver");
#else
MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
#endif

```

`kernel/ksu.h`:

```h
#ifndef __KSU_H_KSU
#define __KSU_H_KSU

#include <linux/types.h>
#include <linux/workqueue.h>
#include <linux/cred.h>

#define KERNEL_SU_VERSION KSU_VERSION

#define EVENT_POST_FS_DATA 1
#define EVENT_BOOT_COMPLETED 2
#define EVENT_MODULE_MOUNTED 3

static inline int startswith(char *s, char *prefix)
{
    return strncmp(s, prefix, strlen(prefix));
}

static inline int endswith(const char *s, const char *t)
{
    size_t slen = strlen(s);
    size_t tlen = strlen(t);
    if (tlen > slen)
        return 1;
    return strcmp(s + slen - tlen, t);
}

extern struct cred *ksu_cred;

#endif

```

`kernel/ksud.c`:

```c
#include <linux/rcupdate.h>
#include <linux/slab.h>
#include <linux/task_work.h>
#include <asm/current.h>
#include <linux/compat.h>
#include <linux/cred.h>
#include <linux/dcache.h>
#include <linux/err.h>
#include <linux/file.h>
#include <linux/fs.h>
#include <linux/version.h>
#include <linux/input-event-codes.h>
#include <linux/kprobes.h>
#include <linux/printk.h>
#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/namei.h>
#include <linux/workqueue.h>
#include <linux/uio.h>

#include "manager.h"
#include "allowlist.h"
#include "arch.h"
#include "klog.h" // IWYU pragma: keep
#include "ksud.h"
#include "util.h"
#include "selinux/selinux.h"
#include "throne_tracker.h"

bool ksu_module_mounted __read_mostly = false;
bool ksu_boot_completed __read_mostly = false;

static const char KERNEL_SU_RC[] =
    "\n"

    "on post-fs-data\n"
    "    start logd\n"
    // We should wait for the post-fs-data finish
    "    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH " post-fs-data\n"
    "\n"

    "on nonencrypted\n"
    "    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH " services\n"
    "\n"

    "on property:vold.decrypt=trigger_restart_framework\n"
    "    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH " services\n"
    "\n"

    "on property:sys.boot_completed=1\n"
    "    exec u:r:" KERNEL_SU_DOMAIN ":s0 root -- " KSUD_PATH
    " boot-completed\n"
    "\n"

    "\n";

static void stop_init_rc_hook();
static void stop_execve_hook();
static void stop_input_hook();

static struct work_struct stop_init_rc_hook_work;
static struct work_struct stop_execve_hook_work;
static struct work_struct stop_input_hook_work;

void on_post_fs_data(void)
{
    static bool done = false;
    if (done) {
        pr_info("on_post_fs_data already done\n");
        return;
    }
    done = true;
    pr_info("on_post_fs_data!\n");

    ksu_load_allow_list();
    ksu_observer_init();
    // sanity check, this may influence the performance
    stop_input_hook();
}

extern void ext4_unregister_sysfs(struct super_block *sb);
int nuke_ext4_sysfs(const char *mnt)
{
    struct path path;
    int err = kern_path(mnt, 0, &path);
    if (err) {
        pr_err("nuke path err: %d\n", err);
        return err;
    }

    struct super_block *sb = path.dentry->d_inode->i_sb;
    const char *name = sb->s_type->name;
    if (strcmp(name, "ext4") != 0) {
        pr_info("nuke but module aren't mounted\n");
        path_put(&path);
        return -EINVAL;
    }

    ext4_unregister_sysfs(sb);
    path_put(&path);
    return 0;
}

void on_module_mounted(void)
{
    pr_info("on_module_mounted!\n");
    ksu_module_mounted = true;
}

void on_boot_completed(void)
{
    ksu_boot_completed = true;
    pr_info("on_boot_completed!\n");
    track_throne(true);
}

#define MAX_ARG_STRINGS 0x7FFFFFFF
struct user_arg_ptr {
#ifdef CONFIG_COMPAT
    bool is_compat;
#endif
    union {
        const char __user *const __user *native;
#ifdef CONFIG_COMPAT
        const compat_uptr_t __user *compat;
#endif
    } ptr;
};

static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)
{
    const char __user *native;

#ifdef CONFIG_COMPAT
    if (unlikely(argv.is_compat)) {
        compat_uptr_t compat;

        if (get_user(compat, argv.ptr.compat + nr))
            return ERR_PTR(-EFAULT);

        return compat_ptr(compat);
    }
#endif

    if (get_user(native, argv.ptr.native + nr))
        return ERR_PTR(-EFAULT);

    return native;
}

/*
 * count() counts the number of strings in array ARGV.
 */

/*
 * Make sure old GCC compiler can use __maybe_unused,
 * Test passed in 4.4.x ~ 4.9.x when use GCC.
 */

static int __maybe_unused count(struct user_arg_ptr argv, int max)
{
    int i = 0;

    if (argv.ptr.native != NULL) {
        for (;;) {
            const char __user *p = get_user_arg_ptr(argv, i);

            if (!p)
                break;

            if (IS_ERR(p))
                return -EFAULT;

            if (i >= max)
                return -E2BIG;
            ++i;

            if (fatal_signal_pending(current))
                return -ERESTARTNOHAND;
        }
    }
    return i;
}

static void on_post_fs_data_cbfun(struct callback_head *cb)
{
    on_post_fs_data();
}

static struct callback_head on_post_fs_data_cb = { .func =
                                                       on_post_fs_data_cbfun };

static bool check_argv(struct user_arg_ptr argv, int index,
                       const char *expected, char *buf, size_t buf_len)
{
    const char __user *p;
    int argc;

    argc = count(argv, MAX_ARG_STRINGS);
    if (argc <= index)
        return false;

    p = get_user_arg_ptr(argv, index);
    if (!p || IS_ERR(p))
        goto fail;

    if (strncpy_from_user_nofault(buf, p, buf_len) <= 0)
        goto fail;

    buf[buf_len - 1] = '\0';
    return !strcmp(buf, expected);

fail:
    pr_err("check_argv failed\n");
    return false;
}

// IMPORTANT NOTE: the call from execve_handler_pre WON'T provided correct value for envp and flags in GKI version
int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
                             struct user_arg_ptr *argv,
                             struct user_arg_ptr *envp, int *flags)
{
    struct filename *filename;

    static const char app_process[] = "/system/bin/app_process";
    static bool first_zygote = true;

    /* This applies to versions Android 10+ */
    static const char system_bin_init[] = "/system/bin/init";
    static bool init_second_stage_executed = false;

    if (!filename_ptr)
        return 0;

    filename = *filename_ptr;
    if (IS_ERR(filename)) {
        return 0;
    }

    // https://cs.android.com/android/platform/superproject/+/android-16.0.0_r2:system/core/init/main.cpp;l=77
    if (unlikely(!memcmp(filename->name, system_bin_init,
                         sizeof(system_bin_init) - 1) &&
                 argv)) {
        char buf[16];
        if (!init_second_stage_executed &&
            check_argv(*argv, 1, "second_stage", buf, sizeof(buf))) {
            pr_info("/system/bin/init second_stage executed\n");
            apply_kernelsu_rules();
            cache_sid();
            setup_ksu_cred();
            init_second_stage_executed = true;
        }
    }

    if (unlikely(
            first_zygote &&
            !memcmp(filename->name, app_process, sizeof(app_process) - 1) &&
            argv)) {
        char buf[16];
        if (check_argv(*argv, 1, "-Xzygote", buf, sizeof(buf))) {
            pr_info("exec zygote, /data prepared, second_stage: %d\n",
                    init_second_stage_executed);
            rcu_read_lock();
            struct task_struct *init_task =
                rcu_dereference(current->real_parent);
            if (init_task)
                task_work_add(init_task, &on_post_fs_data_cb, TWA_RESUME);
            rcu_read_unlock();
            first_zygote = false;
            stop_execve_hook();
        }
    }

    return 0;
}

static ssize_t (*orig_read)(struct file *, char __user *, size_t, loff_t *);
static ssize_t (*orig_read_iter)(struct kiocb *, struct iov_iter *);
static struct file_operations fops_proxy;
static ssize_t ksu_rc_pos = 0;
const size_t ksu_rc_len = sizeof(KERNEL_SU_RC) - 1;

// https://cs.android.com/android/platform/superproject/main/+/main:system/core/init/parser.cpp;l=144;drc=61197364367c9e404c7da6900658f1b16c42d0da
// https://cs.android.com/android/platform/superproject/main/+/main:system/libbase/file.cpp;l=241-243;drc=61197364367c9e404c7da6900658f1b16c42d0da
// The system will read init.rc file until EOF, whenever read() returns 0,
// so we begin append ksu rc when we meet EOF.

static ssize_t read_proxy(struct file *file, char __user *buf, size_t count,
                          loff_t *pos)
{
    ssize_t ret = 0;
    size_t append_count;
    if (ksu_rc_pos && ksu_rc_pos < ksu_rc_len)
        goto append_ksu_rc;

    ret = orig_read(file, buf, count, pos);
    if (ret != 0 || ksu_rc_pos >= ksu_rc_len) {
        return ret;
    } else {
        pr_info("read_proxy: orig read finished, start append rc\n");
    }
append_ksu_rc:
    append_count = ksu_rc_len - ksu_rc_pos;
    if (append_count > count - ret)
        append_count = count - ret;
    // copy_to_user returns the number of not copied
    if (copy_to_user(buf + ret, KERNEL_SU_RC + ksu_rc_pos, append_count)) {
        pr_info("read_proxy: append error, totally appended %ld\n", ksu_rc_pos);
    } else {
        pr_info("read_proxy: append %ld\n", append_count);

        ksu_rc_pos += append_count;
        if (ksu_rc_pos == ksu_rc_len) {
            pr_info("read_proxy: append done\n");
        }
        ret += append_count;
    }

    return ret;
}

static ssize_t read_iter_proxy(struct kiocb *iocb, struct iov_iter *to)
{
    ssize_t ret = 0;
    size_t append_count;
    if (ksu_rc_pos && ksu_rc_pos < ksu_rc_len)
        goto append_ksu_rc;

    ret = orig_read_iter(iocb, to);
    if (ret != 0 || ksu_rc_pos >= ksu_rc_len) {
        return ret;
    } else {
        pr_info("read_iter_proxy: orig read finished, start append rc\n");
    }
append_ksu_rc:
    // copy_to_iter returns the number of copied bytes
    append_count =
        copy_to_iter(KERNEL_SU_RC + ksu_rc_pos, ksu_rc_len - ksu_rc_pos, to);
    if (!append_count) {
        pr_info("read_iter_proxy: append error, totally appended %ld\n",
                ksu_rc_pos);
    } else {
        pr_info("read_iter_proxy: append %ld\n", append_count);

        ksu_rc_pos += append_count;
        if (ksu_rc_pos == ksu_rc_len) {
            pr_info("read_iter_proxy: append done\n");
        }
        ret += append_count;
    }
    return ret;
}

static bool is_init_rc(struct file *fp)
{
    if (strcmp(current->comm, "init")) {
        // we are only interest in `init` process
        return false;
    }

    if (!d_is_reg(fp->f_path.dentry)) {
        return false;
    }

    const char *short_name = fp->f_path.dentry->d_name.name;
    if (strcmp(short_name, "init.rc")) {
        // we are only interest `init.rc` file name file
        return false;
    }
    char path[256];
    char *dpath = d_path(&fp->f_path, path, sizeof(path));

    if (IS_ERR(dpath)) {
        return false;
    }

    if (strcmp(dpath, "/system/etc/init/hw/init.rc")) {
        return false;
    }

    return true;
}

static void ksu_handle_sys_read(unsigned int fd)
{
    struct file *file = fget(fd);
    if (!file) {
        return;
    }

    if (!is_init_rc(file)) {
        goto skip;
    }

    // we only process the first read
    static bool rc_hooked = false;
    if (rc_hooked) {
        // we don't need these kprobe, unregister it!
        stop_init_rc_hook();
        goto skip;
    }
    rc_hooked = true;

    // now we can sure that the init process is reading
    // `/system/etc/init/init.rc`

    pr_info("read init.rc, comm: %s, rc_count: %zu\n", current->comm,
            ksu_rc_len);

    // Now we need to proxy the read and modify the result!
    // But, we can not modify the file_operations directly, because it's in read-only memory.
    // We just replace the whole file_operations with a proxy one.
    memcpy(&fops_proxy, file->f_op, sizeof(struct file_operations));
    orig_read = file->f_op->read;
    if (orig_read) {
        fops_proxy.read = read_proxy;
    }
    orig_read_iter = file->f_op->read_iter;
    if (orig_read_iter) {
        fops_proxy.read_iter = read_iter_proxy;
    }
    // replace the file_operations
    file->f_op = &fops_proxy;

skip:
    fput(file);
}

static unsigned int volumedown_pressed_count = 0;

static bool is_volumedown_enough(unsigned int count)
{
    return count >= 3;
}

int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code,
                                  int *value)
{
    if (*type == EV_KEY && *code == KEY_VOLUMEDOWN) {
        int val = *value;
        pr_info("KEY_VOLUMEDOWN val: %d\n", val);
        if (val) {
            // key pressed, count it
            volumedown_pressed_count += 1;
            if (is_volumedown_enough(volumedown_pressed_count)) {
                stop_input_hook();
            }
        }
    }

    return 0;
}

bool ksu_is_safe_mode()
{
    static bool safe_mode = false;
    if (safe_mode) {
        // don't need to check again, userspace may call multiple times
        return true;
    }

    // stop hook first!
    stop_input_hook();

    pr_info("volumedown_pressed_count: %d\n", volumedown_pressed_count);
    if (is_volumedown_enough(volumedown_pressed_count)) {
        // pressed over 3 times
        pr_info("KEY_VOLUMEDOWN pressed max times, safe mode detected!\n");
        safe_mode = true;
        return true;
    }

    return false;
}

static int sys_execve_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
    struct pt_regs *real_regs = PT_REAL_REGS(regs);
    const char __user **filename_user =
        (const char **)&PT_REGS_PARM1(real_regs);
    const char __user *const __user *__argv =
        (const char __user *const __user *)PT_REGS_PARM2(real_regs);
    struct user_arg_ptr argv = { .ptr.native = __argv };
    struct filename filename_in, *filename_p;
    char path[32];
    long ret;
    unsigned long addr;
    const char __user *fn;

    if (!filename_user)
        return 0;

    addr = untagged_addr((unsigned long)*filename_user);
    fn = (const char __user *)addr;

    memset(path, 0, sizeof(path));
    ret = strncpy_from_user_nofault(path, fn, 32);
    if (ret < 0 && try_set_access_flag(addr)) {
        ret = strncpy_from_user_nofault(path, fn, 32);
    }
    if (ret < 0) {
        pr_err("Access filename failed for execve_handler_pre\n");
        return 0;
    }
    filename_in.name = path;

    filename_p = &filename_in;
    return ksu_handle_execveat_ksud(AT_FDCWD, &filename_p, &argv, NULL, NULL);
}

static int sys_read_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
    struct pt_regs *real_regs = PT_REAL_REGS(regs);
    unsigned int fd = PT_REGS_PARM1(real_regs);

    ksu_handle_sys_read(fd);
    return 0;
}

static int sys_fstat_handler_pre(struct kretprobe_instance *p,
                                 struct pt_regs *regs)
{
    struct pt_regs *real_regs = PT_REAL_REGS(regs);
    unsigned int fd = PT_REGS_PARM1(real_regs);
    void *statbuf = PT_REGS_PARM2(real_regs);
    *(void **)&p->data = NULL;

    struct file *file = fget(fd);
    if (!file)
        return 1;
    if (is_init_rc(file)) {
        pr_info("stat init.rc");
        fput(file);
        *(void **)&p->data = statbuf;
        return 0;
    }
    fput(file);
    return 1;
}

static int sys_fstat_handler_post(struct kretprobe_instance *p,
                                  struct pt_regs *regs)
{
    void __user *statbuf = *(void **)&p->data;
    if (statbuf) {
        void __user *st_size_ptr = statbuf + offsetof(struct stat, st_size);
        long size, new_size;
        if (!copy_from_user_nofault(&size, st_size_ptr, sizeof(long))) {
            new_size = size + ksu_rc_len;
            pr_info("adding ksu_rc_len: %ld -> %ld", size, new_size);
            if (!copy_to_user_nofault(st_size_ptr, &new_size, sizeof(long))) {
                pr_info("added ksu_rc_len");
            } else {
                pr_err("add ksu_rc_len failed: statbuf 0x%lx",
                       (unsigned long)st_size_ptr);
            }
        } else {
            pr_err("read statbuf 0x%lx failed", (unsigned long)st_size_ptr);
        }
    }

    return 0;
}

static int input_handle_event_handler_pre(struct kprobe *p,
                                          struct pt_regs *regs)
{
    unsigned int *type = (unsigned int *)&PT_REGS_PARM2(regs);
    unsigned int *code = (unsigned int *)&PT_REGS_PARM3(regs);
    int *value = (int *)&PT_REGS_CCALL_PARM4(regs);
    return ksu_handle_input_handle_event(type, code, value);
}

static struct kprobe execve_kp = {
    .symbol_name = SYS_EXECVE_SYMBOL,
    .pre_handler = sys_execve_handler_pre,
};

static struct kprobe sys_read_kp = {
    .symbol_name = SYS_READ_SYMBOL,
    .pre_handler = sys_read_handler_pre,
};

static struct kretprobe sys_fstat_kp = {
    .kp.symbol_name = SYS_FSTAT_SYMBOL,
    .entry_handler = sys_fstat_handler_pre,
    .handler = sys_fstat_handler_post,
    .data_size = sizeof(void *),
};

static struct kprobe input_event_kp = {
    .symbol_name = "input_event",
    .pre_handler = input_handle_event_handler_pre,
};

static void do_stop_init_rc_hook(struct work_struct *work)
{
    unregister_kprobe(&sys_read_kp);
    unregister_kretprobe(&sys_fstat_kp);
}

static void do_stop_execve_hook(struct work_struct *work)
{
    unregister_kprobe(&execve_kp);
}

static void do_stop_input_hook(struct work_struct *work)
{
    unregister_kprobe(&input_event_kp);
}

static void stop_init_rc_hook()
{
    bool ret = schedule_work(&stop_init_rc_hook_work);
    pr_info("unregister init_rc_hook kprobe: %d!\n", ret);
}

static void stop_execve_hook()
{
    bool ret = schedule_work(&stop_execve_hook_work);
    pr_info("unregister execve kprobe: %d!\n", ret);
}

static void stop_input_hook()
{
    static bool input_hook_stopped = false;
    if (input_hook_stopped) {
        return;
    }
    input_hook_stopped = true;
    bool ret = schedule_work(&stop_input_hook_work);
    pr_info("unregister input kprobe: %d!\n", ret);
}

// ksud: module support
void ksu_ksud_init()
{
    int ret;

    ret = register_kprobe(&execve_kp);
    pr_info("ksud: execve_kp: %d\n", ret);

    ret = register_kprobe(&sys_read_kp);
    pr_info("ksud: sys_read_kp: %d\n", ret);

    ret = register_kretprobe(&sys_fstat_kp);
    pr_info("ksud: sys_fstat_kp: %d\n", ret);

    ret = register_kprobe(&input_event_kp);
    pr_info("ksud: input_event_kp: %d\n", ret);

    INIT_WORK(&stop_init_rc_hook_work, do_stop_init_rc_hook);
    INIT_WORK(&stop_execve_hook_work, do_stop_execve_hook);
    INIT_WORK(&stop_input_hook_work, do_stop_input_hook);
}

void ksu_ksud_exit()
{
    unregister_kprobe(&execve_kp);
    // this should be done before unregister sys_read_kp
    // unregister_kprobe(&sys_read_kp);
    unregister_kprobe(&input_event_kp);
}

```

`kernel/ksud.h`:

```h
#ifndef __KSU_H_KSUD
#define __KSU_H_KSUD

#include <linux/types.h>

#define KSUD_PATH "/data/adb/ksud"

void ksu_ksud_init();
void ksu_ksud_exit();

void on_post_fs_data(void);
void on_module_mounted(void);
void on_boot_completed(void);

bool ksu_is_safe_mode(void);

int nuke_ext4_sysfs(const char *mnt);

extern u32 ksu_file_sid;
extern bool ksu_module_mounted;
extern bool ksu_boot_completed;

#endif

```

`kernel/manager.h`:

```h
#ifndef __KSU_H_KSU_MANAGER
#define __KSU_H_KSU_MANAGER

#include <linux/cred.h>
#include <linux/types.h>
#include "allowlist.h"

#define KSU_INVALID_APPID -1

extern uid_t ksu_manager_appid; // DO NOT DIRECT USE

static inline bool ksu_is_manager_appid_valid()
{
    return ksu_manager_appid != KSU_INVALID_APPID;
}

static inline bool is_manager()
{
    return unlikely(ksu_manager_appid == current_uid().val % PER_USER_RANGE);
}

static inline bool is_uid_manager(uid_t uid)
{
    return unlikely(ksu_manager_appid == uid % PER_USER_RANGE);
}

static inline uid_t ksu_get_manager_appid()
{
    return ksu_manager_appid;
}

static inline void ksu_set_manager_appid(uid_t appid)
{
    ksu_manager_appid = appid;
}

static inline void ksu_invalidate_manager_uid()
{
    ksu_manager_appid = KSU_INVALID_APPID;
}

int ksu_observer_init(void);
#endif

```

`kernel/pkg_observer.c`:

```c
// SPDX-License-Identifier: GPL-2.0
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/namei.h>
#include <linux/fsnotify_backend.h>
#include <linux/slab.h>
#include <linux/rculist.h>
#include <linux/version.h>
#include "klog.h" // IWYU pragma: keep
#include "throne_tracker.h"

#define MASK_SYSTEM (FS_CREATE | FS_MOVE | FS_EVENT_ON_CHILD)

struct watch_dir {
    const char *path;
    u32 mask;
    struct path kpath;
    struct inode *inode;
    struct fsnotify_mark *mark;
};

static struct fsnotify_group *g;

static int ksu_handle_inode_event(struct fsnotify_mark *mark, u32 mask,
                                  struct inode *inode, struct inode *dir,
                                  const struct qstr *file_name, u32 cookie)
{
    if (!file_name)
        return 0;
    if (mask & FS_ISDIR)
        return 0;
    if (file_name->len == 13 && !memcmp(file_name->name, "packages.list", 13)) {
        pr_info("packages.list detected: %d\n", mask);
        track_throne(false);
    }
    return 0;
}

static const struct fsnotify_ops ksu_ops = {
    .handle_inode_event = ksu_handle_inode_event,
};

static int add_mark_on_inode(struct inode *inode, u32 mask,
                             struct fsnotify_mark **out)
{
    struct fsnotify_mark *m;

    m = kzalloc(sizeof(*m), GFP_KERNEL);
    if (!m)
        return -ENOMEM;

    fsnotify_init_mark(m, g);
    m->mask = mask;

    if (fsnotify_add_inode_mark(m, inode, 0)) {
        fsnotify_put_mark(m);
        return -EINVAL;
    }
    *out = m;
    return 0;
}

static int watch_one_dir(struct watch_dir *wd)
{
    int ret = kern_path(wd->path, LOOKUP_FOLLOW, &wd->kpath);
    if (ret) {
        pr_info("path not ready: %s (%d)\n", wd->path, ret);
        return ret;
    }
    wd->inode = d_inode(wd->kpath.dentry);
    ihold(wd->inode);

    ret = add_mark_on_inode(wd->inode, wd->mask, &wd->mark);
    if (ret) {
        pr_err("Add mark failed for %s (%d)\n", wd->path, ret);
        path_put(&wd->kpath);
        iput(wd->inode);
        wd->inode = NULL;
        return ret;
    }
    pr_info("watching %s\n", wd->path);
    return 0;
}

static void unwatch_one_dir(struct watch_dir *wd)
{
    if (wd->mark) {
        fsnotify_destroy_mark(wd->mark, g);
        fsnotify_put_mark(wd->mark);
        wd->mark = NULL;
    }
    if (wd->inode) {
        iput(wd->inode);
        wd->inode = NULL;
    }
    if (wd->kpath.dentry) {
        path_put(&wd->kpath);
        memset(&wd->kpath, 0, sizeof(wd->kpath));
    }
}

static struct watch_dir g_watch = { .path = "/data/system",
                                    .mask = MASK_SYSTEM };

int ksu_observer_init(void)
{
    int ret = 0;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
    g = fsnotify_alloc_group(&ksu_ops, 0);
#else
    g = fsnotify_alloc_group(&ksu_ops);
#endif
    if (IS_ERR(g))
        return PTR_ERR(g);

    ret = watch_one_dir(&g_watch);
    pr_info("observer init done\n");
    return 0;
}

void ksu_observer_exit(void)
{
    unwatch_one_dir(&g_watch);
    fsnotify_put_group(g);
    pr_info("observer exit done\n");
}
```

`kernel/seccomp_cache.c`:

```c
#include <linux/version.h>
#include <linux/fs.h>
#include <linux/nsproxy.h>
#include <linux/sched/task.h>
#include <linux/uaccess.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include "klog.h" // IWYU pragma: keep
#include "seccomp_cache.h"

struct action_cache {
    DECLARE_BITMAP(allow_native, SECCOMP_ARCH_NATIVE_NR);
#ifdef SECCOMP_ARCH_COMPAT
    DECLARE_BITMAP(allow_compat, SECCOMP_ARCH_COMPAT_NR);
#endif
};

struct seccomp_filter {
    refcount_t refs;
    refcount_t users;
    bool log;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
    bool wait_killable_recv;
#endif
    struct action_cache cache;
    struct seccomp_filter *prev;
    struct bpf_prog *prog;
    struct notification *notif;
    struct mutex notify_lock;
    wait_queue_head_t wqh;
};

void ksu_seccomp_clear_cache(struct seccomp_filter *filter, int nr)
{
    if (!filter) {
        return;
    }

    if (nr >= 0 && nr < SECCOMP_ARCH_NATIVE_NR) {
        clear_bit(nr, filter->cache.allow_native);
    }

#ifdef SECCOMP_ARCH_COMPAT
    if (nr >= 0 && nr < SECCOMP_ARCH_COMPAT_NR) {
        clear_bit(nr, filter->cache.allow_compat);
    }
#endif
}

void ksu_seccomp_allow_cache(struct seccomp_filter *filter, int nr)
{
    if (!filter) {
        return;
    }

    if (nr >= 0 && nr < SECCOMP_ARCH_NATIVE_NR) {
        set_bit(nr, filter->cache.allow_native);
    }

#ifdef SECCOMP_ARCH_COMPAT
    if (nr >= 0 && nr < SECCOMP_ARCH_COMPAT_NR) {
        set_bit(nr, filter->cache.allow_compat);
    }
#endif
}

```

`kernel/seccomp_cache.h`:

```h
#ifndef __KSU_H_KERNEL_COMPAT
#define __KSU_H_KERNEL_COMPAT

#include <linux/fs.h>
#include <linux/version.h>

extern void ksu_seccomp_clear_cache(struct seccomp_filter *filter, int nr);
extern void ksu_seccomp_allow_cache(struct seccomp_filter *filter, int nr);

#endif

```

`kernel/selinux/rules.c`:

```c
#include <linux/uaccess.h>
#include <linux/types.h>
#include <linux/version.h>

#include "../klog.h" // IWYU pragma: keep
#include "selinux.h"
#include "sepolicy.h"
#include "ss/services.h"
#include "linux/lsm_audit.h" // IWYU pragma: keep
#include "xfrm.h"

#define SELINUX_POLICY_INSTEAD_SELINUX_SS

#define ALL NULL

static struct policydb *get_policydb(void)
{
    struct policydb *db;
    struct selinux_policy *policy = selinux_state.policy;
    db = &policy->policydb;
    return db;
}

static DEFINE_MUTEX(ksu_rules);

void apply_kernelsu_rules()
{
    struct policydb *db;

    if (!getenforce()) {
        pr_info("SELinux permissive or disabled, apply rules!\n");
    }

    mutex_lock(&ksu_rules);

    db = get_policydb();

    ksu_permissive(db, KERNEL_SU_DOMAIN);
    ksu_typeattribute(db, KERNEL_SU_DOMAIN, "mlstrustedsubject");
    ksu_typeattribute(db, KERNEL_SU_DOMAIN, "netdomain");
    ksu_typeattribute(db, KERNEL_SU_DOMAIN, "bluetoothdomain");

    // Create unconstrained file type
    ksu_type(db, KERNEL_SU_FILE, "file_type");
    ksu_typeattribute(db, KERNEL_SU_FILE, "mlstrustedobject");
    ksu_allow(db, ALL, KERNEL_SU_FILE, ALL, ALL);

    // allow all!
    ksu_allow(db, KERNEL_SU_DOMAIN, ALL, ALL, ALL);

    // allow us do any ioctl
    if (db->policyvers >= POLICYDB_VERSION_XPERMS_IOCTL) {
        ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "blk_file", ALL);
        ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "fifo_file", ALL);
        ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "chr_file", ALL);
        ksu_allowxperm(db, KERNEL_SU_DOMAIN, ALL, "file", ALL);
    }

    // our ksud triggered by init
    ksu_allow(db, "init", KERNEL_SU_DOMAIN, ALL, ALL);

    // copied from Magisk rules
    // suRights
    ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "dir", "search");
    ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "dir", "read");
    ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "file", "open");
    ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "file", "read");
    ksu_allow(db, "servicemanager", KERNEL_SU_DOMAIN, "process", "getattr");
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "process", "sigchld");

    // allowLog
    ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "dir", "search");
    ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "file", "read");
    ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "file", "open");
    ksu_allow(db, "logd", KERNEL_SU_DOMAIN, "file", "getattr");

    // dumpsys
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fd", "use");
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "write");
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "read");
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "open");
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "fifo_file", "getattr");

    // bootctl
    ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "dir", "search");
    ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "file", "read");
    ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "file", "open");
    ksu_allow(db, "hwservicemanager", KERNEL_SU_DOMAIN, "process", "getattr");

    // Allow all binder transactions
    ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "binder", ALL);

    // Allow system server kill su process
    ksu_allow(db, "system_server", KERNEL_SU_DOMAIN, "process", "getpgid");
    ksu_allow(db, "system_server", KERNEL_SU_DOMAIN, "process", "sigkill");

    mutex_unlock(&ksu_rules);
}

#define MAX_SEPOL_LEN 128

#define CMD_NORMAL_PERM 1
#define CMD_XPERM 2
#define CMD_TYPE_STATE 3
#define CMD_TYPE 4
#define CMD_TYPE_ATTR 5
#define CMD_ATTR 6
#define CMD_TYPE_TRANSITION 7
#define CMD_TYPE_CHANGE 8
#define CMD_GENFSCON 9

struct sepol_data {
    u32 cmd;
    u32 subcmd;
    char __user *sepol1;
    char __user *sepol2;
    char __user *sepol3;
    char __user *sepol4;
    char __user *sepol5;
    char __user *sepol6;
    char __user *sepol7;
};

static int get_object(char *buf, char __user *user_object, size_t buf_sz,
                      char **object)
{
    if (!user_object) {
        *object = ALL;
        return 0;
    }

    if (strncpy_from_user(buf, user_object, buf_sz) < 0) {
        return -EINVAL;
    }

    *object = buf;

    return 0;
}
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0))
extern int avc_ss_reset(u32 seqno);
#else
extern int avc_ss_reset(struct selinux_avc *avc, u32 seqno);
#endif
// reset avc cache table, otherwise the new rules will not take effect if already denied
static void reset_avc_cache()
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0))
    avc_ss_reset(0);
    selnl_notify_policyload(0);
    selinux_status_update_policyload(0);
#else
    struct selinux_avc *avc = selinux_state.avc;
    avc_ss_reset(avc, 0);
    selnl_notify_policyload(0);
    selinux_status_update_policyload(&selinux_state, 0);
#endif
    selinux_xfrm_notify_policyload();
}

int handle_sepolicy(unsigned long arg3, void __user *arg4)
{
    struct policydb *db;

    if (!arg4) {
        return -EINVAL;
    }

    if (!getenforce()) {
        pr_info("SELinux permissive or disabled when handle policy!\n");
    }

    struct sepol_data data;
    if (copy_from_user(&data, arg4, sizeof(struct sepol_data))) {
        pr_err("sepol: copy sepol_data failed.\n");
        return -EINVAL;
    }

    u32 cmd = data.cmd;
    u32 subcmd = data.subcmd;

    mutex_lock(&ksu_rules);

    db = get_policydb();

    int ret = -EINVAL;
    if (cmd == CMD_NORMAL_PERM) {
        char src_buf[MAX_SEPOL_LEN];
        char tgt_buf[MAX_SEPOL_LEN];
        char cls_buf[MAX_SEPOL_LEN];
        char perm_buf[MAX_SEPOL_LEN];

        char *s, *t, *c, *p;
        if (get_object(src_buf, data.sepol1, sizeof(src_buf), &s) < 0) {
            pr_err("sepol: copy src failed.\n");
            goto exit;
        }

        if (get_object(tgt_buf, data.sepol2, sizeof(tgt_buf), &t) < 0) {
            pr_err("sepol: copy tgt failed.\n");
            goto exit;
        }

        if (get_object(cls_buf, data.sepol3, sizeof(cls_buf), &c) < 0) {
            pr_err("sepol: copy cls failed.\n");
            goto exit;
        }

        if (get_object(perm_buf, data.sepol4, sizeof(perm_buf), &p) < 0) {
            pr_err("sepol: copy perm failed.\n");
            goto exit;
        }

        bool success = false;
        if (subcmd == 1) {
            success = ksu_allow(db, s, t, c, p);
        } else if (subcmd == 2) {
            success = ksu_deny(db, s, t, c, p);
        } else if (subcmd == 3) {
            success = ksu_auditallow(db, s, t, c, p);
        } else if (subcmd == 4) {
            success = ksu_dontaudit(db, s, t, c, p);
        } else {
            pr_err("sepol: unknown subcmd: %d\n", subcmd);
        }
        ret = success ? 0 : -EINVAL;

    } else if (cmd == CMD_XPERM) {
        char src_buf[MAX_SEPOL_LEN];
        char tgt_buf[MAX_SEPOL_LEN];
        char cls_buf[MAX_SEPOL_LEN];

        char __maybe_unused operation[MAX_SEPOL_LEN]; // it is always ioctl now!
        char perm_set[MAX_SEPOL_LEN];

        char *s, *t, *c;
        if (get_object(src_buf, data.sepol1, sizeof(src_buf), &s) < 0) {
            pr_err("sepol: copy src failed.\n");
            goto exit;
        }
        if (get_object(tgt_buf, data.sepol2, sizeof(tgt_buf), &t) < 0) {
            pr_err("sepol: copy tgt failed.\n");
            goto exit;
        }
        if (get_object(cls_buf, data.sepol3, sizeof(cls_buf), &c) < 0) {
            pr_err("sepol: copy cls failed.\n");
            goto exit;
        }
        if (strncpy_from_user(operation, data.sepol4, sizeof(operation)) < 0) {
            pr_err("sepol: copy operation failed.\n");
            goto exit;
        }
        if (strncpy_from_user(perm_set, data.sepol5, sizeof(perm_set)) < 0) {
            pr_err("sepol: copy perm_set failed.\n");
            goto exit;
        }

        bool success = false;
        if (subcmd == 1) {
            success = ksu_allowxperm(db, s, t, c, perm_set);
        } else if (subcmd == 2) {
            success = ksu_auditallowxperm(db, s, t, c, perm_set);
        } else if (subcmd == 3) {
            success = ksu_dontauditxperm(db, s, t, c, perm_set);
        } else {
            pr_err("sepol: unknown subcmd: %d\n", subcmd);
        }
        ret = success ? 0 : -EINVAL;
    } else if (cmd == CMD_TYPE_STATE) {
        char src[MAX_SEPOL_LEN];

        if (strncpy_from_user(src, data.sepol1, sizeof(src)) < 0) {
            pr_err("sepol: copy src failed.\n");
            goto exit;
        }

        bool success = false;
        if (subcmd == 1) {
            success = ksu_permissive(db, src);
        } else if (subcmd == 2) {
            success = ksu_enforce(db, src);
        } else {
            pr_err("sepol: unknown subcmd: %d\n", subcmd);
        }
        if (success)
            ret = 0;

    } else if (cmd == CMD_TYPE || cmd == CMD_TYPE_ATTR) {
        char type[MAX_SEPOL_LEN];
        char attr[MAX_SEPOL_LEN];

        if (strncpy_from_user(type, data.sepol1, sizeof(type)) < 0) {
            pr_err("sepol: copy type failed.\n");
            goto exit;
        }
        if (strncpy_from_user(attr, data.sepol2, sizeof(attr)) < 0) {
            pr_err("sepol: copy attr failed.\n");
            goto exit;
        }

        bool success = false;
        if (cmd == CMD_TYPE) {
            success = ksu_type(db, type, attr);
        } else {
            success = ksu_typeattribute(db, type, attr);
        }
        if (!success) {
            pr_err("sepol: %d failed.\n", cmd);
            goto exit;
        }
        ret = 0;

    } else if (cmd == CMD_ATTR) {
        char attr[MAX_SEPOL_LEN];

        if (strncpy_from_user(attr, data.sepol1, sizeof(attr)) < 0) {
            pr_err("sepol: copy attr failed.\n");
            goto exit;
        }
        if (!ksu_attribute(db, attr)) {
            pr_err("sepol: %d failed.\n", cmd);
            goto exit;
        }
        ret = 0;

    } else if (cmd == CMD_TYPE_TRANSITION) {
        char src[MAX_SEPOL_LEN];
        char tgt[MAX_SEPOL_LEN];
        char cls[MAX_SEPOL_LEN];
        char default_type[MAX_SEPOL_LEN];
        char object[MAX_SEPOL_LEN];

        if (strncpy_from_user(src, data.sepol1, sizeof(src)) < 0) {
            pr_err("sepol: copy src failed.\n");
            goto exit;
        }
        if (strncpy_from_user(tgt, data.sepol2, sizeof(tgt)) < 0) {
            pr_err("sepol: copy tgt failed.\n");
            goto exit;
        }
        if (strncpy_from_user(cls, data.sepol3, sizeof(cls)) < 0) {
            pr_err("sepol: copy cls failed.\n");
            goto exit;
        }
        if (strncpy_from_user(default_type, data.sepol4, sizeof(default_type)) <
            0) {
            pr_err("sepol: copy default_type failed.\n");
            goto exit;
        }
        char *real_object;
        if (data.sepol5 == NULL) {
            real_object = NULL;
        } else {
            if (strncpy_from_user(object, data.sepol5, sizeof(object)) < 0) {
                pr_err("sepol: copy object failed.\n");
                goto exit;
            }
            real_object = object;
        }

        bool success =
            ksu_type_transition(db, src, tgt, cls, default_type, real_object);
        if (success)
            ret = 0;

    } else if (cmd == CMD_TYPE_CHANGE) {
        char src[MAX_SEPOL_LEN];
        char tgt[MAX_SEPOL_LEN];
        char cls[MAX_SEPOL_LEN];
        char default_type[MAX_SEPOL_LEN];

        if (strncpy_from_user(src, data.sepol1, sizeof(src)) < 0) {
            pr_err("sepol: copy src failed.\n");
            goto exit;
        }
        if (strncpy_from_user(tgt, data.sepol2, sizeof(tgt)) < 0) {
            pr_err("sepol: copy tgt failed.\n");
            goto exit;
        }
        if (strncpy_from_user(cls, data.sepol3, sizeof(cls)) < 0) {
            pr_err("sepol: copy cls failed.\n");
            goto exit;
        }
        if (strncpy_from_user(default_type, data.sepol4, sizeof(default_type)) <
            0) {
            pr_err("sepol: copy default_type failed.\n");
            goto exit;
        }
        bool success = false;
        if (subcmd == 1) {
            success = ksu_type_change(db, src, tgt, cls, default_type);
        } else if (subcmd == 2) {
            success = ksu_type_member(db, src, tgt, cls, default_type);
        } else {
            pr_err("sepol: unknown subcmd: %d\n", subcmd);
        }
        if (success)
            ret = 0;
    } else if (cmd == CMD_GENFSCON) {
        char name[MAX_SEPOL_LEN];
        char path[MAX_SEPOL_LEN];
        char context[MAX_SEPOL_LEN];
        if (strncpy_from_user(name, data.sepol1, sizeof(name)) < 0) {
            pr_err("sepol: copy name failed.\n");
            goto exit;
        }
        if (strncpy_from_user(path, data.sepol2, sizeof(path)) < 0) {
            pr_err("sepol: copy path failed.\n");
            goto exit;
        }
        if (strncpy_from_user(context, data.sepol3, sizeof(context)) < 0) {
            pr_err("sepol: copy context failed.\n");
            goto exit;
        }

        if (!ksu_genfscon(db, name, path, context)) {
            pr_err("sepol: %d failed.\n", cmd);
            goto exit;
        }
        ret = 0;
    } else {
        pr_err("sepol: unknown cmd: %d\n", cmd);
    }

exit:
    mutex_unlock(&ksu_rules);

    // only allow and xallow needs to reset avc cache, but we cannot do that because
    // we are in atomic context. so we just reset it every time.
    reset_avc_cache();

    return ret;
}

```

`kernel/selinux/selinux.c`:

```c
#include "selinux.h"
#include "linux/cred.h"
#include "linux/sched.h"
#include "objsec.h"
#include "linux/version.h"
#include "../klog.h" // IWYU pragma: keep
#include "../ksu.h"

/*
 * Cached SID values for frequently checked contexts.
 * These are resolved once at init and used for fast u32 comparison
 * instead of expensive string operations on every check.
 *
 * A value of 0 means "no cached SID is available" for that context.
 * This covers both the initial "not yet cached" state and any case
 * where resolving the SID (e.g. via security_secctx_to_secid) failed.
 * In all such cases we intentionally fall back to the slower
 * string-based comparison path; this degrades performance only and
 * does not cause a functional failure.
 */
static u32 cached_su_sid __read_mostly = 0;
static u32 cached_zygote_sid __read_mostly = 0;
static u32 cached_init_sid __read_mostly = 0;
u32 ksu_file_sid __read_mostly = 0;

static int transive_to_domain(const char *domain, struct cred *cred)
{
    u32 sid;
    int error;
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 18, 0)
    struct task_security_struct *tsec;
#else
    struct cred_security_struct *tsec;
#endif
    tsec = selinux_cred(cred);
    if (!tsec) {
        pr_err("tsec == NULL!\n");
        return -1;
    }
    error = security_secctx_to_secid(domain, strlen(domain), &sid);
    if (error) {
        pr_info("security_secctx_to_secid %s -> sid: %d, error: %d\n", domain,
                sid, error);
    }
    if (!error) {
        tsec->sid = sid;
        tsec->create_sid = 0;
        tsec->keycreate_sid = 0;
        tsec->sockcreate_sid = 0;
    }
    return error;
}

void setup_selinux(const char *domain, struct cred *cred)
{
    if (transive_to_domain(domain, cred)) {
        pr_err("transive domain failed.\n");
        return;
    }
}

void setup_ksu_cred(void)
{
    if (ksu_cred && transive_to_domain(KERNEL_SU_CONTEXT, ksu_cred)) {
        pr_err("setup ksu cred failed.\n");
    }
}

void setenforce(bool enforce)
{
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
    selinux_state.enforcing = enforce;
#endif
}

bool getenforce(void)
{
#ifdef CONFIG_SECURITY_SELINUX_DISABLE
    if (selinux_state.disabled) {
        return false;
    }
#endif

#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
    return selinux_state.enforcing;
#else
    return true;
#endif
}

#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 14, 0)
struct lsm_context {
    char *context;
    u32 len;
};

static int __security_secid_to_secctx(u32 secid, struct lsm_context *cp)
{
    return security_secid_to_secctx(secid, &cp->context, &cp->len);
}
static void __security_release_secctx(struct lsm_context *cp)
{
    security_release_secctx(cp->context, cp->len);
}
#else
#define __security_secid_to_secctx security_secid_to_secctx
#define __security_release_secctx security_release_secctx
#endif

/*
 * Initialize cached SID values for frequently checked SELinux contexts.
 * Called once after SELinux policy is loaded (post-fs-data).
 * This eliminates expensive string comparisons in hot paths.
 */
void cache_sid(void)
{
    int err;

    err = security_secctx_to_secid(KERNEL_SU_CONTEXT, strlen(KERNEL_SU_CONTEXT),
                                   &cached_su_sid);
    if (err) {
        pr_warn("Failed to cache kernel su domain SID: %d\n", err);
        cached_su_sid = 0;
    } else {
        pr_info("Cached su SID: %u\n", cached_su_sid);
    }

    err = security_secctx_to_secid(ZYGOTE_CONTEXT, strlen(ZYGOTE_CONTEXT),
                                   &cached_zygote_sid);
    if (err) {
        pr_warn("Failed to cache zygote SID: %d\n", err);
        cached_zygote_sid = 0;
    } else {
        pr_info("Cached zygote SID: %u\n", cached_zygote_sid);
    }

    err = security_secctx_to_secid(INIT_CONTEXT, strlen(INIT_CONTEXT),
                                   &cached_init_sid);
    if (err) {
        pr_warn("Failed to cache init SID: %d\n", err);
        cached_init_sid = 0;
    } else {
        pr_info("Cached init SID: %u\n", cached_init_sid);
    }

    err = security_secctx_to_secid(KSU_FILE_CONTEXT, strlen(KSU_FILE_CONTEXT),
                                   &ksu_file_sid);
    if (err) {
        pr_warn("Failed to cache ksu_file SID: %d\n", err);
        ksu_file_sid = 0;
    } else {
        pr_info("Cached ksu_file SID: %u\n", ksu_file_sid);
    }
}

/*
 * Fast path: compare task's SID directly against cached value.
 * Falls back to string comparison if cache is not initialized.
 */
static bool is_sid_match(const struct cred *cred, u32 cached_sid,
                         const char *fallback_context)
{
    if (!cred) {
        return false;
    }
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 18, 0)
    const struct task_security_struct *tsec = selinux_cred(cred);
#else
    const struct cred_security_struct *tsec = selinux_cred(cred);
#endif
    if (!tsec) {
        return false;
    }

    // Fast path: use cached SID if available
    if (likely(cached_sid != 0)) {
        return tsec->sid == cached_sid;
    }

    // Slow path fallback: string comparison (only before cache is initialized)
    struct lsm_context ctx;
    bool result;
    if (__security_secid_to_secctx(tsec->sid, &ctx)) {
        return false;
    }
    result = strncmp(fallback_context, ctx.context, ctx.len) == 0;
    __security_release_secctx(&ctx);
    return result;
}

bool is_task_ksu_domain(const struct cred *cred)
{
    return is_sid_match(cred, cached_su_sid, KERNEL_SU_CONTEXT);
}

bool is_ksu_domain(void)
{
    return is_task_ksu_domain(current_cred());
}

bool is_zygote(const struct cred *cred)
{
    return is_sid_match(cred, cached_zygote_sid, ZYGOTE_CONTEXT);
}

bool is_init(const struct cred *cred)
{
    return is_sid_match(cred, cached_init_sid, INIT_CONTEXT);
}

```

`kernel/selinux/selinux.h`:

```h
#ifndef __KSU_H_SELINUX
#define __KSU_H_SELINUX

#include "linux/types.h"
#include "linux/version.h"
#include "linux/cred.h"

// TODO: rename to "ksu"
#define KERNEL_SU_DOMAIN "su"
#define KERNEL_SU_FILE "ksu_file"

#define KERNEL_SU_CONTEXT "u:r:" KERNEL_SU_DOMAIN ":s0"
#define KSU_FILE_CONTEXT "u:object_r:" KERNEL_SU_FILE ":s0"
#define ZYGOTE_CONTEXT "u:r:zygote:s0"
#define INIT_CONTEXT "u:r:init:s0"

void setup_selinux(const char *, struct cred *);

void setenforce(bool);

bool getenforce();

void cache_sid(void);

bool is_task_ksu_domain(const struct cred *cred);

bool is_ksu_domain();

bool is_zygote(const struct cred *cred);

bool is_init(const struct cred *cred);

void apply_kernelsu_rules();

int handle_sepolicy(unsigned long arg3, void __user *arg4);

void setup_ksu_cred();

#endif

```

`kernel/selinux/sepolicy.c`:

```c
#include <linux/gfp.h>
#include <linux/printk.h>
#include <linux/slab.h>
#include <linux/version.h>

#include "sepolicy.h"
#include "../klog.h" // IWYU pragma: keep
#include "ss/symtab.h"

#define KSU_SUPPORT_ADD_TYPE

//////////////////////////////////////////////////////
// Declaration
//////////////////////////////////////////////////////

static struct avtab_node *get_avtab_node(struct policydb *db,
                                         struct avtab_key *key,
                                         struct avtab_extended_perms *xperms);

static bool add_rule(struct policydb *db, const char *s, const char *t,
                     const char *c, const char *p, int effect, bool invert);

static void add_rule_raw(struct policydb *db, struct type_datum *src,
                         struct type_datum *tgt, struct class_datum *cls,
                         struct perm_datum *perm, int effect, bool invert);

static void add_xperm_rule_raw(struct policydb *db, struct type_datum *src,
                               struct type_datum *tgt, struct class_datum *cls,
                               uint16_t low, uint16_t high, int effect,
                               bool invert);
static bool add_xperm_rule(struct policydb *db, const char *s, const char *t,
                           const char *c, const char *range, int effect,
                           bool invert);

static bool add_type_rule(struct policydb *db, const char *s, const char *t,
                          const char *c, const char *d, int effect);

static bool add_filename_trans(struct policydb *db, const char *s,
                               const char *t, const char *c, const char *d,
                               const char *o);

static bool add_genfscon(struct policydb *db, const char *fs_name,
                         const char *path, const char *context);

static bool add_type(struct policydb *db, const char *type_name, bool attr);

static bool set_type_state(struct policydb *db, const char *type_name,
                           bool permissive);

static void add_typeattribute_raw(struct policydb *db, struct type_datum *type,
                                  struct type_datum *attr);

static bool add_typeattribute(struct policydb *db, const char *type,
                              const char *attr);

//////////////////////////////////////////////////////
// Implementation
//////////////////////////////////////////////////////

// Invert is adding rules for auditdeny; in other cases, invert is removing
// rules
#define strip_av(effect, invert) ((effect == AVTAB_AUDITDENY) == !invert)

#define ksu_hash_for_each(node_ptr, n_slot, cur)                               \
    int i;                                                                     \
    for (i = 0; i < n_slot; ++i)                                               \
        for (cur = node_ptr[i]; cur; cur = cur->next)

// htable is a struct instead of pointer above 5.8.0:
// https://elixir.bootlin.com/linux/v5.8-rc1/source/security/selinux/ss/symtab.h
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
#define ksu_hashtab_for_each(htab, cur)                                        \
    ksu_hash_for_each(htab.htable, htab.size, cur)
#else
#define ksu_hashtab_for_each(htab, cur)                                        \
    ksu_hash_for_each(htab->htable, htab->size, cur)
#endif

// symtab_search is introduced on 5.9.0:
// https://elixir.bootlin.com/linux/v5.9-rc1/source/security/selinux/ss/symtab.h
#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
#define symtab_search(s, name) hashtab_search((s)->table, name)
#define symtab_insert(s, name, datum) hashtab_insert((s)->table, name, datum)
#endif

#define avtab_for_each(avtab, cur)                                             \
    ksu_hash_for_each(avtab.htable, avtab.nslot, cur);

static struct avtab_node *get_avtab_node(struct policydb *db,
                                         struct avtab_key *key,
                                         struct avtab_extended_perms *xperms)
{
    struct avtab_node *node;

    /* AVTAB_XPERMS entries are not necessarily unique */
    if (key->specified & AVTAB_XPERMS) {
        bool match = false;
        node = avtab_search_node(&db->te_avtab, key);
        while (node) {
            if ((node->datum.u.xperms->specified == xperms->specified) &&
                (node->datum.u.xperms->driver == xperms->driver)) {
                match = true;
                break;
            }
            node = avtab_search_node_next(node, key->specified);
        }
        if (!match)
            node = NULL;
    } else {
        node = avtab_search_node(&db->te_avtab, key);
    }

    if (!node) {
        struct avtab_datum avdatum = {};
        /*
     * AUDITDENY, aka DONTAUDIT, are &= assigned, versus |= for
     * others. Initialize the data accordingly.
     */
        if (key->specified & AVTAB_XPERMS) {
            avdatum.u.xperms = xperms;
        } else {
            avdatum.u.data = key->specified == AVTAB_AUDITDENY ? ~0U : 0U;
        }
        /* this is used to get the node - insertion is actually unique */
        node = avtab_insert_nonunique(&db->te_avtab, key, &avdatum);

        int grow_size = sizeof(struct avtab_key);
        grow_size += sizeof(struct avtab_datum);
        if (key->specified & AVTAB_XPERMS) {
            grow_size += sizeof(u8);
            grow_size += sizeof(u8);
            grow_size += sizeof(u32) * ARRAY_SIZE(avdatum.u.xperms->perms.p);
        }
        db->len += grow_size;
    }

    return node;
}

static bool add_rule(struct policydb *db, const char *s, const char *t,
                     const char *c, const char *p, int effect, bool invert)
{
    struct type_datum *src = NULL, *tgt = NULL;
    struct class_datum *cls = NULL;
    struct perm_datum *perm = NULL;

    if (s) {
        src = symtab_search(&db->p_types, s);
        if (src == NULL) {
            pr_info("source type %s does not exist\n", s);
            return false;
        }
    }

    if (t) {
        tgt = symtab_search(&db->p_types, t);
        if (tgt == NULL) {
            pr_info("target type %s does not exist\n", t);
            return false;
        }
    }

    if (c) {
        cls = symtab_search(&db->p_classes, c);
        if (cls == NULL) {
            pr_info("class %s does not exist\n", c);
            return false;
        }
    }

    if (p) {
        if (c == NULL) {
            pr_info("No class is specified, cannot add perm [%s] \n", p);
            return false;
        }

        perm = symtab_search(&cls->permissions, p);
        if (perm == NULL && cls->comdatum != NULL) {
            perm = symtab_search(&cls->comdatum->permissions, p);
        }
        if (perm == NULL) {
            pr_info("perm %s does not exist in class %s\n", p, c);
            return false;
        }
    }
    add_rule_raw(db, src, tgt, cls, perm, effect, invert);
    return true;
}

static void add_rule_raw(struct policydb *db, struct type_datum *src,
                         struct type_datum *tgt, struct class_datum *cls,
                         struct perm_datum *perm, int effect, bool invert)
{
    if (src == NULL) {
        struct hashtab_node *node;
        if (strip_av(effect, invert)) {
            ksu_hashtab_for_each(db->p_types.table, node)
            {
                add_rule_raw(db, (struct type_datum *)node->datum, tgt, cls,
                             perm, effect, invert);
            };
        } else {
            ksu_hashtab_for_each(db->p_types.table, node)
            {
                struct type_datum *type = (struct type_datum *)(node->datum);
                if (type->attribute) {
                    add_rule_raw(db, type, tgt, cls, perm, effect, invert);
                }
            };
        }
    } else if (tgt == NULL) {
        struct hashtab_node *node;
        if (strip_av(effect, invert)) {
            ksu_hashtab_for_each(db->p_types.table, node)
            {
                add_rule_raw(db, src, (struct type_datum *)node->datum, cls,
                             perm, effect, invert);
            };
        } else {
            ksu_hashtab_for_each(db->p_types.table, node)
            {
                struct type_datum *type = (struct type_datum *)(node->datum);
                if (type->attribute) {
                    add_rule_raw(db, src, type, cls, perm, effect, invert);
                }
            };
        }
    } else if (cls == NULL) {
        struct hashtab_node *node;
        ksu_hashtab_for_each(db->p_classes.table, node)
        {
            add_rule_raw(db, src, tgt, (struct class_datum *)node->datum, perm,
                         effect, invert);
        }
    } else {
        struct avtab_key key;
        key.source_type = src->value;
        key.target_type = tgt->value;
        key.target_class = cls->value;
        key.specified = effect;

        struct avtab_node *node = get_avtab_node(db, &key, NULL);
        if (invert) {
            if (perm)
                node->datum.u.data &= ~(1U << (perm->value - 1));
            else
                node->datum.u.data = 0U;
        } else {
            if (perm)
                node->datum.u.data |= 1U << (perm->value - 1);
            else
                node->datum.u.data = ~0U;
        }
    }
}

#define ioctl_driver(x) (x >> 8 & 0xFF)
#define ioctl_func(x) (x & 0xFF)

#define xperm_test(x, p) (1 & (p[x >> 5] >> (x & 0x1f)))
#define xperm_set(x, p) (p[x >> 5] |= (1 << (x & 0x1f)))
#define xperm_clear(x, p) (p[x >> 5] &= ~(1 << (x & 0x1f)))

static void add_xperm_rule_raw(struct policydb *db, struct type_datum *src,
                               struct type_datum *tgt, struct class_datum *cls,
                               uint16_t low, uint16_t high, int effect,
                               bool invert)
{
    if (src == NULL) {
        struct hashtab_node *node;
        ksu_hashtab_for_each(db->p_types.table, node)
        {
            struct type_datum *type = (struct type_datum *)(node->datum);
            if (type->attribute) {
                add_xperm_rule_raw(db, type, tgt, cls, low, high, effect,
                                   invert);
            }
        };
    } else if (tgt == NULL) {
        struct hashtab_node *node;
        ksu_hashtab_for_each(db->p_types.table, node)
        {
            struct type_datum *type = (struct type_datum *)(node->datum);
            if (type->attribute) {
                add_xperm_rule_raw(db, src, type, cls, low, high, effect,
                                   invert);
            }
        };
    } else if (cls == NULL) {
        struct hashtab_node *node;
        ksu_hashtab_for_each(db->p_classes.table, node)
        {
            add_xperm_rule_raw(db, src, tgt,
                               (struct class_datum *)(node->datum), low, high,
                               effect, invert);
        };
    } else {
        struct avtab_key key;
        key.source_type = src->value;
        key.target_type = tgt->value;
        key.target_class = cls->value;
        key.specified = effect;

        struct avtab_datum *datum;
        struct avtab_node *node;
        struct avtab_extended_perms xperms;

        memset(&xperms, 0, sizeof(xperms));
        if (ioctl_driver(low) != ioctl_driver(high)) {
            xperms.specified = AVTAB_XPERMS_IOCTLDRIVER;
            xperms.driver = 0;
        } else {
            xperms.specified = AVTAB_XPERMS_IOCTLFUNCTION;
            xperms.driver = ioctl_driver(low);
        }
        int i;
        if (xperms.specified == AVTAB_XPERMS_IOCTLDRIVER) {
            for (i = ioctl_driver(low); i <= ioctl_driver(high); ++i) {
                if (invert)
                    xperm_clear(i, xperms.perms.p);
                else
                    xperm_set(i, xperms.perms.p);
            }
        } else {
            for (i = ioctl_func(low); i <= ioctl_func(high); ++i) {
                if (invert)
                    xperm_clear(i, xperms.perms.p);
                else
                    xperm_set(i, xperms.perms.p);
            }
        }

        node = get_avtab_node(db, &key, &xperms);
        if (!node) {
            pr_warn("add_xperm_rule_raw cannot found node!\n");
            return;
        }
        datum = &node->datum;

        if (datum->u.xperms == NULL) {
            datum->u.xperms = (struct avtab_extended_perms *)(kzalloc(
                sizeof(xperms), GFP_ATOMIC));
            if (!datum->u.xperms) {
                pr_err("alloc xperms failed\n");
                return;
            }
            memcpy(datum->u.xperms, &xperms, sizeof(xperms));
        }
    }
}

static bool add_xperm_rule(struct policydb *db, const char *s, const char *t,
                           const char *c, const char *range, int effect,
                           bool invert)
{
    struct type_datum *src = NULL, *tgt = NULL;
    struct class_datum *cls = NULL;

    if (s) {
        src = symtab_search(&db->p_types, s);
        if (src == NULL) {
            pr_info("source type %s does not exist\n", s);
            return false;
        }
    }

    if (t) {
        tgt = symtab_search(&db->p_types, t);
        if (tgt == NULL) {
            pr_info("target type %s does not exist\n", t);
            return false;
        }
    }

    if (c) {
        cls = symtab_search(&db->p_classes, c);
        if (cls == NULL) {
            pr_info("class %s does not exist\n", c);
            return false;
        }
    }

    u16 low, high;

    if (range) {
        if (strchr(range, '-')) {
            sscanf(range, "%hx-%hx", &low, &high);
        } else {
            sscanf(range, "%hx", &low);
            high = low;
        }
    } else {
        low = 0;
        high = 0xFFFF;
    }

    add_xperm_rule_raw(db, src, tgt, cls, low, high, effect, invert);
    return true;
}

static bool add_type_rule(struct policydb *db, const char *s, const char *t,
                          const char *c, const char *d, int effect)
{
    struct type_datum *src, *tgt, *def;
    struct class_datum *cls;

    src = symtab_search(&db->p_types, s);
    if (src == NULL) {
        pr_info("source type %s does not exist\n", s);
        return false;
    }
    tgt = symtab_search(&db->p_types, t);
    if (tgt == NULL) {
        pr_info("target type %s does not exist\n", t);
        return false;
    }
    cls = symtab_search(&db->p_classes, c);
    if (cls == NULL) {
        pr_info("class %s does not exist\n", c);
        return false;
    }
    def = symtab_search(&db->p_types, d);
    if (def == NULL) {
        pr_info("default type %s does not exist\n", d);
        return false;
    }

    struct avtab_key key;
    key.source_type = src->value;
    key.target_type = tgt->value;
    key.target_class = cls->value;
    key.specified = effect;

    struct avtab_node *node = get_avtab_node(db, &key, NULL);
    node->datum.u.data = def->value;

    return true;
}

// 5.9.0 : static inline int hashtab_insert(struct hashtab *h, void *key, void
// *datum, struct hashtab_key_params key_params) 5.8.0: int
// hashtab_insert(struct hashtab *h, void *k, void *d);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
static u32 filenametr_hash(const void *k)
{
    const struct filename_trans_key *ft = k;
    unsigned long hash;
    unsigned int byte_num;
    unsigned char focus;

    hash = ft->ttype ^ ft->tclass;

    byte_num = 0;
    while ((focus = ft->name[byte_num++]))
        hash = partial_name_hash(focus, hash);
    return hash;
}

static int filenametr_cmp(const void *k1, const void *k2)
{
    const struct filename_trans_key *ft1 = k1;
    const struct filename_trans_key *ft2 = k2;
    int v;

    v = ft1->ttype - ft2->ttype;
    if (v)
        return v;

    v = ft1->tclass - ft2->tclass;
    if (v)
        return v;

    return strcmp(ft1->name, ft2->name);
}

static const struct hashtab_key_params filenametr_key_params = {
    .hash = filenametr_hash,
    .cmp = filenametr_cmp,
};
#endif

static bool add_filename_trans(struct policydb *db, const char *s,
                               const char *t, const char *c, const char *d,
                               const char *o)
{
    struct type_datum *src, *tgt, *def;
    struct class_datum *cls;

    src = symtab_search(&db->p_types, s);
    if (src == NULL) {
        pr_warn("source type %s does not exist\n", s);
        return false;
    }
    tgt = symtab_search(&db->p_types, t);
    if (tgt == NULL) {
        pr_warn("target type %s does not exist\n", t);
        return false;
    }
    cls = symtab_search(&db->p_classes, c);
    if (cls == NULL) {
        pr_warn("class %s does not exist\n", c);
        return false;
    }
    def = symtab_search(&db->p_types, d);
    if (def == NULL) {
        pr_warn("default type %s does not exist\n", d);
        return false;
    }

    struct filename_trans_key key;
    key.ttype = tgt->value;
    key.tclass = cls->value;
    key.name = (char *)o;

    struct filename_trans_datum *last = NULL;

    struct filename_trans_datum *trans = policydb_filenametr_search(db, &key);
    while (trans) {
        if (ebitmap_get_bit(&trans->stypes, src->value - 1)) {
            // Duplicate, overwrite existing data and return
            trans->otype = def->value;
            return true;
        }
        if (trans->otype == def->value)
            break;
        last = trans;
        trans = trans->next;
    }

    if (trans == NULL) {
        trans = (struct filename_trans_datum *)kcalloc(1, sizeof(*trans),
                                                       GFP_ATOMIC);
        struct filename_trans_key *new_key =
            (struct filename_trans_key *)kzalloc(sizeof(*new_key), GFP_ATOMIC);
        *new_key = key;
        new_key->name = kstrdup(key.name, GFP_ATOMIC);
        trans->next = last;
        trans->otype = def->value;
        hashtab_insert(&db->filename_trans, new_key, trans,
                       filenametr_key_params);
    }

    db->compat_filename_trans_count++;
    return ebitmap_set_bit(&trans->stypes, src->value - 1, 1) == 0;
}

static bool add_genfscon(struct policydb *db, const char *fs_name,
                         const char *path, const char *context)
{
    return false;
}

// https://github.com/torvalds/linux/commit/590b9d576caec6b4c46bba49ed36223a399c3fc5#diff-cc9aa90e094e6e0f47bd7300db4f33cf4366b98b55d8753744f31eb69c691016R844-R845
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
#define ksu_kvrealloc(p, new_size, _old_size) kvrealloc(p, new_size, GFP_ATOMIC)
// https://github.com/torvalds/linux/commit/de2860f4636256836450c6543be744a50118fc66#diff-fa19cdd9c3369d7f59aa2e8404628109408dbf8e1b568d1157a27328f75b8410R638-R652
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
#define ksu_kvrealloc(p, new_size, old_size)                                   \
    kvrealloc(p, old_size, new_size, GFP_ATOMIC)
#else
// https://cs.android.com/android/_/android/kernel/common/+/f5f3e54f811679761c33526e695bd296190faade
// Some 5.10 kernel don't have this backport, so copy one.
void *ksu_kvrealloc_compat(const void *p, size_t oldsize, size_t newsize,
                           gfp_t flags)
{
    void *newp;

    if (oldsize >= newsize)
        return (void *)p;
    newp = kvmalloc(newsize, flags);
    if (!newp)
        return NULL;
    memcpy(newp, p, oldsize);
    kvfree(p);
    return newp;
}
#define ksu_kvrealloc(p, new_size, old_size)                                   \
    ksu_kvrealloc_compat(p, old_size, new_size, GFP_ATOMIC)
#endif

static bool add_type(struct policydb *db, const char *type_name, bool attr)
{
    struct type_datum *type = symtab_search(&db->p_types, type_name);
    if (type) {
        pr_warn("Type %s already exists\n", type_name);
        return true;
    }

    u32 value = ++db->p_types.nprim;
    type = (struct type_datum *)kzalloc(sizeof(struct type_datum), GFP_ATOMIC);
    if (!type) {
        pr_err("add_type: alloc type_datum failed.\n");
        return false;
    }

    type->primary = 1;
    type->value = value;
    type->attribute = attr;

    char *key = kstrdup(type_name, GFP_ATOMIC);
    if (!key) {
        pr_err("add_type: alloc key failed.\n");
        return false;
    }

    if (symtab_insert(&db->p_types, key, type)) {
        pr_err("add_type: insert symtab failed.\n");
        return false;
    }

    struct ebitmap *new_type_attr_map_array =
        ksu_kvrealloc(db->type_attr_map_array, value * sizeof(struct ebitmap),
                      (value - 1) * sizeof(struct ebitmap));

    if (!new_type_attr_map_array) {
        pr_err("add_type: alloc type_attr_map_array failed\n");
        return false;
    }

    struct type_datum **new_type_val_to_struct =
        ksu_kvrealloc(db->type_val_to_struct,
                      sizeof(*db->type_val_to_struct) * value,
                      sizeof(*db->type_val_to_struct) * (value - 1));

    if (!new_type_val_to_struct) {
        pr_err("add_type: alloc type_val_to_struct failed\n");
        return false;
    }

    char **new_val_to_name_types =
        ksu_kvrealloc(db->sym_val_to_name[SYM_TYPES], sizeof(char *) * value,
                      sizeof(char *) * (value - 1));
    if (!new_val_to_name_types) {
        pr_err("add_type: alloc val_to_name failed\n");
        return false;
    }

    db->type_attr_map_array = new_type_attr_map_array;
    ebitmap_init(&db->type_attr_map_array[value - 1]);
    ebitmap_set_bit(&db->type_attr_map_array[value - 1], value - 1, 1);

    db->type_val_to_struct = new_type_val_to_struct;
    db->type_val_to_struct[value - 1] = type;

    db->sym_val_to_name[SYM_TYPES] = new_val_to_name_types;
    db->sym_val_to_name[SYM_TYPES][value - 1] = key;

    int i;
    for (i = 0; i < db->p_roles.nprim; ++i) {
        ebitmap_set_bit(&db->role_val_to_struct[i]->types, value - 1, 1);
    }

    return true;
}

static bool set_type_state(struct policydb *db, const char *type_name,
                           bool permissive)
{
    struct type_datum *type;
    if (type_name == NULL) {
        struct hashtab_node *node;
        ksu_hashtab_for_each(db->p_types.table, node)
        {
            type = (struct type_datum *)(node->datum);
            if (ebitmap_set_bit(&db->permissive_map, type->value, permissive))
                pr_info("Could not set bit in permissive map\n");
        };
    } else {
        type = (struct type_datum *)symtab_search(&db->p_types, type_name);
        if (type == NULL) {
            pr_info("type %s does not exist\n", type_name);
            return false;
        }
        if (ebitmap_set_bit(&db->permissive_map, type->value, permissive)) {
            pr_info("Could not set bit in permissive map\n");
            return false;
        }
    }
    return true;
}

static void add_typeattribute_raw(struct policydb *db, struct type_datum *type,
                                  struct type_datum *attr)
{
    struct ebitmap *sattr = &db->type_attr_map_array[type->value - 1];
    ebitmap_set_bit(sattr, attr->value - 1, 1);

    struct hashtab_node *node;
    struct constraint_node *n;
    struct constraint_expr *e;
    ksu_hashtab_for_each(db->p_classes.table, node)
    {
        struct class_datum *cls = (struct class_datum *)(node->datum);
        for (n = cls->constraints; n; n = n->next) {
            for (e = n->expr; e; e = e->next) {
                if (e->expr_type == CEXPR_NAMES &&
                    ebitmap_get_bit(&e->type_names->types, attr->value - 1)) {
                    ebitmap_set_bit(&e->names, type->value - 1, 1);
                }
            }
        }
    };
}

static bool add_typeattribute(struct policydb *db, const char *type,
                              const char *attr)
{
    struct type_datum *type_d = symtab_search(&db->p_types, type);
    if (type_d == NULL) {
        pr_info("type %s does not exist\n", type);
        return false;
    } else if (type_d->attribute) {
        pr_info("type %s is an attribute\n", attr);
        return false;
    }

    struct type_datum *attr_d = symtab_search(&db->p_types, attr);
    if (attr_d == NULL) {
        pr_info("attribute %s does not exist\n", type);
        return false;
    } else if (!attr_d->attribute) {
        pr_info("type %s is not an attribute \n", attr);
        return false;
    }

    add_typeattribute_raw(db, type_d, attr_d);
    return true;
}

//////////////////////////////////////////////////////////////////////////

// Operation on types
bool ksu_type(struct policydb *db, const char *name, const char *attr)
{
    return add_type(db, name, false) && add_typeattribute(db, name, attr);
}

bool ksu_attribute(struct policydb *db, const char *name)
{
    return add_type(db, name, true);
}

bool ksu_permissive(struct policydb *db, const char *type)
{
    return set_type_state(db, type, true);
}

bool ksu_enforce(struct policydb *db, const char *type)
{
    return set_type_state(db, type, false);
}

bool ksu_typeattribute(struct policydb *db, const char *type, const char *attr)
{
    return add_typeattribute(db, type, attr);
}

bool ksu_exists(struct policydb *db, const char *type)
{
    return symtab_search(&db->p_types, type) != NULL;
}

// Access vector rules
bool ksu_allow(struct policydb *db, const char *src, const char *tgt,
               const char *cls, const char *perm)
{
    return add_rule(db, src, tgt, cls, perm, AVTAB_ALLOWED, false);
}

bool ksu_deny(struct policydb *db, const char *src, const char *tgt,
              const char *cls, const char *perm)
{
    return add_rule(db, src, tgt, cls, perm, AVTAB_ALLOWED, true);
}

bool ksu_auditallow(struct policydb *db, const char *src, const char *tgt,
                    const char *cls, const char *perm)
{
    return add_rule(db, src, tgt, cls, perm, AVTAB_AUDITALLOW, false);
}
bool ksu_dontaudit(struct policydb *db, const char *src, const char *tgt,
                   const char *cls, const char *perm)
{
    return add_rule(db, src, tgt, cls, perm, AVTAB_AUDITDENY, true);
}

// Extended permissions access vector rules
bool ksu_allowxperm(struct policydb *db, const char *src, const char *tgt,
                    const char *cls, const char *range)
{
    return add_xperm_rule(db, src, tgt, cls, range, AVTAB_XPERMS_ALLOWED,
                          false);
}

bool ksu_auditallowxperm(struct policydb *db, const char *src, const char *tgt,
                         const char *cls, const char *range)
{
    return add_xperm_rule(db, src, tgt, cls, range, AVTAB_XPERMS_AUDITALLOW,
                          false);
}

bool ksu_dontauditxperm(struct policydb *db, const char *src, const char *tgt,
                        const char *cls, const char *range)
{
    return add_xperm_rule(db, src, tgt, cls, range, AVTAB_XPERMS_DONTAUDIT,
                          false);
}

// Type rules
bool ksu_type_transition(struct policydb *db, const char *src, const char *tgt,
                         const char *cls, const char *def, const char *obj)
{
    if (obj) {
        return add_filename_trans(db, src, tgt, cls, def, obj);
    } else {
        return add_type_rule(db, src, tgt, cls, def, AVTAB_TRANSITION);
    }
}

bool ksu_type_change(struct policydb *db, const char *src, const char *tgt,
                     const char *cls, const char *def)
{
    return add_type_rule(db, src, tgt, cls, def, AVTAB_CHANGE);
}

bool ksu_type_member(struct policydb *db, const char *src, const char *tgt,
                     const char *cls, const char *def)
{
    return add_type_rule(db, src, tgt, cls, def, AVTAB_MEMBER);
}

// File system labeling
bool ksu_genfscon(struct policydb *db, const char *fs_name, const char *path,
                  const char *ctx)
{
    return add_genfscon(db, fs_name, path, ctx);
}

```

`kernel/selinux/sepolicy.h`:

```h
#ifndef __KSU_H_SEPOLICY
#define __KSU_H_SEPOLICY

#include <linux/types.h>

#include "ss/policydb.h"

// Operation on types
bool ksu_type(struct policydb *db, const char *name, const char *attr);
bool ksu_attribute(struct policydb *db, const char *name);
bool ksu_permissive(struct policydb *db, const char *type);
bool ksu_enforce(struct policydb *db, const char *type);
bool ksu_typeattribute(struct policydb *db, const char *type, const char *attr);
bool ksu_exists(struct policydb *db, const char *type);

// Access vector rules
bool ksu_allow(struct policydb *db, const char *src, const char *tgt,
               const char *cls, const char *perm);
bool ksu_deny(struct policydb *db, const char *src, const char *tgt,
              const char *cls, const char *perm);
bool ksu_auditallow(struct policydb *db, const char *src, const char *tgt,
                    const char *cls, const char *perm);
bool ksu_dontaudit(struct policydb *db, const char *src, const char *tgt,
                   const char *cls, const char *perm);

// Extended permissions access vector rules
bool ksu_allowxperm(struct policydb *db, const char *src, const char *tgt,
                    const char *cls, const char *range);
bool ksu_auditallowxperm(struct policydb *db, const char *src, const char *tgt,
                         const char *cls, const char *range);
bool ksu_dontauditxperm(struct policydb *db, const char *src, const char *tgt,
                        const char *cls, const char *range);

// Type rules
bool ksu_type_transition(struct policydb *db, const char *src, const char *tgt,
                         const char *cls, const char *def, const char *obj);
bool ksu_type_change(struct policydb *db, const char *src, const char *tgt,
                     const char *cls, const char *def);
bool ksu_type_member(struct policydb *db, const char *src, const char *tgt,
                     const char *cls, const char *def);

// File system labeling
bool ksu_genfscon(struct policydb *db, const char *fs_name, const char *path,
                  const char *ctx);

#endif

```

`kernel/setuid_hook.c`:

```c
#include <linux/compiler.h>
#include <linux/version.h>
#include <linux/slab.h>
#include <linux/task_work.h>
#include <linux/thread_info.h>
#include <linux/seccomp.h>
#include <linux/printk.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/string.h>
#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/uidgid.h>

#include "allowlist.h"
#include "setuid_hook.h"
#include "klog.h" // IWYU pragma: keep
#include "manager.h"
#include "selinux/selinux.h"
#include "seccomp_cache.h"
#include "supercalls.h"
#include "syscall_hook_manager.h"
#include "kernel_umount.h"

static void ksu_install_manager_fd_tw_func(struct callback_head *cb)
{
    ksu_install_fd();
    kfree(cb);
}

int ksu_handle_setresuid(uid_t ruid, uid_t euid, uid_t suid)
{
    // we rely on the fact that zygote always call setresuid(3) with same uids
    uid_t new_uid = ruid;
    uid_t old_uid = current_uid().val;

    pr_info("handle_setresuid from %d to %d\n", old_uid, new_uid);

    if (likely(ksu_is_manager_appid_valid()) &&
        unlikely(ksu_get_manager_appid() == new_uid % PER_USER_RANGE)) {
        spin_lock_irq(&current->sighand->siglock);
        ksu_seccomp_allow_cache(current->seccomp.filter, __NR_reboot);
        ksu_set_task_tracepoint_flag(current);
        spin_unlock_irq(&current->sighand->siglock);

        pr_info("install fd for manager: %d\n", new_uid);
        struct callback_head *cb = kzalloc(sizeof(*cb), GFP_ATOMIC);
        if (!cb)
            return 0;
        cb->func = ksu_install_manager_fd_tw_func;
        if (task_work_add(current, cb, TWA_RESUME)) {
            kfree(cb);
            pr_warn("install manager fd add task_work failed\n");
        }
        return 0;
    }

    if (ksu_is_allow_uid_for_current(new_uid)) {
        if (current->seccomp.mode == SECCOMP_MODE_FILTER &&
            current->seccomp.filter) {
            spin_lock_irq(&current->sighand->siglock);
            ksu_seccomp_allow_cache(current->seccomp.filter, __NR_reboot);
            spin_unlock_irq(&current->sighand->siglock);
        }
        ksu_set_task_tracepoint_flag(current);
    } else {
        ksu_clear_task_tracepoint_flag_if_needed(current);
    }

    // Handle kernel umount
    ksu_handle_umount(old_uid, new_uid);

    return 0;
}

void ksu_setuid_hook_init(void)
{
    ksu_kernel_umount_init();
}

void ksu_setuid_hook_exit(void)
{
    pr_info("ksu_core_exit\n");
    ksu_kernel_umount_exit();
}

```

`kernel/setuid_hook.h`:

```h
#ifndef __KSU_H_KSU_CORE
#define __KSU_H_KSU_CORE

#include <linux/init.h>
#include <linux/types.h>

void ksu_setuid_hook_init(void);
void ksu_setuid_hook_exit(void);

// Handler functions for hook_manager
int ksu_handle_setresuid(uid_t ruid, uid_t euid, uid_t suid);

#endif

```

`kernel/setup.sh`:

```sh
#!/bin/sh
set -eu

GKI_ROOT=$(pwd)

display_usage() {
    echo "Usage: $0 [--cleanup | <commit-or-tag>]"
    echo "  --cleanup:              Cleans up previous modifications made by the script."
    echo "  <commit-or-tag>:        Sets up or updates the KernelSU to specified tag or commit."
    echo "  -h, --help:             Displays this usage information."
    echo "  (no args):              Sets up or updates the KernelSU environment to the latest tagged version."
}

initialize_variables() {
    if test -d "$GKI_ROOT/common/drivers"; then
         DRIVER_DIR="$GKI_ROOT/common/drivers"
    elif test -d "$GKI_ROOT/drivers"; then
         DRIVER_DIR="$GKI_ROOT/drivers"
    else
         echo '[ERROR] "drivers/" directory not found.'
         exit 127
    fi

    DRIVER_MAKEFILE=$DRIVER_DIR/Makefile
    DRIVER_KCONFIG=$DRIVER_DIR/Kconfig
}

# Reverts modifications made by this script
perform_cleanup() {
    echo "[+] Cleaning up..."
    [ -L "$DRIVER_DIR/kernelsu" ] && rm "$DRIVER_DIR/kernelsu" && echo "[-] Symlink removed."
    grep -q "kernelsu" "$DRIVER_MAKEFILE" && sed -i '/kernelsu/d' "$DRIVER_MAKEFILE" && echo "[-] Makefile reverted."
    grep -q "drivers/kernelsu/Kconfig" "$DRIVER_KCONFIG" && sed -i '/drivers\/kernelsu\/Kconfig/d' "$DRIVER_KCONFIG" && echo "[-] Kconfig reverted."
    if [ -d "$GKI_ROOT/KernelSU" ]; then
        rm -rf "$GKI_ROOT/KernelSU" && echo "[-] KernelSU directory deleted."
    fi
}

# Sets up or update KernelSU environment
setup_kernelsu() {
    echo "[+] Setting up KernelSU..."
    test -d "$GKI_ROOT/KernelSU" || git clone https://github.com/tiann/KernelSU && echo "[+] Repository cloned."
    cd "$GKI_ROOT/KernelSU"
    git stash && echo "[-] Stashed current changes."
    if [ "$(git status | grep -Po 'v\d+(\.\d+)*' | head -n1)" ]; then
        git checkout main && echo "[-] Switched to main branch."
    fi
    git pull && echo "[+] Repository updated."
    if [ -z "${1-}" ]; then
        git checkout "$(git describe --abbrev=0 --tags)" && echo "[-] Checked out latest tag."
    else
        git checkout "$1" && echo "[-] Checked out $1." || echo "[-] Checkout default branch"
    fi
    cd "$DRIVER_DIR"
    ln -sf "$(realpath --relative-to="$DRIVER_DIR" "$GKI_ROOT/KernelSU/kernel")" "kernelsu" && echo "[+] Symlink created."

    # Add entries in Makefile and Kconfig if not already existing
    grep -q "kernelsu" "$DRIVER_MAKEFILE" || printf "\nobj-\$(CONFIG_KSU) += kernelsu/\n" >> "$DRIVER_MAKEFILE" && echo "[+] Modified Makefile."
    grep -q "source \"drivers/kernelsu/Kconfig\"" "$DRIVER_KCONFIG" || sed -i "/endmenu/i\source \"drivers/kernelsu/Kconfig\"" "$DRIVER_KCONFIG" && echo "[+] Modified Kconfig."
    echo '[+] Done.'
}

# Process command-line arguments
if [ "$#" -eq 0 ]; then
    initialize_variables
    setup_kernelsu
elif [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    display_usage
elif [ "$1" = "--cleanup" ]; then
    initialize_variables
    perform_cleanup
else
    initialize_variables
    setup_kernelsu "$@"
fi

```

`kernel/su_mount_ns.c`:

```c
#include <linux/dcache.h>
#include <linux/errno.h>
#include <linux/fdtable.h>
#include <linux/file.h>
#include <linux/fs.h>
#include <linux/fs_struct.h>
#include <linux/limits.h>
#include <linux/namei.h>
#include <linux/proc_ns.h>
#include <linux/pid.h>
#include <linux/sched/task.h>
#include <linux/slab.h>
#include <linux/syscalls.h>
#include <linux/task_work.h>
#include <linux/version.h>
#include <uapi/linux/mount.h>

#include "arch.h"
#include "klog.h" // IWYU pragma: keep
#include "ksu.h"
#include "su_mount_ns.h"

extern int path_mount(const char *dev_name, struct path *path,
                      const char *type_page, unsigned long flags,
                      void *data_page);

#if defined(__aarch64__)
extern long __arm64_sys_setns(const struct pt_regs *regs);
#elif defined(__x86_64__)
extern long __x64_sys_setns(const struct pt_regs *regs);
#endif

static long ksu_sys_setns(int fd, int flags)
{
    struct pt_regs regs;
    memset(&regs, 0, sizeof(regs));

    PT_REGS_PARM1(&regs) = fd;
    PT_REGS_PARM2(&regs) = flags;

#if defined(__aarch64__)
    return __arm64_sys_setns(&regs);
#elif defined(__x86_64__)
    return __x64_sys_setns(&regs);
#else
#error "Unsupported arch"
#endif
}

// global mode , need CAP_SYS_ADMIN and CAP_SYS_CHROOT to perform setns
static void ksu_mnt_ns_global(void)
{
    // save current working directory as absolute path before setns
    char *pwd_path = NULL;
    char *pwd_buf = kmalloc(PATH_MAX, GFP_KERNEL);
    if (!pwd_buf) {
        pr_warn("no mem for pwd buffer, skip restore pwd!!\n");
        goto try_setns;
    }

    struct path saved_pwd;
    get_fs_pwd(current->fs, &saved_pwd);
    pwd_path = d_path(&saved_pwd, pwd_buf, PATH_MAX);
    path_put(&saved_pwd);

    if (IS_ERR(pwd_path)) {
        if (PTR_ERR(pwd_path) == -ENAMETOOLONG) {
            pr_warn("absolute pwd longer than: %d, skip restore pwd!!\n",
                    PATH_MAX);
        } else {
            pr_warn("get absolute pwd failed: %ld\n", PTR_ERR(pwd_path));
        }
        pwd_path = NULL;
    }

try_setns:

    rcu_read_lock();
    // &init_task is not init, but swapper/idle, which forks the init process
    // so we need find init process
    struct pid *pid_struct = find_pid_ns(1, &init_pid_ns);
    if (unlikely(!pid_struct)) {
        rcu_read_unlock();
        pr_warn("failed to find pid_struct for PID 1\n");
        goto out;
    }

    struct task_struct *pid1_task = get_pid_task(pid_struct, PIDTYPE_PID);
    rcu_read_unlock();
    if (unlikely(!pid1_task)) {
        pr_warn("failed to get task_struct for PID 1\n");
        goto out;
    }
    struct path ns_path;
    long ret = ns_get_path(&ns_path, pid1_task, &mntns_operations);
    put_task_struct(pid1_task);
    if (ret) {
        pr_warn("failed get path for init mount namespace: %ld\n", ret);
        goto out;
    }
    struct file *ns_file = dentry_open(&ns_path, O_RDONLY, ksu_cred);

    path_put(&ns_path);
    if (IS_ERR(ns_file)) {
        pr_warn("failed open file for init mount namespace: %ld\n",
                PTR_ERR(ns_file));
        goto out;
    }

    int fd = get_unused_fd_flags(O_CLOEXEC);
    if (fd < 0) {
        pr_warn("failed to get an unused fd: %d\n", fd);
        fput(ns_file);
        goto out;
    }

    fd_install(fd, ns_file);
    ret = ksu_sys_setns(fd, CLONE_NEWNS);

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)
    ksys_close(fd);
#else
    close_fd(fd);
#endif

    if (ret) {
        pr_warn("call setns failed: %ld\n", ret);
        goto out;
    }
    // try to restore working directory using absolute path after setns
    if (pwd_path) {
        struct path new_pwd;
        int err = kern_path(pwd_path, 0, &new_pwd);
        if (!err) {
            set_fs_pwd(current->fs, &new_pwd);
            path_put(&new_pwd);
        } else {
            pr_warn("restore pwd failed: %d, path: %s\n", err, pwd_path);
        }
    }
out:
    kfree(pwd_buf);
}

// individual mode , need CAP_SYS_ADMIN to perform unshare and remount
static void ksu_mnt_ns_individual(void)
{
    long ret = ksys_unshare(CLONE_NEWNS);
    if (ret) {
        pr_warn("call ksys_unshare failed: %ld\n", ret);
        return;
    }

    // make root mount private
    struct path root_path;
    get_fs_root(current->fs, &root_path);
    int pm_ret = path_mount(NULL, &root_path, NULL, MS_PRIVATE | MS_REC, NULL);
    path_put(&root_path);

    if (pm_ret < 0) {
        pr_err("failed to make root private, err: %d\n", pm_ret);
    }
}

static void ksu_setup_mount_ns_tw_func(struct callback_head *cb)
{
    struct ksu_mns_tw *tw = container_of(cb, struct ksu_mns_tw, cb);
    const struct cred *old_cred = override_creds(ksu_cred);
    if (tw->ns_mode == KSU_NS_GLOBAL) {
        ksu_mnt_ns_global();
    } else {
        ksu_mnt_ns_individual();
    }
    revert_creds(old_cred);
    kfree(tw);
}

void setup_mount_ns(int32_t ns_mode)
{
    // inherit mode
    if (ns_mode == KSU_NS_INHERITED) {
        // do nothing
        return;
    }

    if (ns_mode != KSU_NS_GLOBAL && ns_mode != KSU_NS_INDIVIDUAL) {
        pr_warn("pid: %d ,unknown mount namespace mode: %d\n", current->pid,
                ns_mode);
        return;
    }

    if (!ksu_cred) {
        pr_err("no ksu cred! skip mnt_ns magic for pid: %d.\n", current->pid);
        return;
    }

    struct ksu_mns_tw *tw = kzalloc(sizeof(*tw), GFP_ATOMIC);
    if (!tw) {
        pr_err("no mem for tw! skip mnt_ns magic for pid: %d.\n", current->pid);
        return;
    }
    tw->cb.func = ksu_setup_mount_ns_tw_func;
    tw->ns_mode = ns_mode;
    if (task_work_add(current, &tw->cb, TWA_RESUME)) {
        kfree(tw);
        pr_err("add task work failed! skip mnt_ns magic for pid: %d.\n",
               current->pid);
    }
}

```

`kernel/su_mount_ns.h`:

```h
#ifndef __KSU_SU_MOUNT_NS_H
#define __KSU_SU_MOUNT_NS_H

#define KSU_NS_INHERITED 0
#define KSU_NS_GLOBAL 1
#define KSU_NS_INDIVIDUAL 2

struct ksu_mns_tw {
    struct callback_head cb;
    int32_t ns_mode;
};

void setup_mount_ns(int32_t ns_mode);

#endif

```

`kernel/sucompat.c`:

```c
#include <linux/compiler_types.h>
#include <linux/preempt.h>
#include <linux/printk.h>
#include <linux/mm.h>
#include <linux/pgtable.h>
#include <linux/uaccess.h>
#include <asm/current.h>
#include <linux/cred.h>
#include <linux/fs.h>
#include <linux/types.h>
#include <linux/version.h>
#include <linux/sched/task_stack.h>
#include <linux/ptrace.h>

#include "allowlist.h"
#include "feature.h"
#include "klog.h" // IWYU pragma: keep
#include "ksud.h"
#include "sucompat.h"
#include "app_profile.h"
#include "util.h"

#define SU_PATH "/system/bin/su"
#define SH_PATH "/system/bin/sh"

bool ksu_su_compat_enabled __read_mostly = true;

static int su_compat_feature_get(u64 *value)
{
    *value = ksu_su_compat_enabled ? 1 : 0;
    return 0;
}

static int su_compat_feature_set(u64 value)
{
    bool enable = value != 0;
    ksu_su_compat_enabled = enable;
    pr_info("su_compat: set to %d\n", enable);
    return 0;
}

static const struct ksu_feature_handler su_compat_handler = {
    .feature_id = KSU_FEATURE_SU_COMPAT,
    .name = "su_compat",
    .get_handler = su_compat_feature_get,
    .set_handler = su_compat_feature_set,
};

static void __user *userspace_stack_buffer(const void *d, size_t len)
{
    // To avoid having to mmap a page in userspace, just write below the stack
    // pointer.
    char __user *p = (void __user *)current_user_stack_pointer() - len;

    return copy_to_user(p, d, len) ? NULL : p;
}

static char __user *sh_user_path(void)
{
    static const char sh_path[] = "/system/bin/sh";

    return userspace_stack_buffer(sh_path, sizeof(sh_path));
}

static char __user *ksud_user_path(void)
{
    static const char ksud_path[] = KSUD_PATH;

    return userspace_stack_buffer(ksud_path, sizeof(ksud_path));
}

int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
                         int *__unused_flags)
{
    const char su[] = SU_PATH;

    if (!ksu_is_allow_uid_for_current(current_uid().val)) {
        return 0;
    }

    char path[sizeof(su) + 1];
    memset(path, 0, sizeof(path));
    strncpy_from_user_nofault(path, *filename_user, sizeof(path));

    if (unlikely(!memcmp(path, su, sizeof(su)))) {
        pr_info("faccessat su->sh!\n");
        *filename_user = sh_user_path();
    }

    return 0;
}

int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
{
    // const char sh[] = SH_PATH;
    const char su[] = SU_PATH;

    if (!ksu_is_allow_uid_for_current(current_uid().val)) {
        return 0;
    }

    if (unlikely(!filename_user)) {
        return 0;
    }

    char path[sizeof(su) + 1];
    memset(path, 0, sizeof(path));
    strncpy_from_user_nofault(path, *filename_user, sizeof(path));

    if (unlikely(!memcmp(path, su, sizeof(su)))) {
        pr_info("newfstatat su->sh!\n");
        *filename_user = sh_user_path();
    }

    return 0;
}

int ksu_handle_execve_sucompat(const char __user **filename_user,
                               void *__never_use_argv, void *__never_use_envp,
                               int *__never_use_flags)
{
    const char su[] = SU_PATH;
    const char __user *fn;
    char path[sizeof(su) + 1];
    long ret;
    unsigned long addr;

    if (unlikely(!filename_user))
        return 0;

    if (!ksu_is_allow_uid_for_current(current_uid().val))
        return 0;

    addr = untagged_addr((unsigned long)*filename_user);
    fn = (const char __user *)addr;
    memset(path, 0, sizeof(path));
    ret = strncpy_from_user_nofault(path, fn, sizeof(path));

    if (ret < 0 && try_set_access_flag(addr)) {
        ret = strncpy_from_user_nofault(path, fn, sizeof(path));
    }

    if (ret < 0 && preempt_count()) {
        /* This is crazy, but we know what we are doing:
         * Temporarily exit atomic context to handle page faults, then restore it */
        pr_info("Access filename failed, try rescue..\n");
        preempt_enable_no_resched_notrace();
        ret = strncpy_from_user(path, fn, sizeof(path));
        preempt_disable_notrace();
    }

    if (ret < 0) {
        pr_warn("Access filename when execve failed: %ld", ret);
        return 0;
    }

    if (likely(memcmp(path, su, sizeof(su))))
        return 0;

    pr_info("sys_execve su found\n");
    *filename_user = ksud_user_path();

    escape_with_root_profile();

    return 0;
}

// sucompat: permitted process can execute 'su' to gain root access.
void ksu_sucompat_init()
{
    if (ksu_register_feature_handler(&su_compat_handler)) {
        pr_err("Failed to register su_compat feature handler\n");
    }
}

void ksu_sucompat_exit()
{
    ksu_unregister_feature_handler(KSU_FEATURE_SU_COMPAT);
}

```

`kernel/sucompat.h`:

```h
#ifndef __KSU_H_SUCOMPAT
#define __KSU_H_SUCOMPAT
#include <linux/types.h>

extern bool ksu_su_compat_enabled;

void ksu_sucompat_init(void);
void ksu_sucompat_exit(void);

// Handler functions exported for hook_manager
int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
                         int *__unused_flags);
int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
int ksu_handle_execve_sucompat(const char __user **filename_user,
                               void *__never_use_argv, void *__never_use_envp,
                               int *__never_use_flags);

#endif
```

`kernel/supercalls.c`:

```c
#include <linux/anon_inodes.h>
#include <linux/capability.h>
#include <linux/cred.h>
#include <linux/err.h>
#include <linux/fdtable.h>
#include <linux/file.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/kprobes.h>
#include <linux/syscalls.h>
#include <linux/task_work.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#include "supercalls.h"
#include "arch.h"
#include "allowlist.h"
#include "feature.h"
#include "klog.h" // IWYU pragma: keep
#include "ksu.h"
#include "ksud.h"
#include "kernel_umount.h"
#include "manager.h"
#include "selinux/selinux.h"
#include "file_wrapper.h"
#include "syscall_hook_manager.h"

// Permission check functions
bool only_manager(void)
{
    return is_manager();
}

bool only_root(void)
{
    return current_uid().val == 0;
}

bool manager_or_root(void)
{
    return current_uid().val == 0 || is_manager();
}

bool always_allow(void)
{
    return true; // No permission check
}

bool allowed_for_su(void)
{
    bool is_allowed =
        is_manager() || ksu_is_allow_uid_for_current(current_uid().val);
    return is_allowed;
}

static int do_grant_root(void __user *arg)
{
    // we already check uid above on allowed_for_su()

    pr_info("allow root for: %d\n", current_uid().val);
    escape_with_root_profile();

    return 0;
}

static int do_get_info(void __user *arg)
{
    struct ksu_get_info_cmd cmd = { .version = KERNEL_SU_VERSION, .flags = 0 };

#ifdef MODULE
    cmd.flags |= 0x1;
#endif

    if (is_manager()) {
        cmd.flags |= 0x2;
    }
    cmd.features = KSU_FEATURE_MAX;

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("get_version: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_report_event(void __user *arg)
{
    struct ksu_report_event_cmd cmd;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    switch (cmd.event) {
    case EVENT_POST_FS_DATA: {
        static bool post_fs_data_lock = false;
        if (!post_fs_data_lock) {
            post_fs_data_lock = true;
            pr_info("post-fs-data triggered\n");
            on_post_fs_data();
        }
        break;
    }
    case EVENT_BOOT_COMPLETED: {
        static bool boot_complete_lock = false;
        if (!boot_complete_lock) {
            boot_complete_lock = true;
            pr_info("boot_complete triggered\n");
            on_boot_completed();
        }
        break;
    }
    case EVENT_MODULE_MOUNTED: {
        pr_info("module mounted!\n");
        on_module_mounted();
        break;
    }
    default:
        break;
    }

    return 0;
}

static int do_set_sepolicy(void __user *arg)
{
    struct ksu_set_sepolicy_cmd cmd;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    return handle_sepolicy(cmd.cmd, (void __user *)cmd.arg);
}

static int do_check_safemode(void __user *arg)
{
    struct ksu_check_safemode_cmd cmd;

    cmd.in_safe_mode = ksu_is_safe_mode();

    if (cmd.in_safe_mode) {
        pr_warn("safemode enabled!\n");
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("check_safemode: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_new_get_allow_list_common(void __user *arg, bool allow)
{
    struct ksu_new_get_allow_list_cmd cmd;
    int *arr = NULL;
    int err = 0;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    if (cmd.count) {
        arr = kmalloc(sizeof(int) * cmd.count, GFP_KERNEL);
        if (!arr) {
            return -ENOMEM;
        }
    }

    bool success =
        ksu_get_allow_list(arr, cmd.count, &cmd.count, &cmd.total_count, allow);

    if (!success) {
        err = -EFAULT;
        goto out;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("new_get_allow_list: copy_to_user count failed\n");
        err = -EFAULT;
        goto out;
    }

    if (cmd.count &&
        copy_to_user(&((struct ksu_new_get_allow_list_cmd *)arg)->uids, arr,
                     sizeof(int) * cmd.count)) {
        pr_err("new_get_allow_list: copy_to_user uids failed\n");
        err = -EFAULT;
    }

out:
    if (arr) {
        kfree(arr);
    }
    return err;
}

static int do_new_get_deny_list(void __user *arg)
{
    return do_new_get_allow_list_common(arg, false);
}

static int do_new_get_allow_list(void __user *arg)
{
    return do_new_get_allow_list_common(arg, true);
}

static int do_get_allow_list_common(void __user *arg, bool allow)
{
    int *arr = NULL;
    int err = 0;
    u16 count;
    u32 out_count;
    static const u16 kSize = 128;

    arr = kmalloc(sizeof(int) * kSize, GFP_KERNEL);
    if (!arr) {
        return -ENOMEM;
    }

    bool success = ksu_get_allow_list(arr, kSize, &count, NULL, allow);

    if (!success) {
        err = -EFAULT;
        goto out;
    }

    out_count = count;

    if (copy_to_user(arg + offsetof(struct ksu_get_allow_list_cmd, count),
                     &out_count, sizeof(u32))) {
        pr_err("get_allow_list: copy_to_user count failed\n");
        err = -EFAULT;
        goto out;
    }

    if (copy_to_user(arg, arr, sizeof(u32) * count)) {
        pr_err("get_allow_list: copy_to_user uids failed\n");
        err = -EFAULT;
    }

out:
    if (arr) {
        kfree(arr);
    }
    return err;
}

static int do_get_deny_list(void __user *arg)
{
    return do_get_allow_list_common(arg, false);
}

static int do_get_allow_list(void __user *arg)
{
    return do_get_allow_list_common(arg, true);
}

static int do_uid_granted_root(void __user *arg)
{
    struct ksu_uid_granted_root_cmd cmd;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    cmd.granted = ksu_is_allow_uid_for_current(cmd.uid);

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("uid_granted_root: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_uid_should_umount(void __user *arg)
{
    struct ksu_uid_should_umount_cmd cmd;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    cmd.should_umount = ksu_uid_should_umount(cmd.uid);

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("uid_should_umount: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_get_manager_appid(void __user *arg)
{
    struct ksu_get_manager_appid_cmd cmd;

    cmd.appid = ksu_get_manager_appid();

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("get_manager_appid: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_get_app_profile(void __user *arg)
{
    struct ksu_get_app_profile_cmd cmd;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        pr_err("get_app_profile: copy_from_user failed\n");
        return -EFAULT;
    }

    if (!ksu_get_app_profile(&cmd.profile)) {
        return -ENOENT;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("get_app_profile: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_set_app_profile(void __user *arg)
{
    struct ksu_set_app_profile_cmd cmd;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        pr_err("set_app_profile: copy_from_user failed\n");
        return -EFAULT;
    }

    ret = ksu_set_app_profile(&cmd.profile);
    if (!ret) {
        ksu_persistent_allow_list();
        ksu_mark_running_process();
    }
    return ret;
}

static int do_get_feature(void __user *arg)
{
    struct ksu_get_feature_cmd cmd;
    bool supported;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        pr_err("get_feature: copy_from_user failed\n");
        return -EFAULT;
    }

    ret = ksu_get_feature(cmd.feature_id, &cmd.value, &supported);
    cmd.supported = supported ? 1 : 0;

    if (ret && supported) {
        pr_err("get_feature: failed for feature %u: %d\n", cmd.feature_id, ret);
        return ret;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("get_feature: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_set_feature(void __user *arg)
{
    struct ksu_set_feature_cmd cmd;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        pr_err("set_feature: copy_from_user failed\n");
        return -EFAULT;
    }

    ret = ksu_set_feature(cmd.feature_id, cmd.value);
    if (ret) {
        pr_err("set_feature: failed for feature %u: %d\n", cmd.feature_id, ret);
        return ret;
    }

    return 0;
}

static int do_get_wrapper_fd(void __user *arg)
{
    if (!ksu_file_sid) {
        return -EINVAL;
    }

    struct ksu_get_wrapper_fd_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        pr_err("get_wrapper_fd: copy_from_user failed\n");
        return -EFAULT;
    }

    return ksu_install_file_wrapper(cmd.fd);
}

static int do_manage_mark(void __user *arg)
{
    struct ksu_manage_mark_cmd cmd;
    int ret = 0;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        pr_err("manage_mark: copy_from_user failed\n");
        return -EFAULT;
    }

    switch (cmd.operation) {
    case KSU_MARK_GET: {
        // Get task mark status
        ret = ksu_get_task_mark(cmd.pid);
        if (ret < 0) {
            pr_err("manage_mark: get failed for pid %d: %d\n", cmd.pid, ret);
            return ret;
        }
        cmd.result = (u32)ret;
        break;
    }
    case KSU_MARK_MARK: {
        if (cmd.pid == 0) {
            ksu_mark_all_process();
        } else {
            ret = ksu_set_task_mark(cmd.pid, true);
            if (ret < 0) {
                pr_err("manage_mark: set_mark failed for pid %d: %d\n", cmd.pid,
                       ret);
                return ret;
            }
        }
        break;
    }
    case KSU_MARK_UNMARK: {
        if (cmd.pid == 0) {
            ksu_unmark_all_process();
        } else {
            ret = ksu_set_task_mark(cmd.pid, false);
            if (ret < 0) {
                pr_err("manage_mark: set_unmark failed for pid %d: %d\n",
                       cmd.pid, ret);
                return ret;
            }
        }
        break;
    }
    case KSU_MARK_REFRESH: {
        ksu_mark_running_process();
        pr_info("manage_mark: refreshed running processes\n");
        break;
    }
    default: {
        pr_err("manage_mark: invalid operation %u\n", cmd.operation);
        return -EINVAL;
    }
    }
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        pr_err("manage_mark: copy_to_user failed\n");
        return -EFAULT;
    }

    return 0;
}

static int do_nuke_ext4_sysfs(void __user *arg)
{
    struct ksu_nuke_ext4_sysfs_cmd cmd;
    char mnt[256];
    long ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd)))
        return -EFAULT;

    if (!cmd.arg)
        return -EINVAL;

    memset(mnt, 0, sizeof(mnt));

    ret = strncpy_from_user(mnt, cmd.arg, sizeof(mnt));
    if (ret < 0) {
        pr_err("nuke ext4 copy mnt failed: %ld\\n", ret);
        return -EFAULT; // 或者 return ret;
    }

    if (ret == sizeof(mnt)) {
        pr_err("nuke ext4 mnt path too long\\n");
        return -ENAMETOOLONG;
    }

    pr_info("do_nuke_ext4_sysfs: %s\n", mnt);

    return nuke_ext4_sysfs(mnt);
}

struct list_head mount_list = LIST_HEAD_INIT(mount_list);
DECLARE_RWSEM(mount_list_lock);

static int add_try_umount(void __user *arg)
{
    struct mount_entry *new_entry, *entry, *tmp;
    struct ksu_add_try_umount_cmd cmd;
    char buf[256] = { 0 };

    if (copy_from_user(&cmd, arg, sizeof cmd))
        return -EFAULT;

    switch (cmd.mode) {
    case KSU_UMOUNT_WIPE: {
        struct mount_entry *entry, *tmp;
        down_write(&mount_list_lock);
        list_for_each_entry_safe (entry, tmp, &mount_list, list) {
            pr_info("wipe_umount_list: removing entry: %s\n",
                    entry->umountable);
            list_del(&entry->list);
            kfree(entry->umountable);
            kfree(entry);
        }
        up_write(&mount_list_lock);

        return 0;
    }

    case KSU_UMOUNT_ADD: {
        long len = strncpy_from_user(buf, (const char __user *)cmd.arg, 256);
        if (len <= 0)
            return -EFAULT;

        buf[sizeof(buf) - 1] = '\0';

        new_entry = kzalloc(sizeof(*new_entry), GFP_KERNEL);
        if (!new_entry)
            return -ENOMEM;

        new_entry->umountable = kstrdup(buf, GFP_KERNEL);
        if (!new_entry->umountable) {
            kfree(new_entry);
            return -ENOMEM;
        }

        down_write(&mount_list_lock);

        // disallow dupes
        // if this gets too many, we can consider moving this whole task to a kthread
        list_for_each_entry (entry, &mount_list, list) {
            if (!strcmp(entry->umountable, buf)) {
                pr_info("cmd_add_try_umount: %s is already here!\n", buf);
                up_write(&mount_list_lock);
                kfree(new_entry->umountable);
                kfree(new_entry);
                return -EEXIST;
            }
        }

        // now check flags and add
        // this also serves as a null check
        if (cmd.flags)
            new_entry->flags = cmd.flags;
        else
            new_entry->flags = 0;

        // debug
        list_add(&new_entry->list, &mount_list);
        up_write(&mount_list_lock);
        pr_info("cmd_add_try_umount: %s added!\n", buf);

        return 0;
    }

    // this is just strcmp'd wipe anyway
    case KSU_UMOUNT_DEL: {
        long len = strncpy_from_user(buf, (const char __user *)cmd.arg,
                                     sizeof(buf) - 1);
        if (len <= 0)
            return -EFAULT;

        buf[sizeof(buf) - 1] = '\0';

        down_write(&mount_list_lock);
        list_for_each_entry_safe (entry, tmp, &mount_list, list) {
            if (!strcmp(entry->umountable, buf)) {
                pr_info("cmd_add_try_umount: entry removed: %s\n",
                        entry->umountable);
                list_del(&entry->list);
                kfree(entry->umountable);
                kfree(entry);
            }
        }
        up_write(&mount_list_lock);

        return 0;
    }

    default: {
        pr_err("cmd_add_try_umount: invalid operation %u\n", cmd.mode);
        return -EINVAL;
    }

    } // switch(cmd.mode)

    return 0;
}

// IOCTL handlers mapping table
static const struct ksu_ioctl_cmd_map ksu_ioctl_handlers[] = {
    { .cmd = KSU_IOCTL_GRANT_ROOT,
      .name = "GRANT_ROOT",
      .handler = do_grant_root,
      .perm_check = allowed_for_su },
    { .cmd = KSU_IOCTL_GET_INFO,
      .name = "GET_INFO",
      .handler = do_get_info,
      .perm_check = always_allow },
    { .cmd = KSU_IOCTL_REPORT_EVENT,
      .name = "REPORT_EVENT",
      .handler = do_report_event,
      .perm_check = only_root },
    { .cmd = KSU_IOCTL_SET_SEPOLICY,
      .name = "SET_SEPOLICY",
      .handler = do_set_sepolicy,
      .perm_check = only_root },
    { .cmd = KSU_IOCTL_CHECK_SAFEMODE,
      .name = "CHECK_SAFEMODE",
      .handler = do_check_safemode,
      .perm_check = always_allow },
    { .cmd = KSU_IOCTL_GET_ALLOW_LIST,
      .name = "GET_ALLOW_LIST",
      .handler = do_get_allow_list,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_GET_DENY_LIST,
      .name = "GET_DENY_LIST",
      .handler = do_get_deny_list,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_NEW_GET_ALLOW_LIST,
      .name = "NEW_GET_ALLOW_LIST",
      .handler = do_new_get_allow_list,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_NEW_GET_DENY_LIST,
      .name = "NEW_GET_DENY_LIST",
      .handler = do_new_get_deny_list,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_UID_GRANTED_ROOT,
      .name = "UID_GRANTED_ROOT",
      .handler = do_uid_granted_root,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_UID_SHOULD_UMOUNT,
      .name = "UID_SHOULD_UMOUNT",
      .handler = do_uid_should_umount,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_GET_MANAGER_APPID,
      .name = "GET_MANAGER_APPID",
      .handler = do_get_manager_appid,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_GET_APP_PROFILE,
      .name = "GET_APP_PROFILE",
      .handler = do_get_app_profile,
      .perm_check = only_manager },
    { .cmd = KSU_IOCTL_SET_APP_PROFILE,
      .name = "SET_APP_PROFILE",
      .handler = do_set_app_profile,
      .perm_check = only_manager },
    { .cmd = KSU_IOCTL_GET_FEATURE,
      .name = "GET_FEATURE",
      .handler = do_get_feature,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_SET_FEATURE,
      .name = "SET_FEATURE",
      .handler = do_set_feature,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_GET_WRAPPER_FD,
      .name = "GET_WRAPPER_FD",
      .handler = do_get_wrapper_fd,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_MANAGE_MARK,
      .name = "MANAGE_MARK",
      .handler = do_manage_mark,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_NUKE_EXT4_SYSFS,
      .name = "NUKE_EXT4_SYSFS",
      .handler = do_nuke_ext4_sysfs,
      .perm_check = manager_or_root },
    { .cmd = KSU_IOCTL_ADD_TRY_UMOUNT,
      .name = "ADD_TRY_UMOUNT",
      .handler = add_try_umount,
      .perm_check = manager_or_root },
    { .cmd = 0, .name = NULL, .handler = NULL, .perm_check = NULL } // Sentinel
};

struct ksu_install_fd_tw {
    struct callback_head cb;
    int __user *outp;
};

static void ksu_install_fd_tw_func(struct callback_head *cb)
{
    struct ksu_install_fd_tw *tw =
        container_of(cb, struct ksu_install_fd_tw, cb);
    int fd = ksu_install_fd();
    pr_info("[%d] install ksu fd: %d\n", current->pid, fd);

    if (copy_to_user(tw->outp, &fd, sizeof(fd))) {
        pr_err("install ksu fd reply err\n");
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
        close_fd(fd);
#else
        ksys_close(fd);
#endif
    }

    kfree(tw);
}

static int reboot_handler_pre(struct kprobe *p, struct pt_regs *regs)
{
    struct pt_regs *real_regs = PT_REAL_REGS(regs);
    int magic1 = (int)PT_REGS_PARM1(real_regs);
    int magic2 = (int)PT_REGS_PARM2(real_regs);
    unsigned long arg4;

    // Check if this is a request to install KSU fd
    if (magic1 == KSU_INSTALL_MAGIC1 && magic2 == KSU_INSTALL_MAGIC2) {
        struct ksu_install_fd_tw *tw;

        arg4 = (unsigned long)PT_REGS_SYSCALL_PARM4(real_regs);

        tw = kzalloc(sizeof(*tw), GFP_ATOMIC);
        if (!tw)
            return 0;

        tw->outp = (int __user *)arg4;
        tw->cb.func = ksu_install_fd_tw_func;

        if (task_work_add(current, &tw->cb, TWA_RESUME)) {
            kfree(tw);
            pr_warn("install fd add task_work failed\n");
        }
    }

    return 0;
}

static struct kprobe reboot_kp = {
    .symbol_name = REBOOT_SYMBOL,
    .pre_handler = reboot_handler_pre,
};

void ksu_supercalls_init(void)
{
    int i;

    pr_info("KernelSU IOCTL Commands:\n");
    for (i = 0; ksu_ioctl_handlers[i].handler; i++) {
        pr_info("  %-18s = 0x%08x\n", ksu_ioctl_handlers[i].name,
                ksu_ioctl_handlers[i].cmd);
    }

    int rc = register_kprobe(&reboot_kp);
    if (rc) {
        pr_err("reboot kprobe failed: %d\n", rc);
    } else {
        pr_info("reboot kprobe registered successfully\n");
    }
}

void ksu_supercalls_exit(void)
{
    unregister_kprobe(&reboot_kp);
}

// IOCTL dispatcher
static long anon_ksu_ioctl(struct file *filp, unsigned int cmd,
                           unsigned long arg)
{
    void __user *argp = (void __user *)arg;
    int i;

#ifdef CONFIG_KSU_DEBUG
    pr_info("ksu ioctl: cmd=0x%x from uid=%d\n", cmd, current_uid().val);
#endif

    for (i = 0; ksu_ioctl_handlers[i].handler; i++) {
        if (cmd == ksu_ioctl_handlers[i].cmd) {
            // Check permission first
            if (ksu_ioctl_handlers[i].perm_check &&
                !ksu_ioctl_handlers[i].perm_check()) {
                pr_warn("ksu ioctl: permission denied for cmd=0x%x uid=%d\n",
                        cmd, current_uid().val);
                return -EPERM;
            }
            // Execute handler
            return ksu_ioctl_handlers[i].handler(argp);
        }
    }

    pr_warn("ksu ioctl: unsupported command 0x%x\n", cmd);
    return -ENOTTY;
}

// File release handler
static int anon_ksu_release(struct inode *inode, struct file *filp)
{
    pr_info("ksu fd released\n");
    return 0;
}

// File operations structure
static const struct file_operations anon_ksu_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = anon_ksu_ioctl,
    .compat_ioctl = anon_ksu_ioctl,
    .release = anon_ksu_release,
};

// Install KSU fd to current process
int ksu_install_fd(void)
{
    struct file *filp;
    int fd;

    // Get unused fd
    fd = get_unused_fd_flags(O_CLOEXEC);
    if (fd < 0) {
        pr_err("ksu_install_fd: failed to get unused fd\n");
        return fd;
    }

    // Create anonymous inode file
    filp = anon_inode_getfile("[ksu_driver]", &anon_ksu_fops, NULL,
                              O_RDWR | O_CLOEXEC);
    if (IS_ERR(filp)) {
        pr_err("ksu_install_fd: failed to create anon inode file\n");
        put_unused_fd(fd);
        return PTR_ERR(filp);
    }

    // Install fd
    fd_install(fd, filp);

    pr_info("ksu fd installed: %d for pid %d\n", fd, current->pid);

    return fd;
}

```

`kernel/supercalls.h`:

```h
#ifndef __KSU_H_SUPERCALLS
#define __KSU_H_SUPERCALLS

#include <linux/types.h>
#include <linux/ioctl.h>
#include "app_profile.h"

// Magic numbers for reboot hook to install fd
#define KSU_INSTALL_MAGIC1 0xDEADBEEF
#define KSU_INSTALL_MAGIC2 0xCAFEBABE

// Command structures for ioctl

struct ksu_become_daemon_cmd {
    __u8 token[65]; // Input: daemon token (null-terminated)
};

struct ksu_get_info_cmd {
    __u32 version; // Output: KERNEL_SU_VERSION
    __u32 flags; // Output: flags (bit 0: MODULE mode)
    __u32 features; // Output: max feature ID supported
};

struct ksu_report_event_cmd {
    __u32 event; // Input: EVENT_POST_FS_DATA, EVENT_BOOT_COMPLETED, etc.
};

struct ksu_set_sepolicy_cmd {
    __u64 cmd; // Input: sepolicy command
    __aligned_u64 arg; // Input: sepolicy argument pointer
};

struct ksu_check_safemode_cmd {
    __u8 in_safe_mode; // Output: true if in safe mode, false otherwise
};

// deprecated
struct ksu_get_allow_list_cmd {
    __u32 uids[128]; // Output: array of allowed/denied UIDs
    __u32 count; // Output: number of UIDs in array
    __u8 allow; // Input: true for allow list, false for deny list
};

struct ksu_new_get_allow_list_cmd {
    __u16 count; // Input / Output: number of UIDs in array
    __u16 total_count; // Output: total number of UIDs in requested list
    __u32 uids[0]; // Output: array of allowed/denied UIDs
};

struct ksu_uid_granted_root_cmd {
    __u32 uid; // Input: target UID to check
    __u8 granted; // Output: true if granted, false otherwise
};

struct ksu_uid_should_umount_cmd {
    __u32 uid; // Input: target UID to check
    __u8 should_umount; // Output: true if should umount, false otherwise
};

struct ksu_get_manager_appid_cmd {
    __u32 appid; // Output: manager app id
};

struct ksu_get_app_profile_cmd {
    struct app_profile profile; // Input/Output: app profile structure
};

struct ksu_set_app_profile_cmd {
    struct app_profile profile; // Input: app profile structure
};

struct ksu_get_feature_cmd {
    __u32 feature_id; // Input: feature ID (enum ksu_feature_id)
    __u64 value; // Output: feature value/state
    __u8 supported; // Output: true if feature is supported, false otherwise
};

struct ksu_set_feature_cmd {
    __u32 feature_id; // Input: feature ID (enum ksu_feature_id)
    __u64 value; // Input: feature value/state to set
};

struct ksu_get_wrapper_fd_cmd {
    __u32 fd; // Input: userspace fd
    __u32 flags; // Input: flags of userspace fd
};

struct ksu_manage_mark_cmd {
    __u32 operation; // Input: KSU_MARK_*
    __s32 pid; // Input: target pid (0 for all processes)
    __u32 result; // Output: for get operation - mark status or reg_count
};

#define KSU_MARK_GET 1
#define KSU_MARK_MARK 2
#define KSU_MARK_UNMARK 3
#define KSU_MARK_REFRESH 4

struct ksu_nuke_ext4_sysfs_cmd {
    __aligned_u64 arg; // Input: mnt pointer
};

struct ksu_add_try_umount_cmd {
    __aligned_u64 arg; // char ptr, this is the mountpoint
    __u32 flags; // this is the flag we use for it
    __u8 mode; // denotes what to do with it 0:wipe_list 1:add_to_list 2:delete_entry
};

#define KSU_UMOUNT_WIPE 0 // ignore everything and wipe list
#define KSU_UMOUNT_ADD 1 // add entry (path + flags)
#define KSU_UMOUNT_DEL 2 // delete entry, strcmp

// IOCTL command definitions
#define KSU_IOCTL_GRANT_ROOT _IOC(_IOC_NONE, 'K', 1, 0)
#define KSU_IOCTL_GET_INFO _IOC(_IOC_READ, 'K', 2, 0)
#define KSU_IOCTL_REPORT_EVENT _IOC(_IOC_WRITE, 'K', 3, 0)
#define KSU_IOCTL_SET_SEPOLICY _IOC(_IOC_READ | _IOC_WRITE, 'K', 4, 0)
#define KSU_IOCTL_CHECK_SAFEMODE _IOC(_IOC_READ, 'K', 5, 0)
// deprecated
#define KSU_IOCTL_GET_ALLOW_LIST _IOC(_IOC_READ | _IOC_WRITE, 'K', 6, 0)
// deprecated
#define KSU_IOCTL_GET_DENY_LIST _IOC(_IOC_READ | _IOC_WRITE, 'K', 7, 0)
#define KSU_IOCTL_NEW_GET_ALLOW_LIST                                           \
    _IOWR('K', 6, struct ksu_new_get_allow_list_cmd)
#define KSU_IOCTL_NEW_GET_DENY_LIST                                            \
    _IOWR('K', 7, struct ksu_new_get_allow_list_cmd)
#define KSU_IOCTL_UID_GRANTED_ROOT _IOC(_IOC_READ | _IOC_WRITE, 'K', 8, 0)
#define KSU_IOCTL_UID_SHOULD_UMOUNT _IOC(_IOC_READ | _IOC_WRITE, 'K', 9, 0)
#define KSU_IOCTL_GET_MANAGER_APPID _IOC(_IOC_READ, 'K', 10, 0)
#define KSU_IOCTL_GET_APP_PROFILE _IOC(_IOC_READ | _IOC_WRITE, 'K', 11, 0)
#define KSU_IOCTL_SET_APP_PROFILE _IOC(_IOC_WRITE, 'K', 12, 0)
#define KSU_IOCTL_GET_FEATURE _IOC(_IOC_READ | _IOC_WRITE, 'K', 13, 0)
#define KSU_IOCTL_SET_FEATURE _IOC(_IOC_WRITE, 'K', 14, 0)
#define KSU_IOCTL_GET_WRAPPER_FD _IOC(_IOC_WRITE, 'K', 15, 0)
#define KSU_IOCTL_MANAGE_MARK _IOC(_IOC_READ | _IOC_WRITE, 'K', 16, 0)
#define KSU_IOCTL_NUKE_EXT4_SYSFS _IOC(_IOC_WRITE, 'K', 17, 0)
#define KSU_IOCTL_ADD_TRY_UMOUNT _IOC(_IOC_WRITE, 'K', 18, 0)

// IOCTL handler types
typedef int (*ksu_ioctl_handler_t)(void __user *arg);
typedef bool (*ksu_perm_check_t)(void);

// IOCTL command mapping
struct ksu_ioctl_cmd_map {
    unsigned int cmd;
    const char *name;
    ksu_ioctl_handler_t handler;
    ksu_perm_check_t perm_check; // Permission check function
};

// Install KSU fd to current process
int ksu_install_fd(void);

void ksu_supercalls_init(void);
void ksu_supercalls_exit(void);
#endif // __KSU_H_SUPERCALLS

```

`kernel/syscall_hook_manager.c`:

```c
#include "linux/compiler.h"
#include "linux/cred.h"
#include "linux/printk.h"
#include "selinux/selinux.h"
#include <linux/spinlock.h>
#include <linux/kprobes.h>
#include <linux/tracepoint.h>
#include <asm/syscall.h>
#include <linux/ptrace.h>
#include <linux/slab.h>
#include <trace/events/syscalls.h>

#include "allowlist.h"
#include "arch.h"
#include "klog.h" // IWYU pragma: keep
#include "syscall_hook_manager.h"
#include "sucompat.h"
#include "setuid_hook.h"
#include "selinux/selinux.h"
#include "util.h"
#include "ksud.h"

// Tracepoint registration count management
// == 1: just us
// >  1: someone else is also using syscall tracepoint e.g. ftrace
static int tracepoint_reg_count = 0;
static DEFINE_SPINLOCK(tracepoint_reg_lock);

void ksu_clear_task_tracepoint_flag_if_needed(struct task_struct *t)
{
    unsigned long flags;
    spin_lock_irqsave(&tracepoint_reg_lock, flags);
    if (tracepoint_reg_count <= 1) {
        ksu_clear_task_tracepoint_flag(t);
    }
    spin_unlock_irqrestore(&tracepoint_reg_lock, flags);
}

// Process marking management
static void handle_process_mark(bool mark)
{
    struct task_struct *p, *t;
    read_lock(&tasklist_lock);
    for_each_process_thread (p, t) {
        if (mark)
            ksu_set_task_tracepoint_flag(t);
        else
            ksu_clear_task_tracepoint_flag(t);
    }
    read_unlock(&tasklist_lock);
}

void ksu_mark_all_process(void)
{
    handle_process_mark(true);
    pr_info("hook_manager: mark all user process done!\n");
}

void ksu_unmark_all_process(void)
{
    handle_process_mark(false);
    pr_info("hook_manager: unmark all user process done!\n");
}

static void ksu_mark_running_process_locked()
{
    struct task_struct *p, *t;
    read_lock(&tasklist_lock);
    for_each_process_thread (p, t) {
        if (!t->mm) { // only user processes
            continue;
        }
        int uid = task_uid(t).val;
        const struct cred *cred = get_task_cred(t);
        bool ksu_root_process = uid == 0 && is_task_ksu_domain(cred);
        bool is_zygote_process = is_zygote(cred);
        bool is_shell = uid == 2000;
        // before boot completed, we shall mark init for marking zygote
        bool is_init = t->pid == 1;
        if (ksu_root_process || is_zygote_process || is_shell || is_init ||
            ksu_is_allow_uid(uid)) {
            ksu_set_task_tracepoint_flag(t);
            pr_info("hook_manager: mark process: pid:%d, uid: %d, comm:%s\n",
                    t->pid, uid, t->comm);
        } else {
            ksu_clear_task_tracepoint_flag(t);
            pr_info("hook_manager: unmark process: pid:%d, uid: %d, comm:%s\n",
                    t->pid, uid, t->comm);
        }
        put_cred(cred);
    }
    read_unlock(&tasklist_lock);
}

void ksu_mark_running_process()
{
    unsigned long flags;
    spin_lock_irqsave(&tracepoint_reg_lock, flags);
    if (tracepoint_reg_count <= 1) {
        ksu_mark_running_process_locked();
    } else {
        pr_info(
            "hook_manager: not mark running process since syscall tracepoint is in use\n");
    }
    spin_unlock_irqrestore(&tracepoint_reg_lock, flags);
}

// Get task mark status
// Returns: 1 if marked, 0 if not marked, -ESRCH if task not found
int ksu_get_task_mark(pid_t pid)
{
    struct task_struct *task;
    int marked = -ESRCH;

    rcu_read_lock();
    task = find_task_by_vpid(pid);
    if (task) {
        get_task_struct(task);
        rcu_read_unlock();
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
        marked = test_task_syscall_work(task, SYSCALL_TRACEPOINT) ? 1 : 0;
#else
        marked = test_tsk_thread_flag(task, TIF_SYSCALL_TRACEPOINT) ? 1 : 0;
#endif
        put_task_struct(task);
    } else {
        rcu_read_unlock();
    }

    return marked;
}

// Set task mark status
// Returns: 0 on success, -ESRCH if task not found
int ksu_set_task_mark(pid_t pid, bool mark)
{
    struct task_struct *task;
    int ret = -ESRCH;

    rcu_read_lock();
    task = find_task_by_vpid(pid);
    if (task) {
        get_task_struct(task);
        rcu_read_unlock();
        if (mark) {
            ksu_set_task_tracepoint_flag(task);
            pr_info("hook_manager: marked task pid=%d comm=%s\n", pid,
                    task->comm);
        } else {
            ksu_clear_task_tracepoint_flag(task);
            pr_info("hook_manager: unmarked task pid=%d comm=%s\n", pid,
                    task->comm);
        }
        put_task_struct(task);
        ret = 0;
    } else {
        rcu_read_unlock();
    }

    return ret;
}

#ifdef CONFIG_KRETPROBES

static struct kretprobe *init_kretprobe(const char *name,
                                        kretprobe_handler_t handler)
{
    struct kretprobe *rp = kzalloc(sizeof(struct kretprobe), GFP_KERNEL);
    if (!rp)
        return NULL;
    rp->kp.symbol_name = name;
    rp->handler = handler;
    rp->data_size = 0;
    rp->maxactive = 0;

    int ret = register_kretprobe(rp);
    pr_info("hook_manager: register_%s kretprobe: %d\n", name, ret);
    if (ret) {
        kfree(rp);
        return NULL;
    }

    return rp;
}

static void destroy_kretprobe(struct kretprobe **rp_ptr)
{
    struct kretprobe *rp = *rp_ptr;
    if (!rp)
        return;
    unregister_kretprobe(rp);
    synchronize_rcu();
    kfree(rp);
    *rp_ptr = NULL;
}

static int syscall_regfunc_handler(struct kretprobe_instance *ri,
                                   struct pt_regs *regs)
{
    unsigned long flags;
    spin_lock_irqsave(&tracepoint_reg_lock, flags);
    if (tracepoint_reg_count < 1) {
        // while install our tracepoint, mark our processes
        ksu_mark_running_process_locked();
    } else if (tracepoint_reg_count == 1) {
        // while other tracepoint first added, mark all processes
        ksu_mark_all_process();
    }
    tracepoint_reg_count++;
    spin_unlock_irqrestore(&tracepoint_reg_lock, flags);
    return 0;
}

static int syscall_unregfunc_handler(struct kretprobe_instance *ri,
                                     struct pt_regs *regs)
{
    unsigned long flags;
    spin_lock_irqsave(&tracepoint_reg_lock, flags);
    tracepoint_reg_count--;
    if (tracepoint_reg_count <= 0) {
        // while no tracepoint left, unmark all processes
        ksu_unmark_all_process();
    } else if (tracepoint_reg_count == 1) {
        // while just our tracepoint left, unmark disallowed processes
        ksu_mark_running_process_locked();
    }
    spin_unlock_irqrestore(&tracepoint_reg_lock, flags);
    return 0;
}

static struct kretprobe *syscall_regfunc_rp = NULL;
static struct kretprobe *syscall_unregfunc_rp = NULL;
#endif

static inline bool check_syscall_fastpath(int nr)
{
    switch (nr) {
    case __NR_newfstatat:
    case __NR_faccessat:
    case __NR_execve:
    case __NR_setresuid:
        return true;
    default:
        return false;
    }
}

// Unmark init's child that are not zygote, adbd or ksud
int ksu_handle_init_mark_tracker(const char __user **filename_user)
{
    char path[64];
    unsigned long addr;
    const char __user *fn;
    long ret;

    if (unlikely(!filename_user))
        return 0;

    addr = untagged_addr((unsigned long)*filename_user);
    fn = (const char __user *)addr;

    memset(path, 0, sizeof(path));
    ret = strncpy_from_user_nofault(path, fn, sizeof(path));
    if (ret < 0 && try_set_access_flag(addr)) {
        ret = strncpy_from_user_nofault(path, fn, sizeof(path));
        pr_info("ksu_handle_init_mark_tracker: %ld\n", ret);
    }

    if (unlikely(strcmp(path, KSUD_PATH) == 0)) {
        pr_info("hook_manager: escape to root for init executing ksud: %d\n",
                current->pid);
        escape_to_root_for_init();
    } else if (likely(strstr(path, "/app_process") == NULL &&
                      strstr(path, "/adbd") == NULL)) {
        pr_info("hook_manager: unmark %d exec %s\n", current->pid, path);
        ksu_clear_task_tracepoint_flag_if_needed(current);
    }

    return 0;
}

#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
// Generic sys_enter handler that dispatches to specific handlers
static void ksu_sys_enter_handler(void *data, struct pt_regs *regs, long id)
{
    if (unlikely(check_syscall_fastpath(id))) {
        if (ksu_su_compat_enabled) {
            // Handle newfstatat
            if (id == __NR_newfstatat) {
                int *dfd = (int *)&PT_REGS_PARM1(regs);
                const char __user **filename_user =
                    (const char __user **)&PT_REGS_PARM2(regs);
                int *flags = (int *)&PT_REGS_SYSCALL_PARM4(regs);
                ksu_handle_stat(dfd, filename_user, flags);
                return;
            }

            // Handle faccessat
            if (id == __NR_faccessat) {
                int *dfd = (int *)&PT_REGS_PARM1(regs);
                const char __user **filename_user =
                    (const char __user **)&PT_REGS_PARM2(regs);
                int *mode = (int *)&PT_REGS_PARM3(regs);
                ksu_handle_faccessat(dfd, filename_user, mode, NULL);
                return;
            }

            // Handle execve
            if (id == __NR_execve) {
                const char __user **filename_user =
                    (const char __user **)&PT_REGS_PARM1(regs);
                if (current->pid != 1 && is_init(get_current_cred())) {
                    ksu_handle_init_mark_tracker(filename_user);
                } else {
                    ksu_handle_execve_sucompat(filename_user, NULL, NULL, NULL);
                }
                return;
            }
        }

        // Handle setresuid
        if (id == __NR_setresuid) {
            uid_t ruid = (uid_t)PT_REGS_PARM1(regs);
            uid_t euid = (uid_t)PT_REGS_PARM2(regs);
            uid_t suid = (uid_t)PT_REGS_PARM3(regs);
            ksu_handle_setresuid(ruid, euid, suid);
            return;
        }
    }
}
#endif

void ksu_syscall_hook_manager_init(void)
{
    int ret;
    pr_info("hook_manager: ksu_hook_manager_init called\n");

#ifdef CONFIG_KRETPROBES
    // Register kretprobe for syscall_regfunc
    syscall_regfunc_rp =
        init_kretprobe("syscall_regfunc", syscall_regfunc_handler);
    // Register kretprobe for syscall_unregfunc
    syscall_unregfunc_rp =
        init_kretprobe("syscall_unregfunc", syscall_unregfunc_handler);
#endif

#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
    ret = register_trace_sys_enter(ksu_sys_enter_handler, NULL);
#ifndef CONFIG_KRETPROBES
    ksu_mark_running_process_locked();
#endif
    if (ret) {
        pr_err("hook_manager: failed to register sys_enter tracepoint: %d\n",
               ret);
    } else {
        pr_info("hook_manager: sys_enter tracepoint registered\n");
    }
#endif

    ksu_setuid_hook_init();
    ksu_sucompat_init();
}

void ksu_syscall_hook_manager_exit(void)
{
    pr_info("hook_manager: ksu_hook_manager_exit called\n");
#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
    unregister_trace_sys_enter(ksu_sys_enter_handler, NULL);
    tracepoint_synchronize_unregister();
    pr_info("hook_manager: sys_enter tracepoint unregistered\n");
#endif

#ifdef CONFIG_KRETPROBES
    destroy_kretprobe(&syscall_regfunc_rp);
    destroy_kretprobe(&syscall_unregfunc_rp);
#endif

    ksu_sucompat_exit();
    ksu_setuid_hook_exit();
}

```

`kernel/syscall_hook_manager.h`:

```h
#ifndef __KSU_H_HOOK_MANAGER
#define __KSU_H_HOOK_MANAGER

#include <linux/version.h>
#include <linux/sched.h>
#include <linux/thread_info.h>

// Hook manager initialization and cleanup
void ksu_syscall_hook_manager_init(void);
void ksu_syscall_hook_manager_exit(void);

// Process marking for tracepoint
void ksu_mark_all_process(void);
void ksu_unmark_all_process(void);
void ksu_mark_running_process(void);

// Per-task mark operations
int ksu_get_task_mark(pid_t pid);
int ksu_set_task_mark(pid_t pid, bool mark);

static inline void ksu_set_task_tracepoint_flag(struct task_struct *t)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
    set_task_syscall_work(t, SYSCALL_TRACEPOINT);
#else
    set_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);
#endif
}

static inline void ksu_clear_task_tracepoint_flag(struct task_struct *t)
{
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
    clear_task_syscall_work(t, SYSCALL_TRACEPOINT);
#else
    clear_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);
#endif
}

void ksu_clear_task_tracepoint_flag_if_needed(struct task_struct *t);

#endif

```

`kernel/throne_tracker.c`:

```c
#include <linux/err.h>
#include <linux/fs.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/types.h>
#include <linux/version.h>

#include "allowlist.h"
#include "apk_sign.h"
#include "klog.h" // IWYU pragma: keep
#include "manager.h"
#include "throne_tracker.h"

uid_t ksu_manager_appid = KSU_INVALID_APPID;

#define SYSTEM_PACKAGES_LIST_PATH "/data/system/packages.list"

struct uid_data {
    struct list_head list;
    u32 uid;
    char package[KSU_MAX_PACKAGE_NAME];
};

static void crown_manager(const char *apk, struct list_head *uid_data)
{
    char pkg[KSU_MAX_PACKAGE_NAME];
    if (get_pkg_from_apk_path(pkg, apk) < 0) {
        pr_err("Failed to get package name from apk path: %s\n", apk);
        return;
    }

    pr_info("manager pkg: %s\n", pkg);

    struct list_head *list = (struct list_head *)uid_data;
    struct uid_data *np;

    list_for_each_entry (np, list, list) {
        if (strncmp(np->package, pkg, KSU_MAX_PACKAGE_NAME) == 0) {
            pr_info("Crowning manager: %s(uid=%d)\n", pkg, np->uid);
            ksu_set_manager_appid(np->uid);
            break;
        }
    }
}

#define DATA_PATH_LEN 384 // 384 is enough for /data/app/<package>/base.apk

struct data_path {
    char dirpath[DATA_PATH_LEN];
    int depth;
    struct list_head list;
};

struct apk_path_hash {
    unsigned int hash;
    bool exists;
    struct list_head list;
};

static struct list_head apk_path_hash_list = LIST_HEAD_INIT(apk_path_hash_list);

struct my_dir_context {
    struct dir_context ctx;
    struct list_head *data_path_list;
    char *parent_dir;
    void *private_data;
    int depth;
    int *stop;
};
// https://docs.kernel.org/filesystems/porting.html
// filldir_t (readdir callbacks) calling conventions have changed. Instead of returning 0 or -E... it returns bool now. false means "no more" (as -E... used to) and true - "keep going" (as 0 in old calling conventions). Rationale: callers never looked at specific -E... values anyway. -> iterate_shared() instances require no changes at all, all filldir_t ones in the tree converted.
#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
#define FILLDIR_RETURN_TYPE bool
#define FILLDIR_ACTOR_CONTINUE true
#define FILLDIR_ACTOR_STOP false
#else
#define FILLDIR_RETURN_TYPE int
#define FILLDIR_ACTOR_CONTINUE 0
#define FILLDIR_ACTOR_STOP -EINVAL
#endif
extern bool is_manager_apk(char *path);
FILLDIR_RETURN_TYPE my_actor(struct dir_context *ctx, const char *name,
                             int namelen, loff_t off, u64 ino,
                             unsigned int d_type)
{
    struct my_dir_context *my_ctx =
        container_of(ctx, struct my_dir_context, ctx);
    char dirpath[DATA_PATH_LEN];

    if (!my_ctx) {
        pr_err("Invalid context\n");
        return FILLDIR_ACTOR_STOP;
    }
    if (my_ctx->stop && *my_ctx->stop) {
        pr_info("Stop searching\n");
        return FILLDIR_ACTOR_STOP;
    }

    if (!strncmp(name, "..", namelen) || !strncmp(name, ".", namelen))
        return FILLDIR_ACTOR_CONTINUE; // Skip "." and ".."

    if (d_type == DT_DIR && namelen >= 8 && !strncmp(name, "vmdl", 4) &&
        !strncmp(name + namelen - 4, ".tmp", 4)) {
        pr_info("Skipping directory: %.*s\n", namelen, name);
        return FILLDIR_ACTOR_CONTINUE; // Skip staging package
    }

    if (snprintf(dirpath, DATA_PATH_LEN, "%s/%.*s", my_ctx->parent_dir, namelen,
                 name) >= DATA_PATH_LEN) {
        pr_err("Path too long: %s/%.*s\n", my_ctx->parent_dir, namelen, name);
        return FILLDIR_ACTOR_CONTINUE;
    }

    if (d_type == DT_DIR && my_ctx->depth > 0 &&
        (my_ctx->stop && !*my_ctx->stop)) {
        struct data_path *data = kzalloc(sizeof(struct data_path), GFP_ATOMIC);

        if (!data) {
            pr_err("Failed to allocate memory for %s\n", dirpath);
            return FILLDIR_ACTOR_CONTINUE;
        }

        strscpy(data->dirpath, dirpath, DATA_PATH_LEN);
        data->depth = my_ctx->depth - 1;
        list_add_tail(&data->list, my_ctx->data_path_list);
    } else {
        if ((namelen == 8) && (strncmp(name, "base.apk", namelen) == 0)) {
            struct apk_path_hash *pos, *n;
            unsigned int hash = full_name_hash(NULL, dirpath, strlen(dirpath));
            list_for_each_entry (pos, &apk_path_hash_list, list) {
                if (hash == pos->hash) {
                    pos->exists = true;
                    return FILLDIR_ACTOR_CONTINUE;
                }
            }

            bool is_manager = is_manager_apk(dirpath);
            pr_info("Found new base.apk at path: %s, is_manager: %d\n", dirpath,
                    is_manager);
            if (is_manager) {
                crown_manager(dirpath, my_ctx->private_data);
                *my_ctx->stop = 1;

                // Manager found, clear APK cache list
                list_for_each_entry_safe (pos, n, &apk_path_hash_list, list) {
                    list_del(&pos->list);
                    kfree(pos);
                }
            } else {
                struct apk_path_hash *apk_data =
                    kzalloc(sizeof(struct apk_path_hash), GFP_ATOMIC);
                apk_data->hash = hash;
                apk_data->exists = true;
                list_add_tail(&apk_data->list, &apk_path_hash_list);
            }
        }
    }

    return FILLDIR_ACTOR_CONTINUE;
}

void search_manager(const char *path, int depth, struct list_head *uid_data)
{
    int i, stop = 0;
    struct list_head data_path_list;
    INIT_LIST_HEAD(&data_path_list);
    unsigned long data_app_magic = 0;

    // Initialize APK cache list
    struct apk_path_hash *pos, *n;
    list_for_each_entry (pos, &apk_path_hash_list, list) {
        pos->exists = false;
    }

    // First depth
    struct data_path data;
    strscpy(data.dirpath, path, DATA_PATH_LEN);
    data.depth = depth;
    list_add_tail(&data.list, &data_path_list);

    for (i = depth; i >= 0; i--) {
        struct data_path *pos, *n;

        list_for_each_entry_safe (pos, n, &data_path_list, list) {
            struct my_dir_context ctx = { .ctx.actor = my_actor,
                                          .data_path_list = &data_path_list,
                                          .parent_dir = pos->dirpath,
                                          .private_data = uid_data,
                                          .depth = pos->depth,
                                          .stop = &stop };
            struct file *file;

            if (!stop) {
                file = filp_open(pos->dirpath, O_RDONLY | O_NOFOLLOW, 0);
                if (IS_ERR(file)) {
                    pr_err("Failed to open directory: %s, err: %ld\n",
                           pos->dirpath, PTR_ERR(file));
                    goto skip_iterate;
                }

                // grab magic on first folder, which is /data/app
                if (!data_app_magic) {
                    if (file->f_inode->i_sb->s_magic) {
                        data_app_magic = file->f_inode->i_sb->s_magic;
                        pr_info("%s: dir: %s got magic! 0x%lx\n", __func__,
                                pos->dirpath, data_app_magic);
                    } else {
                        filp_close(file, NULL);
                        goto skip_iterate;
                    }
                }

                if (file->f_inode->i_sb->s_magic != data_app_magic) {
                    pr_info("%s: skip: %s magic: 0x%lx expected: 0x%lx\n",
                            __func__, pos->dirpath,
                            file->f_inode->i_sb->s_magic, data_app_magic);
                    filp_close(file, NULL);
                    goto skip_iterate;
                }

                iterate_dir(file, &ctx.ctx);
                filp_close(file, NULL);
            }
        skip_iterate:
            list_del(&pos->list);
            if (pos != &data)
                kfree(pos);
        }
    }

    // Remove stale cached APK entries
    list_for_each_entry_safe (pos, n, &apk_path_hash_list, list) {
        if (!pos->exists) {
            list_del(&pos->list);
            kfree(pos);
        }
    }
}

static bool is_uid_exist(uid_t uid, char *package, void *data)
{
    struct list_head *list = (struct list_head *)data;
    struct uid_data *np;

    bool exist = false;
    list_for_each_entry (np, list, list) {
        if (np->uid == uid % PER_USER_RANGE &&
            strncmp(np->package, package, KSU_MAX_PACKAGE_NAME) == 0) {
            exist = true;
            break;
        }
    }
    return exist;
}

void track_throne(bool prune_only)
{
    struct file *fp = filp_open(SYSTEM_PACKAGES_LIST_PATH, O_RDONLY, 0);
    if (IS_ERR(fp)) {
        pr_err("%s: open " SYSTEM_PACKAGES_LIST_PATH " failed: %ld\n", __func__,
               PTR_ERR(fp));
        return;
    }

    struct list_head uid_list;
    INIT_LIST_HEAD(&uid_list);

    char chr = 0;
    loff_t pos = 0;
    loff_t line_start = 0;
    char buf[KSU_MAX_PACKAGE_NAME];
    for (;;) {
        ssize_t count = kernel_read(fp, &chr, sizeof(chr), &pos);
        if (count != sizeof(chr))
            break;
        if (chr != '\n')
            continue;

        count = kernel_read(fp, buf, sizeof(buf), &line_start);

        struct uid_data *data = kzalloc(sizeof(struct uid_data), GFP_ATOMIC);
        if (!data) {
            filp_close(fp, 0);
            goto out;
        }

        char *tmp = buf;
        const char *delim = " ";
        char *package = strsep(&tmp, delim);
        char *uid = strsep(&tmp, delim);
        if (!uid || !package) {
            kfree(data);
            pr_err("update_uid: package or uid is NULL!\n");
            break;
        }

        u32 res;
        if (kstrtou32(uid, 10, &res)) {
            kfree(data);
            pr_err("update_uid: uid parse err\n");
            break;
        }
        data->uid = res;
        strncpy(data->package, package, KSU_MAX_PACKAGE_NAME);
        list_add_tail(&data->list, &uid_list);
        // reset line start
        line_start = pos;
    }
    filp_close(fp, 0);

    // now update uid list
    struct uid_data *np;
    struct uid_data *n;

    if (prune_only)
        goto prune;

    // first, check if manager_uid exist!
    bool manager_exist = false;
    list_for_each_entry (np, &uid_list, list) {
        if (np->uid == ksu_get_manager_appid()) {
            manager_exist = true;
            break;
        }
    }

    if (!manager_exist) {
        if (ksu_is_manager_appid_valid()) {
            pr_info("manager is uninstalled, invalidate it!\n");
            ksu_invalidate_manager_uid();
            goto prune;
        }
        pr_info("Searching manager...\n");
        search_manager("/data/app", 2, &uid_list);
        pr_info("Search manager finished\n");
    }

prune:
    // then prune the allowlist
    ksu_prune_allowlist(is_uid_exist, &uid_list);
out:
    // free uid_list
    list_for_each_entry_safe (np, n, &uid_list, list) {
        list_del(&np->list);
        kfree(np);
    }
}

void ksu_throne_tracker_init()
{
    // nothing to do
}

void ksu_throne_tracker_exit()
{
    // nothing to do
}

```

`kernel/throne_tracker.h`:

```h
#ifndef __KSU_H_UID_OBSERVER
#define __KSU_H_UID_OBSERVER

void ksu_throne_tracker_init();

void ksu_throne_tracker_exit();

void track_throne(bool prune_only);

#endif

```

`kernel/tools/check_symbol.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <elf.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>

typedef struct {
    void *data;
    size_t size;
    Elf64_Ehdr *ehdr;
    Elf64_Shdr *shdr;
    char *shstrtab;
} ElfFile;

int open_elf(const char *path, ElfFile *elf)
{
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        fprintf(stderr, "Error: Cannot open file %s\n", path);
        return -1;
    }

    struct stat st;
    if (fstat(fd, &st) < 0) {
        fprintf(stderr, "Error: Cannot stat file %s\n", path);
        close(fd);
        return -1;
    }

    elf->size = st.st_size;
    elf->data = mmap(NULL, elf->size, PROT_READ, MAP_PRIVATE, fd, 0);
    close(fd);

    if (elf->data == MAP_FAILED) {
        fprintf(stderr, "Error: Cannot mmap file %s\n", path);
        return -1;
    }

    elf->ehdr = (Elf64_Ehdr *)elf->data;

    if (memcmp(elf->ehdr->e_ident, ELFMAG, SELFMAG) != 0) {
        fprintf(stderr, "Error: %s is not a valid ELF file\n", path);
        munmap(elf->data, elf->size);
        return -1;
    }

    if (elf->ehdr->e_ident[EI_CLASS] != ELFCLASS64) {
        fprintf(stderr, "Error: %s is not a 64-bit ELF file\n", path);
        munmap(elf->data, elf->size);
        return -1;
    }

    elf->shdr = (Elf64_Shdr *)((char *)elf->data + elf->ehdr->e_shoff);

    elf->shstrtab =
        (char *)elf->data + elf->shdr[elf->ehdr->e_shstrndx].sh_offset;

    return 0;
}

void close_elf(ElfFile *elf)
{
    munmap(elf->data, elf->size);
}

Elf64_Shdr *find_symtab(ElfFile *elf)
{
    for (int i = 0; i < elf->ehdr->e_shnum; i++) {
        if (elf->shdr[i].sh_type == SHT_SYMTAB) {
            return &elf->shdr[i];
        }
    }
    return NULL;
}

Elf64_Sym *find_symbol(ElfFile *elf, const char *name, Elf64_Shdr *symtab,
                       char *strtab)
{
    Elf64_Sym *syms = (Elf64_Sym *)((char *)elf->data + symtab->sh_offset);
    int sym_count = symtab->sh_size / sizeof(Elf64_Sym);

    for (int i = 0; i < sym_count; i++) {
        const char *sym_name = strtab + syms[i].st_name;
        if (strcmp(sym_name, name) == 0) {
            return &syms[i];
        }
    }
    return NULL;
}

int main(int argc, char *argv[])
{
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <ko_elf> <vmlinux>\n", argv[0]);
        return 1;
    }

    const char *ko_path = argv[1];
    const char *vmlinux_path = argv[2];

    ElfFile ko_elf, vmlinux;

    if (open_elf(ko_path, &ko_elf) < 0) {
        return 1;
    }

    if (open_elf(vmlinux_path, &vmlinux) < 0) {
        close_elf(&ko_elf);
        return 1;
    }

    Elf64_Shdr *ko_symtab = find_symtab(&ko_elf);
    Elf64_Shdr *vmlinux_symtab = find_symtab(&vmlinux);

    if (!ko_symtab) {
        fprintf(stderr, "Error: No symbol table found in %s\n", ko_path);
        close_elf(&ko_elf);
        close_elf(&vmlinux);
        return 1;
    }

    if (!vmlinux_symtab) {
        fprintf(stderr, "Error: No symbol table found in %s\n", vmlinux_path);
        close_elf(&ko_elf);
        close_elf(&vmlinux);
        return 1;
    }

    char *ko_strtab =
        (char *)ko_elf.data + ko_elf.shdr[ko_symtab->sh_link].sh_offset;
    char *vmlinux_strtab =
        (char *)vmlinux.data + vmlinux.shdr[vmlinux_symtab->sh_link].sh_offset;

    Elf64_Sym *ko_syms =
        (Elf64_Sym *)((char *)ko_elf.data + ko_symtab->sh_offset);
    int ko_sym_count = ko_symtab->sh_size / sizeof(Elf64_Sym);

    int has_error = 0;

    for (int i = 0; i < ko_sym_count; i++) {
        if (ko_syms[i].st_shndx == SHN_UNDEF && ko_syms[i].st_name != 0) {
            const char *sym_name = ko_strtab + ko_syms[i].st_name;

            Elf64_Sym *vmlinux_sym =
                find_symbol(&vmlinux, sym_name, vmlinux_symtab, vmlinux_strtab);

            if (!vmlinux_sym || vmlinux_sym->st_shndx == SHN_UNDEF) {
                fprintf(stderr,
                        "Error: Symbol '%s' not found or undefined in %s\n",
                        sym_name, vmlinux_path);
                has_error = 1;
            } else {
                int binding = ELF64_ST_BIND(vmlinux_sym->st_info);
                if (binding != STB_GLOBAL && binding != STB_WEAK) {
                    fprintf(
                        stderr,
                        "Warning: Symbol '%s' is defined in %s but not global (binding=%d)\n",
                        sym_name, vmlinux_path, binding);
                }
            }
        }
    }

    close_elf(&ko_elf);
    close_elf(&vmlinux);

    return has_error ? 1 : 0;
}

```

`kernel/util.c`:

```c
#include <linux/mm.h>
#include <linux/pgtable.h>
#include <linux/printk.h>
#include <asm/current.h>

#include "util.h"

bool try_set_access_flag(unsigned long addr)
{
#ifdef CONFIG_ARM64
    struct mm_struct *mm = current->mm;
    struct vm_area_struct *vma;
    pgd_t *pgd;
    p4d_t *p4d;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *ptep, pte;
    spinlock_t *ptl;
    bool ret = false;

    if (!mm)
        return false;

    if (!mmap_read_trylock(mm))
        return false;

    vma = find_vma(mm, addr);
    if (!vma || addr < vma->vm_start)
        goto out_unlock;

    pgd = pgd_offset(mm, addr);
    if (!pgd_present(*pgd))
        goto out_unlock;

    p4d = p4d_offset(pgd, addr);
    if (!p4d_present(*p4d))
        goto out_unlock;

    pud = pud_offset(p4d, addr);
    if (!pud_present(*pud))
        goto out_unlock;

    pmd = pmd_offset(pud, addr);
    if (!pmd_present(*pmd))
        goto out_unlock;

    if (pmd_trans_huge(*pmd))
        goto out_unlock;

    ptep = pte_offset_map_lock(mm, pmd, addr, &ptl);
    if (!ptep)
        goto out_unlock;

    pte = *ptep;

    if (!pte_present(pte))
        goto out_pte_unlock;

    if (pte_young(pte)) {
        ret = true;
        goto out_pte_unlock;
    }

    ptep_set_access_flags(vma, addr, ptep, pte_mkyoung(pte), 0);
    pr_info("set AF for addr %lx\n", addr);
    ret = true;

out_pte_unlock:
    pte_unmap_unlock(ptep, ptl);
out_unlock:
    mmap_read_unlock(mm);
    return ret;
#else
    return false;
#endif
}

```

`kernel/util.h`:

```h
#ifndef __KSU_UTIL_H
#define __KSU_UTIL_H

#include <linux/types.h>

#ifndef preempt_enable_no_resched_notrace
#define preempt_enable_no_resched_notrace()                                    \
    do {                                                                       \
        barrier();                                                             \
        __preempt_count_dec();                                                 \
    } while (0)
#endif

#ifndef preempt_disable_notrace
#define preempt_disable_notrace()                                              \
    do {                                                                       \
        __preempt_count_inc();                                                 \
        barrier();                                                             \
    } while (0)
#endif

bool try_set_access_flag(unsigned long addr);

#endif

```

`manager/app/build.gradle.kts`:

```kts
@file:Suppress("UnstableApiUsage")

plugins {
    alias(libs.plugins.agp.app)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.kotlin.serialization)
    alias(libs.plugins.lsplugin.apksign)
    id("kotlin-parcelize")
}

val androidCompileSdkVersion: Int by rootProject.extra
val androidCompileNdkVersion: String by rootProject.extra
val androidBuildToolsVersion: String by rootProject.extra
val androidMinSdkVersion: Int by rootProject.extra
val androidTargetSdkVersion: Int by rootProject.extra
val androidSourceCompatibility: JavaVersion by rootProject.extra
val androidTargetCompatibility: JavaVersion by rootProject.extra
val managerVersionCode: Int by rootProject.extra
val managerVersionName: String by rootProject.extra

apksign {
    storeFileProperty = "KEYSTORE_FILE"
    storePasswordProperty = "KEYSTORE_PASSWORD"
    keyAliasProperty = "KEY_ALIAS"
    keyPasswordProperty = "KEY_PASSWORD"
}

val baseCFlags = listOf(
    "-Wall", "-Qunused-arguments", "-fvisibility=hidden", "-fvisibility-inlines-hidden",
    "-fno-exceptions", "-fno-stack-protector", "-fomit-frame-pointer",
    "-Wno-builtin-macro-redefined", "-Wno-unused-value", "-D__FILE__=__FILE_NAME__"
)
val baseCppFlags = baseCFlags + "-fno-rtti"

android {
    namespace = "me.weishu.kernelsu"

    buildTypes {
        debug {
            externalNativeBuild {
                cmake {
                    arguments += listOf("-DCMAKE_CXX_FLAGS_DEBUG=-Og", "-DCMAKE_C_FLAGS_DEBUG=-Og")
                }
            }
        }
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            vcsInfo.include = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
            externalNativeBuild {
                cmake {
                    arguments += "-DDEBUG_SYMBOLS_PATH=${layout.buildDirectory.get().asFile.absolutePath}/symbols"
                    arguments += "-DCMAKE_BUILD_TYPE=Release"

                    val releaseFlags = listOf(
                        "-flto", "-ffunction-sections", "-fdata-sections", "-Wl,--gc-sections",
                        "-fno-unwind-tables", "-fno-asynchronous-unwind-tables", "-Wl,--exclude-libs,ALL"
                    )
                    val configFlags = listOf("-Oz", "-DNDEBUG").joinToString(" ")

                    cppFlags += releaseFlags
                    cFlags += releaseFlags

                    arguments += listOf(
                        "-DCMAKE_CXX_FLAGS_RELEASE=$configFlags",
                        "-DCMAKE_C_FLAGS_RELEASE=$configFlags",
                        "-DCMAKE_SHARED_LINKER_FLAGS=-Wl,--gc-sections -Wl,--exclude-libs,ALL -Wl,--icf=all -s -Wl,--hash-style=sysv -Wl,-z,norelro"
                    )
                }
            }
        }
    }

    buildFeatures {
        aidl = true
        buildConfig = true
        compose = true
        prefab = true
    }

    packaging {
        jniLibs {
            useLegacyPackaging = true
        }
    }

    externalNativeBuild {
        cmake {
            path = file("src/main/cpp/CMakeLists.txt")
        }
    }

    dependenciesInfo {
        includeInApk = false
        includeInBundle = false
    }

    androidResources {
        generateLocaleConfig = true
    }

    compileSdk = androidCompileSdkVersion
    ndkVersion = androidCompileNdkVersion
    buildToolsVersion = androidBuildToolsVersion

    defaultConfig {
        minSdk = androidMinSdkVersion
        targetSdk = androidTargetSdkVersion
        versionCode = managerVersionCode
        versionName = managerVersionName

        externalNativeBuild {
            cmake {
                arguments += "-DANDROID_STL=none"
                cFlags += baseCFlags + "-std=c2x"
                cppFlags += baseCppFlags + "-std=c++2b"
            }
        }

        ndk {
            abiFilters += listOf("arm64-v8a", "x86_64")
        }
    }

    lint {
        abortOnError = true
        checkReleaseBuilds = false
    }

    compileOptions {
        sourceCompatibility = androidSourceCompatibility
        targetCompatibility = androidTargetCompatibility
    }
}

androidComponents {
    onVariants(selector().withBuildType("release")) {
        it.packaging.resources.excludes.addAll(listOf("META-INF/**", "kotlin/**", "org/**", "**.bin"))
    }
}

base {
    archivesName.set(
        "KernelSU_${managerVersionName}_${managerVersionCode}"
    )
}

dependencies {
    implementation(libs.androidx.activity.compose)

    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.compose.material.icons.extended)
    implementation(libs.androidx.compose.ui)
    implementation(libs.androidx.compose.ui.tooling.preview)

    debugImplementation(libs.androidx.compose.ui.test.manifest)
    debugImplementation(libs.androidx.compose.ui.tooling)

    implementation(libs.androidx.lifecycle.runtime.compose)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.lifecycle.viewmodel.navigation3)

    implementation(libs.androidx.navigation3.runtime)
    implementation(libs.androidx.navigationevent.compose)

    implementation(libs.com.github.topjohnwu.libsu.core)
    implementation(libs.com.github.topjohnwu.libsu.service)
    implementation(libs.com.github.topjohnwu.libsu.io)

    implementation(libs.dev.rikka.rikkax.parcelablelist)

    implementation(libs.kotlinx.coroutines.core)

    implementation(libs.markwon)

    implementation(libs.androidx.webkit)

    implementation(libs.lsposed.cxx)

    implementation(libs.hiddenapibypass)

    implementation(libs.miuix)
    implementation(libs.miuix.icons)
    implementation(libs.miuix.navigation3.ui)

    implementation(platform(libs.okhttp.bom))
    implementation(libs.okhttp)

    implementation(libs.haze)
    implementation(libs.capsule)
}

```

`manager/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission
        android:name="android.permission.READ_PHONE_STATE"
        tools:node="remove" />
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage"
        tools:node="remove" />
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage"
        tools:node="remove" />

    <application
        android:name=".KernelSUApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:hasFragileUserData="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:networkSecurityConfig="@xml/network_security_config"
        android:supportsRtl="true"
        android:theme="@style/Theme.KernelSU"
        tools:targetApi="29">
        <activity
            android:name=".ui.MainActivity"
            android:exported="true"
            android:theme="@style/Theme.KernelSU"
            android:windowSoftInputMode="adjustResize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data
                    android:mimeType="application/zip"
                    android:scheme="content" />
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.webui.WebUIActivity"
            android:autoRemoveFromRecents="true"
            android:configChanges="density|orientation|screenSize|screenLayout|smallestScreenSize|uiMode|locale|layoutDirection|fontScale|keyboard|keyboardHidden"
            android:documentLaunchMode="intoExisting"
            android:exported="false"
            android:taskAffinity="${applicationId}.webui"
            android:theme="@style/Theme.KernelSU.WebUI" />

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths" />
        </provider>
    </application>

</manifest>

```

`manager/app/src/main/aidl/me/weishu/kernelsu/IKsuInterface.aidl`:

```aidl
// IKsuInterface.aidl
package me.weishu.kernelsu;

import android.content.pm.PackageInfo;
import rikka.parcelablelist.ParcelableListSlice;

interface IKsuInterface {
    ParcelableListSlice<PackageInfo> getPackages(int flags);
}
```

`manager/app/src/main/assets/github-markdown.css`:

```css
/* https://raw.githubusercontent.com/sindresorhus/github-markdown-css/gh-pages/github-markdown.css */
.markdown-body {
  --base-size-4: 0.25rem;
  --base-size-8: 0.5rem;
  --base-size-16: 1rem;
  --base-size-24: 1.5rem;
  --base-size-40: 2.5rem;
  --base-text-weight-normal: 400;
  --base-text-weight-medium: 500;
  --base-text-weight-semibold: 600;
  --fontStack-monospace: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  --fgColor-accent: Highlight;
}

[data-theme="dark"] {
  color-scheme: dark;
  --focus-outlineColor: #1f6feb;
  --fgColor-default: #f0f6fc;
  --fgColor-muted: #9198a1;
  --fgColor-accent: #4493f8;
  --fgColor-success: #3fb950;
  --fgColor-attention: #d29922;
  --fgColor-danger: #f85149;
  --fgColor-done: #ab7df8;
  --bgColor-default: #0d1117;
  --bgColor-muted: #151b23;
  --bgColor-neutral-muted: #656c7633;
  --bgColor-attention-muted: #bb800926;
  --borderColor-default: #3d444d;
  --borderColor-muted: #3d444db3;
  --borderColor-neutral-muted: #3d444db3;
  --borderColor-accent-emphasis: #1f6feb;
  --borderColor-success-emphasis: #238636;
  --borderColor-attention-emphasis: #9e6a03;
  --borderColor-danger-emphasis: #da3633;
  --borderColor-done-emphasis: #8957e5;
  --color-prettylights-syntax-comment: #9198a1;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f6fc;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-brackethighlighter-angle: #9198a1;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #f0f6fc;
  --color-prettylights-syntax-markup-bold: #f0f6fc;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #f0f6fc;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #3d444d;
}

[data-theme="light"] {
  color-scheme: light;
  --focus-outlineColor: #0969da;
  --fgColor-default: #1f2328;
  --fgColor-muted: #59636e;
  --fgColor-accent: #0969da;
  --fgColor-success: #1a7f37;
  --fgColor-attention: #9a6700;
  --fgColor-danger: #d1242f;
  --fgColor-done: #8250df;
  --bgColor-default: #ffffff;
  --bgColor-muted: #f6f8fa;
  --bgColor-neutral-muted: #818b981f;
  --bgColor-attention-muted: #fff8c5;
  --borderColor-default: #d1d9e0;
  --borderColor-muted: #d1d9e0b3;
  --borderColor-neutral-muted: #d1d9e0b3;
  --borderColor-accent-emphasis: #0969da;
  --borderColor-success-emphasis: #1a7f37;
  --borderColor-attention-emphasis: #9a6700;
  --borderColor-danger-emphasis: #cf222e;
  --borderColor-done-emphasis: #8250df;
  --color-prettylights-syntax-comment: #59636e;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #1f2328;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-brackethighlighter-angle: #59636e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #1f2328;
  --color-prettylights-syntax-markup-bold: #1f2328;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #d1d9e0;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #818b98;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--fgColor-default);
  background-color: var(--bgColor-default);
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body h1:hover .anchor .octicon-link:before,
.markdown-body h2:hover .anchor .octicon-link:before,
.markdown-body h3:hover .anchor .octicon-link:before,
.markdown-body h4:hover .anchor .octicon-link:before,
.markdown-body h5:hover .anchor .octicon-link:before,
.markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.markdown-body details,
.markdown-body figcaption,
.markdown-body figure {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body [hidden] {
  display: none !important;
}

.markdown-body a {
  background-color: transparent;
  color: var(--fgColor-accent);
  text-decoration: none;
}

.markdown-body abbr[title] {
  border-bottom: none;
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

.markdown-body b,
.markdown-body strong {
  font-weight: var(--base-text-weight-semibold, 600);
}

.markdown-body dfn {
  font-style: italic;
}

.markdown-body h1 {
  margin: .67em 0;
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--borderColor-muted);
}

.markdown-body mark {
  background-color: var(--bgColor-attention-muted);
  color: var(--fgColor-default);
}

.markdown-body small {
  font-size: 90%;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body sup {
  top: -0.5em;
}

.markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.markdown-body figure {
  margin: 1em var(--base-size-40);
}

.markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--borderColor-muted);
  height: .25em;
  padding: 0;
  margin: var(--base-size-24) 0;
  background-color: var(--borderColor-default);
  border: 0;
}

.markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body [type=button],
.markdown-body [type=reset],
.markdown-body [type=submit] {
  -webkit-appearance: button;
  appearance: button;
}

.markdown-body [type=checkbox],
.markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body [type=number]::-webkit-inner-spin-button,
.markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.markdown-body [type=search]::-webkit-search-cancel-button,
.markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  appearance: button;
  font: inherit;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body ::placeholder {
  color: var(--fgColor-muted);
  opacity: 1;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
  font-variant: tabular-nums;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body a:focus,
.markdown-body [role=button]:focus,
.markdown-body input[type=radio]:focus,
.markdown-body input[type=checkbox]:focus {
  outline: 2px solid var(--focus-outlineColor);
  outline-offset: -2px;
  box-shadow: none;
}

.markdown-body a:focus:not(:focus-visible),
.markdown-body [role=button]:focus:not(:focus-visible),
.markdown-body input[type=radio]:focus:not(:focus-visible),
.markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.markdown-body a:focus-visible,
.markdown-body [role=button]:focus-visible,
.markdown-body input[type=radio]:focus-visible,
.markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid var(--focus-outlineColor);
  outline-offset: -2px;
  box-shadow: none;
}

.markdown-body a:not([class]):focus,
.markdown-body a:not([class]):focus-visible,
.markdown-body input[type=radio]:focus,
.markdown-body input[type=radio]:focus-visible,
.markdown-body input[type=checkbox]:focus,
.markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.markdown-body kbd {
  display: inline-block;
  padding: var(--base-size-4);
  font: 11px var(--fontStack-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);
  line-height: 10px;
  color: var(--fgColor-default);
  vertical-align: middle;
  background-color: var(--bgColor-muted);
  border: solid 1px var(--borderColor-neutral-muted);
  border-bottom-color: var(--borderColor-neutral-muted);
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--borderColor-neutral-muted);
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: var(--base-size-24);
  margin-bottom: var(--base-size-16);
  font-weight: var(--base-text-weight-semibold, 600);
  line-height: 1.25;
}

.markdown-body h2 {
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--borderColor-muted);
}

.markdown-body h3 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1.25em;
}

.markdown-body h4 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1em;
}

.markdown-body h5 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .875em;
}

.markdown-body h6 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .85em;
  color: var(--fgColor-muted);
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--fgColor-muted);
  border-left: .25em solid var(--borderColor-default);
}

.markdown-body ul,
.markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body tt,
.markdown-body code,
.markdown-body samp {
  font-family: var(--fontStack-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: var(--fontStack-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);
  font-size: 12px;
  word-wrap: normal;
}

.markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-body input::-webkit-outer-spin-button,
.markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  appearance: none;
}

.markdown-body .mr-2 {
  margin-right: var(--base-size-8, 8px) !important;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .absent {
  color: var(--fgColor-danger);
}

.markdown-body .anchor {
  float: left;
  padding-right: var(--base-size-4);
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body details {
  margin-top: 0;
  margin-bottom: var(--base-size-16);
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: var(--fgColor-default);
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.markdown-body summary h1,
.markdown-body summary h2,
.markdown-body summary h3,
.markdown-body summary h4,
.markdown-body summary h5,
.markdown-body summary h6 {
  display: inline-block;
}

.markdown-body summary h1 .anchor,
.markdown-body summary h2 .anchor,
.markdown-body summary h3 .anchor,
.markdown-body summary h4 .anchor,
.markdown-body summary h5 .anchor,
.markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.markdown-body summary h1,
.markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: var(--base-size-16);
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: var(--base-size-16);
  font-size: 1em;
  font-style: italic;
  font-weight: var(--base-text-weight-semibold, 600);
}

.markdown-body dl dd {
  padding: 0 var(--base-size-16);
  margin-bottom: var(--base-size-16);
}

.markdown-body table th {
  font-weight: var(--base-text-weight-semibold, 600);
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--borderColor-default);
}

.markdown-body table td>:last-child {
  margin-bottom: 0;
}

.markdown-body table tr {
  background-color: var(--bgColor-default);
  border-top: 1px solid var(--borderColor-muted);
}

.markdown-body table tr:nth-child(2n) {
  background-color: var(--bgColor-muted);
}

.markdown-body table img {
  background-color: transparent;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--borderColor-default);
}

.markdown-body span.frame span img {
  display: block;
  float: left;
}

.markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--fgColor-default);
}

.markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.markdown-body span.float-left span {
  margin: 13px 0 0;
}

.markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body code,
.markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: var(--bgColor-neutral-muted);
  border-radius: 6px;
}

.markdown-body code br,
.markdown-body tt br {
  display: none;
}

.markdown-body del code {
  text-decoration: inherit;
}

.markdown-body samp {
  font-size: 85%;
}

.markdown-body pre code {
  font-size: 100%;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: var(--base-size-16);
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: var(--base-size-16);
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: var(--fgColor-default);
  background-color: var(--bgColor-muted);
  border-radius: 6px;
}

.markdown-body pre code,
.markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body .csv-data td,
.markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.markdown-body .csv-data .blob-num {
  padding: 10px var(--base-size-8) 9px;
  text-align: right;
  background: var(--bgColor-default);
  border: 0;
}

.markdown-body .csv-data tr {
  border-top: 0;
}

.markdown-body .csv-data th {
  font-weight: var(--base-text-weight-semibold, 600);
  background: var(--bgColor-muted);
  border-top: 0;
}

.markdown-body [data-footnote-ref]::before {
  content: "[";
}

.markdown-body [data-footnote-ref]::after {
  content: "]";
}

.markdown-body .footnotes {
  font-size: 12px;
  color: var(--fgColor-muted);
  border-top: 1px solid var(--borderColor-default);
}

.markdown-body .footnotes ol {
  padding-left: var(--base-size-16);
}

.markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: var(--base-size-16);
  margin-top: var(--base-size-16);
}

.markdown-body .footnotes li {
  position: relative;
}

.markdown-body .footnotes li:target::before {
  position: absolute;
  top: calc(var(--base-size-8)*-1);
  right: calc(var(--base-size-8)*-1);
  bottom: calc(var(--base-size-8)*-1);
  left: calc(var(--base-size-24)*-1);
  pointer-events: none;
  content: "";
  border: 2px solid var(--borderColor-accent-emphasis);
  border-radius: 6px;
}

.markdown-body .footnotes li:target {
  color: var(--fgColor-default);
}

.markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.markdown-body body:has(:modal) {
  padding-right: var(--dialog-scrollgutter) !important;
}

.markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.markdown-body [role=button]:focus:not(:focus-visible),
.markdown-body [role=tabpanel][tabindex="0"]:focus:not(:focus-visible),
.markdown-body button:focus:not(:focus-visible),
.markdown-body summary:focus:not(:focus-visible),
.markdown-body a:focus:not(:focus-visible) {
  outline: none;
  box-shadow: none;
}

.markdown-body [tabindex="0"]:focus:not(:focus-visible),
.markdown-body details-dialog:focus:not(:focus-visible) {
  outline: none;
}

.markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: var(--base-text-weight-normal, 400);
  line-height: 1;
  vertical-align: -0.075em;
}

.markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item label {
  font-weight: var(--base-text-weight-normal, 400);
}

.markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: var(--base-size-4);
}

.markdown-body .task-list-item .handle {
  display: none;
}

.markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.markdown-body ul:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.markdown-body ol:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.markdown-body .contains-task-list:hover .task-list-item-convert-container,
.markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}

.markdown-body .markdown-alert {
  padding: var(--base-size-8) var(--base-size-16);
  margin-bottom: var(--base-size-16);
  color: inherit;
  border-left: .25em solid var(--borderColor-default);
}

.markdown-body .markdown-alert>:first-child {
  margin-top: 0;
}

.markdown-body .markdown-alert>:last-child {
  margin-bottom: 0;
}

.markdown-body .markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: var(--base-text-weight-medium, 500);
  align-items: center;
  line-height: 1;
}

.markdown-body .markdown-alert.markdown-alert-note {
  border-left-color: var(--borderColor-accent-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--fgColor-accent);
}

.markdown-body .markdown-alert.markdown-alert-important {
  border-left-color: var(--borderColor-done-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--fgColor-done);
}

.markdown-body .markdown-alert.markdown-alert-warning {
  border-left-color: var(--borderColor-attention-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--fgColor-attention);
}

.markdown-body .markdown-alert.markdown-alert-tip {
  border-left-color: var(--borderColor-success-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--fgColor-success);
}

.markdown-body .markdown-alert.markdown-alert-caution {
  border-left-color: var(--borderColor-danger-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--fgColor-danger);
}

.markdown-body>*:first-child>.heading-element:first-child {
  margin-top: 0 !important;
}

.markdown-body .highlight pre:has(+.zeroclipboard-container) {
  min-height: 52px;
}

```

`manager/app/src/main/cpp/CMakeLists.txt`:

```txt

# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.
cmake_minimum_required(VERSION 3.18.1)

project("kernelsu")

find_package(cxx REQUIRED CONFIG)
link_libraries(cxx::cxx)

add_library(kernelsu
        SHARED
        jni.cc
        ksu.cc
        )

find_library(log-lib log)

target_link_libraries(kernelsu ${log-lib})
```

`manager/app/src/main/cpp/jni.cc`:

```cc
#include <jni.h>

#include <sys/prctl.h>
#include <linux/capability.h>
#include <pwd.h>

#include <android/log.h>
#include <cstring>

#include "ksu.h"

#define LOG_TAG "KernelSU"
#ifdef NDEBUG
#define LOGD(...) (void)0
#else
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#endif

extern "C"
JNIEXPORT jint JNICALL
Java_me_weishu_kernelsu_Natives_getVersion(JNIEnv *env, jobject) {
    int version = get_version();
    if (version > 0) {
        return version;
    }
    // try legacy method as fallback
    return legacy_get_info().first;
}

extern "C"
JNIEXPORT jint JNICALL
Java_me_weishu_kernelsu_Natives_getSuperuserCount(JNIEnv *env, jobject) {
    struct ksu_new_get_allow_list_cmd cmd = {
        .count = 0
    };
    bool result = get_allow_list(&cmd);
    return result ? cmd.total_count : 0;
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_isSafeMode(JNIEnv *env, jclass clazz) {
    return is_safe_mode();
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_isLkmMode(JNIEnv *env, jclass clazz) {
    return is_lkm_mode();
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_isManager(JNIEnv *env, jclass clazz) {
    return is_manager();
}

static void fillIntArray(JNIEnv *env, jobject list, int *data, int count) {
    auto cls = env->GetObjectClass(list);
    auto add = env->GetMethodID(cls, "add", "(Ljava/lang/Object;)Z");
    auto integerCls = env->FindClass("java/lang/Integer");
    auto constructor = env->GetMethodID(integerCls, "<init>", "(I)V");
    for (int i = 0; i < count; ++i) {
        auto integer = env->NewObject(integerCls, constructor, data[i]);
        env->CallBooleanMethod(list, add, integer);
    }
}

static void addIntToList(JNIEnv *env, jobject list, int ele) {
    auto cls = env->GetObjectClass(list);
    auto add = env->GetMethodID(cls, "add", "(Ljava/lang/Object;)Z");
    auto integerCls = env->FindClass("java/lang/Integer");
    auto constructor = env->GetMethodID(integerCls, "<init>", "(I)V");
    auto integer = env->NewObject(integerCls, constructor, ele);
    env->CallBooleanMethod(list, add, integer);
}

static uint64_t capListToBits(JNIEnv *env, jobject list) {
    auto cls = env->GetObjectClass(list);
    auto get = env->GetMethodID(cls, "get", "(I)Ljava/lang/Object;");
    auto size = env->GetMethodID(cls, "size", "()I");
    auto listSize = env->CallIntMethod(list, size);
    auto integerCls = env->FindClass("java/lang/Integer");
    auto intValue = env->GetMethodID(integerCls, "intValue", "()I");
    uint64_t result = 0;
    for (int i = 0; i < listSize; ++i) {
        auto integer = env->CallObjectMethod(list, get, i);
        int data = env->CallIntMethod(integer, intValue);

        if (cap_valid(data)) {
            result |= (1ULL << data);
        }
    }

    return result;
}

static int getListSize(JNIEnv *env, jobject list) {
    auto cls = env->GetObjectClass(list);
    auto size = env->GetMethodID(cls, "size", "()I");
    return env->CallIntMethod(list, size);
}

static void fillArrayWithList(JNIEnv *env, jobject list, int *data, int count) {
    auto cls = env->GetObjectClass(list);
    auto get = env->GetMethodID(cls, "get", "(I)Ljava/lang/Object;");
    auto integerCls = env->FindClass("java/lang/Integer");
    auto intValue = env->GetMethodID(integerCls, "intValue", "()I");
    for (int i = 0; i < count; ++i) {
        auto integer = env->CallObjectMethod(list, get, i);
        data[i] = env->CallIntMethod(integer, intValue);
    }
}

extern "C"
JNIEXPORT jobject JNICALL
Java_me_weishu_kernelsu_Natives_getAppProfile(JNIEnv *env, jobject, jstring pkg, jint uid) {
    if (env->GetStringLength(pkg) > KSU_MAX_PACKAGE_NAME) {
        return nullptr;
    }

    p_key_t key = {};
    auto cpkg = env->GetStringUTFChars(pkg, nullptr);
    strcpy(key, cpkg);
    env->ReleaseStringUTFChars(pkg, cpkg);

    app_profile profile = {};
    profile.version = KSU_APP_PROFILE_VER;

    strcpy(profile.key, key);
    profile.current_uid = uid;

    bool useDefaultProfile = get_app_profile(&profile) != 0;

    auto cls = env->FindClass("me/weishu/kernelsu/Natives$Profile");
    auto constructor = env->GetMethodID(cls, "<init>", "()V");
    auto obj = env->NewObject(cls, constructor);
    auto keyField = env->GetFieldID(cls, "name", "Ljava/lang/String;");
    auto currentUidField = env->GetFieldID(cls, "currentUid", "I");
    auto allowSuField = env->GetFieldID(cls, "allowSu", "Z");

    auto rootUseDefaultField = env->GetFieldID(cls, "rootUseDefault", "Z");
    auto rootTemplateField = env->GetFieldID(cls, "rootTemplate", "Ljava/lang/String;");

    auto uidField = env->GetFieldID(cls, "uid", "I");
    auto gidField = env->GetFieldID(cls, "gid", "I");
    auto groupsField = env->GetFieldID(cls, "groups", "Ljava/util/List;");
    auto capabilitiesField = env->GetFieldID(cls, "capabilities", "Ljava/util/List;");
    auto domainField = env->GetFieldID(cls, "context", "Ljava/lang/String;");
    auto namespacesField = env->GetFieldID(cls, "namespace", "I");

    auto nonRootUseDefaultField = env->GetFieldID(cls, "nonRootUseDefault", "Z");
    auto umountModulesField = env->GetFieldID(cls, "umountModules", "Z");

    env->SetObjectField(obj, keyField, env->NewStringUTF(profile.key));
    env->SetIntField(obj, currentUidField, profile.current_uid);

    if (useDefaultProfile) {
        // no profile found, so just use default profile:
        // don't allow root and use default profile!
        LOGD("use default profile for: %s, %d", key, uid);

        // allow_su = false
        // non root use default = true
        env->SetBooleanField(obj, allowSuField, false);
        env->SetBooleanField(obj, nonRootUseDefaultField, true);

        return obj;
    }

    auto allowSu = profile.allow_su;

    if (allowSu) {
        env->SetBooleanField(obj, rootUseDefaultField, (jboolean) profile.rp_config.use_default);
        if (strlen(profile.rp_config.template_name) > 0) {
            env->SetObjectField(obj, rootTemplateField,
                    env->NewStringUTF(profile.rp_config.template_name));
        }

        env->SetIntField(obj, uidField, profile.rp_config.profile.uid);
        env->SetIntField(obj, gidField, profile.rp_config.profile.gid);

        jobject groupList = env->GetObjectField(obj, groupsField);
        int groupCount = profile.rp_config.profile.groups_count;
        if (groupCount > KSU_MAX_GROUPS) {
            LOGD("kernel group count too large: %d???", groupCount);
            groupCount = KSU_MAX_GROUPS;
        }
        fillIntArray(env, groupList, profile.rp_config.profile.groups, groupCount);

        jobject capList = env->GetObjectField(obj, capabilitiesField);
        for (int i = 0; i <= CAP_LAST_CAP; i++) {
            if (profile.rp_config.profile.capabilities.effective & (1ULL << i)) {
                addIntToList(env, capList, i);
            }
        }

        env->SetObjectField(obj, domainField,
                env->NewStringUTF(profile.rp_config.profile.selinux_domain));
        env->SetIntField(obj, namespacesField, profile.rp_config.profile.namespaces);
        env->SetBooleanField(obj, allowSuField, profile.allow_su);
    } else {
        env->SetBooleanField(obj, nonRootUseDefaultField,
                (jboolean) profile.nrp_config.use_default);
        env->SetBooleanField(obj, umountModulesField, profile.nrp_config.profile.umount_modules);
    }

    return obj;
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_setAppProfile(JNIEnv *env, jobject clazz, jobject profile) {
    auto cls = env->FindClass("me/weishu/kernelsu/Natives$Profile");

    auto keyField = env->GetFieldID(cls, "name", "Ljava/lang/String;");
    auto currentUidField = env->GetFieldID(cls, "currentUid", "I");
    auto allowSuField = env->GetFieldID(cls, "allowSu", "Z");

    auto rootUseDefaultField = env->GetFieldID(cls, "rootUseDefault", "Z");
    auto rootTemplateField = env->GetFieldID(cls, "rootTemplate", "Ljava/lang/String;");

    auto uidField = env->GetFieldID(cls, "uid", "I");
    auto gidField = env->GetFieldID(cls, "gid", "I");
    auto groupsField = env->GetFieldID(cls, "groups", "Ljava/util/List;");
    auto capabilitiesField = env->GetFieldID(cls, "capabilities", "Ljava/util/List;");
    auto domainField = env->GetFieldID(cls, "context", "Ljava/lang/String;");
    auto namespacesField = env->GetFieldID(cls, "namespace", "I");

    auto nonRootUseDefaultField = env->GetFieldID(cls, "nonRootUseDefault", "Z");
    auto umountModulesField = env->GetFieldID(cls, "umountModules", "Z");

    auto key = env->GetObjectField(profile, keyField);
    if (!key) {
        return false;
    }
    if (env->GetStringLength((jstring) key) > KSU_MAX_PACKAGE_NAME) {
        return false;
    }

    auto cpkg = env->GetStringUTFChars((jstring) key, nullptr);
    p_key_t p_key = {};
    strcpy(p_key, cpkg);
    env->ReleaseStringUTFChars((jstring) key, cpkg);

    auto currentUid = env->GetIntField(profile, currentUidField);

    auto uid = env->GetIntField(profile, uidField);
    auto gid = env->GetIntField(profile, gidField);
    auto groups = env->GetObjectField(profile, groupsField);
    auto capabilities = env->GetObjectField(profile, capabilitiesField);
    auto domain = env->GetObjectField(profile, domainField);
    auto allowSu = env->GetBooleanField(profile, allowSuField);
    auto umountModules = env->GetBooleanField(profile, umountModulesField);

    app_profile p = {};
    p.version = KSU_APP_PROFILE_VER;

    strcpy(p.key, p_key);
    p.allow_su = allowSu;
    p.current_uid = currentUid;

    if (allowSu) {
        p.rp_config.use_default = env->GetBooleanField(profile, rootUseDefaultField);
        auto templateName = env->GetObjectField(profile, rootTemplateField);
        if (templateName) {
            auto ctemplateName = env->GetStringUTFChars((jstring) templateName, nullptr);
            strcpy(p.rp_config.template_name, ctemplateName);
            env->ReleaseStringUTFChars((jstring) templateName, ctemplateName);
        }

        p.rp_config.profile.uid = uid;
        p.rp_config.profile.gid = gid;

        int groups_count = getListSize(env, groups);
        if (groups_count > KSU_MAX_GROUPS) {
            LOGD("groups count too large: %d", groups_count);
            return false;
        }
        p.rp_config.profile.groups_count = groups_count;
        fillArrayWithList(env, groups, p.rp_config.profile.groups, groups_count);

        p.rp_config.profile.capabilities.effective = capListToBits(env, capabilities);

        auto cdomain = env->GetStringUTFChars((jstring) domain, nullptr);
        strcpy(p.rp_config.profile.selinux_domain, cdomain);
        env->ReleaseStringUTFChars((jstring) domain, cdomain);

        p.rp_config.profile.namespaces = env->GetIntField(profile, namespacesField);
    } else {
        p.nrp_config.use_default = env->GetBooleanField(profile, nonRootUseDefaultField);
        p.nrp_config.profile.umount_modules = umountModules;
    }

    return set_app_profile(&p);
}
extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_uidShouldUmount(JNIEnv *env, jobject thiz, jint uid) {
    return uid_should_umount(uid);
}
extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_isSuEnabled(JNIEnv *env, jobject thiz) {
    return is_su_enabled();
}
extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_setSuEnabled(JNIEnv *env, jobject thiz, jboolean enabled) {
    return set_su_enabled(enabled);
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_isKernelUmountEnabled(JNIEnv *env, jobject thiz) {
    return is_kernel_umount_enabled();
}

extern "C"
JNIEXPORT jboolean JNICALL
Java_me_weishu_kernelsu_Natives_setKernelUmountEnabled(JNIEnv *env, jobject thiz, jboolean enabled) {
    return set_kernel_umount_enabled(enabled);
}

extern "C"
JNIEXPORT jstring JNICALL
Java_me_weishu_kernelsu_Natives_getUserName(JNIEnv *env, jobject thiz, jint uid) {
    struct passwd *pw = getpwuid((uid_t) uid);
    if (pw && pw->pw_name && pw->pw_name[0] != '\0') {
        return env->NewStringUTF(pw->pw_name);
    }
    return nullptr;
}

```

`manager/app/src/main/cpp/ksu.cc`:

```cc
//
// Created by weishu on 2022/12/9.
//

#include <sys/prctl.h>
#include <cstdint>
#include <cstring>
#include <cstdio>
#include <unistd.h>
#include <utility>
#include <android/log.h>
#include <dirent.h>
#include <cstdlib>

#include <unistd.h>
#include <climits>
#include <sys/syscall.h>
#include "ksu.h"

static int fd = -1;

static inline int scan_driver_fd() {
    const char *kName = "[ksu_driver]";
    DIR *dir = opendir("/proc/self/fd");
    if (!dir) {
        return -1;
    }

    int found = -1;
    struct dirent *de;
    char path[64];
    char target[PATH_MAX];

    while ((de = readdir(dir)) != NULL) {
        if (de->d_name[0] == '.') {
            continue;
        }

        char *endptr = NULL;
        long fd_long = strtol(de->d_name, &endptr, 10);
        if (!de->d_name[0] || *endptr != '\0' || fd_long < 0 || fd_long > INT_MAX) {
            continue;
        }

        snprintf(path, sizeof(path), "/proc/self/fd/%s", de->d_name);
        ssize_t n = readlink(path, target, sizeof(target) - 1);
        if (n < 0) {
            continue;
        }
        target[n] = '\0';

        const char *base = strrchr(target, '/');
        base = base ? base + 1 : target;

        if (strstr(base, kName)) {
            found = (int)fd_long;
            break;
        }
    }

    closedir(dir);
    return found;
}

template<typename... Args>
static int ksuctl(unsigned long op, Args &&... args) {

    if (fd < 0) {
        fd = scan_driver_fd();
    }

    static_assert(sizeof...(Args) <= 1, "ioctl expects at most one extra argument");

    return ioctl(fd, op, std::forward<Args>(args)...);
}

static struct ksu_get_info_cmd g_version {};

struct ksu_get_info_cmd get_info() {
    if (!g_version.version) {
        ksuctl(KSU_IOCTL_GET_INFO, &g_version);
    }
    return g_version;
}

uint32_t get_version() {
    auto info = get_info();
    return info.version;
}

bool get_allow_list(struct ksu_new_get_allow_list_cmd *cmd) {
    return ksuctl(KSU_IOCTL_NEW_GET_ALLOW_LIST, cmd) == 0;
}

bool is_safe_mode() {
    struct ksu_check_safemode_cmd cmd = {};
    ksuctl(KSU_IOCTL_CHECK_SAFEMODE, &cmd);
    return cmd.in_safe_mode;
}

bool is_lkm_mode() {
    auto info = get_info();
    if (info.version > 0) {
        return (info.flags & 0x1) != 0;
    }
    return (legacy_get_info().second & 0x1) != 0;
}

bool is_manager() {
    auto info = get_info();
    if (info.version > 0) {
        return (info.flags & 0x2) != 0;
    }
    return legacy_get_info().first > 0;
}

bool uid_should_umount(int uid) {
    struct ksu_uid_should_umount_cmd cmd = {};
    cmd.uid = uid;
    ksuctl(KSU_IOCTL_UID_SHOULD_UMOUNT, &cmd);
    return cmd.should_umount;
}

bool set_app_profile(const app_profile *profile) {
    struct ksu_set_app_profile_cmd cmd = {};
    cmd.profile = *profile;
    return ksuctl(KSU_IOCTL_SET_APP_PROFILE, &cmd) == 0;
}

int get_app_profile(app_profile *profile) {
    struct ksu_get_app_profile_cmd cmd = {.profile = *profile};
    int ret = ksuctl(KSU_IOCTL_GET_APP_PROFILE, &cmd);
    *profile = cmd.profile;
    return ret;
}

bool set_su_enabled(bool enabled) {
    struct ksu_set_feature_cmd cmd = {};
    cmd.feature_id = KSU_FEATURE_SU_COMPAT;
    cmd.value = enabled ? 1 : 0;
    return ksuctl(KSU_IOCTL_SET_FEATURE, &cmd) == 0;
}

bool is_su_enabled() {
    struct ksu_get_feature_cmd cmd = {};
    cmd.feature_id = KSU_FEATURE_SU_COMPAT;
    if (ksuctl(KSU_IOCTL_GET_FEATURE, &cmd) != 0) {
        return false;
    }
    if (!cmd.supported) {
        return false;
    }
    return cmd.value != 0;
}

static inline bool get_feature(uint32_t feature_id, uint64_t *out_value, bool *out_supported) {
    struct ksu_get_feature_cmd cmd = {};
    cmd.feature_id = feature_id;
    if (ksuctl(KSU_IOCTL_GET_FEATURE, &cmd) != 0) {
        return false;
    }
    if (out_value) *out_value = cmd.value;
    if (out_supported) *out_supported = cmd.supported;
    return true;
}

static inline bool set_feature(uint32_t feature_id, uint64_t value) {
    struct ksu_set_feature_cmd cmd = {};
    cmd.feature_id = feature_id;
    cmd.value = value;
    return ksuctl(KSU_IOCTL_SET_FEATURE, &cmd) == 0;
}

bool set_kernel_umount_enabled(bool enabled) {
    return set_feature(KSU_FEATURE_KERNEL_UMOUNT, enabled ? 1 : 0);
}

bool is_kernel_umount_enabled() {
    uint64_t value = 0;
    bool supported = false;
    if (!get_feature(KSU_FEATURE_KERNEL_UMOUNT, &value, &supported)) {
        return false;
    }
    if (!supported) {
        return false;
    }
    return value != 0;
}

```

`manager/app/src/main/cpp/ksu.h`:

```h
//
// Created by weishu on 2022/12/9.
//

#ifndef KERNELSU_KSU_H
#define KERNELSU_KSU_H

#include <cstdint>
#include <sys/ioctl.h>
#include <utility>

uint32_t get_version();

bool uid_should_umount(int uid);

bool is_safe_mode();

bool is_lkm_mode();

bool is_manager();

#define KSU_APP_PROFILE_VER 2
#define KSU_MAX_PACKAGE_NAME 256
// NGROUPS_MAX for Linux is 65535 generally, but we only supports 32 groups.
#define KSU_MAX_GROUPS 32
#define KSU_SELINUX_DOMAIN 64

using p_key_t = char[KSU_MAX_PACKAGE_NAME];

struct root_profile {
    int32_t uid;
    int32_t gid;

    int32_t groups_count;
    int32_t groups[KSU_MAX_GROUPS];

    // kernel_cap_t is u32[2] for capabilities v3
    struct {
        uint64_t effective;
        uint64_t permitted;
        uint64_t inheritable;
    } capabilities;

    char selinux_domain[KSU_SELINUX_DOMAIN];

    int32_t namespaces;
};

struct non_root_profile {
    bool umount_modules;
};

struct app_profile {
    // It may be utilized for backward compatibility, although we have never explicitly made any promises regarding this.
    uint32_t version;

    // this is usually the package of the app, but can be other value for special apps
    char key[KSU_MAX_PACKAGE_NAME];
    int32_t current_uid;
    bool allow_su;

    union {
        struct {
            bool use_default;
            char template_name[KSU_MAX_PACKAGE_NAME];

            struct root_profile profile;
        } rp_config;

        struct {
            bool use_default;

            struct non_root_profile profile;
        } nrp_config;
    };
};

bool set_app_profile(const app_profile *profile);

int get_app_profile(app_profile *profile);

// Feature IDs
enum ksu_feature_id {
    KSU_FEATURE_SU_COMPAT = 0,
    KSU_FEATURE_KERNEL_UMOUNT = 1,
};

// Generic feature API
struct ksu_get_feature_cmd {
    uint32_t feature_id; // Input: feature ID
    uint64_t value;      // Output: feature value/state
    uint8_t supported;   // Output: whether the feature is supported
};

struct ksu_set_feature_cmd {
    uint32_t feature_id; // Input: feature ID
    uint64_t value;      // Input: feature value/state to set
};

struct ksu_become_daemon_cmd {
    uint8_t token[65]; // Input: daemon token (null-terminated)
};

struct ksu_get_info_cmd {
    uint32_t version; // Output: KERNEL_SU_VERSION
    uint32_t flags;   // Output: flags (bit 0: MODULE mode)
    uint32_t features; // Output: max feature ID supported (KSU_FEATURE_MAX)
};

struct ksu_report_event_cmd {
    uint32_t event; // Input: EVENT_POST_FS_DATA, EVENT_BOOT_COMPLETED, etc.
};

struct ksu_set_sepolicy_cmd {
    uint64_t cmd; // Input: sepolicy command
    uint64_t arg; // Input: sepolicy argument pointer
};

struct ksu_check_safemode_cmd {
    uint8_t in_safe_mode; // Output: true if in safe mode, false otherwise
};

struct ksu_new_get_allow_list_cmd {
    uint16_t count; // Input / Output: number of UIDs in array
    uint16_t total_count; // Output: total number of UIDs in requested list
    uint32_t uids[0]; // Output: array of allowed/denied UIDs
};

struct ksu_uid_granted_root_cmd {
    uint32_t uid; // Input: target UID to check
    uint8_t granted; // Output: true if granted, false otherwise
};

struct ksu_uid_should_umount_cmd {
    uint32_t uid; // Input: target UID to check
    uint8_t should_umount; // Output: true if should umount, false otherwise
};

struct ksu_get_manager_appid_cmd {
    uint32_t appid; // Output: manager app id
};

struct ksu_get_app_profile_cmd {
    struct app_profile profile; // Input/Output: app profile structure
};

struct ksu_set_app_profile_cmd {
    struct app_profile profile; // Input: app profile structure
};

// Su compat
bool set_su_enabled(bool enabled);

bool is_su_enabled();

// Kernel umount
bool set_kernel_umount_enabled(bool enabled);

bool is_kernel_umount_enabled();

// IOCTL command definitions
#define KSU_IOCTL_GRANT_ROOT _IOC(_IOC_NONE, 'K', 1, 0)
#define KSU_IOCTL_GET_INFO _IOC(_IOC_READ, 'K', 2, 0)
#define KSU_IOCTL_REPORT_EVENT _IOC(_IOC_WRITE, 'K', 3, 0)
#define KSU_IOCTL_SET_SEPOLICY _IOC(_IOC_READ|_IOC_WRITE, 'K', 4, 0)
#define KSU_IOCTL_CHECK_SAFEMODE _IOC(_IOC_READ, 'K', 5, 0)
#define KSU_IOCTL_NEW_GET_ALLOW_LIST _IOWR('K', 6, struct ksu_new_get_allow_list_cmd)
#define KSU_IOCTL_NEW_GET_DENY_LIST _IOWR('K', 7, struct ksu_new_get_allow_list_cmd)
#define KSU_IOCTL_UID_GRANTED_ROOT _IOC(_IOC_READ|_IOC_WRITE, 'K', 8, 0)
#define KSU_IOCTL_UID_SHOULD_UMOUNT _IOC(_IOC_READ|_IOC_WRITE, 'K', 9, 0)
#define KSU_IOCTL_GET_MANAGER_APPID _IOC(_IOC_READ, 'K', 10, 0)
#define KSU_IOCTL_GET_APP_PROFILE _IOC(_IOC_READ|_IOC_WRITE, 'K', 11, 0)
#define KSU_IOCTL_SET_APP_PROFILE _IOC(_IOC_WRITE, 'K', 12, 0)
#define KSU_IOCTL_GET_FEATURE _IOC(_IOC_READ|_IOC_WRITE, 'K', 13, 0)
#define KSU_IOCTL_SET_FEATURE _IOC(_IOC_WRITE, 'K', 14, 0)

bool get_allow_list(struct ksu_new_get_allow_list_cmd *);

inline std::pair<int, int> legacy_get_info() {
    int32_t version = -1;
    int32_t flags = 0;
    int32_t result = 0;
    prctl(0xDEADBEEF, 2, &version, &flags, &result);
    return {version, flags};
}

#endif //KERNELSU_KSU_H

```

`manager/app/src/main/java/me/weishu/kernelsu/KernelSUApplication.kt`:

```kt
package me.weishu.kernelsu

import android.app.Application
import android.content.pm.ApplicationInfo
import android.os.Build
import android.system.Os
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.ViewModelStore
import androidx.lifecycle.ViewModelStoreOwner
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel
import okhttp3.Cache
import okhttp3.OkHttpClient
import org.lsposed.hiddenapibypass.HiddenApiBypass
import java.io.File
import java.util.Locale

lateinit var ksuApp: KernelSUApplication

class KernelSUApplication : Application(), ViewModelStoreOwner {

    companion object {
        fun setEnableOnBackInvokedCallback(appInfo: ApplicationInfo, enable: Boolean) {
            runCatching {
                val applicationInfoClass = ApplicationInfo::class.java
                val method = applicationInfoClass.getDeclaredMethod("setEnableOnBackInvokedCallback", Boolean::class.javaPrimitiveType)
                method.isAccessible = true
                method.invoke(appInfo, enable)
            }
        }
    }

    lateinit var okhttpClient: OkHttpClient
    private val appViewModelStore by lazy { ViewModelStore() }

    override fun onCreate() {
        super.onCreate()
        ksuApp = this

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            val prefs = this.getSharedPreferences("settings", MODE_PRIVATE)
            val enable = prefs.getBoolean("enable_predictive_back", false)
            HiddenApiBypass.addHiddenApiExemptions("Landroid/content/pm/ApplicationInfo;->setEnableOnBackInvokedCallback")
            setEnableOnBackInvokedCallback(applicationInfo, enable)
        }

        val superUserViewModel = ViewModelProvider(this)[SuperUserViewModel::class.java]
        superUserViewModel.loadAppList()

        val webroot = File(dataDir, "webroot")
        if (!webroot.exists()) {
            webroot.mkdir()
        }

        // Provide working env for rust's temp_dir()
        Os.setenv("TMPDIR", cacheDir.absolutePath, true)

        okhttpClient =
            OkHttpClient.Builder().cache(Cache(File(cacheDir, "okhttp"), 10 * 1024 * 1024))
                .addInterceptor { block ->
                    block.proceed(
                        block.request().newBuilder()
                            .header("User-Agent", "KernelSU/${BuildConfig.VERSION_CODE}")
                            .header("Accept-Language", Locale.getDefault().toLanguageTag()).build()
                    )
                }.build()
    }

    override val viewModelStore: ViewModelStore
        get() = appViewModelStore
}

```

`manager/app/src/main/java/me/weishu/kernelsu/Kernels.kt`:

```kt
package me.weishu.kernelsu

import android.system.Os

/**
 * @author weishu
 * @date 2022/12/10.
 */

data class KernelVersion(val major: Int, val patchLevel: Int, val subLevel: Int) {
    override fun toString(): String {
        return "$major.$patchLevel.$subLevel"
    }

    fun isGKI(): Boolean {

        // kernel 6.x
        if (major > 5) {
            return true
        }

        // kernel 5.10.x
        if (major == 5) {
            return patchLevel >= 10
        }

        return false
    }
}

fun parseKernelVersion(version: String): KernelVersion {
    val find = "(\\d+)\\.(\\d+)\\.(\\d+)".toRegex().find(version)
    return if (find != null) {
        KernelVersion(find.groupValues[1].toInt(), find.groupValues[2].toInt(), find.groupValues[3].toInt())
    } else {
        KernelVersion(-1, -1, -1)
    }
}

fun getKernelVersion(): KernelVersion {
    Os.uname().release.let {
        return parseKernelVersion(it)
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/Natives.kt`:

```kt
package me.weishu.kernelsu

import android.os.Parcelable
import androidx.annotation.Keep
import androidx.compose.runtime.Immutable
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.Serializable

/**
 * @author weishu
 * @date 2022/12/8.
 */
object Natives {
    // minimal supported kernel version
    // 10915: allowlist breaking change, add app profile
    // 10931: app profile struct add 'version' field
    // 10946: add capabilities
    // 10977: change groups_count and groups to avoid overflow write
    // 11071: Fix the issue of failing to set a custom SELinux type.
    // 12143: breaking: new supercall impl
    // 32310: new get_allow_list ioctl
    const val MINIMAL_SUPPORTED_KERNEL = 32310

    const val KERNEL_SU_DOMAIN = "u:r:su:s0"

    const val ROOT_UID = 0
    const val ROOT_GID = 0

    init {
        System.loadLibrary("kernelsu")
    }

    val version: Int
        external get

    val isSafeMode: Boolean
        external get

    val isLkmMode: Boolean
        external get

    val isManager: Boolean
        external get

    external fun uidShouldUmount(uid: Int): Boolean

    /**
     * Get the profile of the given package.
     * @param key usually the package name
     * @return return null if failed.
     */
    external fun getAppProfile(key: String?, uid: Int): Profile
    external fun setAppProfile(profile: Profile?): Boolean

    /**
     * `su` compat mode can be disabled temporarily.
     *  0: disabled
     *  1: enabled
     *  negative : error
     */
    external fun isSuEnabled(): Boolean
    external fun setSuEnabled(enabled: Boolean): Boolean

    /**
     * Kernel module umount can be disabled temporarily.
     *  0: disabled
     *  1: enabled
     *  negative : error
     */
    external fun isKernelUmountEnabled(): Boolean
    external fun setKernelUmountEnabled(enabled: Boolean): Boolean

    /**
     * Get the user name for the uid.
     */
    external fun getUserName(uid: Int): String?

    external fun getSuperuserCount(): Int

    private const val NON_ROOT_DEFAULT_PROFILE_KEY = "$"
    private const val NOBODY_UID = 9999

    fun setDefaultUmountModules(umountModules: Boolean): Boolean {
        Profile(
            NON_ROOT_DEFAULT_PROFILE_KEY,
            NOBODY_UID,
            false,
            umountModules = umountModules
        ).let {
            return setAppProfile(it)
        }
    }

    fun isDefaultUmountModules(): Boolean {
        getAppProfile(NON_ROOT_DEFAULT_PROFILE_KEY, NOBODY_UID).let {
            return it.umountModules
        }
    }

    fun requireNewKernel(): Boolean {
        return version != -1 && version < MINIMAL_SUPPORTED_KERNEL
    }

    @Keep
    @Immutable
    @Parcelize
    @Serializable
    data class Profile(
        // and there is a default profile for root and non-root
        val name: String,
        // current uid for the package, this is convivent for kernel to check
        // if the package name doesn't match uid, then it should be invalidated.
        val currentUid: Int = 0,

        // if this is true, kernel will grant root permission to this package
        val allowSu: Boolean = false,

        // these are used for root profile
        val rootUseDefault: Boolean = true,
        val rootTemplate: String? = null,
        val uid: Int = ROOT_UID,
        val gid: Int = ROOT_GID,
        val groups: List<Int> = mutableListOf(),
        val capabilities: List<Int> = mutableListOf(),
        val context: String = KERNEL_SU_DOMAIN,
        val namespace: Int = Namespace.INHERITED.ordinal,

        val nonRootUseDefault: Boolean = true,
        val umountModules: Boolean = true,
        var rules: String = "", // this field is save in ksud!!
    ) : Parcelable {
        enum class Namespace {
            INHERITED,
            GLOBAL,
            INDIVIDUAL,
        }

        constructor() : this("")
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/profile/Capabilities.kt`:

```kt
package me.weishu.kernelsu.profile

/**
 * @author weishu
 * @date 2023/6/3.
 */
enum class Capabilities(val cap: Int, val display: String, val desc: String) {
    CAP_CHOWN(0, "CHOWN", "Make arbitrary changes to file UIDs and GIDs (see chown(2))"),
    CAP_DAC_OVERRIDE(1, "DAC_OVERRIDE", "Bypass file read, write, and execute permission checks"),
    CAP_DAC_READ_SEARCH(2, "DAC_READ_SEARCH", "Bypass file read permission checks and directory read and execute permission checks"),
    CAP_FOWNER(3, "FOWNER", "Bypass permission checks on operations that normally require the filesystem UID of the process to match the UID of the file (e.g., chmod(2), utime(2)), excluding those operations covered by CAP_DAC_OVERRIDE and CAP_DAC_READ_SEARCH"),
    CAP_FSETID(4, "FSETID", "Don’t clear set-user-ID and set-group-ID permission bits when a file is modified; set the set-group-ID bit for a file whose GID does not match the filesystem or any of the supplementary GIDs of the calling process"),
    CAP_KILL(5, "KILL", "Bypass permission checks for sending signals (see kill(2))."),
    CAP_SETGID(6, "SETGID", "Make arbitrary manipulations of process GIDs and supplementary GID list; allow setgid(2) manipulation of the caller’s effective and real group IDs"),
    CAP_SETUID(7, "SETUID", "Make arbitrary manipulations of process UIDs (setuid(2), setreuid(2), setresuid(2), setfsuid(2)); allow changing the current process user IDs; allow changing of the current process group ID to any value in the system’s range of legal group IDs"),
    CAP_SETPCAP(8, "SETPCAP", "If file capabilities are supported: grant or remove any capability in the caller’s permitted capability set to or from any other process. (This property supersedes the obsolete notion of giving a process all capabilities by granting all capabilities in its permitted set, and of removing all capabilities from a process by granting no capabilities in its permitted set. It does not permit any actions that were not permitted before.)"),
    CAP_LINUX_IMMUTABLE(9, "LINUX_IMMUTABLE", "Set the FS_APPEND_FL and FS_IMMUTABLE_FL inode flags (see chattr(1))."),
    CAP_NET_BIND_SERVICE(10, "NET_BIND_SERVICE", "Bind a socket to Internet domain"),
    CAP_NET_BROADCAST(11, "NET_BROADCAST", "Make socket broadcasts, and listen to multicasts"),
    CAP_NET_ADMIN(12, "NET_ADMIN", "Perform various network-related operations: interface configuration, administration of IP firewall, masquerading, and accounting, modify routing tables, bind to any address for transparent proxying, set type-of-service (TOS), clear driver statistics, set promiscuous mode, enabling multicasting, use setsockopt(2) to set the following socket options: SO_DEBUG, SO_MARK, SO_PRIORITY (for a priority outside the range 0 to 6), SO_RCVBUFFORCE, and SO_SNDBUFFORCE"),
    CAP_NET_RAW(13, "NET_RAW", "Use RAW and PACKET sockets"),
    CAP_IPC_LOCK(14, "IPC_LOCK", "Lock memory (mlock(2), mlockall(2), mmap(2), shmctl(2))"),
    CAP_IPC_OWNER(15, "IPC_OWNER", "Bypass permission checks for operations on System V IPC objects"),
    CAP_SYS_MODULE(16, "SYS_MODULE", "Load and unload kernel modules (see init_module(2) and delete_module(2)); in kernels before 2.6.25, this also granted rights for various other operations related to kernel modules"),
    CAP_SYS_RAWIO(17, "SYS_RAWIO", "Perform I/O port operations (iopl(2) and ioperm(2)); access /proc/kcore"),
    CAP_SYS_CHROOT(18, "SYS_CHROOT", "Use chroot(2)"),
    CAP_SYS_PTRACE(19, "SYS_PTRACE", "Trace arbitrary processes using ptrace(2)"),
    CAP_SYS_PACCT(20, "SYS_PACCT", "Use acct(2)"),
    CAP_SYS_ADMIN(21, "SYS_ADMIN", "Perform a range of system administration operations including: quotactl(2), mount(2), umount(2), swapon(2), swapoff(2), sethostname(2), and setdomainname(2); set and modify process resource limits (setrlimit(2)); perform various network-related operations (e.g., setting privileged socket options, enabling multicasting, interface configuration); perform various IPC operations (e.g., SysV semaphores, POSIX message queues, System V shared memory); allow reboot and kexec_load(2); override /proc/sys kernel tunables; perform ptrace(2) PTRACE_SECCOMP_GET_FILTER operation; perform some tracing and debugging operations (see ptrace(2)); administer the lifetime of kernel tracepoints (tracefs(5)); perform the KEYCTL_CHOWN and KEYCTL_SETPERM keyctl(2) operations; perform the following keyctl(2) operations: KEYCTL_CAPABILITIES, KEYCTL_CAPSQUASH, and KEYCTL_PKEY_ OPERATIONS; set state for the Extensible Authentication Protocol (EAP) kernel module; and override the RLIMIT_NPROC resource limit; allow ioperm/iopl access to I/O ports"),
    CAP_SYS_BOOT(22, "SYS_BOOT", "Use reboot(2) and kexec_load(2), reboot and load a new kernel for later execution"),
    CAP_SYS_NICE(23, "SYS_NICE", "Raise process nice value (nice(2), setpriority(2)) and change the nice value for arbitrary processes; set real-time scheduling policies for calling process, and set scheduling policies and priorities for arbitrary processes (sched_setscheduler(2), sched_setparam(2)"),
    CAP_SYS_RESOURCE(24, "SYS_RESOURCE", "Override resource Limits. Set resource limits (setrlimit(2), prlimit(2)), override quota limits (quota(2), quotactl(2)), override reserved space on ext2 filesystem (ext2_ioctl(2)), override size restrictions on IPC message queues (msg(2)) and system V shared memory segments (shmget(2)), and override the /proc/sys/fs/pipe-size-max limit"),
    CAP_SYS_TIME(25, "SYS_TIME", "Set system clock (settimeofday(2), stime(2), adjtimex(2)); set real-time (hardware) clock"),
    CAP_SYS_TTY_CONFIG(26, "SYS_TTY_CONFIG", "Use vhangup(2); employ various privileged ioctl(2) operations on virtual terminals"),
    CAP_MKNOD(27, "MKNOD", "Create special files using mknod(2)"),
    CAP_LEASE(28, "LEASE", "Establish leases on arbitrary files (see fcntl(2))"),
    CAP_AUDIT_WRITE(29, "AUDIT_WRITE", "Write records to kernel auditing log"),
    CAP_AUDIT_CONTROL(30, "AUDIT_CONTROL", "Enable and disable kernel auditing; change auditing filter rules; retrieve auditing status and filtering rules"),
    CAP_SETFCAP(31, "SETFCAP", "If file capabilities are supported: grant or remove any capability in any capability set to any file"),
    CAP_MAC_OVERRIDE(32, "MAC_OVERRIDE", "Override Mandatory Access Control (MAC). Implemented for the Smack Linux Security Module (LSM)"),
    CAP_MAC_ADMIN(33, "MAC_ADMIN", "Allow MAC configuration or state changes. Implemented for the Smack LSM"),
    CAP_SYSLOG(34, "SYSLOG", "Perform privileged syslog(2) operations. See syslog(2) for information on which operations require privilege"),
    CAP_WAKE_ALARM(35, "WAKE_ALARM", "Trigger something that will wake up the system"),
    CAP_BLOCK_SUSPEND(36, "BLOCK_SUSPEND", "Employ features that can block system suspend"),
    CAP_AUDIT_READ(37, "AUDIT_READ", "Allow reading the audit log via a multicast netlink socket"),
    CAP_PERFMON(38, "PERFMON", "Allow performance monitoring via perf_event_open(2)"),
    CAP_BPF(39, "BPF", "Allow BPF operations via bpf(2)"),
    CAP_CHECKPOINT_RESTORE(40, "CHECKPOINT_RESTORE", "Allow processes to be checkpointed via checkpoint/restore in user namespace(2)"),
}
```

`manager/app/src/main/java/me/weishu/kernelsu/profile/Groups.kt`:

```kt
package me.weishu.kernelsu.profile

/**
 * https://cs.android.com/android/platform/superproject/main/+/main:system/core/libcutils/include/private/android_filesystem_config.h
 * @author weishu
 * @date 2023/6/3.
 */
enum class Groups(val gid: Int, val display: String, val desc: String) {
    ROOT(0, "root", "traditional unix root user"),
    DAEMON(1, "daemon", "Traditional unix daemon owner."),
    BIN(2, "bin", "Traditional unix binaries owner."),
    SYS(3, "sys", "A group with the same gid on Linux/macOS/Android."),
    SYSTEM(1000, "system", "system server"),
    RADIO(1001, "radio", "telephony subsystem, RIL"),
    BLUETOOTH(1002, "bluetooth", "bluetooth subsystem"),
    GRAPHICS(1003, "graphics", "graphics devices"),
    INPUT(1004, "input", "input devices"),
    AUDIO(1005, "audio", "audio devices"),
    CAMERA(1006, "camera", "camera devices"),
    LOG(1007, "log", "log devices"),
    COMPASS(1008, "compass", "compass device"),
    MOUNT(1009, "mount", "mountd socket"),
    WIFI(1010, "wifi", "wifi subsystem"),
    ADB(1011, "adb", "android debug bridge (adbd)"),
    INSTALL(1012, "install", "group for installing packages"),
    MEDIA(1013, "media", "mediaserver process"),
    DHCP(1014, "dhcp", "dhcp client"),
    SDCARD_RW(1015, "sdcard_rw", "external storage write access"),
    VPN(1016, "vpn", "vpn system"),
    KEYSTORE(1017, "keystore", "keystore subsystem"),
    USB(1018, "usb", "USB devices"),
    DRM(1019, "drm", "DRM server"),
    MDNSR(1020, "mdnsr", "MulticastDNSResponder (service discovery)"),
    GPS(1021, "gps", "GPS daemon"),
    UNUSED1(1022, "unused1", "deprecated, DO NOT USE"),
    MEDIA_RW(1023, "media_rw", "internal media storage write access"),
    MTP(1024, "mtp", "MTP USB driver access"),
    UNUSED2(1025, "unused2", "deprecated, DO NOT USE"),
    DRMRPC(1026, "drmrpc", "group for drm rpc"),
    NFC(1027, "nfc", "nfc subsystem"),
    SDCARD_R(1028, "sdcard_r", "external storage read access"),
    CLAT(1029, "clat", "clat part of nat464"),
    LOOP_RADIO(1030, "loop_radio", "loop radio devices"),
    MEDIA_DRM(1031, "media_drm", "MediaDrm plugins"),
    PACKAGE_INFO(1032, "package_info", "access to installed package details"),
    SDCARD_PICS(1033, "sdcard_pics", "external storage photos access"),
    SDCARD_AV(1034, "sdcard_av", "external storage audio/video access"),
    SDCARD_ALL(1035, "sdcard_all", "access all users external storage"),
    LOGD(1036, "logd", "log daemon"),
    SHARED_RELRO(1037, "shared_relro", "creator of shared GNU RELRO files"),
    DBUS(1038, "dbus", "dbus-daemon IPC broker process"),
    TLSDATE(1039, "tlsdate", "tlsdate unprivileged user"),
    MEDIA_EX(1040, "media_ex", "mediaextractor process"),
    AUDIOSERVER(1041, "audioserver", "audioserver process"),
    METRICS_COLL(1042, "metrics_coll", "metrics_collector process"),
    METRICSD(1043, "metricsd", "metricsd process"),
    WEBSERV(1044, "webserv", "webservd process"),
    DEBUGGERD(1045, "debuggerd", "debuggerd unprivileged user"),
    MEDIA_CODEC(1046, "media_codec", "media_codec process"),
    CAMERASERVER(1047, "cameraserver", "cameraserver process"),
    FIREWALL(1048, "firewall", "firewall process"),
    TRUNKS(1049, "trunks", "trunksd process"),
    NVRAM(1050, "nvram", "nvram daemon"),
    DNS(1051, "dns", "DNS resolution daemon (system: netd)"),
    DNS_TETHER(1052, "dns_tether", "DNS resolution daemon (tether: dnsmasq)"),
    WEBVIEW_ZYGOTE(1053, "webview_zygote", "WebView zygote process"),
    VEHICLE_NETWORK(1054, "vehicle_network", "Vehicle network service"),
    MEDIA_AUDIO(1055, "media_audio", "GID for audio files on internal media storage"),
    MEDIA_VIDEO(1056, "media_video", "GID for video files on internal media storage"),
    MEDIA_IMAGE(1057, "media_image", "GID for image files on internal media storage"),
    TOMBSTONED(1058, "tombstoned", "tombstoned user"),
    MEDIA_OBB(1059, "media_obb", "GID for OBB files on internal media storage"),
    ESE(1060, "ese", "embedded secure element (eSE) subsystem"),
    OTA_UPDATE(1061, "ota_update", "resource tracking UID for OTA updates"),
    AUTOMOTIVE_EVS(1062, "automotive_evs", "Automotive rear and surround view system"),
    LOWPAN(1063, "lowpan", "LoWPAN subsystem"),
    HSM(1064, "lowpan", "hardware security module subsystem"),
    RESERVED_DISK(1065, "reserved_disk", "GID that has access to reserved disk space"),
    STATSD(1066, "statsd", "statsd daemon"),
    INCIDENTD(1067, "incidentd", "incidentd daemon"),
    SECURE_ELEMENT(1068, "secure_element", "secure element subsystem"),
    LMKD(1069, "lmkd", "low memory killer daemon"),
    LLKD(1070, "llkd", "live lock daemon"),
    IORAPD(1071, "iorapd", "input/output readahead and pin daemon"),
    GPU_SERVICE(1072, "gpu_service", "GPU service daemon"),
    NETWORK_STACK(1073, "network_stack", "network stack service"),
    GSID(1074, "GSID", "GSI service daemon"),
    FSVERITY_CERT(1075, "fsverity_cert", "fs-verity key ownership in keystore"),
    CREDSTORE(1076, "credstore", "identity credential manager service"),
    EXTERNAL_STORAGE(1077, "external_storage", "Full external storage access including USB OTG volumes"),
    EXT_DATA_RW(1078, "ext_data_rw", "GID for app-private data directories on external storage"),
    EXT_OBB_RW(1079, "ext_obb_rw", "GID for OBB directories on external storage"),
    CONTEXT_HUB(1080, "context_hub", "GID for access to the Context Hub"),
    VIRTUALIZATIONSERVICE(1081, "virtualizationservice", "VirtualizationService daemon"),
    ARTD(1082, "artd", "ART Service daemon"),
    UWB(1083, "uwb", "UWB subsystem"),
    THREAD_NETWORK(1084, "thread_network", "Thread Network subsystem"),
    DICED(1085, "diced", "Android's DICE daemon"),
    DMESGD(1086, "dmesgd", "dmesg parsing daemon for kernel report collection"),
    JC_WEAVER(1087, "jc_weaver", "Javacard Weaver HAL - to manage omapi ARA rules"),
    JC_STRONGBOX(1088, "jc_strongbox", "Javacard Strongbox HAL - to manage omapi ARA rules"),
    JC_IDENTITYCRED(1089, "jc_identitycred", "Javacard Identity Cred HAL - to manage omapi ARA rules"),
    SDK_SANDBOX(1090, "sdk_sandbox", "SDK sandbox virtual UID"),
    SECURITY_LOG_WRITER(1091, "security_log_writer", "write to security log"),
    PRNG_SEEDER(1092, "prng_seeder", "PRNG seeder daemon"),
    UPROBESTATS(1093, "uprobestats", "uid for uprobestats"),
    CROS_EC(1094, "cros_ec", "uid for accessing ChromeOS EC (cros_ec)"),
    MMD(1095, "mmd", "uid for memory management daemon"),

    SHELL(2000, "shell", "adb and debug shell user"),
    CACHE(2001, "cache", "cache access"),
    DIAG(2002, "diag", "access to diagnostic resources"),

    /* The 3000 series are intended for use as supplemental group id's only.
     * They indicate special Android capabilities that the kernel is aware of. */
    NET_BT_ADMIN(3001, "net_bt_admin", "bluetooth: create any socket"),
    NET_BT(3002, "net_bt", "bluetooth: create sco, rfcomm or l2cap sockets"),
    INET(3003, "inet", "can create AF_INET and AF_INET6 sockets"),
    NET_RAW(3004, "net_raw", "can create raw INET sockets"),
    NET_ADMIN(3005, "net_admin", "can configure interfaces and routing tables."),
    NET_BW_STATS(3006, "net_bw_stats", "read bandwidth statistics"),
    NET_BW_ACCT(3007, "net_bw_acct", "change bandwidth statistics accounting"),
    NET_BT_STACK(3008, "net_bt_stack", "access to various bluetooth management functions"),
    READPROC(3009, "readproc", "Allow /proc read access"),
    WAKELOCK(3010, "wakelock", "Allow system wakelock read/write access"),
    UHID(3011, "uhid", "Allow read/write to /dev/uhid node"),
    READTRACEFS(3012, "readtracefs", "Allow tracefs read"),
    VIRTUALMACHINE(3013, "virtualmachine", "Allows VMs to tune for performance"),

    EVERYBODY(9997, "everybody", "Shared external storage read/write"),
    MISC(9998, "misc", "Access to misc storage"),
    NOBODY(9999, "nobody", "Reserved"),
    APP(10000, "app", "Access to app data"),
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/KsuService.kt`:

```kt
package me.weishu.kernelsu.ui

import android.content.Intent
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.os.IBinder
import android.os.UserHandle
import android.os.UserManager
import android.util.Log
import com.topjohnwu.superuser.ipc.RootService
import me.weishu.kernelsu.IKsuInterface
import rikka.parcelablelist.ParcelableListSlice

/**
 * @author weishu
 * @date 2023/4/18.
 */

class KsuService : RootService() {

    companion object {
        private const val TAG = "KsuService"
    }

    override fun onBind(intent: Intent): IBinder {
        return Stub()
    }

    private fun getUserIds(): List<Int> {
        val result = ArrayList<Int>()
        val um = getSystemService(USER_SERVICE) as UserManager
        val userProfiles = um.userProfiles
        for (userProfile: UserHandle in userProfiles) {
            result.add(userProfile.hashCode())
        }
        return result
    }

    private fun getInstalledPackagesAll(flags: Int): ArrayList<PackageInfo> {
        val packages = ArrayList<PackageInfo>()
        for (userId in getUserIds()) {
            Log.i(TAG, "getInstalledPackagesAll: $userId")
            packages.addAll(getInstalledPackagesAsUser(flags, userId))
        }
        return packages
    }

    @Suppress("UNCHECKED_CAST")
    private fun getInstalledPackagesAsUser(flags: Int, userId: Int): List<PackageInfo> {
        return try {
            val pm: PackageManager = packageManager
            val method = pm.javaClass.getDeclaredMethod(
                "getInstalledPackagesAsUser",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            method.invoke(pm, flags, userId) as List<PackageInfo>
        } catch (e: Throwable) {
            Log.e(TAG, "err", e)
            ArrayList()
        }
    }

    private inner class Stub : IKsuInterface.Stub() {
        override fun getPackages(flags: Int): ParcelableListSlice<PackageInfo> {
            val list = getInstalledPackagesAll(flags)
            Log.i(TAG, "getPackages: ${list.size}")
            return ParcelableListSlice(list)
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/MainActivity.kt`:

```kt
package me.weishu.kernelsu.ui

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.SystemBarStyle
import androidx.activity.compose.LocalActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.Density
import androidx.core.net.toUri
import androidx.lifecycle.viewmodel.navigation3.rememberViewModelStoreNavEntryDecorator
import androidx.navigation3.runtime.entryProvider
import androidx.navigation3.runtime.rememberSaveableStateHolderNavEntryDecorator
import androidx.navigation3.ui.NavDisplay
import androidx.navigationevent.NavigationEventInfo
import androidx.navigationevent.compose.NavigationBackHandler
import androidx.navigationevent.compose.rememberNavigationEventState
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.flow.MutableStateFlow
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.BottomBar
import me.weishu.kernelsu.ui.component.MainPagerState
import me.weishu.kernelsu.ui.component.rememberConfirmDialog
import me.weishu.kernelsu.ui.component.rememberMainPagerState
import me.weishu.kernelsu.ui.navigation3.HandleDeepLink
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.navigation3.rememberNavigator
import me.weishu.kernelsu.ui.screen.AboutScreen
import me.weishu.kernelsu.ui.screen.AppProfileScreen
import me.weishu.kernelsu.ui.screen.AppProfileTemplateScreen
import me.weishu.kernelsu.ui.screen.ExecuteModuleActionScreen
import me.weishu.kernelsu.ui.screen.FlashIt
import me.weishu.kernelsu.ui.screen.FlashScreen
import me.weishu.kernelsu.ui.screen.HomePager
import me.weishu.kernelsu.ui.screen.InstallScreen
import me.weishu.kernelsu.ui.screen.ModulePager
import me.weishu.kernelsu.ui.screen.ModuleRepoDetailScreen
import me.weishu.kernelsu.ui.screen.ModuleRepoScreen
import me.weishu.kernelsu.ui.screen.SettingPager
import me.weishu.kernelsu.ui.screen.SuperUserPager
import me.weishu.kernelsu.ui.screen.TemplateEditorScreen
import me.weishu.kernelsu.ui.theme.KernelSUTheme
import me.weishu.kernelsu.ui.util.getFileName
import me.weishu.kernelsu.ui.util.install
import me.weishu.kernelsu.ui.webui.WebUIActivity
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.theme.MiuixTheme

class MainActivity : ComponentActivity() {

    private val intentState = MutableStateFlow(0)

    override fun onCreate(savedInstanceState: Bundle?) {

        super.onCreate(savedInstanceState)

        val isManager = Natives.isManager
        if (isManager && !Natives.requireNewKernel()) install()

        setContent {
            val context = LocalActivity.current ?: this
            val prefs = context.getSharedPreferences("settings", MODE_PRIVATE)
            var colorMode by remember { mutableIntStateOf(prefs.getInt("color_mode", 0)) }
            var keyColorInt by remember { mutableIntStateOf(prefs.getInt("key_color", 0)) }
            var pageScale by remember { mutableFloatStateOf(prefs.getFloat("page_scale", 1f)) }
            val keyColor = remember(keyColorInt) { if (keyColorInt == 0) null else Color(keyColorInt) }

            val darkMode = when (colorMode) {
                2, 5 -> true
                0, 3 -> isSystemInDarkTheme()
                else -> false
            }

            DisposableEffect(prefs, darkMode) {
                enableEdgeToEdge(
                    statusBarStyle = SystemBarStyle.auto(
                        android.graphics.Color.TRANSPARENT,
                        android.graphics.Color.TRANSPARENT
                    ) { darkMode },
                    navigationBarStyle = SystemBarStyle.auto(
                        android.graphics.Color.TRANSPARENT,
                        android.graphics.Color.TRANSPARENT
                    ) { darkMode },
                )
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    window.isNavigationBarContrastEnforced = false
                }

                val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
                    when (key) {
                        "color_mode" -> colorMode = prefs.getInt("color_mode", 0)
                        "key_color" -> keyColorInt = prefs.getInt("key_color", 0)
                        "page_scale" -> pageScale = prefs.getFloat("page_scale", 1f)
                    }
                }
                prefs.registerOnSharedPreferenceChangeListener(listener)
                onDispose { prefs.unregisterOnSharedPreferenceChangeListener(listener) }
            }

            val navigator = rememberNavigator(Route.Main)
            val systemDensity = LocalDensity.current
            val density = remember(systemDensity, pageScale) {
                Density(systemDensity.density * pageScale, systemDensity.fontScale)
            }
            CompositionLocalProvider(
                LocalNavigator provides navigator,
                LocalDensity provides density
            ) {
                KernelSUTheme(colorMode = colorMode, keyColor = keyColor) {

                    HandleDeepLink(
                        intentState = intentState.collectAsState(),
                    )

                    ZipFileIntentHandler(
                        intentState = intentState,
                        isManager = isManager,
                    )
                    ShortcutIntentHandler(
                        intentState = intentState,
                    )

                    Scaffold {
                        NavDisplay(
                            backStack = navigator.backStack,
                            entryDecorators = listOf(
                                rememberSaveableStateHolderNavEntryDecorator(),
                                rememberViewModelStoreNavEntryDecorator()
                            ),
                            onBack = {
                                when (val top = navigator.current()) {
                                    is Route.TemplateEditor -> {
                                        if (!top.readOnly) {
                                            navigator.setResult("template_edit", true)
                                        } else {
                                            navigator.pop()
                                        }
                                    }

                                    else -> navigator.pop()
                                }
                            },
                            entryProvider = entryProvider {
                                entry<Route.Main> { MainScreen() }
                                entry<Route.About> { AboutScreen() }
                                entry<Route.AppProfileTemplate> { AppProfileTemplateScreen() }
                                entry<Route.TemplateEditor> { key -> TemplateEditorScreen(key.template, key.readOnly) }
                                entry<Route.AppProfile> { key -> AppProfileScreen(key.packageName) }
                                entry<Route.ModuleRepo> { ModuleRepoScreen() }
                                entry<Route.ModuleRepoDetail> { key -> ModuleRepoDetailScreen(key.module) }
                                entry<Route.Install> { InstallScreen() }
                                entry<Route.Flash> { key -> FlashScreen(key.flashIt) }
                                entry<Route.ExecuteModuleAction> { key -> ExecuteModuleActionScreen(key.moduleId) }
                                entry<Route.Home> { MainScreen() }
                                entry<Route.SuperUser> { MainScreen() }
                                entry<Route.Module> { MainScreen() }
                                entry<Route.Settings> { MainScreen() }
                            }
                        )
                    }
                }
            }
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        setIntent(intent)
        // Increment intentState to trigger LaunchedEffect re-execution
        intentState.value += 1
    }
}

val LocalMainPagerState = staticCompositionLocalOf<MainPagerState> { error("LocalMainPagerState not provided") }

@Composable
fun MainScreen() {
    val navController = LocalNavigator.current
    val pagerState = rememberPagerState(initialPage = 0, pageCount = { 4 })
    val mainPagerState = rememberMainPagerState(pagerState)
    val isManager = Natives.isManager
    val isFullFeatured = isManager && !Natives.requireNewKernel()
    var userScrollEnabled by remember(isFullFeatured) { mutableStateOf(isFullFeatured) }
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = MiuixTheme.colorScheme.surface,
        tint = HazeTint(MiuixTheme.colorScheme.surface.copy(0.8f))
    )

    LaunchedEffect(mainPagerState.pagerState.currentPage) {
        mainPagerState.syncPage()
    }

    MainScreenBackHandler(mainPagerState, navController)

    CompositionLocalProvider(
        LocalMainPagerState provides mainPagerState
    ) {
        Scaffold(
            bottomBar = {
                BottomBar(hazeState, hazeStyle)
            },
        ) { innerPadding ->
            HorizontalPager(
                modifier = Modifier.hazeSource(state = hazeState),
                state = mainPagerState.pagerState,
                beyondViewportPageCount = 3,
                userScrollEnabled = userScrollEnabled,
            ) {
                when (it) {
                    0 -> HomePager(navController, innerPadding.calculateBottomPadding())
                    1 -> SuperUserPager(navController, innerPadding.calculateBottomPadding())
                    2 -> ModulePager(navController, innerPadding.calculateBottomPadding())
                    3 -> SettingPager(navController, innerPadding.calculateBottomPadding())
                }
            }
        }
    }
}


@Composable
private fun MainScreenBackHandler(
    mainState: MainPagerState,
    navController: Navigator,
) {
    val isPagerBackHandlerEnabled by remember {
        derivedStateOf {
            navController.current() is Route.Main && navController.backStackSize() == 1 && mainState.selectedPage != 0
        }
    }

    val navEventState = rememberNavigationEventState(NavigationEventInfo.None)

    NavigationBackHandler(
        state = navEventState,
        isBackEnabled = isPagerBackHandlerEnabled,
        onBackCompleted = {
            mainState.animateToPage(0)
        }
    )
}

/**
 * Handles ZIP file installation from external apps (e.g., file managers).
 * - In normal mode: Shows a confirmation dialog before installation
 * - In safe mode: Shows a Toast notification and prevents installation
 */
@SuppressLint("StringFormatInvalid", "LocalContextGetResourceValueCall")
@Composable
private fun ZipFileIntentHandler(
    intentState: MutableStateFlow<Int>,
    isManager: Boolean,
) {
    val activity = LocalActivity.current ?: return
    val context = LocalContext.current
    var zipUri by remember { mutableStateOf<Uri?>(null) }
    val isSafeMode = Natives.isSafeMode
    val clearZipUri = { zipUri = null }
    val navigator = LocalNavigator.current

    val installDialog = rememberConfirmDialog(
        onConfirm = {
            zipUri?.let { uri ->
                navigator.push(Route.Flash(FlashIt.FlashModules(listOf(uri))))
            }
            clearZipUri()
        },
        onDismiss = clearZipUri
    )

    fun getDisplayName(uri: Uri): String {
        return uri.getFileName(context) ?: uri.lastPathSegment ?: "Unknown"
    }

    val intentStateValue by intentState.collectAsState()
    LaunchedEffect(intentStateValue) {
        val currentIntent = activity.intent
        val uri = currentIntent?.data ?: return@LaunchedEffect

        if (!isManager || uri.scheme != "content" || currentIntent.type != "application/zip") {
            return@LaunchedEffect
        }

        if (isSafeMode) {
            Toast.makeText(
                context,
                context.getString(R.string.safe_mode_module_disabled), Toast.LENGTH_SHORT
            )
                .show()
        } else {
            zipUri = uri
            installDialog.showConfirm(
                title = context.getString(R.string.module),
                content = context.getString(
                    R.string.module_install_prompt_with_name,
                    "\n${getDisplayName(uri)}"
                )
            )
        }
    }
}

@Composable
private fun ShortcutIntentHandler(
    intentState: MutableStateFlow<Int>,
) {
    val activity = LocalActivity.current ?: return
    val context = LocalContext.current
    val intentStateValue by intentState.collectAsState()
    val navigator = LocalNavigator.current
    LaunchedEffect(intentStateValue) {
        val intent = activity.intent
        val type = intent?.getStringExtra("shortcut_type") ?: return@LaunchedEffect
        when (type) {
            "module_action" -> {
                val moduleId = intent.getStringExtra("module_id") ?: return@LaunchedEffect
                navigator.push(Route.ExecuteModuleAction(moduleId))
            }

            "module_webui" -> {
                val moduleId = intent.getStringExtra("module_id") ?: return@LaunchedEffect
                val webIntent = Intent(context, WebUIActivity::class.java)
                    .setData("kernelsu://webui/$moduleId".toUri())
                context.startActivity(webIntent)
            }

            else -> return@LaunchedEffect
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/AppIconImage.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.content.pm.PackageInfo
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.graphics.drawable.toBitmap
import com.kyant.capsule.ContinuousRoundedRectangle
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme

@Composable
fun AppIconImage(
    packageInfo: PackageInfo,
    label: String,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    var icon by remember(packageInfo.packageName) { mutableStateOf<ImageBitmap?>(null) }

    LaunchedEffect(packageInfo.packageName) {
        withContext(Dispatchers.IO) {
            val drawable = packageInfo.applicationInfo?.loadIcon(context.packageManager)
            val bitmap = drawable?.toBitmap()?.asImageBitmap()
            icon = bitmap
        }
    }

    icon.let { imageBitmap ->
        imageBitmap?.let {
            Image(
                bitmap = it,
                contentDescription = label,
                modifier = modifier
            )
        }
    } ?: Box(
        modifier = modifier
            .clip(ContinuousRoundedRectangle(12.dp))
            .background(colorScheme.secondaryContainer),
        contentAlignment = Alignment.Center
    ) {}
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/BottomBar.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.annotation.StringRes
import androidx.compose.animation.core.EaseInOut
import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.animateScrollBy
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.pager.PagerState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.Cottage
import androidx.compose.material.icons.rounded.Extension
import androidx.compose.material.icons.rounded.Security
import androidx.compose.material.icons.rounded.Settings
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Alignment.Companion.CenterHorizontally
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.hazeEffect
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.job
import kotlinx.coroutines.launch
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.LocalMainPagerState
import me.weishu.kernelsu.ui.util.rootAvailable
import top.yukonga.miuix.kmp.basic.HorizontalDivider
import top.yukonga.miuix.kmp.basic.NavigationItem
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.theme.MiuixTheme
import kotlin.math.abs

@Composable
fun BottomBar(hazeState: HazeState, hazeStyle: HazeStyle) {
    val isManager = Natives.isManager
    val fullFeatured = isManager && !Natives.requireNewKernel() && rootAvailable()

    val mainState = LocalMainPagerState.current

    if (!fullFeatured) return

    val item = BottomBarDestination.entries.map { destination ->
        NavigationItem(
            label = stringResource(destination.label),
            icon = destination.icon,
        )
    }

    NavigationBar(
        modifier = Modifier
            .hazeEffect(hazeState) {
                style = hazeStyle
                blurRadius = 30.dp
                noiseFactor = 0f
            },
        color = Color.Transparent,
        items = item,
        selected = mainState.selectedPage,
        onClick = { targetIndex ->
            mainState.animateToPage(targetIndex)
        }
    )
}

@Composable
fun NavigationBar(
    items: List<NavigationItem>,
    selected: Int,
    onClick: (Int) -> Unit,
    modifier: Modifier = Modifier,
    color: Color = MiuixTheme.colorScheme.surface,
    showDivider: Boolean = true,
    defaultWindowInsetsPadding: Boolean = true,
) {
    require(items.size in 2..5) { "BottomBar must have between 2 and 5 items" }

    val captionBarPaddings = WindowInsets.captionBar.only(WindowInsetsSides.Bottom).asPaddingValues()
    val captionBarBottomPaddingValue = captionBarPaddings.calculateBottomPadding()

    val animatedCaptionBarHeight by animateDpAsState(
        targetValue = if (captionBarBottomPaddingValue > 0.dp) captionBarBottomPaddingValue else 0.dp,
        animationSpec = tween(durationMillis = 300),
    )

    val currentOnClick by rememberUpdatedState(onClick)
    Column(
        modifier = modifier
            .fillMaxWidth()
            .background(color),
    ) {
        if (showDivider) {
            HorizontalDivider(
                thickness = 0.6.dp,
                color = MiuixTheme.colorScheme.dividerLine.copy(0.8f)
            )
        }
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically,
        ) {
            val itemHeight = 64.dp
            val itemWeight = 1f / items.size

            items.forEachIndexed { index, item ->
                val isSelected = selected == index
                var isPressed by remember { mutableStateOf(false) }

                val onSurfaceContainerColor = MiuixTheme.colorScheme.onSurfaceContainer
                val onSurfaceContainerVariantColor = MiuixTheme.colorScheme.onSurfaceContainerVariant

                val tint = when {
                    isPressed -> if (isSelected) {
                        onSurfaceContainerColor.copy(alpha = 0.5f)
                    } else {
                        onSurfaceContainerVariantColor.copy(alpha = 0.5f)
                    }

                    isSelected -> onSurfaceContainerColor

                    else -> onSurfaceContainerVariantColor
                }
                val fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal

                Column(
                    modifier = Modifier
                        .height(itemHeight)
                        .weight(itemWeight)
                        .pointerInput(index) {
                            detectTapGestures(
                                onPress = {
                                    isPressed = true
                                    tryAwaitRelease()
                                    isPressed = false
                                },
                                onTap = { currentOnClick(index) },
                            )
                        },
                    horizontalAlignment = CenterHorizontally,
                    verticalArrangement = Arrangement.Top,
                ) {
                    Image(
                        modifier = Modifier
                            .padding(top = 8.dp)
                            .size(26.dp),
                        imageVector = item.icon,
                        contentDescription = item.label,
                        colorFilter = ColorFilter.tint(tint),
                    )
                    Text(
                        modifier = Modifier.padding(top = 1.dp, bottom = 8.dp),
                        text = item.label,
                        color = tint,
                        textAlign = TextAlign.Center,
                        fontSize = 12.sp,
                        fontWeight = fontWeight,
                    )
                }
            }
        }
        if (defaultWindowInsetsPadding) {
            val navigationBarsPadding = WindowInsets.navigationBars.asPaddingValues()
            Spacer(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(navigationBarsPadding.calculateBottomPadding() + animatedCaptionBarHeight)
                    .pointerInput(Unit) { detectTapGestures { /* Do nothing to consume the click */ } },
            )
        }
    }
}

enum class BottomBarDestination(
    @get:StringRes val label: Int,
    val icon: ImageVector,
) {
    Home(R.string.home, Icons.Rounded.Cottage),
    SuperUser(R.string.superuser, Icons.Rounded.Security),
    Module(R.string.module, Icons.Rounded.Extension),
    Setting(R.string.settings, Icons.Rounded.Settings)
}

class MainPagerState(
    val pagerState: PagerState,
    private val coroutineScope: CoroutineScope
) {
    var selectedPage by mutableIntStateOf(pagerState.currentPage)
        private set

    var isNavigating by mutableStateOf(false)
        private set

    private var navJob: Job? = null

    fun animateToPage(targetIndex: Int) {
        if (targetIndex == selectedPage) return

        navJob?.cancel()

        selectedPage = targetIndex
        isNavigating = true

        val distance = abs(targetIndex - pagerState.currentPage).coerceAtLeast(2)
        val duration = 100 * distance + 100
        val layoutInfo = pagerState.layoutInfo
        val pageSize = layoutInfo.pageSize + layoutInfo.pageSpacing
        val currentDistanceInPages = targetIndex - pagerState.currentPage - pagerState.currentPageOffsetFraction
        val scrollPixels = currentDistanceInPages * pageSize

        navJob = coroutineScope.launch {
            val myJob = coroutineContext.job
            try {
                pagerState.animateScrollBy(
                    value = scrollPixels,
                    animationSpec = tween(easing = EaseInOut, durationMillis = duration)
                )
            } finally {
                if (navJob == myJob) {
                    isNavigating = false
                    if (pagerState.currentPage != targetIndex) {
                        selectedPage = pagerState.currentPage
                    }
                }
            }
        }
    }

    fun syncPage() {
        if (!isNavigating && selectedPage != pagerState.currentPage) {
            selectedPage = pagerState.currentPage
        }
    }
}

@Composable
fun rememberMainPagerState(
    pagerState: PagerState,
    coroutineScope: CoroutineScope = rememberCoroutineScope()
): MainPagerState {
    return remember(pagerState, coroutineScope) {
        MainPagerState(pagerState, coroutineScope)
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/ChooseKmiDialog.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.produceState
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.DpSize
import androidx.compose.ui.unit.dp
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.util.getCurrentKmi
import me.weishu.kernelsu.ui.util.getSupportedKmis
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.extra.CheckboxLocation
import top.yukonga.miuix.kmp.extra.SuperCheckbox
import top.yukonga.miuix.kmp.extra.SuperDialog

@Composable
fun ChooseKmiDialog(
    showDialog: MutableState<Boolean>,
    onSelected: (String?) -> Unit
) {
    val supportedKMIs by produceState(initialValue = emptyList()) {
        value = getSupportedKmis()
    }
    val currentKmi by produceState(initialValue = "") {
        value = getCurrentKmi()
    }
    val currentSelection = rememberSaveable(currentKmi) { mutableStateOf(currentKmi) }
    SuperDialog(
        show = showDialog,
        title = stringResource(R.string.select_kmi),
        summary = stringResource(R.string.current_kmi, currentKmi.let { it.ifBlank { "Unknown" } }),
        insideMargin = DpSize(0.dp, 24.dp),
        onDismissRequest = {
            showDialog.value = false
            currentSelection.value = currentKmi
        },
    ) {
        Column(modifier = Modifier.heightIn(max = 500.dp)) {
            LazyColumn(modifier = Modifier.weight(1f, fill = false)) {
                items(supportedKMIs) { kmi ->
                    SuperCheckbox(
                        title = kmi,
                        summary = if (kmi == currentKmi) stringResource(R.string.current_device_kmi) else null,
                        insideMargin = PaddingValues(horizontal = 30.dp, vertical = 16.dp),
                        checkboxLocation = CheckboxLocation.End,
                        checked = currentSelection.value == kmi,
                        holdDownState = currentSelection.value == kmi,
                        onCheckedChange = { _ ->
                            currentSelection.value = kmi
                        }
                    )
                }
            }
            Spacer(Modifier.height(12.dp))
            Row(
                modifier = Modifier.padding(horizontal = 24.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                TextButton(
                    onClick = {
                        showDialog.value = false
                        currentSelection.value = currentKmi
                    },
                    text = stringResource(android.R.string.cancel),
                    modifier = Modifier.weight(1f),
                )
                Spacer(modifier = Modifier.width(20.dp))
                TextButton(
                    enabled = supportedKMIs.contains(currentSelection.value),
                    onClick = {
                        onSelected(currentSelection.value)
                        showDialog.value = false
                    },
                    text = stringResource(R.string.confirm),
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.textButtonColorsPrimary()
                )
            }
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/Dialog.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.os.Parcelable
import android.util.Log
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.windowInsetsPadding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.saveable.Saver
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.async
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.flow.FlowCollector
import kotlinx.coroutines.flow.consumeAsFlow
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.R
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.InfiniteProgressIndicator
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.extra.SuperDialog
import top.yukonga.miuix.kmp.theme.MiuixTheme
import kotlin.coroutines.resume

private const val TAG = "DialogComponent"

interface ConfirmDialogVisuals : Parcelable {
    val title: String
    val content: String?
    val isMarkdown: Boolean
    val isHtml: Boolean
    val confirm: String?
    val dismiss: String?
}

@Parcelize
private data class ConfirmDialogVisualsImpl(
    override val title: String,
    override val content: String?,
    override val isMarkdown: Boolean,
    override val isHtml: Boolean,
    override val confirm: String?,
    override val dismiss: String?,
) : ConfirmDialogVisuals {
    companion object {
        val Empty: ConfirmDialogVisuals = ConfirmDialogVisualsImpl("", "", false, false, null, null)
    }
}

interface DialogHandle {
    val isShown: Boolean
    val dialogType: String
    fun show()
    fun hide()
}

interface LoadingDialogHandle : DialogHandle {
    suspend fun <R> withLoading(block: suspend () -> R): R
    fun showLoading()
}

sealed interface ConfirmResult {
    object Confirmed : ConfirmResult
    object Canceled : ConfirmResult
}

interface ConfirmDialogHandle : DialogHandle {
    val visuals: ConfirmDialogVisuals

    fun showConfirm(
        title: String,
        content: String? = null,
        markdown: Boolean = false,
        html: Boolean = false,
        confirm: String? = null,
        dismiss: String? = null
    )

    suspend fun awaitConfirm(
        title: String,
        content: String? = null,
        markdown: Boolean = false,
        html: Boolean = false,
        confirm: String? = null,
        dismiss: String? = null
    ): ConfirmResult
}

private abstract class DialogHandleBase(
    val visible: MutableState<Boolean>,
    val coroutineScope: CoroutineScope
) : DialogHandle {
    override val isShown: Boolean
        get() = visible.value

    override fun show() {
        coroutineScope.launch {
            visible.value = true
        }
    }

    final override fun hide() {
        coroutineScope.launch {
            visible.value = false
        }
    }

    override fun toString(): String {
        return dialogType
    }
}

private class LoadingDialogHandleImpl(
    visible: MutableState<Boolean>,
    coroutineScope: CoroutineScope
) : LoadingDialogHandle, DialogHandleBase(visible, coroutineScope) {
    override suspend fun <R> withLoading(block: suspend () -> R): R {
        return coroutineScope.async {
            try {
                visible.value = true
                block()
            } finally {
                visible.value = false
            }
        }.await()
    }

    override fun showLoading() {
        show()
    }

    override val dialogType: String get() = "LoadingDialog"
}

typealias NullableCallback = (() -> Unit)?

interface ConfirmCallback {

    val onConfirm: NullableCallback

    val onDismiss: NullableCallback

    val isEmpty: Boolean get() = onConfirm == null && onDismiss == null

    companion object {
        operator fun invoke(
            onConfirmProvider: () -> NullableCallback,
            onDismissProvider: () -> NullableCallback
        ): ConfirmCallback {
            return object : ConfirmCallback {
                override val onConfirm: NullableCallback
                    get() = onConfirmProvider()
                override val onDismiss: NullableCallback
                    get() = onDismissProvider()
            }
        }
    }
}

private class ConfirmDialogHandleImpl(
    visible: MutableState<Boolean>,
    coroutineScope: CoroutineScope,
    callback: ConfirmCallback,
    override var visuals: ConfirmDialogVisuals = ConfirmDialogVisualsImpl.Empty,
    private val resultFlow: ReceiveChannel<ConfirmResult>
) : ConfirmDialogHandle, DialogHandleBase(visible, coroutineScope) {
    private class ResultCollector(
        private val callback: ConfirmCallback
    ) : FlowCollector<ConfirmResult> {
        fun handleResult(result: ConfirmResult) {
            Log.d(TAG, "handleResult: ${result.javaClass.simpleName}")
            when (result) {
                ConfirmResult.Confirmed -> onConfirm()
                ConfirmResult.Canceled -> onDismiss()
            }
        }

        fun onConfirm() {
            callback.onConfirm?.invoke()
        }

        fun onDismiss() {
            callback.onDismiss?.invoke()
        }

        override suspend fun emit(value: ConfirmResult) {
            handleResult(value)
        }
    }

    private val resultCollector = ResultCollector(callback)

    private var awaitContinuation: CancellableContinuation<ConfirmResult>? = null

    private val isCallbackEmpty = callback.isEmpty

    init {
        coroutineScope.launch {
            resultFlow
                .consumeAsFlow()
                .onEach { result ->
                    awaitContinuation?.let {
                        awaitContinuation = null
                        if (it.isActive) {
                            it.resume(result)
                        }
                    }
                }
                .onEach { hide() }
                .collect(resultCollector)
        }
    }

    private suspend fun awaitResult(): ConfirmResult {
        return suspendCancellableCoroutine {
            awaitContinuation = it.apply {
                if (isCallbackEmpty) {
                    invokeOnCancellation {
                        visible.value = false
                    }
                }
            }
        }
    }

    fun updateVisuals(visuals: ConfirmDialogVisuals) {
        this.visuals = visuals
    }

    override fun show() {
        if (visuals !== ConfirmDialogVisualsImpl.Empty) {
            super.show()
        } else {
            throw UnsupportedOperationException("can't show confirm dialog with the Empty visuals")
        }
    }

    override fun showConfirm(
        title: String,
        content: String?,
        markdown: Boolean,
        html: Boolean,
        confirm: String?,
        dismiss: String?
    ) {
        coroutineScope.launch {
            updateVisuals(ConfirmDialogVisualsImpl(title, content, markdown, html, confirm, dismiss))
            show()
        }
    }

    override suspend fun awaitConfirm(
        title: String,
        content: String?,
        markdown: Boolean,
        html: Boolean,
        confirm: String?,
        dismiss: String?
    ): ConfirmResult {
        coroutineScope.launch {
            updateVisuals(ConfirmDialogVisualsImpl(title, content, markdown, html, confirm, dismiss))
            show()
        }
        return awaitResult()
    }

    override val dialogType: String get() = "ConfirmDialog"

    override fun toString(): String {
        return "${super.toString()}(visuals: $visuals)"
    }

    companion object {
        fun Saver(
            visible: MutableState<Boolean>,
            coroutineScope: CoroutineScope,
            callback: ConfirmCallback,
            resultChannel: ReceiveChannel<ConfirmResult>
        ) = Saver<ConfirmDialogHandle, ConfirmDialogVisuals>(
            save = {
                it.visuals
            },
            restore = {
                Log.d(TAG, "ConfirmDialog restore, visuals: $it")
                ConfirmDialogHandleImpl(visible, coroutineScope, callback, it, resultChannel)
            }
        )
    }
}

@Composable
fun rememberLoadingDialog(): LoadingDialogHandle {
    val visible = remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()

    LoadingDialog(visible)

    return remember {
        LoadingDialogHandleImpl(visible, coroutineScope)
    }
}

@Composable
private fun rememberConfirmDialog(visuals: ConfirmDialogVisuals, callback: ConfirmCallback): ConfirmDialogHandle {
    val visible = rememberSaveable {
        mutableStateOf(false)
    }
    val coroutineScope = rememberCoroutineScope()
    val resultChannel = remember {
        Channel<ConfirmResult>()
    }

    val handle = rememberSaveable(
        saver = ConfirmDialogHandleImpl.Saver(visible, coroutineScope, callback, resultChannel),
        init = {
            ConfirmDialogHandleImpl(visible, coroutineScope, callback, visuals, resultChannel)
        }
    )

    if (visible.value) {
        ConfirmDialog(
            handle.visuals,
            confirm = { coroutineScope.launch { resultChannel.send(ConfirmResult.Confirmed) } },
            dismiss = { coroutineScope.launch { resultChannel.send(ConfirmResult.Canceled) } },
            showDialog = visible
        )
    }

    return handle
}

@Composable
fun rememberConfirmCallback(onConfirm: NullableCallback, onDismiss: NullableCallback): ConfirmCallback {
    val currentOnConfirm by rememberUpdatedState(newValue = onConfirm)
    val currentOnDismiss by rememberUpdatedState(newValue = onDismiss)
    return remember {
        ConfirmCallback({ currentOnConfirm }, { currentOnDismiss })
    }
}

@Composable
fun rememberConfirmDialog(onConfirm: NullableCallback = null, onDismiss: NullableCallback = null): ConfirmDialogHandle {
    return rememberConfirmDialog(rememberConfirmCallback(onConfirm, onDismiss))
}

@Composable
fun rememberConfirmDialog(callback: ConfirmCallback): ConfirmDialogHandle {
    return rememberConfirmDialog(ConfirmDialogVisualsImpl.Empty, callback)
}

@Composable
private fun LoadingDialog(showDialog: MutableState<Boolean>) {
    SuperDialog(
        show = showDialog,
        onDismissRequest = {},
        content = {
            Box(
                modifier = Modifier.fillMaxWidth(),
                contentAlignment = Alignment.CenterStart
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.Start,
                ) {
                    InfiniteProgressIndicator(
                        color = MiuixTheme.colorScheme.onBackground
                    )
                    Text(
                        modifier = Modifier.padding(start = 12.dp),
                        text = stringResource(R.string.processing),
                        fontWeight = FontWeight.Medium
                    )
                }
            }
        }
    )
}

@Composable
private fun ConfirmDialog(
    visuals: ConfirmDialogVisuals,
    confirm: () -> Unit,
    dismiss: () -> Unit,
    showDialog: MutableState<Boolean>
) {
    SuperDialog(
        modifier = Modifier.windowInsetsPadding(WindowInsets.systemBars.only(WindowInsetsSides.Top)),
        show = showDialog,
        title = visuals.title,
        onDismissRequest = {
            dismiss()
            showDialog.value = false
        },
        content = {
            Layout(
                content = {
                    visuals.content?.let { content ->
                        when {
                            visuals.isMarkdown -> Markdown(content = content)
                            visuals.isHtml -> GithubMarkdown(content = content)
                            else -> Text(text = content)
                        }
                    }
                    Row(
                        horizontalArrangement = Arrangement.SpaceBetween,
                        modifier = Modifier.padding(top = 12.dp)
                    ) {
                        TextButton(
                            text = visuals.dismiss ?: stringResource(id = android.R.string.cancel),
                            onClick = {
                                dismiss()
                                showDialog.value = false
                            },
                            modifier = Modifier.weight(1f)
                        )
                        Spacer(Modifier.width(20.dp))
                        TextButton(
                            text = visuals.confirm ?: stringResource(id = android.R.string.ok),
                            onClick = {
                                confirm()
                                showDialog.value = false
                            },
                            modifier = Modifier.weight(1f),
                            colors = ButtonDefaults.textButtonColorsPrimary()
                        )
                    }
                }
            ) { measurables, constraints ->
                if (measurables.size != 2) {
                    val button = measurables[0].measure(constraints)
                    layout(constraints.maxWidth, button.height) {
                        button.place(0, 0)
                    }
                } else {
                    val button = measurables[1].measure(constraints)
                    val lazyList = measurables[0].measure(constraints.copy(maxHeight = constraints.maxHeight - button.height))
                    layout(constraints.maxWidth, lazyList.height + button.height) {
                        lazyList.place(0, 0)
                        button.place(0, lazyList.height)
                    }
                }
            }
        }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/DropdownItem.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import top.yukonga.miuix.kmp.basic.DropdownColors
import top.yukonga.miuix.kmp.basic.DropdownDefaults
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.theme.MiuixTheme

@Composable
fun DropdownItem(
    text: String,
    optionSize: Int,
    index: Int,
    dropdownColors: DropdownColors = DropdownDefaults.dropdownColors(),
    onSelectedIndexChange: (Int) -> Unit
) {
    val currentOnSelectedIndexChange = rememberUpdatedState(onSelectedIndexChange)
    val additionalTopPadding = if (index == 0) 20f.dp else 12f.dp
    val additionalBottomPadding = if (index == optionSize - 1) 20f.dp else 12f.dp

    Row(
        modifier = Modifier
            .clickable { currentOnSelectedIndexChange.value(index) }
            .background(dropdownColors.containerColor)
            .padding(horizontal = 20.dp)
            .padding(
                top = additionalTopPadding,
                bottom = additionalBottomPadding
            ),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = text,
            fontSize = MiuixTheme.textStyles.body1.fontSize,
            fontWeight = FontWeight.Medium,
            color = dropdownColors.contentColor,
        )
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/EditText.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.FocusInteraction
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsFocusedAsState
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.runtime.Composable
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.Stable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.semantics.onClick
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.theme.MiuixTheme
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import kotlin.math.max

@Composable
fun EditText(
    title: String,
    summary: String? = null,
    textValue: MutableState<String>,
    onTextValueChange: (String) -> Unit = {},
    textHint: String = "",
    enabled: Boolean = true,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    titleColor: BasicComponentColors = EditTextDefaults.titleColor(),
    summaryColor: BasicComponentColors = EditTextDefaults.summaryColor(),
    rightActionColor: BasicComponentColors = EditTextDefaults.rightActionColors(),
    isError: Boolean = false,
) {
    val interactionSource = remember { MutableInteractionSource() }
    val coroutineScope = rememberCoroutineScope()
    val focused = interactionSource.collectIsFocusedAsState().value
    val focusRequester = remember { FocusRequester() }
    if (focused) {
        focusRequester.requestFocus()
    }

    Box(
        modifier = Modifier
            .clickable(
                indication = null,
                interactionSource = null
            ) {
                if (enabled) {
                    coroutineScope.launch {
                        interactionSource.emit(FocusInteraction.Focus())
                    }
                }
            }
            .heightIn(min = 56.dp)
            .fillMaxWidth()
            .padding(EditTextDefaults.InsideMargin),
    ) {
        Layout(
            content = {
                Text(
                    text = title,
                    fontSize = MiuixTheme.textStyles.headline1.fontSize,
                    fontWeight = FontWeight.Medium,
                    color = titleColor.color(enabled)
                )
                summary?.let {
                    Text(
                        text = it,
                        fontSize = MiuixTheme.textStyles.body2.fontSize,
                        color = summaryColor.color(enabled)
                    )
                }
                BasicTextField(
                    value = textValue.value,
                    onValueChange = {
                        onTextValueChange(it)
                    },
                    modifier = Modifier
                        .focusRequester(focusRequester)
                        .semantics {
                            onClick {
                                focusRequester.requestFocus()
                                true
                            }
                        },
                    enabled = enabled,
                    textStyle = MiuixTheme.textStyles.main.copy(
                        textAlign = TextAlign.End,
                        color = if (isError) {
                            Color.Red.copy(alpha = if (isSystemInDarkTheme()) 0.3f else 0.6f)
                        } else {
                            rightActionColor.color(enabled)
                        }
                    ),
                    keyboardOptions = keyboardOptions,
                    cursorBrush = SolidColor(colorScheme.primary),
                    interactionSource = interactionSource,
                    decorationBox =
                        @Composable { innerTextField ->
                            Box(
                                contentAlignment = Alignment.CenterEnd
                            ) {
                                Text(
                                    text = if (textValue.value.isEmpty()) textHint else "",
                                    color = rightActionColor.color(enabled),
                                    textAlign = TextAlign.End,
                                    softWrap = false,
                                    maxLines = 1
                                )
                                innerTextField()
                            }
                        }
                )
            }
        ) { measurables, constraints ->
            val leftConstraints = constraints.copy(maxWidth = constraints.maxWidth / 2)
            val hasSummary = measurables.size > 2
            val titleText = measurables[0].measure(leftConstraints)
            val summaryText = (if (hasSummary) measurables[1] else null)?.measure(leftConstraints)
            val leftWidth = max(titleText.width, (summaryText?.width ?: 0))
            val leftHeight = titleText.height + (summaryText?.height ?: 0)
            val rightWidth = constraints.maxWidth - leftWidth - 16.dp.roundToPx()
            val rightConstraints = constraints.copy(maxWidth = rightWidth)
            val inputField = (if (hasSummary) measurables[2] else measurables[1]).measure(rightConstraints)
            val totalHeight = max(leftHeight, inputField.height)
            layout(constraints.maxWidth, totalHeight) {
                val titleY = (totalHeight - leftHeight) / 2
                titleText.placeRelative(0, titleY)
                summaryText?.placeRelative(0, titleY + titleText.height)
                inputField.placeRelative(constraints.maxWidth - inputField.width, (totalHeight - inputField.height) / 2)
            }
        }
    }
}

object EditTextDefaults {
    val InsideMargin = PaddingValues(16.dp)

    @Composable
    fun titleColor(
        color: Color = colorScheme.onSurface,
        disabledColor: Color = colorScheme.disabledOnSecondaryVariant
    ): BasicComponentColors {
        return BasicComponentColors(
            color = color,
            disabledColor = disabledColor
        )
    }

    @Composable
    fun summaryColor(
        color: Color = colorScheme.onSurfaceVariantSummary,
        disabledColor: Color = colorScheme.disabledOnSecondaryVariant
    ): BasicComponentColors {
        return BasicComponentColors(
            color = color,
            disabledColor = disabledColor
        )
    }

    @Composable
    fun rightActionColors(
        color: Color = colorScheme.onSurfaceVariantActions,
        disabledColor: Color = colorScheme.disabledOnSecondaryVariant,
    ): BasicComponentColors {
        return BasicComponentColors(
            color = color,
            disabledColor = disabledColor
        )
    }
}

@Immutable
class BasicComponentColors(
    private val color: Color,
    private val disabledColor: Color
) {
    @Stable
    fun color(enabled: Boolean): Color = if (enabled) color else disabledColor
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/GithubMarkdown.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.graphics.Color
import android.util.Log
import android.view.MotionEvent
import android.view.View
import android.webkit.JavascriptInterface
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.FrameLayout
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.wrapContentHeight
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clipToBounds
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.platform.LocalResources
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.net.toUri
import androidx.webkit.WebViewAssetLoader
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.theme.isInDarkTheme
import me.weishu.kernelsu.ui.util.adjustLightnessArgb
import me.weishu.kernelsu.ui.util.cssColorFromArgb
import me.weishu.kernelsu.ui.util.ensureVisibleByMix
import me.weishu.kernelsu.ui.util.relativeLuminance
import okhttp3.Headers.Companion.toHeaders
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okio.IOException
import top.yukonga.miuix.kmp.theme.MiuixTheme
import java.io.ByteArrayInputStream
import java.nio.charset.StandardCharsets
import kotlin.math.abs

@SuppressLint("ClickableViewAccessibility", "JavascriptInterface", "SetJavaScriptEnabled")
@Composable
fun GithubMarkdown(
    content: String,
    isLoading: MutableState<Boolean> = mutableStateOf(true)
) {
    isLoading.value = true
    val context = LocalContext.current

    val density = LocalDensity.current
    val systemDensity = LocalResources.current.displayMetrics.density
    val fontScale = density.fontScale
    val pageScale = density.density / systemDensity
    val newtTextZoom = (90 * pageScale * fontScale).toInt()

    val scrollInterface = remember { MarkdownScrollInterface() }
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    val themeMode = prefs.getInt("color_mode", 0)
    val isDark = isInDarkTheme(themeMode)
    val dir = if (LocalLayoutDirection.current == LayoutDirection.Rtl) "rtl" else "ltr"

    val bgArgb = MiuixTheme.colorScheme.surfaceContainer.toArgb()
    val bgLuminance = relativeLuminance(bgArgb)

    fun makeVariant(delta: Float): Int {
        val candidate = adjustLightnessArgb(bgArgb, delta)
        val madeLighter = delta > 0f
        return ensureVisibleByMix(bgArgb, candidate, 1.15, madeLighter)
    }

    val bgDefault = cssColorFromArgb(bgArgb)
    val bgMuted = cssColorFromArgb(makeVariant(if (bgLuminance > 0.6) -0.06f else 0.06f))
    val bgNeutralMuted = cssColorFromArgb(makeVariant(if (bgLuminance > 0.6) -0.12f else 0.12f))
    val bgAttentionMuted = cssColorFromArgb(makeVariant(-0.12f))
    val fgLink = cssColorFromArgb(MiuixTheme.colorScheme.primary.toArgb())

    val cssHref = "https://appassets.androidplatform.net/assets/github-markdown.css"
    val html = """
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset='utf-8'/>
          <meta name='viewport' content='width=device-width, initial-scale=1'/>
          <link rel="stylesheet" href="$cssHref" />
          <style>
            html, body { margin:0; padding:0; }
            img, video { max-width:100%; height:auto; }
            .markdown-body {
              padding: 16px;
              --bgColor-default: $bgDefault;
              --bgColor-muted: $bgMuted;
              --bgColor-neutral-muted: $bgNeutralMuted;
              --bgColor-attention-muted: $bgAttentionMuted;
              --fgColor-accent: $fgLink;
            }
          </style>
        </head>
        <body dir='${dir}'>
          <article class='markdown-body' data-theme='${if (isDark) "dark" else "light"}'>${content}</article>
        </body>
        </html>
    """.trimIndent()

    AndroidView(
        factory = { context ->
            val frameLayout = FrameLayout(context)
            val webView = WebView(context).apply {
                try {
                    setBackgroundColor(Color.TRANSPARENT)
                    isVerticalScrollBarEnabled = false
                    isHorizontalScrollBarEnabled = false

                    settings.apply {
                        offscreenPreRaster = true
                        javaScriptEnabled = true
                        domStorageEnabled = true
                        mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
                        allowContentAccess = false
                        allowFileAccess = false
                        cacheMode = WebSettings.LOAD_CACHE_ELSE_NETWORK
                        textZoom = newtTextZoom
                        setSupportZoom(false)
                        setGeolocationEnabled(false)
                    }
                    addJavascriptInterface(scrollInterface, "AndroidScroll")
                    webViewClient = object : WebViewClient() {
                        private val assetLoader = WebViewAssetLoader.Builder()
                            .addPathHandler("/assets/", WebViewAssetLoader.AssetsPathHandler(context))
                            .build()

                        override fun onPageFinished(view: WebView, url: String) {
                            super.onPageFinished(view, url)

                            val js = """
                                (function() {
                                    if (window.androidScrollInjected) return;
                                    window.androidScrollInjected = true;
                                
                                    function checkScroll(target) {
                                        if (!target || target === document.body || target === document.documentElement) return {l: false, r: false};
                                        var style = window.getComputedStyle(target);
                                        if (style.overflowX !== 'auto' && style.overflowX !== 'scroll') return {l: false, r: false};
                                        if (target.scrollWidth <= target.clientWidth) return {l: false, r: false};
                                        
                                        var atLeft = target.scrollLeft <= 0;
                                        var atRight = Math.ceil(target.scrollLeft + target.clientWidth) >= target.scrollWidth;
                                        
                                        return {l: !atLeft, r: !atRight};
                                    }
                                
                                    var lastTarget = null;
                                    var lastState = {l: false, r: false};
                                    
                                    function update(l, r) {
                                        if (lastState.l !== l || lastState.r !== r) {
                                            lastState = {l: l, r: r};
                                            AndroidScroll.updateScrollState(l, r);
                                        }
                                    }
                                
                                    document.addEventListener('touchstart', function(e) {
                                        var t = e.target;
                                        var found = false;
                                        while(t && t !== document.body) {
                                            var s = checkScroll(t);
                                            if (s.l || s.r) { 
                                                 lastTarget = t;
                                                 update(s.l, s.r);
                                                 found = true;
                                                 break;
                                            }
                                            t = t.parentElement;
                                        }
                                        if (!found) {
                                            lastTarget = null;
                                            update(false, false);
                                        }
                                    }, {passive: true});
                                
                                    document.addEventListener('touchmove', function(e) {
                                        if (lastTarget) {
                                             var s = checkScroll(lastTarget);
                                             update(s.l, s.r);
                                        }
                                    }, {passive: true});
                                    
                                    document.addEventListener('scroll', function(e) {
                                        if (lastTarget && (e.target === lastTarget || e.target.contains(lastTarget))) {
                                              var s = checkScroll(lastTarget);
                                              update(s.l, s.r);
                                        }
                                    }, {passive: true, capture: true});
                                })();
                            """.trimIndent()
                            view.evaluateJavascript(js, null)
                        }

                        override fun shouldOverrideUrlLoading(
                            view: WebView, request: WebResourceRequest
                        ): Boolean {
                            val url = request.url.toString()
                            val intent = Intent(Intent.ACTION_VIEW, url.toUri())
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                            context.startActivity(intent)
                            return true
                        }

                        override fun onPageCommitVisible(view: WebView?, url: String?) {
                            isLoading.value = false
                        }

                        override fun shouldInterceptRequest(
                            view: WebView, request: WebResourceRequest
                        ): WebResourceResponse? {
                            assetLoader.shouldInterceptRequest(request.url)?.let { return it }
                            val scheme = request.url.scheme ?: return null
                            if (!scheme.startsWith("http")) return null
                            val client: OkHttpClient = ksuApp.okhttpClient
                            val call = client.newCall(
                                Request.Builder()
                                    .url(request.url.toString())
                                    .method(request.method, null)
                                    .headers(request.requestHeaders.toHeaders())
                                    .build()
                            )
                            return try {
                                val reply: Response = call.execute()
                                val header = reply.header("content-type", "text/plain; charset=utf-8")
                                val contentTypes = header?.split(";\\s*".toRegex()) ?: emptyList()
                                val mimeType = contentTypes.firstOrNull() ?: "image/*"
                                val charset = contentTypes.getOrNull(1)?.split("=\\s*".toRegex())?.getOrNull(1) ?: "utf-8"
                                val body = reply.body
                                WebResourceResponse(mimeType, charset, body.byteStream())
                            } catch (e: IOException) {
                                WebResourceResponse(
                                    "text/html", "utf-8",
                                    ByteArrayInputStream(Log.getStackTraceString(e).toByteArray(StandardCharsets.UTF_8))
                                )
                            }
                        }
                    }
                    setOnTouchListener(object : View.OnTouchListener {
                        private var isHorizontalScrollLocked = false
                        private var initialDownX = 0f
                        private var initialDownY = 0f

                        override fun onTouch(v: View, event: MotionEvent): Boolean {
                            when (event.action) {
                                MotionEvent.ACTION_DOWN -> {
                                    initialDownX = event.x
                                    initialDownY = event.y
                                    isHorizontalScrollLocked = false
                                    v.parent.requestDisallowInterceptTouchEvent(true)
                                }

                                MotionEvent.ACTION_MOVE -> {
                                    if (isHorizontalScrollLocked) {
                                        v.parent.requestDisallowInterceptTouchEvent(true)
                                    } else {
                                        val dx = event.x - initialDownX
                                        val dy = event.y - initialDownY
                                        if (abs(dx) > abs(dy)) {
                                            val canScroll = if (dx < 0) scrollInterface.canScrollRight else scrollInterface.canScrollLeft
                                            if (canScroll) {
                                                isHorizontalScrollLocked = true
                                                v.parent.requestDisallowInterceptTouchEvent(true)
                                            } else {
                                                v.parent.requestDisallowInterceptTouchEvent(false)
                                            }
                                        } else {
                                            v.parent.requestDisallowInterceptTouchEvent(false)
                                            return true
                                        }
                                    }
                                }

                                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                                    v.parent.requestDisallowInterceptTouchEvent(false)
                                    isHorizontalScrollLocked = false
                                }
                            }
                            return false
                        }
                    })
                    loadDataWithBaseURL(
                        "https://appassets.androidplatform.net", html,
                        "text/html", StandardCharsets.UTF_8.name(), null
                    )
                } catch (e: Throwable) {
                    Log.e("GithubMarkdown", "WebView setup failed", e)
                }
            }
            frameLayout.addView(webView)
            frameLayout
        },
        onRelease = { frameLayout ->
            val webView = frameLayout.getChildAt(0) as? WebView
            frameLayout.removeAllViews()
            webView?.apply {
                stopLoading()
                destroy()
            }
        },
        modifier = Modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .clipToBounds(),
    )
}

class MarkdownScrollInterface {
    @Volatile
    var canScrollLeft = false

    @Volatile
    var canScrollRight = false

    @JavascriptInterface
    fun updateScrollState(left: Boolean, right: Boolean) {
        canScrollLeft = left
        canScrollRight = right
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/KeyEventBlocker.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.focusable
import androidx.compose.foundation.layout.Box
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.input.key.KeyEvent
import androidx.compose.ui.input.key.onKeyEvent

@Composable
fun KeyEventBlocker(predicate: (KeyEvent) -> Boolean) {
    val requester = remember { FocusRequester() }
    Box(
        Modifier
            .onKeyEvent {
                predicate(it)
            }
            .focusRequester(requester)
            .focusable()
    )
    LaunchedEffect(Unit) {
        requester.requestFocus()
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/KsuValidCheck.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.runtime.Composable
import me.weishu.kernelsu.Natives

@Composable
fun KsuIsValid(
    content: @Composable () -> Unit
) {
    val isManager = Natives.isManager
    val ksuVersion = if (isManager) Natives.version else null

    if (ksuVersion != null) {
        content()
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/Markdown.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.graphics.text.LineBreaker
import android.os.Build
import android.text.Layout
import android.text.method.LinkMovementMethod
import android.view.ViewGroup
import android.widget.FrameLayout
import android.widget.ScrollView
import android.widget.TextView
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.wrapContentHeight
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clipToBounds
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.viewinterop.AndroidView
import io.noties.markwon.Markwon
import io.noties.markwon.utils.NoCopySpannableFactory
import top.yukonga.miuix.kmp.theme.MiuixTheme

private const val TEXTVIEW_TAG = "markdownTextView"

@Composable
fun Markdown(content: String) {
    val contentColor = MiuixTheme.colorScheme.onBackground.toArgb()

    AndroidView(
        factory = { context ->
            val frameLayout = FrameLayout(context)
            val scrollView = ScrollView(context)
            val textView = TextView(context).apply {
                tag = TEXTVIEW_TAG
                movementMethod = LinkMovementMethod.getInstance()
                setSpannableFactory(NoCopySpannableFactory.getInstance())
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    breakStrategy = LineBreaker.BREAK_STRATEGY_SIMPLE
                }
                hyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE
                layoutParams = ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT
                )
            }
            scrollView.addView(textView)
            frameLayout.addView(scrollView)
            frameLayout
        },
        modifier = Modifier
            .fillMaxWidth()
            .wrapContentHeight()
            .clipToBounds(),
        update = { frameLayout ->
            frameLayout.findViewWithTag<TextView>(TEXTVIEW_TAG)?.let { textView ->
                Markwon.create(textView.context).setMarkdown(textView, content)
                textView.setTextColor(contentColor)
            }
        }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/ScaleDialog.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import me.weishu.kernelsu.R
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TextField
import top.yukonga.miuix.kmp.extra.SuperDialog
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme

@Composable
fun ScaleDialog(
    showDialog: MutableState<Boolean>,
    volumeState: () -> Float,
    onVolumeChange: (Float) -> Unit,
) {
    SuperDialog(
        title = stringResource(R.string.settings_page_scale),
        summary = "80% - 110%",
        show = showDialog,
        onDismissRequest = { showDialog.value = false },
    ) {
        var text by remember(showDialog.value) {
            mutableStateOf((volumeState() * 100).toString().removeSuffix(".0"))
        }
        TextField(
            modifier = Modifier.padding(bottom = 16.dp),
            value = text,
            maxLines = 1,
            trailingIcon = {
                Text(
                    text = "%",
                    modifier = Modifier.padding(horizontal = 16.dp),
                    color = colorScheme.onSurfaceVariantActions,
                )
            },
            onValueChange = { newValue ->
                if (newValue.isEmpty()) {
                    text = ""
                } else {
                    val valid = newValue.count { it == '.' } <= 1 && newValue.all { it.isDigit() || it == '.' }
                    if (valid) {
                        text = newValue
                    }
                }
            },
        )
        Row(horizontalArrangement = Arrangement.SpaceBetween) {
            TextButton(
                text = stringResource(android.R.string.cancel),
                onClick = { showDialog.value = false },
                modifier = Modifier.weight(1f),
            )
            Spacer(Modifier.width(20.dp))
            TextButton(
                text = stringResource(android.R.string.ok),
                onClick = {
                    val parsed = text.toFloatOrNull()
                    val clamped = parsed?.coerceIn(80f, 110f) ?: (volumeState() * 100)
                    onVolumeChange(clamped / 100f)
                    showDialog.value = false
                },
                modifier = Modifier.weight(1f),
                colors = ButtonDefaults.textButtonColorsPrimary(),
            )
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/SendLogDialog.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.content.Intent
import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.Save
import androidx.compose.material.icons.rounded.Share
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.DpSize
import androidx.compose.ui.unit.dp
import androidx.core.content.FileProvider
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.BuildConfig
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.util.getBugreportFile
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperDialog
import top.yukonga.miuix.kmp.theme.MiuixTheme
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

@Composable
fun SendLogDialog(
    showDialog: MutableState<Boolean>,
    loadingDialog: LoadingDialogHandle,
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val exportBugreportLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.CreateDocument("application/gzip")
    ) { uri: Uri? ->
        if (uri == null) return@rememberLauncherForActivityResult
        scope.launch(Dispatchers.IO) {
            loadingDialog.show()
            context.contentResolver.openOutputStream(uri)?.use { output ->
                getBugreportFile(context).inputStream().use {
                    it.copyTo(output)
                }
            }
            loadingDialog.hide()
            withContext(Dispatchers.Main) {
                Toast.makeText(context, context.getString(R.string.log_saved), Toast.LENGTH_SHORT).show()
            }
        }
    }
    SuperDialog(
        show = showDialog,
        insideMargin = DpSize(0.dp, 0.dp),
        onDismissRequest = {
            showDialog.value = false
        },
        content = {
            Text(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 24.dp, bottom = 12.dp),
                text = stringResource(R.string.send_log),
                fontSize = MiuixTheme.textStyles.title4.fontSize,
                fontWeight = FontWeight.Medium,
                textAlign = TextAlign.Center,
                color = colorScheme.onSurface
            )
            SuperArrow(
                title = stringResource(id = R.string.save_log),
                startAction = {
                    Icon(
                        Icons.Rounded.Save,
                        contentDescription = null,
                        modifier = Modifier.padding(end = 16.dp),
                        tint = colorScheme.onSurface
                    )
                },
                onClick = {
                    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH_mm")
                    val current = LocalDateTime.now().format(formatter)
                    exportBugreportLauncher.launch("KernelSU_bugreport_${current}.tar.gz")
                    showDialog.value = false
                },
                insideMargin = PaddingValues(horizontal = 24.dp, vertical = 12.dp)
            )
            SuperArrow(
                title = stringResource(id = R.string.send_log),
                startAction = {
                    Icon(
                        Icons.Rounded.Share,
                        contentDescription = null,
                        modifier = Modifier.padding(end = 16.dp),
                        tint = colorScheme.onSurface
                    )
                },
                onClick = {
                    scope.launch {
                        showDialog.value = false
                        val bugreport = loadingDialog.withLoading {
                            withContext(Dispatchers.IO) {
                                getBugreportFile(context)
                            }
                        }

                        val uri: Uri =
                            FileProvider.getUriForFile(
                                context,
                                "${BuildConfig.APPLICATION_ID}.fileprovider",
                                bugreport
                            )

                        val shareIntent = Intent(Intent.ACTION_SEND).apply {
                            putExtra(Intent.EXTRA_STREAM, uri)
                            setDataAndType(uri, "application/gzip")
                            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        }

                        context.startActivity(
                            Intent.createChooser(
                                shareIntent,
                                context.getString(R.string.send_log)
                            )
                        )
                    }
                },
                insideMargin = PaddingValues(horizontal = 24.dp, vertical = 12.dp)
            )
            TextButton(
                text = stringResource(id = android.R.string.cancel),
                onClick = {
                    showDialog.value = false
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 12.dp, bottom = 24.dp)
                    .padding(horizontal = 24.dp)
            )
        }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/SuperEditArrow.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.filter.FilterNumber
import top.yukonga.miuix.kmp.basic.BasicComponentColors
import top.yukonga.miuix.kmp.basic.BasicComponentDefaults
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TextField
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperDialog

@Composable
fun SuperEditArrow(
    modifier: Modifier = Modifier,
    title: String,
    titleColor: BasicComponentColors = BasicComponentDefaults.titleColor(),
    defaultValue: Int = -1,
    summaryColor: BasicComponentColors = BasicComponentDefaults.summaryColor(),
    startAction: @Composable (() -> Unit)? = null,
    insideMargin: PaddingValues = BasicComponentDefaults.InsideMargin,
    enabled: Boolean = true,
    onValueChange: ((Int) -> Unit)? = null
) {
    val showDialog = remember { mutableStateOf(false) }
    val dialogTextFieldValue = remember { mutableIntStateOf(defaultValue) }

    SuperArrow(
        title = title,
        titleColor = titleColor,
        summary = dialogTextFieldValue.intValue.toString(),
        summaryColor = summaryColor,
        startAction = startAction,
        modifier = modifier,
        insideMargin = insideMargin,
        onClick = {
            showDialog.value = true
        },
        holdDownState = showDialog.value,
        enabled = enabled
    )

    EditDialog(
        title,
        showDialog,
        dialogTextFieldValue = dialogTextFieldValue.intValue,
    ) {
        dialogTextFieldValue.intValue = it
        onValueChange?.invoke(dialogTextFieldValue.intValue)
    }

}

@Composable
private fun EditDialog(
    title: String,
    showDialog: MutableState<Boolean>,
    dialogTextFieldValue: Int,
    onValueChange: (Int) -> Unit,
) {
    val inputTextFieldValue = remember { mutableIntStateOf(dialogTextFieldValue) }
    val filter = remember(key1 = inputTextFieldValue.intValue) { FilterNumber(dialogTextFieldValue) }

    SuperDialog(
        title = title,
        show = showDialog,
        onDismissRequest = {
            showDialog.value = false
            filter.setInputValue(dialogTextFieldValue.toString())
        }
    ) {
        TextField(
            modifier = Modifier.padding(bottom = 16.dp),
            value = filter.getInputValue(),
            maxLines = 1,
            keyboardOptions = KeyboardOptions(
                keyboardType = KeyboardType.Number,
            ),
            onValueChange = filter.onValueChange()
        )
        Row(
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            TextButton(
                text = stringResource(android.R.string.cancel),
                onClick = {
                    showDialog.value = false
                    filter.setInputValue(dialogTextFieldValue.toString())
                },
                modifier = Modifier.weight(1f)
            )
            Spacer(Modifier.width(20.dp))
            TextButton(
                text = stringResource(R.string.confirm),
                onClick = {
                    showDialog.value = false
                    with(filter.getInputValue().text) {
                        if (isEmpty()) {
                            onValueChange(0)
                            filter.setInputValue("0")
                        } else {
                            onValueChange(this@with.toInt())
                        }

                    }
                },
                modifier = Modifier.weight(1f),
                colors = ButtonDefaults.textButtonColorsPrimary()
            )
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/SuperSearchBar.kt`:

```kt
package me.weishu.kernelsu.ui.component

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.LinearOutSlowInEasing
import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandHorizontally
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.scaleIn
import androidx.compose.animation.scaleOut
import androidx.compose.animation.shrinkHorizontally
import androidx.compose.animation.slideInHorizontally
import androidx.compose.animation.slideInVertically
import androidx.compose.animation.slideOutHorizontally
import androidx.compose.animation.slideOutVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateEndPadding
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyListScope
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.Stable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.layout.positionInWindow
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.onClick
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.max
import androidx.compose.ui.zIndex
import androidx.navigationevent.NavigationEventInfo
import androidx.navigationevent.compose.NavigationBackHandler
import androidx.navigationevent.compose.rememberNavigationEventState
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.hazeEffect
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.InputField
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.basic.Search
import top.yukonga.miuix.kmp.icon.basic.SearchCleanup
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical

// Search Status Class
@Stable
class SearchStatus(val label: String) {
    var searchText by mutableStateOf("")
    var current by mutableStateOf(Status.COLLAPSED)

    var offsetY by mutableStateOf(0.dp)
    var resultStatus by mutableStateOf(ResultStatus.DEFAULT)

    fun isExpand() = current == Status.EXPANDED
    fun isCollapsed() = current == Status.COLLAPSED
    fun shouldExpand() = current == Status.EXPANDED || current == Status.EXPANDING
    fun shouldCollapsed() = current == Status.COLLAPSED || current == Status.COLLAPSING
    fun isAnimatingExpand() = current == Status.EXPANDING

    // 动画完成回调
    fun onAnimationComplete() {
        current = when (current) {
            Status.EXPANDING -> Status.EXPANDED
            Status.COLLAPSING -> {
                searchText = ""
                Status.COLLAPSED
            }

            else -> current
        }
    }

    @Composable
    fun TopAppBarAnim(
        modifier: Modifier = Modifier,
        visible: Boolean = shouldCollapsed(),
        hazeState: HazeState? = null,
        hazeStyle: HazeStyle? = null,
        content: @Composable () -> Unit
    ) {
        val topAppBarAlpha = animateFloatAsState(
            if (visible) 1f else 0f,
            animationSpec = tween(if (visible) 550 else 0, easing = FastOutSlowInEasing),
        )
        Box(modifier = modifier) {
            Box(
                modifier = Modifier
                    .matchParentSize()
                    .then(
                        if (hazeState != null && hazeStyle != null) {
                            Modifier.hazeEffect(hazeState) {
                                style = hazeStyle
                                blurRadius = 30.dp
                                noiseFactor = 0f
                            }
                        } else {
                            Modifier.background(colorScheme.surface)
                        }
                    )
            )
            Box(
                modifier = Modifier
                    .alpha(topAppBarAlpha.value)
            ) { content() }
        }
    }

    enum class Status { EXPANDED, EXPANDING, COLLAPSED, COLLAPSING }
    enum class ResultStatus { DEFAULT, EMPTY, LOAD, SHOW }
}

// Search Box Composable
@Composable
fun SearchStatus.SearchBox(
    collapseBar: @Composable (SearchStatus, Dp, PaddingValues) -> Unit = { searchStatus, topPadding, innerPadding ->
        SearchBarFake(searchStatus.label, topPadding, innerPadding)
    },
    searchBarTopPadding: Dp = 12.dp,
    contentPadding: PaddingValues = PaddingValues(0.dp),
    hazeState: HazeState,
    hazeStyle: HazeStyle,
    content: @Composable (MutableState<Dp>) -> Unit
) {
    val searchStatus = this
    val density = LocalDensity.current

    animateFloatAsState(if (searchStatus.shouldCollapsed()) 1f else 0f)

    val offsetY = remember { mutableIntStateOf(0) }
    val boxHeight = remember { mutableStateOf(0.dp) }

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .zIndex(10f)
            .alpha(if (searchStatus.isCollapsed()) 1f else 0f)
            .offset(y = contentPadding.calculateTopPadding())
            .onGloballyPositioned {
                it.positionInWindow().y.apply {
                    offsetY.intValue = (this@apply * 0.9).toInt()
                    with(density) {
                        searchStatus.offsetY = this@apply.toDp()
                        boxHeight.value = it.size.height.toDp()
                    }
                }
            }
            .pointerInput(Unit) {
                detectTapGestures { searchStatus.current = SearchStatus.Status.EXPANDING }
            }
            .hazeEffect(hazeState) {
                style = hazeStyle
                blurRadius = 30.dp
                noiseFactor = 0f
            }
    ) {
        collapseBar(searchStatus, searchBarTopPadding, contentPadding)
    }
    Box {
        AnimatedVisibility(
            visible = searchStatus.shouldCollapsed(),
            enter = fadeIn(tween(300, easing = LinearOutSlowInEasing)) + slideInVertically(
                tween(
                    300,
                    easing = LinearOutSlowInEasing
                )
            ) { -offsetY.intValue },
            exit = fadeOut(tween(300, easing = LinearOutSlowInEasing)) + slideOutVertically(
                tween(
                    300,
                    easing = LinearOutSlowInEasing
                )
            ) { -offsetY.intValue }
        ) {
            content(boxHeight)
        }
    }
}

// Search Pager Composable
@Composable
fun SearchStatus.SearchPager(
    defaultResult: @Composable () -> Unit,
    expandBar: @Composable (SearchStatus, Dp) -> Unit = { searchStatus, padding ->
        SearchBar(searchStatus, padding)
    },
    searchBarTopPadding: Dp = 12.dp,
    result: LazyListScope.() -> Unit
) {
    val searchStatus = this
    val systemBarsPadding = WindowInsets.systemBars.asPaddingValues().calculateTopPadding()
    val topPadding by animateDpAsState(
        targetValue = if (searchStatus.shouldExpand()) {
            systemBarsPadding + 5.dp
        } else {
            max(searchStatus.offsetY, 0.dp)
        },
        animationSpec = tween(300, easing = LinearOutSlowInEasing)
    ) {
        searchStatus.onAnimationComplete()
    }
    val surfaceAlpha by animateFloatAsState(
        if (searchStatus.shouldExpand()) 1f else 0f,
        animationSpec = tween(200, easing = FastOutSlowInEasing)
    )

    Column(
        modifier = Modifier
            .fillMaxSize()
            .zIndex(5f)
            .background(colorScheme.surface.copy(alpha = surfaceAlpha))
            .semantics { onClick { false } }
            .then(
                if (!searchStatus.isCollapsed()) Modifier.pointerInput(Unit) { } else Modifier
            )
    ) {
        Row(
            Modifier
                .fillMaxWidth()
                .padding(top = topPadding)
                .then(
                    if (!searchStatus.isCollapsed()) Modifier.background(colorScheme.surface)
                    else Modifier
                ),
            horizontalArrangement = Arrangement.Start,
            verticalAlignment = Alignment.CenterVertically
        ) {
            if (!searchStatus.isCollapsed()) {
                Box(
                    modifier = Modifier
                        .weight(1f)
                        .background(colorScheme.surface)
                ) {
                    expandBar(searchStatus, searchBarTopPadding)
                }
            }
            AnimatedVisibility(
                visible = searchStatus.isExpand() || searchStatus.isAnimatingExpand(),
                enter = expandHorizontally() + slideInHorizontally(initialOffsetX = { it }),
                exit = shrinkHorizontally() + slideOutHorizontally(targetOffsetX = { it })
            ) {
                Text(
                    text = stringResource(android.R.string.cancel),
                    fontWeight = FontWeight.Bold,
                    color = colorScheme.primary,
                    modifier = Modifier
                        .padding(start = 4.dp, end = 16.dp, top = searchBarTopPadding)
                        .clickable(
                            interactionSource = null,
                            enabled = searchStatus.isExpand(),
                            indication = null
                        ) {
                            searchStatus.searchText = ""
                            searchStatus.current = SearchStatus.Status.COLLAPSING
                        }
                )
                run {
                    val navEventState = rememberNavigationEventState(NavigationEventInfo.None)
                    NavigationBackHandler(
                        state = navEventState,
                        isBackEnabled = true,
                        onBackCompleted = {
                            searchStatus.searchText = ""
                            searchStatus.current = SearchStatus.Status.COLLAPSING
                        }
                    )
                }
            }
        }
        AnimatedVisibility(
            visible = searchStatus.isExpand(),
            modifier = Modifier
                .fillMaxSize()
                .zIndex(1f),
            enter = fadeIn(),
            exit = fadeOut()
        ) {
            when (searchStatus.resultStatus) {
                SearchStatus.ResultStatus.DEFAULT -> defaultResult()
                SearchStatus.ResultStatus.EMPTY -> {}
                SearchStatus.ResultStatus.LOAD -> {}
                SearchStatus.ResultStatus.SHOW -> LazyColumn(
                    Modifier
                        .fillMaxSize()
                        .overScrollVertical(),
                ) {
                    result()
                }
            }
        }
    }
}

@Composable
fun SearchBar(
    searchStatus: SearchStatus,
    searchBarTopPadding: Dp = 12.dp,
) {
    val focusRequester = remember { FocusRequester() }
    var expanded by rememberSaveable { mutableStateOf(false) }

    InputField(
        query = searchStatus.searchText,
        onQueryChange = { searchStatus.searchText = it },
        label = "",
        leadingIcon = {
            Icon(
                imageVector = MiuixIcons.Basic.Search,
                contentDescription = "back",
                modifier = Modifier
                    .size(44.dp)
                    .padding(start = 16.dp, end = 8.dp),
                tint = colorScheme.onSurfaceContainerHigh,
            )
        },
        trailingIcon = {
            AnimatedVisibility(
                searchStatus.searchText.isNotEmpty(),
                enter = fadeIn() + scaleIn(),
                exit = fadeOut() + scaleOut(),
            ) {
                Icon(
                    imageVector = MiuixIcons.Basic.SearchCleanup,
                    tint = colorScheme.onSurface,
                    contentDescription = "Clean",
                    modifier = Modifier
                        .size(44.dp)
                        .padding(start = 8.dp, end = 16.dp)
                        .clickable(
                            interactionSource = null,
                            indication = null
                        ) {
                            searchStatus.searchText = ""
                        },
                )
            }
        },
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 12.dp)
            .padding(top = searchBarTopPadding, bottom = 6.dp)
            .focusRequester(focusRequester),
        onSearch = { it },
        expanded = searchStatus.shouldExpand(),
        onExpandedChange = {
            searchStatus.current = if (it) SearchStatus.Status.EXPANDED else SearchStatus.Status.COLLAPSED
        }
    )
    LaunchedEffect(Unit) {
        if (!expanded && searchStatus.shouldExpand()) {
            focusRequester.requestFocus()
            expanded = true
        }
    }
}

@Composable
fun SearchBarFake(
    label: String,
    searchBarTopPadding: Dp = 12.dp,
    innerPadding: PaddingValues = PaddingValues(0.dp)
) {
    val layoutDirection = LocalLayoutDirection.current
    InputField(
        query = "",
        onQueryChange = { },
        label = label,
        leadingIcon = {
            Icon(
                imageVector = MiuixIcons.Basic.Search,
                contentDescription = "Clean",
                modifier = Modifier
                    .size(44.dp)
                    .padding(start = 16.dp, end = 8.dp),
                tint = colorScheme.onSurfaceContainerHigh,
            )
        },
        modifier = Modifier
            .padding(horizontal = 12.dp)
            .padding(
                start = innerPadding.calculateStartPadding(layoutDirection),
                end = innerPadding.calculateEndPadding(layoutDirection)
            )
            .padding(top = searchBarTopPadding, bottom = 6.dp),
        onSearch = { },
        enabled = false,
        expanded = false,
        onExpandedChange = { }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/UninstallDialog.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.widget.Toast
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.DpSize
import androidx.compose.ui.unit.dp
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.screen.FlashIt
import me.weishu.kernelsu.ui.screen.UninstallType
import me.weishu.kernelsu.ui.screen.UninstallType.NONE
import me.weishu.kernelsu.ui.screen.UninstallType.PERMANENT
import me.weishu.kernelsu.ui.screen.UninstallType.RESTORE_STOCK_IMAGE
import me.weishu.kernelsu.ui.screen.UninstallType.TEMPORARY
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperDialog
import top.yukonga.miuix.kmp.theme.MiuixTheme

@Composable
fun UninstallDialog(
    showDialog: MutableState<Boolean>,
    navigator: Navigator,
) {
    val context = LocalContext.current
    val options = listOf(
        // TEMPORARY,
        PERMANENT,
        RESTORE_STOCK_IMAGE
    )
    val showTodo = {
        Toast.makeText(context, "TODO", Toast.LENGTH_SHORT).show()
    }
    val showConfirmDialog = remember(showDialog.value) { mutableStateOf(false) }
    val runType = remember(showDialog.value) { mutableStateOf<UninstallType?>(null) }

    val run = { type: UninstallType ->
        when (type) {
            PERMANENT -> navigator.push(Route.Flash(FlashIt.FlashUninstall))

            RESTORE_STOCK_IMAGE -> navigator.push(Route.Flash(FlashIt.FlashRestore))

            TEMPORARY -> showTodo()
            NONE -> Unit
        }
    }

    SuperDialog(
        show = showDialog,
        insideMargin = DpSize(0.dp, 0.dp),
        onDismissRequest = {
            showDialog.value = false
        },
        content = {
            Text(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 24.dp, bottom = 12.dp),
                text = stringResource(R.string.uninstall),
                fontSize = MiuixTheme.textStyles.title4.fontSize,
                fontWeight = FontWeight.Medium,
                textAlign = TextAlign.Center,
                color = MiuixTheme.colorScheme.onSurface
            )
            options.forEach { type ->
                SuperArrow(
                    onClick = {
                        showConfirmDialog.value = true
                        runType.value = type
                    },
                    title = stringResource(type.title),
                    startAction = {
                        Icon(
                            imageVector = type.icon,
                            contentDescription = null,
                            modifier = Modifier.padding(end = 16.dp),
                            tint = MiuixTheme.colorScheme.onSurface
                        )
                    },
                    insideMargin = PaddingValues(horizontal = 24.dp, vertical = 12.dp)
                )
            }
            TextButton(
                text = stringResource(id = android.R.string.cancel),
                onClick = {
                    showDialog.value = false
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 12.dp, bottom = 24.dp)
                    .padding(horizontal = 24.dp)
            )
        }
    )
    val confirmDialog = rememberConfirmDialog(
        onConfirm = {
            showConfirmDialog.value = false
            showDialog.value = false
            runType.value?.let { type ->
                run(type)
            }
        },
        onDismiss = {
            showConfirmDialog.value = false
        }
    )
    val dialogTitle = runType.value?.let { type ->
        options.find { it == type }?.let { stringResource(it.title) }
    } ?: ""
    val dialogContent = runType.value?.let { type ->
        options.find { it == type }?.let { stringResource(it.message) }
    }
    if (showConfirmDialog.value) {
        confirmDialog.showConfirm(title = dialogTitle, content = dialogContent)
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/filter/BaseFieldFilter.kt`:

```kt
package me.weishu.kernelsu.ui.component.filter

import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.input.TextFieldValue

open class BaseFieldFilter() {
    private var inputValue = mutableStateOf(TextFieldValue())

    constructor(value: String) : this() {
        inputValue.value = TextFieldValue(value, TextRange(value.lastIndex + 1))
    }

    protected open fun onFilter(inputTextFieldValue: TextFieldValue, lastTextFieldValue: TextFieldValue): TextFieldValue {
        return TextFieldValue()
    }

    protected open fun computePos(): Int {
        // TODO
        return 0
    }

    protected fun getNewTextRange(
        lastTextFiled: TextFieldValue,
        inputTextFieldValue: TextFieldValue
    ): TextRange? {
        return null
    }

    protected fun getNewText(
        lastTextFiled: TextFieldValue,
        inputTextFieldValue: TextFieldValue
    ): TextRange? {

        return null
    }

    fun setInputValue(value: String) {
        inputValue.value = TextFieldValue(value, TextRange(value.lastIndex + 1))
    }

    fun getInputValue(): TextFieldValue {
        return inputValue.value
    }

    fun onValueChange(): (TextFieldValue) -> Unit {
        return {
            inputValue.value = onFilter(it, inputValue.value)
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/filter/FilterNumber.kt`:

```kt
package me.weishu.kernelsu.ui.component.filter

import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.input.TextFieldValue

class FilterNumber(
    private val value: Int,
    private val minValue: Int = Int.MIN_VALUE,
    private val maxValue: Int = Int.MAX_VALUE,
) : BaseFieldFilter(value.toString()) {

    override fun onFilter(
        inputTextFieldValue: TextFieldValue,
        lastTextFieldValue: TextFieldValue
    ): TextFieldValue {
        return filterInputNumber(inputTextFieldValue, lastTextFieldValue, minValue, maxValue)
    }

    private fun filterInputNumber(
        inputTextFieldValue: TextFieldValue,
        lastInputTextFieldValue: TextFieldValue,
        minValue: Int = Int.MIN_VALUE,
        maxValue: Int = Int.MAX_VALUE,
    ): TextFieldValue {
        val inputString = inputTextFieldValue.text
        lastInputTextFieldValue.text

        val newString = StringBuilder()
        val supportNegative = minValue < 0
        var isNegative = false

        // 只允许负号在首位，并且只允许一个负号
        if (supportNegative && inputString.isNotEmpty() && inputString.first() == '-') {
            isNegative = true
            newString.append('-')
        }

        for ((i, c) in inputString.withIndex()) {
            if (i == 0 && isNegative) continue // 首字符已经处理
            when (c) {
                in '0'..'9' -> {
                    newString.append(c)
                    // 检查是否超出范围
                    val tempText = newString.toString()
                    // 只在不是单独 '-' 时做判断（因为 '-' toInt 会异常）
                    if (tempText != "-" && tempText.isNotEmpty()) {
                        try {
                            val tempValue = tempText.toInt()
                            if (tempValue > maxValue || tempValue < minValue) {
                                newString.deleteCharAt(newString.lastIndex)
                            }
                        } catch (e: NumberFormatException) {
                            // 超出int范围
                            newString.deleteCharAt(newString.lastIndex)
                        }
                    }
                }
                // 忽略其他字符（包括点号）
            }
        }

        val textRange: TextRange
        if (inputTextFieldValue.selection.collapsed) { // 表示的是光标范围
            if (inputTextFieldValue.selection.end != inputTextFieldValue.text.length) { // 光标没有指向末尾
                var newPosition = inputTextFieldValue.selection.end + (newString.length - inputString.length)
                if (newPosition < 0) {
                    newPosition = inputTextFieldValue.selection.end
                }
                textRange = TextRange(newPosition)
            } else { // 光标指向了末尾
                textRange = TextRange(newString.length)
            }
        } else {
            textRange = TextRange(newString.length)
        }

        return lastInputTextFieldValue.copy(
            text = newString.toString(),
            selection = textRange
        )
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/profile/AppProfileConfig.kt`:

```kt
package me.weishu.kernelsu.ui.component.profile

import androidx.compose.foundation.layout.Column
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.EditText
import top.yukonga.miuix.kmp.extra.SuperSwitch

@Composable
fun AppProfileConfig(
    modifier: Modifier = Modifier,
    fixedName: Boolean,
    enabled: Boolean,
    profile: Natives.Profile,
    onProfileChange: (Natives.Profile) -> Unit,
) {
    Column(modifier = modifier) {
        if (!fixedName) {
            EditText(
                title = stringResource(R.string.profile_name),
                textValue = remember { mutableStateOf(profile.name) },
                onTextValueChange = { onProfileChange(profile.copy(name = it)) },
                enabled = enabled,
            )
        }

        SuperSwitch(
            title = stringResource(R.string.profile_umount_modules),
            summary = stringResource(R.string.profile_umount_modules_summary),
            checked = if (enabled) {
                profile.umountModules
            } else {
                Natives.isDefaultUmountModules()
            },
            enabled = enabled,
            onCheckedChange = {
                onProfileChange(
                    profile.copy(
                        umountModules = it,
                        nonRootUseDefault = false
                    )
                )
            }
        )
    }
}

@Preview
@Composable
private fun AppProfileConfigPreview() {
    var profile by remember { mutableStateOf(Natives.Profile("")) }
    AppProfileConfig(fixedName = true, enabled = false, profile = profile) {
        profile = it
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/profile/RootProfileConfig.kt`:

```kt
package me.weishu.kernelsu.ui.component.profile

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.DpSize
import androidx.compose.ui.unit.dp
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.profile.Capabilities
import me.weishu.kernelsu.profile.Groups
import me.weishu.kernelsu.ui.component.SuperEditArrow
import me.weishu.kernelsu.ui.util.isSepolicyValid
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TextField
import top.yukonga.miuix.kmp.extra.CheckboxLocation
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperCheckbox
import top.yukonga.miuix.kmp.extra.SuperDialog
import top.yukonga.miuix.kmp.extra.SuperDropdown
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme

@Composable
fun RootProfileConfig(
    modifier: Modifier = Modifier,
    fixedName: Boolean,
    profile: Natives.Profile,
    onProfileChange: (Natives.Profile) -> Unit,
) {
    Column(
        modifier = modifier
    ) {
        if (!fixedName) {
            TextField(
                label = stringResource(R.string.profile_name),
                value = profile.name,
                onValueChange = { onProfileChange(profile.copy(name = it)) }
            )
        }

        SuperEditArrow(
            title = "UID",
            defaultValue = profile.uid,
        ) {
            onProfileChange(
                profile.copy(
                    uid = it,
                    rootUseDefault = false
                )
            )

        }

        SuperEditArrow(
            title = "GID",
            defaultValue = profile.gid,
        ) {
            onProfileChange(
                profile.copy(
                    gid = it,
                    rootUseDefault = false
                )
            )

        }

        val selectedGroups = profile.groups.ifEmpty { listOf(0) }.let { e ->
            e.mapNotNull { g ->
                Groups.entries.find { it.gid == g }
            }
        }

        GroupsPanel(selectedGroups) {
            onProfileChange(
                profile.copy(
                    groups = it.map { group -> group.gid }.ifEmpty { listOf(0) },
                    rootUseDefault = false
                )
            )
        }

        val selectedCaps = profile.capabilities.mapNotNull { e ->
            Capabilities.entries.find { it.cap == e }
        }

        CapsPanel(selectedCaps) {
            onProfileChange(
                profile.copy(
                    capabilities = it.map { cap -> cap.cap },
                    rootUseDefault = false
                )
            )
        }

        MountNameSpacePanel(profile = profile) {
            onProfileChange(
                profile.copy(
                    namespace = it,
                    rootUseDefault = false
                )
            )
        }

        SELinuxPanel(profile = profile, onSELinuxChange = { domain, rules ->
            onProfileChange(
                profile.copy(
                    context = domain,
                    rules = rules,
                    rootUseDefault = false
                )
            )
        })
    }
}

@Composable
fun GroupsPanel(selected: List<Groups>, closeSelection: (selection: Set<Groups>) -> Unit) {
    val showDialog = remember { mutableStateOf(false) }

    val groups = remember {
        Groups.entries.toTypedArray().sortedWith(
            compareBy<Groups> { if (selected.contains(it)) 0 else 1 }
                .then(compareBy {
                    when (it) {
                        Groups.ROOT -> 0
                        Groups.SYSTEM -> 1
                        Groups.SHELL -> 2
                        else -> Int.MAX_VALUE
                    }
                })
                .then(compareBy { it.name })
        )
    }

    val currentSelection = remember { mutableStateOf(selected.toSet()) }

    SuperDialog(
        show = showDialog,
        title = stringResource(R.string.profile_groups),
        summary = "${currentSelection.value.size} / 32",
        insideMargin = DpSize(0.dp, 24.dp),
        onDismissRequest = { showDialog.value = false }
    ) {
        Column(modifier = Modifier.heightIn(max = 500.dp)) {
            LazyColumn(modifier = Modifier.weight(1f, fill = false)) {
                items(groups) { group ->
                    SuperCheckbox(
                        title = group.display,
                        summary = group.desc,
                        insideMargin = PaddingValues(horizontal = 30.dp, vertical = 16.dp),
                        checkboxLocation = CheckboxLocation.End,
                        checked = currentSelection.value.contains(group),
                        holdDownState = currentSelection.value.contains(group),
                        onCheckedChange = { isChecked ->
                            val newSelection = currentSelection.value.toMutableSet()
                            if (isChecked) {
                                if (newSelection.size < 32) newSelection.add(group)
                            } else {
                                newSelection.remove(group)
                            }
                            currentSelection.value = newSelection
                        }
                    )
                }
            }
            Spacer(Modifier.height(12.dp))
            Row(
                modifier = Modifier.padding(horizontal = 24.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                TextButton(
                    onClick = {
                        currentSelection.value = selected.toSet()
                        showDialog.value = false
                    },
                    text = stringResource(android.R.string.cancel),
                    modifier = Modifier.weight(1f),
                )
                Spacer(modifier = Modifier.width(20.dp))
                TextButton(
                    onClick = {
                        closeSelection(currentSelection.value)
                        showDialog.value = false
                    },
                    text = stringResource(R.string.confirm),
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.textButtonColorsPrimary()
                )
            }
        }
    }

    val tag = if (selected.isEmpty()) {
        "None"
    } else {
        selected.joinToString(separator = ",", transform = { it.display })
    }
    SuperArrow(
        title = stringResource(R.string.profile_groups),
        summary = tag,
        onClick = {
            showDialog.value = true
        },
    )

}

@Composable
fun MountNameSpacePanel(
    profile: Natives.Profile, onMntNamespaceChange: (namespaceType: Int) -> Unit
) {
    SuperDropdown(
        title = stringResource(id = R.string.profile_namespace), items = listOf(
            stringResource(id = R.string.profile_namespace_inherited),
            stringResource(id = R.string.profile_namespace_global),
            stringResource(id = R.string.profile_namespace_individual),
        ), selectedIndex = profile.namespace, onSelectedIndexChange = { index ->
            onMntNamespaceChange(index)
        })
}

@Composable
fun CapsPanel(
    selected: Collection<Capabilities>,
    closeSelection: (selection: Set<Capabilities>) -> Unit
) {
    val showDialog = remember { mutableStateOf(false) }

    val caps = remember {
        Capabilities.entries.toTypedArray().sortedWith(
            compareBy<Capabilities> { if (selected.contains(it)) 0 else 1 }
                .then(compareBy { it.name })
        )
    }

    val currentSelection = remember { mutableStateOf(selected.toSet()) }

    SuperDialog(
        show = showDialog,
        title = stringResource(R.string.profile_capabilities),
        insideMargin = DpSize(0.dp, 24.dp),
        onDismissRequest = { showDialog.value = false },
        content = {
            Column(modifier = Modifier.heightIn(max = 500.dp)) {
                LazyColumn(modifier = Modifier.weight(1f, fill = false)) {
                    items(caps) { cap ->
                        SuperCheckbox(
                            title = cap.display,
                            summary = cap.desc,
                            insideMargin = PaddingValues(horizontal = 30.dp, vertical = 16.dp),
                            checkboxLocation = CheckboxLocation.End,
                            checked = currentSelection.value.contains(cap),
                            holdDownState = currentSelection.value.contains(cap),
                            onCheckedChange = { isChecked ->
                                val newSelection = currentSelection.value.toMutableSet()
                                if (isChecked) {
                                    newSelection.add(cap)
                                } else {
                                    newSelection.remove(cap)
                                }
                                currentSelection.value = newSelection
                            }
                        )
                    }
                }
                Spacer(Modifier.height(12.dp))
                Row(
                    modifier = Modifier.padding(horizontal = 24.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    TextButton(
                        onClick = {
                            showDialog.value = false
                            currentSelection.value = selected.toSet()
                        },
                        text = stringResource(android.R.string.cancel),
                        modifier = Modifier.weight(1f)
                    )
                    Spacer(modifier = Modifier.width(20.dp))
                    TextButton(
                        onClick = {
                            closeSelection(currentSelection.value)
                            showDialog.value = false
                        },
                        text = stringResource(R.string.confirm),
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.textButtonColorsPrimary()
                    )
                }
            }
        }
    )

    val tag = if (selected.isEmpty()) {
        "None"
    } else {
        selected.joinToString(separator = ",", transform = { it.display })
    }
    SuperArrow(
        title = stringResource(R.string.profile_capabilities),
        summary = tag,
        onClick = {
            showDialog.value = true
        }
    )

}

@Composable
private fun SELinuxPanel(
    profile: Natives.Profile,
    onSELinuxChange: (domain: String, rules: String) -> Unit
) {
    val showDialog = remember { mutableStateOf(false) }

    var domain by remember { mutableStateOf(profile.context) }
    var rules by remember { mutableStateOf(profile.rules) }

    val isDomainValid = remember(domain) {
        val regex = Regex("^[a-z_]+:[a-z0-9_]+:[a-z0-9_]+(:[a-z0-9_]+)?$")
        domain.matches(regex)
    }
    val isRulesValid = remember(rules) { isSepolicyValid(rules) }

    SuperDialog(
        show = showDialog,
        title = stringResource(R.string.profile_selinux_context),
        onDismissRequest = { showDialog.value = false }
    ) {
        Column(modifier = Modifier.heightIn(max = 500.dp)) {
            Column(modifier = Modifier.weight(1f, fill = false)) {
                TextField(
                    value = domain,
                    onValueChange = { domain = it },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp),
                    label = stringResource(id = R.string.profile_selinux_domain),
                    borderColor = if (isDomainValid) {
                        colorScheme.primary
                    } else {
                        Color.Red.copy(alpha = if (isSystemInDarkTheme()) 0.3f else 0.6f)
                    },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Ascii,
                        imeAction = ImeAction.Next
                    ),
                    singleLine = true
                )
                TextField(
                    value = rules,
                    onValueChange = { rules = it },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp),
                    label = stringResource(id = R.string.profile_selinux_rules),
                    borderColor = if (isRulesValid) {
                        colorScheme.primary
                    } else {
                        Color.Red.copy(alpha = if (isSystemInDarkTheme()) 0.3f else 0.6f)
                    },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Ascii,
                    ),
                    singleLine = false
                )
            }
            Spacer(Modifier.height(12.dp))
            Row(
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                TextButton(
                    onClick = { showDialog.value = false },
                    text = stringResource(android.R.string.cancel),
                    modifier = Modifier.weight(1f)
                )
                Spacer(modifier = Modifier.width(20.dp))
                TextButton(
                    onClick = {
                        onSELinuxChange(domain, rules)
                        showDialog.value = false
                    },
                    text = stringResource(R.string.confirm),
                    enabled = isDomainValid && isRulesValid,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.textButtonColorsPrimary()
                )
            }
        }
    }

    SuperArrow(
        title = stringResource(R.string.profile_selinux_context),
        summary = profile.context,
        onClick = { showDialog.value = true }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/profile/TemplateConfig.kt`:

```kt
package me.weishu.kernelsu.ui.component.profile

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.Create
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.util.listAppProfileTemplates
import me.weishu.kernelsu.ui.util.setSepolicy
import me.weishu.kernelsu.ui.viewmodel.getTemplateInfoById
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperDropdown
import top.yukonga.miuix.kmp.theme.MiuixTheme

/**
 * @author weishu
 * @date 2023/10/21.
 */
@Composable
fun TemplateConfig(
    modifier: Modifier = Modifier,
    profile: Natives.Profile,
    onViewTemplate: (id: String) -> Unit = {},
    onManageTemplate: () -> Unit = {},
    onProfileChange: (Natives.Profile) -> Unit
) {
    val profileTemplates = listAppProfileTemplates()
    val noTemplates = profileTemplates.isEmpty()

    if (noTemplates) {
        SuperArrow(
            modifier = modifier,
            title = stringResource(R.string.app_profile_template_create),
            startAction = {
                Icon(
                    Icons.Rounded.Create,
                    null,
                    modifier = Modifier.padding(end = 16.dp),
                    tint = MiuixTheme.colorScheme.onBackground
                )
            },
            onClick = onManageTemplate,
        )
    } else {
        var template by rememberSaveable { mutableStateOf(profile.rootTemplate ?: profileTemplates[0]) }

        Column(modifier = modifier) {
            SuperDropdown(
                title = stringResource(R.string.profile_template),
                items = profileTemplates,
                selectedIndex = profileTemplates.indexOf(template).takeIf { it >= 0 } ?: 0,
                onSelectedIndexChange = { index ->
                    if (index < 0 || index >= profileTemplates.size) return@SuperDropdown
                    template = profileTemplates[index]
                    val templateInfo = getTemplateInfoById(template)
                    if (templateInfo != null && setSepolicy(template, templateInfo.rules.joinToString("\n"))) {
                        onProfileChange(
                            profile.copy(
                                rootTemplate = template,
                                rootUseDefault = false,
                                uid = templateInfo.uid,
                                gid = templateInfo.gid,
                                groups = templateInfo.groups,
                                capabilities = templateInfo.capabilities,
                                context = templateInfo.context,
                                namespace = templateInfo.namespace,
                            )
                        )
                    }
                },
                maxHeight = 280.dp
            )
            SuperArrow(
                title = stringResource(R.string.app_profile_template_view),
                onClick = { onViewTemplate(template) }
            )
        }
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/component/rebootListPopup.kt`:

```kt
package me.weishu.kernelsu.ui.component

import android.content.Context
import android.os.Build
import android.os.PowerManager
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.screen.RebootDropdownItem
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.ListPopupColumn
import top.yukonga.miuix.kmp.basic.ListPopupDefaults
import top.yukonga.miuix.kmp.basic.PopupPositionProvider
import top.yukonga.miuix.kmp.extra.SuperListPopup
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Close2
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme

@Composable
fun RebootListPopup(
    modifier: Modifier = Modifier,
    alignment: PopupPositionProvider.Align = PopupPositionProvider.Align.TopEnd
) {
    val showTopPopup = remember { mutableStateOf(false) }
    KsuIsValid {
        IconButton(
            modifier = modifier,
            onClick = { showTopPopup.value = true },
            holdDownState = showTopPopup.value
        ) {
            Icon(
                imageVector = MiuixIcons.Close2,
                contentDescription = stringResource(id = R.string.reboot),
                tint = colorScheme.onBackground
            )
        }
        SuperListPopup(
            show = showTopPopup,
            popupPositionProvider = ListPopupDefaults.ContextMenuPositionProvider,
            alignment = alignment,
            onDismissRequest = {
                showTopPopup.value = false
            }
        ) {
            val pm = LocalContext.current.getSystemService(Context.POWER_SERVICE) as PowerManager?

            @Suppress("DEPRECATION")
            val isRebootingUserspaceSupported =
                Build.VERSION.SDK_INT >= Build.VERSION_CODES.R && pm?.isRebootingUserspaceSupported == true

            ListPopupColumn {
                val rebootOptions = mutableListOf(
                    Pair(R.string.reboot, ""),
                    Pair(R.string.reboot_recovery, "recovery"),
                    Pair(R.string.reboot_bootloader, "bootloader"),
                    Pair(R.string.reboot_download, "download"),
                    Pair(R.string.reboot_edl, "edl")
                )
                if (isRebootingUserspaceSupported) {
                    rebootOptions.add(1, Pair(R.string.reboot_userspace, "userspace"))
                }
                rebootOptions.forEachIndexed { idx, (id, reason) ->
                    RebootDropdownItem(
                        id = id,
                        reason = reason,
                        showTopPopup = showTopPopup,
                        optionSize = rebootOptions.size,
                        index = idx
                    )
                }
            }
        }
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/navigation3/DeepLinkResolver.kt`:

```kt
package me.weishu.kernelsu.ui.navigation3

import android.app.Activity
import android.content.Intent
import android.net.Uri
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.State
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.platform.LocalContext

/**
 * Deep link resolution: maps external Intent/Uri to an initial back stack.
 * Call resolve(intent) at Activity start to seed the back stack.
 */
object DeepLinkResolver {
    fun resolve(intent: Intent?): List<Route> {
        if (intent == null) return emptyList()
        val shortcutType = intent.getStringExtra("shortcut_type")
        return when (shortcutType) {
            "module_action" -> {
                val moduleId = intent.getStringExtra("module_id") ?: return emptyList()
                listOf(Route.Main, Route.ExecuteModuleAction(moduleId))
            }

            else -> emptyList()
        }
    }

    fun resolve(uri: Uri?): List<Route> {
        return emptyList()
    }
}

/**
 * Composable that handles deep link intents and updates the back stack accordingly.
 * Should be placed at the root of the NavHost.
 */
@Composable
fun HandleDeepLink(
    intentState: State<Int>,
) {
    val context = LocalContext.current
    val activity = context as? Activity
    val currentIntentId by intentState
    val navigator = LocalNavigator.current
    var lastHandledIntentId by rememberSaveable { mutableIntStateOf(-1) }

    LaunchedEffect(currentIntentId) {
        if (currentIntentId != lastHandledIntentId) {
            val intent = activity?.intent
            val initialStack = DeepLinkResolver.resolve(intent)
            if (initialStack.isNotEmpty()) {
                navigator.replaceAll(initialStack)
            }
            lastHandledIntentId = currentIntentId
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/navigation3/Navigator.kt`:

```kt
package me.weishu.kernelsu.ui.navigation3

import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.saveable.Saver
import androidx.compose.runtime.saveable.listSaver
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.snapshots.SnapshotStateList
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.navigation3.runtime.NavKey
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow

/**
 * Simple navigation helper that owns a back stack and result channels.
 * Supports push/replace/pop/popUntil and result APIs: navigateForResult/setResult/observeResult/clearResult.
 */
class Navigator(
    initialKey: NavKey
) {
    val backStack: SnapshotStateList<NavKey> = mutableStateListOf(initialKey)

    private val resultBus = mutableMapOf<String, MutableSharedFlow<Any>>()

    /**
     * Push a key onto the back stack.
     */
    fun push(key: NavKey) {
        backStack.add(key)
    }

    /**
     * Replace the top key, or push if the stack is empty.
     */
    fun replace(key: NavKey) {
        if (backStack.isNotEmpty()) {
            backStack[backStack.lastIndex] = key
        } else {
            backStack.add(key)
        }
    }

    /**
     * Replace the backstack with a new list of keys if the stack is not empty.
     */
    fun replaceAll(keys: List<NavKey>) {
        if (keys.isEmpty()) {
            return
        }
        if (backStack.isNotEmpty()) {
            backStack.clear()
            backStack.addAll(keys)
        }
    }


    /**
     * Pop the top key if present.
     */
    fun pop() {
        backStack.removeLastOrNull()
    }

    /**
     * Pop until predicate matches the top key.
     */
    fun popUntil(predicate: (NavKey) -> Boolean) {
        while (backStack.isNotEmpty() && !predicate(backStack.last())) {
            backStack.removeAt(backStack.lastIndex)
        }
    }

    /**
     * Navigate expecting a result. Caller should subscribe via observeResult(requestKey).
     */
    fun navigateForResult(route: Route, requestKey: String) {
        ensureChannel(requestKey)
        push(route)
    }

    /**
     * Set a result for the given request and then pop.
     */
    fun <T : Any> setResult(requestKey: String, value: T) {
        ensureChannel(requestKey).tryEmit(value)
        pop()
    }

    /**
     * Observe results for a given request key as a SharedFlow.
     */
    @Suppress("UNCHECKED_CAST")
    fun <T : Any> observeResult(requestKey: String): SharedFlow<T> {
        return ensureChannel(requestKey) as SharedFlow<T>
    }

    /**
     * Clear the last emitted result for the request key.
     */
    @OptIn(ExperimentalCoroutinesApi::class)
    fun clearResult(requestKey: String) {
        ensureChannel(requestKey).resetReplayCache()
    }

    /**
     * Get current NavKey on the back stack.
     */
    fun current(): NavKey? {
        return backStack.lastOrNull()
    }

    /**
     * Get current size of back stack.
     */
    fun backStackSize(): Int {
        return backStack.size
    }

    private fun ensureChannel(key: String): MutableSharedFlow<Any> {
        return resultBus.getOrPut(key) { MutableSharedFlow(replay = 1, extraBufferCapacity = 0) }
    }

    companion object {
        val Saver: Saver<Navigator, Any> = listSaver(save = { navigator ->
            navigator.backStack.toList()
        }, restore = { savedList ->
            val initialKey = savedList.firstOrNull() ?: Route.Home
            val navigator = Navigator(initialKey)
            navigator.backStack.clear()
            navigator.backStack.addAll(savedList)
            navigator
        })
    }
}


@Composable
fun rememberNavigator(startRoute: NavKey): Navigator {
    return rememberSaveable(startRoute, saver = Navigator.Saver) {
        Navigator(startRoute)
    }
}

val LocalNavigator = staticCompositionLocalOf<Navigator> {
    error("LocalNavigator not provided")
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/navigation3/Routes.kt`:

```kt
package me.weishu.kernelsu.ui.navigation3

import android.os.Parcelable
import androidx.navigation3.runtime.NavKey
import kotlinx.parcelize.Parcelize
import kotlinx.serialization.Serializable
import me.weishu.kernelsu.ui.screen.FlashIt
import me.weishu.kernelsu.ui.screen.RepoModuleArg
import me.weishu.kernelsu.ui.util.FlashItSerializer
import me.weishu.kernelsu.ui.util.RepoModuleArgSerializer
import me.weishu.kernelsu.ui.util.TemplateInfoSerializer
import me.weishu.kernelsu.ui.viewmodel.TemplateViewModel

/**
 * Type-safe navigation keys for Navigation3.
 * Each destination is a NavKey (data object/data class) and can be saved/restored in the back stack.
 */
sealed interface Route : NavKey, Parcelable {
    @Parcelize
    @Serializable
    data object Main : Route

    @Parcelize
    @Serializable
    data object Home : Route

    @Parcelize
    @Serializable
    data object SuperUser : Route

    @Parcelize
    @Serializable
    data object Module : Route

    @Parcelize
    @Serializable
    data object Settings : Route

    @Parcelize
    @Serializable
    data object About : Route

    @Parcelize
    @Serializable
    data object AppProfileTemplate : Route

    @Parcelize
    @Serializable
    data class TemplateEditor(@Serializable(with = TemplateInfoSerializer::class) val template: TemplateViewModel.TemplateInfo, val readOnly: Boolean) : Route

    @Parcelize
    @Serializable
    data class AppProfile(val packageName: String) : Route

    @Parcelize
    @Serializable
    data object Install : Route

    @Parcelize
    @Serializable
    data class ModuleRepoDetail(@Serializable(with = RepoModuleArgSerializer::class) val module: RepoModuleArg) : Route

    @Parcelize
    @Serializable
    data object ModuleRepo : Route

    @Parcelize
    @Serializable
    data class Flash(@Serializable(with = FlashItSerializer::class) val flashIt: FlashIt) : Route

    @Parcelize
    @Serializable
    data class ExecuteModuleAction(val moduleId: String) : Route
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/About.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.util.Log
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.layout.FixedScale
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.dropUnlessResumed
import com.kyant.capsule.ContinuousRoundedRectangle
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import me.weishu.kernelsu.BuildConfig
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical

@Composable
fun AboutScreen() {
    val navigator = LocalNavigator.current
    val uriHandler = LocalUriHandler.current
    val scrollBehavior = MiuixScrollBehavior()
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    val htmlString = stringResource(
        id = R.string.about_source_code,
        "<b><a href=\"https://github.com/tiann/KernelSU\">GitHub</a></b>",
        "<b><a href=\"https://t.me/KernelSU\">Telegram</a></b>"
    )
    val result = extractLinks(htmlString)

    Scaffold(
        topBar = {
            TopAppBar(
                modifier = Modifier.hazeEffect(hazeState) {
                    style = hazeStyle
                    blurRadius = 30.dp
                    noiseFactor = 0f
                },
                color = Color.Transparent,
                title = stringResource(R.string.about),
                navigationIcon = {
                    IconButton(
                        modifier = Modifier.padding(start = 16.dp),
                        onClick = dropUnlessResumed { navigator.pop() }
                    ) {
                        val layoutDirection = LocalLayoutDirection.current
                        Icon(
                            modifier = Modifier.graphicsLayer {
                                if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                            },
                            imageVector = MiuixIcons.Back,
                            contentDescription = null,
                            tint = colorScheme.onBackground
                        )
                    }
                },
                scrollBehavior = scrollBehavior
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxHeight()
                .overScrollVertical()
                .nestedScroll(scrollBehavior.nestedScrollConnection)
                .hazeSource(state = hazeState)
                .padding(horizontal = 12.dp),
            contentPadding = innerPadding,
            overscrollEffect = null,
        ) {
            item {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 12.dp)
                        .padding(vertical = 48.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Box(
                        contentAlignment = Alignment.Center,
                        modifier = Modifier
                            .size(80.dp)
                            .clip(ContinuousRoundedRectangle(16.dp))
                            .background(Color.White)
                    ) {
                        Image(
                            painter = painterResource(id = R.drawable.ic_launcher_foreground),
                            contentDescription = "icon",
                            contentScale = FixedScale(1f)
                        )
                    }
                    Text(
                        modifier = Modifier.padding(top = 12.dp),
                        text = stringResource(id = R.string.app_name),
                        fontWeight = FontWeight.Medium,
                        fontSize = 26.sp
                    )
                    Text(
                        text = BuildConfig.VERSION_NAME,
                        fontSize = 14.sp
                    )
                }
            }
            item {
                Card(
                    modifier = Modifier.padding(bottom = 12.dp)
                ) {
                    result.forEach {
                        SuperArrow(
                            title = it.fullText,
                            onClick = {
                                uriHandler.openUri(it.url)
                            }
                        )
                    }
                }
                Spacer(
                    Modifier.height(
                        WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                    )
                )
            }
        }
    }
}

data class LinkInfo(
    val fullText: String,
    val url: String
)

fun extractLinks(html: String): List<LinkInfo> {
    val regex = Regex(
        """([^<>\n\r]+?)\s*<b>\s*<a\b[^>]*\bhref\s*=\s*(['"]?)([^'"\s>]+)\2[^>]*>([^<]+)</a>\s*</b>\s*(.*?)\s*(?=<br|\n|$)""",
        RegexOption.MULTILINE
    )

    Log.d("ggc", "extractLinks: $html")

    return regex.findAll(html).mapNotNull { match ->
        try {
            val before = match.groupValues[1].trim()
            val url = match.groupValues[3].trim()
            val title = match.groupValues[4].trim()
            val after = match.groupValues[5].trim()

            val fullText = "$before $title $after"
            Log.d("ggc", "extractLinks: $fullText -> $url")
            LinkInfo(fullText, url)
        } catch (e: Exception) {
            Log.e("ggc", "匹配失败: ${e.message}")
            null
        }
    }.toList()
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/AppProfile.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.os.Build
import android.widget.Toast
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.basicMarquee
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.AccountCircle
import androidx.compose.material.icons.rounded.Security
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.dropUnlessResumed
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.launch
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.AppIconImage
import me.weishu.kernelsu.ui.component.DropdownItem
import me.weishu.kernelsu.ui.component.profile.AppProfileConfig
import me.weishu.kernelsu.ui.component.profile.RootProfileConfig
import me.weishu.kernelsu.ui.component.profile.TemplateConfig
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.util.forceStopApp
import me.weishu.kernelsu.ui.util.getSepolicy
import me.weishu.kernelsu.ui.util.launchApp
import me.weishu.kernelsu.ui.util.listAppProfileTemplates
import me.weishu.kernelsu.ui.util.ownerNameForUid
import me.weishu.kernelsu.ui.util.pickPrimary
import me.weishu.kernelsu.ui.util.restartApp
import me.weishu.kernelsu.ui.util.setSepolicy
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel
import me.weishu.kernelsu.ui.viewmodel.getTemplateInfoById
import top.yukonga.miuix.kmp.basic.BasicComponent
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.ListPopupColumn
import top.yukonga.miuix.kmp.basic.ListPopupDefaults
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.PopupPositionProvider
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.ScrollBehavior
import top.yukonga.miuix.kmp.basic.SmallTitle
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.extra.SuperDropdown
import top.yukonga.miuix.kmp.extra.SuperListPopup
import top.yukonga.miuix.kmp.extra.SuperSwitch
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.MoreCircle
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

/**
 * @author weishu
 * @date 2023/5/16.
 */
@Composable
fun AppProfileScreen(
    packageName: String,
) {
    val navigator = LocalNavigator.current
    val context = LocalContext.current
    val scrollBehavior = MiuixScrollBehavior()
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )
    val scope = rememberCoroutineScope()
    val appInfoState = remember(packageName) {
        derivedStateOf { SuperUserViewModel.apps.find { it.packageName == packageName } }
    }
    val appInfo = appInfoState.value
    if (appInfo == null) {
        LaunchedEffect(Unit) {
            navigator.pop()
        }
        return
    }
    val failToUpdateAppProfile = stringResource(R.string.failed_to_update_app_profile).format(appInfo.label).format(appInfo.uid)
    val failToUpdateSepolicy = stringResource(R.string.failed_to_update_sepolicy).format(appInfo.label)
    val suNotAllowed = stringResource(R.string.su_not_allowed).format(appInfo.label)
    val sameUidApps = remember(appInfo.uid) {
        SuperUserViewModel.apps.filter { it.uid == appInfo.uid }
    }
    val isUidGroup = sameUidApps.size > 1
    val primaryForIcon = remember(appInfo.uid, sameUidApps) {
        runCatching { pickPrimary(sameUidApps) }.getOrNull() ?: appInfo
    }
    val sharedUserId = remember(appInfo.uid, sameUidApps, primaryForIcon) {
        primaryForIcon.packageInfo.sharedUserId
            ?: sameUidApps.firstOrNull { it.packageInfo.sharedUserId != null }?.packageInfo?.sharedUserId
            ?: ""
    }

    val initialProfile = Natives.getAppProfile(packageName, appInfo.uid)
    if (initialProfile.allowSu) {
        initialProfile.rules = getSepolicy(packageName)
    }
    var profile by rememberSaveable {
        mutableStateOf(initialProfile)
    }

    Scaffold(
        topBar = {
            TopBar(
                onBack = dropUnlessResumed { navigator.pop() },
                packageName = packageName,
                showActions = !isUidGroup,
                scrollBehavior = scrollBehavior,
                hazeState = hazeState,
                hazeStyle = hazeStyle,
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxHeight()
                .padding(top = 16.dp)
                .scrollEndHaptic()
                .overScrollVertical()
                .nestedScroll(scrollBehavior.nestedScrollConnection)
                .hazeSource(state = hazeState),
            contentPadding = innerPadding,
            overscrollEffect = null
        ) {
            item {
                AppProfileInner(
                    packageName = if (isUidGroup) "" else appInfo.packageName,
                    appLabel = if (isUidGroup) ownerNameForUid(appInfo.uid) else appInfo.label,
                    appIcon = {
                        val iconApp = if (isUidGroup) primaryForIcon else appInfo
                        AppIconImage(
                            packageInfo = iconApp.packageInfo,
                            label = iconApp.label,
                            modifier = Modifier.size(54.dp)
                        )
                    },
                    appUid = appInfo.uid,
                    sharedUserId = if (isUidGroup) sharedUserId else "",
                    appVersionName = if (isUidGroup) "" else (appInfo.packageInfo.versionName ?: ""),
                    appVersionCode = if (isUidGroup) 0L else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                        appInfo.packageInfo.longVersionCode
                    } else {
                        @Suppress("DEPRECATION")
                        appInfo.packageInfo.versionCode.toLong()
                    },
                    profile = profile,
                    isUidGroup = isUidGroup,
                    affectedApps = sameUidApps,
                    onViewTemplate = {
                        getTemplateInfoById(it)?.let { info ->
                            navigator.push(Route.TemplateEditor(info, readOnly = true))
                        }
                    },
                    onManageTemplate = { navigator.push(Route.AppProfileTemplate) },
                    onProfileChange = {
                        scope.launch {
                            if (it.allowSu) {
                                if (appInfo.uid < 2000 && appInfo.uid != 1000) {
                                    Toast.makeText(context, suNotAllowed, Toast.LENGTH_SHORT).show()
                                    return@launch
                                }
                                if (!it.rootUseDefault && it.rules.isNotEmpty() && !setSepolicy(profile.name, it.rules)) {
                                    Toast.makeText(context, failToUpdateSepolicy, Toast.LENGTH_SHORT).show()
                                    return@launch
                                }
                            }
                            if (!Natives.setAppProfile(it)) {
                                Toast.makeText(context, failToUpdateAppProfile, Toast.LENGTH_SHORT).show()
                            } else {
                                profile = it
                            }
                        }
                    },
                )
                Spacer(
                    Modifier.height(
                        WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                    )
                )
            }
        }
    }
}

@Composable
private fun AppProfileInner(
    modifier: Modifier = Modifier,
    packageName: String,
    appLabel: String,
    appIcon: @Composable (() -> Unit),
    appUid: Int,
    sharedUserId: String = "",
    appVersionName: String,
    appVersionCode: Long,
    profile: Natives.Profile,
    isUidGroup: Boolean = false,
    affectedApps: List<SuperUserViewModel.AppInfo> = emptyList(),
    onViewTemplate: (id: String) -> Unit = {},
    onManageTemplate: () -> Unit = {},
    onProfileChange: (Natives.Profile) -> Unit,
) {
    val isRootGranted = profile.allowSu
    val userId = appUid / 100000
    val appId = appUid % 100000

    Column(
        modifier = modifier
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 12.dp)
                .padding(bottom = 12.dp),
            insideMargin = PaddingValues(horizontal = 16.dp, vertical = 14.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                appIcon()
                Column(
                    modifier = Modifier
                        .padding(start = 16.dp, end = 8.dp)
                        .weight(1f),
                ) {
                    Text(
                        text = appLabel,
                        color = colorScheme.onSurface,
                        fontWeight = FontWeight(550),
                        modifier = Modifier
                            .basicMarquee(),
                        maxLines = 1,
                        softWrap = false
                    )
                    if (!isUidGroup) {
                        Text(
                            text = "$appVersionName ($appVersionCode)",
                            fontSize = 12.sp,
                            color = colorScheme.onSurfaceVariantSummary,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier
                                .basicMarquee(),
                            maxLines = 1,
                            softWrap = false
                        )
                        Text(
                            text = packageName,
                            fontSize = 12.sp,
                            color = colorScheme.onSurfaceVariantSummary,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier
                                .basicMarquee(),
                            maxLines = 1,
                            softWrap = false
                        )
                    } else {
                        if (sharedUserId.isNotEmpty()) {
                            Text(
                                text = sharedUserId,
                                fontSize = 12.sp,
                                color = colorScheme.onSurfaceVariantSummary,
                                fontWeight = FontWeight.Medium,
                                modifier = Modifier
                                    .basicMarquee(),
                                maxLines = 1,
                                softWrap = false
                            )
                        }
                        Text(
                            text = stringResource(R.string.group_contains_apps, affectedApps.size),
                            fontSize = 12.sp,
                            color = colorScheme.onSurfaceVariantSummary,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier
                                .basicMarquee(),
                            maxLines = 1,
                            softWrap = false
                        )
                    }
                }
                Column(
                    modifier = Modifier,
                    horizontalAlignment = Alignment.End,
                    verticalArrangement = Arrangement.spacedBy(6.dp)
                ) {
                    if (userId != 0) {
                        StatusTag(
                            label = "USER $userId",
                            backgroundColor = colorScheme.primary.copy(alpha = 0.8f),
                            contentColor = colorScheme.onPrimary
                        )
                        StatusTag(
                            label = "UID $appId",
                            backgroundColor = colorScheme.primary.copy(alpha = 0.8f),
                            contentColor = colorScheme.onPrimary
                        )
                    } else {
                        StatusTag(
                            label = "UID $appUid",
                            backgroundColor = colorScheme.primary.copy(alpha = 0.8f),
                            contentColor = colorScheme.onPrimary
                        )
                    }
                }
            }
        }

        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 12.dp)
                .padding(bottom = 12.dp),
        ) {
            SuperSwitch(
                startAction = {
                    Icon(
                        imageVector = Icons.Rounded.Security,
                        contentDescription = null,
                        modifier = Modifier.padding(end = 16.dp),
                        tint = colorScheme.onBackground
                    )
                },
                title = stringResource(id = R.string.superuser),
                checked = isRootGranted,
                onCheckedChange = { onProfileChange(profile.copy(allowSu = it)) },
            )
        }

        val initialRootMode = if (profile.rootUseDefault) {
            Mode.Default
        } else if (profile.rootTemplate != null) {
            Mode.Template
        } else {
            Mode.Custom
        }
        var rootMode by rememberSaveable {
            mutableStateOf(initialRootMode)
        }
        val nonRootMode = if (profile.nonRootUseDefault) Mode.Default else Mode.Custom
        val dropdownMode = if (isRootGranted) rootMode else nonRootMode
        ProfileBox(dropdownMode, isRootGranted) { mode ->
            if (isRootGranted) {
                when (mode) {
                    Mode.Default, Mode.Custom -> {
                        onProfileChange(
                            profile.copy(
                                rootUseDefault = mode == Mode.Default,
                                rootTemplate = null
                            )
                        )
                        rootMode = mode
                    }

                    Mode.Template -> {
                        val templates = listAppProfileTemplates()
                        if (templates.isNotEmpty()) {
                            val selected = profile.rootTemplate ?: templates[0]
                            val info = getTemplateInfoById(selected)
                            if (info != null && setSepolicy(selected, info.rules.joinToString("\n"))) {
                                onProfileChange(
                                    profile.copy(
                                        rootUseDefault = false,
                                        rootTemplate = selected,
                                        uid = info.uid,
                                        gid = info.gid,
                                        groups = info.groups,
                                        capabilities = info.capabilities,
                                        context = info.context,
                                        namespace = info.namespace,
                                    )
                                )
                            } else if (profile.rootTemplate != selected || profile.rootUseDefault) {
                                onProfileChange(
                                    profile.copy(
                                        rootUseDefault = false,
                                        rootTemplate = selected
                                    )
                                )
                            }
                            rootMode = Mode.Template
                        }
                    }
                }
            } else {
                onProfileChange(profile.copy(nonRootUseDefault = (mode == Mode.Default)))
            }
        }
        Spacer(Modifier.height(12.dp))

        AnimatedVisibility(
            visible = isRootGranted,
            enter = fadeIn() + expandVertically(),
            exit = fadeOut() + shrinkVertically()
        ) {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 12.dp)
                    .padding(bottom = if (rootMode != Mode.Default) 12.dp else 0.dp),
            ) {
                AnimatedVisibility(
                    visible = rootMode == Mode.Template,
                    enter = fadeIn() + expandVertically(),
                    exit = fadeOut() + shrinkVertically()
                ) {
                    TemplateConfig(
                        profile = profile,
                        onViewTemplate = onViewTemplate,
                        onManageTemplate = onManageTemplate,
                        onProfileChange = onProfileChange
                    )
                }
                AnimatedVisibility(
                    visible = rootMode == Mode.Custom,
                    enter = fadeIn() + expandVertically(),
                    exit = fadeOut() + shrinkVertically()
                ) {
                    RootProfileConfig(
                        fixedName = true,
                        profile = profile,
                        onProfileChange = onProfileChange
                    )
                }
            }
        }
        AnimatedVisibility(
            visible = !isRootGranted,
            enter = fadeIn() + expandVertically(),
            exit = fadeOut() + shrinkVertically()
        ) {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 12.dp)
                    .padding(bottom = if (nonRootMode != Mode.Default) 12.dp else 0.dp),
            ) {
                AnimatedVisibility(
                    visible = nonRootMode == Mode.Custom,
                    enter = fadeIn() + expandVertically(),
                    exit = fadeOut() + shrinkVertically()
                ) {
                    AppProfileConfig(
                        fixedName = true,
                        profile = profile,
                        enabled = true,
                        onProfileChange = onProfileChange
                    )
                }
            }
        }

        if (isUidGroup) {
            SmallTitle(
                text = stringResource(R.string.app_profile_affects_following_apps),
                modifier = Modifier.padding(top = 4.dp)
            )
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 12.dp)
                    .padding(bottom = 12.dp),
            ) {
                Spacer(Modifier.height(3.dp))
                affectedApps.forEach { app ->
                    BasicComponent(
                        startAction = {
                            AppIconImage(
                                packageInfo = app.packageInfo,
                                label = app.label,
                                modifier = Modifier
                                    .padding(end = 12.dp)
                                    .size(40.dp)
                            )
                        },
                        title = app.label,
                        summary = app.packageName,
                        insideMargin = PaddingValues(horizontal = 16.dp, vertical = 12.dp)
                    )
                }
                Spacer(Modifier.height(3.dp))
            }
        }
    }
}

private enum class Mode {
    Default,
    Template,
    Custom;
}

@Composable
private fun TopBar(
    onBack: () -> Unit,
    packageName: String,
    showActions: Boolean = true,
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    hazeStyle: HazeStyle,
) {
    TopAppBar(
        modifier = Modifier.hazeEffect(hazeState) {
            style = hazeStyle
            blurRadius = 30.dp
            noiseFactor = 0f
        },
        color = Color.Transparent,
        title = stringResource(R.string.profile),
        navigationIcon = {
            IconButton(
                modifier = Modifier.padding(start = 16.dp),
                onClick = onBack
            ) {
                val layoutDirection = LocalLayoutDirection.current
                Icon(
                    modifier = Modifier.graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    },
                    imageVector = MiuixIcons.Back,
                    contentDescription = null,
                    tint = colorScheme.onBackground
                )
            }
        },
        actions = {
            if (showActions) {
                val showTopPopup = remember { mutableStateOf(false) }
                IconButton(
                    modifier = Modifier.padding(end = 16.dp),
                    onClick = { showTopPopup.value = true },
                    holdDownState = showTopPopup.value
                ) {
                    Icon(
                        imageVector = MiuixIcons.MoreCircle,
                        tint = colorScheme.onSurface,
                        contentDescription = stringResource(id = R.string.settings)
                    )
                }
                SuperListPopup(
                    show = showTopPopup,
                    onDismissRequest = { showTopPopup.value = false },
                    popupPositionProvider = ListPopupDefaults.ContextMenuPositionProvider,
                    alignment = PopupPositionProvider.Align.TopEnd,
                ) {
                    ListPopupColumn {
                        val items = listOf(
                            stringResource(id = R.string.launch_app),
                            stringResource(id = R.string.force_stop_app),
                            stringResource(id = R.string.restart_app)
                        )

                        items.forEachIndexed { index, text ->
                            DropdownItem(
                                text = text,
                                optionSize = items.size,
                                index = index,
                                onSelectedIndexChange = { selectedIndex ->
                                    when (selectedIndex) {
                                        0 -> launchApp(packageName)
                                        1 -> forceStopApp(packageName)
                                        2 -> restartApp(packageName)
                                    }
                                    showTopPopup.value = false
                                }
                            )
                        }
                    }
                }
            }
        },
        scrollBehavior = scrollBehavior
    )
}

@Composable
private fun ProfileBox(
    mode: Mode,
    hasTemplate: Boolean,
    onModeChange: (Mode) -> Unit,
) {
    val defaultText = stringResource(R.string.profile_default)
    val templateText = stringResource(R.string.profile_template)
    val customText = stringResource(R.string.profile_custom)
    val list =
        remember(hasTemplate, defaultText, templateText, customText) {
            buildList {
                add(defaultText)
                if (hasTemplate) {
                    add(templateText)
                }
                add(customText)
            }
        }

    val modesAndTitles = remember(hasTemplate, defaultText, templateText, customText) {
        buildList {
            add(Mode.Default to defaultText)
            if (hasTemplate) {
                add(Mode.Template to templateText)
            }
            add(Mode.Custom to customText)
        }
    }
    val selectedIndex = modesAndTitles.indexOfFirst { it.first == mode }
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 12.dp),
    ) {
        SuperDropdown(
            title = stringResource(R.string.profile),
            items = list,
            startAction = {
                Icon(
                    Icons.Rounded.AccountCircle,
                    modifier = Modifier.padding(end = 16.dp),
                    contentDescription = null,
                    tint = colorScheme.onBackground
                )
            },
            selectedIndex = if (selectedIndex == -1) 0 else selectedIndex,
        ) {
            onModeChange(modesAndTitles[it].first)
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/ExecuteModuleAction.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.annotation.SuppressLint
import android.os.Environment
import android.widget.Toast
import androidx.activity.compose.LocalActivity
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.key.Key
import androidx.compose.ui.input.key.key
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.dropUnlessResumed
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.KeyEventBlocker
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.util.runModuleAction
import me.weishu.kernelsu.ui.viewmodel.ModuleViewModel
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.SmallTopAppBar
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.Download
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.scrollEndHaptic
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@SuppressLint("LocalContextGetResourceValueCall")
@Composable
fun ExecuteModuleActionScreen(moduleId: String) {
    val navigator = LocalNavigator.current
    var text by rememberSaveable { mutableStateOf("") }
    var tempText: String
    val logContent = rememberSaveable { StringBuilder() }
    val context = LocalContext.current
    val activity = LocalActivity.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()
    var actionResult: Boolean
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    val fromShortcut = remember(activity) {
        val intent = activity?.intent
        intent?.getStringExtra("shortcut_type") == "module_action"
    }

    val exitExecute = {
        if (fromShortcut && activity != null) {
            activity.finishAndRemoveTask()
        } else {
            navigator.pop()
        }
    }
    val noModule = stringResource(R.string.no_such_module)
    val moduleUnavailable = stringResource(R.string.module_unavailable)
    LaunchedEffect(Unit) {
        if (text.isNotEmpty()) {
            return@LaunchedEffect
        }
        val viewModel = ModuleViewModel()
        if (viewModel.moduleList.isEmpty()) {
            viewModel.loadModuleList()
        }
        val moduleInfo = viewModel.moduleList.find { info -> info.id == moduleId }
        if (moduleInfo == null) {
            Toast.makeText(context, noModule.format(moduleId), Toast.LENGTH_SHORT).show()
            exitExecute()
            return@LaunchedEffect
        }
        if (!moduleInfo.hasActionScript) {
            exitExecute()
            return@LaunchedEffect
        }
        if (!moduleInfo.enabled || moduleInfo.update || moduleInfo.remove) {
            Toast.makeText(context, moduleUnavailable.format(moduleInfo.name), Toast.LENGTH_SHORT).show()
            exitExecute()
            return@LaunchedEffect
        }
        withContext(Dispatchers.IO) {
            runModuleAction(
                moduleId = moduleId,
                onStdout = {
                    tempText = "$it\n"
                    if (tempText.startsWith("[H[J")) { // clear command
                        text = tempText.substring(6)
                    } else {
                        text += tempText
                    }
                    logContent.append(it).append("\n")
                },
                onStderr = {
                    logContent.append(it).append("\n")
                }
            ).let {
                actionResult = it
            }
        }
        if (actionResult) {
            if (fromShortcut) {
                Toast.makeText(
                    context,
                    context.getString(R.string.module_action_success),
                    Toast.LENGTH_SHORT
                ).show()
            }
            exitExecute()
        }
    }

    Scaffold(
        topBar = {
            TopBar(
                onBack = dropUnlessResumed { navigator.pop() },
                onSave = {
                    scope.launch {
                        val format = SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.getDefault())
                        val date = format.format(Date())
                        val file = File(
                            Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                            "KernelSU_module_action_log_${date}.log"
                        )
                        file.writeText(logContent.toString())
                        Toast.makeText(context, "Log saved to ${file.absolutePath}", Toast.LENGTH_SHORT).show()
                    }
                },
                hazeState = hazeState,
                hazeStyle = hazeStyle,
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        val layoutDirection = LocalLayoutDirection.current
        KeyEventBlocker {
            it.key == Key.VolumeDown || it.key == Key.VolumeUp
        }
        Column(
            modifier = Modifier
                .fillMaxSize(1f)
                .scrollEndHaptic()
                .hazeSource(state = hazeState)
                .padding(
                    start = innerPadding.calculateStartPadding(layoutDirection),
                    end = innerPadding.calculateStartPadding(layoutDirection),
                )
                .verticalScroll(scrollState),
        ) {
            LaunchedEffect(text) {
                scrollState.animateScrollTo(scrollState.maxValue)
            }
            Spacer(Modifier.height(innerPadding.calculateTopPadding()))
            Text(
                modifier = Modifier.padding(8.dp),
                text = text,
                fontSize = 12.sp,
                fontFamily = FontFamily.Monospace,
            )
            Spacer(
                Modifier.height(
                    12.dp + WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                            WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                )
            )
        }
    }
}

@Composable
private fun TopBar(
    onBack: () -> Unit = {},
    onSave: () -> Unit = {},
    hazeState: HazeState,
    hazeStyle: HazeStyle,
) {
    SmallTopAppBar(
        modifier = Modifier.hazeEffect(hazeState) {
            style = hazeStyle
            blurRadius = 30.dp
            noiseFactor = 0f
        },
        title = stringResource(R.string.action),
        navigationIcon = {
            IconButton(
                modifier = Modifier.padding(start = 16.dp),
                onClick = onBack
            ) {
                val layoutDirection = LocalLayoutDirection.current
                Icon(
                    modifier = Modifier.graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    },
                    imageVector = MiuixIcons.Back,
                    contentDescription = null,
                    tint = colorScheme.onBackground
                )
            }
        },
        actions = {
            IconButton(
                modifier = Modifier.padding(end = 16.dp),
                onClick = onSave
            ) {
                Icon(
                    imageVector = MiuixIcons.Download,
                    contentDescription = stringResource(id = R.string.save_log),
                    tint = colorScheme.onBackground
                )
            }
        }
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Flash.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.net.Uri
import android.os.Environment
import android.os.Parcelable
import android.widget.Toast
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.Refresh
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.key.Key
import androidx.compose.ui.input.key.key
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.dropUnlessResumed
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.KeyEventBlocker
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.util.FlashResult
import me.weishu.kernelsu.ui.util.LkmSelection
import me.weishu.kernelsu.ui.util.flashModule
import me.weishu.kernelsu.ui.util.installBoot
import me.weishu.kernelsu.ui.util.reboot
import me.weishu.kernelsu.ui.util.restoreBoot
import me.weishu.kernelsu.ui.util.uninstallPermanently
import top.yukonga.miuix.kmp.basic.FloatingActionButton
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.SmallTopAppBar
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.Share
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.scrollEndHaptic
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

/**
 * @author weishu
 * @date 2023/1/1.
 */

enum class FlashingStatus {
    FLASHING,
    SUCCESS,
    FAILED
}

// Lets you flash modules sequentially when mutiple zipUris are selected
fun flashModulesSequentially(
    uris: List<Uri>,
    onStdout: (String) -> Unit,
    onStderr: (String) -> Unit
): FlashResult {
    for (uri in uris) {
        flashModule(uri, onStdout, onStderr).apply {
            if (code != 0) {
                return FlashResult(code, err, showReboot)
            }
        }
    }
    return FlashResult(0, "", true)
}

@Composable
fun FlashScreen(
    flashIt: FlashIt
) {
    val navigator = LocalNavigator.current
    var text by rememberSaveable { mutableStateOf("") }
    var tempText: String
    val logContent = rememberSaveable { StringBuilder() }
    var showFloatAction by rememberSaveable { mutableStateOf(false) }

    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()
    var flashing by rememberSaveable {
        mutableStateOf(FlashingStatus.FLASHING)
    }

    LaunchedEffect(Unit) {
        if (text.isNotEmpty()) {
            return@LaunchedEffect
        }
        withContext(Dispatchers.IO) {
            flashIt(flashIt, onStdout = {
                tempText = "$it\n"
                if (tempText.startsWith("[H[J")) { // clear command
                    text = tempText.substring(6)
                } else {
                    text += tempText
                }
                logContent.append(it).append("\n")
            }, onStderr = {
                logContent.append(it).append("\n")
            }).apply {
                if (code != 0) {
                    text += "Error code: $code.\n $err Please save and check the log.\n"
                }
                if (showReboot) {
                    text += "\n\n\n"
                    showFloatAction = true
                }
                flashing = if (code == 0) FlashingStatus.SUCCESS else FlashingStatus.FAILED
            }
        }
    }

    Scaffold(
        topBar = {
            TopBar(
                flashing,
                onBack = dropUnlessResumed { navigator.pop() },
                onSave = {
                    scope.launch {
                        val format = SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.getDefault())
                        val date = format.format(Date())
                        val file = File(
                            Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                            "KernelSU_install_log_${date}.log"
                        )
                        file.writeText(logContent.toString())
                        Toast.makeText(context, "Log saved to ${file.absolutePath}", Toast.LENGTH_SHORT).show()
                    }
                },
            )
        },
        floatingActionButton = {
            if (showFloatAction) {
                val reboot = stringResource(id = R.string.reboot)
                FloatingActionButton(
                    modifier = Modifier
                        .padding(
                            bottom = WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                    WindowInsets.captionBar.asPaddingValues().calculateBottomPadding() + 20.dp,
                            end = 20.dp
                        )
                        .border(0.05.dp, colorScheme.outline.copy(alpha = 0.5f), CircleShape),
                    onClick = {
                        scope.launch {
                            withContext(Dispatchers.IO) {
                                reboot()
                            }
                        }
                    },
                    shadowElevation = 0.dp,
                    content = {
                        Icon(
                            Icons.Rounded.Refresh,
                            reboot,
                            Modifier.size(40.dp),
                            tint = Color.White
                        )
                    },
                )
            }
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        val layoutDirection = LocalLayoutDirection.current
        KeyEventBlocker {
            it.key == Key.VolumeDown || it.key == Key.VolumeUp
        }

        Column(
            modifier = Modifier
                .fillMaxSize(1f)
                .scrollEndHaptic()
                .padding(
                    start = innerPadding.calculateStartPadding(layoutDirection),
                    end = innerPadding.calculateStartPadding(layoutDirection),
                )
                .verticalScroll(scrollState),
        ) {
            LaunchedEffect(text) {
                scrollState.animateScrollTo(scrollState.maxValue)
            }
            Spacer(Modifier.height(innerPadding.calculateTopPadding()))
            Text(
                modifier = Modifier.padding(8.dp),
                text = text,
                fontSize = 12.sp,
                fontFamily = FontFamily.Monospace,
            )
            Spacer(
                Modifier.height(
                    12.dp + WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                            WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                )
            )
        }
    }
}

@Parcelize
sealed class FlashIt : Parcelable {
    @Parcelize
    data class FlashBoot(
        val boot: Uri? = null,
        val lkm: LkmSelection,
        val ota: Boolean,
        val partition: String? = null
    ) : FlashIt()

    @Parcelize
    data class FlashModules(val uris: List<Uri>) : FlashIt()

    @Parcelize
    data object FlashRestore : FlashIt()

    @Parcelize
    data object FlashUninstall : FlashIt()
}

fun flashIt(
    flashIt: FlashIt,
    onStdout: (String) -> Unit,
    onStderr: (String) -> Unit
): FlashResult {
    return when (flashIt) {
        is FlashIt.FlashBoot -> installBoot(
            flashIt.boot,
            flashIt.lkm,
            flashIt.ota,
            flashIt.partition,
            onStdout,
            onStderr
        )

        is FlashIt.FlashModules -> {
            flashModulesSequentially(flashIt.uris, onStdout, onStderr)
        }

        FlashIt.FlashRestore -> restoreBoot(onStdout, onStderr)

        FlashIt.FlashUninstall -> uninstallPermanently(onStdout, onStderr)
    }
}

@Composable
private fun TopBar(
    status: FlashingStatus,
    onBack: () -> Unit = {},
    onSave: () -> Unit = {},
) {
    SmallTopAppBar(
        title = stringResource(
            when (status) {
                FlashingStatus.FLASHING -> R.string.flashing
                FlashingStatus.SUCCESS -> R.string.flash_success
                FlashingStatus.FAILED -> R.string.flash_failed
            }
        ),
        navigationIcon = {
            IconButton(
                modifier = Modifier.padding(start = 16.dp),
                onClick = onBack
            ) {
                val layoutDirection = LocalLayoutDirection.current
                Icon(
                    modifier = Modifier.graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    },
                    imageVector = MiuixIcons.Back,
                    contentDescription = null,
                    tint = colorScheme.onBackground
                )
            }
        },
        actions = {
            IconButton(
                modifier = Modifier.padding(end = 16.dp),
                onClick = onSave
            ) {
                Icon(
                    imageVector = MiuixIcons.Share,
                    contentDescription = stringResource(id = R.string.save_log),
                    tint = colorScheme.onBackground
                )
            }
        },
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Home.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.content.Context
import android.os.Build
import android.system.Os
import androidx.annotation.StringRes
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.IntrinsicSize
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.CheckCircleOutline
import androidx.compose.material.icons.rounded.ErrorOutline
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.pm.PackageInfoCompat
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.KernelVersion
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.getKernelVersion
import me.weishu.kernelsu.ui.LocalMainPagerState
import me.weishu.kernelsu.ui.component.DropdownItem
import me.weishu.kernelsu.ui.component.RebootListPopup
import me.weishu.kernelsu.ui.component.rememberConfirmDialog
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.theme.isInDarkTheme
import me.weishu.kernelsu.ui.util.checkNewVersion
import me.weishu.kernelsu.ui.util.getModuleCount
import me.weishu.kernelsu.ui.util.getSELinuxStatus
import me.weishu.kernelsu.ui.util.getSuperuserCount
import me.weishu.kernelsu.ui.util.module.LatestVersionInfo
import me.weishu.kernelsu.ui.util.reboot
import me.weishu.kernelsu.ui.util.rootAvailable
import top.yukonga.miuix.kmp.basic.BasicComponent
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.CardDefaults
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.ScrollBehavior
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Link
import top.yukonga.miuix.kmp.theme.MiuixTheme
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.theme.MiuixTheme.isDynamicColor
import top.yukonga.miuix.kmp.utils.PressFeedbackType
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

@Composable
fun HomePager(
    navigator: Navigator,
    bottomInnerPadding: Dp
) {
    val kernelVersion = getKernelVersion()
    val scrollBehavior = MiuixScrollBehavior()
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    val context = LocalContext.current
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    val checkUpdate = prefs.getBoolean("check_update", true)
    val themeMode = prefs.getInt("color_mode", 0)

    Scaffold(
        topBar = {
            TopBar(
                scrollBehavior = scrollBehavior,
                hazeState = hazeState,
                hazeStyle = hazeStyle,
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxHeight()
                .scrollEndHaptic()
                .overScrollVertical()
                .nestedScroll(scrollBehavior.nestedScrollConnection)
                .padding(horizontal = 12.dp)
                .hazeSource(state = hazeState),
            contentPadding = innerPadding,
            overscrollEffect = null,
        ) {
            item {
                val isManager = Natives.isManager
                val ksuVersion = if (isManager) Natives.version else null
                val lkmMode = ksuVersion?.let {
                    if (kernelVersion.isGKI()) Natives.isLkmMode else null
                }
                val mainState = LocalMainPagerState.current

                Column(
                    modifier = Modifier.padding(vertical = 12.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                ) {
                    if (ksuVersion != null && !Natives.isLkmMode) {
                        WarningCard(
                            stringResource(id = R.string.home_gki_warning),
                            themeMode
                        )
                    }
                    if (isManager && Natives.requireNewKernel()) {
                        WarningCard(
                            stringResource(id = R.string.require_kernel_version)
                                .format(ksuVersion, Natives.MINIMAL_SUPPORTED_KERNEL),
                            themeMode
                        )
                    }
                    if (ksuVersion != null && !rootAvailable()) {
                        WarningCard(
                            stringResource(id = R.string.grant_root_failed),
                            themeMode
                        )
                    }
                    StatusCard(
                        kernelVersion, ksuVersion, lkmMode,
                        onClickInstall = {
                            navigator.push(Route.Install)
                        },
                        onClickSuperuser = {
                            mainState.animateToPage(1)
                        },
                        onclickModule = {
                            mainState.animateToPage(2)
                        },
                        themeMode = themeMode
                    )

                    if (checkUpdate) {
                        UpdateCard(themeMode)
                    }
                    InfoCard()
                    DonateCard()
                    LearnMoreCard()
                }
                Spacer(Modifier.height(bottomInnerPadding))
            }
        }
    }
}

@Composable
fun UpdateCard(
    themeMode: Int,
) {
    val context = LocalContext.current
    val latestVersionInfo = LatestVersionInfo()
    val newVersion by produceState(initialValue = latestVersionInfo) {
        value = withContext(Dispatchers.IO) {
            checkNewVersion()
        }
    }

    val currentVersionCode = getManagerVersion(context).second
    val newVersionCode = newVersion.versionCode
    val newVersionUrl = newVersion.downloadUrl
    val changelog = newVersion.changelog

    val uriHandler = LocalUriHandler.current
    val title = stringResource(id = R.string.module_changelog)
    val updateText = stringResource(id = R.string.module_update)

    AnimatedVisibility(
        visible = newVersionCode > currentVersionCode,
        enter = fadeIn() + expandVertically(),
        exit = shrinkVertically() + fadeOut()
    ) {
        val updateDialog = rememberConfirmDialog(onConfirm = { uriHandler.openUri(newVersionUrl) })
        WarningCard(
            message = stringResource(id = R.string.new_version_available).format(newVersionCode),
            themeMode, colorScheme.outline
        ) {
            if (changelog.isEmpty()) {
                uriHandler.openUri(newVersionUrl)
            } else {
                updateDialog.showConfirm(
                    title = title,
                    content = changelog,
                    markdown = true,
                    confirm = updateText
                )
            }
        }
    }
}

@Composable
fun RebootDropdownItem(
    @StringRes id: Int, reason: String = "",
    showTopPopup: MutableState<Boolean>,
    optionSize: Int,
    index: Int,
) {
    DropdownItem(
        text = stringResource(id),
        optionSize = optionSize,
        onSelectedIndexChange = {
            reboot(reason)
            showTopPopup.value = false
        },
        index = index
    )
}

@Composable
private fun TopBar(
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    hazeStyle: HazeStyle,
) {
    TopAppBar(
        modifier = Modifier.hazeEffect(hazeState) {
            style = hazeStyle
            blurRadius = 30.dp
            noiseFactor = 0f
        },
        color = Color.Transparent,
        title = stringResource(R.string.app_name),
        actions = {
            RebootListPopup(
                modifier = Modifier.padding(end = 16.dp),
            )
        },
        scrollBehavior = scrollBehavior
    )
}

@Composable
private fun StatusCard(
    kernelVersion: KernelVersion,
    ksuVersion: Int?,
    lkmMode: Boolean?,
    onClickInstall: () -> Unit = {},
    onClickSuperuser: () -> Unit = {},
    onclickModule: () -> Unit = {},
    themeMode: Int,
) {
    Column(
        modifier = Modifier
    ) {
        when {
            ksuVersion != null -> {
                val safeMode = when {
                    Natives.isSafeMode -> " [${stringResource(id = R.string.safe_mode)}]"
                    else -> ""
                }

                val workingMode = when (lkmMode) {
                    null -> ""
                    true -> " <LKM>"
                    else -> " <GKI>"
                }

                val workingText = "${stringResource(id = R.string.home_working)}$workingMode$safeMode"

                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(IntrinsicSize.Min),
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalAlignment = Alignment.CenterVertically,
                ) {
                    Card(
                        modifier = Modifier
                            .weight(1f)
                            .fillMaxHeight(),
                        colors = CardDefaults.defaultColors(
                            color = when {
                                isDynamicColor -> colorScheme.secondaryContainer
                                isInDarkTheme(themeMode) -> Color(0xFF1A3825)
                                else -> Color(0xFFDFFAE4)
                            }
                        ),
                        onClick = {
                            onClickInstall()
                        },
                        showIndication = true,
                        pressFeedbackType = PressFeedbackType.Tilt
                    ) {
                        Box(
                            modifier = Modifier.fillMaxSize()
                        ) {
                            Box(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .offset(38.dp, 45.dp),
                                contentAlignment = Alignment.BottomEnd
                            ) {
                                Icon(
                                    modifier = Modifier.size(170.dp),
                                    imageVector = Icons.Rounded.CheckCircleOutline,
                                    tint = if (isDynamicColor) {
                                        colorScheme.primary.copy(alpha = 0.8f)
                                    } else {
                                        Color(0xFF36D167)
                                    },
                                    contentDescription = null
                                )
                            }
                            Column(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .padding(all = 16.dp)
                            ) {
                                Text(
                                    modifier = Modifier.fillMaxWidth(),
                                    text = workingText,
                                    fontSize = 20.sp,
                                    fontWeight = FontWeight.SemiBold,
                                )
                                Spacer(Modifier.height(2.dp))
                                Text(
                                    modifier = Modifier.fillMaxWidth(),
                                    text = stringResource(R.string.home_working_version, ksuVersion),
                                    fontSize = 14.sp,
                                    fontWeight = FontWeight.Medium,
                                )
                            }
                        }
                    }
                    Column(
                        modifier = Modifier
                            .weight(1f)
                            .fillMaxHeight()
                    ) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .weight(1f),
                            insideMargin = PaddingValues(16.dp),
                            onClick = { onClickSuperuser() },
                            showIndication = true,
                            pressFeedbackType = PressFeedbackType.Tilt
                        ) {
                            Column(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalAlignment = Alignment.Start
                            ) {
                                Text(
                                    modifier = Modifier.fillMaxWidth(),
                                    text = stringResource(R.string.superuser),
                                    fontWeight = FontWeight.Medium,
                                    fontSize = 15.sp,
                                    color = colorScheme.onSurfaceVariantSummary,
                                )
                                Text(
                                    modifier = Modifier.fillMaxWidth(),
                                    text = getSuperuserCount().toString(),
                                    fontSize = 26.sp,
                                    fontWeight = FontWeight.SemiBold,
                                    color = colorScheme.onSurface,
                                )
                            }
                        }
                        Spacer(Modifier.height(12.dp))
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .weight(1f),
                            insideMargin = PaddingValues(16.dp),
                            onClick = { onclickModule() },
                            showIndication = true,
                            pressFeedbackType = PressFeedbackType.Tilt
                        ) {
                            Column(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalAlignment = Alignment.Start
                            ) {
                                Text(
                                    modifier = Modifier.fillMaxWidth(),
                                    text = stringResource(R.string.module),
                                    fontWeight = FontWeight.Medium,
                                    fontSize = 15.sp,
                                    color = colorScheme.onSurfaceVariantSummary,
                                )
                                Text(
                                    modifier = Modifier.fillMaxWidth(),
                                    text = getModuleCount().toString(),
                                    fontSize = 26.sp,
                                    fontWeight = FontWeight.SemiBold,
                                    color = colorScheme.onSurface,
                                )
                            }
                        }
                    }
                }
            }

            kernelVersion.isGKI() -> {
                Card(
                    onClick = {
                        onClickInstall()
                    },
                    showIndication = true,
                    pressFeedbackType = PressFeedbackType.Sink
                ) {
                    BasicComponent(
                        title = stringResource(R.string.home_not_installed),
                        summary = stringResource(R.string.home_click_to_install),
                        startAction = {
                            Icon(
                                Icons.Rounded.ErrorOutline,
                                stringResource(R.string.home_not_installed),
                                modifier = Modifier
                                    .padding(end = 16.dp),
                                tint = colorScheme.onBackground,
                            )
                        }
                    )
                }
            }

            else -> {
                Card(
                    onClick = {
                        onClickInstall()
                    },
                    showIndication = true,
                    pressFeedbackType = PressFeedbackType.Sink
                ) {
                    BasicComponent(
                        title = stringResource(R.string.home_unsupported),
                        summary = stringResource(R.string.home_unsupported_reason),
                        startAction = {
                            Icon(
                                Icons.Rounded.ErrorOutline,
                                stringResource(R.string.home_unsupported),
                                modifier = Modifier
                                    .padding(end = 16.dp),
                                tint = colorScheme.onBackground,
                            )
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun WarningCard(
    message: String,
    themeMode: Int,
    color: Color? = null,
    onClick: (() -> Unit)? = null,
) {
    Card(
        onClick = {
            onClick?.invoke()
        },
        colors = CardDefaults.defaultColors(
            color = color ?: when {
                isDynamicColor -> colorScheme.errorContainer
                isInDarkTheme(themeMode) -> Color(0XFF310808)
                else -> Color(0xFFF8E2E2)
            }
        ),
        showIndication = onClick != null,
        pressFeedbackType = PressFeedbackType.Tilt
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = message,
                color = if (isDynamicColor) colorScheme.onErrorContainer else Color(0xFFF72727),
                fontSize = 14.sp
            )
        }
    }
}

@Composable
fun LearnMoreCard() {
    val uriHandler = LocalUriHandler.current
    val url = stringResource(R.string.home_learn_kernelsu_url)

    Card(
        modifier = Modifier
            .fillMaxWidth(),
    ) {
        BasicComponent(
            title = stringResource(R.string.home_learn_kernelsu),
            summary = stringResource(R.string.home_click_to_learn_kernelsu),
            endActions = {
                Icon(
                    imageVector = MiuixIcons.Link,
                    tint = colorScheme.onSurface,
                    contentDescription = null
                )
            },
            onClick = {
                uriHandler.openUri(url)
            }
        )
    }
}

@Composable
fun DonateCard() {
    val uriHandler = LocalUriHandler.current

    Card(
        modifier = Modifier
            .fillMaxWidth(),
    ) {
        BasicComponent(
            title = stringResource(R.string.home_support_title),
            summary = stringResource(R.string.home_support_content),
            endActions = {
                Icon(
                    imageVector = MiuixIcons.Link,
                    tint = colorScheme.onSurface,
                    contentDescription = null
                )
            },
            onClick = {
                uriHandler.openUri("https://patreon.com/weishu")
            },
            insideMargin = PaddingValues(18.dp)
        )
    }
}

@Composable
private fun InfoCard() {
    @Composable
    fun InfoText(
        title: String,
        content: String,
        bottomPadding: Dp = 24.dp
    ) {
        Text(
            text = title,
            fontSize = MiuixTheme.textStyles.headline1.fontSize,
            fontWeight = FontWeight.Medium,
            color = colorScheme.onSurface
        )
        Text(
            text = content,
            fontSize = MiuixTheme.textStyles.body2.fontSize,
            color = colorScheme.onSurfaceVariantSummary,
            modifier = Modifier.padding(top = 2.dp, bottom = bottomPadding)
        )
    }
    Card {
        val context = LocalContext.current
        val uname = Os.uname()
        val managerVersion = getManagerVersion(context)
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            InfoText(
                title = stringResource(R.string.home_kernel),
                content = uname.release
            )
            InfoText(
                title = stringResource(R.string.home_manager_version),
                content = "${managerVersion.first} (${managerVersion.second})"
            )
            InfoText(
                title = stringResource(R.string.home_fingerprint),
                content = Build.FINGERPRINT
            )
            InfoText(
                title = stringResource(R.string.home_selinux_status),
                content = getSELinuxStatus(),
                bottomPadding = 0.dp
            )
        }
    }
}

fun getManagerVersion(context: Context): Pair<String, Long> {
    val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)!!
    val versionCode = PackageInfoCompat.getLongVersionCode(packageInfo)
    return Pair(packageInfo.versionName!!, versionCode)
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Install.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.provider.OpenableColumns
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.StringRes
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.LocalIndication
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.selection.toggleable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.lifecycle.compose.dropUnlessResumed
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import me.weishu.kernelsu.R
import me.weishu.kernelsu.getKernelVersion
import me.weishu.kernelsu.ui.component.ChooseKmiDialog
import me.weishu.kernelsu.ui.component.rememberConfirmDialog
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.util.LkmSelection
import me.weishu.kernelsu.ui.util.getAvailablePartitions
import me.weishu.kernelsu.ui.util.getCurrentKmi
import me.weishu.kernelsu.ui.util.getDefaultPartition
import me.weishu.kernelsu.ui.util.getSlotSuffix
import me.weishu.kernelsu.ui.util.isAbDevice
import me.weishu.kernelsu.ui.util.rootAvailable
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.ScrollBehavior
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperCheckbox
import top.yukonga.miuix.kmp.extra.SuperDropdown
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.ConvertFile
import top.yukonga.miuix.kmp.icon.extended.MoveFile
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

/**
 * @author weishu
 * @date 2024/3/12.
 */
@SuppressLint("LocalContextGetResourceValueCall")
@Composable
fun InstallScreen() {
    val navigator = LocalNavigator.current
    val context = LocalContext.current
    var installMethod by remember {
        mutableStateOf<InstallMethod?>(null)
    }

    var lkmSelection by remember {
        mutableStateOf<LkmSelection>(LkmSelection.KmiNone)
    }

    var partitionSelectionIndex by remember { mutableIntStateOf(0) }
    var partitionsState by remember { mutableStateOf<List<String>>(emptyList()) }
    var hasCustomSelected by remember { mutableStateOf(false) }

    val onInstall = {
        installMethod?.let { method ->
            val isOta = method is InstallMethod.DirectInstallToInactiveSlot
            val partitionSelection = partitionsState.getOrNull(partitionSelectionIndex)
            val flashIt = FlashIt.FlashBoot(
                boot = if (method is InstallMethod.SelectFile) method.uri else null,
                lkm = lkmSelection,
                ota = isOta,
                partition = partitionSelection
            )
            navigator.push(Route.Flash(flashIt))
        }
    }

    val currentKmi by produceState(initialValue = "") { value = getCurrentKmi() }

    val showChooseKmiDialog = rememberSaveable { mutableStateOf(false) }
    val chooseKmiDialog = ChooseKmiDialog(showChooseKmiDialog) { kmi ->
        kmi?.let {
            lkmSelection = LkmSelection.KmiString(it)
            onInstall()
        }
    }

    val onClickNext = {
        val isLkmSelected = lkmSelection != LkmSelection.KmiNone
        val isKmiUnknown = currentKmi.isBlank()
        val isSelectFileMode = installMethod is InstallMethod.SelectFile
        if (!isLkmSelected && (isKmiUnknown || isSelectFileMode)) {
            // no lkm file selected and cannot get current kmi or select file mode
            showChooseKmiDialog.value = true
            chooseKmiDialog
        } else {
            onInstall()
        }
    }

    val selectLkmLauncher =
        rememberLauncherForActivityResult(contract = ActivityResultContracts.StartActivityForResult()) {
            if (it.resultCode == Activity.RESULT_OK) {
                it.data?.data?.let { uri ->
                    val isKo = isKoFile(context, uri)
                    if (isKo) {
                        lkmSelection = LkmSelection.LkmUri(uri)
                    } else {
                        lkmSelection = LkmSelection.KmiNone
                        Toast.makeText(
                            context,
                            context.getString(R.string.install_only_support_ko_file),
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            }
        }

    val onLkmUpload = {
        selectLkmLauncher.launch(Intent(Intent.ACTION_GET_CONTENT).apply {
            type = "application/octet-stream"
        })
    }

    val scrollBehavior = MiuixScrollBehavior()
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            TopBar(
                onBack = dropUnlessResumed { navigator.pop() },
                scrollBehavior = scrollBehavior,
                hazeState = hazeState,
                hazeStyle = hazeStyle,
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxHeight()
                .scrollEndHaptic()
                .overScrollVertical()
                .nestedScroll(scrollBehavior.nestedScrollConnection)
                .hazeSource(state = hazeState)
                .padding(top = 12.dp)
                .padding(horizontal = 16.dp),
            contentPadding = innerPadding,
            overscrollEffect = null,
        ) {
            item {
                Card(
                    modifier = Modifier
                        .fillMaxWidth(),
                ) {
                    SelectInstallMethod { method ->
                        installMethod = method
                    }
                }
                AnimatedVisibility(
                    visible = installMethod is InstallMethod.DirectInstall || installMethod is InstallMethod.DirectInstallToInactiveSlot,
                    enter = expandVertically(),
                    exit = shrinkVertically()
                ) {
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(top = 12.dp),
                    ) {
                        val isOta = installMethod is InstallMethod.DirectInstallToInactiveSlot
                        val suffix = produceState(initialValue = "", isOta) {
                            value = getSlotSuffix(isOta)
                        }.value
                        val partitions = produceState(initialValue = emptyList()) {
                            value = getAvailablePartitions()
                        }.value
                        val defaultPartition = produceState(initialValue = "") {
                            value = getDefaultPartition()
                        }.value
                        partitionsState = partitions
                        val displayPartitions = partitions.map { name ->
                            if (defaultPartition == name) "$name (default)" else name
                        }
                        val defaultIndex = partitions.indexOf(defaultPartition).takeIf { it >= 0 } ?: 0
                        if (!hasCustomSelected) partitionSelectionIndex = defaultIndex
                        SuperDropdown(
                            items = displayPartitions,
                            selectedIndex = partitionSelectionIndex,
                            title = "${stringResource(R.string.install_select_partition)} (${suffix})",
                            onSelectedIndexChange = { index ->
                                hasCustomSelected = true
                                partitionSelectionIndex = index
                            },
                            startAction = {
                                Icon(
                                    MiuixIcons.ConvertFile,
                                    tint = colorScheme.onSurface,
                                    modifier = Modifier.padding(end = 16.dp),
                                    contentDescription = null
                                )
                            }
                        )
                    }
                }
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 12.dp),
                ) {
                    SuperArrow(
                        title = stringResource(id = R.string.install_upload_lkm_file),
                        summary = (lkmSelection as? LkmSelection.LkmUri)?.let {
                            stringResource(
                                id = R.string.selected_lkm,
                                it.uri.lastPathSegment ?: "(file)"
                            )
                        },
                        onClick = onLkmUpload,
                        startAction = {
                            Icon(
                                MiuixIcons.MoveFile,
                                tint = colorScheme.onSurface,
                                modifier = Modifier.padding(end = 16.dp),
                                contentDescription = null
                            )
                        }
                    )
                }
                TextButton(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 12.dp),
                    text = stringResource(id = R.string.install_next),
                    enabled = installMethod != null,
                    colors = ButtonDefaults.textButtonColorsPrimary(),
                    onClick = { onClickNext() }
                )
                Spacer(
                    Modifier.height(
                        WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                    )
                )
            }
        }
    }
}

sealed class InstallMethod {
    data class SelectFile(
        val uri: Uri? = null,
        @get:StringRes override val label: Int = R.string.select_file,
        override val summary: String?
    ) : InstallMethod()

    data object DirectInstall : InstallMethod() {
        override val label: Int
            get() = R.string.direct_install
    }

    data object DirectInstallToInactiveSlot : InstallMethod() {
        override val label: Int
            get() = R.string.install_inactive_slot
    }

    abstract val label: Int
    open val summary: String? = null
}

@Composable
private fun SelectInstallMethod(onSelected: (InstallMethod) -> Unit = {}) {
    val rootAvailable = rootAvailable()
    val isAbDevice = produceState(initialValue = false) {
        value = isAbDevice()
    }.value
    val defaultPartitionName = produceState(initialValue = "boot") {
        value = getDefaultPartition()
    }.value
    val isGkiDevice = produceState(initialValue = false) {
        value = getKernelVersion().isGKI()
    }.value
    val selectFileTip = stringResource(
        id = R.string.select_file_tip, defaultPartitionName
    )
    val selectFileTipNoGKI = stringResource(id = R.string.select_file_tip_nogki)
    val radioOptions = mutableListOf<InstallMethod>(InstallMethod.SelectFile(summary = if (isGkiDevice) selectFileTip else selectFileTipNoGKI))
    if (rootAvailable && isGkiDevice) {
        radioOptions.add(InstallMethod.DirectInstall)

        if (isAbDevice) {
            radioOptions.add(InstallMethod.DirectInstallToInactiveSlot)
        }
    }

    var selectedOption by remember { mutableStateOf<InstallMethod?>(null) }
    val selectImageLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) {
        if (it.resultCode == Activity.RESULT_OK) {
            it.data?.data?.let { uri ->
                val option = InstallMethod.SelectFile(uri, summary = selectFileTip)
                selectedOption = option
                onSelected(option)
            }
        }
    }

    val confirmDialog = rememberConfirmDialog(
        onConfirm = {
            selectedOption = InstallMethod.DirectInstallToInactiveSlot
            onSelected(InstallMethod.DirectInstallToInactiveSlot)
        }
    )
    val dialogTitle = stringResource(id = android.R.string.dialog_alert_title)
    val dialogContent = stringResource(id = R.string.install_inactive_slot_warning)

    val onClick = { option: InstallMethod ->

        when (option) {
            is InstallMethod.SelectFile -> {
                selectImageLauncher.launch(Intent(Intent.ACTION_GET_CONTENT).apply {
                    type = "application/octet-stream"
                })
            }

            is InstallMethod.DirectInstall -> {
                selectedOption = option
                onSelected(option)
            }

            is InstallMethod.DirectInstallToInactiveSlot -> {
                confirmDialog.showConfirm(dialogTitle, dialogContent)
            }
        }
    }

    Column {
        radioOptions.forEach { option ->
            val interactionSource = remember { MutableInteractionSource() }
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier
                    .fillMaxWidth()
                    .toggleable(
                        value = option.javaClass == selectedOption?.javaClass,
                        onValueChange = {
                            onClick(option)
                        },
                        role = Role.RadioButton,
                        indication = LocalIndication.current,
                        interactionSource = interactionSource
                    )
            ) {
                SuperCheckbox(
                    title = stringResource(id = option.label),
                    summary = option.summary,
                    checked = option.javaClass == selectedOption?.javaClass,
                    onCheckedChange = {
                        onClick(option)
                    },
                )
            }
        }
    }
}

@Composable
private fun TopBar(
    onBack: () -> Unit = {},
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    hazeStyle: HazeStyle,
) {
    TopAppBar(
        modifier = Modifier.hazeEffect(hazeState) {
            style = hazeStyle
            blurRadius = 30.dp
            noiseFactor = 0f
        },
        color = Color.Transparent,
        title = stringResource(R.string.install),
        navigationIcon = {
            IconButton(
                modifier = Modifier.padding(start = 16.dp),
                onClick = onBack
            ) {
                val layoutDirection = LocalLayoutDirection.current
                Icon(
                    modifier = Modifier.graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    },
                    imageVector = MiuixIcons.Back,
                    tint = colorScheme.onSurface,
                    contentDescription = null,
                )
            }
        },
        scrollBehavior = scrollBehavior
    )
}

private fun isKoFile(context: Context, uri: Uri): Boolean {
    val seg = uri.lastPathSegment ?: ""
    if (seg.endsWith(".ko", ignoreCase = true)) return true

    return try {
        context.contentResolver.query(
            uri,
            arrayOf(OpenableColumns.DISPLAY_NAME),
            null,
            null,
            null
        )?.use { cursor ->
            val idx = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)
            if (idx != -1 && cursor.moveToFirst()) {
                val name = cursor.getString(idx)
                name?.endsWith(".ko", ignoreCase = true) == true
            } else {
                false
            }
        } ?: false
    } catch (_: Throwable) {
        false
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Module.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.annotation.SuppressLint
import android.app.Activity.RESULT_OK
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.animateContentSize
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandHorizontally
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkHorizontally
import androidx.compose.animation.shrinkVertically
import androidx.compose.animation.slideInHorizontally
import androidx.compose.animation.slideOutHorizontally
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateEndPadding
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.ime
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.Add
import androidx.compose.material.icons.rounded.Code
import androidx.compose.material.icons.rounded.PlayArrow
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.nestedscroll.NestedScrollConnection
import androidx.compose.ui.input.nestedscroll.NestedScrollSource
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.layout.FixedScale
import androidx.compose.ui.layout.SubcomposeLayout
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.TextLayoutResult
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.edit
import androidx.core.net.toUri
import androidx.lifecycle.viewmodel.compose.viewModel
import com.kyant.capsule.ContinuousRoundedRectangle
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.component.ConfirmResult
import me.weishu.kernelsu.ui.component.RebootListPopup
import me.weishu.kernelsu.ui.component.SearchBox
import me.weishu.kernelsu.ui.component.SearchPager
import me.weishu.kernelsu.ui.component.rememberConfirmDialog
import me.weishu.kernelsu.ui.component.rememberLoadingDialog
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.theme.isInDarkTheme
import me.weishu.kernelsu.ui.util.DownloadListener
import me.weishu.kernelsu.ui.util.download
import me.weishu.kernelsu.ui.util.getFileName
import me.weishu.kernelsu.ui.util.hasMagisk
import me.weishu.kernelsu.ui.util.module.Shortcut
import me.weishu.kernelsu.ui.util.module.fetchModuleDetail
import me.weishu.kernelsu.ui.util.module.fetchReleaseDescriptionHtml
import me.weishu.kernelsu.ui.util.toggleModule
import me.weishu.kernelsu.ui.util.undoUninstallModule
import me.weishu.kernelsu.ui.util.uninstallModule
import me.weishu.kernelsu.ui.viewmodel.ModuleViewModel
import me.weishu.kernelsu.ui.webui.WebUIActivity
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.DropdownImpl
import top.yukonga.miuix.kmp.basic.FloatingActionButton
import top.yukonga.miuix.kmp.basic.HorizontalDivider
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.ListPopupColumn
import top.yukonga.miuix.kmp.basic.ListPopupDefaults
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.PopupPositionProvider
import top.yukonga.miuix.kmp.basic.PullToRefresh
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.Switch
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TextField
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.basic.rememberPullToRefreshState
import top.yukonga.miuix.kmp.extra.SuperDialog
import top.yukonga.miuix.kmp.extra.SuperListPopup
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Delete
import top.yukonga.miuix.kmp.icon.extended.Download
import top.yukonga.miuix.kmp.icon.extended.MoreCircle
import top.yukonga.miuix.kmp.icon.extended.Undo
import top.yukonga.miuix.kmp.icon.extended.UploadCloud
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

private enum class ShortcutType {
    Action,
    WebUI
}

@SuppressLint("StringFormatInvalid", "LocalContextGetResourceValueCall")
@Composable
fun ModulePager(
    navigator: Navigator,
    bottomInnerPadding: Dp
) {
    val viewModel = viewModel<ModuleViewModel>()
    val modules = viewModel.moduleList
    val scope = rememberCoroutineScope()
    val searchStatus by viewModel.searchStatus

    val context = LocalContext.current
    var isInitialized by rememberSaveable { mutableStateOf(false) }
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)

    LaunchedEffect(Unit) {
        when {
            !isInitialized || modules.isEmpty() -> {
                viewModel.checkModuleUpdate = prefs.getBoolean("module_check_update", true)
                viewModel.sortEnabledFirst = prefs.getBoolean("module_sort_enabled_first", false)
                viewModel.sortActionFirst = prefs.getBoolean("module_sort_action_first", false)
                viewModel.fetchModuleList(checkUpdate = true)
                isInitialized = true
            }

            viewModel.isNeedRefresh -> {
                viewModel.fetchModuleList(checkUpdate = true)
            }
        }
    }

    LaunchedEffect(searchStatus.searchText) {
        viewModel.updateSearchText(searchStatus.searchText)
    }

    LaunchedEffect(modules) {
        if (searchStatus.searchText.isNotEmpty()) {
            viewModel.updateSearchText(searchStatus.searchText)
        }
    }

    val webUILauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { viewModel.fetchModuleList() }

    val loadingDialog = rememberLoadingDialog()
    val confirmDialog = rememberConfirmDialog()

    val isSafeMode = Natives.isSafeMode
    val magiskInstalled by produceState(initialValue = false) {
        value = withContext(Dispatchers.IO) { hasMagisk() }
    }
    val hideInstallButton = isSafeMode || magiskInstalled

    val scrollBehavior = MiuixScrollBehavior()
    var fabVisible by remember { mutableStateOf(true) }
    var scrollDistance by remember { mutableFloatStateOf(0f) }
    val dynamicTopPadding by remember {
        derivedStateOf { 12.dp * (1f - scrollBehavior.state.collapsedFraction) }
    }

    val failedEnable = stringResource(R.string.module_failed_to_enable)
    val failedDisable = stringResource(R.string.module_failed_to_disable)
    val failedUndoUninstall = stringResource(R.string.module_undo_uninstall_failed)
    val successUndoUninstall = stringResource(R.string.module_undo_uninstall_success)
    val failedUninstall = stringResource(R.string.module_uninstall_failed)
    val successUninstall = stringResource(R.string.module_uninstall_success)
    val rebootToApply = stringResource(R.string.reboot_to_apply)
    val moduleStr = stringResource(R.string.module)
    val uninstall = stringResource(R.string.uninstall)
    val cancel = stringResource(android.R.string.cancel)
    val moduleUninstallConfirm = stringResource(R.string.module_uninstall_confirm)
    val metaModuleUninstallConfirm = stringResource(R.string.metamodule_uninstall_confirm)
    val updateText = stringResource(R.string.module_update)
    val changelogText = stringResource(R.string.module_changelog)
    val downloadingText = stringResource(R.string.module_downloading)
    val startDownloadingText = stringResource(R.string.module_start_downloading)

    var shortcutModuleId by rememberSaveable { mutableStateOf<String?>(null) }
    var shortcutName by rememberSaveable { mutableStateOf("") }
    var shortcutIconUri by rememberSaveable { mutableStateOf<String?>(null) }
    var defaultShortcutIconUri by rememberSaveable { mutableStateOf<String?>(null) }
    var defaultActionShortcutIconUri by rememberSaveable { mutableStateOf<String?>(null) }
    var defaultWebUiShortcutIconUri by rememberSaveable { mutableStateOf<String?>(null) }
    var selectedShortcutType by rememberSaveable { mutableStateOf<ShortcutType?>(null) }
    val showShortcutDialog = remember { mutableStateOf(false) }
    val showShortcutTypeDialog = remember { mutableStateOf(false) }

    fun openShortcutDialogForType(type: ShortcutType) {
        selectedShortcutType = type
        val defaultIcon = when (type) {
            ShortcutType.Action -> defaultActionShortcutIconUri ?: defaultWebUiShortcutIconUri
            ShortcutType.WebUI -> defaultWebUiShortcutIconUri ?: defaultActionShortcutIconUri
        }
        defaultShortcutIconUri = defaultIcon
        shortcutIconUri = defaultIcon
        showShortcutDialog.value = true
    }

    fun hasModuleShortcut(context: Context, moduleId: String, type: ShortcutType): Boolean {
        return when (type) {
            ShortcutType.Action -> Shortcut.hasModuleActionShortcut(context, moduleId)
            ShortcutType.WebUI -> Shortcut.hasModuleWebUiShortcut(context, moduleId)
        }
    }

    fun deleteModuleShortcut(context: Context, moduleId: String, type: ShortcutType) {
        when (type) {
            ShortcutType.Action -> Shortcut.deleteModuleActionShortcut(context, moduleId)
            ShortcutType.WebUI -> Shortcut.deleteModuleWebUiShortcut(context, moduleId)
        }
    }

    fun createModuleShortcut(
        context: Context,
        moduleId: String,
        name: String,
        iconUri: String?,
        type: ShortcutType
    ) {
        when (type) {
            ShortcutType.Action -> {
                Shortcut.createModuleActionShortcut(
                    context = context,
                    moduleId = moduleId,
                    name = name,
                    iconUri = iconUri
                )
            }

            ShortcutType.WebUI -> {
                Shortcut.createModuleWebUiShortcut(
                    context = context,
                    moduleId = moduleId,
                    name = name,
                    iconUri = iconUri
                )
            }
        }
    }

    val pickShortcutIconLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri ->
        shortcutIconUri = uri?.toString()
    }

    val shortcutPreviewIcon = remember { mutableStateOf<ImageBitmap?>(null) }
    LaunchedEffect(shortcutIconUri) {
        val uriStr = shortcutIconUri
        if (uriStr.isNullOrBlank()) {
            shortcutPreviewIcon.value = null
            return@LaunchedEffect
        }
        val bitmap = withContext(Dispatchers.IO) {
            Shortcut.loadShortcutBitmap(context, uriStr)
        }
        shortcutPreviewIcon.value = bitmap?.asImageBitmap()
    }

    var hasExistingShortcut by rememberSaveable { mutableStateOf(false) }
    LaunchedEffect(shortcutModuleId, selectedShortcutType, showShortcutDialog.value) {
        val moduleId = shortcutModuleId
        val type = selectedShortcutType
        if (!showShortcutDialog.value || moduleId.isNullOrBlank() || type == null) {
            hasExistingShortcut = false
            return@LaunchedEffect
        }
        val exists = withContext(Dispatchers.IO) {
            hasModuleShortcut(context, moduleId, type)
        }
        hasExistingShortcut = exists
    }

    suspend fun onModuleUpdate(
        module: ModuleViewModel.ModuleInfo,
        changelogUrl: String,
        downloadUrl: String,
        fileName: String,
        context: Context,
        onInstallModule: (Uri) -> Unit
    ) {
        val changelogResult = if (changelogUrl.isBlank()) {
            Result.success("")
        } else {
            loadingDialog.withLoading {
                withContext(Dispatchers.IO) {
                    runCatching {
                        ksuApp.okhttpClient.newCall(
                            okhttp3.Request.Builder().url(changelogUrl).build()
                        ).execute().body.string()
                    }
                }
            }
        }

        val showToast: suspend (String) -> Unit = { msg ->
            withContext(Dispatchers.Main) {
                Toast.makeText(
                    context,
                    msg,
                    Toast.LENGTH_SHORT
                ).show()
            }
        }

        val changelog = changelogResult.getOrElse { "" }
        var htmlLog = ""
        if (changelog.isBlank()) {
            withContext(Dispatchers.IO) {
                runCatching {
                    val detail = fetchModuleDetail(module.id)
                    val latestTag = detail?.latestTag ?: ""
                    val html = if (latestTag.isNotBlank()) fetchReleaseDescriptionHtml(module.id, latestTag) else null
                    if (html != null) htmlLog = html
                }
            }
        }

        val confirmResult = confirmDialog.awaitConfirm(
            if (changelog.isNotEmpty() || htmlLog.isNotEmpty()) changelogText else updateText,
            content = when {
                changelog.isNotEmpty() -> changelog
                htmlLog.isNotEmpty() -> htmlLog
                else -> startDownloadingText.format(module.name)
            },
            markdown = changelog.isNotEmpty(),
            html = htmlLog.isNotEmpty(),
            confirm = updateText,
        )

        if (confirmResult != ConfirmResult.Confirmed) {
            return
        }

        showToast(startDownloadingText.format(module.name))

        val downloading = downloadingText.format(module.name)
        withContext(Dispatchers.IO) {
            download(
                url = downloadUrl,
                fileName = fileName,
                onDownloaded = onInstallModule,
                onDownloading = {
                    scope.launch(Dispatchers.Main) {
                        Toast.makeText(context, downloading, Toast.LENGTH_SHORT).show()
                    }
                }
            )
        }
    }

    suspend fun onModuleUndoUninstall(module: ModuleViewModel.ModuleInfo) {

        val success = loadingDialog.withLoading {
            withContext(Dispatchers.IO) {
                undoUninstallModule(module.id)
            }
        }

        if (success) {
            viewModel.fetchModuleList()
        }
        val message = if (success) {
            successUndoUninstall.format(module.name)
        } else {
            failedUndoUninstall.format(module.name)
        }
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }

    suspend fun onModuleUninstall(module: ModuleViewModel.ModuleInfo) {
        val formatter = if (module.metamodule) metaModuleUninstallConfirm else moduleUninstallConfirm
        val confirmResult = confirmDialog.awaitConfirm(
            moduleStr,
            content = formatter.format(module.name),
            confirm = uninstall,
            dismiss = cancel
        )
        if (confirmResult != ConfirmResult.Confirmed) {
            return
        }

        val success = loadingDialog.withLoading {
            withContext(Dispatchers.IO) {
                uninstallModule(module.id)
            }
        }

        if (success) {
            viewModel.fetchModuleList()
        }
        val message = if (success) {
            successUninstall.format(module.name)
        } else {
            failedUninstall.format(module.name)
        }
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }

    suspend fun onModuleToggle(module: ModuleViewModel.ModuleInfo) {
        val success = loadingDialog.withLoading {
            withContext(Dispatchers.IO) {
                toggleModule(module.id, !module.enabled)
            }
        }
        if (success) {
            viewModel.fetchModuleList()
            Toast.makeText(context, rebootToApply, Toast.LENGTH_SHORT).show()
        } else {
            val message = if (module.enabled) failedDisable else failedEnable
            Toast.makeText(context, message.format(module.name), Toast.LENGTH_SHORT).show()
        }
    }

    fun onModuleClick(id: String, name: String, hasWebUi: Boolean) {
        if (hasWebUi) {
            webUILauncher.launch(
                Intent(context, WebUIActivity::class.java)
                    .setData("kernelsu://webui/$id".toUri())
                    .putExtra("id", id)
                    .putExtra("name", name)
            )
        }
    }

    fun onModuleAddShortcut(module: ModuleViewModel.ModuleInfo) {
        shortcutModuleId = module.id
        shortcutName = module.name
        shortcutIconUri = null
        defaultShortcutIconUri = null
        defaultActionShortcutIconUri = module.actionIconPath
            ?.takeIf { it.isNotBlank() }
            ?.let { "su:$it" }
        defaultWebUiShortcutIconUri = module.webUiIconPath
            ?.takeIf { it.isNotBlank() }
            ?.let { "su:$it" }
        if (module.hasActionScript && module.hasWebUi) {
            selectedShortcutType = null
            showShortcutTypeDialog.value = true
        } else if (module.hasActionScript) {
            openShortcutDialogForType(ShortcutType.Action)
        } else if (module.hasWebUi) {
            openShortcutDialogForType(ShortcutType.WebUI)
        }
    }

    val listState = rememberLazyListState()
    val nestedScrollConnection = remember {
        object : NestedScrollConnection {
            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {
                val isScrolledToEnd =
                    (listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index == listState.layoutInfo.totalItemsCount - 1
                            && (listState.layoutInfo.visibleItemsInfo.lastOrNull()?.size
                        ?: 0) < listState.layoutInfo.viewportEndOffset)
                val delta = available.y
                if (!isScrolledToEnd) {
                    scrollDistance += delta
                    if (scrollDistance < -50f) {
                        if (fabVisible) fabVisible = false
                        scrollDistance = 0f
                    } else if (scrollDistance > 50f) {
                        if (!fabVisible) fabVisible = true
                        scrollDistance = 0f
                    }
                }
                return Offset.Zero
            }
        }
    }
    val offsetHeight by animateDpAsState(
        targetValue = if (fabVisible) 0.dp else 180.dp + WindowInsets.systemBars.asPaddingValues().calculateBottomPadding(),
        animationSpec = tween(durationMillis = 350)
    )

    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            searchStatus.TopAppBarAnim(hazeState = hazeState, hazeStyle = hazeStyle) {
                TopAppBar(
                    color = Color.Transparent,
                    title = stringResource(R.string.module),
                    actions = {
                        val showTopPopup = remember { mutableStateOf(false) }
                        SuperListPopup(
                            show = showTopPopup,
                            popupPositionProvider = ListPopupDefaults.ContextMenuPositionProvider,
                            alignment = PopupPositionProvider.Align.TopEnd,
                            onDismissRequest = {
                                showTopPopup.value = false
                            }
                        ) {
                            ListPopupColumn {
                                DropdownImpl(
                                    text = stringResource(R.string.module_sort_action_first),
                                    optionSize = 2,
                                    isSelected = viewModel.sortActionFirst,
                                    onSelectedIndexChange = {
                                        viewModel.sortActionFirst = !viewModel.sortActionFirst
                                        prefs.edit {
                                            putBoolean("module_sort_action_first", viewModel.sortActionFirst)
                                        }
                                        scope.launch {
                                            viewModel.fetchModuleList()
                                        }
                                        showTopPopup.value = false
                                    },
                                    index = 0
                                )
                                DropdownImpl(
                                    text = stringResource(R.string.module_sort_enabled_first),
                                    optionSize = 2,
                                    isSelected = viewModel.sortEnabledFirst,
                                    onSelectedIndexChange = {
                                        viewModel.sortEnabledFirst = !viewModel.sortEnabledFirst
                                        prefs.edit {
                                            putBoolean("module_sort_enabled_first", viewModel.sortEnabledFirst)
                                        }
                                        scope.launch {
                                            viewModel.fetchModuleList()
                                        }
                                        showTopPopup.value = false
                                    },
                                    index = 1
                                )
                            }
                        }
                        IconButton(
                            modifier = Modifier.padding(end = 8.dp),
                            onClick = { showTopPopup.value = true },
                            holdDownState = showTopPopup.value
                        ) {
                            Icon(
                                imageVector = MiuixIcons.MoreCircle,
                                tint = colorScheme.onSurface,
                                contentDescription = null
                            )
                        }
                        RebootListPopup(
                            modifier = Modifier.padding(end = 16.dp),
                            alignment = PopupPositionProvider.Align.TopEnd,
                        )
                    },
                    navigationIcon = {
                        IconButton(
                            modifier = Modifier.padding(start = 16.dp),
                            onClick = { navigator.push(Route.ModuleRepo) },
                        ) {
                            Icon(
                                imageVector = MiuixIcons.Download,
                                tint = colorScheme.onSurface,
                                contentDescription = null
                            )
                        }
                    },
                    scrollBehavior = scrollBehavior
                )
            }
        },
        floatingActionButton = {
            if (!hideInstallButton) {
                val moduleInstall = stringResource(id = R.string.module_install)
                val confirmTitle = stringResource(R.string.module)
                var zipUris by remember { mutableStateOf<List<Uri>>(emptyList()) }
                val confirmDialog = rememberConfirmDialog(
                    onConfirm = {
                        navigator.push(Route.Flash(FlashIt.FlashModules(zipUris)))
                        viewModel.markNeedRefresh()
                    }
                )
                val selectZipLauncher = rememberLauncherForActivityResult(
                    contract = ActivityResultContracts.StartActivityForResult()
                ) {
                    val uris = mutableListOf<Uri>()
                    if (it.resultCode != RESULT_OK) {
                        return@rememberLauncherForActivityResult
                    }
                    val data = it.data ?: return@rememberLauncherForActivityResult
                    val clipData = data.clipData

                    if (clipData != null) {
                        for (i in 0 until clipData.itemCount) {
                            clipData.getItemAt(i)?.uri?.let { uris.add(it) }
                        }
                    } else {
                        data.data?.let { uris.add(it) }
                    }

                    if (uris.size == 1) {
                        navigator.push(Route.Flash(FlashIt.FlashModules(listOf(uris.first()))))
                        viewModel.markNeedRefresh()
                    } else if (uris.size > 1) {
                        // multiple files selected
                        zipUris = uris
                        val moduleNames = uris.mapIndexed { index, uri -> "\n${index + 1}. ${uri.getFileName(context)}" }.joinToString("")
                        val confirmContent = context.getString(R.string.module_install_prompt_with_name, moduleNames)
                        confirmDialog.showConfirm(
                            title = confirmTitle,
                            content = confirmContent
                        )
                    }
                }
                FloatingActionButton(
                    modifier = Modifier
                        .offset(y = offsetHeight)
                        .padding(bottom = bottomInnerPadding + 20.dp, end = 20.dp)
                        .border(0.05.dp, colorScheme.outline.copy(alpha = 0.5f), CircleShape),
                    shadowElevation = 0.dp,
                    onClick = {
                        // Select the zip files to install
                        val intent = Intent(Intent.ACTION_GET_CONTENT).apply {
                            type = "application/zip"
                            putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
                        }
                        selectZipLauncher.launch(intent)
                    },
                    content = {
                        Icon(
                            Icons.Rounded.Add,
                            moduleInstall,
                            modifier = Modifier.size(40.dp),
                            tint = colorScheme.onPrimary
                        )
                    },
                )
            }
        },
        popupHost = {
            searchStatus.SearchPager(
                defaultResult = {},
                searchBarTopPadding = dynamicTopPadding,
            ) {
                item {
                    Spacer(Modifier.height(6.dp))
                }
                items(
                    viewModel.searchResults.value,
                    key = { it.id },
                    contentType = { "module" }
                ) { module ->
                    AnimatedVisibility(
                        visible = viewModel.searchResults.value.isNotEmpty(),
                        enter = fadeIn() + expandVertically(),
                        exit = fadeOut() + shrinkVertically()
                    ) {
                        val itemScope = rememberCoroutineScope()
                        val updateInfoMap = viewModel.updateInfo
                        val currentModuleState = rememberUpdatedState(module)
                        val moduleUpdateInfo = updateInfoMap[module.id] ?: ModuleViewModel.ModuleUpdateInfo.Empty

                        val onUninstallClick = remember(module.id, itemScope, ::onModuleUninstall) {
                            {
                                itemScope.launch {
                                    onModuleUninstall(currentModuleState.value)
                                }
                                Unit
                            }
                        }
                        val onUndoUninstallClick = remember(module.id, itemScope, ::onModuleUndoUninstall) {
                            {
                                itemScope.launch {
                                    onModuleUndoUninstall(currentModuleState.value)
                                }
                                Unit
                            }
                        }
                        val onToggleClick = remember(module.id, itemScope, ::onModuleToggle) {
                            { _: Boolean ->
                                itemScope.launch {
                                    onModuleToggle(currentModuleState.value)
                                }
                                Unit
                            }
                        }
                        val onUpdateClick = remember(module.id, moduleUpdateInfo, itemScope, ::onModuleUpdate, context, navigator) {
                            {
                                itemScope.launch {
                                    onModuleUpdate(
                                        currentModuleState.value,
                                        moduleUpdateInfo.changelog,
                                        moduleUpdateInfo.downloadUrl,
                                        "${currentModuleState.value.name}-${moduleUpdateInfo.version}.zip",
                                        context
                                    ) { uri ->
                                        navigator.push(Route.Flash(FlashIt.FlashModules(listOf(uri))))
                                        viewModel.markNeedRefresh()
                                    }
                                }
                                Unit
                            }
                        }
                        val onExecuteActionClick = remember(module.id, navigator, viewModel) {
                            {
                                navigator.push(Route.ExecuteModuleAction(currentModuleState.value.id))
                                viewModel.markNeedRefresh()
                            }
                        }
                        val onAddShortcutClick = remember(module.id) {
                            {
                                onModuleAddShortcut(currentModuleState.value)
                            }
                        }
                        val onOpenWebUiClick = remember(module.id) {
                            {
                                onModuleClick(
                                    currentModuleState.value.id,
                                    currentModuleState.value.name,
                                    currentModuleState.value.hasWebUi
                                )
                            }
                        }
                        ModuleItem(
                            module = module,
                            updateUrl = moduleUpdateInfo.downloadUrl,
                            onUndoUninstall = onUndoUninstallClick,
                            onUninstall = onUninstallClick,
                            onCheckChanged = onToggleClick,
                            onUpdate = onUpdateClick,
                            onExecuteAction = onExecuteActionClick,
                            onAddActionShortcut = onAddShortcutClick,
                            onOpenWebUi = onOpenWebUiClick
                        )
                    }
                }
                item {
                    val imeBottomPadding = WindowInsets.ime.asPaddingValues().calculateBottomPadding()
                    Spacer(Modifier.height(maxOf(bottomInnerPadding, imeBottomPadding)))
                }
            }
        },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        when {
            magiskInstalled -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(12.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        stringResource(R.string.module_magisk_conflict),
                        textAlign = TextAlign.Center,
                    )
                }
            }

            else -> {
                val layoutDirection = LocalLayoutDirection.current
                searchStatus.SearchBox(
                    searchBarTopPadding = dynamicTopPadding,
                    contentPadding = PaddingValues(
                        top = innerPadding.calculateTopPadding(),
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection)
                    ),
                    hazeState = hazeState,
                    hazeStyle = hazeStyle
                ) { boxHeight ->
                    ModuleList(
                        navigator = navigator,
                        viewModel = viewModel,
                        modifier = Modifier
                            .fillMaxHeight()
                            .scrollEndHaptic()
                            .overScrollVertical()
                            .nestedScroll(scrollBehavior.nestedScrollConnection)
                            .nestedScroll(nestedScrollConnection)
                            .hazeSource(state = hazeState),
                        scope = scope,
                        modules = modules,
                        onInstallModule = { navigator.push(Route.Flash(FlashIt.FlashModules(listOf(it)))) },
                        onClickModule = { id, name, hasWebUi ->
                            onModuleClick(id, name, hasWebUi)
                        },
                        onModuleUninstall = { module ->
                            onModuleUninstall(module)
                        },
                        onModuleUndoUninstall = { module ->
                            onModuleUndoUninstall(module)
                        },
                        onModuleToggle = { module ->
                            onModuleToggle(module)
                        },
                        onModuleUpdate = { module, changelogUrl, downloadUrl, fileName ->
                            onModuleUpdate(
                                module,
                                changelogUrl,
                                downloadUrl,
                                fileName,
                                context
                            ) { uri ->
                                navigator.push(Route.Flash(FlashIt.FlashModules(listOf(uri))))
                                viewModel.markNeedRefresh()
                            }
                        },
                        onModuleAddShortcut = { module ->
                            onModuleAddShortcut(module)
                        },
                        context = context,
                        innerPadding = innerPadding,
                        bottomInnerPadding = bottomInnerPadding,
                        boxHeight = boxHeight
                    )
                }
            }
        }
    }
    if (showShortcutTypeDialog.value) {
        SuperDialog(
            show = showShortcutTypeDialog,
            title = stringResource(R.string.module_shortcut_type_title),
            onDismissRequest = {
                showShortcutTypeDialog.value = false
            }
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                TextButton(
                    text = "Action",
                    onClick = {
                        showShortcutTypeDialog.value = false
                        openShortcutDialogForType(ShortcutType.Action)
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                TextButton(
                    text = "WebUI",
                    onClick = {
                        showShortcutTypeDialog.value = false
                        openShortcutDialogForType(ShortcutType.WebUI)
                    },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
    if (showShortcutDialog.value) {
        SuperDialog(
            show = showShortcutDialog,
            title = stringResource(R.string.module_shortcut_title),
            onDismissRequest = {
                showShortcutDialog.value = false
            }
        ) {
            Column(
                verticalArrangement = Arrangement.spacedBy(12.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
            ) {
                Box(
                    contentAlignment = Alignment.Center,
                    modifier = Modifier
                        .padding(vertical = 16.dp)
                        .size(100.dp)
                        .clip(ContinuousRoundedRectangle(25.dp))
                ) {
                    val preview = shortcutPreviewIcon.value
                    if (preview != null) {
                        Image(
                            bitmap = preview,
                            modifier = Modifier.size(100.dp),
                            contentDescription = null,
                        )
                    } else {
                        Box(
                            modifier = Modifier
                                .size(100.dp)
                                .background(Color.White)
                        )
                        Image(
                            painter = painterResource(id = R.drawable.ic_launcher_foreground),
                            contentDescription = null,
                            contentScale = FixedScale(1.5f)
                        )
                    }
                }
                Row {
                    TextButton(
                        modifier = Modifier.weight(1f),
                        text = stringResource(id = R.string.module_shortcut_icon_pick),
                        onClick = { pickShortcutIconLauncher.launch("image/*") },
                    )
                    AnimatedVisibility(
                        visible = shortcutIconUri != defaultShortcutIconUri,
                        enter = expandHorizontally() + slideInHorizontally(initialOffsetX = { it }),
                        exit = shrinkHorizontally() + slideOutHorizontally(targetOffsetX = { it }),
                        modifier = Modifier.align(Alignment.CenterVertically),
                    ) {
                        IconButton(
                            onClick = { shortcutIconUri = defaultShortcutIconUri },
                            modifier = Modifier.padding(start = 12.dp)
                        ) {
                            Icon(
                                imageVector = MiuixIcons.Undo,
                                contentDescription = null,
                                tint = colorScheme.onSurface,
                                modifier = Modifier.size(28.dp),
                            )
                        }
                    }
                }
                TextField(
                    value = shortcutName,
                    onValueChange = { shortcutName = it },
                    label = stringResource(id = R.string.module_shortcut_name_label)
                )
                if (hasExistingShortcut) {
                    TextButton(
                        text = stringResource(id = R.string.module_shortcut_delete),
                        onClick = {
                            val moduleId = shortcutModuleId
                            val type = selectedShortcutType
                            if (!moduleId.isNullOrBlank() && type != null) {
                                deleteModuleShortcut(context, moduleId, type)
                            }
                            showShortcutDialog.value = false
                        },
                        modifier = Modifier.fillMaxWidth(),
                    )
                }
                Row(
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    TextButton(
                        text = stringResource(id = android.R.string.cancel),
                        onClick = { showShortcutDialog.value = false },
                        modifier = Modifier.weight(1f),
                    )
                    TextButton(
                        text = if (hasExistingShortcut) {
                            stringResource(id = R.string.module_update)
                        } else {
                            stringResource(id = android.R.string.ok)
                        },
                        onClick = {
                            val moduleId = shortcutModuleId
                            val type = selectedShortcutType
                            if (!moduleId.isNullOrBlank() && shortcutName.isNotBlank() && type != null) {
                                createModuleShortcut(
                                    context = context,
                                    moduleId = moduleId,
                                    name = shortcutName,
                                    iconUri = shortcutIconUri,
                                    type = type
                                )
                            }
                            showShortcutDialog.value = false
                        },
                        colors = ButtonDefaults.textButtonColorsPrimary(),
                        modifier = Modifier.weight(1f),
                    )
                }
            }
        }
    }
}

@Composable
private fun ModuleList(
    navigator: Navigator,
    viewModel: ModuleViewModel,
    modifier: Modifier = Modifier,
    scope: CoroutineScope,
    modules: List<ModuleViewModel.ModuleInfo>,
    onInstallModule: (Uri) -> Unit,
    onClickModule: (id: String, name: String, hasWebUi: Boolean) -> Unit,
    onModuleUninstall: suspend (ModuleViewModel.ModuleInfo) -> Unit,
    onModuleUndoUninstall: suspend (ModuleViewModel.ModuleInfo) -> Unit,
    onModuleToggle: suspend (ModuleViewModel.ModuleInfo) -> Unit,
    onModuleUpdate: suspend (ModuleViewModel.ModuleInfo, String, String, String) -> Unit,
    onModuleAddShortcut: (ModuleViewModel.ModuleInfo) -> Unit,
    context: Context,
    innerPadding: PaddingValues,
    bottomInnerPadding: Dp,
    boxHeight: MutableState<Dp>
) {
    val layoutDirection = LocalLayoutDirection.current
    val updateInfoMap = viewModel.updateInfo

    var isRefreshing by rememberSaveable { mutableStateOf(false) }
    val pullToRefreshState = rememberPullToRefreshState()
    val refreshTexts = remember {
        listOf(
            context.getString(R.string.refresh_pulling),
            context.getString(R.string.refresh_release),
            context.getString(R.string.refresh_refresh),
            context.getString(R.string.refresh_complete),
        )
    }
    LaunchedEffect(isRefreshing) {
        if (isRefreshing) {
            delay(150)
            viewModel.fetchModuleList()
            isRefreshing = false
        }
    }

    when {
        modules.isEmpty() -> {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(
                        top = innerPadding.calculateTopPadding(),
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection),
                        bottom = bottomInnerPadding
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    stringResource(R.string.module_empty),
                    textAlign = TextAlign.Center,
                    color = Color.Gray,
                )
            }
        }

        else -> {
            PullToRefresh(
                isRefreshing = isRefreshing,
                pullToRefreshState = pullToRefreshState,
                onRefresh = { if (!isRefreshing) isRefreshing = true },
                refreshTexts = refreshTexts,
                contentPadding = PaddingValues(
                    top = innerPadding.calculateTopPadding() + boxHeight.value + 6.dp,
                    start = innerPadding.calculateStartPadding(layoutDirection),
                    end = innerPadding.calculateEndPadding(layoutDirection),
                ),
            ) {
                LazyColumn(
                    modifier = modifier
                        .fillMaxHeight(),
                    contentPadding = PaddingValues(
                        top = innerPadding.calculateTopPadding() + boxHeight.value + 6.dp,
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection),
                    ),
                    overscrollEffect = null,
                ) {
                    items(
                        items = modules,
                        key = { it.id },
                        contentType = { "module" }
                    ) { module ->
                        val currentModuleState = rememberUpdatedState(module)
                        val moduleUpdateInfo = updateInfoMap[module.id] ?: ModuleViewModel.ModuleUpdateInfo.Empty

                        val onUndoUninstallClick = remember(module.id, scope, onModuleUndoUninstall) {
                            {
                                scope.launch {
                                    onModuleUndoUninstall(currentModuleState.value)
                                }
                                Unit
                            }
                        }
                        val onUninstallClick = remember(module.id, scope, onModuleUninstall) {
                            {
                                scope.launch {
                                    onModuleUninstall(currentModuleState.value)
                                }
                                Unit
                            }
                        }
                        val onToggleClick = remember(module.id, scope, onModuleToggle) {
                            { _: Boolean ->
                                scope.launch {
                                    onModuleToggle(currentModuleState.value)
                                }
                                Unit
                            }
                        }
                        val onUpdateClick = remember(module.id, moduleUpdateInfo, scope, onModuleUpdate) {
                            {
                                scope.launch {
                                    onModuleUpdate(
                                        currentModuleState.value,
                                        moduleUpdateInfo.changelog,
                                        moduleUpdateInfo.downloadUrl,
                                        "${currentModuleState.value.name}-${moduleUpdateInfo.version}.zip",
                                    )
                                }
                                Unit
                            }
                        }
                        val onExecuteActionClick = remember(module.id, navigator, viewModel) {
                            {
                                navigator.push(Route.ExecuteModuleAction(currentModuleState.value.id))
                                viewModel.markNeedRefresh()
                            }
                        }
                        val onAddShortcutClick = remember(module.id) {
                            {
                                onModuleAddShortcut(currentModuleState.value)
                            }
                        }
                        val onOpenWebUiClick = remember(module.id, onClickModule) {
                            {
                                onClickModule(
                                    currentModuleState.value.id,
                                    currentModuleState.value.name,
                                    currentModuleState.value.hasWebUi
                                )
                            }
                        }

                        ModuleItem(
                            module = module,
                            updateUrl = moduleUpdateInfo.downloadUrl,
                            onUninstall = onUninstallClick,
                            onUndoUninstall = onUndoUninstallClick,
                            onCheckChanged = onToggleClick,
                            onUpdate = onUpdateClick,
                            onExecuteAction = onExecuteActionClick,
                            onAddActionShortcut = onAddShortcutClick,
                            onOpenWebUi = onOpenWebUiClick
                        )
                    }
                    item {
                        Spacer(Modifier.height(bottomInnerPadding))
                    }
                }
            }
        }
    }
    DownloadListener(context, onInstallModule)
}

@Composable
fun ModuleItem(
    module: ModuleViewModel.ModuleInfo,
    updateUrl: String,
    onUndoUninstall: () -> Unit,
    onUninstall: () -> Unit,
    onCheckChanged: (Boolean) -> Unit,
    onUpdate: () -> Unit,
    onExecuteAction: () -> Unit,
    onAddActionShortcut: () -> Unit,
    onOpenWebUi: () -> Unit
) {
    val context = LocalContext.current
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    val isDark = isInDarkTheme(prefs.getInt("color_mode", 0))
    val secondaryContainer = colorScheme.secondaryContainer.copy(alpha = 0.8f)
    val actionIconTint = colorScheme.onSurface.copy(alpha = if (isDark) 0.7f else 0.9f)
    val updateBg = colorScheme.tertiaryContainer.copy(alpha = 0.6f)
    val updateTint = colorScheme.onTertiaryContainer.copy(alpha = 0.8f)
    val hasUpdate by remember(updateUrl) { derivedStateOf { updateUrl.isNotEmpty() } }
    val textDecoration by remember(module.remove) {
        mutableStateOf(if (module.remove) TextDecoration.LineThrough else null)
    }
    val hasDescription by remember(module.description) {
        derivedStateOf { module.description.isNotBlank() }
    }
    var expanded by rememberSaveable(module.id) { mutableStateOf(false) }

    Card(
        modifier = Modifier
            .padding(horizontal = 12.dp)
            .padding(bottom = 12.dp),
        insideMargin = PaddingValues(16.dp),
        onClick = {
            if (hasDescription) expanded = !expanded
        }
    ) {
        Row(
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalAlignment = Alignment.CenterVertically,
        ) {
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(end = 4.dp)
            ) {
                val moduleVersion = stringResource(id = R.string.module_version)
                val moduleAuthor = stringResource(id = R.string.module_author)

                SubcomposeLayout { constraints ->
                    val spacingPx = 6.dp.roundToPx()
                    var nameTextLayout: TextLayoutResult? = null
                    val metaPlaceable = if (module.metamodule) {
                        subcompose("meta") {
                            Text(
                                text = "META",
                                fontSize = 12.sp,
                                color = updateTint,
                                modifier = Modifier
                                    .clip(ContinuousRoundedRectangle(6.dp))
                                    .background(updateBg)
                                    .padding(horizontal = 6.dp, vertical = 2.dp),
                                fontWeight = FontWeight(750),
                                maxLines = 1,
                                softWrap = false
                            )
                        }.first().measure(Constraints(0, constraints.maxWidth, 0, constraints.maxHeight))
                    } else null

                    val reserved = (metaPlaceable?.width ?: 0) + if (metaPlaceable != null) spacingPx else 0
                    val nameMax = (constraints.maxWidth - reserved).coerceAtLeast(0)
                    val namePlaceable = subcompose("name") {
                        Text(
                            text = module.name,
                            fontSize = 17.sp,
                            fontWeight = FontWeight(550),
                            color = colorScheme.onSurface,
                            textDecoration = textDecoration,
                            onTextLayout = { nameTextLayout = it }
                        )
                    }.first().measure(Constraints(constraints.minWidth, nameMax, constraints.minHeight, constraints.maxHeight))

                    val width = (namePlaceable.width + reserved).coerceIn(constraints.minWidth, constraints.maxWidth)
                    val height = maxOf(namePlaceable.height, metaPlaceable?.height ?: 0)

                    layout(width, height) {
                        namePlaceable.placeRelative(0, 0)
                        val endX = nameTextLayout?.let { layoutRes ->
                            val last = (layoutRes.lineCount - 1).coerceAtLeast(0)
                            layoutRes.getLineRight(last).toInt()
                        } ?: namePlaceable.width
                        metaPlaceable?.placeRelative(endX + spacingPx, (height - (metaPlaceable.height)) / 2)
                    }
                }
                Text(
                    text = "$moduleVersion: ${module.version}",
                    fontSize = 12.sp,
                    modifier = Modifier.padding(top = 2.dp),
                    fontWeight = FontWeight(550),
                    color = colorScheme.onSurfaceVariantSummary,
                    textDecoration = textDecoration
                )
                Text(
                    text = "$moduleAuthor: ${module.author}",
                    fontSize = 12.sp,
                    modifier = Modifier.padding(bottom = 1.dp),
                    fontWeight = FontWeight(550),
                    color = colorScheme.onSurfaceVariantSummary,
                    textDecoration = textDecoration
                )
            }
            Switch(
                enabled = !module.update,
                checked = module.enabled,
                onCheckedChange = {
                    if (it != module.enabled) onCheckChanged(it)
                }
            )
        }

        if (hasDescription) {
            Box(
                modifier = Modifier
                    .padding(top = 2.dp)
                    .animateContentSize(
                        animationSpec = tween(
                            durationMillis = 250,
                            easing = FastOutSlowInEasing
                        )
                    )
            ) {
                Text(
                    text = module.description,
                    fontSize = 14.sp,
                    color = colorScheme.onSurfaceVariantSummary,
                    overflow = if (expanded) TextOverflow.Clip else TextOverflow.Ellipsis,
                    maxLines = if (expanded) Int.MAX_VALUE else 4,
                    textDecoration = textDecoration
                )
            }
        }

        HorizontalDivider(
            modifier = Modifier.padding(vertical = 8.dp),
            thickness = 0.5.dp,
            color = colorScheme.outline.copy(alpha = 0.5f)
        )

        Row {
            AnimatedVisibility(
                visible = module.enabled && !module.remove && !module.update,
                enter = fadeIn(),
                exit = fadeOut()
            ) {
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    if (module.hasActionScript) {
                        IconButton(
                            backgroundColor = secondaryContainer,
                            minHeight = 35.dp,
                            minWidth = 35.dp,
                            onClick = onExecuteAction,
                        ) {
                            Icon(
                                modifier = Modifier.size(20.dp),
                                imageVector = Icons.Rounded.PlayArrow,
                                tint = actionIconTint,
                                contentDescription = stringResource(R.string.action)
                            )
                        }
                    }
                    if (module.hasWebUi) {
                        IconButton(
                            backgroundColor = secondaryContainer,
                            minHeight = 35.dp,
                            minWidth = 35.dp,
                            onClick = onOpenWebUi,
                        ) {
                            Icon(
                                modifier = Modifier.size(20.dp),
                                imageVector = Icons.Rounded.Code,
                                tint = actionIconTint,
                                contentDescription = stringResource(R.string.open)
                            )
                        }
                    }
                    if (module.hasActionScript || module.hasWebUi) {
                        IconButton(
                            backgroundColor = secondaryContainer,
                            minHeight = 35.dp,
                            minWidth = 35.dp,
                            onClick = onAddActionShortcut,
                        ) {
                            Icon(
                                modifier = Modifier.size(20.dp),
                                imageVector = Icons.Rounded.Add,
                                tint = actionIconTint,
                                contentDescription = stringResource(R.string.module_shortcut_add)
                            )
                        }
                    }
                }
            }

            Spacer(Modifier.weight(1f))

            AnimatedVisibility(
                visible = hasUpdate,
                enter = fadeIn(),
                exit = fadeOut()
            ) {
                IconButton(
                    modifier = Modifier.padding(end = 16.dp),
                    backgroundColor = updateBg,
                    enabled = !module.remove,
                    minHeight = 35.dp,
                    minWidth = 35.dp,
                    onClick = onUpdate,
                ) {
                    Row(
                        modifier = Modifier.padding(horizontal = 10.dp),
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(2.dp),
                    ) {
                        Icon(
                            modifier = Modifier.size(20.dp),
                            imageVector = MiuixIcons.UploadCloud,
                            tint = updateTint,
                            contentDescription = stringResource(R.string.module_update),
                        )
                        Text(
                            modifier = Modifier.padding(start = 4.dp, end = 2.dp),
                            text = stringResource(R.string.module_update),
                            color = updateTint,
                            fontWeight = FontWeight.Medium,
                            fontSize = 15.sp
                        )
                    }
                }
            }
            IconButton(
                minHeight = 35.dp,
                minWidth = 35.dp,
                onClick = if (module.remove) onUndoUninstall else onUninstall,
                backgroundColor = if (module.remove) {
                    secondaryContainer.copy(alpha = 0.8f)
                } else {
                    secondaryContainer
                },
            ) {
                val animatedPadding by animateDpAsState(
                    targetValue = if (!hasUpdate) 10.dp else 0.dp,
                    animationSpec = tween(durationMillis = 300)
                )
                Row(
                    modifier = Modifier.padding(horizontal = animatedPadding),
                    verticalAlignment = Alignment.CenterVertically,
                ) {
                    Icon(
                        modifier = Modifier.size(20.dp),
                        imageVector = if (module.remove) {
                            MiuixIcons.Undo
                        } else {
                            MiuixIcons.Delete
                        },
                        tint = actionIconTint,
                        contentDescription = null
                    )
                    AnimatedVisibility(
                        visible = !hasUpdate,
                        enter = expandHorizontally(),
                        exit = shrinkHorizontally()
                    ) {
                        Text(
                            modifier = Modifier.padding(start = 4.dp, end = 3.dp),
                            text = stringResource(
                                if (module.remove) R.string.undo else R.string.uninstall
                            ),
                            color = actionIconTint,
                            fontWeight = FontWeight.Medium,
                            fontSize = 15.sp
                        )
                    }
                }
            }
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/ModuleRepo.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.annotation.SuppressLint
import android.content.Context
import android.net.Uri
import android.os.Parcelable
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.EaseInOut
import androidx.compose.animation.core.tween
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateEndPadding
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.platform.UriHandler
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.zIndex
import androidx.core.content.edit
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigationevent.NavigationEventInfo
import androidx.navigationevent.compose.NavigationBackHandler
import androidx.navigationevent.compose.rememberNavigationEventState
import com.kyant.capsule.ContinuousRoundedRectangle
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.ConfirmDialogHandle
import me.weishu.kernelsu.ui.component.GithubMarkdown
import me.weishu.kernelsu.ui.component.SearchBox
import me.weishu.kernelsu.ui.component.SearchPager
import me.weishu.kernelsu.ui.component.rememberConfirmDialog
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.theme.isInDarkTheme
import me.weishu.kernelsu.ui.util.DownloadListener
import me.weishu.kernelsu.ui.util.download
import me.weishu.kernelsu.ui.util.isNetworkAvailable
import me.weishu.kernelsu.ui.util.module.fetchModuleDetail
import me.weishu.kernelsu.ui.viewmodel.ModuleRepoViewModel
import me.weishu.kernelsu.ui.viewmodel.ModuleViewModel
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.CircularProgressIndicator
import top.yukonga.miuix.kmp.basic.DropdownImpl
import top.yukonga.miuix.kmp.basic.HorizontalDivider
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.InfiniteProgressIndicator
import top.yukonga.miuix.kmp.basic.ListPopupColumn
import top.yukonga.miuix.kmp.basic.ListPopupDefaults
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.PopupPositionProvider
import top.yukonga.miuix.kmp.basic.PullToRefresh
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.ScrollBehavior
import top.yukonga.miuix.kmp.basic.SmallTitle
import top.yukonga.miuix.kmp.basic.TabRow
import top.yukonga.miuix.kmp.basic.TabRowDefaults
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.basic.rememberPullToRefreshState
import top.yukonga.miuix.kmp.extra.SuperListPopup
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.FileDownloads
import top.yukonga.miuix.kmp.icon.extended.HorizontalSplit
import top.yukonga.miuix.kmp.icon.extended.Link
import top.yukonga.miuix.kmp.icon.extended.MoreCircle
import top.yukonga.miuix.kmp.icon.extended.TopDownloads
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.PressFeedbackType
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic
import java.text.Collator
import java.util.Locale

@Parcelize
data class ReleaseAssetArg(
    val name: String,
    val downloadUrl: String,
    val size: Long,
    val downloadCount: Int
) : Parcelable

@Parcelize
data class ReleaseArg(
    val tagName: String,
    val name: String,
    val publishedAt: String,
    val assets: List<ReleaseAssetArg>,
    val descriptionHTML: String
) : Parcelable

@Parcelize
data class AuthorArg(
    val name: String,
    val link: String,
) : Parcelable

@Parcelize
data class RepoModuleArg(
    val moduleId: String,
    val moduleName: String,
    val authors: String,
    val authorsList: List<AuthorArg>,
    val latestRelease: String,
    val latestReleaseTime: String,
    val releases: List<ReleaseArg>
) : Parcelable

@SuppressLint("LocalContextGetResourceValueCall")
@Composable
fun ModuleRepoScreen(
) {
    val navigator = LocalNavigator.current
    val viewModel = viewModel<ModuleRepoViewModel>()
    val installedVm = viewModel<ModuleViewModel>()
    val searchStatus by viewModel.searchStatus
    val context = LocalContext.current
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    val metaBg = colorScheme.tertiaryContainer.copy(alpha = 0.6f)
    val metaTint = colorScheme.onTertiaryContainer.copy(alpha = 0.8f)
    val repoSortByNameState = remember { mutableStateOf(prefs.getBoolean("module_repo_sort_name", false)) }

    LaunchedEffect(Unit) {
        if (viewModel.modules.value.isEmpty()) {
            viewModel.refresh()
        }
        if (installedVm.moduleList.isEmpty()) {
            installedVm.fetchModuleList()
        }
    }

    LaunchedEffect(searchStatus.searchText) {
        viewModel.updateSearchText(searchStatus.searchText)
    }

    val scrollBehavior = MiuixScrollBehavior()
    val dynamicTopPadding by remember {
        derivedStateOf { 12.dp * (1f - scrollBehavior.state.collapsedFraction) }
    }

    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            searchStatus.TopAppBarAnim(hazeState = hazeState, hazeStyle = hazeStyle) {
                TopAppBar(
                    color = Color.Transparent,
                    title = stringResource(R.string.module_repos),
                    actions = {
                        val showTopPopup = remember { mutableStateOf(false) }
                        SuperListPopup(
                            show = showTopPopup,
                            popupPositionProvider = ListPopupDefaults.ContextMenuPositionProvider,
                            alignment = PopupPositionProvider.Align.TopEnd,
                            onDismissRequest = { showTopPopup.value = false }
                        ) {
                            ListPopupColumn {
                                DropdownImpl(
                                    text = stringResource(R.string.module_repos_sort_name),
                                    optionSize = 1,
                                    isSelected = repoSortByNameState.value,
                                    onSelectedIndexChange = {
                                        repoSortByNameState.value = !repoSortByNameState.value
                                        prefs.edit {
                                            putBoolean("module_repo_sort_name", repoSortByNameState.value)
                                        }
                                        showTopPopup.value = false
                                    },
                                    index = 0
                                )
                            }
                        }
                        IconButton(
                            modifier = Modifier.padding(end = 16.dp),
                            onClick = { showTopPopup.value = true },
                            holdDownState = showTopPopup.value
                        ) {
                            Icon(
                                imageVector = MiuixIcons.MoreCircle,
                                tint = colorScheme.onSurface,
                                contentDescription = null,
                            )
                        }
                    },
                    navigationIcon = {
                        IconButton(
                            modifier = Modifier.padding(start = 16.dp),
                            onClick = { navigator.pop() }

                        ) {
                            val layoutDirection = LocalLayoutDirection.current
                            Icon(
                                modifier = Modifier.graphicsLayer {
                                    if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                                },
                                imageVector = MiuixIcons.Back,
                                contentDescription = null,
                                tint = colorScheme.onSurface
                            )
                        }
                    },
                    scrollBehavior = scrollBehavior,
                )
            }
        },
        popupHost = {
            searchStatus.SearchPager(
                defaultResult = {},
                searchBarTopPadding = dynamicTopPadding,
            ) {
                item {
                    Spacer(Modifier.height(6.dp))
                }
                val displaySearch = run {
                    val base = viewModel.searchResults.value
                    val sortByName = repoSortByNameState.value
                    val collator = Collator.getInstance(Locale.getDefault())
                    if (!sortByName) base else base.sortedWith(compareBy(collator) { it.moduleName })
                }
                items(displaySearch, key = { it.moduleId }) { module ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 12.dp)
                            .padding(bottom = 12.dp),
                        insideMargin = PaddingValues(16.dp),
                        showIndication = true,
                        pressFeedbackType = PressFeedbackType.Sink,
                        onClick = {
                            val args = RepoModuleArg(
                                moduleId = module.moduleId,
                                moduleName = module.moduleName,
                                authors = module.authors,
                                authorsList = module.authorList.map { AuthorArg(it.name, it.link) },
                                latestRelease = module.latestRelease,
                                latestReleaseTime = module.latestReleaseTime,
                                releases = emptyList()
                            )
                            navigator.push(Route.ModuleRepoDetail(args))
                        }
                    ) {
                        Column {
                            if (module.moduleName.isNotEmpty()) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Text(
                                        text = module.moduleName,
                                        fontSize = 17.sp,
                                        fontWeight = FontWeight(550),
                                        color = colorScheme.onSurface
                                    )
                                    if (module.metamodule) {
                                        Text(
                                            text = "META",
                                            fontSize = 12.sp,
                                            color = metaTint,
                                            modifier = Modifier
                                                .padding(start = 6.dp)
                                                .clip(ContinuousRoundedRectangle(6.dp))
                                                .background(metaBg)
                                                .padding(horizontal = 6.dp, vertical = 2.dp),
                                            fontWeight = FontWeight(750),
                                            maxLines = 1
                                        )
                                    }
                                    Spacer(Modifier.weight(1f))
                                    if (module.stargazerCount > 0) {
                                        Row(verticalAlignment = Alignment.CenterVertically) {
                                            Icon(
                                                imageVector = MiuixIcons.TopDownloads,
                                                contentDescription = "stars",
                                                tint = colorScheme.onSurfaceVariantSummary,
                                                modifier = Modifier.size(16.dp)
                                            )
                                            Text(
                                                text = module.stargazerCount.toString(),
                                                fontSize = 12.sp,
                                                color = colorScheme.onSurfaceVariantSummary,
                                                modifier = Modifier.padding(start = 4.dp)
                                            )
                                        }
                                    }
                                }
                            }
                            if (module.moduleId.isNotEmpty()) {
                                Text(
                                    text = "ID: ${module.moduleId}",
                                    fontSize = 12.sp,
                                    fontWeight = FontWeight(550),
                                    color = colorScheme.onSurfaceVariantSummary,
                                )
                            }
                            Text(
                                text = "${stringResource(id = R.string.module_author)}: ${module.authors}",
                                fontSize = 12.sp,
                                modifier = Modifier.padding(bottom = 1.dp),
                                fontWeight = FontWeight(550),
                                color = colorScheme.onSurfaceVariantSummary,
                            )
                            if (module.summary.isNotEmpty()) {
                                Text(
                                    text = module.summary,
                                    fontSize = 14.sp,
                                    color = colorScheme.onSurfaceVariantSummary,
                                    modifier = Modifier.padding(top = 2.dp),
                                    overflow = TextOverflow.Ellipsis,
                                    maxLines = 4,
                                )
                            }
                        }
                    }
                }
            }
        },
    ) { innerPadding ->
        val layoutDirection = LocalLayoutDirection.current
        val isLoading = viewModel.modules.value.isEmpty()
        val offline = !isNetworkAvailable(context)

        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                if (offline) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(text = stringResource(R.string.network_offline), color = colorScheme.onSurfaceVariantSummary, fontSize = 16.sp)
                        Spacer(Modifier.height(12.dp))
                        TextButton(
                            modifier = Modifier
                                .padding(horizontal = 24.dp)
                                .fillMaxWidth(),
                            text = stringResource(R.string.network_retry),
                            onClick = { viewModel.refresh() },
                        )
                    }
                } else {
                    InfiniteProgressIndicator()
                }
            }
        } else {
            searchStatus.SearchBox(
                searchBarTopPadding = dynamicTopPadding,
                contentPadding = PaddingValues(
                    top = innerPadding.calculateTopPadding(),
                    start = innerPadding.calculateStartPadding(layoutDirection),
                    end = innerPadding.calculateEndPadding(layoutDirection)
                ),
                hazeState = hazeState,
                hazeStyle = hazeStyle
            ) { boxHeight ->
                var isRefreshing by rememberSaveable { mutableStateOf(false) }
                val pullToRefreshState = rememberPullToRefreshState()
                LaunchedEffect(isRefreshing) {
                    if (isRefreshing) {
                        delay(150)
                        viewModel.refresh()
                        isRefreshing = false
                    }
                }
                val refreshTexts = listOf(
                    stringResource(R.string.refresh_pulling),
                    stringResource(R.string.refresh_release),
                    stringResource(R.string.refresh_refresh),
                    stringResource(R.string.refresh_complete),
                )
                PullToRefresh(
                    isRefreshing = isRefreshing,
                    pullToRefreshState = pullToRefreshState,
                    onRefresh = { if (!isRefreshing) isRefreshing = true },
                    refreshTexts = refreshTexts,
                    contentPadding = PaddingValues(
                        top = innerPadding.calculateTopPadding() + boxHeight.value + 6.dp,
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection)
                    ),
                ) {
                    val displayModules = run {
                        val base = viewModel.modules.value
                        val sortByName = repoSortByNameState.value
                        val collator = Collator.getInstance(Locale.getDefault())
                        if (!sortByName) base else base.sortedWith(compareBy(collator) { it.moduleName })
                    }
                    LazyColumn(
                        modifier = Modifier
                            .fillMaxHeight()
                            .scrollEndHaptic()
                            .overScrollVertical()
                            .nestedScroll(scrollBehavior.nestedScrollConnection)
                            .hazeSource(state = hazeState),
                        contentPadding = PaddingValues(
                            top = innerPadding.calculateTopPadding() + boxHeight.value + 6.dp,
                            start = innerPadding.calculateStartPadding(layoutDirection),
                            end = innerPadding.calculateEndPadding(layoutDirection)
                        ),
                        overscrollEffect = null,
                    ) {
                        items(
                            items = displayModules,
                            key = { it.moduleId },
                            contentType = { "module" }
                        ) { module ->
                            val moduleAuthor = stringResource(id = R.string.module_author)

                            Card(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(horizontal = 12.dp)
                                    .padding(bottom = 12.dp),
                                insideMargin = PaddingValues(16.dp),
                                showIndication = true,
                                pressFeedbackType = PressFeedbackType.Sink,
                                onClick = {
                                    val args = RepoModuleArg(
                                        moduleId = module.moduleId,
                                        moduleName = module.moduleName,
                                        authors = module.authors,
                                        authorsList = module.authorList.map { AuthorArg(it.name, it.link) },
                                        latestRelease = module.latestRelease,
                                        latestReleaseTime = module.latestReleaseTime,
                                        releases = emptyList()
                                    )
                                    navigator.push(Route.ModuleRepoDetail(args))
                                }
                            ) {
                                Column {
                                    if (module.moduleName.isNotEmpty()) {
                                        Row(verticalAlignment = Alignment.CenterVertically) {
                                            Text(
                                                text = module.moduleName,
                                                fontSize = 17.sp,
                                                fontWeight = FontWeight(550),
                                                color = colorScheme.onSurface
                                            )
                                            if (module.metamodule) {
                                                Text(
                                                    text = "META",
                                                    fontSize = 12.sp,
                                                    color = metaTint,
                                                    modifier = Modifier
                                                        .padding(start = 6.dp)
                                                        .clip(ContinuousRoundedRectangle(6.dp))
                                                        .background(metaBg)
                                                        .padding(horizontal = 6.dp, vertical = 2.dp),
                                                    fontWeight = FontWeight(750),
                                                    maxLines = 1
                                                )
                                            }
                                        }
                                    }
                                    if (module.moduleId.isNotEmpty()) {
                                        Text(
                                            text = "ID: ${module.moduleId}",
                                            fontSize = 12.sp,
                                            fontWeight = FontWeight(550),
                                            color = colorScheme.onSurfaceVariantSummary,
                                        )
                                    }
                                    Text(
                                        text = "$moduleAuthor: ${module.authors}",
                                        fontSize = 12.sp,
                                        modifier = Modifier.padding(bottom = 1.dp),
                                        fontWeight = FontWeight(550),
                                        color = colorScheme.onSurfaceVariantSummary,
                                    )
                                    if (module.summary.isNotEmpty()) {
                                        Text(
                                            text = module.summary,
                                            fontSize = 14.sp,
                                            color = colorScheme.onSurfaceVariantSummary,
                                            modifier = Modifier.padding(top = 2.dp),
                                            overflow = TextOverflow.Ellipsis,
                                            maxLines = 4,
                                        )
                                    }
                                    HorizontalDivider(
                                        modifier = Modifier.padding(vertical = 8.dp),
                                        thickness = 0.5.dp,
                                        color = colorScheme.outline.copy(alpha = 0.5f)
                                    )
                                    Row(
                                        verticalAlignment = Alignment.CenterVertically,
                                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                                    ) {
                                        Row {
                                            if (module.stargazerCount > 0) {
                                                Row(verticalAlignment = Alignment.CenterVertically) {
                                                    Icon(
                                                        imageVector = MiuixIcons.TopDownloads,
                                                        contentDescription = "stars",
                                                        tint = colorScheme.onSurfaceVariantSummary,
                                                        modifier = Modifier.size(16.dp)
                                                    )
                                                    Text(
                                                        text = module.stargazerCount.toString(),
                                                        fontSize = 12.sp,
                                                        color = colorScheme.onSurfaceVariantSummary,
                                                        modifier = Modifier.padding(start = 4.dp)
                                                    )
                                                }
                                            }
                                            Spacer(Modifier.weight(1f))
                                            if (module.latestReleaseTime.isNotEmpty()) {
                                                Text(
                                                    text = module.latestReleaseTime,
                                                    fontSize = 12.sp,
                                                    color = colorScheme.onSurfaceVariantSummary,
                                                    textAlign = TextAlign.End
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        item {
                            Spacer(Modifier.height(WindowInsets.systemBars.asPaddingValues().calculateBottomPadding()))
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ReadmePage(
    readmeHtml: String?,
    readmeLoaded: Boolean,
    innerPadding: PaddingValues,
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState
) {
    val layoutDirection = LocalLayoutDirection.current
    LazyColumn(
        modifier = Modifier
            .fillMaxHeight()
            .scrollEndHaptic()
            .overScrollVertical()
            .nestedScroll(scrollBehavior.nestedScrollConnection)
            .hazeSource(state = hazeState),
        contentPadding = PaddingValues(
            top = innerPadding.calculateTopPadding(),
            start = innerPadding.calculateStartPadding(layoutDirection),
            end = innerPadding.calculateEndPadding(layoutDirection),
            bottom = innerPadding.calculateBottomPadding(),
        ),
        overscrollEffect = null,
    ) {
        item {
            val isLoading = remember { mutableStateOf(true) }
            if (isLoading.value) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(
                            top = innerPadding.calculateTopPadding(),
                            start = innerPadding.calculateStartPadding(layoutDirection),
                            end = innerPadding.calculateEndPadding(layoutDirection),
                            bottom = innerPadding.calculateBottomPadding(),
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    InfiniteProgressIndicator()
                }
            }
            AnimatedVisibility(
                visible = readmeLoaded && readmeHtml != null,
                enter = expandVertically() + fadeIn(),
                exit = shrinkVertically() + fadeOut()
            ) {
                Column {
                    Spacer(Modifier.height(6.dp))
                    Card(
                        modifier = Modifier.padding(horizontal = 12.dp),
                    ) {
                        Column {
                            GithubMarkdown(content = readmeHtml!!, isLoading)
                        }
                    }
                }
            }
        }
        item { Spacer(Modifier.height(12.dp)) }
    }
}

@SuppressLint("DefaultLocale")
@Composable
fun ReleasesPage(
    detailReleases: List<ReleaseArg>,
    innerPadding: PaddingValues,
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    actionIconTint: Color,
    secondaryContainer: Color,
    confirmTitle: String,
    confirmDialog: ConfirmDialogHandle,
    scope: CoroutineScope,
    onInstallModule: (Uri) -> Unit,
    context: Context,
    setPendingDownload: ((() -> Unit)) -> Unit,
) {
    val layoutDirection = LocalLayoutDirection.current
    LazyColumn(
        modifier = Modifier
            .fillMaxHeight()
            .scrollEndHaptic()
            .overScrollVertical()
            .nestedScroll(scrollBehavior.nestedScrollConnection)
            .hazeSource(state = hazeState),
        contentPadding = PaddingValues(
            top = innerPadding.calculateTopPadding(),
            start = innerPadding.calculateStartPadding(layoutDirection),
            end = innerPadding.calculateEndPadding(layoutDirection),
            bottom = innerPadding.calculateBottomPadding(),
        ),
        overscrollEffect = null,
    ) {
        if (detailReleases.isNotEmpty()) {
            item {
                Spacer(Modifier.height(6.dp))
            }
            items(
                items = detailReleases,
                key = { it.tagName },
                contentType = { "release" }
            ) { rel ->
                val title = remember(rel.name, rel.tagName) { rel.name.ifBlank { rel.tagName } }
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 12.dp)
                        .padding(bottom = 12.dp)
                ) {
                    Column {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Column(
                                modifier = Modifier
                                    .padding(start = 16.dp, end = 16.dp, top = 16.dp)
                                    .weight(1f)
                            ) {
                                Text(
                                    text = title,
                                    fontSize = 17.sp,
                                    fontWeight = FontWeight(550),
                                    color = colorScheme.onSurface
                                )
                                Text(
                                    text = rel.tagName,
                                    fontSize = 12.sp,
                                    fontWeight = FontWeight(550),
                                    color = colorScheme.onSurfaceVariantSummary,
                                    modifier = Modifier.padding(top = 2.dp)
                                )
                            }
                            Text(
                                text = rel.publishedAt,
                                fontSize = 12.sp,
                                color = colorScheme.onSurfaceVariantSummary,
                                modifier = Modifier
                                    .padding(start = 16.dp, end = 16.dp, top = 16.dp)
                                    .align(Alignment.Top)
                            )
                        }
                        AnimatedVisibility(
                            visible = rel.assets.isNotEmpty(),
                            enter = fadeIn() + expandVertically(),
                            exit = fadeOut() + shrinkVertically()
                        ) {
                            Column {
                                AnimatedVisibility(
                                    visible = rel.descriptionHTML.isNotEmpty(),
                                    enter = fadeIn() + expandVertically(),
                                    exit = fadeOut() + shrinkVertically()
                                ) {
                                    Column {
                                        HorizontalDivider(
                                            modifier = Modifier.padding(start = 16.dp, end = 16.dp, top = 4.dp),
                                            thickness = 0.5.dp,
                                            color = colorScheme.outline.copy(alpha = 0.5f)
                                        )
                                        GithubMarkdown(content = rel.descriptionHTML)
                                    }
                                }
                                HorizontalDivider(
                                    modifier = Modifier.padding(start = 16.dp, end = 16.dp, bottom = 8.dp),
                                    thickness = 0.5.dp,
                                    color = colorScheme.outline.copy(alpha = 0.5f)
                                )
                                rel.assets.forEachIndexed { index, asset ->
                                    val fileName = asset.name
                                    stringResource(R.string.module_downloading)
                                    val sizeText = remember(asset.size) {
                                        val s = asset.size
                                        when {
                                            s >= 1024L * 1024L * 1024L -> String.format("%.1f GB", s / (1024f * 1024f * 1024f))
                                            s >= 1024L * 1024L -> String.format("%.1f MB", s / (1024f * 1024f))
                                            s >= 1024L -> String.format("%.0f KB", s / 1024f)
                                            else -> "$s B"
                                        }
                                    }
                                    val sizeAndDownloads =
                                        remember(sizeText, asset.downloadCount) { "$sizeText · ${asset.downloadCount} downloads" }
                                    var isDownloading by remember(fileName, asset.downloadUrl) { mutableStateOf(false) }
                                    var progress by remember(fileName, asset.downloadUrl) { mutableIntStateOf(0) }
                                    val onClickDownload = remember(fileName, asset.downloadUrl) {
                                        {
                                            val startText = context.getString(R.string.module_start_downloading, fileName)
                                            setPendingDownload {
                                                isDownloading = true
                                                scope.launch(Dispatchers.IO) {
                                                    download(
                                                        asset.downloadUrl,
                                                        fileName,
                                                        onDownloaded = onInstallModule,
                                                        onDownloading = { isDownloading = true },
                                                        onProgress = { p -> scope.launch(Dispatchers.Main) { progress = p } }
                                                    )
                                                }
                                            }
                                            confirmDialog.showConfirm(title = confirmTitle, content = startText)
                                        }
                                    }
                                    val bottomPadding = if (index == rel.assets.lastIndex) 16.dp else 8.dp
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        verticalAlignment = Alignment.CenterVertically,
                                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                                    ) {
                                        Column(
                                            modifier = Modifier
                                                .padding(start = 16.dp, end = 16.dp, bottom = bottomPadding)
                                                .weight(1f)
                                        ) {
                                            Text(
                                                text = fileName,
                                                fontSize = 14.sp,
                                                color = colorScheme.onSurface
                                            )
                                            Text(
                                                text = sizeAndDownloads,
                                                fontSize = 12.sp,
                                                color = colorScheme.onSurfaceVariantSummary,
                                                modifier = Modifier.padding(top = 2.dp)
                                            )
                                        }
                                        IconButton(
                                            modifier = Modifier.padding(start = 16.dp, end = 16.dp, bottom = bottomPadding),
                                            backgroundColor = secondaryContainer,
                                            minHeight = 35.dp,
                                            minWidth = 35.dp,
                                            enabled = !isDownloading,
                                            onClick = onClickDownload,
                                        ) {
                                            if (isDownloading) {
                                                CircularProgressIndicator(
                                                    progress = progress / 100f,
                                                    size = 20.dp,
                                                    strokeWidth = 2.dp
                                                )
                                            } else {
                                                Row(
                                                    modifier = Modifier.padding(horizontal = 10.dp),
                                                    verticalAlignment = Alignment.CenterVertically,
                                                ) {
                                                    Icon(
                                                        modifier = Modifier.size(20.dp),
                                                        imageVector = MiuixIcons.FileDownloads,
                                                        tint = actionIconTint,
                                                        contentDescription = stringResource(R.string.install)
                                                    )
                                                    Text(
                                                        modifier = Modifier.padding(start = 4.dp, end = 2.dp),
                                                        text = stringResource(R.string.install),
                                                        color = actionIconTint,
                                                        fontWeight = FontWeight.Medium,
                                                        fontSize = 15.sp
                                                    )
                                                }
                                            }
                                        }
                                    }
                                    if (index != rel.assets.lastIndex) {
                                        HorizontalDivider(
                                            modifier = Modifier.padding(start = 16.dp, end = 16.dp, bottom = 8.dp),
                                            thickness = 0.5.dp,
                                            color = colorScheme.outline.copy(alpha = 0.5f)
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun InfoPage(
    module: RepoModuleArg,
    innerPadding: PaddingValues,
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    actionIconTint: Color,
    secondaryContainer: Color,
    uriHandler: UriHandler,
    sourceUrl: String,
) {
    val layoutDirection = LocalLayoutDirection.current
    LazyColumn(
        modifier = Modifier
            .fillMaxHeight()
            .scrollEndHaptic()
            .overScrollVertical()
            .nestedScroll(scrollBehavior.nestedScrollConnection)
            .hazeSource(state = hazeState),
        contentPadding = PaddingValues(
            top = innerPadding.calculateTopPadding(),
            start = innerPadding.calculateStartPadding(layoutDirection),
            end = innerPadding.calculateEndPadding(layoutDirection),
            bottom = innerPadding.calculateBottomPadding(),
        ),
        overscrollEffect = null,
    ) {
        if (module.authorsList.isNotEmpty()) {
            item {
                SmallTitle(
                    text = stringResource(R.string.module_author),
                    modifier = Modifier.padding(top = 6.dp)
                )
                Card(
                    modifier = Modifier
                        .padding(horizontal = 12.dp),
                    insideMargin = PaddingValues(16.dp)
                ) {
                    Column {
                        module.authorsList.forEachIndexed { index, author ->
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Text(
                                    text = author.name,
                                    fontSize = 14.sp,
                                    color = colorScheme.onSurface,
                                    modifier = Modifier.weight(1f)
                                )
                                val clickable = author.link.isNotEmpty()
                                val tint = if (clickable) actionIconTint else actionIconTint.copy(alpha = 0.35f)
                                IconButton(
                                    backgroundColor = secondaryContainer,
                                    minHeight = 35.dp,
                                    minWidth = 35.dp,
                                    enabled = clickable,
                                    onClick = {
                                        if (clickable) {
                                            uriHandler.openUri(author.link)
                                        }
                                    },
                                ) {
                                    Icon(
                                        modifier = Modifier.size(20.dp),
                                        imageVector = MiuixIcons.Link,
                                        tint = tint,
                                        contentDescription = null
                                    )
                                }
                            }
                            if (index != module.authorsList.lastIndex) {
                                HorizontalDivider(
                                    modifier = Modifier.padding(vertical = 8.dp),
                                    thickness = 0.5.dp,
                                    color = colorScheme.outline.copy(alpha = 0.5f)
                                )
                            }
                        }
                    }
                }
            }
        }
        if (sourceUrl.isNotEmpty()) {
            item {
                SmallTitle(
                    text = stringResource(R.string.module_repos_source_code),
                    modifier = Modifier.padding(top = 6.dp)
                )
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 12.dp)
                        .padding(bottom = 12.dp),
                    insideMargin = PaddingValues(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = sourceUrl,
                            fontSize = 16.sp,
                            color = colorScheme.onSurface,
                            modifier = Modifier.weight(1f),
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                        IconButton(
                            backgroundColor = secondaryContainer,
                            minHeight = 35.dp,
                            minWidth = 35.dp,
                            onClick = {
                                uriHandler.openUri(sourceUrl)
                            },
                        ) {
                            Icon(
                                modifier = Modifier.size(20.dp),
                                imageVector = MiuixIcons.Link,
                                tint = actionIconTint,
                                contentDescription = null
                            )
                        }
                    }
                }
            }
        }
        item { Spacer(Modifier.height(12.dp)) }
    }
}

@SuppressLint("StringFormatInvalid", "DefaultLocale")
@Composable
fun ModuleRepoDetailScreen(
    module: RepoModuleArg
) {
    val navigator = LocalNavigator.current
    val context = LocalContext.current
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    val isDark = isInDarkTheme(prefs.getInt("color_mode", 0))
    val actionIconTint = colorScheme.onSurface.copy(alpha = if (isDark) 0.7f else 0.9f)
    val secondaryContainer = colorScheme.secondaryContainer.copy(alpha = 0.8f)
    val uriHandler = LocalUriHandler.current
    val scope = rememberCoroutineScope()
    val confirmTitle = stringResource(R.string.module_install)
    var pendingDownload by remember { mutableStateOf<(() -> Unit)?>(null) }
    val confirmDialog = rememberConfirmDialog(onConfirm = { pendingDownload?.invoke() })
    val onInstallModule: (Uri) -> Unit = { uri ->
        navigator.push(Route.Flash(FlashIt.FlashModules(listOf(uri))))
    }

    var readmeHtml by remember(module.moduleId) { mutableStateOf<String?>(null) }
    var readmeLoaded by remember(module.moduleId) { mutableStateOf(false) }
    var detailReleases by remember(module.moduleId) { mutableStateOf<List<ReleaseArg>>(emptyList()) }
    var webUrl by remember(module.moduleId) { mutableStateOf("https://modules.kernelsu.org/module/${module.moduleId}") }
    var sourceUrl by remember(module.moduleId) { mutableStateOf("https://github.com/KernelSU-Modules-Repo/${module.moduleId}") }


    val scrollBehavior = MiuixScrollBehavior()

    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            TopAppBar(
                modifier = Modifier.hazeEffect(hazeState) {
                    style = hazeStyle
                    blurRadius = 30.dp
                    noiseFactor = 0f
                },
                color = Color.Transparent,
                title = module.moduleName,
                scrollBehavior = scrollBehavior,
                navigationIcon = {
                    IconButton(
                        modifier = Modifier.padding(start = 16.dp),
                        onClick = { navigator.pop() }
                    ) {
                        val layoutDirection = LocalLayoutDirection.current
                        Icon(
                            modifier = Modifier.graphicsLayer {
                                if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                            },
                            imageVector = MiuixIcons.Back,
                            contentDescription = null,
                            tint = colorScheme.onSurface
                        )
                    }
                },
                actions = {
                    if (webUrl.isNotEmpty()) {
                        IconButton(
                            modifier = Modifier.padding(end = 16.dp),
                            onClick = { uriHandler.openUri(webUrl) }
                        ) {
                            Icon(
                                imageVector = MiuixIcons.HorizontalSplit,
                                contentDescription = null,
                                tint = colorScheme.onBackground
                            )
                        }
                    }
                }
            )
        },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal),
    ) { innerPadding ->
        LaunchedEffect(module.moduleId) {
            if (module.moduleId.isNotEmpty()) {
                withContext(Dispatchers.IO) {
                    runCatching {
                        val detail = fetchModuleDetail(module.moduleId)
                        if (detail != null) {
                            readmeHtml = detail.readmeHtml
                            if (detail.sourceUrl.isNotEmpty()) sourceUrl = detail.sourceUrl
                            detailReleases = detail.releases.map { r ->
                                ReleaseArg(
                                    tagName = r.tagName,
                                    name = r.name,
                                    publishedAt = r.publishedAt,
                                    assets = r.assets.map { a -> ReleaseAssetArg(a.name, a.downloadUrl, a.size, a.downloadCount) },
                                    descriptionHTML = r.descriptionHTML
                                )
                            }
                        } else {
                            detailReleases = emptyList()
                        }
                    }.onSuccess {
                        readmeLoaded = true
                    }.onFailure {
                        readmeLoaded = true
                    }
                }
            } else {
                readmeLoaded = true
            }
        }
        val tabs = listOf(
            stringResource(R.string.tab_readme),
            stringResource(R.string.tab_releases),
            stringResource(R.string.tab_info)
        )
        val pagerState = rememberPagerState(initialPage = 0, pageCount = { tabs.size })
        LocalDensity.current
        val tabRowHeight by remember { mutableStateOf(40.dp) }
        var collapsedFraction by remember { mutableFloatStateOf(scrollBehavior.state.collapsedFraction) }
        LaunchedEffect(scrollBehavior.state.collapsedFraction) {
            snapshotFlow { scrollBehavior.state.collapsedFraction }.collectLatest { collapsedFraction = it }
        }
        val dynamicTopPadding by remember { derivedStateOf { 12.dp * (1f - collapsedFraction) } }
        val layoutDirection = LocalLayoutDirection.current
        val coroutineScope = rememberCoroutineScope()
        Box(
            modifier = Modifier.fillMaxSize()
        ) {
            Column(
                modifier = Modifier
                    .hazeEffect(hazeState) {
                        style = hazeStyle
                        blurRadius = 30.dp
                        noiseFactor = 0f
                    }
                    .zIndex(1f)
                    .padding(
                        top = innerPadding.calculateTopPadding() + dynamicTopPadding,
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection),
                        bottom = 6.dp
                    )
                    .padding(horizontal = 12.dp)
            ) {
                TabRow(
                    tabs = tabs,
                    selectedTabIndex = pagerState.currentPage,
                    onTabSelected = { index ->
                        coroutineScope.launch {
                            pagerState.animateScrollToPage(page = index, animationSpec = tween(easing = EaseInOut))
                        }
                    },
                    colors = TabRowDefaults.tabRowColors(backgroundColor = Color.Transparent),
                    height = tabRowHeight,
                )
            }
            HorizontalPager(
                state = pagerState,
                modifier = Modifier.fillMaxSize(),
                beyondViewportPageCount = 2,
            ) { page ->
                run {
                    val navEventState = rememberNavigationEventState(NavigationEventInfo.None)
                    NavigationBackHandler(
                        state = navEventState,
                        isBackEnabled = pagerState.currentPage != 0,
                        onBackCompleted = {
                            scope.launch { pagerState.animateScrollToPage(0) }
                        }
                    )
                }
                val innerPadding = PaddingValues(
                    top = innerPadding.calculateTopPadding() + tabRowHeight + dynamicTopPadding + 6.dp,
                    start = innerPadding.calculateStartPadding(layoutDirection),
                    end = innerPadding.calculateEndPadding(layoutDirection),
                    bottom = innerPadding.calculateBottomPadding() + WindowInsets.systemBars.asPaddingValues().calculateBottomPadding()
                )

                when (page) {
                    0 -> ReadmePage(
                        readmeHtml = readmeHtml,
                        readmeLoaded = readmeLoaded,
                        innerPadding = innerPadding,
                        scrollBehavior = scrollBehavior,
                        hazeState = hazeState
                    )

                    1 -> ReleasesPage(
                        detailReleases = detailReleases,
                        innerPadding = innerPadding,
                        scrollBehavior = scrollBehavior,
                        hazeState = hazeState,
                        actionIconTint = actionIconTint,
                        secondaryContainer = secondaryContainer,
                        confirmTitle = confirmTitle,
                        confirmDialog = confirmDialog,
                        scope = scope,
                        onInstallModule = onInstallModule,
                        context = context,
                        setPendingDownload = { pendingDownload = it }
                    )

                    2 -> InfoPage(
                        module = module,
                        innerPadding = innerPadding,
                        scrollBehavior = scrollBehavior,
                        hazeState = hazeState,
                        actionIconTint = actionIconTint,
                        secondaryContainer = secondaryContainer,
                        uriHandler = uriHandler,
                        sourceUrl = sourceUrl,
                    )
                }
            }
        }
        DownloadListener(context, onInstallModule)
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Settings.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.content.Context
import android.os.Build
import androidx.activity.compose.LocalActivity
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.Adb
import androidx.compose.material.icons.rounded.AspectRatio
import androidx.compose.material.icons.rounded.BugReport
import androidx.compose.material.icons.rounded.Colorize
import androidx.compose.material.icons.rounded.ContactPage
import androidx.compose.material.icons.rounded.Delete
import androidx.compose.material.icons.rounded.DeleteForever
import androidx.compose.material.icons.rounded.DeveloperMode
import androidx.compose.material.icons.rounded.Fence
import androidx.compose.material.icons.rounded.FolderDelete
import androidx.compose.material.icons.rounded.Palette
import androidx.compose.material.icons.rounded.RemoveCircle
import androidx.compose.material.icons.rounded.RemoveModerator
import androidx.compose.material.icons.rounded.RestartAlt
import androidx.compose.material.icons.rounded.Update
import androidx.compose.material.icons.rounded.UploadFile
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.core.content.edit
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import me.weishu.kernelsu.KernelSUApplication
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.KsuIsValid
import me.weishu.kernelsu.ui.component.ScaleDialog
import me.weishu.kernelsu.ui.component.SendLogDialog
import me.weishu.kernelsu.ui.component.UninstallDialog
import me.weishu.kernelsu.ui.component.rememberLoadingDialog
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.util.execKsud
import me.weishu.kernelsu.ui.util.getFeaturePersistValue
import me.weishu.kernelsu.ui.util.getFeatureStatus
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.Slider
import top.yukonga.miuix.kmp.basic.SliderDefaults
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.extra.SuperArrow
import top.yukonga.miuix.kmp.extra.SuperDropdown
import top.yukonga.miuix.kmp.extra.SuperSwitch
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

/**
 * @author weishu
 * @date 2023/1/1.
 */
@Composable
fun SettingPager(
    navigator: Navigator,
    bottomInnerPadding: Dp
) {
    val scrollBehavior = MiuixScrollBehavior()
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            TopAppBar(
                modifier = Modifier.hazeEffect(hazeState) {
                    style = hazeStyle
                    blurRadius = 30.dp
                    noiseFactor = 0f
                },
                color = Color.Transparent,
                title = stringResource(R.string.settings),
                scrollBehavior = scrollBehavior
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        val context = LocalContext.current
        val activity = LocalActivity.current
        val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)

        val loadingDialog = rememberLoadingDialog()
        val showScaleDialog = rememberSaveable { mutableStateOf(false) }
        val showUninstallDialog = rememberSaveable { mutableStateOf(false) }
        val showSendLogDialog = rememberSaveable { mutableStateOf(false) }

        LazyColumn(
            modifier = Modifier
                .fillMaxHeight()
                .scrollEndHaptic()
                .overScrollVertical()
                .nestedScroll(scrollBehavior.nestedScrollConnection)
                .hazeSource(state = hazeState)
                .padding(horizontal = 12.dp),
            contentPadding = innerPadding,
            overscrollEffect = null,
        ) {
            item {
                var checkUpdate by rememberSaveable {
                    mutableStateOf(prefs.getBoolean("check_update", true))
                }

                Card(
                    modifier = Modifier
                        .padding(top = 12.dp)
                        .fillMaxWidth(),
                ) {
                    SuperSwitch(
                        title = stringResource(id = R.string.settings_check_update),
                        summary = stringResource(id = R.string.settings_check_update_summary),
                        startAction = {
                            Icon(
                                Icons.Rounded.Update,
                                modifier = Modifier.padding(end = 6.dp),
                                contentDescription = stringResource(id = R.string.settings_check_update),
                                tint = colorScheme.onBackground
                            )
                        },
                        checked = checkUpdate,
                        onCheckedChange = {
                            prefs.edit {
                                putBoolean("check_update", it)
                            }
                            checkUpdate = it
                        }
                    )
                    KsuIsValid {
                        var checkModuleUpdate by rememberSaveable {
                            mutableStateOf(prefs.getBoolean("module_check_update", true))
                        }
                        SuperSwitch(
                            title = stringResource(id = R.string.settings_module_check_update),
                            summary = stringResource(id = R.string.settings_check_update_summary),
                            startAction = {
                                Icon(
                                    Icons.Rounded.UploadFile,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.settings_check_update),
                                    tint = colorScheme.onBackground
                                )
                            },
                            checked = checkModuleUpdate,
                            onCheckedChange = {
                                prefs.edit {
                                    putBoolean("module_check_update", it)
                                }
                                checkModuleUpdate = it
                            }
                        )
                    }
                }

                Card(
                    modifier = Modifier
                        .padding(top = 12.dp)
                        .fillMaxWidth(),
                ) {
                    val themeItems = listOf(
                        stringResource(id = R.string.settings_theme_mode_system),
                        stringResource(id = R.string.settings_theme_mode_light),
                        stringResource(id = R.string.settings_theme_mode_dark),
                        stringResource(id = R.string.settings_theme_mode_monet_system),
                        stringResource(id = R.string.settings_theme_mode_monet_light),
                        stringResource(id = R.string.settings_theme_mode_monet_dark),
                    )
                    var themeMode by rememberSaveable {
                        mutableIntStateOf(prefs.getInt("color_mode", 0))
                    }
                    SuperDropdown(
                        title = stringResource(id = R.string.settings_theme),
                        summary = stringResource(id = R.string.settings_theme_summary),
                        items = themeItems,
                        startAction = {
                            Icon(
                                Icons.Rounded.Palette,
                                modifier = Modifier.padding(end = 6.dp),
                                contentDescription = stringResource(id = R.string.settings_theme),
                                tint = colorScheme.onBackground
                            )
                        },
                        selectedIndex = themeMode,
                        onSelectedIndexChange = { index ->
                            prefs.edit { putInt("color_mode", index) }
                            themeMode = index
                        }
                    )

                    AnimatedVisibility(
                        visible = themeMode in 3..5
                    ) {
                        val colorItems = listOf(
                            stringResource(id = R.string.settings_key_color_default),
                            stringResource(id = R.string.color_red),
                            stringResource(id = R.string.color_pink),
                            stringResource(id = R.string.color_purple),
                            stringResource(id = R.string.color_deep_purple),
                            stringResource(id = R.string.color_indigo),
                            stringResource(id = R.string.color_blue),
                            stringResource(id = R.string.color_cyan),
                            stringResource(id = R.string.color_teal),
                            stringResource(id = R.string.color_green),
                            stringResource(id = R.string.color_yellow),
                            stringResource(id = R.string.color_amber),
                            stringResource(id = R.string.color_orange),
                            stringResource(id = R.string.color_brown),
                            stringResource(id = R.string.color_blue_grey),
                            stringResource(id = R.string.color_sakura),
                        )
                        val colorValues = listOf(
                            0,
                            Color(0xFFF44336).toArgb(),
                            Color(0xFFE91E63).toArgb(),
                            Color(0xFF9C27B0).toArgb(),
                            Color(0xFF673AB7).toArgb(),
                            Color(0xFF3F51B5).toArgb(),
                            Color(0xFF2196F3).toArgb(),
                            Color(0xFF00BCD4).toArgb(),
                            Color(0xFF009688).toArgb(),
                            Color(0xFF4FAF50).toArgb(),
                            Color(0xFFFFEB3B).toArgb(),
                            Color(0xFFFFC107).toArgb(),
                            Color(0xFFFF9800).toArgb(),
                            Color(0xFF795548).toArgb(),
                            Color(0xFF607D8F).toArgb(),
                            Color(0xFFFF9CA8).toArgb(),
                        )
                        var keyColorIndex by rememberSaveable {
                            mutableIntStateOf(
                                colorValues.indexOf(prefs.getInt("key_color", 0)).takeIf { it >= 0 } ?: 0
                            )
                        }
                        SuperDropdown(
                            title = stringResource(id = R.string.settings_key_color),
                            summary = stringResource(id = R.string.settings_key_color_summary),
                            items = colorItems,
                            startAction = {
                                Icon(
                                    Icons.Rounded.Colorize,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.settings_key_color),
                                    tint = colorScheme.onBackground
                                )
                            },
                            selectedIndex = keyColorIndex,
                            onSelectedIndexChange = { index ->
                                prefs.edit { putInt("key_color", colorValues[index]) }
                                keyColorIndex = index
                            }
                        )
                    }

                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                        var enablePredictiveBack by rememberSaveable {
                            mutableStateOf(prefs.getBoolean("enable_predictive_back", false))
                        }
                        SuperSwitch(
                            title = stringResource(id = R.string.settings_enable_predictive_back),
                            summary = stringResource(id = R.string.settings_enable_predictive_back_summary),
                            startAction = {
                                Icon(
                                    Icons.Rounded.Adb,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.settings_enable_predictive_back),
                                    tint = colorScheme.onBackground
                                )
                            },
                            checked = enablePredictiveBack,
                            onCheckedChange = {
                                prefs.edit { putBoolean("enable_predictive_back", it) }
                                enablePredictiveBack = it
                                KernelSUApplication.setEnableOnBackInvokedCallback(context.applicationInfo, it)
                                activity?.recreate()
                            }
                        )
                    }
                    var pageScale by rememberSaveable {
                        mutableFloatStateOf(prefs.getFloat("page_scale", 1.0f))
                    }
                    SuperArrow(
                        title = stringResource(id = R.string.settings_page_scale),
                        summary = stringResource(id = R.string.settings_page_scale_summary),
                        startAction = {
                            Icon(
                                Icons.Rounded.AspectRatio,
                                modifier = Modifier.padding(end = 6.dp),
                                contentDescription = stringResource(id = R.string.settings_page_scale),
                                tint = colorScheme.onBackground
                            )
                        },
                        endActions = {
                            Text(
                                text = "${(pageScale * 100).toInt()}%",
                                color = colorScheme.onSurfaceVariantActions,
                            )
                        },
                        onClick = { showScaleDialog.value = !showScaleDialog.value },
                        holdDownState = showScaleDialog.value,
                        bottomAction = {
                            Slider(
                                value = pageScale,
                                onValueChange = {
                                    pageScale = it
                                },
                                onValueChangeFinished = {
                                    prefs.edit { putFloat("page_scale", pageScale) }
                                },
                                valueRange = 0.8f..1.1f,
                                showKeyPoints = true,
                                keyPoints = listOf(0.8f, 0.9f, 1f, 1.1f),
                                magnetThreshold = 0.01f,
                                hapticEffect = SliderDefaults.SliderHapticEffect.Step,
                            )
                        },
                    )
                    ScaleDialog(
                        showScaleDialog,
                        volumeState = { pageScale },
                        onVolumeChange = {
                            pageScale = it
                            prefs.edit { putFloat("page_scale", it) }
                        }
                    )
                }

                KsuIsValid {
                    Card(
                        modifier = Modifier
                            .padding(top = 12.dp)
                            .fillMaxWidth(),
                    ) {
                        val profileTemplate = stringResource(id = R.string.settings_profile_template)
                        SuperArrow(
                            title = profileTemplate,
                            summary = stringResource(id = R.string.settings_profile_template_summary),
                            startAction = {
                                Icon(
                                    Icons.Rounded.Fence,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = profileTemplate,
                                    tint = colorScheme.onBackground
                                )
                            },
                            onClick = {
                                navigator.push(Route.AppProfileTemplate)
                            }
                        )
                    }
                }

                KsuIsValid {
                    Card(
                        modifier = Modifier
                            .padding(top = 12.dp)
                            .fillMaxWidth(),
                    ) {
                        val suCompatModeItems = listOf(
                            stringResource(id = R.string.settings_mode_enable_by_default),
                            stringResource(id = R.string.settings_mode_disable_until_reboot),
                            stringResource(id = R.string.settings_mode_disable_always),
                        )

                        val currentSuEnabled = Natives.isSuEnabled()
                        var suCompatMode by rememberSaveable { mutableIntStateOf(if (!currentSuEnabled) 1 else 0) }
                        val suPersistValue by produceState(initialValue = null as Long?) {
                            value = getFeaturePersistValue("su_compat")
                        }
                        LaunchedEffect(suPersistValue) {
                            suPersistValue?.let { v ->
                                suCompatMode = if (v == 0L) 2 else if (!currentSuEnabled) 1 else 0
                            }
                        }
                        val suStatus by produceState(initialValue = "") {
                            value = getFeatureStatus("su_compat")
                        }
                        val suSummary = when (suStatus) {
                            "unsupported" -> stringResource(id = R.string.feature_status_unsupported_summary)
                            "managed" -> stringResource(id = R.string.feature_status_managed_summary)
                            else -> stringResource(id = R.string.settings_sucompat_summary)
                        }
                        SuperDropdown(
                            title = stringResource(id = R.string.settings_sucompat),
                            summary = suSummary,
                            items = suCompatModeItems,
                            startAction = {
                                Icon(
                                    Icons.Rounded.RemoveModerator,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.settings_sucompat),
                                    tint = colorScheme.onBackground
                                )
                            },
                            enabled = suStatus == "supported",
                            selectedIndex = suCompatMode,
                            onSelectedIndexChange = { index ->
                                when (index) {
                                    // Default: enable and save to persist
                                    0 -> if (Natives.setSuEnabled(true)) {
                                        execKsud("feature save", true)
                                        prefs.edit { putInt("su_compat_mode", 0) }
                                        suCompatMode = 0
                                    }

                                    // Temporarily disable: save enabled state first, then disable
                                    1 -> if (Natives.setSuEnabled(true)) {
                                        execKsud("feature save", true)
                                        if (Natives.setSuEnabled(false)) {
                                            prefs.edit { putInt("su_compat_mode", 0) }
                                            suCompatMode = 1
                                        }
                                    }

                                    // Permanently disable: disable and save
                                    2 -> if (Natives.setSuEnabled(false)) {
                                        execKsud("feature save", true)
                                        prefs.edit { putInt("su_compat_mode", 2) }
                                        suCompatMode = 2
                                    }
                                }
                            }
                        )

                        var isKernelUmountEnabled by rememberSaveable { mutableStateOf(Natives.isKernelUmountEnabled()) }
                        val umountStatus by produceState(initialValue = "") {
                            value = getFeatureStatus("kernel_umount")
                        }
                        val umountSummary = when (umountStatus) {
                            "unsupported" -> stringResource(id = R.string.feature_status_unsupported_summary)
                            "managed" -> stringResource(id = R.string.feature_status_managed_summary)
                            else -> stringResource(id = R.string.settings_kernel_umount_summary)
                        }
                        SuperSwitch(
                            title = stringResource(id = R.string.settings_kernel_umount),
                            summary = umountSummary,
                            startAction = {
                                Icon(
                                    Icons.Rounded.RemoveCircle,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.settings_kernel_umount),
                                    tint = colorScheme.onBackground
                                )
                            },
                            enabled = umountStatus == "supported",
                            checked = isKernelUmountEnabled,
                            onCheckedChange = { checked ->
                                if (Natives.setKernelUmountEnabled(checked)) {
                                    execKsud("feature save", true)
                                    isKernelUmountEnabled = checked
                                }
                            }
                        )

                        var umountChecked by rememberSaveable { mutableStateOf(Natives.isDefaultUmountModules()) }
                        SuperSwitch(
                            title = stringResource(id = R.string.settings_umount_modules_default),
                            summary = stringResource(id = R.string.settings_umount_modules_default_summary),
                            startAction = {
                                Icon(
                                    Icons.Rounded.FolderDelete,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.settings_umount_modules_default),
                                    tint = colorScheme.onBackground
                                )
                            },
                            checked = umountChecked,
                            onCheckedChange = {
                                if (Natives.setDefaultUmountModules(it)) {
                                    umountChecked = it
                                }
                            }
                        )

                        var enableWebDebugging by rememberSaveable {
                            mutableStateOf(prefs.getBoolean("enable_web_debugging", false))
                        }
                        SuperSwitch(
                            title = stringResource(id = R.string.enable_web_debugging),
                            summary = stringResource(id = R.string.enable_web_debugging_summary),
                            startAction = {
                                Icon(
                                    Icons.Rounded.DeveloperMode,
                                    modifier = Modifier.padding(end = 6.dp),
                                    contentDescription = stringResource(id = R.string.enable_web_debugging),
                                    tint = colorScheme.onBackground
                                )
                            },
                            checked = enableWebDebugging,
                            onCheckedChange = {
                                prefs.edit { putBoolean("enable_web_debugging", it) }
                                enableWebDebugging = it
                            }
                        )
                    }
                }

                KsuIsValid {
                    Card(
                        modifier = Modifier
                            .padding(top = 12.dp)
                            .fillMaxWidth(),
                    ) {
                        val lkmMode = Natives.isLkmMode
                        if (lkmMode) {
                            val uninstall = stringResource(id = R.string.settings_uninstall)
                            SuperArrow(
                                title = uninstall,
                                startAction = {
                                    Icon(
                                        Icons.Rounded.Delete,
                                        modifier = Modifier.padding(end = 6.dp),
                                        contentDescription = uninstall,
                                        tint = colorScheme.onBackground,
                                    )
                                },
                                onClick = {
                                    showUninstallDialog.value = true
                                }
                            )
                            UninstallDialog(showUninstallDialog, navigator)
                        }
                    }
                }

                Card(
                    modifier = Modifier
                        .padding(vertical = 12.dp)
                        .fillMaxWidth(),
                ) {
                    SuperArrow(
                        title = stringResource(id = R.string.send_log),
                        startAction = {
                            Icon(
                                Icons.Rounded.BugReport,
                                modifier = Modifier.padding(end = 6.dp),
                                contentDescription = stringResource(id = R.string.send_log),
                                tint = colorScheme.onBackground
                            )
                        },
                        onClick = {
                            showSendLogDialog.value = true
                        },
                    )
                    SendLogDialog(showSendLogDialog, loadingDialog)
                    val about = stringResource(id = R.string.about)
                    SuperArrow(
                        title = about,
                        startAction = {
                            Icon(
                                Icons.Rounded.ContactPage,
                                modifier = Modifier.padding(end = 6.dp),
                                contentDescription = about,
                                tint = colorScheme.onBackground
                            )
                        },
                        onClick = {
                            navigator.push(Route.About)
                        }
                    )
                }
                Spacer(Modifier.height(bottomInnerPadding))
            }
        }
    }
}

enum class UninstallType(val icon: ImageVector, val title: Int, val message: Int) {
    TEMPORARY(
        Icons.Rounded.RemoveModerator,
        R.string.settings_uninstall_temporary,
        R.string.settings_uninstall_temporary_message
    ),
    PERMANENT(
        Icons.Rounded.DeleteForever,
        R.string.settings_uninstall_permanent,
        R.string.settings_uninstall_permanent_message
    ),
    RESTORE_STOCK_IMAGE(
        Icons.Rounded.RestartAlt,
        R.string.settings_restore_stock_image,
        R.string.settings_restore_stock_image_message
    ),
    NONE(Icons.Rounded.Adb, 0, 0)
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/SuperUser.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.content.Context
import android.content.pm.ApplicationInfo
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.basicMarquee
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateEndPadding
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.ime
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.runtime.Composable
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.edit
import androidx.lifecycle.viewmodel.compose.viewModel
import com.kyant.capsule.ContinuousRoundedRectangle
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.component.AppIconImage
import me.weishu.kernelsu.ui.component.SearchBox
import me.weishu.kernelsu.ui.component.SearchPager
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.theme.isInDarkTheme
import me.weishu.kernelsu.ui.util.ownerNameForUid
import me.weishu.kernelsu.ui.util.pickPrimary
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel
import top.yukonga.miuix.kmp.basic.BasicComponent
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.DropdownImpl
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.InfiniteProgressIndicator
import top.yukonga.miuix.kmp.basic.ListPopupColumn
import top.yukonga.miuix.kmp.basic.ListPopupDefaults
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.PopupPositionProvider
import top.yukonga.miuix.kmp.basic.PullToRefresh
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.basic.rememberPullToRefreshState
import top.yukonga.miuix.kmp.extra.SuperListPopup
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.basic.ArrowRight
import top.yukonga.miuix.kmp.icon.extended.MoreCircle
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.PressFeedbackType
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

@Composable
fun SuperUserPager(
    navigator: Navigator,
    bottomInnerPadding: Dp
) {
    val viewModel = viewModel<SuperUserViewModel>()
    val scope = rememberCoroutineScope()
    val searchStatus by viewModel.searchStatus

    val context = LocalContext.current
    var isInitialized by rememberSaveable { mutableStateOf(false) }
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)

    LaunchedEffect(Unit) {
        when {
            !isInitialized || viewModel.appList.value.isEmpty() -> {
                viewModel.showSystemApps = prefs.getBoolean("show_system_apps", false)
                viewModel.loadAppList()
                isInitialized = true
            }

            viewModel.isNeedRefresh -> {
                viewModel.loadAppList()
            }
        }
    }

    LaunchedEffect(searchStatus.searchText) {
        viewModel.updateSearchText(searchStatus.searchText)
    }

    val scrollBehavior = MiuixScrollBehavior()
    val dynamicTopPadding by remember {
        derivedStateOf { 12.dp * (1f - scrollBehavior.state.collapsedFraction) }
    }
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            searchStatus.TopAppBarAnim(hazeState = hazeState, hazeStyle = hazeStyle) {
                TopAppBar(
                    color = Color.Transparent,
                    title = stringResource(R.string.superuser),
                    actions = {
                        val showTopPopup = remember { mutableStateOf(false) }
                        SuperListPopup(
                            show = showTopPopup,
                            popupPositionProvider = ListPopupDefaults.ContextMenuPositionProvider,
                            alignment = PopupPositionProvider.Align.TopEnd,
                            onDismissRequest = {
                                showTopPopup.value = false
                            }
                        ) {
                            ListPopupColumn {
                                DropdownImpl(
                                    text = stringResource(R.string.show_system_apps),
                                    isSelected = viewModel.showSystemApps,
                                    optionSize = 1,
                                    onSelectedIndexChange = {
                                        viewModel.showSystemApps = !viewModel.showSystemApps
                                        prefs.edit {
                                            putBoolean("show_system_apps", viewModel.showSystemApps)
                                        }
                                        scope.launch {
                                            viewModel.loadAppList()
                                        }
                                        showTopPopup.value = false
                                    },
                                    index = 0
                                )
                            }
                        }
                        IconButton(
                            modifier = Modifier.padding(end = 16.dp),
                            onClick = {
                                showTopPopup.value = true
                            },
                            holdDownState = showTopPopup.value
                        ) {
                            Icon(
                                imageVector = MiuixIcons.MoreCircle,
                                tint = colorScheme.onSurface,
                                contentDescription = null
                            )
                        }
                    },
                    scrollBehavior = scrollBehavior
                )
            }
        },
        popupHost = {
            val filteredApps = remember(viewModel.appList.value) {
                viewModel.appList.value.filter { it.packageName != ksuApp.packageName }
            }
            val allGroups = remember(filteredApps) { buildGroups(filteredApps) }
            val matchedByUid = remember(viewModel.searchResults.value) {
                viewModel.searchResults.value.groupBy { it.uid }
            }
            val searchGroups = remember(allGroups, matchedByUid) {
                allGroups.filter { matchedByUid.containsKey(it.uid) }
            }
            val expandedSearchUids = remember { mutableStateOf(setOf<Int>()) }
            LaunchedEffect(matchedByUid) {
                expandedSearchUids.value = searchGroups
                    .filter { it.apps.size > 1 }
                    .map { it.uid }
                    .toSet()
            }
            searchStatus.SearchPager(
                defaultResult = {},
                searchBarTopPadding = dynamicTopPadding,
            ) {
                item {
                    Spacer(Modifier.height(6.dp))
                }
                items(searchGroups, key = { it.uid }) { group ->
                    val expanded = expandedSearchUids.value.contains(group.uid)
                    AnimatedVisibility(
                        visible = searchGroups.isNotEmpty(),
                        enter = fadeIn() + expandVertically(),
                        exit = fadeOut() + shrinkVertically()
                    ) {
                        Column {
                            GroupItem(
                                group = group,
                                onToggleExpand = {
                                    if (group.apps.size > 1) {
                                        expandedSearchUids.value =
                                            if (expanded) expandedSearchUids.value - group.uid else expandedSearchUids.value + group.uid
                                    }
                                },
                            ) {
                                navigator.push(Route.AppProfile(group.primary.packageName))
                                viewModel.markNeedRefresh()
                            }
                            AnimatedVisibility(
                                visible = expanded && group.apps.size > 1,
                                enter = expandVertically() + fadeIn(),
                                exit = shrinkVertically() + fadeOut()
                            ) {
                                Column {
                                    val matchedApps = matchedByUid[group.uid] ?: emptyList()
                                    matchedApps.forEach { app -> SimpleAppItem(app) }
                                    Spacer(Modifier.height(6.dp))
                                }
                            }
                        }
                    }
                }
                item {
                    val imeBottomPadding = WindowInsets.ime.asPaddingValues().calculateBottomPadding()
                    Spacer(Modifier.height(maxOf(bottomInnerPadding, imeBottomPadding)))
                }
            }
        },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        val layoutDirection = LocalLayoutDirection.current
        searchStatus.SearchBox(
            searchBarTopPadding = dynamicTopPadding,
            contentPadding = PaddingValues(
                top = innerPadding.calculateTopPadding(),
                start = innerPadding.calculateStartPadding(layoutDirection),
                end = innerPadding.calculateEndPadding(layoutDirection)
            ),
            hazeState = hazeState,
            hazeStyle = hazeStyle
        ) { boxHeight ->
            var isRefreshing by rememberSaveable { mutableStateOf(false) }
            val pullToRefreshState = rememberPullToRefreshState()
            LaunchedEffect(isRefreshing) {
                if (isRefreshing) {
                    delay(150)
                    viewModel.loadAppList(force = true)
                    isRefreshing = false
                }
            }
            val refreshTexts = listOf(
                stringResource(R.string.refresh_pulling),
                stringResource(R.string.refresh_release),
                stringResource(R.string.refresh_refresh),
                stringResource(R.string.refresh_complete),
            )
            if (viewModel.appList.value.isEmpty()) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(
                            top = innerPadding.calculateTopPadding(),
                            start = innerPadding.calculateStartPadding(layoutDirection),
                            end = innerPadding.calculateEndPadding(layoutDirection),
                            bottom = bottomInnerPadding
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    InfiniteProgressIndicator()
                }
            } else {
                val filteredApps = remember(SuperUserViewModel.apps) {
                    SuperUserViewModel.apps.filter { it.packageName != ksuApp.packageName }
                }
                val allGroups = remember(filteredApps) { buildGroups(filteredApps) }
                val visibleUidSet = remember(viewModel.appList.value) { viewModel.appList.value.map { it.uid }.toSet() }
                val expandedUids = remember { mutableStateOf(setOf<Int>()) }
                PullToRefresh(
                    isRefreshing = isRefreshing,
                    pullToRefreshState = pullToRefreshState,
                    onRefresh = { isRefreshing = true },
                    refreshTexts = refreshTexts,
                    contentPadding = PaddingValues(
                        top = innerPadding.calculateTopPadding() + boxHeight.value + 6.dp,
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection)
                    ),
                ) {
                    LazyColumn(
                        modifier = Modifier
                            .fillMaxHeight()
                            .scrollEndHaptic()
                            .overScrollVertical()
                            .nestedScroll(scrollBehavior.nestedScrollConnection)
                            .hazeSource(state = hazeState),
                        contentPadding = PaddingValues(
                            top = innerPadding.calculateTopPadding() + boxHeight.value + 6.dp,
                            start = innerPadding.calculateStartPadding(layoutDirection),
                            end = innerPadding.calculateEndPadding(layoutDirection)
                        ),
                        overscrollEffect = null,
                    ) {
                        items(allGroups, key = { it.uid }) { group ->
                            val expanded = expandedUids.value.contains(group.uid)
                            val isVisible = visibleUidSet.contains(group.uid)
                            AnimatedVisibility(
                                visible = isVisible,
                                enter = expandVertically() + fadeIn(),
                                exit = shrinkVertically() + fadeOut()
                            ) {
                                Column {
                                    GroupItem(
                                        group = group,
                                        onToggleExpand = {
                                            if (group.apps.size > 1) {
                                                expandedUids.value =
                                                    if (expanded) expandedUids.value - group.uid else expandedUids.value + group.uid
                                            }
                                        }
                                    ) {
                                        navigator.push(Route.AppProfile(group.primary.packageName))
                                        viewModel.markNeedRefresh()
                                    }
                                    AnimatedVisibility(
                                        visible = expanded && group.apps.size > 1,
                                        enter = expandVertically() + fadeIn(),
                                        exit = shrinkVertically() + fadeOut()
                                    ) {
                                        Column {
                                            group.apps.forEach { app ->
                                                SimpleAppItem(app)
                                            }
                                            Spacer(Modifier.height(6.dp))
                                        }
                                    }
                                }
                            }
                        }
                        item {
                            Spacer(Modifier.height(bottomInnerPadding))
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun SimpleAppItem(
    app: SuperUserViewModel.AppInfo,
) {
    Row {
        Box(
            modifier = Modifier
                .padding(start = 12.dp)
                .width(6.dp)
                .height(24.dp)
                .align(Alignment.CenterVertically)
                .clip(ContinuousRoundedRectangle(16.dp))
                .background(colorScheme.primaryContainer)
        )
        Card(
            modifier = Modifier
                .padding(start = 6.dp, end = 12.dp, bottom = 6.dp)
        ) {
            BasicComponent(
                title = app.label,
                summary = app.packageName,
                startAction = {
                    AppIconImage(
                        packageInfo = app.packageInfo,
                        label = app.label,
                        modifier = Modifier
                            .padding(end = 9.dp)
                            .size(40.dp)
                    )
                },
                insideMargin = PaddingValues(horizontal = 9.dp)
            )
        }
    }
}

@Immutable
private data class GroupedApps(
    val uid: Int,
    val apps: List<SuperUserViewModel.AppInfo>,
    val primary: SuperUserViewModel.AppInfo,
    val anyAllowSu: Boolean,
    val anyCustom: Boolean,
    val shouldUmount: Boolean,
)

private val uidShouldUmountCache = mutableMapOf<Int, Boolean>()

private fun uidShouldUmountCached(uid: Int): Boolean {
    uidShouldUmountCache[uid]?.let { return it }
    val value = Natives.uidShouldUmount(uid)
    uidShouldUmountCache[uid] = value
    return value
}

private fun buildGroups(apps: List<SuperUserViewModel.AppInfo>): List<GroupedApps> {
    val comparator = compareBy<SuperUserViewModel.AppInfo> {
        when {
            it.allowSu -> 0
            it.hasCustomProfile -> 1
            else -> 2
        }
    }.thenBy { it.label.lowercase() }
    val groups = apps.groupBy { it.uid }.map { (uid, list) ->
        val sorted = list.sortedWith(comparator)
        val primary = pickPrimary(sorted)
        val shouldUmount = uidShouldUmountCached(uid)
        GroupedApps(
            uid = uid,
            apps = sorted,
            primary = primary,
            anyAllowSu = sorted.any { it.allowSu },
            anyCustom = sorted.any { it.hasCustomProfile },
            shouldUmount = shouldUmount,
        )
    }
    return groups.sortedWith(Comparator { a, b ->
        fun rank(g: GroupedApps): Int = when {
            g.anyAllowSu -> 0
            g.anyCustom -> 1
            g.apps.size > 1 -> 2
            g.shouldUmount -> 4
            else -> 3
        }

        val ra = rank(a)
        val rb = rank(b)
        if (ra != rb) return@Comparator ra - rb
        return@Comparator when (ra) {
            2 -> a.uid.compareTo(b.uid)
            else -> a.primary.label.lowercase().compareTo(b.primary.label.lowercase())
        }
    })
}

@Composable
private fun GroupItem(
    group: GroupedApps,
    onToggleExpand: () -> Unit,
    onClickPrimary: () -> Unit,
) {
    val context = LocalContext.current
    val prefs = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    val isDark = isInDarkTheme(prefs.getInt("color_mode", 0))
    val bg = colorScheme.secondaryContainer.copy(alpha = 0.8f)
    val rootBg = colorScheme.tertiaryContainer.copy(alpha = 0.6f)
    val unmountBg = if (isDark) Color.White.copy(alpha = 0.4f) else Color.Black.copy(alpha = 0.3f)
    val fg = colorScheme.onSecondaryContainer
    val rootFg = colorScheme.onTertiaryContainer.copy(alpha = 0.8f)
    val unmountFg = if (isDark) Color.Black.copy(alpha = 0.4f) else Color.White.copy(alpha = 0.8f)

    val userId = group.uid / 100000
    val packageInfo = group.primary.packageInfo
    val applicationInfo = packageInfo.applicationInfo
    val hasSharedUserId = !packageInfo.sharedUserId.isNullOrEmpty()
    val isSystemApp = applicationInfo?.flags?.and(ApplicationInfo.FLAG_SYSTEM) != 0
            || applicationInfo.flags.and(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0
    val tags = buildList {
        if (group.anyAllowSu) add(StatusMeta("ROOT", rootBg, rootFg))
        if (group.shouldUmount) add(StatusMeta("UMOUNT", unmountBg, unmountFg))
        if (group.anyCustom) add(StatusMeta("CUSTOM", bg, fg))
        if (userId != 0) add(StatusMeta("USER $userId", bg, fg))
        if (isSystemApp) add(StatusMeta("SYSTEM", bg, fg))
        if (hasSharedUserId) add(StatusMeta("SHARED UID", bg, fg))
    }
    Card(
        modifier = Modifier
            .padding(horizontal = 12.dp)
            .padding(bottom = 12.dp),
        onClick = onClickPrimary,
        onLongPress = if (group.apps.size > 1) onToggleExpand else null,
        pressFeedbackType = PressFeedbackType.Sink,
        showIndication = true,
        insideMargin = PaddingValues(vertical = 8.dp, horizontal = 16.dp)
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            AppIconImage(
                packageInfo = group.primary.packageInfo,
                label = group.primary.label,
                modifier = Modifier
                    .padding(end = 14.dp)
                    .size(48.dp)
            )
            Column(
                modifier = Modifier
                    .weight(1f),
            ) {
                Text(
                    text = if (group.apps.size > 1) ownerNameForUid(group.uid) else group.primary.label,
                    modifier = Modifier.basicMarquee(),
                    fontWeight = FontWeight(550),
                    color = colorScheme.onSurface,
                    maxLines = 1,
                    softWrap = false
                )
                Text(
                    text = if (group.apps.size > 1) {
                        stringResource(R.string.group_contains_apps, group.apps.size)
                    } else {
                        group.primary.packageName
                    },
                    modifier = Modifier
                        .basicMarquee(),
                    fontSize = 12.sp,
                    fontWeight = FontWeight(550),
                    color = colorScheme.onSurfaceVariantSummary,
                    maxLines = 1,
                    softWrap = false
                )
                FlowRow(
                    modifier = Modifier.padding(top = 3.dp, bottom = 3.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    tags.forEach { tag ->
                        StatusTag(
                            label = tag.label,
                            backgroundColor = tag.bg,
                            contentColor = tag.fg
                        )
                    }
                }
            }
            val layoutDirection = LocalLayoutDirection.current
            Image(
                modifier = Modifier
                    .graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    }
                    .padding(start = 8.dp)
                    .size(width = 10.dp, height = 16.dp),
                imageVector = MiuixIcons.Basic.ArrowRight,
                contentDescription = null,
                colorFilter = ColorFilter.tint(colorScheme.onSurfaceVariantActions),
            )
        }
    }
}

@Composable
fun StatusTag(
    label: String,
    backgroundColor: Color,
    contentColor: Color
) {
    Box(
        modifier = Modifier
            .background(
                color = backgroundColor,
                shape = ContinuousRoundedRectangle(6.dp)
            )
    ) {
        Text(
            modifier = Modifier.padding(horizontal = 4.dp, vertical = 2.dp),
            text = label,
            color = contentColor,
            fontSize = 9.sp,
            fontWeight = FontWeight(750),
            maxLines = 1,
            softWrap = false
        )
    }
}

@Immutable
private data class StatusMeta(
    val label: String,
    val bg: Color,
    val fg: Color
)

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/Template.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.annotation.SuppressLint
import android.content.ClipData
import android.widget.Toast
import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.calculateEndPadding
import androidx.compose.foundation.layout.calculateStartPadding
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Fingerprint
import androidx.compose.material.icons.outlined.Group
import androidx.compose.material.icons.outlined.Shield
import androidx.compose.material.icons.rounded.Add
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.input.nestedscroll.NestedScrollConnection
import androidx.compose.ui.input.nestedscroll.NestedScrollSource
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.platform.ClipEntry
import androidx.compose.ui.platform.LocalClipboard
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.dropUnlessResumed
import androidx.lifecycle.viewmodel.compose.viewModel
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.DropdownItem
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.navigation3.Navigator
import me.weishu.kernelsu.ui.navigation3.Route
import me.weishu.kernelsu.ui.util.isNetworkAvailable
import me.weishu.kernelsu.ui.viewmodel.TemplateViewModel
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.FloatingActionButton
import top.yukonga.miuix.kmp.basic.HorizontalDivider
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.InfiniteProgressIndicator
import top.yukonga.miuix.kmp.basic.ListPopupColumn
import top.yukonga.miuix.kmp.basic.ListPopupDefaults
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.PopupPositionProvider
import top.yukonga.miuix.kmp.basic.PullToRefresh
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.ScrollBehavior
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.basic.rememberPullToRefreshState
import top.yukonga.miuix.kmp.extra.SuperListPopup
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.Copy
import top.yukonga.miuix.kmp.theme.MiuixTheme
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.PressFeedbackType
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

/**
 * @author weishu
 * @date 2023/10/20.
 */
@SuppressLint("LocalContextGetResourceValueCall")
@Composable
fun AppProfileTemplateScreen(
) {
    val navigator = LocalNavigator.current
    val viewModel = viewModel<TemplateViewModel>()
    val scope = rememberCoroutineScope()
    val scrollBehavior = MiuixScrollBehavior()

    LaunchedEffect(Unit) {
        if (viewModel.templateList.isEmpty()) {
            scope.launch { viewModel.fetchTemplates() }
        }
    }

    val requestKey = "template_edit"
    LaunchedEffect(Unit) {
        navigator.observeResult<Boolean>(requestKey).collect { success ->
            if (success) {
                navigator.clearResult(requestKey)
                scope.launch { viewModel.fetchTemplates() }
            }
        }
    }

    val listState = rememberLazyListState()
    var fabVisible by remember { mutableStateOf(true) }
    var scrollDistance by remember { mutableFloatStateOf(0f) }
    val nestedScrollConnection = remember {
        object : NestedScrollConnection {
            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {
                val isScrolledToEnd =
                    (listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index == listState.layoutInfo.totalItemsCount - 1
                            && (listState.layoutInfo.visibleItemsInfo.lastOrNull()?.size
                        ?: 0) < listState.layoutInfo.viewportEndOffset)
                val delta = available.y
                if (!isScrolledToEnd) {
                    scrollDistance += delta
                    if (scrollDistance < -50f) {
                        if (fabVisible) fabVisible = false
                        scrollDistance = 0f
                    } else if (scrollDistance > 50f) {
                        if (!fabVisible) fabVisible = true
                        scrollDistance = 0f
                    }
                }
                return Offset.Zero
            }
        }
    }
    val offsetHeight by animateDpAsState(
        targetValue = if (fabVisible) 0.dp else 100.dp + WindowInsets.systemBars.asPaddingValues().calculateBottomPadding(),
        animationSpec = tween(durationMillis = 350)
    )
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            val clipboard = LocalClipboard.current
            val context = LocalContext.current
            val showToast = fun(msg: String) {
                scope.launch(Dispatchers.Main) {
                    Toast.makeText(context, msg, Toast.LENGTH_SHORT).show()
                }
            }
            TopBar(
                onBack = dropUnlessResumed { navigator.pop() },
                onSync = {
                    scope.launch { viewModel.fetchTemplates(true) }
                },
                onImport = {
                    scope.launch {
                        clipboard.getClipEntry()?.clipData?.getItemAt(0)?.text?.toString()?.let {
                            if (it.isEmpty()) {
                                showToast(context.getString(R.string.app_profile_template_import_empty))
                                return@let
                            }
                            viewModel.importTemplates(
                                it,
                                {
                                    showToast(context.getString(R.string.app_profile_template_import_success))
                                    viewModel.fetchTemplates(false)
                                },
                                showToast
                            )
                        }
                    }
                },
                onExport = {
                    scope.launch {
                        viewModel.exportTemplates(
                            {
                                showToast(context.getString(R.string.app_profile_template_export_empty))
                            },
                            {
                                clipboard.setClipEntry(ClipEntry(ClipData.newPlainText("template", it)))
                            }
                        )
                    }
                },
                scrollBehavior = scrollBehavior,
                hazeState = hazeState,
                hazeStyle = hazeStyle,
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                containerColor = colorScheme.primary,
                shadowElevation = 0.dp,
                onClick = {
                    navigator.navigateForResult(Route.TemplateEditor(TemplateViewModel.TemplateInfo(), false), requestKey)
                },
                modifier = Modifier
                    .offset(y = offsetHeight)
                    .padding(
                        bottom = WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                WindowInsets.captionBar.asPaddingValues().calculateBottomPadding() + 20.dp,
                        end = 20.dp
                    )
                    .border(0.05.dp, colorScheme.outline.copy(alpha = 0.5f), CircleShape),
                content = {
                    Icon(
                        Icons.Rounded.Add,
                        null,
                        Modifier.size(40.dp),
                        tint = colorScheme.onPrimary
                    )
                },
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        val context = LocalContext.current
        val offline = !isNetworkAvailable(context)
        if (viewModel.templateList.isEmpty()) {
            val layoutDirection = LocalLayoutDirection.current
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(
                        start = innerPadding.calculateStartPadding(layoutDirection),
                        end = innerPadding.calculateEndPadding(layoutDirection),
                        bottom = innerPadding.calculateBottomPadding(),
                    ),
                contentAlignment = Alignment.Center
            ) {
                if (offline) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(text = stringResource(R.string.network_offline), color = colorScheme.onSurfaceVariantSummary, fontSize = 16.sp)
                        Spacer(Modifier.height(12.dp))
                        TextButton(
                            modifier = Modifier
                                .padding(horizontal = 24.dp)
                                .fillMaxWidth(),
                            text = stringResource(R.string.network_retry),
                            onClick = {
                                scope.launch { viewModel.fetchTemplates() }
                            },
                        )
                    }
                } else {
                    InfiniteProgressIndicator()
                }
            }
        }
        var isRefreshing by rememberSaveable { mutableStateOf(false) }
        val pullToRefreshState = rememberPullToRefreshState()
        LaunchedEffect(isRefreshing) {
            if (isRefreshing) {
                delay(150)
                viewModel.fetchTemplates()
                isRefreshing = false
            }
        }
        val refreshTexts = listOf(
            stringResource(R.string.refresh_pulling),
            stringResource(R.string.refresh_release),
            stringResource(R.string.refresh_refresh),
            stringResource(R.string.refresh_complete),
        )
        val layoutDirection = LocalLayoutDirection.current
        PullToRefresh(
            isRefreshing = isRefreshing,
            pullToRefreshState = pullToRefreshState,
            onRefresh = { isRefreshing = true },
            refreshTexts = refreshTexts,
            contentPadding = PaddingValues(
                top = innerPadding.calculateTopPadding() + 12.dp,
                start = innerPadding.calculateStartPadding(layoutDirection),
                end = innerPadding.calculateEndPadding(layoutDirection)
            ),
        ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxHeight()
                    .scrollEndHaptic()
                    .overScrollVertical()
                    .nestedScroll(nestedScrollConnection)
                    .nestedScroll(scrollBehavior.nestedScrollConnection)
                    .hazeSource(state = hazeState)
                    .padding(horizontal = 12.dp),
                contentPadding = innerPadding,
                overscrollEffect = null
            ) {
                item {
                    Spacer(Modifier.height(12.dp))
                }
                items(viewModel.templateList, key = { it.id }) { app ->
                    TemplateItem(navigator, app)
                }
                item {
                    Spacer(
                        Modifier.height(
                            WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                    WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                        )
                    )
                }
            }
        }
    }
}

@Composable
private fun TemplateItem(
    navigator: Navigator,
    template: TemplateViewModel.TemplateInfo
) {
    Card(
        modifier = Modifier.padding(bottom = 12.dp),
        onClick = {
            navigator.navigateForResult(Route.TemplateEditor(template, !template.local), "template_edit")
        },
        showIndication = true,
        pressFeedbackType = PressFeedbackType.Sink
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = template.name,
                    fontWeight = FontWeight(550),
                    color = colorScheme.onSurface,
                )
                Spacer(modifier = Modifier.weight(1f))
                if (template.local) {
                    Text(
                        text = "LOCAL",
                        color = colorScheme.onTertiaryContainer,
                        fontWeight = FontWeight(750),
                        style = MiuixTheme.textStyles.footnote1
                    )
                } else {
                    Text(
                        text = "REMOTE",
                        color = colorScheme.onSurfaceSecondary,
                        fontWeight = FontWeight(750),
                        style = MiuixTheme.textStyles.footnote1
                    )
                }
            }

            Text(
                text = "${template.id}${if (template.author.isEmpty()) "" else " by @${template.author}"}",
                modifier = Modifier.padding(top = 1.dp),
                fontSize = 12.sp,
                fontWeight = FontWeight(550),
                color = colorScheme.onSurfaceVariantSummary,
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = template.description,
                fontSize = 14.sp,
                color = colorScheme.onSurfaceVariantSummary,
            )

            HorizontalDivider(
                modifier = Modifier.padding(vertical = 8.dp),
                thickness = 0.5.dp,
                color = colorScheme.outline.copy(alpha = 0.5f)
            )

            FlowRow(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                InfoChip(
                    icon = Icons.Outlined.Fingerprint,
                    text = "UID: ${template.uid}"
                )
                InfoChip(
                    icon = Icons.Outlined.Group,
                    text = "GID: ${template.gid}"
                )
                InfoChip(
                    icon = Icons.Outlined.Shield,
                    text = template.context
                )
            }
        }
    }
}

@Composable
private fun InfoChip(icon: ImageVector, text: String) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.size(14.dp),
            tint = colorScheme.onSurfaceSecondary.copy(alpha = 0.8f)
        )
        Text(
            modifier = Modifier.padding(start = 4.dp),
            text = text,
            fontSize = 12.sp,
            fontWeight = FontWeight(550),
            color = colorScheme.onSurfaceSecondary
        )
    }
}

@Composable
private fun TopBar(
    onBack: () -> Unit,
    onSync: () -> Unit = {},
    onImport: () -> Unit = {},
    onExport: () -> Unit = {},
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    hazeStyle: HazeStyle,
) {
    TopAppBar(
        modifier = Modifier.hazeEffect(hazeState) {
            style = hazeStyle
            blurRadius = 30.dp
            noiseFactor = 0f
        },
        color = Color.Transparent,
        title = stringResource(R.string.settings_profile_template),
        navigationIcon = {
            IconButton(
                modifier = Modifier.padding(start = 16.dp),
                onClick = onBack
            ) {
                val layoutDirection = LocalLayoutDirection.current
                Icon(
                    modifier = Modifier.graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    },
                    imageVector = MiuixIcons.Back,
                    contentDescription = null,
                    tint = colorScheme.onBackground
                )
            }
        },
        actions = {
            val showTopPopup = remember { mutableStateOf(false) }
            SuperListPopup(
                show = showTopPopup,
                popupPositionProvider = ListPopupDefaults.ContextMenuPositionProvider,
                alignment = PopupPositionProvider.Align.TopEnd,
                onDismissRequest = {
                    showTopPopup.value = false
                }
            ) {
                ListPopupColumn {
                    val items = listOf(
                        stringResource(id = R.string.app_profile_import_from_clipboard),
                        stringResource(id = R.string.app_profile_export_to_clipboard)
                    )
                    items.forEachIndexed { index, text ->
                        DropdownItem(
                            text = text,
                            optionSize = items.size,
                            index = index,
                            onSelectedIndexChange = { selectedIndex ->
                                if (selectedIndex == 0) {
                                    onImport()
                                } else {
                                    onExport()
                                }
                                showTopPopup.value = false
                            }
                        )
                    }
                }
            }
            IconButton(
                modifier = Modifier.padding(end = 16.dp),
                onClick = { showTopPopup.value = true },
                holdDownState = showTopPopup.value
            ) {
                Icon(
                    imageVector = MiuixIcons.Copy,
                    contentDescription = stringResource(id = R.string.app_profile_import_export),
                    tint = colorScheme.onBackground
                )
            }
        },
        scrollBehavior = scrollBehavior
    )
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/screen/TemplateEditor.kt`:

```kt
package me.weishu.kernelsu.ui.screen

import android.widget.Toast
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.WindowInsetsSides
import androidx.compose.foundation.layout.add
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.captionBar
import androidx.compose.foundation.layout.displayCutout
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBars
import androidx.compose.foundation.layout.only
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.systemBars
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.ui.input.pointer.pointerInteropFilter
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import androidx.lifecycle.compose.dropUnlessResumed
import dev.chrisbanes.haze.HazeState
import dev.chrisbanes.haze.HazeStyle
import dev.chrisbanes.haze.HazeTint
import dev.chrisbanes.haze.hazeEffect
import dev.chrisbanes.haze.hazeSource
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.component.EditText
import me.weishu.kernelsu.ui.component.profile.RootProfileConfig
import me.weishu.kernelsu.ui.navigation3.LocalNavigator
import me.weishu.kernelsu.ui.util.deleteAppProfileTemplate
import me.weishu.kernelsu.ui.util.getAppProfileTemplate
import me.weishu.kernelsu.ui.util.setAppProfileTemplate
import me.weishu.kernelsu.ui.viewmodel.TemplateViewModel
import me.weishu.kernelsu.ui.viewmodel.toJSON
import top.yukonga.miuix.kmp.basic.Card
import top.yukonga.miuix.kmp.basic.Icon
import top.yukonga.miuix.kmp.basic.IconButton
import top.yukonga.miuix.kmp.basic.MiuixScrollBehavior
import top.yukonga.miuix.kmp.basic.Scaffold
import top.yukonga.miuix.kmp.basic.ScrollBehavior
import top.yukonga.miuix.kmp.basic.TopAppBar
import top.yukonga.miuix.kmp.icon.MiuixIcons
import top.yukonga.miuix.kmp.icon.extended.Back
import top.yukonga.miuix.kmp.icon.extended.Delete
import top.yukonga.miuix.kmp.icon.extended.Ok
import top.yukonga.miuix.kmp.theme.MiuixTheme.colorScheme
import top.yukonga.miuix.kmp.utils.overScrollVertical
import top.yukonga.miuix.kmp.utils.scrollEndHaptic

/**
 * @author weishu
 * @date 2023/10/20.
 */
@Composable
fun TemplateEditorScreen(
    initialTemplate: TemplateViewModel.TemplateInfo,
    readOnly: Boolean = true,
) {
    val navigator = LocalNavigator.current
    val isCreation = initialTemplate.id.isBlank()
    val autoSave = !isCreation

    var template by rememberSaveable {
        mutableStateOf(initialTemplate)
    }

    val scrollBehavior = MiuixScrollBehavior()
    val hazeState = remember { HazeState() }
    val hazeStyle = HazeStyle(
        backgroundColor = colorScheme.surface,
        tint = HazeTint(colorScheme.surface.copy(0.8f))
    )

    Scaffold(
        topBar = {
            val saveTemplateFailed = stringResource(id = R.string.app_profile_template_save_failed)
            val idConflictError = stringResource(id = R.string.app_profile_template_id_exist)
            val idInvalidError = stringResource(id = R.string.app_profile_template_id_invalid)
            val context = LocalContext.current

            TopBar(
                title = if (isCreation) {
                    stringResource(R.string.app_profile_template_create)
                } else if (readOnly) {
                    stringResource(R.string.app_profile_template_view)
                } else {
                    stringResource(R.string.app_profile_template_edit)
                },
                readOnly = readOnly,
                isCreation = isCreation,
                onBack = dropUnlessResumed {
                    if (readOnly) navigator.pop() else navigator.setResult("template_edit", true)
                },
                onDelete = {
                    if (deleteAppProfileTemplate(template.id)) navigator.setResult("template_edit", true)
                },
                onSave = {
                    when (idCheck(template.id)) {
                        0 -> Unit

                        1 -> {
                            Toast.makeText(context, idConflictError, Toast.LENGTH_SHORT).show()
                            return@TopBar
                        }

                        2 -> {
                            Toast.makeText(context, idInvalidError, Toast.LENGTH_SHORT).show()
                            return@TopBar
                        }
                    }
                    if (saveTemplate(template, isCreation)) {
                        navigator.setResult("template_edit", true)
                    } else {
                        Toast.makeText(context, saveTemplateFailed, Toast.LENGTH_SHORT).show()
                    }
                },
                scrollBehavior = scrollBehavior,
                hazeState = hazeState,
                hazeStyle = hazeStyle,
            )
        },
        popupHost = { },
        contentWindowInsets = WindowInsets.systemBars.add(WindowInsets.displayCutout).only(WindowInsetsSides.Horizontal)
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxHeight()
                .scrollEndHaptic()
                .overScrollVertical()
                .nestedScroll(scrollBehavior.nestedScrollConnection)
                .hazeSource(state = hazeState)
                .pointerInteropFilter {
                    // disable click and ripple if readOnly
                    readOnly
                },
            contentPadding = innerPadding,
            overscrollEffect = null
        ) {
            item {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                ) {
                    var errorHint by rememberSaveable { mutableStateOf(false) }

                    TextEdit(
                        label = stringResource(id = R.string.app_profile_template_name),
                        text = template.name
                    ) { value ->
                        template.copy(name = value).run {
                            if (autoSave) {
                                if (!saveTemplate(this)) {
                                    // failed
                                    return@run
                                }
                            }
                            template = this
                        }
                    }

                    TextEdit(
                        label = stringResource(id = R.string.app_profile_template_id),
                        text = template.id,
                        isError = errorHint
                    ) { value ->
                        template = template.copy(id = value)
                    }
                    TextEdit(
                        label = stringResource(R.string.module_author),
                        text = template.author
                    ) { value ->
                        template.copy(author = value).run {
                            if (autoSave) {
                                if (!saveTemplate(this)) {
                                    // failed
                                    return@run
                                }
                            }
                            template = this
                        }
                    }

                    TextEdit(
                        label = stringResource(id = R.string.app_profile_template_description),
                        text = template.description
                    ) { value ->
                        template.copy(description = value).run {
                            if (autoSave) {
                                if (!saveTemplate(this)) {
                                    // failed
                                    return@run
                                }
                            }
                            template = this
                        }
                    }

                    RootProfileConfig(
                        fixedName = true,
                        profile = toNativeProfile(template),
                        onProfileChange = {
                            template.copy(
                                uid = it.uid,
                                gid = it.gid,
                                groups = it.groups,
                                capabilities = it.capabilities,
                                context = it.context,
                                namespace = it.namespace,
                                rules = it.rules.split("\n")
                            ).run {
                                if (autoSave) {
                                    if (!saveTemplate(this)) {
                                        // failed
                                        return@run
                                    }
                                }
                                template = this
                            }
                        }
                    )
                }
                Spacer(
                    Modifier.height(
                        WindowInsets.navigationBars.asPaddingValues().calculateBottomPadding() +
                                WindowInsets.captionBar.asPaddingValues().calculateBottomPadding()
                    )
                )
            }
        }
    }
}

fun toNativeProfile(templateInfo: TemplateViewModel.TemplateInfo): Natives.Profile {
    return Natives.Profile().copy(
        rootTemplate = templateInfo.id,
        uid = templateInfo.uid,
        gid = templateInfo.gid,
        groups = templateInfo.groups,
        capabilities = templateInfo.capabilities,
        context = templateInfo.context,
        namespace = templateInfo.namespace,
        rules = templateInfo.rules.joinToString("\n").ifBlank { "" })
}

fun isTemplateValid(template: TemplateViewModel.TemplateInfo): Boolean {
    if (template.id.isBlank()) {
        return false
    }

    if (!isValidTemplateId(template.id)) {
        return false
    }

    return true
}

fun idCheck(value: String): Int {
    return if (value.isEmpty()) 0 else if (isTemplateExist(value)) 1 else if (!isValidTemplateId(value)) 2 else 0
}

fun saveTemplate(template: TemplateViewModel.TemplateInfo, isCreation: Boolean = false): Boolean {
    if (!isTemplateValid(template)) {
        return false
    }

    if (isCreation && isTemplateExist(template.id)) {
        return false
    }

    val json = template.toJSON()
    json.put("local", true)
    return setAppProfileTemplate(template.id, json.toString())
}

@Composable
private fun TopBar(
    title: String,
    readOnly: Boolean,
    isCreation: Boolean,
    onBack: () -> Unit,
    onDelete: () -> Unit = {},
    onSave: () -> Unit = {},
    scrollBehavior: ScrollBehavior,
    hazeState: HazeState,
    hazeStyle: HazeStyle,
) {
    TopAppBar(
        modifier = Modifier.hazeEffect(hazeState) {
            style = hazeStyle
            blurRadius = 30.dp
            noiseFactor = 0f
        },
        color = Color.Transparent,
        title = title,
        navigationIcon = {
            IconButton(
                modifier = Modifier.padding(start = 16.dp),
                onClick = onBack
            ) {
                val layoutDirection = LocalLayoutDirection.current
                Icon(
                    modifier = Modifier.graphicsLayer {
                        if (layoutDirection == LayoutDirection.Rtl) scaleX = -1f
                    },
                    imageVector = MiuixIcons.Back,
                    contentDescription = null,
                    tint = colorScheme.onSurface
                )
            }
        },
        actions = {
            when {
                !readOnly && !isCreation -> {
                    IconButton(
                        modifier = Modifier.padding(end = 16.dp),
                        onClick = onDelete
                    ) {
                        Icon(
                            imageVector = MiuixIcons.Delete,
                            contentDescription = stringResource(id = R.string.app_profile_template_delete),
                            tint = colorScheme.onBackground
                        )
                    }
                }

                isCreation -> {
                    IconButton(
                        modifier = Modifier.padding(end = 16.dp),
                        onClick = onSave
                    ) {
                        Icon(
                            imageVector = MiuixIcons.Ok,
                            contentDescription = stringResource(id = R.string.app_profile_template_save),
                            tint = colorScheme.onBackground
                        )
                    }
                }
            }
        },
        scrollBehavior = scrollBehavior
    )
}

@Composable
private fun TextEdit(
    label: String,
    text: String,
    isError: Boolean = false,
    onValueChange: (String) -> Unit = {}
) {
    val editText = remember { mutableStateOf(text) }
    EditText(
        title = label.uppercase(),
        textValue = editText,
        onTextValueChange = { newText ->
            editText.value = newText
            onValueChange(newText)
        },
        keyboardOptions = KeyboardOptions(
            keyboardType = KeyboardType.Ascii,
        ),
        isError = isError,
    )
}

private fun isValidTemplateId(id: String): Boolean {
    return Regex("""^([A-Za-z][A-Za-z\d_]*\.)*[A-Za-z][A-Za-z\d_]*$""").matches(id)
}

private fun isTemplateExist(id: String): Boolean {
    return getAppProfileTemplate(id).isNotBlank()
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/theme/Theme.kt`:

```kt
package me.weishu.kernelsu.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.ReadOnlyComposable
import androidx.compose.ui.graphics.Color
import me.weishu.kernelsu.ui.webui.MonetColorsProvider.UpdateCss
import top.yukonga.miuix.kmp.theme.ColorSchemeMode
import top.yukonga.miuix.kmp.theme.MiuixTheme
import top.yukonga.miuix.kmp.theme.ThemeController

@Composable
fun KernelSUTheme(
    colorMode: Int = 0,
    keyColor: Color? = null,
    content: @Composable () -> Unit
) {
    val isDark = isSystemInDarkTheme()
    val controller = when (colorMode) {
        1 -> ThemeController(ColorSchemeMode.Light)
        2 -> ThemeController(ColorSchemeMode.Dark)
        3 -> ThemeController(
            ColorSchemeMode.MonetSystem,
            keyColor = keyColor,
            isDark = isDark
        )

        4 -> ThemeController(
            ColorSchemeMode.MonetLight,
            keyColor = keyColor,
        )

        5 -> ThemeController(
            ColorSchemeMode.MonetDark,
            keyColor = keyColor,
        )

        else -> ThemeController(ColorSchemeMode.System)
    }
    return MiuixTheme(
        controller = controller,
        content = {
            UpdateCss()
            content()
        }
    )
}

@Composable
@ReadOnlyComposable
fun isInDarkTheme(themeMode: Int): Boolean {
    return when (themeMode) {
        1, 4 -> false  // Force light mode
        2, 5 -> true   // Force dark mode
        else -> isSystemInDarkTheme()  // Follow system (0 or default)
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/Colors.kt`:

```kt
package me.weishu.kernelsu.ui.util

import kotlin.math.pow

fun cssColorFromArgb(argb: Int): String {
    val a = ((argb ushr 24) and 0xFF) / 255f
    val r = (argb ushr 16) and 0xFF
    val g = (argb ushr 8) and 0xFF
    val b = argb and 0xFF
    return "rgba(${r},${g},${b},${"%.3f".format(a)})"
}

fun mixArgb(c1: Int, c2: Int, ratio: Float): Int {
    val r1 = (c1 ushr 16) and 0xFF
    val g1 = (c1 ushr 8) and 0xFF
    val b1 = c1 and 0xFF
    val a1 = (c1 ushr 24) and 0xFF

    val r2 = (c2 ushr 16) and 0xFF
    val g2 = (c2 ushr 8) and 0xFF
    val b2 = c2 and 0xFF
    val a2 = (c2 ushr 24) and 0xFF

    val r = (r1 * (1 - ratio) + r2 * ratio).toInt().coerceIn(0, 255)
    val g = (g1 * (1 - ratio) + g2 * ratio).toInt().coerceIn(0, 255)
    val b = (b1 * (1 - ratio) + b2 * ratio).toInt().coerceIn(0, 255)
    val a = (a1 * (1 - ratio) + a2 * ratio).toInt().coerceIn(0, 255)

    return (a shl 24) or (r shl 16) or (g shl 8) or b
}

fun relativeLuminance(argb: Int): Double {
    fun linearize(c: Int): Double {
        val s = c / 255.0
        return if (s <= 0.03928) s / 12.92 else ((s + 0.055) / 1.055).pow(2.4)
    }

    val r = linearize((argb ushr 16) and 0xFF)
    val g = linearize((argb ushr 8) and 0xFF)
    val b = linearize(argb and 0xFF)
    return 0.2126 * r + 0.7152 * g + 0.0722 * b
}

fun contrastRatio(a: Int, b: Int): Double {
    val l1 = relativeLuminance(a)
    val l2 = relativeLuminance(b)
    val (hi, lo) = if (l1 >= l2) Pair(l1, l2) else Pair(l2, l1)
    return (hi + 0.05) / (lo + 0.05)
}

fun argbToHsl(argb: Int): Triple<Float, Float, Float> {
    val r = ((argb ushr 16) and 0xFF) / 255f
    val g = ((argb ushr 8) and 0xFF) / 255f
    val b = (argb and 0xFF) / 255f
    val max = maxOf(r, g, b)
    val min = minOf(r, g, b)
    val l = (max + min) / 2f
    val d = max - min
    val s = if (d == 0f) 0f else d / (1f - kotlin.math.abs(2f * l - 1f))
    val h = when {
        d == 0f -> 0f
        max == r -> ((g - b) / d % 6f) * 60f
        max == g -> ((b - r) / d + 2f) * 60f
        else -> ((r - g) / d + 4f) * 60f
    }.let { if (it < 0f) it + 360f else it }
    return Triple(h, s, l)
}

fun hslToArgb(h: Float, s: Float, l: Float, alpha: Int = 0xFF): Int {
    val c = (1f - kotlin.math.abs(2f * l - 1f)) * s
    val x = c * (1f - kotlin.math.abs((h / 60f) % 2f - 1f))
    val m = l - c / 2f
    val (r1, g1, b1) = when {
        h < 60f -> Triple(c, x, 0f)
        h < 120f -> Triple(x, c, 0f)
        h < 180f -> Triple(0f, c, x)
        h < 240f -> Triple(0f, x, c)
        h < 300f -> Triple(x, 0f, c)
        else -> Triple(c, 0f, x)
    }
    val r = ((r1 + m) * 255f).toInt().coerceIn(0, 255)
    val g = ((g1 + m) * 255f).toInt().coerceIn(0, 255)
    val b = ((b1 + m) * 255f).toInt().coerceIn(0, 255)
    return (alpha shl 24) or (r shl 16) or (g shl 8) or b
}

fun adjustLightnessArgb(argb: Int, delta: Float): Int {
    val (h, s, l) = argbToHsl(argb)
    val nl = (l + delta).coerceIn(0f, 1f)
    val alpha = (argb ushr 24) and 0xFF
    return hslToArgb(h, s, nl, alpha)
}

fun ensureVisibleByMix(original: Int, candidate: Int, minRatio: Double, mixWithWhiteIfLighter: Boolean): Int {
    if (contrastRatio(original, candidate) >= minRatio) return candidate
    val target = if (mixWithWhiteIfLighter) 0xFFFFFFFF.toInt() else 0xFF000000.toInt()
    var lo = 0f
    var hi = 1f
    var best = candidate
    for (i in 0 until 12) {
        val mid = (lo + hi) / 2f
        val mixed = mixArgb(candidate, target, mid)
        if (contrastRatio(original, mixed) >= minRatio) {
            best = mixed
            hi = mid
        } else {
            lo = mid
        }
    }
    return best
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/Downloader.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.annotation.SuppressLint
import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.Uri
import android.os.Environment
import android.os.Handler
import android.os.Looper
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.util.module.LatestVersionInfo
import okhttp3.Request
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

/**
 * @author weishu
 * @date 2023/6/22.
 */
@SuppressLint("Range")
fun download(
    url: String,
    fileName: String,
    onDownloaded: (Uri) -> Unit = {},
    onDownloading: () -> Unit = {},
    onProgress: (Int) -> Unit = {}
) {
    onDownloading()
    Thread {
        val target = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), fileName)
        try {
            ksuApp.okhttpClient.newCall(Request.Builder().url(url).build()).execute().use { resp ->
                if (!resp.isSuccessful) throw IOException("HTTP ${resp.code}")
                val body = resp.body
                val total = body.contentLength()
                target.parentFile?.mkdirs()
                FileOutputStream(target).use { fos ->
                    val buf = ByteArray(8 * 1024)
                    var read: Int
                    var soFar = 0L
                    val source = body.byteStream()
                    while (true) {
                        read = source.read(buf)
                        if (read == -1) break
                        fos.write(buf, 0, read)
                        soFar += read
                        if (total > 0) {
                            val percent = ((soFar * 100L) / total).toInt().coerceIn(0, 100)
                            onProgress(percent)
                        }
                    }
                    fos.flush()
                }
            }
            Handler(Looper.getMainLooper()).post {
                onDownloaded(Uri.fromFile(target))
            }
        } catch (_: Exception) {
            // ignore, keep UI state
        }
    }.start()
}

fun checkNewVersion(): LatestVersionInfo {
    if (!isNetworkAvailable(ksuApp)) return LatestVersionInfo()
    val url = "https://api.github.com/repos/tiann/KernelSU/releases/latest"
    // default null value if failed
    val defaultValue = LatestVersionInfo()
    runCatching {
        ksuApp.okhttpClient.newCall(Request.Builder().url(url).build()).execute()
            .use { response ->
                if (!response.isSuccessful) {
                    return defaultValue
                }
                val body = response.body.string()
                val json = org.json.JSONObject(body)
                val changelog = json.optString("body")

                val assets = json.getJSONArray("assets")
                for (i in 0 until assets.length()) {
                    val asset = assets.getJSONObject(i)
                    val name = asset.getString("name")
                    if (!name.endsWith(".apk")) {
                        continue
                    }

                    val regex = Regex("v(.+?)_(\\d+)-")
                    val matchResult = regex.find(name) ?: continue
                    matchResult.groupValues[1]
                    val versionCode = matchResult.groupValues[2].toInt()
                    val downloadUrl = asset.getString("browser_download_url")

                    return LatestVersionInfo(
                        versionCode,
                        downloadUrl,
                        changelog
                    )
                }

            }
    }
    return defaultValue
}

@Composable
fun DownloadListener(context: Context, onDownloaded: (Uri) -> Unit) {
    DisposableEffect(context) {
        val receiver = object : BroadcastReceiver() {
            @SuppressLint("Range")
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == DownloadManager.ACTION_DOWNLOAD_COMPLETE) {
                    val id = intent.getLongExtra(
                        DownloadManager.EXTRA_DOWNLOAD_ID, -1
                    )
                    val query = DownloadManager.Query().setFilterById(id)
                    val downloadManager =
                        context?.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
                    val cursor = downloadManager.query(query)
                    if (cursor.moveToFirst()) {
                        val status = cursor.getInt(
                            cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                        )
                        if (status == DownloadManager.STATUS_SUCCESSFUL) {
                            val uri = cursor.getString(
                                cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)
                            )
                            onDownloaded(uri.toUri())
                        }
                    }
                }
            }
        }
        ContextCompat.registerReceiver(
            context,
            receiver,
            IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE),
            ContextCompat.RECEIVER_EXPORTED
        )
        onDispose {
            context.unregisterReceiver(receiver)
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/HanziToPinyin.java`:

```java
package me.weishu.kernelsu.ui.util;
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import android.text.TextUtils;
import android.util.Log;

import java.text.Collator;
import java.util.ArrayList;
import java.util.Locale;

/**
 * An object to convert Chinese character to its corresponding pinyin string. For characters with
 * multiple possible pinyin string, only one is selected according to collator. Polyphone is not
 * supported in this implementation. This class is implemented to achieve the best runtime
 * performance and minimum runtime resources with tolerable sacrifice of accuracy. This
 * implementation highly depends on zh_CN ICU collation data and must be always synchronized with
 * ICU.
 * <p>
 * Currently this file is aligned to zh.txt in ICU 4.6
 */
public class HanziToPinyin {
    /**
     * Unihans array.
     * <p>
     * Each unihans is the first one within same pinyin when collator is zh_CN.
     */
    public static final char[] UNIHANS = {
            '\u963f', '\u54ce', '\u5b89', '\u80ae', '\u51f9', '\u516b',
            '\u6300', '\u6273', '\u90a6', '\u52f9', '\u9642', '\u5954',
            '\u4f3b', '\u5c44', '\u8fb9', '\u706c', '\u618b', '\u6c43',
            '\u51ab', '\u7676', '\u5cec', '\u5693', '\u5072', '\u53c2',
            '\u4ed3', '\u64a1', '\u518a', '\u5d7e', '\u66fd', '\u66fe',
            '\u5c64', '\u53c9', '\u8286', '\u8fbf', '\u4f25', '\u6284',
            '\u8f66', '\u62bb', '\u6c88', '\u6c89', '\u9637', '\u5403',
            '\u5145', '\u62bd', '\u51fa', '\u6b3b', '\u63e3', '\u5ddb',
            '\u5205', '\u5439', '\u65fe', '\u9034', '\u5472', '\u5306',
            '\u51d1', '\u7c97', '\u6c46', '\u5d14', '\u90a8', '\u6413',
            '\u5491', '\u5446', '\u4e39', '\u5f53', '\u5200', '\u561a',
            '\u6265', '\u706f', '\u6c10', '\u55f2', '\u7538', '\u5201',
            '\u7239', '\u4e01', '\u4e1f', '\u4e1c', '\u543a', '\u53be',
            '\u8011', '\u8968', '\u5428', '\u591a', '\u59b8', '\u8bf6',
            '\u5940', '\u97a5', '\u513f', '\u53d1', '\u5e06', '\u531a',
            '\u98de', '\u5206', '\u4e30', '\u8985', '\u4ecf', '\u7d11',
            '\u4f15', '\u65ee', '\u4f85', '\u7518', '\u5188', '\u768b',
            '\u6208', '\u7ed9', '\u6839', '\u522f', '\u5de5', '\u52fe',
            '\u4f30', '\u74dc', '\u4e56', '\u5173', '\u5149', '\u5f52',
            '\u4e28', '\u5459', '\u54c8', '\u548d', '\u4f44', '\u592f',
            '\u8320', '\u8bc3', '\u9ed2', '\u62eb', '\u4ea8', '\u5677',
            '\u53ff', '\u9f41', '\u4e6f', '\u82b1', '\u6000', '\u72bf',
            '\u5ddf', '\u7070', '\u660f', '\u5419', '\u4e0c', '\u52a0',
            '\u620b', '\u6c5f', '\u827d', '\u9636', '\u5dfe', '\u5755',
            '\u5182', '\u4e29', '\u51e5', '\u59e2', '\u5658', '\u519b',
            '\u5494', '\u5f00', '\u520a', '\u5ffc', '\u5c3b', '\u533c',
            '\u808e', '\u52a5', '\u7a7a', '\u62a0', '\u625d', '\u5938',
            '\u84af', '\u5bbd', '\u5321', '\u4e8f', '\u5764', '\u6269',
            '\u5783', '\u6765', '\u5170', '\u5577', '\u635e', '\u808b',
            '\u52d2', '\u5d1a', '\u5215', '\u4fe9', '\u5941', '\u826f',
            '\u64a9', '\u5217', '\u62ce', '\u5222', '\u6e9c', '\u56d6',
            '\u9f99', '\u779c', '\u565c', '\u5a08', '\u7567', '\u62a1',
            '\u7f57', '\u5463', '\u5988', '\u57cb', '\u5ada', '\u7264',
            '\u732b', '\u4e48', '\u5445', '\u95e8', '\u753f', '\u54aa',
            '\u5b80', '\u55b5', '\u4e5c', '\u6c11', '\u540d', '\u8c2c',
            '\u6478', '\u54de', '\u6bea', '\u55ef', '\u62cf', '\u8149',
            '\u56e1', '\u56d4', '\u5b6c', '\u7592', '\u5a1e', '\u6041',
            '\u80fd', '\u59ae', '\u62c8', '\u5b22', '\u9e1f', '\u634f',
            '\u56dc', '\u5b81', '\u599e', '\u519c', '\u7fba', '\u5974',
            '\u597b', '\u759f', '\u9ec1', '\u90cd', '\u5594', '\u8bb4',
            '\u5991', '\u62cd', '\u7705', '\u4e53', '\u629b', '\u5478',
            '\u55b7', '\u5309', '\u4e15', '\u56e8', '\u527d', '\u6c15',
            '\u59d8', '\u4e52', '\u948b', '\u5256', '\u4ec6', '\u4e03',
            '\u6390', '\u5343', '\u545b', '\u6084', '\u767f', '\u4eb2',
            '\u72c5', '\u828e', '\u4e18', '\u533a', '\u5cd1', '\u7f3a',
            '\u590b', '\u5465', '\u7a63', '\u5a06', '\u60f9', '\u4eba',
            '\u6254', '\u65e5', '\u8338', '\u53b9', '\u909a', '\u633c',
            '\u5827', '\u5a51', '\u77a4', '\u637c', '\u4ee8', '\u6be2',
            '\u4e09', '\u6852', '\u63bb', '\u95aa', '\u68ee', '\u50e7',
            '\u6740', '\u7b5b', '\u5c71', '\u4f24', '\u5f30', '\u5962',
            '\u7533', '\u8398', '\u6552', '\u5347', '\u5c38', '\u53ce',
            '\u4e66', '\u5237', '\u8870', '\u95e9', '\u53cc', '\u8c01',
            '\u542e', '\u8bf4', '\u53b6', '\u5fea', '\u635c', '\u82cf',
            '\u72fb', '\u590a', '\u5b59', '\u5506', '\u4ed6', '\u56fc',
            '\u574d', '\u6c64', '\u5932', '\u5fd1', '\u71a5', '\u5254',
            '\u5929', '\u65eb', '\u5e16', '\u5385', '\u56f2', '\u5077',
            '\u51f8', '\u6e4d', '\u63a8', '\u541e', '\u4e47', '\u7a75',
            '\u6b6a', '\u5f2f', '\u5c23', '\u5371', '\u6637', '\u7fc1',
            '\u631d', '\u4e4c', '\u5915', '\u8672', '\u4eda', '\u4e61',
            '\u7071', '\u4e9b', '\u5fc3', '\u661f', '\u51f6', '\u4f11',
            '\u5401', '\u5405', '\u524a', '\u5743', '\u4e2b', '\u6079',
            '\u592e', '\u5e7a', '\u503b', '\u4e00', '\u56d9', '\u5e94',
            '\u54df', '\u4f63', '\u4f18', '\u625c', '\u56e6', '\u66f0',
            '\u6655', '\u7b60', '\u7b7c', '\u5e00', '\u707d', '\u5142',
            '\u5328', '\u50ae', '\u5219', '\u8d3c', '\u600e', '\u5897',
            '\u624e', '\u635a', '\u6cbe', '\u5f20', '\u957f', '\u9577',
            '\u4f4b', '\u8707', '\u8d1e', '\u4e89', '\u4e4b', '\u5cd9',
            '\u5ea2', '\u4e2d', '\u5dde', '\u6731', '\u6293', '\u62fd',
            '\u4e13', '\u5986', '\u96b9', '\u5b92', '\u5353', '\u4e72',
            '\u5b97', '\u90b9', '\u79df', '\u94bb', '\u539c', '\u5c0a',
            '\u6628', '\u5159', '\u9fc3', '\u9fc4',};
    /**
     * Pinyin array.
     * <p>
     * Each pinyin is corresponding to unihans of same
     * offset in the unihans array.
     */
    public static final byte[][] PINYINS = {
            {65, 0, 0, 0, 0, 0}, {65, 73, 0, 0, 0, 0},
            {65, 78, 0, 0, 0, 0}, {65, 78, 71, 0, 0, 0},
            {65, 79, 0, 0, 0, 0}, {66, 65, 0, 0, 0, 0},
            {66, 65, 73, 0, 0, 0}, {66, 65, 78, 0, 0, 0},
            {66, 65, 78, 71, 0, 0}, {66, 65, 79, 0, 0, 0},
            {66, 69, 73, 0, 0, 0}, {66, 69, 78, 0, 0, 0},
            {66, 69, 78, 71, 0, 0}, {66, 73, 0, 0, 0, 0},
            {66, 73, 65, 78, 0, 0}, {66, 73, 65, 79, 0, 0},
            {66, 73, 69, 0, 0, 0}, {66, 73, 78, 0, 0, 0},
            {66, 73, 78, 71, 0, 0}, {66, 79, 0, 0, 0, 0},
            {66, 85, 0, 0, 0, 0}, {67, 65, 0, 0, 0, 0},
            {67, 65, 73, 0, 0, 0}, {67, 65, 78, 0, 0, 0},
            {67, 65, 78, 71, 0, 0}, {67, 65, 79, 0, 0, 0},
            {67, 69, 0, 0, 0, 0}, {67, 69, 78, 0, 0, 0},
            {67, 69, 78, 71, 0, 0}, {90, 69, 78, 71, 0, 0},
            {67, 69, 78, 71, 0, 0}, {67, 72, 65, 0, 0, 0},
            {67, 72, 65, 73, 0, 0}, {67, 72, 65, 78, 0, 0},
            {67, 72, 65, 78, 71, 0}, {67, 72, 65, 79, 0, 0},
            {67, 72, 69, 0, 0, 0}, {67, 72, 69, 78, 0, 0},
            {83, 72, 69, 78, 0, 0}, {67, 72, 69, 78, 0, 0},
            {67, 72, 69, 78, 71, 0}, {67, 72, 73, 0, 0, 0},
            {67, 72, 79, 78, 71, 0}, {67, 72, 79, 85, 0, 0},
            {67, 72, 85, 0, 0, 0}, {67, 72, 85, 65, 0, 0},
            {67, 72, 85, 65, 73, 0}, {67, 72, 85, 65, 78, 0},
            {67, 72, 85, 65, 78, 71}, {67, 72, 85, 73, 0, 0},
            {67, 72, 85, 78, 0, 0}, {67, 72, 85, 79, 0, 0},
            {67, 73, 0, 0, 0, 0}, {67, 79, 78, 71, 0, 0},
            {67, 79, 85, 0, 0, 0}, {67, 85, 0, 0, 0, 0},
            {67, 85, 65, 78, 0, 0}, {67, 85, 73, 0, 0, 0},
            {67, 85, 78, 0, 0, 0}, {67, 85, 79, 0, 0, 0},
            {68, 65, 0, 0, 0, 0}, {68, 65, 73, 0, 0, 0},
            {68, 65, 78, 0, 0, 0}, {68, 65, 78, 71, 0, 0},
            {68, 65, 79, 0, 0, 0}, {68, 69, 0, 0, 0, 0},
            {68, 69, 78, 0, 0, 0}, {68, 69, 78, 71, 0, 0},
            {68, 73, 0, 0, 0, 0}, {68, 73, 65, 0, 0, 0},
            {68, 73, 65, 78, 0, 0}, {68, 73, 65, 79, 0, 0},
            {68, 73, 69, 0, 0, 0}, {68, 73, 78, 71, 0, 0},
            {68, 73, 85, 0, 0, 0}, {68, 79, 78, 71, 0, 0},
            {68, 79, 85, 0, 0, 0}, {68, 85, 0, 0, 0, 0},
            {68, 85, 65, 78, 0, 0}, {68, 85, 73, 0, 0, 0},
            {68, 85, 78, 0, 0, 0}, {68, 85, 79, 0, 0, 0},
            {69, 0, 0, 0, 0, 0}, {69, 73, 0, 0, 0, 0},
            {69, 78, 0, 0, 0, 0}, {69, 78, 71, 0, 0, 0},
            {69, 82, 0, 0, 0, 0}, {70, 65, 0, 0, 0, 0},
            {70, 65, 78, 0, 0, 0}, {70, 65, 78, 71, 0, 0},
            {70, 69, 73, 0, 0, 0}, {70, 69, 78, 0, 0, 0},
            {70, 69, 78, 71, 0, 0}, {70, 73, 65, 79, 0, 0},
            {70, 79, 0, 0, 0, 0}, {70, 79, 85, 0, 0, 0},
            {70, 85, 0, 0, 0, 0}, {71, 65, 0, 0, 0, 0},
            {71, 65, 73, 0, 0, 0}, {71, 65, 78, 0, 0, 0},
            {71, 65, 78, 71, 0, 0}, {71, 65, 79, 0, 0, 0},
            {71, 69, 0, 0, 0, 0}, {71, 69, 73, 0, 0, 0},
            {71, 69, 78, 0, 0, 0}, {71, 69, 78, 71, 0, 0},
            {71, 79, 78, 71, 0, 0}, {71, 79, 85, 0, 0, 0},
            {71, 85, 0, 0, 0, 0}, {71, 85, 65, 0, 0, 0},
            {71, 85, 65, 73, 0, 0}, {71, 85, 65, 78, 0, 0},
            {71, 85, 65, 78, 71, 0}, {71, 85, 73, 0, 0, 0},
            {71, 85, 78, 0, 0, 0}, {71, 85, 79, 0, 0, 0},
            {72, 65, 0, 0, 0, 0}, {72, 65, 73, 0, 0, 0},
            {72, 65, 78, 0, 0, 0}, {72, 65, 78, 71, 0, 0},
            {72, 65, 79, 0, 0, 0}, {72, 69, 0, 0, 0, 0},
            {72, 69, 73, 0, 0, 0}, {72, 69, 78, 0, 0, 0},
            {72, 69, 78, 71, 0, 0}, {72, 77, 0, 0, 0, 0},
            {72, 79, 78, 71, 0, 0}, {72, 79, 85, 0, 0, 0},
            {72, 85, 0, 0, 0, 0}, {72, 85, 65, 0, 0, 0},
            {72, 85, 65, 73, 0, 0}, {72, 85, 65, 78, 0, 0},
            {72, 85, 65, 78, 71, 0}, {72, 85, 73, 0, 0, 0},
            {72, 85, 78, 0, 0, 0}, {72, 85, 79, 0, 0, 0},
            {74, 73, 0, 0, 0, 0}, {74, 73, 65, 0, 0, 0},
            {74, 73, 65, 78, 0, 0}, {74, 73, 65, 78, 71, 0},
            {74, 73, 65, 79, 0, 0}, {74, 73, 69, 0, 0, 0},
            {74, 73, 78, 0, 0, 0}, {74, 73, 78, 71, 0, 0},
            {74, 73, 79, 78, 71, 0}, {74, 73, 85, 0, 0, 0},
            {74, 85, 0, 0, 0, 0}, {74, 85, 65, 78, 0, 0},
            {74, 85, 69, 0, 0, 0}, {74, 85, 78, 0, 0, 0},
            {75, 65, 0, 0, 0, 0}, {75, 65, 73, 0, 0, 0},
            {75, 65, 78, 0, 0, 0}, {75, 65, 78, 71, 0, 0},
            {75, 65, 79, 0, 0, 0}, {75, 69, 0, 0, 0, 0},
            {75, 69, 78, 0, 0, 0}, {75, 69, 78, 71, 0, 0},
            {75, 79, 78, 71, 0, 0}, {75, 79, 85, 0, 0, 0},
            {75, 85, 0, 0, 0, 0}, {75, 85, 65, 0, 0, 0},
            {75, 85, 65, 73, 0, 0}, {75, 85, 65, 78, 0, 0},
            {75, 85, 65, 78, 71, 0}, {75, 85, 73, 0, 0, 0},
            {75, 85, 78, 0, 0, 0}, {75, 85, 79, 0, 0, 0},
            {76, 65, 0, 0, 0, 0}, {76, 65, 73, 0, 0, 0},
            {76, 65, 78, 0, 0, 0}, {76, 65, 78, 71, 0, 0},
            {76, 65, 79, 0, 0, 0}, {76, 69, 0, 0, 0, 0},
            {76, 69, 73, 0, 0, 0}, {76, 69, 78, 71, 0, 0},
            {76, 73, 0, 0, 0, 0}, {76, 73, 65, 0, 0, 0},
            {76, 73, 65, 78, 0, 0}, {76, 73, 65, 78, 71, 0},
            {76, 73, 65, 79, 0, 0}, {76, 73, 69, 0, 0, 0},
            {76, 73, 78, 0, 0, 0}, {76, 73, 78, 71, 0, 0},
            {76, 73, 85, 0, 0, 0}, {76, 79, 0, 0, 0, 0},
            {76, 79, 78, 71, 0, 0}, {76, 79, 85, 0, 0, 0},
            {76, 85, 0, 0, 0, 0}, {76, 85, 65, 78, 0, 0},
            {76, 85, 69, 0, 0, 0}, {76, 85, 78, 0, 0, 0},
            {76, 85, 79, 0, 0, 0}, {77, 0, 0, 0, 0, 0},
            {77, 65, 0, 0, 0, 0}, {77, 65, 73, 0, 0, 0},
            {77, 65, 78, 0, 0, 0}, {77, 65, 78, 71, 0, 0},
            {77, 65, 79, 0, 0, 0}, {77, 69, 0, 0, 0, 0},
            {77, 69, 73, 0, 0, 0}, {77, 69, 78, 0, 0, 0},
            {77, 69, 78, 71, 0, 0}, {77, 73, 0, 0, 0, 0},
            {77, 73, 65, 78, 0, 0}, {77, 73, 65, 79, 0, 0},
            {77, 73, 69, 0, 0, 0}, {77, 73, 78, 0, 0, 0},
            {77, 73, 78, 71, 0, 0}, {77, 73, 85, 0, 0, 0},
            {77, 79, 0, 0, 0, 0}, {77, 79, 85, 0, 0, 0},
            {77, 85, 0, 0, 0, 0}, {78, 0, 0, 0, 0, 0},
            {78, 65, 0, 0, 0, 0}, {78, 65, 73, 0, 0, 0},
            {78, 65, 78, 0, 0, 0}, {78, 65, 78, 71, 0, 0},
            {78, 65, 79, 0, 0, 0}, {78, 69, 0, 0, 0, 0},
            {78, 69, 73, 0, 0, 0}, {78, 69, 78, 0, 0, 0},
            {78, 69, 78, 71, 0, 0}, {78, 73, 0, 0, 0, 0},
            {78, 73, 65, 78, 0, 0}, {78, 73, 65, 78, 71, 0},
            {78, 73, 65, 79, 0, 0}, {78, 73, 69, 0, 0, 0},
            {78, 73, 78, 0, 0, 0}, {78, 73, 78, 71, 0, 0},
            {78, 73, 85, 0, 0, 0}, {78, 79, 78, 71, 0, 0},
            {78, 79, 85, 0, 0, 0}, {78, 85, 0, 0, 0, 0},
            {78, 85, 65, 78, 0, 0}, {78, 85, 69, 0, 0, 0},
            {78, 85, 78, 0, 0, 0}, {78, 85, 79, 0, 0, 0},
            {79, 0, 0, 0, 0, 0}, {79, 85, 0, 0, 0, 0},
            {80, 65, 0, 0, 0, 0}, {80, 65, 73, 0, 0, 0},
            {80, 65, 78, 0, 0, 0}, {80, 65, 78, 71, 0, 0},
            {80, 65, 79, 0, 0, 0}, {80, 69, 73, 0, 0, 0},
            {80, 69, 78, 0, 0, 0}, {80, 69, 78, 71, 0, 0},
            {80, 73, 0, 0, 0, 0}, {80, 73, 65, 78, 0, 0},
            {80, 73, 65, 79, 0, 0}, {80, 73, 69, 0, 0, 0},
            {80, 73, 78, 0, 0, 0}, {80, 73, 78, 71, 0, 0},
            {80, 79, 0, 0, 0, 0}, {80, 79, 85, 0, 0, 0},
            {80, 85, 0, 0, 0, 0}, {81, 73, 0, 0, 0, 0},
            {81, 73, 65, 0, 0, 0}, {81, 73, 65, 78, 0, 0},
            {81, 73, 65, 78, 71, 0}, {81, 73, 65, 79, 0, 0},
            {81, 73, 69, 0, 0, 0}, {81, 73, 78, 0, 0, 0},
            {81, 73, 78, 71, 0, 0}, {81, 73, 79, 78, 71, 0},
            {81, 73, 85, 0, 0, 0}, {81, 85, 0, 0, 0, 0},
            {81, 85, 65, 78, 0, 0}, {81, 85, 69, 0, 0, 0},
            {81, 85, 78, 0, 0, 0}, {82, 65, 78, 0, 0, 0},
            {82, 65, 78, 71, 0, 0}, {82, 65, 79, 0, 0, 0},
            {82, 69, 0, 0, 0, 0}, {82, 69, 78, 0, 0, 0},
            {82, 69, 78, 71, 0, 0}, {82, 73, 0, 0, 0, 0},
            {82, 79, 78, 71, 0, 0}, {82, 79, 85, 0, 0, 0},
            {82, 85, 0, 0, 0, 0}, {82, 85, 65, 0, 0, 0},
            {82, 85, 65, 78, 0, 0}, {82, 85, 73, 0, 0, 0},
            {82, 85, 78, 0, 0, 0}, {82, 85, 79, 0, 0, 0},
            {83, 65, 0, 0, 0, 0}, {83, 65, 73, 0, 0, 0},
            {83, 65, 78, 0, 0, 0}, {83, 65, 78, 71, 0, 0},
            {83, 65, 79, 0, 0, 0}, {83, 69, 0, 0, 0, 0},
            {83, 69, 78, 0, 0, 0}, {83, 69, 78, 71, 0, 0},
            {83, 72, 65, 0, 0, 0}, {83, 72, 65, 73, 0, 0},
            {83, 72, 65, 78, 0, 0}, {83, 72, 65, 78, 71, 0},
            {83, 72, 65, 79, 0, 0}, {83, 72, 69, 0, 0, 0},
            {83, 72, 69, 78, 0, 0}, {88, 73, 78, 0, 0, 0},
            {83, 72, 69, 78, 0, 0}, {83, 72, 69, 78, 71, 0},
            {83, 72, 73, 0, 0, 0}, {83, 72, 79, 85, 0, 0},
            {83, 72, 85, 0, 0, 0}, {83, 72, 85, 65, 0, 0},
            {83, 72, 85, 65, 73, 0}, {83, 72, 85, 65, 78, 0},
            {83, 72, 85, 65, 78, 71}, {83, 72, 85, 73, 0, 0},
            {83, 72, 85, 78, 0, 0}, {83, 72, 85, 79, 0, 0},
            {83, 73, 0, 0, 0, 0}, {83, 79, 78, 71, 0, 0},
            {83, 79, 85, 0, 0, 0}, {83, 85, 0, 0, 0, 0},
            {83, 85, 65, 78, 0, 0}, {83, 85, 73, 0, 0, 0},
            {83, 85, 78, 0, 0, 0}, {83, 85, 79, 0, 0, 0},
            {84, 65, 0, 0, 0, 0}, {84, 65, 73, 0, 0, 0},
            {84, 65, 78, 0, 0, 0}, {84, 65, 78, 71, 0, 0},
            {84, 65, 79, 0, 0, 0}, {84, 69, 0, 0, 0, 0},
            {84, 69, 78, 71, 0, 0}, {84, 73, 0, 0, 0, 0},
            {84, 73, 65, 78, 0, 0}, {84, 73, 65, 79, 0, 0},
            {84, 73, 69, 0, 0, 0}, {84, 73, 78, 71, 0, 0},
            {84, 79, 78, 71, 0, 0}, {84, 79, 85, 0, 0, 0},
            {84, 85, 0, 0, 0, 0}, {84, 85, 65, 78, 0, 0},
            {84, 85, 73, 0, 0, 0}, {84, 85, 78, 0, 0, 0},
            {84, 85, 79, 0, 0, 0}, {87, 65, 0, 0, 0, 0},
            {87, 65, 73, 0, 0, 0}, {87, 65, 78, 0, 0, 0},
            {87, 65, 78, 71, 0, 0}, {87, 69, 73, 0, 0, 0},
            {87, 69, 78, 0, 0, 0}, {87, 69, 78, 71, 0, 0},
            {87, 79, 0, 0, 0, 0}, {87, 85, 0, 0, 0, 0},
            {88, 73, 0, 0, 0, 0}, {88, 73, 65, 0, 0, 0},
            {88, 73, 65, 78, 0, 0}, {88, 73, 65, 78, 71, 0},
            {88, 73, 65, 79, 0, 0}, {88, 73, 69, 0, 0, 0},
            {88, 73, 78, 0, 0, 0}, {88, 73, 78, 71, 0, 0},
            {88, 73, 79, 78, 71, 0}, {88, 73, 85, 0, 0, 0},
            {88, 85, 0, 0, 0, 0}, {88, 85, 65, 78, 0, 0},
            {88, 85, 69, 0, 0, 0}, {88, 85, 78, 0, 0, 0},
            {89, 65, 0, 0, 0, 0}, {89, 65, 78, 0, 0, 0},
            {89, 65, 78, 71, 0, 0}, {89, 65, 79, 0, 0, 0},
            {89, 69, 0, 0, 0, 0}, {89, 73, 0, 0, 0, 0},
            {89, 73, 78, 0, 0, 0}, {89, 73, 78, 71, 0, 0},
            {89, 79, 0, 0, 0, 0}, {89, 79, 78, 71, 0, 0},
            {89, 79, 85, 0, 0, 0}, {89, 85, 0, 0, 0, 0},
            {89, 85, 65, 78, 0, 0}, {89, 85, 69, 0, 0, 0},
            {89, 85, 78, 0, 0, 0}, {74, 85, 78, 0, 0, 0},
            {89, 85, 78, 0, 0, 0}, {90, 65, 0, 0, 0, 0},
            {90, 65, 73, 0, 0, 0}, {90, 65, 78, 0, 0, 0},
            {90, 65, 78, 71, 0, 0}, {90, 65, 79, 0, 0, 0},
            {90, 69, 0, 0, 0, 0}, {90, 69, 73, 0, 0, 0},
            {90, 69, 78, 0, 0, 0}, {90, 69, 78, 71, 0, 0},
            {90, 72, 65, 0, 0, 0}, {90, 72, 65, 73, 0, 0},
            {90, 72, 65, 78, 0, 0}, {90, 72, 65, 78, 71, 0},
            {67, 72, 65, 78, 71, 0}, {90, 72, 65, 78, 71, 0},
            {90, 72, 65, 79, 0, 0}, {90, 72, 69, 0, 0, 0},
            {90, 72, 69, 78, 0, 0}, {90, 72, 69, 78, 71, 0},
            {90, 72, 73, 0, 0, 0}, {83, 72, 73, 0, 0, 0},
            {90, 72, 73, 0, 0, 0}, {90, 72, 79, 78, 71, 0},
            {90, 72, 79, 85, 0, 0}, {90, 72, 85, 0, 0, 0},
            {90, 72, 85, 65, 0, 0}, {90, 72, 85, 65, 73, 0},
            {90, 72, 85, 65, 78, 0}, {90, 72, 85, 65, 78, 71},
            {90, 72, 85, 73, 0, 0}, {90, 72, 85, 78, 0, 0},
            {90, 72, 85, 79, 0, 0}, {90, 73, 0, 0, 0, 0},
            {90, 79, 78, 71, 0, 0}, {90, 79, 85, 0, 0, 0},
            {90, 85, 0, 0, 0, 0}, {90, 85, 65, 78, 0, 0},
            {90, 85, 73, 0, 0, 0}, {90, 85, 78, 0, 0, 0},
            {90, 85, 79, 0, 0, 0}, {0, 0, 0, 0, 0, 0},
            {83, 72, 65, 78, 0, 0}, {0, 0, 0, 0, 0, 0},};
    private static final String TAG = "HanziToPinyin";
    // Turn on this flag when we want to check internal data structure.
    private static final boolean DEBUG = false;
    /**
     * First and last Chinese character with known Pinyin according to zh collation
     */
    private static final String FIRST_PINYIN_UNIHAN = "\u963F";
    private static final String LAST_PINYIN_UNIHAN = "\u9FFF";

    private static final Collator COLLATOR = Collator.getInstance(Locale.CHINA);

    private static HanziToPinyin sInstance;
    private final boolean mHasChinaCollator;

    protected HanziToPinyin(boolean hasChinaCollator) {
        mHasChinaCollator = hasChinaCollator;
    }

    public static HanziToPinyin getInstance() {
        synchronized (HanziToPinyin.class) {
            if (sInstance != null) {
                return sInstance;
            }
            // Check if zh_CN collation data is available
            final Locale[] locale = Collator.getAvailableLocales();
            for (Locale value : locale) {
                if (value.equals(Locale.CHINA) || value.getLanguage().contains("zh")) {
                    // Do self validation just once.
                    if (DEBUG) {
                        Log.d(TAG, "Self validation. Result: " + doSelfValidation());
                    }
                    sInstance = new HanziToPinyin(true);
                    return sInstance;
                }
            }
            if (sInstance == null) {//这个判断是用于处理国产ROM的兼容性问题
                if (Locale.CHINA.equals(Locale.getDefault())) {
                    sInstance = new HanziToPinyin(true);
                    return sInstance;
                }
            }
            Log.w(TAG, "There is no Chinese collator, HanziToPinyin is disabled");
            sInstance = new HanziToPinyin(false);
            return sInstance;
        }
    }

    /**
     * Validate if our internal table has some wrong value.
     *
     * @return true when the table looks correct.
     */
    private static boolean doSelfValidation() {
        char lastChar = UNIHANS[0];
        String lastString = Character.toString(lastChar);
        for (char c : UNIHANS) {
            if (lastChar == c) {
                continue;
            }
            final String curString = Character.toString(c);
            int cmp = COLLATOR.compare(lastString, curString);
            if (cmp >= 0) {
                Log.e(TAG, "Internal error in Unihan table. " + "The last string \"" + lastString
                        + "\" is greater than current string \"" + curString + "\".");
                return false;
            }
            lastString = curString;
        }
        return true;
    }

    private Token getToken(char character) {
        Token token = new Token();
        final String letter = Character.toString(character);
        token.source = letter;
        int offset = -1;
        int cmp;
        if (character < 256) {
            token.type = Token.LATIN;
            token.target = letter;
            return token;
        } else {
            cmp = COLLATOR.compare(letter, FIRST_PINYIN_UNIHAN);
            if (cmp < 0) {
                token.type = Token.UNKNOWN;
                token.target = letter;
                return token;
            } else if (cmp == 0) {
                token.type = Token.PINYIN;
                offset = 0;
            } else {
                cmp = COLLATOR.compare(letter, LAST_PINYIN_UNIHAN);
                if (cmp > 0) {
                    token.type = Token.UNKNOWN;
                    token.target = letter;
                    return token;
                } else if (cmp == 0) {
                    token.type = Token.PINYIN;
                    offset = UNIHANS.length - 1;
                }
            }
        }

        token.type = Token.PINYIN;
        if (offset < 0) {
            int begin = 0;
            int end = UNIHANS.length - 1;
            while (begin <= end) {
                offset = (begin + end) / 2;
                final String unihan = Character.toString(UNIHANS[offset]);
                cmp = COLLATOR.compare(letter, unihan);
                if (cmp == 0) {
                    break;
                } else if (cmp > 0) {
                    begin = offset + 1;
                } else {
                    end = offset - 1;
                }
            }
        }
        if (cmp < 0) {
            offset--;
        }
        StringBuilder pinyin = new StringBuilder();
        for (int j = 0; j < PINYINS[offset].length && PINYINS[offset][j] != 0; j++) {
            pinyin.append((char) PINYINS[offset][j]);
        }
        token.target = pinyin.toString();
        if (TextUtils.isEmpty(token.target)) {
            token.type = Token.UNKNOWN;
            token.target = token.source;
        }
        return token;
    }

    /**
     * Convert the input to a array of tokens. The sequence of ASCII or Unknown characters without
     * space will be put into a Token, One Hanzi character which has pinyin will be treated as a
     * Token. If these is no China collator, the empty token array is returned.
     */
    public ArrayList<Token> get(final String input) {
        ArrayList<Token> tokens = new ArrayList<>();
        if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
            // return empty tokens.
            return tokens;
        }
        final int inputLength = input.length();
        final StringBuilder sb = new StringBuilder();
        int tokenType = Token.LATIN;
        // Go through the input, create a new token when
        // a. Token type changed
        // b. Get the Pinyin of current charater.
        // c. current character is space.
        for (int i = 0; i < inputLength; i++) {
            final char character = input.charAt(i);
            if (character == ' ') {
                if (sb.length() > 0) {
                    addToken(sb, tokens, tokenType);
                }
            } else if (character < 256) {
                if (tokenType != Token.LATIN && sb.length() > 0) {
                    addToken(sb, tokens, tokenType);
                }
                tokenType = Token.LATIN;
                sb.append(character);
            } else {
                Token t = getToken(character);
                if (t.type == Token.PINYIN) {
                    if (sb.length() > 0) {
                        addToken(sb, tokens, tokenType);
                    }
                    tokens.add(t);
                    tokenType = Token.PINYIN;
                } else {
                    if (tokenType != t.type && sb.length() > 0) {
                        addToken(sb, tokens, tokenType);
                    }
                    tokenType = t.type;
                    sb.append(character);
                }
            }
        }
        if (sb.length() > 0) {
            addToken(sb, tokens, tokenType);
        }
        return tokens;
    }

    private void addToken(
            final StringBuilder sb, final ArrayList<Token> tokens, final int tokenType) {
        String str = sb.toString();
        tokens.add(new Token(tokenType, str, str));
        sb.setLength(0);
    }

    public String toPinyinString(String string) {
        if (string == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        ArrayList<Token> tokens = get(string);
        for (Token token : tokens) {
            sb.append(token.target);
        }
        return sb.toString().toLowerCase();
    }

    public static class Token {
        /**
         * Separator between target string for each source char
         */
        public static final String SEPARATOR = " ";

        public static final int LATIN = 1;
        public static final int PINYIN = 2;
        public static final int UNKNOWN = 3;
        /**
         * Type of this token, ASCII, PINYIN or UNKNOWN.
         */
        public int type;
        /**
         * Original string before translation.
         */
        public String source;
        /**
         * Translated string of source. For Han, target is corresponding Pinyin. Otherwise target is
         * original string in source.
         */
        public String target;

        public Token() {
        }

        public Token(int type, String source, String target) {
            this.type = type;
            this.source = source;
            this.target = target;
        }
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/KsuCli.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.content.ContentResolver
import android.content.Context
import android.database.Cursor
import android.net.Uri
import android.os.Environment
import android.os.Parcelable
import android.os.SystemClock
import android.provider.OpenableColumns
import android.system.Os
import android.util.Log
import com.topjohnwu.superuser.CallbackList
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.ShellUtils
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.BuildConfig
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import org.json.JSONArray
import java.io.File


/**
 * @author weishu
 * @date 2023/1/1.
 */
private const val TAG = "KsuCli"

private fun getKsuDaemonPath(): String {
    return ksuApp.applicationInfo.nativeLibraryDir + File.separator + "libksud.so"
}

data class FlashResult(val code: Int, val err: String, val showReboot: Boolean) {
    constructor(result: Shell.Result, showReboot: Boolean) : this(result.code, result.err.joinToString("\n"), showReboot)
    constructor(result: Shell.Result) : this(result, result.isSuccess)
}

object KsuCli {
    val SHELL: Shell = createRootShell()
    val GLOBAL_MNT_SHELL: Shell = createRootShell(true)
}

fun getRootShell(globalMnt: Boolean = false): Shell {
    return if (globalMnt) KsuCli.GLOBAL_MNT_SHELL else {
        KsuCli.SHELL
    }
}

inline fun <T> withNewRootShell(
    globalMnt: Boolean = false,
    block: Shell.() -> T
): T {
    return createRootShell(globalMnt).use(block)
}

fun Uri.getFileName(context: Context): String? {
    var fileName: String? = null
    val contentResolver: ContentResolver = context.contentResolver
    val cursor: Cursor? = contentResolver.query(this, null, null, null, null)
    cursor?.use {
        if (it.moveToFirst()) {
            fileName = it.getString(it.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME))
        }
    }
    return fileName
}

fun createRootShell(globalMnt: Boolean = false): Shell {
    Shell.enableVerboseLogging = BuildConfig.DEBUG
    val builder = Shell.Builder.create()
    return try {
        if (globalMnt) {
            builder.build(getKsuDaemonPath(), "debug", "su", "-g")
        } else {
            builder.build(getKsuDaemonPath(), "debug", "su")
        }
    } catch (e: Throwable) {
        Log.w(TAG, "ksu failed: ", e)
        try {
            if (globalMnt) {
                builder.build("su", "-mm")
            } else {
                builder.build("su")
            }
        } catch (e: Throwable) {
            Log.e(TAG, "su failed: ", e)
            builder.build("sh")
        }
    }
}

fun execKsud(args: String, newShell: Boolean = false): Boolean {
    return if (newShell) {
        withNewRootShell {
            ShellUtils.fastCmdResult(this, "${getKsuDaemonPath()} $args")
        }
    } else {
        ShellUtils.fastCmdResult(getRootShell(), "${getKsuDaemonPath()} $args")
    }
}

suspend fun getFeatureStatus(feature: String): String = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val out = shell.newJob()
        .add("${getKsuDaemonPath()} feature check $feature").to(ArrayList<String>(), null).exec().out
    out.firstOrNull()?.trim().orEmpty()
}

suspend fun getFeaturePersistValue(feature: String): Long? = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val out = shell.newJob()
        .add("${getKsuDaemonPath()} feature get --config $feature").to(ArrayList<String>(), null).exec().out
    val valueLine = out.firstOrNull { it.trim().startsWith("Value:") } ?: return@withContext null
    valueLine.substringAfter("Value:").trim().toLongOrNull()
}

fun install() {
    val start = SystemClock.elapsedRealtime()
    val magiskboot = File(ksuApp.applicationInfo.nativeLibraryDir, "libmagiskboot.so").absolutePath
    val result = execKsud("install --magiskboot $magiskboot", true)
    Log.w(TAG, "install result: $result, cost: ${SystemClock.elapsedRealtime() - start}ms")
}

fun listModules(): String {
    val shell = getRootShell()

    val out = shell.newJob()
        .add("${getKsuDaemonPath()} module list").to(ArrayList(), null).exec().out
    return out.joinToString("\n").ifBlank { "[]" }
}

fun getModuleCount(): Int {
    val result = listModules()
    runCatching {
        val array = JSONArray(result)
        return array.length()
    }.getOrElse { return 0 }
}

fun getSuperuserCount(): Int {
    return Natives.getSuperuserCount()
}

fun toggleModule(id: String, enable: Boolean): Boolean {
    val cmd = if (enable) {
        "module enable $id"
    } else {
        "module disable $id"
    }
    val result = execKsud(cmd, true)
    Log.i(TAG, "$cmd result: $result")
    return result
}

fun undoUninstallModule(id: String): Boolean {
    val cmd = "module undo-uninstall $id"
    val result = execKsud(cmd, true)
    Log.i(TAG, "undo uninstall module $id result: $result")
    return result
}

fun uninstallModule(id: String): Boolean {
    val cmd = "module uninstall $id"
    val result = execKsud(cmd, true)
    Log.i(TAG, "uninstall module $id result: $result")
    return result
}

private fun flashWithIO(
    cmd: String,
    onStdout: (String) -> Unit,
    onStderr: (String) -> Unit
): Shell.Result {

    val stdoutCallback: CallbackList<String?> = object : CallbackList<String?>() {
        override fun onAddElement(s: String?) {
            onStdout(s ?: "")
        }
    }

    val stderrCallback: CallbackList<String?> = object : CallbackList<String?>() {
        override fun onAddElement(s: String?) {
            onStderr(s ?: "")
        }
    }

    return withNewRootShell {
        newJob().add(cmd).to(stdoutCallback, stderrCallback).exec()
    }
}

fun flashModule(
    uri: Uri,
    onStdout: (String) -> Unit,
    onStderr: (String) -> Unit
): FlashResult {
    val resolver = ksuApp.contentResolver
    with(resolver.openInputStream(uri)) {
        val file = File(ksuApp.cacheDir, "module.zip")
        file.outputStream().use { output ->
            this?.copyTo(output)
        }
        val cmd = "module install ${file.absolutePath}"
        val result = flashWithIO("${getKsuDaemonPath()} $cmd", onStdout, onStderr)
        Log.i("KernelSU", "install module $uri result: $result")

        file.delete()

        return FlashResult(result)
    }
}

fun runModuleAction(
    moduleId: String, onStdout: (String) -> Unit, onStderr: (String) -> Unit
): Boolean {
    val shell = createRootShell(true)

    val stdoutCallback: CallbackList<String?> = object : CallbackList<String?>() {
        override fun onAddElement(s: String?) {
            onStdout(s ?: "")
        }
    }

    val stderrCallback: CallbackList<String?> = object : CallbackList<String?>() {
        override fun onAddElement(s: String?) {
            onStderr(s ?: "")
        }
    }

    val result = shell.newJob().add("${getKsuDaemonPath()} module action $moduleId")
        .to(stdoutCallback, stderrCallback).exec()
    Log.i("KernelSU", "Module runAction result: $result")

    return result.isSuccess
}

fun restoreBoot(
    onStdout: (String) -> Unit, onStderr: (String) -> Unit
): FlashResult {
    val magiskboot = File(ksuApp.applicationInfo.nativeLibraryDir, "libmagiskboot.so")
    val result = flashWithIO("${getKsuDaemonPath()} boot-restore -f --magiskboot $magiskboot", onStdout, onStderr)
    return FlashResult(result)
}

fun uninstallPermanently(
    onStdout: (String) -> Unit, onStderr: (String) -> Unit
): FlashResult {
    val magiskboot = File(ksuApp.applicationInfo.nativeLibraryDir, "libmagiskboot.so")
    val result = flashWithIO("${getKsuDaemonPath()} uninstall --magiskboot $magiskboot", onStdout, onStderr)
    return FlashResult(result)
}

@Parcelize
sealed class LkmSelection : Parcelable {
    @Parcelize
    data class LkmUri(val uri: Uri) : LkmSelection()
    @Parcelize
    data class KmiString(val value: String) : LkmSelection()
    @Parcelize
    data object KmiNone : LkmSelection()
}

fun installBoot(
    bootUri: Uri?,
    lkm: LkmSelection,
    ota: Boolean,
    partition: String?,
    onStdout: (String) -> Unit,
    onStderr: (String) -> Unit,
): FlashResult {
    val resolver = ksuApp.contentResolver

    val bootFile = bootUri?.let { uri ->
        with(resolver.openInputStream(uri)) {
            val bootFile = File(ksuApp.cacheDir, "boot.img")
            bootFile.outputStream().use { output ->
                this?.copyTo(output)
            }

            bootFile
        }
    }

    val magiskboot = File(ksuApp.applicationInfo.nativeLibraryDir, "libmagiskboot.so")
    var cmd = "boot-patch --magiskboot ${magiskboot.absolutePath}"

    cmd += if (bootFile == null) {
        // no boot.img, use -f to force install
        " -f"
    } else {
        " -b ${bootFile.absolutePath}"
    }

    if (ota) {
        cmd += " -u"
    }

    var lkmFile: File? = null
    when (lkm) {
        is LkmSelection.LkmUri -> {
            lkmFile = with(resolver.openInputStream(lkm.uri)) {
                val file = File(ksuApp.cacheDir, "kernelsu-tmp-lkm.ko")
                file.outputStream().use { output ->
                    this?.copyTo(output)
                }

                file
            }
            cmd += " -m ${lkmFile.absolutePath}"
        }

        is LkmSelection.KmiString -> {
            cmd += " --kmi ${lkm.value}"
        }

        LkmSelection.KmiNone -> {
            // do nothing
        }
    }

    // output dir
    val downloadsDir =
        Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
    cmd += " -o $downloadsDir"

    partition?.let { part ->
        cmd += " --partition $part"
    }

    val result = flashWithIO("${getKsuDaemonPath()} $cmd", onStdout, onStderr)
    Log.i("KernelSU", "install boot result: ${result.isSuccess}")

    bootFile?.delete()
    lkmFile?.delete()

    // if boot uri is empty, it is direct install, when success, we should show reboot button
    val showReboot = bootUri == null && result.isSuccess // we create a temporary val here, to avoid calc showReboot double
    if (showReboot) { // because we decide do not update ksud when startActivity
        install() // install ksud here
    }
    return FlashResult(result, showReboot)
}

fun reboot(reason: String = "") {
    val shell = getRootShell()
    if (reason == "recovery") {
        // KEYCODE_POWER = 26, hide incorrect "Factory data reset" message
        ShellUtils.fastCmd(shell, "/system/bin/input keyevent 26")
    }
    ShellUtils.fastCmd(shell, "/system/bin/svc power reboot $reason || /system/bin/reboot $reason")
}

fun rootAvailable(): Boolean {
    val shell = getRootShell()
    return shell.isRoot
}

suspend fun getCurrentKmi(): String = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val cmd = "boot-info current-kmi"
    ShellUtils.fastCmd(shell, "${getKsuDaemonPath()} $cmd")
}

suspend fun getSupportedKmis(): List<String> = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val cmd = "boot-info supported-kmis"
    val out = shell.newJob().add("${getKsuDaemonPath()} $cmd").to(ArrayList(), null).exec().out
    out.filter { it.isNotBlank() }.map { it.trim() }
}

suspend fun isAbDevice(): Boolean = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val cmd = "boot-info is-ab-device"
    ShellUtils.fastCmd(shell, "${getKsuDaemonPath()} $cmd").trim().toBoolean()
}

suspend fun getDefaultPartition(): String = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    if (shell.isRoot) {
        val cmd = "boot-info default-partition"
        ShellUtils.fastCmd(shell, "${getKsuDaemonPath()} $cmd").trim()
    } else {
        if (!Os.uname().release.contains("android12-")) "init_boot" else "boot"
    }
}

suspend fun getSlotSuffix(ota: Boolean): String = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val cmd = if (ota) {
        "boot-info slot-suffix --ota"
    } else {
        "boot-info slot-suffix"
    }
    ShellUtils.fastCmd(shell, "${getKsuDaemonPath()} $cmd").trim()
}

suspend fun getAvailablePartitions(): List<String> = withContext(Dispatchers.IO) {
    val shell = getRootShell()
    val cmd = "boot-info available-partitions"
    val out = shell.newJob().add("${getKsuDaemonPath()} $cmd").to(ArrayList(), null).exec().out
    out.filter { it.isNotBlank() }.map { it.trim() }
}

fun hasMagisk(): Boolean {
    val shell = getRootShell(true)
    val result = shell.newJob().add("which magisk").exec()
    Log.i(TAG, "has magisk: ${result.isSuccess}")
    return result.isSuccess
}

fun isSepolicyValid(rules: String?): Boolean {
    if (rules == null) {
        return true
    }
    val shell = getRootShell()
    val result =
        shell.newJob().add("${getKsuDaemonPath()} sepolicy check '$rules'").to(ArrayList(), null)
            .exec()
    return result.isSuccess
}

fun getSepolicy(pkg: String): String {
    val shell = getRootShell()
    val result =
        shell.newJob().add("${getKsuDaemonPath()} profile get-sepolicy $pkg").to(ArrayList(), null)
            .exec()
    Log.i(TAG, "code: ${result.code}, out: ${result.out}, err: ${result.err}")
    return result.out.joinToString("\n")
}

fun setSepolicy(pkg: String, rules: String): Boolean {
    val shell = getRootShell()
    val result = shell.newJob().add("${getKsuDaemonPath()} profile set-sepolicy $pkg '$rules'")
        .to(ArrayList(), null).exec()
    Log.i(TAG, "set sepolicy result: ${result.code}")
    return result.isSuccess
}

fun listAppProfileTemplates(): List<String> {
    val shell = getRootShell()
    return shell.newJob().add("${getKsuDaemonPath()} profile list-templates").to(ArrayList(), null)
        .exec().out
}

fun getAppProfileTemplate(id: String): String {
    val shell = getRootShell()
    return shell.newJob().add("${getKsuDaemonPath()} profile get-template '${id}'")
        .to(ArrayList(), null).exec().out.joinToString("\n")
}

fun setAppProfileTemplate(id: String, template: String): Boolean {
    val shell = getRootShell()
    val escapedTemplate = template.replace("\"", "\\\"")
    val cmd = """${getKsuDaemonPath()} profile set-template "$id" "$escapedTemplate'""""
    return shell.newJob().add(cmd)
        .to(ArrayList(), null).exec().isSuccess
}

fun deleteAppProfileTemplate(id: String): Boolean {
    val shell = getRootShell()
    return shell.newJob().add("${getKsuDaemonPath()} profile delete-template '${id}'")
        .to(ArrayList(), null).exec().isSuccess
}

fun forceStopApp(packageName: String) {
    val shell = getRootShell()
    val result = shell.newJob().add("am force-stop $packageName").exec()
    Log.i(TAG, "force stop $packageName result: $result")
}

fun launchApp(packageName: String) {
    val shell = getRootShell()
    val result =
        shell.newJob()
            .add("cmd package resolve-activity --brief $packageName | tail -n 1 | xargs cmd activity start-activity -n")
            .exec()
    Log.i(TAG, "launch $packageName result: $result")
}

fun restartApp(packageName: String) {
    forceStopApp(packageName)
    launchApp(packageName)
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/LogEvent.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.content.Context
import android.os.Build
import android.system.Os
import com.topjohnwu.superuser.ShellUtils
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ui.screen.getManagerVersion
import java.io.File
import java.io.FileWriter
import java.io.PrintWriter
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

fun getBugreportFile(context: Context): File {

    val bugreportDir = File(context.cacheDir, "bugreport")
    bugreportDir.mkdirs()

    val processFile = File(bugreportDir, "process.txt")
    val dmesgFile = File(bugreportDir, "dmesg.txt")
    val logcatFile = File(bugreportDir, "logcat.txt")
    val tombstonesFile = File(bugreportDir, "tombstones.tar.gz")
    val dropboxFile = File(bugreportDir, "dropbox.tar.gz")
    val pstoreFile = File(bugreportDir, "pstore.tar.gz")
    // Xiaomi/Readmi devices have diag in /data/vendor/diag
    val diagFile = File(bugreportDir, "diag.tar.gz")
    val oplusFile = File(bugreportDir, "oplus.tar.gz")
    val bootlogFile = File(bugreportDir, "bootlog.tar.gz")
    val mountsFile = File(bugreportDir, "mounts.txt")
    val fileSystemsFile = File(bugreportDir, "filesystems.txt")
    val adbFileTree = File(bugreportDir, "adb_tree.txt")
    val adbFileDetails = File(bugreportDir, "adb_details.txt")
    val ksuFileSize = File(bugreportDir, "ksu_size.txt")
    val appListFile = File(bugreportDir, "packages.txt")
    val propFile = File(bugreportDir, "props.txt")
    val allowListFile = File(bugreportDir, "allowlist.bin")
    val procModules = File(bugreportDir, "proc_modules.txt")
    val bootConfig = File(bugreportDir, "boot_config.txt")
    val kernelConfig = File(bugreportDir, "defconfig.gz")

    val shell = getRootShell(true)

    // busybox ps has very few features for embed devices
    shell.newJob().add("toybox ps -T -A -w -o PID,TID,UID,COMM,CMDLINE,CMD,LABEL,STAT,WCHAN > ${processFile.absolutePath}").exec()
    shell.newJob().add("dmesg -r > ${dmesgFile.absolutePath}").exec()
    shell.newJob().add("logcat -b all -v uid -d > ${logcatFile.absolutePath}").exec()
    shell.newJob().add("tar -czf ${tombstonesFile.absolutePath} -C /data/tombstones .").exec()
    shell.newJob().add("tar -czf ${dropboxFile.absolutePath} -C /data/system/dropbox .").exec()
    shell.newJob().add("tar -czf ${pstoreFile.absolutePath} -C /sys/fs/pstore .").exec()
    shell.newJob().add("tar -czf ${diagFile.absolutePath} -C /data/vendor/diag . --exclude=./minidump.gz").exec()
    shell.newJob().add("tar -czf ${oplusFile.absolutePath} -C /mnt/oplus/op2/media/log/boot_log/ .").exec()
    shell.newJob().add("tar -czf ${bootlogFile.absolutePath} -C /data/adb/ksu/log .").exec()

    shell.newJob().add("cat /proc/1/mountinfo > ${mountsFile.absolutePath}").exec()
    shell.newJob().add("cat /proc/filesystems > ${fileSystemsFile.absolutePath}").exec()
    shell.newJob().add("busybox tree /data/adb > ${adbFileTree.absolutePath}").exec()
    shell.newJob().add("ls -alRZ /data/adb > ${adbFileDetails.absolutePath}").exec()
    shell.newJob().add("du -sh /data/adb/ksu/* > ${ksuFileSize.absolutePath}").exec()
    shell.newJob().add("cp /data/system/packages.list ${appListFile.absolutePath}").exec()
    shell.newJob().add("getprop > ${propFile.absolutePath}").exec()
    shell.newJob().add("cp /data/adb/ksu/.allowlist ${allowListFile.absolutePath}").exec()
    shell.newJob().add("cp /proc/modules ${procModules.absolutePath}").exec()
    shell.newJob().add("cp /proc/bootconfig ${bootConfig.absolutePath}").exec()
    shell.newJob().add("cp /proc/config.gz ${kernelConfig.absolutePath}").exec()

    val selinux = ShellUtils.fastCmd(shell, "getenforce")

    // basic information
    val buildInfo = File(bugreportDir, "basic.txt")
    PrintWriter(FileWriter(buildInfo)).use { pw ->
        pw.println("Kernel: ${System.getProperty("os.version")}")
        pw.println("BRAND: " + Build.BRAND)
        pw.println("MODEL: " + Build.MODEL)
        pw.println("PRODUCT: " + Build.PRODUCT)
        pw.println("MANUFACTURER: " + Build.MANUFACTURER)
        pw.println("SDK: " + Build.VERSION.SDK_INT)
        pw.println("PREVIEW_SDK: " + Build.VERSION.PREVIEW_SDK_INT)
        pw.println("FINGERPRINT: " + Build.FINGERPRINT)
        pw.println("DEVICE: " + Build.DEVICE)
        pw.println("Manager: " + getManagerVersion(context))
        pw.println("SELinux: $selinux")

        val uname = Os.uname()
        pw.println("KernelRelease: ${uname.release}")
        pw.println("KernelVersion: ${uname.version}")
        pw.println("Machine: ${uname.machine}")
        pw.println("Nodename: ${uname.nodename}")
        pw.println("Sysname: ${uname.sysname}")

        val ksuKernel = Natives.version
        pw.println("KernelSU: $ksuKernel")
        val safeMode = Natives.isSafeMode
        pw.println("SafeMode: $safeMode")
        val lkmMode = Natives.isLkmMode
        pw.println("LKM: $lkmMode")
    }

    // modules
    val modulesFile = File(bugreportDir, "modules.json")
    modulesFile.writeText(listModules())

    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH_mm")
    val current = LocalDateTime.now().format(formatter)

    val targetFile = File(context.cacheDir, "KernelSU_bugreport_${current}.tar.gz")

    shell.newJob().add("tar czf ${targetFile.absolutePath} -C ${bugreportDir.absolutePath} .").exec()
    shell.newJob().add("rm -rf ${bugreportDir.absolutePath}").exec()
    shell.newJob().add("chmod 0644 ${targetFile.absolutePath}").exec()

    return targetFile
}


```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/Network.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities

fun isNetworkAvailable(context: Context): Boolean {
    val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    val network = cm.activeNetwork ?: return false
    val caps = cm.getNetworkCapabilities(network) ?: return false

    val hasTransport = caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
            caps.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) ||
            caps.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)

    return hasTransport &&
            caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
            caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/OemHelper.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.annotation.SuppressLint

@SuppressLint("PrivateApi")
private fun getSystemProperty(key: String): String {
    return try {
        val props = Class.forName("android.os.SystemProperties")
        props.getMethod("get", String::class.java).invoke(null, key) as? String ?: ""
    } catch (_: Throwable) {
        ""
    }
}

fun isMiui(): Boolean {
    return getSystemProperty("ro.miui.ui.version.name").isNotEmpty()
}

fun isHyperOS(): Boolean {
    return getSystemProperty("ro.mi.os.version.name").isNotEmpty()
}

fun isColorOS(): Boolean {
    return getSystemProperty("ro.build.version.oplus.api").isNotEmpty() || getSystemProperty("ro.vendor.oplus.market.name").isNotEmpty()
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/SELinuxChecker.kt`:

```kt
package me.weishu.kernelsu.ui.util

import androidx.compose.runtime.Composable
import androidx.compose.ui.res.stringResource
import com.topjohnwu.superuser.Shell
import me.weishu.kernelsu.R

@Composable
fun getSELinuxStatus(): String {
    val shell = Shell.Builder.create().build("sh")

    val stdoutList = ArrayList<String>()
    val stderrList = ArrayList<String>()
    val result = shell.use {
        it.newJob().add("getenforce").to(stdoutList, stderrList).exec()
    }
    val stdout = stdoutList.joinToString("\n").trim()
    val stderr = stderrList.joinToString("\n").trim()

    if (result.isSuccess) {
        return when (stdout) {
            "Enforcing" -> stringResource(R.string.selinux_status_enforcing)
            "Permissive" -> stringResource(R.string.selinux_status_permissive)
            "Disabled" -> stringResource(R.string.selinux_status_disabled)
            else -> stringResource(R.string.selinux_status_unknown)
        }
    }

    return if (stderr.endsWith("Permission denied")) {
        stringResource(R.string.selinux_status_enforcing)
    } else {
        stringResource(R.string.selinux_status_unknown)
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/Serialization.kt`:

```kt
package me.weishu.kernelsu.ui.util

import android.os.Parcel
import android.os.Parcelable
import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.ByteArraySerializer
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import me.weishu.kernelsu.ui.screen.FlashIt
import me.weishu.kernelsu.ui.screen.RepoModuleArg
import me.weishu.kernelsu.ui.viewmodel.TemplateViewModel

object FlashItSerializer : BaseParcelableSerializer<FlashIt>(FlashIt::class.java)
object RepoModuleArgSerializer : BaseParcelableSerializer<RepoModuleArg>(RepoModuleArg::class.java)
object TemplateInfoSerializer : BaseParcelableSerializer<TemplateViewModel.TemplateInfo>(TemplateViewModel.TemplateInfo::class.java)

open class BaseParcelableSerializer<T : Parcelable>(
    private val clazz: Class<T>
) : KSerializer<T> {

    private val delegate = ByteArraySerializer()
    override val descriptor = delegate.descriptor

    private val creator: Parcelable.Creator<T> by lazy {
        @Suppress("UNCHECKED_CAST")
        clazz.getField("CREATOR").get(null) as Parcelable.Creator<T>
    }

    override fun serialize(encoder: Encoder, value: T) {
        val parcel = Parcel.obtain()
        try {
            value.writeToParcel(parcel, 0)
            val bytes = parcel.marshall()
            encoder.encodeSerializableValue(delegate, bytes)
        } finally {
            parcel.recycle()
        }
    }

    override fun deserialize(decoder: Decoder): T {
        val bytes = decoder.decodeSerializableValue(delegate)
        val parcel = Parcel.obtain()
        try {
            parcel.unmarshall(bytes, 0, bytes.size)
            parcel.setDataPosition(0)
            return creator.createFromParcel(parcel)
        } finally {
            parcel.recycle()
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/UidGroupUtils.kt`:

```kt
package me.weishu.kernelsu.ui.util

import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel

private val PREFERRED_PKG_BY_SUID = mapOf(
    "android.uid.system" to "android",
    "android.uid.phone" to "com.android.phone",
    "android.uid.bluetooth" to "com.android.bluetooth",
    "android.uid.nfc" to "com.android.nfc",
)

fun pickPrimary(apps: List<SuperUserViewModel.AppInfo>): SuperUserViewModel.AppInfo {
    if (apps.isEmpty()) throw IllegalArgumentException("apps must not be empty")
    val labeled = apps.filter { it.packageInfo.sharedUserLabel != 0 }
    if (labeled.isNotEmpty()) {
        return labeled.minWith(compareBy({ it.packageName.length }, { it.packageName }))
    }
    val bySuid = apps.groupBy { it.packageInfo.sharedUserId ?: "" }
        .filterKeys { it.startsWith("android.uid.") }
    if (bySuid.isEmpty()) return apps.first()
    val suid = bySuid.keys.minOf { it }
    val group = bySuid[suid] ?: apps
    val preferredPkg = PREFERRED_PKG_BY_SUID[suid]
    preferredPkg?.let { pkg ->
        group.firstOrNull { it.packageName == pkg }?.let { return it }
    }
    return group.minWith(compareBy({ it.packageName.length }, { it.packageName }))
}

val ownerNameCache = mutableMapOf<Int, String>()
fun ownerNameForUid(uid: Int): String {
    ownerNameCache[uid]?.let { return it.ifEmpty { uid.toString() } }
    val apps = SuperUserViewModel.apps.filter { it.uid == uid }
    val labeledApp = apps.firstOrNull { it.packageInfo.sharedUserLabel != 0 }
    val name = if (labeledApp != null) {
        val pm = ksuApp.packageManager
        val resId = labeledApp.packageInfo.sharedUserLabel
        val text = runCatching { pm.getText(labeledApp.packageName, resId, labeledApp.packageInfo.applicationInfo) }.getOrNull()
        text?.toString() ?: ""
    } else {
        Natives.getUserName(uid) ?: ""
    }
    val appId = uid % 100000
    val isAppRange = appId in 10000..19999
    val isUA = name.matches(Regex("u\\d+_a\\d+"))
    val sharedUserId = apps.firstOrNull { !it.packageInfo.sharedUserId.isNullOrEmpty() }?.packageInfo?.sharedUserId
    val finalName = if (isAppRange && isUA && !sharedUserId.isNullOrEmpty()) {
        sharedUserId
    } else {
        name
    }
    ownerNameCache[uid] = finalName
    return finalName.ifEmpty { uid.toString() }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/module/LatestVersionInfo.kt`:

```kt
package me.weishu.kernelsu.ui.util.module

data class LatestVersionInfo(
    val versionCode: Int = 0,
    val downloadUrl: String = "",
    val changelog: String = ""
)

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/module/ModuleRepoApi.kt`:

```kt
package me.weishu.kernelsu.ui.util.module

import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.util.isNetworkAvailable
import okhttp3.Request
import org.json.JSONArray
import org.json.JSONObject

data class ModuleDetail(
    val readme: String,
    val readmeHtml: String,
    val latestTag: String,
    val latestTime: String,
    val latestAssetName: String?,
    val latestAssetUrl: String?,
    val releases: List<ReleaseInfo>,
    val homepageUrl: String,
    val sourceUrl: String,
    val url: String
)

data class ReleaseInfo(
    val name: String,
    val tagName: String,
    val publishedAt: String,
    val descriptionHTML: String,
    val assets: List<ReleaseAssetInfo>
)

data class ReleaseAssetInfo(
    val name: String,
    val downloadUrl: String,
    val size: Long,
    val downloadCount: Int
)

fun sanitizeVersionString(version: String): String {
    return version.replace(Regex("[^a-zA-Z0-9.\\-_]"), "_")
}

fun stripTicks(s: String): String {
    val t = s.trim()
    return if (t.startsWith("`") && t.endsWith("`") && t.length >= 2) t.substring(1, t.length - 1) else t
}

fun fetchReleaseDescriptionHtml(moduleId: String, latestTag: String): String? {
    if (!isNetworkAvailable(ksuApp)) return null
    val url = "https://modules.kernelsu.org/module/$moduleId.json"
    return runCatching {
        ksuApp.okhttpClient.newCall(Request.Builder().url(url).build()).execute().use { resp ->
            if (!resp.isSuccessful) null else {
                val body = resp.body.string()
                val obj = JSONObject(body)
                val releasesArray = obj.optJSONArray("releases") ?: return@use null
                var fallbackHtml: String? = null
                for (i in 0 until releasesArray.length()) {
                    val r = releasesArray.optJSONObject(i) ?: continue
                    val descHtml = r.optString("descriptionHTML", "")
                    if (fallbackHtml == null && descHtml.isNotBlank()) {
                        fallbackHtml = descHtml
                    }
                    val rname = r.optString("name", r.optString("tagName", r.optString("version", "")))
                    if (rname == latestTag && descHtml.isNotBlank()) {
                        return@use descHtml
                    }
                }
                fallbackHtml
            }
        }
    }.getOrNull()
}


fun fetchModuleDetail(moduleId: String): ModuleDetail? {
    if (!isNetworkAvailable(ksuApp)) return null
    val url = "https://modules.kernelsu.org/module/$moduleId.json"
    return runCatching {
        ksuApp.okhttpClient.newCall(Request.Builder().url(url).build()).execute().use { resp ->
            if (!resp.isSuccessful) return@use null
            val body = resp.body.string()
            val obj = JSONObject(body)
            val readme = obj.optString("readme", "")
            val readmeHtml = obj.optString("readmeHTML", "")
            val homepageUrl = stripTicks(obj.optString("homepageUrl", ""))
            val sourceUrl = stripTicks(obj.optString("sourceUrl", ""))
            val url = stripTicks(obj.optString("url", ""))
            val lr = obj.optJSONObject("latestRelease")
            var latestTag: String
            var latestTime = ""
            var latestAssetName: String? = null
            var latestAssetUrl: String? = null
            if (lr != null) {
                latestTag = lr.optString("name", lr.optString("version", ""))
                latestTime = lr.optString("time", "")
                var urlDl = lr.optString("downloadUrl", "")
                urlDl = stripTicks(urlDl)
                if (urlDl.isNotEmpty()) {
                    latestAssetName = urlDl.substringAfterLast('/')
                    latestAssetUrl = urlDl
                }
            } else {
                latestTag = obj.optString("latestRelease", "")
            }

            val releasesArray = obj.optJSONArray("releases")
            val releases = if (releasesArray != null) {
                (0 until releasesArray.length()).mapNotNull { rIdx ->
                    val r = releasesArray.optJSONObject(rIdx) ?: return@mapNotNull null
                    val rname = r.optString("name", r.optString("tagName", r.optString("version", "")))
                    val publishedAt = r.optString("publishedAt", "")
                    val descHtml = r.optString("descriptionHTML", "")
                    val assetsArray = r.optJSONArray("releaseAssets") ?: JSONArray()
                    val assets = (0 until assetsArray.length()).mapNotNull { aIdx ->
                        val a = assetsArray.optJSONObject(aIdx) ?: return@mapNotNull null
                        val aname = a.optString("name", "")
                        var adl = a.optString("downloadUrl", "")
                        adl = stripTicks(adl)
                        val asz = a.optLong("size", 0L)
                        val dcnt = when (val dcAny = a.opt("downloadCount")) {
                            is Number -> dcAny.toInt()
                            is String -> dcAny.toIntOrNull() ?: 0
                            else -> 0
                        }
                        if (aname.isEmpty() || adl.isEmpty()) null else ReleaseAssetInfo(aname, adl, asz, dcnt)
                    }
                    ReleaseInfo(
                        name = rname,
                        tagName = r.optString("tagName", rname),
                        publishedAt = publishedAt,
                        descriptionHTML = descHtml,
                        assets = assets
                    )
                }
            } else emptyList()

            return@use ModuleDetail(
                readme = readme,
                readmeHtml = readmeHtml,
                latestTag = latestTag,
                latestTime = latestTime,
                latestAssetName = latestAssetName,
                latestAssetUrl = latestAssetUrl,
                releases = releases,
                homepageUrl = homepageUrl,
                sourceUrl = sourceUrl,
                url = url
            )
        }
    }.getOrNull()
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/util/module/Shortcut.kt`:

```kt
package me.weishu.kernelsu.ui.util.module

import android.app.AppOpsManager
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.provider.Settings
import android.util.Log
import android.widget.Toast
import androidx.core.content.pm.ShortcutInfoCompat
import androidx.core.content.pm.ShortcutManagerCompat
import androidx.core.graphics.drawable.IconCompat
import androidx.core.graphics.scale
import androidx.core.net.toUri
import com.topjohnwu.superuser.io.SuFile
import com.topjohnwu.superuser.io.SuFileInputStream
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.MainActivity
import me.weishu.kernelsu.ui.util.getRootShell
import me.weishu.kernelsu.ui.util.isColorOS
import me.weishu.kernelsu.ui.util.isHyperOS
import me.weishu.kernelsu.ui.util.isMiui
import me.weishu.kernelsu.ui.webui.WebUIActivity

object Shortcut {

    private const val TAG = "ModuleShortcut"

    fun createModuleActionShortcut(
        context: Context,
        moduleId: String,
        name: String,
        iconUri: String?
    ) {
        val shortcutId = "module_action_$moduleId"
        val shortcutIntent = Intent(context, MainActivity::class.java).apply {
            action = Intent.ACTION_VIEW
            putExtra("shortcut_type", "module_action")
            putExtra("module_id", moduleId)
            addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
        }
        createModuleShortcut(
            context = context,
            moduleId = moduleId,
            name = name,
            iconUri = iconUri,
            shortcutId = shortcutId,
            shortcutIntent = shortcutIntent,
            logPrefix = "createModuleActionShortcut"
        )
    }

    fun createModuleWebUiShortcut(
        context: Context,
        moduleId: String,
        name: String,
        iconUri: String?
    ) {
        val shortcutId = "module_webui_$moduleId"
        val shortcutIntent = Intent(context, WebUIActivity::class.java).apply {
            action = Intent.ACTION_VIEW
            data = "kernelsu://webui/$moduleId".toUri()
            putExtra("id", moduleId)
            putExtra("name", name)
            putExtra("from_webui_shortcut", true)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
        }
        createModuleShortcut(
            context = context,
            moduleId = moduleId,
            name = name,
            iconUri = iconUri,
            shortcutId = shortcutId,
            shortcutIntent = shortcutIntent,
            logPrefix = "createModuleWebUiShortcut"
        )
    }

    private fun createModuleShortcut(
        context: Context,
        moduleId: String,
        name: String,
        iconUri: String?,
        shortcutId: String,
        shortcutIntent: Intent,
        logPrefix: String
    ) {
        val hasPinned = hasPinnedShortcut(context, shortcutId)
        Log.d(TAG, "$logPrefix: shortcutId=$shortcutId, hasPinned=$hasPinned")

        val iconCompat = createShortcutIcon(context, iconUri)
        val finalIcon = iconCompat ?: IconCompat.createWithResource(context, R.mipmap.ic_launcher)

        val shortcut = ShortcutInfoCompat.Builder(context, shortcutId)
            .setShortLabel(name)
            .setIntent(shortcutIntent)
            .setIcon(finalIcon)
            .build()

        try {
            Log.d(TAG, "$logPrefix: pushDynamicShortcut() called for moduleId=$moduleId")
            ShortcutManagerCompat.pushDynamicShortcut(context, shortcut)
        } catch (t: Throwable) {
            Log.w(TAG, "$logPrefix: pushDynamicShortcut() threw exception for moduleId=$moduleId: ${t.message}", t)
        }

        if (hasPinned) {
            Log.d(TAG, "$logPrefix: detected existing pinned shortcut, updating only")
            Toast.makeText(context, context.getString(R.string.module_shortcut_updated), Toast.LENGTH_SHORT).show()
            return
        }

        val initialState = getShortcutPermissionState(context)
        Log.d(TAG, "$logPrefix: initial permission state=$initialState")
        if ((isMiui() || isHyperOS()) && initialState != ShortcutPermissionState.Granted) {
            Log.d(TAG, "$logPrefix: device is Xiaomi, trying to grant via root shell")
            val rootSuccess = tryGrantMiuiShortcutPermissionByRoot(context)
            Log.d(TAG, "$logPrefix: root grant attempt success=$rootSuccess")
            val afterState = getShortcutPermissionState(context)
            Log.d(TAG, "$logPrefix: state after root attempt=$afterState")
            if (afterState != ShortcutPermissionState.Granted) {
                Log.d(TAG, "$logPrefix: still not Granted after root, showing hint")
                showShortcutPermissionHint(context)
                return
            }
        } else if (initialState == ShortcutPermissionState.Denied || initialState == ShortcutPermissionState.Ask) {
            Log.d(TAG, "$logPrefix: permission not granted (state=$initialState), showing hint first")
            showShortcutPermissionHint(context)
            return
        }
        if (!ShortcutManagerCompat.isRequestPinShortcutSupported(context)) {
            Log.w(TAG, "$logPrefix: requestPinShortcut not supported on this launcher")
            Toast.makeText(
                context,
                context.getString(R.string.module_shortcut_not_supported),
                Toast.LENGTH_LONG
            ).show()
            return
        }

        val pinned = try {
            Log.d(TAG, "$logPrefix: requestPinShortcut() called for moduleId=$moduleId")
            val result = ShortcutManagerCompat.requestPinShortcut(context, shortcut, null)
            Log.d(TAG, "$logPrefix: requestPinShortcut() result=$result")
            result
        } catch (t: Throwable) {
            Log.w(TAG, "$logPrefix: requestPinShortcut() threw exception for moduleId=$moduleId: ${t.message}", t)
            false
        }

        if (pinned) {
            Log.d(TAG, "$logPrefix: pinned shortcut created successfully for moduleId=$moduleId")
            Toast.makeText(
                context,
                context.getString(R.string.module_shortcut_created),
                Toast.LENGTH_SHORT
            ).show()
        } else {
            Log.w(TAG, "$logPrefix: pinned shortcut not created, showing permission hint for moduleId=$moduleId")
            showShortcutPermissionHint(context)
        }
    }

    fun hasModuleActionShortcut(context: Context, moduleId: String): Boolean {
        val id = "module_action_$moduleId"
        return hasPinnedShortcut(context, id)
    }

    fun hasModuleWebUiShortcut(context: Context, moduleId: String): Boolean {
        val id = "module_webui_$moduleId"
        return hasPinnedShortcut(context, id)
    }

    fun deleteModuleActionShortcut(context: Context, moduleId: String) {
        deleteShortcut(context, "module_action_$moduleId")
    }

    fun deleteModuleWebUiShortcut(context: Context, moduleId: String) {
        deleteShortcut(context, "module_webui_$moduleId")
    }

    fun loadShortcutBitmap(context: Context, iconUri: String?): Bitmap? {
        if (iconUri.isNullOrBlank()) {
            return null
        }
        return try {
            val uri = iconUri.toUri()
            Log.d(TAG, "loadShortcutBitmap: loading bitmap from uri=$uri")
            val rawBitmap = if (uri.scheme.equals("su", ignoreCase = true)) {
                val path = uri.path ?: ""
                if (path.isNotBlank()) {
                    val shell = getRootShell(true)
                    val suFile = SuFile(path)
                    suFile.shell = shell
                    SuFileInputStream.open(suFile).use { input ->
                        BitmapFactory.decodeStream(input)
                    }
                } else null
            } else {
                context.contentResolver.openInputStream(uri)?.use { input ->
                    BitmapFactory.decodeStream(input)
                }
            }
            if (rawBitmap != null) {
                Log.d(TAG, "loadShortcutBitmap: decoded bitmap successfully")
                val w = rawBitmap.width
                val h = rawBitmap.height
                val side = minOf(w, h)
                val x = (w - side) / 2
                val y = (h - side) / 2
                val square = try {
                    Bitmap.createBitmap(rawBitmap, x, y, side, side)
                } catch (_: Throwable) {
                    rawBitmap
                }
                if (square !== rawBitmap && !rawBitmap.isRecycled) {
                    rawBitmap.recycle()
                }
                if (side > 512) {
                    try {
                        val scaled = square.scale(512, 512)
                        if (scaled !== square && !square.isRecycled) {
                            square.recycle()
                        }
                        scaled
                    } catch (_: Throwable) {
                        square
                    }
                } else {
                    square
                }
            } else {
                Log.w(TAG, "loadShortcutBitmap: bitmap decode returned null")
                null
            }
        } catch (t: Throwable) {
            Log.w(TAG, "loadShortcutBitmap: exception when loading icon from uri=$iconUri: ${t.message}", t)
            null
        }
    }

    private fun createShortcutIcon(context: Context, iconUri: String?): IconCompat? {
        val bitmap = loadShortcutBitmap(context, iconUri) ?: return null
        return IconCompat.createWithBitmap(bitmap)
    }

    private fun hasPinnedShortcut(context: Context, id: String): Boolean {
        return try {
            val shortcuts = ShortcutManagerCompat.getShortcuts(
                context,
                ShortcutManagerCompat.FLAG_MATCH_PINNED
            )
            val exists = shortcuts.any { it.id == id && it.isEnabled }
            Log.d(TAG, "hasPinnedShortcut: id=$id, exists=$exists")
            exists
        } catch (t: Throwable) {
            Log.w(TAG, "hasPinnedShortcut: exception for id=$id: ${t.message}", t)
            false
        }
    }

    private fun deleteShortcut(context: Context, id: String) {
        try {
            ShortcutManagerCompat.removeDynamicShortcuts(context, listOf(id))
            Log.d(TAG, "deleteShortcut: removed dynamic shortcut id=$id")
        } catch (t: Throwable) {
            Log.w(TAG, "deleteShortcut: removeDynamicShortcuts exception for id=$id: ${t.message}", t)
        }
        try {
            ShortcutManagerCompat.disableShortcuts(context, listOf(id), "")
            Log.d(TAG, "deleteShortcut: disabled shortcut id=$id")
        } catch (t: Throwable) {
            Log.w(TAG, "deleteShortcut: disableShortcuts exception for id=$id: ${t.message}", t)
        }
    }

    private enum class ShortcutPermissionState {
        Granted,
        Denied,
        Ask,
        Unknown
    }

    private fun checkMiuiShortcutPermission(context: Context): ShortcutPermissionState {
        return try {
            val appOps = context.getSystemService(Context.APP_OPS_SERVICE) as? AppOpsManager
                ?: return ShortcutPermissionState.Unknown
            val pkg = context.applicationContext.packageName
            val uid = context.applicationInfo.uid
            Log.d(TAG, "checkMiuiShortcutPermission: pkg=$pkg, uid=$uid")
            val appOpsClass = Class.forName(AppOpsManager::class.java.name)
            val method = appOpsClass.getDeclaredMethod(
                "checkOpNoThrow",
                Integer.TYPE,
                Integer.TYPE,
                String::class.java
            )
            val result = method.invoke(appOps, 10017, uid, pkg)?.toString()
            if (result == null) {
                Log.w(TAG, "checkMiuiShortcutPermission: checkOpNoThrow returned null")
                return ShortcutPermissionState.Unknown
            }
            Log.d(TAG, "checkMiuiShortcutPermission: raw result=$result")
            val state = when (result) {
                "0" -> ShortcutPermissionState.Granted
                "1" -> ShortcutPermissionState.Denied
                "5" -> ShortcutPermissionState.Ask
                else -> ShortcutPermissionState.Unknown
            }
            Log.d(TAG, "checkMiuiShortcutPermission: mapped state=$state")
            state
        } catch (t: Throwable) {
            Log.w(TAG, "checkMiuiShortcutPermission: exception=${t.message}", t)
            ShortcutPermissionState.Unknown
        }
    }

    private fun checkOppoShortcutPermission(context: Context): ShortcutPermissionState {
        val resolver = context.contentResolver ?: run {
            Log.w(TAG, "checkOppoShortcutPermission: contentResolver is null")
            return ShortcutPermissionState.Unknown
        }
        val uri = "content://settings/secure/launcher_shortcut_permission_settings".toUri()
        val cursor = resolver.query(uri, null, null, null, null) ?: run {
            Log.w(TAG, "checkOppoShortcutPermission: query returned null cursor, uri=$uri")
            return ShortcutPermissionState.Unknown
        }
        cursor.use { c ->
            val pkg = context.applicationContext.packageName
            val index = c.getColumnIndex("value")
            if (index == -1) {
                Log.w(TAG, "checkOppoShortcutPermission: 'value' column not found")
                return ShortcutPermissionState.Unknown
            }
            Log.d(TAG, "checkOppoShortcutPermission: pkg=$pkg")
            while (c.moveToNext()) {
                val value = c.getString(index)
                if (!value.isNullOrEmpty()) {
                    Log.d(TAG, "checkOppoShortcutPermission: row value=$value")
                    if (value.contains("$pkg, 1")) {
                        Log.d(TAG, "checkOppoShortcutPermission: detected Granted")
                        return ShortcutPermissionState.Granted
                    }
                    if (value.contains("$pkg, 0")) {
                        Log.d(TAG, "checkOppoShortcutPermission: detected Denied")
                        return ShortcutPermissionState.Denied
                    }
                }
            }
        }
        return ShortcutPermissionState.Unknown
    }

    private fun tryGrantMiuiShortcutPermissionByRoot(context: Context): Boolean {
        val pkg = context.applicationContext.packageName
        val cmd = "appops set $pkg 10017 allow"
        return try {
            val shell = getRootShell()
            val result = shell.newJob().add(cmd).exec()
            Log.d(TAG, "tryGrantMiuiShortcutPermissionByRoot: cmd=$cmd, code=${result.code}, isSuccess=${result.isSuccess}")
            result.isSuccess
        } catch (t: Throwable) {
            Log.w(TAG, "tryGrantMiuiShortcutPermissionByRoot: exception=${t.message}", t)
            false
        }
    }

    private fun getShortcutPermissionState(context: Context): ShortcutPermissionState {
        return when {
            isMiui() || isHyperOS() -> checkMiuiShortcutPermission(context)
            isColorOS() -> checkOppoShortcutPermission(context)
            else -> ShortcutPermissionState.Unknown
        }
    }

    private fun showShortcutPermissionHint(context: Context) {
        val state = getShortcutPermissionState(context)
        val messageRes = when {
            isMiui() || isHyperOS() -> R.string.module_shortcut_permission_tip_xiaomi
            isColorOS() -> R.string.module_shortcut_permission_tip_oppo
            else -> R.string.module_shortcut_permission_tip_default
        }
        Log.d(TAG, "showShortcutPermissionHint: state=$state, messageRes=$messageRes")
        Toast.makeText(context, context.getString(messageRes), Toast.LENGTH_LONG).show()
        if (state != ShortcutPermissionState.Granted) {
            Log.d(TAG, "showShortcutPermissionHint: state is not Granted, opening app details settings")
            openAppDetailsSettings(context)
        }
    }

    private fun openAppDetailsSettings(context: Context) {
        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = Uri.fromParts("package", context.packageName, null)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        try {
            Log.d(TAG, "openAppDetailsSettings: launching settings for package=${context.packageName}")
            context.startActivity(intent)
        } catch (t: Throwable) {
            Log.w(TAG, "openAppDetailsSettings: failed to launch settings: ${t.message}", t)
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/viewmodel/ModuleRepoViewModel.kt`:

```kt
package me.weishu.kernelsu.ui.viewmodel

import android.util.Log
import android.widget.Toast
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.State
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.component.SearchStatus
import me.weishu.kernelsu.ui.util.HanziToPinyin
import me.weishu.kernelsu.ui.util.isNetworkAvailable
import okhttp3.Request
import org.json.JSONArray
import org.json.JSONObject

class ModuleRepoViewModel : ViewModel() {

    companion object {
        private const val TAG = "ModuleRepoViewModel"
        private const val MODULES_URL = "https://modules.kernelsu.org/modules.json"
    }

    @Immutable
    data class Author(
        val name: String,
        val link: String,
    )

    @Immutable
    data class ReleaseAsset(
        val name: String,
        val downloadUrl: String,
        val size: Long
    )

    @Immutable
    data class RepoModule(
        val moduleId: String,
        val moduleName: String,
        val authors: String,
        val authorList: List<Author>,
        val summary: String,
        val metamodule: Boolean,
        val stargazerCount: Int,
        val updatedAt: String,
        val createdAt: String,
        val latestRelease: String,
        val latestReleaseTime: String,
        val latestVersionCode: Int,
        val latestAsset: ReleaseAsset?,
    )

    private var _modules = mutableStateOf<List<RepoModule>>(emptyList())
    val modules: State<List<RepoModule>> = _modules

    var isRefreshing by mutableStateOf(false)
        private set

    private val _searchStatus = mutableStateOf(SearchStatus(""))
    val searchStatus: State<SearchStatus> = _searchStatus

    private val _searchResults = mutableStateOf<List<RepoModule>>(emptyList())
    val searchResults: State<List<RepoModule>> = _searchResults

    fun refresh() {
        viewModelScope.launch {
            val netAvailable = isNetworkAvailable(ksuApp)
            withContext(Dispatchers.Main) { isRefreshing = true }
            val parsed = withContext(Dispatchers.IO) { if (!netAvailable) null else fetchModulesInternal() }
            withContext(Dispatchers.Main) {
                if (parsed != null) {
                    _modules.value = parsed
                } else {
                    Toast.makeText(
                        ksuApp,
                        ksuApp.getString(R.string.network_offline), Toast.LENGTH_SHORT
                    ).show()
                }
                isRefreshing = false
            }
        }
    }

    suspend fun updateSearchText(text: String) {
        _searchStatus.value.searchText = text

        if (text.isEmpty()) {
            _searchStatus.value.resultStatus = SearchStatus.ResultStatus.DEFAULT
            _searchResults.value = emptyList()
            return
        }

        val result = withContext(Dispatchers.IO) {
            _searchStatus.value.resultStatus = SearchStatus.ResultStatus.LOAD
            _modules.value.filter {
                it.moduleId.contains(text, true)
                        || it.moduleName.contains(text, true)
                        || it.authors.contains(text, true)
                        || it.summary.contains(text, true)
                        || HanziToPinyin.getInstance().toPinyinString(it.moduleName).contains(text, true)
            }
        }

        _searchResults.value = result
        _searchStatus.value.resultStatus = if (result.isEmpty()) {
            SearchStatus.ResultStatus.EMPTY
        } else {
            SearchStatus.ResultStatus.SHOW
        }
    }

    private fun fetchModulesInternal(): List<RepoModule> {
        return runCatching {
            val request = Request.Builder().url(MODULES_URL).build()
            ksuApp.okhttpClient.newCall(request).execute().use { resp ->
                if (!resp.isSuccessful) return emptyList()
                val body = resp.body.string()
                val json = JSONArray(body)
                (0 until json.length()).mapNotNull { idx ->
                    val item = json.optJSONObject(idx) ?: return@mapNotNull null
                    parseRepoModule(item)
                }
            }
        }.getOrElse {
            Log.e(TAG, "fetch modules failed", it)
            emptyList()
        }
    }

    private fun parseRepoModule(item: JSONObject): RepoModule? {
        val moduleId = item.optString("moduleId", "")
        if (moduleId.isEmpty()) return null
        val moduleName = item.optString("moduleName", "")
        val authorsArray = item.optJSONArray("authors")
        val authorList = if (authorsArray != null) {
            (0 until authorsArray.length())
                .mapNotNull { idx ->
                    val authorObj = authorsArray.optJSONObject(idx) ?: return@mapNotNull null
                    val name = authorObj.optString("name", "").trim()
                    var link = authorObj.optString("link", "").trim()
                    if (link.startsWith("`") && link.endsWith("`") && link.length >= 2) {
                        link = link.substring(1, link.length - 1)
                    }
                    if (name.isEmpty()) null else Author(name = name, link = link)
                }
        } else {
            emptyList()
        }
        val authors = if (authorList.isNotEmpty()) authorList.joinToString(", ") { it.name } else item.optString("authors", "")
        val summary = item.optString("summary", "")
        val metamodule = item.optBoolean("metamodule", false)
        val stargazerCount = item.optInt("stargazerCount", 0)
        val updatedAt = item.optString("updatedAt", "")
        val createdAt = item.optString("createdAt", "")

        var latestRelease = ""
        var latestReleaseTime = ""
        var latestVersionCode = 0
        var latestAsset: ReleaseAsset? = null
        val lr = item.optJSONObject("latestRelease")
        if (lr != null) {
            val lrName = lr.optString("name", lr.optString("version", ""))
            val lrTime = lr.optString("time", "")
            var lrUrl = lr.optString("downloadUrl", "")
            lrUrl = lrUrl.trim().let {
                var s = it
                if (s.startsWith("`") && s.endsWith("`") && s.length >= 2) {
                    s = s.substring(1, s.length - 1)
                }
                s
            }
            val vcAny = lr.opt("versionCode")
            latestVersionCode = when (vcAny) {
                is Number -> vcAny.toInt()
                is String -> vcAny.toIntOrNull() ?: 0
                else -> 0
            }
            latestRelease = lrName
            latestReleaseTime = lrTime
            if (lrUrl.isNotEmpty()) {
                val fileName = lrUrl.substringAfterLast('/')
                latestAsset = ReleaseAsset(name = fileName, downloadUrl = lrUrl, size = 0L)
            }
        }

        return RepoModule(
            moduleId = moduleId,
            moduleName = moduleName,
            authors = authors,
            authorList = authorList,
            summary = summary,
            metamodule = metamodule,
            stargazerCount = stargazerCount,
            updatedAt = updatedAt,
            createdAt = createdAt,
            latestRelease = latestRelease,
            latestReleaseTime = latestReleaseTime,
            latestVersionCode = latestVersionCode,
            latestAsset = latestAsset,
        )
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/viewmodel/ModuleViewModel.kt`:

```kt
package me.weishu.kernelsu.ui.viewmodel

import android.os.SystemClock
import android.util.Log
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.State
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateMapOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshots.SnapshotStateMap
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.component.SearchStatus
import me.weishu.kernelsu.ui.util.HanziToPinyin
import me.weishu.kernelsu.ui.util.isNetworkAvailable
import me.weishu.kernelsu.ui.util.listModules
import me.weishu.kernelsu.ui.util.module.sanitizeVersionString
import org.json.JSONArray
import org.json.JSONObject
import java.text.Collator
import java.util.Locale

class ModuleViewModel : ViewModel() {

    companion object {
        private const val TAG = "ModuleViewModel"
        private var modules by mutableStateOf<List<ModuleInfo>>(emptyList())
    }

    @Immutable
    class ModuleInfo(
        val id: String,
        val name: String,
        val author: String,
        val version: String,
        val versionCode: Int,
        val description: String,
        val enabled: Boolean,
        val update: Boolean,
        val remove: Boolean,
        val updateJson: String,
        val hasWebUi: Boolean,
        val hasActionScript: Boolean,
        val metamodule: Boolean,
        val actionIconPath: String?,
        val webUiIconPath: String?,
    )

    @Immutable
    data class ModuleUpdateInfo(
        val downloadUrl: String,
        val version: String,
        val changelog: String
    ) {
        companion object {
            val Empty = ModuleUpdateInfo("", "", "")
        }
    }

    private data class ModuleUpdateSignature(
        val updateJson: String,
        val versionCode: Int,
        val enabled: Boolean,
        val update: Boolean,
        val remove: Boolean
    )

    private data class ModuleUpdateCache(
        val signature: ModuleUpdateSignature,
        val info: ModuleUpdateInfo
    )

    var isRefreshing by mutableStateOf(false)
        private set

    var sortEnabledFirst by mutableStateOf(false)
    var sortActionFirst by mutableStateOf(false)
    var checkModuleUpdate by mutableStateOf(true)

    private val updateInfoMutex = Mutex()
    private var updateInfoCache: MutableMap<String, ModuleUpdateCache> = mutableMapOf()
    private val updateInfoInFlight = mutableSetOf<String>()
    private val _updateInfo = mutableStateMapOf<String, ModuleUpdateInfo>()
    val updateInfo: SnapshotStateMap<String, ModuleUpdateInfo> = _updateInfo

    private val _searchStatus = mutableStateOf(SearchStatus(""))
    val searchStatus: State<SearchStatus> = _searchStatus

    private val _searchResults = mutableStateOf<List<ModuleInfo>>(emptyList())
    val searchResults: State<List<ModuleInfo>> = _searchResults

    val moduleList by derivedStateOf {
        val comparator = moduleComparator()
        modules.filter {
            it.id.contains(searchStatus.value.searchText, true) || it.name.contains(
                searchStatus.value.searchText,
                true
            ) || HanziToPinyin.getInstance()
                .toPinyinString(it.name).contains(searchStatus.value.searchText, true)
        }.sortedWith(comparator).also {
            isRefreshing = false
        }
    }

    var isNeedRefresh by mutableStateOf(false)
        private set

    fun markNeedRefresh() {
        isNeedRefresh = true
    }

    suspend fun updateSearchText(text: String) {
        _searchStatus.value.searchText = text

        if (text.isEmpty()) {
            _searchStatus.value.resultStatus = SearchStatus.ResultStatus.DEFAULT
            _searchResults.value = emptyList()
            return
        }

        val result = withContext(Dispatchers.IO) {
            _searchStatus.value.resultStatus = SearchStatus.ResultStatus.LOAD
            modules.filter {
                it.id.contains(text, true) || it.name.contains(text, true) ||
                        it.description.contains(text, true) || it.author.contains(text, true) ||
                        HanziToPinyin.getInstance().toPinyinString(it.name).contains(text, true)
            }.let { filteredModules ->
                val comparator = moduleComparator()
                filteredModules.sortedWith(comparator)
            }
        }

        _searchResults.value = result
        _searchStatus.value.resultStatus = if (result.isEmpty()) {
            SearchStatus.ResultStatus.EMPTY
        } else {
            SearchStatus.ResultStatus.SHOW
        }
    }

    private fun moduleComparator(): Comparator<ModuleInfo> {
        return compareBy<ModuleInfo>(
            {
                val executable = it.hasWebUi || it.hasActionScript
                when {
                    it.metamodule && it.enabled -> 0
                    sortEnabledFirst && sortActionFirst -> when {
                        it.enabled && executable -> 1
                        it.enabled -> 2
                        executable -> 3
                        else -> 4
                    }

                    sortEnabledFirst && !sortActionFirst -> if (it.enabled) 1 else 2
                    !sortEnabledFirst && sortActionFirst -> if (executable) 1 else 2
                    else -> 1
                }
            },
            { if (sortEnabledFirst) !it.enabled else 0 },
            { if (sortActionFirst) !(it.hasWebUi || it.hasActionScript) else 0 },
        ).thenBy(Collator.getInstance(Locale.getDefault()), ModuleInfo::id)
    }

    suspend fun loadModuleList() {
        val parsedModules = withContext(Dispatchers.IO) {
            kotlin.runCatching {
                val result = listModules()
                Log.i(TAG, "result: $result")
                val array = JSONArray(result)
                (0 until array.length())
                    .asSequence()
                    .map { array.getJSONObject(it) }
                    .map { obj ->
                        ModuleInfo(
                            obj.getString("id"),
                            obj.optString("name"),
                            obj.optString("author", "Unknown"),
                            obj.optString("version", "Unknown"),
                            obj.optInt("versionCode", 0),
                            obj.optString("description"),
                            obj.getBoolean("enabled"),
                            obj.optBoolean("update"),
                            obj.getBoolean("remove"),
                            obj.optString("updateJson"),
                            obj.optBoolean("web"),
                            obj.optBoolean("action"),
                            (obj.optInt("metamodule") != 0) or obj.optBoolean("metamodule"),
                            obj.optString("actionIcon").takeIf { it.isNotBlank() },
                            obj.optString("webuiIcon").takeIf { it.isNotBlank() }
                        )
                    }.toList()
            }.getOrElse {
                Log.e(TAG, "fetchModuleList: ", it)
                emptyList()
            }
        }

        withContext(Dispatchers.Main) {
            modules = parsedModules
            isNeedRefresh = false
        }
    }

    fun fetchModuleList(checkUpdate: Boolean = false) {
        viewModelScope.launch {
            withContext(Dispatchers.Main) {
                isRefreshing = true
            }

            val start = SystemClock.elapsedRealtime()

            loadModuleList()

            if (checkUpdate) syncModuleUpdateInfo(modules)

            withContext(Dispatchers.Main) {
                isRefreshing = false
            }

            Log.i(TAG, "load cost: ${SystemClock.elapsedRealtime() - start}, modules: $modules")
        }
    }

    private fun ModuleInfo.toSignature(): ModuleUpdateSignature {
        return ModuleUpdateSignature(
            updateJson = updateJson,
            versionCode = versionCode,
            enabled = enabled,
            update = update,
            remove = remove
        )
    }

    suspend fun syncModuleUpdateInfo(modules: List<ModuleInfo>) {
        if (!checkModuleUpdate) return

        val modulesToFetch = mutableListOf<Triple<String, ModuleInfo, ModuleUpdateSignature>>()
        val removedIds = mutableSetOf<String>()

        updateInfoMutex.withLock {
            val ids = modules.map { it.id }.toSet()
            updateInfoCache.keys.filter { it !in ids }.forEach { removedId ->
                removedIds += removedId
                updateInfoCache.remove(removedId)
                updateInfoInFlight.remove(removedId)
            }

            modules.forEach { module ->
                val signature = module.toSignature()
                val cached = updateInfoCache[module.id]
                if ((cached == null || cached.signature != signature) && updateInfoInFlight.add(module.id)) {
                    modulesToFetch += Triple(module.id, module, signature)
                }
            }
        }

        val fetchedEntries = coroutineScope {
            modulesToFetch.map { (id, module, signature) ->
                async(Dispatchers.IO) {
                    id to ModuleUpdateCache(signature, checkUpdate(module))
                }
            }.awaitAll()
        }

        val changedEntries = mutableListOf<Pair<String, ModuleUpdateInfo>>()
        updateInfoMutex.withLock {
            fetchedEntries.forEach { (id, entry) ->
                val existing = updateInfoCache[id]
                if (existing == null || existing.signature != entry.signature || existing.info != entry.info) {
                    updateInfoCache[id] = entry
                    changedEntries += id to entry.info
                }
                updateInfoInFlight.remove(id)
            }
        }

        if (removedIds.isEmpty() && changedEntries.isEmpty()) {
            return
        }

        withContext(Dispatchers.Main) {
            removedIds.forEach { _updateInfo.remove(it) }
            changedEntries.forEach { (id, info) ->
                _updateInfo[id] = info
            }
        }
    }

    fun checkUpdate(m: ModuleInfo): ModuleUpdateInfo {
        if (!isNetworkAvailable(ksuApp)) {
            return ModuleUpdateInfo.Empty
        }
        if (m.updateJson.isEmpty() || m.remove || m.update || !m.enabled) {
            return ModuleUpdateInfo.Empty
        }
        // download updateJson
        val result = kotlin.runCatching {
            val url = m.updateJson
            Log.i(TAG, "checkUpdate url: $url")
            val response = ksuApp.okhttpClient.newCall(
                okhttp3.Request.Builder().url(url).build()
            ).execute()
            Log.d(TAG, "checkUpdate code: ${response.code}")
            if (response.isSuccessful) {
                response.body.string()
            } else {
                ""
            }
        }.getOrDefault("")
        Log.i(TAG, "checkUpdate result: $result")

        if (result.isEmpty()) {
            return ModuleUpdateInfo.Empty
        }

        val updateJson = kotlin.runCatching {
            JSONObject(result)
        }.getOrNull() ?: return ModuleUpdateInfo.Empty

        var version = updateJson.optString("version", "")
        version = sanitizeVersionString(version)
        val versionCode = updateJson.optInt("versionCode", 0)
        val zipUrl = updateJson.optString("zipUrl", "")
        val changelog = updateJson.optString("changelog", "")
        if (versionCode <= m.versionCode || zipUrl.isEmpty()) {
            return ModuleUpdateInfo.Empty
        }

        return ModuleUpdateInfo(zipUrl, version, changelog)
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/viewmodel/SuperUserViewModel.kt`:

```kt
package me.weishu.kernelsu.ui.viewmodel

import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.ApplicationInfo
import android.content.pm.PackageInfo
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.DeadObjectException
import android.os.IBinder
import android.os.Parcelable
import android.os.RemoteException
import android.os.SystemClock
import android.util.Log
import androidx.compose.runtime.State
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.topjohnwu.superuser.Shell
import com.topjohnwu.superuser.ipc.RootService
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.IKsuInterface
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.ui.KsuService
import me.weishu.kernelsu.ui.component.SearchStatus
import me.weishu.kernelsu.ui.util.HanziToPinyin
import me.weishu.kernelsu.ui.util.KsuCli
import java.text.Collator
import java.util.Locale
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

class SuperUserViewModel : ViewModel() {

    companion object {
        private const val TAG = "SuperUserViewModel"
        private val appsLock = Any()
        var apps by mutableStateOf<List<AppInfo>>(emptyList())

        @JvmStatic
        fun getAppIconDrawable(context: Context, packageName: String): Drawable? {
            val appList = synchronized(appsLock) { apps }
            val appDetail = appList.find { it.packageName == packageName }
            return appDetail?.packageInfo?.applicationInfo?.loadIcon(context.packageManager)
        }
    }

    private var _appList = mutableStateOf<List<AppInfo>>(emptyList())
    val appList: State<List<AppInfo>> = _appList

    private val _searchStatus = mutableStateOf(SearchStatus(""))
    val searchStatus: State<SearchStatus> = _searchStatus

    @Parcelize
    data class AppInfo(
        val label: String,
        val packageInfo: PackageInfo,
        val profile: Natives.Profile?,
    ) : Parcelable {
        val packageName: String
            get() = packageInfo.packageName
        val uid: Int
            get() = packageInfo.applicationInfo!!.uid

        val allowSu: Boolean
            get() = profile != null && profile.allowSu
        val hasCustomProfile: Boolean
            get() {
                if (profile == null) {
                    return false
                }

                return if (profile.allowSu) {
                    !profile.rootUseDefault
                } else {
                    !profile.nonRootUseDefault
                }
            }
    }

    var showSystemApps by mutableStateOf(false)
    var isRefreshing by mutableStateOf(false)
        private set

    var isNeedRefresh by mutableStateOf(false)
        private set

    fun markNeedRefresh() {
        isNeedRefresh = true
    }

    private val _searchResults = mutableStateOf<List<AppInfo>>(emptyList())
    val searchResults: State<List<AppInfo>> = _searchResults

    suspend fun updateSearchText(text: String) {
        _searchStatus.value.searchText = text

        if (text.isEmpty()) {
            _searchStatus.value.resultStatus = SearchStatus.ResultStatus.DEFAULT
            _searchResults.value = emptyList()
            return
        }

        val result = withContext(Dispatchers.IO) {
            _searchStatus.value.resultStatus = SearchStatus.ResultStatus.LOAD
            _appList.value.filter {
                it.label.contains(_searchStatus.value.searchText, true) || it.packageName.contains(
                    _searchStatus.value.searchText,
                    true
                ) || HanziToPinyin.getInstance().toPinyinString(it.label)
                    .contains(_searchStatus.value.searchText, true)
            }
        }

        _searchResults.value = result
        _searchStatus.value.resultStatus = if (result.isEmpty()) {
            SearchStatus.ResultStatus.EMPTY
        } else {
            SearchStatus.ResultStatus.SHOW
        }

    }

    private suspend inline fun connectKsuService(
        crossinline onDisconnect: () -> Unit = {}
    ): Pair<IBinder, ServiceConnection> = withContext(Dispatchers.Main) {
        suspendCoroutine { cont ->
            val connection = object : ServiceConnection {
                override fun onServiceDisconnected(name: ComponentName?) {
                    onDisconnect()
                }

                override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
                    cont.resume(binder as IBinder to this)
                }
            }

            val intent = Intent(ksuApp, KsuService::class.java)

            val task = RootService.bindOrTask(
                intent,
                Shell.EXECUTOR,
                connection,
            )
            val shell = KsuCli.SHELL
            task?.let { shell.execTask(it) }
        }
    }

    private fun stopKsuService() {
        val intent = Intent(ksuApp, KsuService::class.java)
        RootService.stop(intent)
    }

    private fun filterAndSort(list: List<AppInfo>): List<AppInfo> {
        val comparator = compareBy<AppInfo> {
            when {
                it.allowSu -> 0
                it.hasCustomProfile -> 1
                else -> 2
            }
        }.then(compareBy(Collator.getInstance(Locale.getDefault()), AppInfo::label))
        return list.sortedWith(comparator).filter {
            it.uid == 2000
                    || showSystemApps
                    || it.allowSu
                    || it.hasCustomProfile
                    || it.packageInfo.applicationInfo!!.flags.and(ApplicationInfo.FLAG_SYSTEM) == 0
        }
    }

    suspend fun fetchAppList() {
        Mutex().withLock {
            withContext(Dispatchers.Main) { isRefreshing = true }

            val result = connectKsuService {
                Log.w(TAG, "KsuService disconnected")
            }

            val allPackagesSlice = withContext(Dispatchers.IO) {
                val pm = ksuApp.packageManager
                val start = SystemClock.elapsedRealtime()

                val binder = result.first
                val iface = IKsuInterface.Stub.asInterface(binder)
                val slice = try {
                    iface.getPackages(0)
                } catch (_: DeadObjectException) {
                    val retry = connectKsuService { Log.w(TAG, "KsuService disconnected") }
                    IKsuInterface.Stub.asInterface(retry.first).getPackages(0)
                } catch (_: RemoteException) {
                    val retry = connectKsuService { Log.w(TAG, "KsuService disconnected") }
                    IKsuInterface.Stub.asInterface(retry.first).getPackages(0)
                }

                val packages = slice.list
                val newApps = packages.map {
                    val appInfo = it.applicationInfo
                    val uid = appInfo!!.uid
                    val profile = Natives.getAppProfile(it.packageName, uid)
                    AppInfo(
                        label = appInfo.loadLabel(pm).toString(),
                        packageInfo = it,
                        profile = profile,
                    )
                }.filter {
                    val ai = it.packageInfo.applicationInfo!!
                    if (Build.VERSION.SDK_INT >= 29) !ai.isResourceOverlay else true
                }

                val sortedFiltered = filterAndSort(newApps)

                Log.i(TAG, "load cost: ${SystemClock.elapsedRealtime() - start}")

                Pair(newApps, sortedFiltered)
            }

            withContext(Dispatchers.Main) {
                synchronized(appsLock) {
                    apps = allPackagesSlice.first
                }
                _appList.value = allPackagesSlice.second
                isRefreshing = false
                isNeedRefresh = false
                stopKsuService()
            }
        }
    }

    private suspend fun refreshAppList() {
        Mutex().withLock {
            val currentApps = synchronized(appsLock) { apps }
            if (currentApps.isEmpty()) return

            val updatedApps = withContext(Dispatchers.IO) {
                currentApps.map {
                    val profile = Natives.getAppProfile(it.packageName, it.uid)
                    it.copy(profile = profile)
                }
            }

            val sortedFiltered = withContext(Dispatchers.IO) {
                filterAndSort(updatedApps)
            }

            withContext(Dispatchers.Main) {
                synchronized(appsLock) {
                    apps = updatedApps
                }
                _appList.value = sortedFiltered
                isNeedRefresh = false
            }
        }
    }

    fun loadAppList(force: Boolean = false) {
        viewModelScope.launch {
            if (force || apps.isEmpty()) {
                fetchAppList()
            } else {
                refreshAppList()
            }
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/viewmodel/TemplateViewModel.kt`:

```kt
package me.weishu.kernelsu.ui.viewmodel

import android.os.Parcelable
import android.util.Log
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.parcelize.Parcelize
import me.weishu.kernelsu.Natives
import me.weishu.kernelsu.ksuApp
import me.weishu.kernelsu.profile.Capabilities
import me.weishu.kernelsu.profile.Groups
import me.weishu.kernelsu.ui.util.getAppProfileTemplate
import me.weishu.kernelsu.ui.util.listAppProfileTemplates
import me.weishu.kernelsu.ui.util.setAppProfileTemplate
import okhttp3.Request
import org.json.JSONArray
import org.json.JSONObject
import java.text.Collator
import java.util.Locale


/**
 * @author weishu
 * @date 2023/10/20.
 */
const val TEMPLATE_INDEX_URL = "https://kernelsu.org/templates/index.json"
const val TEMPLATE_URL = "https://kernelsu.org/templates/%s"

const val TAG = "TemplateViewModel"

class TemplateViewModel : ViewModel() {
    companion object {
        private var templates by mutableStateOf<List<TemplateInfo>>(emptyList())
    }

    @Parcelize
    data class TemplateInfo(
        val id: String = "",
        val name: String = "",
        val description: String = "",
        val author: String = "",
        val local: Boolean = true,
        val namespace: Int = Natives.Profile.Namespace.INHERITED.ordinal,
        val uid: Int = Natives.ROOT_UID,
        val gid: Int = Natives.ROOT_GID,
        val groups: List<Int> = mutableListOf(),
        val capabilities: List<Int> = mutableListOf(),
        val context: String = Natives.KERNEL_SU_DOMAIN,
        val rules: List<String> = mutableListOf(),
    ) : Parcelable

    var isRefreshing by mutableStateOf(false)
        private set

    val templateList by derivedStateOf {
        val comparator = compareBy(TemplateInfo::local).reversed().then(
            compareBy(
                Collator.getInstance(Locale.getDefault()), TemplateInfo::id
            )
        )
        templates.sortedWith(comparator).apply {
            isRefreshing = false
        }
    }

    suspend fun fetchTemplates(sync: Boolean = false) {
        isRefreshing = true
        withContext(Dispatchers.IO) {
            val localTemplateIds = listAppProfileTemplates()
            Log.i(TAG, "localTemplateIds: $localTemplateIds")
            if (localTemplateIds.isEmpty() || sync) {
                // if no templates, fetch remote templates
                fetchRemoteTemplates()
            }

            // fetch templates again
            templates = listAppProfileTemplates().mapNotNull(::getTemplateInfoById)

            isRefreshing = false
        }
    }

    suspend fun importTemplates(
        templates: String,
        onSuccess: suspend () -> Unit,
        onFailure: suspend (String) -> Unit
    ) {
        withContext(Dispatchers.IO) {
            runCatching {
                JSONArray(templates)
            }.getOrElse {
                runCatching {
                    val json = JSONObject(templates)
                    JSONArray().apply { put(json) }
                }.getOrElse {
                    onFailure("invalid templates: $templates")
                    return@withContext
                }
            }.let {
                0.until(it.length()).forEach { i ->
                    runCatching {
                        val template = it.getJSONObject(i)
                        val id = template.getString("id")
                        template.put("local", true)
                        setAppProfileTemplate(id, template.toString())
                    }.onFailure { e ->
                        Log.e(TAG, "ignore invalid template: $it", e)
                    }
                }
                onSuccess()
            }
        }
    }

    suspend fun exportTemplates(onTemplateEmpty: suspend () -> Unit, callback: suspend (String) -> Unit) {
        val result = withContext(Dispatchers.IO) {
            val templates = listAppProfileTemplates()
                .mapNotNull(::getTemplateInfoById)
                .filter { it.local }
            if (templates.isEmpty()) return@withContext null
            JSONArray(templates.map { it.toJSON() }).toString()
        }

        if (result == null) onTemplateEmpty() else callback(result)
    }
}

private fun fetchRemoteTemplates() {
    runCatching {
        ksuApp.okhttpClient.newCall(
            Request.Builder().url(TEMPLATE_INDEX_URL).build()
        ).execute().use { response ->
            if (!response.isSuccessful) {
                return
            }
            val remoteTemplateIds = JSONArray(response.body.string())
            Log.i(TAG, "fetchRemoteTemplates: $remoteTemplateIds")
            0.until(remoteTemplateIds.length()).forEach { i ->
                val id = remoteTemplateIds.getString(i)
                Log.i(TAG, "fetch template: $id")
                val templateJson = ksuApp.okhttpClient.newCall(
                    Request.Builder().url(TEMPLATE_URL.format(id)).build()
                ).runCatching {
                    execute().use { response ->
                        if (!response.isSuccessful) {
                            return@forEach
                        }
                        response.body.string()
                    }
                }.getOrNull() ?: return@forEach
                Log.i(TAG, "template: $templateJson")

                // validate remote template
                runCatching {
                    val json = JSONObject(templateJson)
                    fromJSON(json)?.let {
                        // force local template
                        json.put("local", false)
                        setAppProfileTemplate(id, json.toString())
                    }
                }.onFailure {
                    Log.e(TAG, "ignore invalid template: $it", it)
                    return@forEach
                }
            }
        }
    }.onFailure { Log.e(TAG, "fetchRemoteTemplates: $it", it) }
}

@Suppress("UNCHECKED_CAST")
private fun <T, R> JSONArray.mapCatching(
    transform: (T) -> R, onFail: (Throwable) -> Unit
): List<R> {
    return List(length()) { i -> get(i) as T }.mapNotNull { element ->
        runCatching {
            transform(element)
        }.onFailure(onFail).getOrNull()
    }
}

private inline fun <reified T : Enum<T>> getEnumOrdinals(
    jsonArray: JSONArray?, enumClass: Class<T>
): List<T> {
    return jsonArray?.mapCatching<String, T>({ name ->
        enumValueOf(name.uppercase())
    }, {
        Log.e(TAG, "ignore invalid enum ${enumClass.simpleName}: $it", it)
    }).orEmpty()
}

fun getTemplateInfoById(id: String): TemplateViewModel.TemplateInfo? {
    return runCatching {
        fromJSON(JSONObject(getAppProfileTemplate(id)))
    }.onFailure {
        Log.e(TAG, "ignore invalid template: $it", it)
    }.getOrNull()
}

private fun getLocaleString(json: JSONObject, key: String): String {
    val fallback = json.getString(key)
    val locale = Locale.getDefault()
    val localeKey = "${locale.language}_${locale.country}"
    json.optJSONObject("locales")?.let {
        // check locale first
        it.optJSONObject(localeKey)?.let { json ->
            return json.optString(key, fallback)
        }
        // fallback to language
        it.optJSONObject(locale.language)?.let { json ->
            return json.optString(key, fallback)
        }
    }
    return fallback
}

private fun fromJSON(templateJson: JSONObject): TemplateViewModel.TemplateInfo? {
    return runCatching {
        val groupsJsonArray = templateJson.optJSONArray("groups")
        val capabilitiesJsonArray = templateJson.optJSONArray("capabilities")
        val context = templateJson.optString("context").takeIf { it.isNotEmpty() }
            ?: Natives.KERNEL_SU_DOMAIN
        val namespace = templateJson.optString("namespace").takeIf { it.isNotEmpty() }
            ?: Natives.Profile.Namespace.INHERITED.name

        val rulesJsonArray = templateJson.optJSONArray("rules")
        val templateInfo = TemplateViewModel.TemplateInfo(
            id = templateJson.getString("id"),
            name = getLocaleString(templateJson, "name"),
            description = getLocaleString(templateJson, "description"),
            author = templateJson.optString("author"),
            local = templateJson.optBoolean("local"),
            namespace = Natives.Profile.Namespace.valueOf(
                namespace.uppercase()
            ).ordinal,
            uid = templateJson.optInt("uid", Natives.ROOT_UID),
            gid = templateJson.optInt("gid", Natives.ROOT_GID),
            groups = getEnumOrdinals(groupsJsonArray, Groups::class.java).map { it.gid },
            capabilities = getEnumOrdinals(
                capabilitiesJsonArray, Capabilities::class.java
            ).map { it.cap },
            context = context,
            rules = rulesJsonArray?.mapCatching<String, String>({ it }, {
                Log.e(TAG, "ignore invalid rule: $it", it)
            }).orEmpty()
        )
        templateInfo
    }.onFailure {
        Log.e(TAG, "ignore invalid template: $it", it)
    }.getOrNull()
}

fun TemplateViewModel.TemplateInfo.toJSON(): JSONObject {
    val template = this
    return JSONObject().apply {

        put("id", template.id)
        put("name", template.name.ifBlank { template.id })
        put("description", template.description.ifBlank { template.id })
        if (template.author.isNotEmpty()) {
            put("author", template.author)
        }
        put("namespace", Natives.Profile.Namespace.entries[template.namespace].name)
        put("uid", template.uid)
        put("gid", template.gid)

        if (template.groups.isNotEmpty()) {
            put(
                "groups", JSONArray(
                    Groups.entries.filter {
                        template.groups.contains(it.gid)
                    }.map {
                        it.name
                    }
                ))
        }

        if (template.capabilities.isNotEmpty()) {
            put(
                "capabilities", JSONArray(
                    Capabilities.entries.filter {
                        template.capabilities.contains(it.cap)
                    }.map {
                        it.name
                    }
                ))
        }

        if (template.context.isNotEmpty()) {
            put("context", template.context)
        }

        if (template.rules.isNotEmpty()) {
            put("rules", JSONArray(template.rules))
        }
    }
}

@Suppress("unused")
fun generateTemplates() {
    val templateJson = JSONObject()
    templateJson.put("id", "com.example")
    templateJson.put("name", "Example")
    templateJson.put("description", "This is an example template")
    templateJson.put("local", true)
    templateJson.put("namespace", Natives.Profile.Namespace.INHERITED.name)
    templateJson.put("uid", 0)
    templateJson.put("gid", 0)

    templateJson.put("groups", JSONArray().apply { put(Groups.INET.name) })
    templateJson.put("capabilities", JSONArray().apply { put(Capabilities.CAP_NET_RAW.name) })
    templateJson.put("context", "u:r:su:s0")
    Log.i(TAG, "$templateJson")
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/AppIconUtil.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.util.LruCache
import androidx.core.graphics.createBitmap
import androidx.core.graphics.scale
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel.Companion.getAppIconDrawable

object AppIconUtil {
    // Limit cache size to 200 icons
    private const val CACHE_SIZE = 200
    private val iconCache = LruCache<String?, Bitmap?>(CACHE_SIZE)

    @Synchronized
    fun loadAppIconSync(context: Context, packageName: String, sizePx: Int): Bitmap? {
        val cached = iconCache.get(packageName)
        if (cached != null) return cached

        try {
            val drawable = getAppIconDrawable(context, packageName) ?: return null
            val raw = drawableToBitmap(drawable, sizePx)
            val icon = raw.scale(sizePx, sizePx)
            iconCache.put(packageName, icon)
            return icon
        } catch (_: Exception) {
            return null
        }
    }

    private fun drawableToBitmap(drawable: Drawable, size: Int): Bitmap {
        if (drawable is BitmapDrawable) return drawable.bitmap

        val width = if (drawable.intrinsicWidth > 0) drawable.intrinsicWidth else size
        val height = if (drawable.intrinsicHeight > 0) drawable.intrinsicHeight else size

        val bmp = createBitmap(width, height)
        val canvas = Canvas(bmp)
        drawable.setBounds(0, 0, canvas.width, canvas.height)
        drawable.draw(canvas)
        return bmp
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/Insets.kt`:

```kt
package me.weishu.kernelsu.ui.webui

/**
 * Insets data class from GitHub@MMRLApp/WebUI-X-Portable
 *
 * Data class representing insets (top, bottom, left, right) for a view.
 *
 * This class provides methods to generate CSS code that can be injected into a WebView
 * to apply these insets as CSS variables. This is useful for adapting web content
 * to the safe areas of a device screen, considering notches, status bars, and navigation bars.
 *
 * @property top The top inset value in pixels.
 * @property bottom The bottom inset value in pixels.
 * @property left The left inset value in pixels.
 * @property right The right inset value in pixels.
 */
data class Insets(
    val top: Int,
    val bottom: Int,
    val left: Int,
    val right: Int,
) {
    val css
        get() = buildString {
            appendLine(":root {")
            appendLine("\t--safe-area-inset-top: ${top}px;")
            appendLine("\t--safe-area-inset-right: ${right}px;")
            appendLine("\t--safe-area-inset-bottom: ${bottom}px;")
            appendLine("\t--safe-area-inset-left: ${left}px;")
            appendLine("\t--window-inset-top: var(--safe-area-inset-top, 0px);")
            appendLine("\t--window-inset-bottom: var(--safe-area-inset-bottom, 0px);")
            appendLine("\t--window-inset-left: var(--safe-area-inset-left, 0px);")
            appendLine("\t--window-inset-right: var(--safe-area-inset-right, 0px);")
            appendLine("\t--f7-safe-area-top: var(--window-inset-top, 0px) !important;")
            appendLine("\t--f7-safe-area-bottom: var(--window-inset-bottom, 0px) !important;")
            appendLine("\t--f7-safe-area-left: var(--window-inset-left, 0px) !important;")
            appendLine("\t--f7-safe-area-right: var(--window-inset-right, 0px) !important;")
            append("}")
        }
    val js
        get() = buildString {
            append("(function() {")
            append(" var s = document.documentElement.style;")
            append(" s.setProperty('--safe-area-inset-top', '${top}px');")
            append(" s.setProperty('--safe-area-inset-right', '${right}px');")
            append(" s.setProperty('--safe-area-inset-bottom', '${bottom}px');")
            append(" s.setProperty('--safe-area-inset-left', '${left}px');")
            append("})();")
        }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/MimeUtil.java`:

```java
/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.weishu.kernelsu.ui.webui;

import java.net.URLConnection;

class MimeUtil {

    public static String getMimeFromFileName(String fileName) {
        if (fileName == null) {
            return null;
        }

        // Copying the logic and mapping that Chromium follows.
        // First we check against the OS (this is a limited list by default)
        // but app developers can extend this.
        // We then check against a list of hardcoded mime types above if the
        // OS didn't provide a result.
        String mimeType = URLConnection.guessContentTypeFromName(fileName);

        if (mimeType != null) {
            return mimeType;
        }

        return guessHardcodedMime(fileName);
    }

    // We should keep this map in sync with the lists under
    // //net/base/mime_util.cc in Chromium.
    // A bunch of the mime types don't really apply to Android land
    // like word docs so feel free to filter out where necessary.
    private static String guessHardcodedMime(String fileName) {
        int finalFullStop = fileName.lastIndexOf('.');
        if (finalFullStop == -1) {
            return null;
        }

        final String extension = fileName.substring(finalFullStop + 1).toLowerCase();

        return switch (extension) {
            case "webm" -> "video/webm";
            case "mpeg", "mpg" -> "video/mpeg";
            case "mp3" -> "audio/mpeg";
            case "wasm" -> "application/wasm";
            case "xhtml", "xht", "xhtm" -> "application/xhtml+xml";
            case "flac" -> "audio/flac";
            case "ogg", "oga", "opus" -> "audio/ogg";
            case "wav" -> "audio/wav";
            case "m4a" -> "audio/x-m4a";
            case "gif" -> "image/gif";
            case "jpeg", "jpg", "jfif", "pjpeg", "pjp" -> "image/jpeg";
            case "png" -> "image/png";
            case "apng" -> "image/apng";
            case "svg", "svgz" -> "image/svg+xml";
            case "webp" -> "image/webp";
            case "mht", "mhtml" -> "multipart/related";
            case "css" -> "text/css";
            case "html", "htm", "shtml", "shtm", "ehtml" -> "text/html";
            case "js", "mjs" -> "application/javascript";
            case "xml" -> "text/xml";
            case "mp4", "m4v" -> "video/mp4";
            case "ogv", "ogm" -> "video/ogg";
            case "ico" -> "image/x-icon";
            case "woff" -> "application/font-woff";
            case "gz", "tgz" -> "application/gzip";
            case "json" -> "application/json";
            case "pdf" -> "application/pdf";
            case "zip" -> "application/zip";
            case "bmp" -> "image/bmp";
            case "tiff", "tif" -> "image/tiff";
            default -> null;
        };
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/MonetColorsProvider.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.graphics.Color
import top.yukonga.miuix.kmp.theme.MiuixTheme
import java.util.concurrent.atomic.AtomicReference

/**
 * @author rifsxd
 * @date 2025/6/2.
 */
object MonetColorsProvider {

    private val colorsCss: AtomicReference<String?> = AtomicReference(null)

    fun getColorsCss(): String {
        return colorsCss.get() ?: ""
    }

    @Composable
    fun UpdateCss() {
        val colorScheme = MiuixTheme.colorScheme

        LaunchedEffect(colorScheme) {
            // Generate CSS only when colorScheme changes
            val monetColors = mapOf(
                // App Base Colors
                "primary" to colorScheme.primary.toCssValue(),
                "onPrimary" to colorScheme.onPrimary.toCssValue(),
                "primaryContainer" to colorScheme.primaryContainer.toCssValue(),
                "onPrimaryContainer" to colorScheme.onPrimaryContainer.toCssValue(),
                "inversePrimary" to colorScheme.primaryVariant.toCssValue(),
                "secondary" to colorScheme.secondary.toCssValue(),
                "onSecondary" to colorScheme.onSecondary.toCssValue(),
                "secondaryContainer" to colorScheme.secondaryContainer.toCssValue(),
                "onSecondaryContainer" to colorScheme.onSecondaryContainer.toCssValue(),
                "tertiary" to colorScheme.tertiaryContainerVariant.toCssValue(),
                "onTertiary" to colorScheme.tertiaryContainer.toCssValue(),
                "tertiaryContainer" to colorScheme.tertiaryContainer.toCssValue(),
                "onTertiaryContainer" to colorScheme.onTertiaryContainer.toCssValue(),
                "background" to colorScheme.background.toCssValue(),
                "onBackground" to colorScheme.onBackground.toCssValue(),
                "surface" to colorScheme.surface.toCssValue(),
                "tonalSurface" to colorScheme.surfaceContainer.toCssValue(),
                "onSurface" to colorScheme.onSurface.toCssValue(),
                "surfaceVariant" to colorScheme.surfaceVariant.toCssValue(),
                "onSurfaceVariant" to colorScheme.onSurfaceVariantSummary.toCssValue(),
                "surfaceTint" to colorScheme.surface.toCssValue(),
                "inverseSurface" to colorScheme.disabledOnSurface.toCssValue(),
                "inverseOnSurface" to colorScheme.surfaceContainer.toCssValue(),
                "error" to colorScheme.error.toCssValue(),
                "onError" to colorScheme.onError.toCssValue(),
                "errorContainer" to colorScheme.errorContainer.toCssValue(),
                "onErrorContainer" to colorScheme.onErrorContainer.toCssValue(),
                "outline" to colorScheme.outline.toCssValue(),
                "outlineVariant" to colorScheme.dividerLine.toCssValue(),
                "scrim" to colorScheme.windowDimming.toCssValue(),
                "surfaceBright" to colorScheme.surface.toCssValue(),
                "surfaceDim" to colorScheme.surface.toCssValue(),
                "surfaceContainer" to colorScheme.surfaceContainer.toCssValue(),
                "surfaceContainerHigh" to colorScheme.surfaceContainerHigh.toCssValue(),
                "surfaceContainerHighest" to colorScheme.surfaceContainerHighest.toCssValue(),
                "surfaceContainerLow" to colorScheme.surfaceContainer.toCssValue(),
                "surfaceContainerLowest" to colorScheme.surfaceContainer.toCssValue(),
                "filledTonalButtonContentColor" to colorScheme.onPrimaryContainer.toCssValue(),
                "filledTonalButtonContainerColor" to colorScheme.secondaryContainer.toCssValue(),
                "filledTonalButtonDisabledContentColor" to colorScheme.onSurfaceVariantSummary.toCssValue(),
                "filledTonalButtonDisabledContainerColor" to colorScheme.surfaceVariant.toCssValue(),
                "filledCardContentColor" to colorScheme.onPrimaryContainer.toCssValue(),
                "filledCardContainerColor" to colorScheme.primaryContainer.toCssValue(),
                "filledCardDisabledContentColor" to colorScheme.onSurfaceVariantSummary.toCssValue(),
                "filledCardDisabledContainerColor" to colorScheme.surfaceVariant.toCssValue()
            )

            colorsCss.set(monetColors.toCssVars())
        }
    }

    private fun Map<String, String>.toCssVars(): String {
        return buildString {
            append(":root {\n")
            for ((k, v) in this@toCssVars) {
                append("  --$k: $v;\n")
            }
            append("}\n")
        }
    }

    private fun Color.toCssValue(): String {
        fun Float.toHex(): String {
            return (this * 255).toInt().coerceIn(0, 255).toString(16).padStart(2, '0')
        }
        return if (alpha == 1f) {
            "#${red.toHex()}${green.toHex()}${blue.toHex()}"
        } else {
            "#${red.toHex()}${green.toHex()}${blue.toHex()}${alpha.toHex()}"
        }
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/SuFilePathHandler.java`:

```java
package me.weishu.kernelsu.ui.webui;

import android.content.Context;
import android.util.Log;
import android.webkit.WebResourceResponse;

import androidx.annotation.NonNull;
import androidx.annotation.WorkerThread;
import androidx.webkit.WebViewAssetLoader;

import com.topjohnwu.superuser.Shell;
import com.topjohnwu.superuser.io.SuFile;
import com.topjohnwu.superuser.io.SuFileInputStream;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.zip.GZIPInputStream;

/**
 * Handler class to open files from file system by root access
 * For more information about android storage please refer to
 * <a href="https://developer.android.com/guide/topics/data/data-storage">Android Developers
 * Docs: Data and file storage overview</a>.
 * <p class="note">
 * To avoid leaking user or app data to the web, make sure to choose {@code directory}
 * carefully, and assume any file under this directory could be accessed by any web page subject
 * to same-origin rules.
 * <p>
 * A typical usage would be like:
 * <pre class="prettyprint">
 * File publicDir = new File(context.getFilesDir(), "public");
 * // Host "files/public/" in app's data directory under:
 * // http://appassets.androidplatform.net/public/...
 * WebViewAssetLoader assetLoader = new WebViewAssetLoader.Builder()
 *          .addPathHandler("/public/", new InternalStoragePathHandler(context, publicDir))
 *          .build();
 * </pre>
 */
public final class SuFilePathHandler implements WebViewAssetLoader.PathHandler {
    /**
     * Default value to be used as MIME type if guessing MIME type failed.
     */
    public static final String DEFAULT_MIME_TYPE = "text/plain";
    private static final String TAG = "SuFilePathHandler";
    /**
     * Forbidden subdirectories of {@link Context#getDataDir} that cannot be exposed by this
     * handler. They are forbidden as they often contain sensitive information.
     * <p class="note">
     * Note: Any future addition to this list will be considered breaking changes to the API.
     */
    private static final String[] FORBIDDEN_DATA_DIRS =
            new String[]{"/data/data", "/data/system"};

    @NonNull
    private final File mDirectory;

    private final Shell mShell;
    private final InsetsSupplier mInsetsSupplier;
    private final OnInsetsRequestedListener mOnInsetsRequestedListener;
    private final Context mContext;

    /**
     * Creates PathHandler for app's internal storage.
     * The directory to be exposed must be inside either the application's internal data
     * directory {@link Context#getDataDir} or cache directory {@link Context#getCacheDir}.
     * External storage is not supported for security reasons, as other apps with
     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} may be able to modify the
     * files.
     * <p>
     * Exposing the entire data or cache directory is not permitted, to avoid accidentally
     * exposing sensitive application files to the web. Certain existing subdirectories of
     * {@link Context#getDataDir} are also not permitted as they are often sensitive.
     * These files are ({@code "app_webview/"}, {@code "databases/"}, {@code "lib/"},
     * {@code "shared_prefs/"} and {@code "code_cache/"}).
     * <p>
     * The application should typically use a dedicated subdirectory for the files it intends to
     * expose and keep them separate from other files.
     *
     * @param context                   {@link Context} that is used to access app's internal storage.
     * @param directory                 the absolute path of the exposed app internal storage directory from
     *                                  which files can be loaded.
     * @param rootShell                 {@link Shell} instance with root access to read files.
     * @param insetsSupplier            {@link InsetsSupplier} to provide window insets for styling web content.
     * @param onInsetsRequestedListener {@link OnInsetsRequestedListener} to notify when insets are requested.
     * @throws IllegalArgumentException if the directory is not allowed.
     */
    public SuFilePathHandler(@NonNull Context context, @NonNull File directory, Shell rootShell, @NonNull InsetsSupplier insetsSupplier, OnInsetsRequestedListener onInsetsRequestedListener) {
        try {
            mContext = context;
            mInsetsSupplier = insetsSupplier;
            mOnInsetsRequestedListener = onInsetsRequestedListener;
            mDirectory = new File(getCanonicalDirPath(directory));
            if (!isAllowedInternalStorageDir(context)) {
                throw new IllegalArgumentException("The given directory \"" + directory
                        + "\" doesn't exist under an allowed app internal storage directory");
            }
            mShell = rootShell;
        } catch (IOException e) {
            throw new IllegalArgumentException(
                    "Failed to resolve the canonical path for the given directory: "
                            + directory.getPath(), e);
        }
    }

    public static String getCanonicalDirPath(@NonNull File file) throws IOException {
        String canonicalPath = file.getCanonicalPath();
        if (!canonicalPath.endsWith("/")) canonicalPath += "/";
        return canonicalPath;
    }

    public static File getCanonicalFileIfChild(@NonNull File parent, @NonNull String child)
            throws IOException {
        String parentCanonicalPath = getCanonicalDirPath(parent);
        String childCanonicalPath = new File(parent, child).getCanonicalPath();
        if (childCanonicalPath.startsWith(parentCanonicalPath)) {
            return new File(childCanonicalPath);
        }
        return null;
    }

    @NonNull
    private static InputStream handleSvgzStream(@NonNull String path,
                                                @NonNull InputStream stream) throws IOException {
        return path.endsWith(".svgz") ? new GZIPInputStream(stream) : stream;
    }

    public static InputStream openFile(@NonNull File file, @NonNull Shell shell) throws IOException {
        SuFile suFile = new SuFile(file.getAbsolutePath());
        suFile.setShell(shell);
        InputStream fis = SuFileInputStream.open(suFile);
        return handleSvgzStream(file.getPath(), fis);
    }

    /**
     * Use {@link MimeUtil#getMimeFromFileName} to guess MIME type or return the
     * {@link #DEFAULT_MIME_TYPE} if it can't guess.
     *
     * @param filePath path of the file to guess its MIME type.
     * @return MIME type guessed from file extension or {@link #DEFAULT_MIME_TYPE}.
     */
    @NonNull
    public static String guessMimeType(@NonNull String filePath) {
        String mimeType = MimeUtil.getMimeFromFileName(filePath);
        return mimeType == null ? DEFAULT_MIME_TYPE : mimeType;
    }

    private boolean isAllowedInternalStorageDir(@NonNull Context context) throws IOException {
        String dir = getCanonicalDirPath(mDirectory);

        for (String forbiddenPath : FORBIDDEN_DATA_DIRS) {
            if (dir.startsWith(forbiddenPath)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Opens the requested file from the exposed data directory.
     * <p>
     * The matched prefix path used shouldn't be a prefix of a real web path. Thus, if the
     * requested file cannot be found or is outside the mounted directory a
     * {@link WebResourceResponse} object with a {@code null} {@link InputStream} will be
     * returned instead of {@code null}. This saves the time of falling back to network and
     * trying to resolve a path that doesn't exist. A {@link WebResourceResponse} with
     * {@code null} {@link InputStream} will be received as an HTTP response with status code
     * {@code 404} and no body.
     * <p class="note">
     * The MIME type for the file will be determined from the file's extension using
     * {@link java.net.URLConnection#guessContentTypeFromName}. Developers should ensure that
     * files are named using standard file extensions. If the file does not have a
     * recognised extension, {@code "text/plain"} will be used by default.
     *
     * @param path the suffix path to be handled.
     * @return {@link WebResourceResponse} for the requested file.
     */
    @Override
    @WorkerThread
    @NonNull
    public WebResourceResponse handle(@NonNull String path) {
        if ("internal/insets.css".equals(path)) {
            if (mOnInsetsRequestedListener != null) {
                mOnInsetsRequestedListener.onInsetsRequested(true);
            }
            String css = mInsetsSupplier.get().getCss();
            return new WebResourceResponse(
                    "text/css",
                    "utf-8",
                    new ByteArrayInputStream(css.getBytes(StandardCharsets.UTF_8))
            );
        }
        if ("internal/colors.css".equals(path)) {
            int colorMode = mContext.getSharedPreferences("settings", Context.MODE_PRIVATE).getInt("color_mode", 0);
            String css = "";
            if (colorMode >= 3 && colorMode <= 5) {
                css = MonetColorsProvider.INSTANCE.getColorsCss();
            }
            return new WebResourceResponse(
                    "text/css",
                    "utf-8",
                    new ByteArrayInputStream(css.getBytes(StandardCharsets.UTF_8))
            );
        }
        try {
            File file = getCanonicalFileIfChild(mDirectory, path);
            if (file != null) {
                InputStream is = openFile(file, mShell);
                String mimeType = guessMimeType(path);
                return new WebResourceResponse(mimeType, null, is);
            } else {
                Log.e(TAG, String.format(
                        "The requested file: %s is outside the mounted directory: %s", path,
                        mDirectory));
            }
        } catch (IOException e) {
            Log.e(TAG, "Error opening the requested path: " + path, e);
        }
        return new WebResourceResponse(null, null, null);
    }

    public interface InsetsSupplier {
        @NonNull
        Insets get();
    }

    public interface OnInsetsRequestedListener {
        void onInsetsRequested(boolean enable);
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/WebUIActivity.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import android.annotation.SuppressLint
import android.os.Build
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.animation.Crossfade
import androidx.compose.animation.core.tween
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import me.weishu.kernelsu.ui.theme.KernelSUTheme
import top.yukonga.miuix.kmp.basic.InfiniteProgressIndicator

@SuppressLint("SetJavaScriptEnabled")
class WebUIActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {

        // Enable edge to edge
        enableEdgeToEdge()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            window.isNavigationBarContrastEnforced = false
        }

        super.onCreate(savedInstanceState)

        setContent {
            val prefs = LocalContext.current.getSharedPreferences("settings", MODE_PRIVATE)
            var colorMode by remember { mutableIntStateOf(prefs.getInt("color_mode", 0)) }
            var keyColorInt by remember { mutableIntStateOf(prefs.getInt("key_color", 0)) }
            val keyColor =
                remember(keyColorInt) {
                    if (keyColorInt == 0) null else androidx.compose.ui.graphics.Color(
                        keyColorInt
                    )
                }
            KernelSUTheme(colorMode = colorMode, keyColor = keyColor) {
                MainContent(activity = this, onFinish = { finish() })
            }
        }
    }
}

@Composable
private fun MainContent(activity: ComponentActivity, onFinish: () -> Unit) {
    val moduleId = remember { activity.intent.getStringExtra("id") }
    val webUIState = remember { WebUIState() }


    LaunchedEffect(moduleId) {
        if (moduleId == null) {
            onFinish()
            return@LaunchedEffect
        }
        prepareWebView(activity, moduleId, webUIState)
    }

    DisposableEffect(Unit) {
        onDispose { webUIState.dispose() }
    }

    when (val event = webUIState.uiEvent) {
        is WebUIEvent.Error -> {
            LaunchedEffect(event) {
                Toast.makeText(activity, event.message, Toast.LENGTH_SHORT).show()
                onFinish()
            }
        }

        is WebUIEvent.Close -> {
            LaunchedEffect(event) { onFinish() }
        }

        else -> {}
    }
    val isLoading = webUIState.uiEvent is WebUIEvent.Loading

    Crossfade(targetState = isLoading, animationSpec = tween(300)) { loading ->
        if (loading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                InfiniteProgressIndicator()
            }
        } else {
            WebUIScreen(webUIState = webUIState)
        }
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/WebUIScreen.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import android.app.Activity
import android.net.Uri
import android.view.View
import android.view.ViewGroup
import android.webkit.WebView
import androidx.activity.compose.BackHandler
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.WindowInsets
import androidx.compose.foundation.layout.asPaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.safeDrawing
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.text.input.rememberTextFieldState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.compose.LocalLifecycleOwner
import me.weishu.kernelsu.R
import top.yukonga.miuix.kmp.basic.ButtonDefaults
import top.yukonga.miuix.kmp.basic.Text
import top.yukonga.miuix.kmp.basic.TextButton
import top.yukonga.miuix.kmp.basic.TextField
import top.yukonga.miuix.kmp.extra.WindowDialog


@Composable
fun WebUIScreen(webUIState: WebUIState) {
    val density = LocalDensity.current
    val layoutDirection = LocalLayoutDirection.current
    val windowInsets = WindowInsets.safeDrawing
    val innerPadding = if (webUIState.isInsetsEnabled) PaddingValues(0.dp) else windowInsets.asPaddingValues()

    LaunchedEffect(density, layoutDirection, windowInsets, webUIState.isInsetsEnabled) {
        if (!webUIState.isInsetsEnabled) {
            return@LaunchedEffect
        }
        snapshotFlow {
            val top = (windowInsets.getTop(density) / density.density).toInt()
            val bottom = (windowInsets.getBottom(density) / density.density).toInt()
            val left = (windowInsets.getLeft(density, layoutDirection) / density.density).toInt()
            val right = (windowInsets.getRight(density, layoutDirection) / density.density).toInt()
            Insets(top, bottom, left, right)
        }.collect { newInsets ->
            if (webUIState.currentInsets != newInsets) {
                webUIState.currentInsets = newInsets
                webUIState.webView?.evaluateJavascript(newInsets.js, null)
            }
        }
    }

    BackHandler(enabled = webUIState.webCanGoBack) {
        webUIState.webView?.goBack()
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(innerPadding)
    ) {
        if (webUIState.webView != null) {
            AndroidView(
                modifier = Modifier.fillMaxSize(),
                factory = { _ ->
                    webUIState.webView!!.apply {
                        layoutParams = ViewGroup.LayoutParams(
                            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT
                        )
                        if (!webUIState.isUrlLoaded) {
                            val homePage = "https://mui.kernelsu.org/index.html"
                            if (width > 0 && height > 0) {
                                loadUrl(homePage)
                                webUIState.isUrlLoaded = true
                            } else {
                                val listener = object : View.OnLayoutChangeListener {
                                    override fun onLayoutChange(
                                        v: View, left: Int, top: Int, right: Int, bottom: Int,
                                        oldLeft: Int, oldTop: Int, oldRight: Int, oldBottom: Int
                                    ) {
                                        if (v.width > 0 && v.height > 0) {
                                            (v as WebView).loadUrl(homePage)
                                            webUIState.isUrlLoaded = true
                                            v.removeOnLayoutChangeListener(this)
                                        }
                                    }
                                }
                                addOnLayoutChangeListener(listener)
                            }
                        }
                    }
                }
            )
        }
    }

    HandleWebUIEvent(webUIState)
    HandleWebViewLifecycle(webUIState)
    HandleConfigurationChanges(webUIState)
}

@Composable
private fun HandleWebUIEvent(webUIState: WebUIState) {

    val fileLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        val uris: Array<Uri>? = if (result.resultCode == Activity.RESULT_OK) {
            result.data?.let { data ->
                if (data.clipData != null) {
                    Array(data.clipData!!.itemCount) { i -> data.clipData!!.getItemAt(i).uri }
                } else {
                    data.data?.let { arrayOf(it) }
                }
            }
        } else null
        webUIState.onFileChooserResult(uris)
    }

    when (val event = webUIState.uiEvent) {
        is WebUIEvent.ShowAlert -> {
            val showDialog = remember(event) { mutableStateOf(true) }
            WindowDialog(
                onDismissRequest = { },
                show = showDialog,
            ) {
                Column {
                    Text(event.message)
                    Spacer(Modifier.height(12.dp))
                    TextButton(
                        modifier = Modifier.fillMaxWidth(), onClick = {
                            webUIState.onAlertResult()
                            showDialog.value = false
                        }, text = stringResource(R.string.confirm), colors = ButtonDefaults.textButtonColorsPrimary()
                    )
                }
            }
        }

        is WebUIEvent.ShowConfirm -> {
            val showDialog = remember(event) { mutableStateOf(true) }
            WindowDialog(
                onDismissRequest = { webUIState.onConfirmResult(false) },
                show = showDialog,
            ) {
                Column {
                    Text(event.message)
                    Spacer(Modifier.height(12.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        TextButton(
                            onClick = {
                                webUIState.onConfirmResult(false)
                                showDialog.value = false
                            },
                            text = stringResource(android.R.string.cancel),
                            modifier = Modifier.weight(1f),
                        )
                        Spacer(modifier = Modifier.width(20.dp))
                        TextButton(
                            onClick = {
                                webUIState.onConfirmResult(true)
                                showDialog.value = false
                            }, text = stringResource(R.string.confirm), modifier = Modifier.weight(1f), colors = ButtonDefaults.textButtonColorsPrimary()
                        )
                    }
                }
            }
        }

        is WebUIEvent.ShowPrompt -> {
            val showDialog = remember(event) { mutableStateOf(true) }
            val state = rememberTextFieldState(event.defaultValue)
            WindowDialog(
                onDismissRequest = { webUIState.onPromptResult(null) },
                show = showDialog,
            ) {
                Column {
                    Text(event.message)
                    Spacer(Modifier.height(12.dp))
                    TextField(
                        modifier = Modifier.padding(bottom = 16.dp), state = state
                    )
                    Row(
                        modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        TextButton(
                            onClick = {
                                webUIState.onPromptResult(null)
                                showDialog.value = false
                            },
                            text = stringResource(android.R.string.cancel),
                            modifier = Modifier.weight(1f),
                        )
                        Spacer(modifier = Modifier.width(20.dp))
                        TextButton(
                            onClick = {
                                webUIState.onPromptResult(state.text.toString())
                                showDialog.value = false
                            }, text = stringResource(R.string.confirm), modifier = Modifier.weight(1f), colors = ButtonDefaults.textButtonColorsPrimary()
                        )
                    }
                }
            }
        }

        is WebUIEvent.ShowFileChooser -> {
            LaunchedEffect(event) {
                try {
                    fileLauncher.launch(event.intent)
                } catch (_: Exception) {
                    webUIState.onFileChooserResult(null)
                }
            }
        }

        else -> {}
    }
}

@Composable
private fun HandleWebViewLifecycle(webUIState: WebUIState) {
    val lifecycleOwner = LocalLifecycleOwner.current

    DisposableEffect(lifecycleOwner, webUIState) {
        val observer = LifecycleEventObserver { _, event ->
            when (event) {
                Lifecycle.Event.ON_RESUME -> webUIState.webView?.onResume()
                Lifecycle.Event.ON_PAUSE -> webUIState.webView?.onPause()
                else -> {}
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)

        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
}

@Composable
private fun HandleConfigurationChanges(webUIState: WebUIState) {
    val configuration = LocalConfiguration.current
    LaunchedEffect(configuration.fontScale, webUIState.webView) {
        webUIState.webView?.settings?.textZoom = (configuration.fontScale * 100).toInt()
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/WebUIState.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import android.content.Intent
import android.net.Uri
import android.webkit.JsPromptResult
import android.webkit.JsResult
import android.webkit.WebView
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import com.topjohnwu.superuser.Shell

sealed class WebUIEvent {
    data object Loading : WebUIEvent()
    data object WebViewReady : WebUIEvent()
    data class Error(val message: String) : WebUIEvent()
    data object Close : WebUIEvent()
    data class ShowAlert(val message: String, val result: JsResult) : WebUIEvent()
    data class ShowConfirm(val message: String, val result: JsResult) : WebUIEvent()
    data class ShowPrompt(val message: String, val defaultValue: String, val result: JsPromptResult) : WebUIEvent()
    data class ShowFileChooser(val intent: Intent) : WebUIEvent()
}

class WebUIState {
    var webView: WebView? = null
    var rootShell: Shell? = null
    lateinit var modDir: String
    var moduleName: String = ""

    var uiEvent by mutableStateOf<WebUIEvent>(WebUIEvent.Loading)
    var isUrlLoaded = false
    var currentInsets: Insets = Insets(0, 0, 0, 0)
    var isInsetsEnabled by mutableStateOf(false)
    var webCanGoBack by mutableStateOf(false)
    var filePathCallback: android.webkit.ValueCallback<Array<Uri>>? = null

    fun onAlertResult() {
        val event = uiEvent
        if (event is WebUIEvent.ShowAlert) {
            event.result.confirm()
            uiEvent = WebUIEvent.WebViewReady
        }
    }

    fun onConfirmResult(confirmed: Boolean) {
        val event = uiEvent
        if (event is WebUIEvent.ShowConfirm) {
            if (confirmed) event.result.confirm() else event.result.cancel()
            uiEvent = WebUIEvent.WebViewReady
        }
    }

    fun onPromptResult(result: String?) {
        val event = uiEvent
        if (event is WebUIEvent.ShowPrompt) {
            if (result != null) event.result.confirm(result) else event.result.cancel()
            uiEvent = WebUIEvent.WebViewReady
        }
    }

    fun onFileChooserResult(uris: Array<Uri>?) {
        filePathCallback?.onReceiveValue(uris)
        filePathCallback = null
        uiEvent = WebUIEvent.WebViewReady
    }

    fun requestExit() {
        uiEvent = WebUIEvent.Close
    }

    fun dispose() {
        webView?.let { view ->
            (view.parent as? android.view.ViewGroup)?.removeView(view)
            view.destroy()
        }
        webView = null
        rootShell?.close()
    }
}

```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/WebViewHelper.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import android.annotation.SuppressLint
import android.app.Activity
import android.app.ActivityManager
import android.content.Context
import android.content.Intent
import android.graphics.Color
import android.net.Uri
import android.os.Build
import android.webkit.JsPromptResult
import android.webkit.JsResult
import android.webkit.ValueCallback
import android.webkit.WebChromeClient
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.webkit.WebViewAssetLoader
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import me.weishu.kernelsu.R
import me.weishu.kernelsu.ui.util.createRootShell
import me.weishu.kernelsu.ui.viewmodel.ModuleViewModel
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel
import java.io.File


@SuppressLint("SetJavaScriptEnabled")
internal suspend fun prepareWebView(
    activity: Activity,
    moduleId: String,
    webUIState: WebUIState,
) {
    withContext(Dispatchers.IO) {
        val viewModel = ModuleViewModel()
        if (viewModel.moduleList.isEmpty()) {
            viewModel.loadModuleList()
        }

        val moduleInfo = viewModel.moduleList.find { info -> info.id == moduleId }

        if (moduleInfo == null) {
            withContext(Dispatchers.Main) {
                webUIState.uiEvent = WebUIEvent.Error(activity.getString(R.string.no_such_module, moduleId))
            }
            return@withContext
        }

        if (!moduleInfo.hasWebUi || !moduleInfo.enabled || moduleInfo.update || moduleInfo.remove) {
            withContext(Dispatchers.Main) {
                webUIState.uiEvent = WebUIEvent.Error(activity.getString(R.string.module_unavailable, moduleInfo.name))
            }
            return@withContext
        }

        webUIState.moduleName = moduleInfo.name
        webUIState.modDir = "/data/adb/modules/${moduleId}"

        if (SuperUserViewModel.apps.isEmpty()) {
            SuperUserViewModel().fetchAppList()
        }
        val shell = createRootShell(true)
        webUIState.rootShell = shell

        withContext(Dispatchers.Main) {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
                @Suppress("DEPRECATION")
                activity.setTaskDescription(ActivityManager.TaskDescription("KernelSU - ${moduleInfo.name}"))
            } else {
                val taskDescription = ActivityManager.TaskDescription.Builder()
                    .setLabel("KernelSU - ${moduleInfo.name}")
                    .build()
                activity.setTaskDescription(taskDescription)
            }

            val webView = WebView(activity)
            webView.setBackgroundColor(Color.TRANSPARENT)

            val prefs = activity.getSharedPreferences("settings", Context.MODE_PRIVATE)
            WebView.setWebContentsDebuggingEnabled(prefs.getBoolean("enable_web_debugging", false))

            webView.settings.apply {
                javaScriptEnabled = true
                domStorageEnabled = true
                allowFileAccess = false
            }

            val webRoot = File("${webUIState.modDir}/webroot")
            val webViewAssetLoader = WebViewAssetLoader.Builder()
                .setDomain("mui.kernelsu.org")
                .addPathHandler(
                    "/",
                    SuFilePathHandler(activity, webRoot, shell, { webUIState.currentInsets }, { enable -> webUIState.isInsetsEnabled = enable })
                )
                .build()

            // WebViewClient
            webView.webViewClient = object : WebViewClient() {
                override fun shouldInterceptRequest(view: WebView, request: WebResourceRequest): WebResourceResponse? {
                    val url = request.url
                    if (url.scheme.equals("ksu", ignoreCase = true) && url.host.equals("icon", ignoreCase = true)) {
                        val packageName = url.path?.substring(1)
                        if (!packageName.isNullOrEmpty()) {
                            val icon = AppIconUtil.loadAppIconSync(activity, packageName, 512)
                            if (icon != null) {
                                val stream = java.io.ByteArrayOutputStream()
                                icon.compress(android.graphics.Bitmap.CompressFormat.PNG, 100, stream)
                                return WebResourceResponse("image/png", null, java.io.ByteArrayInputStream(stream.toByteArray()))
                            }
                        }
                    }
                    return webViewAssetLoader.shouldInterceptRequest(url)
                }

                override fun doUpdateVisitedHistory(view: WebView?, url: String?, isReload: Boolean) {
                    webUIState.webCanGoBack = view?.canGoBack() ?: false
                    if (webUIState.isInsetsEnabled) webUIState.webView?.evaluateJavascript(webUIState.currentInsets.js, null)
                    super.doUpdateVisitedHistory(view, url, isReload)
                }
            }

            // WebChromeClient
            webView.webChromeClient = object : WebChromeClient() {
                override fun onJsAlert(view: WebView?, url: String?, message: String?, result: JsResult?): Boolean {
                    if (message == null || result == null) return false
                    webUIState.uiEvent = WebUIEvent.ShowAlert(message, result)
                    return true
                }

                override fun onJsConfirm(view: WebView?, url: String?, message: String?, result: JsResult?): Boolean {
                    if (message == null || result == null) return false
                    webUIState.uiEvent = WebUIEvent.ShowConfirm(message, result)
                    return true
                }

                override fun onJsPrompt(view: WebView?, url: String?, message: String?, defaultValue: String?, result: JsPromptResult?): Boolean {
                    if (message == null || result == null || defaultValue == null) return false
                    webUIState.uiEvent = WebUIEvent.ShowPrompt(message, defaultValue, result)
                    return true
                }

                override fun onShowFileChooser(
                    webView: WebView?, filePathCallback: ValueCallback<Array<Uri>>?, fileChooserParams: FileChooserParams?
                ): Boolean {
                    webUIState.filePathCallback?.onReceiveValue(null)
                    webUIState.filePathCallback = filePathCallback

                    val intent = fileChooserParams?.createIntent() ?: Intent(Intent.ACTION_GET_CONTENT).apply { type = "*/*" }
                    if (fileChooserParams?.mode == FileChooserParams.MODE_OPEN_MULTIPLE) {
                        intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
                    }
                    webUIState.uiEvent = WebUIEvent.ShowFileChooser(intent)
                    return true
                }
            }

            // JS Interface
            val webviewInterface = WebViewInterface(webUIState)
            webUIState.webView = webView
            webView.addJavascriptInterface(webviewInterface, "ksu")
            webUIState.uiEvent = WebUIEvent.WebViewReady
        }
    }
}
```

`manager/app/src/main/java/me/weishu/kernelsu/ui/webui/WebViewInterface.kt`:

```kt
package me.weishu.kernelsu.ui.webui

import android.app.Activity
import android.content.pm.ApplicationInfo
import android.os.Handler
import android.os.Looper
import android.text.TextUtils
import android.view.Window
import android.webkit.JavascriptInterface
import android.widget.Toast
import androidx.core.content.pm.PackageInfoCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat
import com.topjohnwu.superuser.CallbackList
import com.topjohnwu.superuser.ShellUtils
import com.topjohnwu.superuser.internal.UiThreadHandler
import me.weishu.kernelsu.ui.util.createRootShell
import me.weishu.kernelsu.ui.util.listModules
import me.weishu.kernelsu.ui.util.withNewRootShell
import me.weishu.kernelsu.ui.viewmodel.SuperUserViewModel
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.util.concurrent.CompletableFuture

class WebViewInterface(private val state: WebUIState) {
    private val webView get() = state.webView!!
    private val modDir get() = state.modDir

    @JavascriptInterface
    fun exec(cmd: String): String {
        return withNewRootShell(true) { ShellUtils.fastCmd(this, cmd) }
    }

    @JavascriptInterface
    fun exec(cmd: String, callbackFunc: String) {
        exec(cmd, null, callbackFunc)
    }

    private fun processOptions(sb: StringBuilder, options: String?) {
        val opts = if (options == null) JSONObject() else {
            JSONObject(options)
        }

        val cwd = opts.optString("cwd")
        if (!TextUtils.isEmpty(cwd)) {
            sb.append("cd ${cwd};")
        }

        opts.optJSONObject("env")?.let { env ->
            env.keys().forEach { key ->
                sb.append("export ${key}=${env.getString(key)};")
            }
        }
    }

    @JavascriptInterface
    fun exec(
        cmd: String,
        options: String?,
        callbackFunc: String
    ) {
        val finalCommand = StringBuilder()
        processOptions(finalCommand, options)
        finalCommand.append(cmd)

        val result = withNewRootShell(true) {
            newJob().add(finalCommand.toString()).to(ArrayList(), ArrayList()).exec()
        }
        val stdout = result.out.joinToString(separator = "\n")
        val stderr = result.err.joinToString(separator = "\n")

        val jsCode =
            "javascript: (function() { try { ${callbackFunc}(${result.code}, ${
                JSONObject.quote(
                    stdout
                )
            }, ${JSONObject.quote(stderr)}); } catch(e) { console.error(e); } })();"
        webView.post {
            webView.loadUrl(jsCode)
        }
    }

    @JavascriptInterface
    fun spawn(command: String, args: String, options: String?, callbackFunc: String) {
        val finalCommand = StringBuilder()

        processOptions(finalCommand, options)

        if (!TextUtils.isEmpty(args)) {
            finalCommand.append(command).append(" ")
            JSONArray(args).let { argsArray ->
                for (i in 0 until argsArray.length()) {
                    finalCommand.append(argsArray.getString(i))
                    finalCommand.append(" ")
                }
            }
        } else {
            finalCommand.append(command)
        }

        val shell = createRootShell(true)

        val emitData = fun(name: String, data: String) {
            val jsCode =
                "javascript: (function() { try { ${callbackFunc}.${name}.emit('data', ${
                    JSONObject.quote(
                        data
                    )
                }); } catch(e) { console.error('emitData', e); } })();"
            webView.post {
                webView.loadUrl(jsCode)
            }
        }

        val stdout = object : CallbackList<String>(UiThreadHandler::runAndWait) {
            override fun onAddElement(s: String) {
                emitData("stdout", s)
            }
        }

        val stderr = object : CallbackList<String>(UiThreadHandler::runAndWait) {
            override fun onAddElement(s: String) {
                emitData("stderr", s)
            }
        }

        val future = shell.newJob().add(finalCommand.toString()).to(stdout, stderr).enqueue()
        val completableFuture = CompletableFuture.supplyAsync {
            future.get()
        }

        completableFuture.thenAccept { result ->
            val emitExitCode =
                "javascript: (function() { try { ${callbackFunc}.emit('exit', ${result.code}); } catch(e) { console.error(`emitExit error: \${e}`); } })();"
            webView.post {
                webView.loadUrl(emitExitCode)
            }

            if (result.code != 0) {
                val emitErrCode =
                    "javascript: (function() { try { var err = new Error(); err.exitCode = ${result.code}; err.message = ${
                        JSONObject.quote(
                            result.err.joinToString(
                                "\n"
                            )
                        )
                    };${callbackFunc}.emit('error', err); } catch(e) { console.error('emitErr', e); } })();"
                webView.post {
                    webView.loadUrl(emitErrCode)
                }
            }
        }.whenComplete { _, _ ->
            runCatching { shell.close() }
        }
    }

    @JavascriptInterface
    fun toast(msg: String) {
        webView.post {
            Toast.makeText(webView.context, msg, Toast.LENGTH_SHORT).show()
        }
    }

    @JavascriptInterface
    fun fullScreen(enable: Boolean) {
        val context = webView.context
        if (context is Activity) {
            Handler(Looper.getMainLooper()).post {
                if (enable) {
                    hideSystemUI(context.window)
                } else {
                    showSystemUI(context.window)
                }
            }
        }
        enableEdgeToEdge(enable)
    }

    @JavascriptInterface
    fun enableEdgeToEdge(enable: Boolean = true) {
        state.isInsetsEnabled = enable
    }

    @JavascriptInterface
    fun moduleInfo(): String {
        val moduleInfos = JSONArray(listModules())
        val currentModuleInfo = JSONObject()
        currentModuleInfo.put("moduleDir", modDir)
        val moduleId = File(modDir).name
        for (i in 0 until moduleInfos.length()) {
            val currentInfo = moduleInfos.getJSONObject(i)

            if (currentInfo.getString("id") != moduleId) {
                continue
            }

            val keys = currentInfo.keys()
            for (key in keys) {
                currentModuleInfo.put(key, currentInfo.get(key))
            }
            break
        }
        return currentModuleInfo.toString()
    }

    @JavascriptInterface
    fun listPackages(type: String): String {
        val packageNames = SuperUserViewModel.apps
            .filter { appInfo ->
                val flags = appInfo.packageInfo.applicationInfo?.flags ?: 0
                when (type.lowercase()) {
                    "system" -> (flags and ApplicationInfo.FLAG_SYSTEM) != 0
                    "user" -> (flags and ApplicationInfo.FLAG_SYSTEM) == 0
                    else -> true
                }
            }
            .map { it.packageName }
            .sorted()

        val jsonArray = JSONArray()
        for (pkgName in packageNames) {
            jsonArray.put(pkgName)
        }
        return jsonArray.toString()
    }

    @JavascriptInterface
    fun getPackagesInfo(packageNamesJson: String): String {
        val packageNames = JSONArray(packageNamesJson)
        val jsonArray = JSONArray()
        val appMap = SuperUserViewModel.apps.associateBy { it.packageName }
        for (i in 0 until packageNames.length()) {
            val pkgName = packageNames.getString(i)
            val appInfo = appMap[pkgName]
            if (appInfo != null) {
                val pkg = appInfo.packageInfo
                val app = pkg.applicationInfo
                val obj = JSONObject()
                obj.put("packageName", pkg.packageName)
                obj.put("versionName", pkg.versionName ?: "")
                obj.put("versionCode", PackageInfoCompat.getLongVersionCode(pkg))
                obj.put("appLabel", appInfo.label)
                obj.put("isSystem", if (app != null) ((app.flags and ApplicationInfo.FLAG_SYSTEM) != 0) else JSONObject.NULL)
                obj.put("uid", app?.uid ?: JSONObject.NULL)
                jsonArray.put(obj)
            } else {
                val obj = JSONObject()
                obj.put("packageName", pkgName)
                obj.put("error", "Package not found or inaccessible")
                jsonArray.put(obj)
            }
        }
        return jsonArray.toString()
    }

    @JavascriptInterface
    fun exit() {
        state.requestExit()
    }
}

fun hideSystemUI(window: Window) =
    WindowInsetsControllerCompat(window, window.decorView).let { controller ->
        controller.hide(WindowInsetsCompat.Type.systemBars())
        controller.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
    }

fun showSystemUI(window: Window) =
    WindowInsetsControllerCompat(window, window.decorView).show(WindowInsetsCompat.Type.systemBars())

```

`manager/app/src/main/res/drawable/ic_launcher_foreground.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">

    <group
        android:scaleX="0.135"
        android:scaleY="0.135">
        <path
            android:pathData="M 259 259 H 541 V 541 H 259 V 259 Z"
            android:strokeWidth="18"
            android:strokeColor="#1e110d" />
        <path
            android:fillColor="#1e110d"
            android:pathData="M 257 257 H 407 V 407 H 257 V 257 Z" />
        <path
            android:fillColor="#1e110d"
            android:pathData="M 393 393 H 543 V 543 H 393 V 393 Z" />
    </group>
</vector>
```

`manager/app/src/main/res/drawable/ic_launcher_monochrome.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">

    <group
        android:scaleX="0.135"
        android:scaleY="0.135">
        <path
            android:pathData="M 259 259 H 541 V 541 H 259 V 259 Z"
            android:strokeWidth="18"
            android:strokeColor="#000000" />
        <path
            android:fillColor="#000000"
            android:pathData="M 257 257 H 407 V 407 H 257 V 257 Z" />
        <path
            android:fillColor="#000000"
            android:pathData="M 393 393 H 543 V 543 H 393 V 393 Z" />
    </group>
</vector>
```

`manager/app/src/main/res/mipmap-anydpi/ic_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_monochrome" />
</adaptive-icon>
```

`manager/app/src/main/res/resources.properties`:

```properties
unqualifiedResLocale=en-US
```

`manager/app/src/main/res/values-ar/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">الرئيسية</string>
    <string name="home_not_installed">غير مثبت</string>
    <string name="home_click_to_install">إضغط للتثبيت</string>
    <string name="home_working">يعمل</string>
    <string name="home_working_version">الإصدار: %d</string>
    <string name="home_unsupported">غير مدعوم</string>
    <string name="home_unsupported_reason">KernelSU يدعم GKI kernels فقط</string>
    <string name="home_kernel">إصدار النواة</string>
    <string name="home_manager_version">إصدار المدير</string>
    <string name="home_fingerprint">البصمة</string>
    <string name="home_selinux_status">وضع SELinux</string>
    <string name="selinux_status_disabled">معطل</string>
    <string name="selinux_status_enforcing">مفروض</string>
    <string name="selinux_status_permissive">متساهل</string>
    <string name="selinux_status_unknown">مجهول</string>
    <string name="superuser">مستخدم خارق</string>
    <string name="module_failed_to_enable">فشل في تمكين الوحدة %s</string>
    <string name="module_failed_to_disable">فشل تعطيل الإضافة : %s</string>
    <string name="module_empty">لا توجد إضافات مثبتة</string>
    <string name="module">الإضافات</string>
    <string name="uninstall">إلغاء التثبيت</string>
    <string name="module_install">تثبيت الوحدة</string>
    <string name="install">تثبيت</string>
    <string name="reboot">إعادة تشغيل</string>
    <string name="settings">الإعدادات</string>
    <string name="reboot_userspace">إعادة تشغيل سريعة</string>
    <string name="reboot_recovery">إعادة تشغيل إلى وضع Recovery</string>
    <string name="reboot_bootloader">إعادة تشغيل إلى وضع Bootloader</string>
    <string name="reboot_download">إعادة تشغيل إلى وضع Download</string>
    <string name="reboot_edl">إعادة تشغيل إلى وضع EDL</string>
    <string name="about">من نحن</string>
    <string name="module_uninstall_confirm">هل أنت متأكد أنك تريد إلغاء تثبيت الإضافة %s ?</string>
    <string name="module_uninstall_success">تم إلغاء تثبيتها %s</string>
    <string name="module_uninstall_failed">فشل إلغاء تثبيت %s</string>
    <string name="module_version">الإصدار</string>
    <string name="module_author">المطور</string>
    <string name="show_system_apps">إظهار تطبيقات النظام</string>
    <string name="send_log">إرسال السجلات</string>
    <string name="safe_mode">الوضع الآمن</string>
    <string name="reboot_to_apply">إعادة التشغيل لتطبيق التغييرات</string>
    <string name="module_magisk_conflict">الوحدات غير متاحة بسبب تعارضها مع Magisk!</string>
    <string name="home_learn_kernelsu">تعلم KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">تعرف على كيفية تثبيت KernelSU واستخدام الإضافات</string>
    <string name="home_support_title">إدعمنا</string>
    <string name="home_support_content">KernelSU سيظل دائماً مجانياً ومفتوح المصدر. مع ذلك، يمكنك متى ما استطعت أن تظهر لنا أنك تهتم بالتبرع.</string>
    <string name="about_source_code"><![CDATA[أنظر إلى مصدر البرمجة في %1$s<br/>إنضم إلى قناتنا في %2$s ]]></string>
    <string name="profile_capabilities">القدرات</string>
    <string name="module_update">تحديث</string>
    <string name="module_downloading">تحميل الإضافة: %s</string>
    <string name="module_start_downloading">ابدأ التنزيل: %s</string>
    <string name="new_version_available">الإصدار الجديد: %s متاح ، انقر للتحديث.</string>
    <string name="launch_app">تشغيل</string>
    <string name="profile_default">الإفتراضي</string>
    <string name="profile_template">نموذج</string>
    <string name="profile_namespace_inherited">موروث</string>
    <string name="profile_namespace_global">عالمي</string>
    <string name="profile_namespace_individual">فردي</string>
    <string name="profile_groups">مجموعات</string>
    <string name="profile_custom">مُخصّص</string>
    <string name="profile_namespace">تركيب مساحة الاسم</string>
    <string name="profile_umount_modules">الغاء تحميل الإضافات</string>
    <string name="failed_to_update_app_profile">فشل تحديث ملف تعريف التطبيق لـ %s</string>
    <string name="profile_selinux_context">سياق SELinux</string>
    <string name="force_stop_app">ايقاف إجباري</string>
    <string name="settings_umount_modules_default">الغاء تحميل الإضافات بشكل افتراضي</string>
    <string name="settings_umount_modules_default_summary">القيمة الافتراضية العامة لـ\"إلغاء تحميل الإضافات\" في ملفات تعريف التطبيقات. إذا تم تمكينه، إزالة جميع تعديلات الإضافات على النظام للتطبيقات التي لا تحتوي على مجموعة ملف تعريف.</string>
    <string name="profile_umount_modules_summary">سيسمح تمكين هذا الخيار لـKernelSU باستعادة أي ملفات معدلة بواسطة الإضافات لهذا التطبيق.</string>
    <string name="profile_selinux_domain">المجال</string>
    <string name="profile_selinux_rules">القواعد</string>
    <string name="restart_app">إعادة تشغيل التطبيق</string>
    <string name="failed_to_update_sepolicy">فشل تحديث قواعد SELinux لـ %s</string>
    <string name="profile_name">اسم الملف الشخصي</string>
    <string name="require_kernel_version">إصدار KernelSU الحالي %1$d منخفض جدًا بحيث لا يعمل المدير بشكل صحيح. الرجاء الترقية إلى الإصدار %2$d أو أعلى!</string>
    <string name="module_changelog">سجل التغييرات</string>
    <string name="app_profile_template_import_success">تم الاستيراد بنجاح</string>
    <string name="app_profile_export_to_clipboard">تصدير إلى الحافظة</string>
    <string name="app_profile_template_export_empty">لا يمكن العثور على القالب المحلي للتصدير!</string>
    <string name="app_profile_template_id_exist">معرف القالب موجود بالفعل!</string>
    <string name="app_profile_import_from_clipboard">استيراد من الحافظة</string>
    <string name="app_profile_template_name">الاسم</string>
    <string name="app_profile_template_id_invalid">معرف القالب غير صالح</string>
    <string name="app_profile_template_create">إنشاء قالب</string>
    <string name="app_profile_import_export">استيراد / تصدير</string>
    <string name="app_profile_template_save_failed">فشل في حفظ القالب</string>
    <string name="app_profile_template_edit">تحرير القالب</string>
    <string name="app_profile_template_id">المعرف</string>
    <string name="settings_profile_template">قالب ملف تعريف التطبيق</string>
    <string name="app_profile_template_description">الوصف</string>
    <string name="app_profile_template_save">حفظ</string>
    <string name="settings_profile_template_summary">إدارة القالب المحلي وعبر الإنترنت لملف تعريف التطبيق</string>
    <string name="app_profile_template_delete">حذف</string>
    <string name="app_profile_template_import_empty">الحافظة فارغة!</string>
    <string name="app_profile_template_view">عرض القالب</string>
    <string name="grant_root_failed">فشل في منح صلاحية الجذر!</string>
    <string name="open">فتح</string>
    <string name="settings_check_update_summary">التحقق تلقائيًا من وجود تحديثات عند فتح التطبيق</string>
    <string name="settings_check_update">التحقق من التحديث</string>
    <string name="enable_web_debugging">تمكين تصحيح أخطاء WebView</string>
    <string name="enable_web_debugging_summary">يمكن استخدامه لتصحيح أخطاء WebUI، يرجى تمكينه فقط عند الحاجة.</string>
    <string name="install_next">التالي</string>
    <string name="select_file">اختيار ملف</string>
    <string name="direct_install">تثبيت مباشر (موصى به)</string>
    <string name="install_inactive_slot">التثبيت على فتحة غير نشطة (بعد OTA)</string>
    <string name="install_inactive_slot_warning">سيتم **إجبار** جهازك على التمهيد إلى الفتحة غير النشطة الحالية بعد إعادة التشغيل!
\nاستخدم هذا الخيار فقط بعد انتهاء التحديث.
\nأستمرار؟</string>
    <string name="select_kmi">اختر KMI</string>
    <string name="select_file_tip">يوصى باستخدام صورة القسم %1$s</string>
    <string name="settings_uninstall">إلغاء التثبيت</string>
    <string name="settings_uninstall_temporary">إلغاء التثبيت مؤقتًا</string>
    <string name="settings_uninstall_permanent">إلغاء التثبيت بشكل دائم</string>
    <string name="settings_restore_stock_image">استعادة الصورة الاصلية</string>
    <string name="settings_uninstall_permanent_message">‬إلغاء تثبيت KernelSU .(الجذر وجميع الوحدات) بشكل كامل ودائم.</string>
    <string name="flashing">تركيب</string>
    <string name="flash_success">نجح التركيب</string>
    <string name="flash_failed">فشل التركيب</string>
    <string name="selected_lkm">LKM المحددة: %s</string>
    <string name="settings_restore_stock_image_message">استعادة صورة المصنع المخزنة (في حالة وجود نسخة احتياطية)، والتي تُستخدم عادة قبل OTA؛ إذا كنت بحاجة إلى إلغاء تثبيت KernelSU، فيرجى استخدام \"إلغاء التثبيت الدائم\".</string>
    <string name="settings_uninstall_temporary_message">قم بإلغاء تثبيت KernelSU مؤقتًا، واستعد إلى حالته الأصلية بعد إعادة التشغيل التالية.</string>
    <string name="save_log">حفظ السجلات</string>
    <string name="action">إجراء</string>
    <string name="log_saved">السجلات محفوظة</string>
    <string name="module_sort_enabled_first">فرز (الممكن أولاً)</string>
    <string name="module_sort_action_first">فرز (الإجراء أولاً)</string>
    <string name="module_install_prompt_with_name">الحزم الاتيه سيتم تثبيتها %1$s</string>
    <string name="confirm">تأكيد</string>
    <string name="su_not_allowed">من الغير ممكن اعطاء صلاحيات (المسخدم الخارق) لـ %s</string>
    <string name="settings_sucompat">إعادة توجيه ثنائي su</string>
    <string name="settings_sucompat_summary">يسمح للتطبيقات التي تم منحها صلاحيات Superuser في ملف تعريف التطبيق بالحصول على shell superuser من خلال تنفيذ /system/bin/su؛ فعال فقط للعمليات الجديدة.</string>
    <string name="settings_kernel_umount">إلغاء تحميل النواة</string>
    <string name="settings_kernel_umount_summary">سلوك إلغاء تحميل مستوى النواة الذي يسيطر عليه KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-az/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Ana səhifə</string>
    <string name="home_kernel">Nüvə</string>
    <string name="home_not_installed">Yüklənmədi</string>
    <string name="home_click_to_install">Yükləmək üçün toxunun</string>
    <string name="home_working">İşləyir</string>
    <string name="home_working_version">Versiya: %d</string>
    <string name="home_unsupported_reason">Hal-hazırda KernelSU yalnız GKI nüvələrini dəstəkləyir</string>
    <string name="home_unsupported">Dəstəklənmir</string>
    <string name="module_install">Yüklə</string>
    <string name="install">Yüklə</string>
    <string name="selinux_status_unknown">Naməlum</string>
    <string name="home_fingerprint">Barmaq izi</string>
    <string name="home_manager_version">Menecer versiyası</string>
    <string name="selinux_status_disabled">Qeyri-aktiv</string>
    <string name="home_selinux_status">SELinux vəziyyəti</string>
    <string name="selinux_status_permissive">Sərbəst</string>
    <string name="selinux_status_enforcing">Məcburi</string>
    <string name="superuser">Super istifadəçi</string>
    <string name="uninstall">Sil</string>
    <string name="module_failed_to_enable">Modulu aktiv etmək mümkün olmadı: %s</string>
    <string name="module_failed_to_disable">Modulu deaktiv etmək mümkün olmadı: %s</string>
    <string name="module_empty">Heç bir modul quraşdırılmayıb</string>
    <string name="module">Modul</string>
    <string name="reboot">Yenidən başlat</string>
    <string name="settings">Parametrlər</string>
    <string name="reboot_recovery">Bərpa rejimində yenidən başlat</string>
    <string name="reboot_userspace">Yüngül vəziyyətdə yenodən başlat</string>
    <string name="reboot_bootloader">Bootloader rejimində yenidən başlat</string>
    <string name="reboot_download">Yükləmə rejimində yenidən başlat</string>
    <string name="module_version">Versiya</string>
    <string name="module_author">Sahib</string>
    <string name="module_uninstall_confirm">Modulu silmək istədiyinizdən əminsiniz %s\?</string>
    <string name="show_system_apps">Sistem proqramlarını göstər</string>
    <string name="about">Haqqında</string>
    <string name="reboot_edl">EDL rejimində yenidən başlat</string>
    <string name="module_uninstall_failed">Silmək mümkün olmadı: %s</string>
    <string name="module_uninstall_success">%s silindi</string>
    <string name="send_log">Log-u göndər</string>
    <string name="safe_mode">Təhlükəsiz rejimi</string>
    <string name="reboot_to_apply">Qüvvəyə minməsi üçün yenidən başlat</string>
    <string name="module_magisk_conflict">Modular deaktiv edilir,çünki o Magisk-in modulları ilə toqquşur!</string>
    <string name="home_learn_kernelsu">KernelSU-yu öyrən</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_support_title">Bizi dəstəkləyin</string>
    <string name="home_click_to_learn_kernelsu">KernelSU-yu necə quraşdırılacağını və modulların necə istifadə ediləcəyini öyrən</string>
    <string name="profile_template">Şablon</string>
    <string name="profile_default">Defolt</string>
    <string name="profile_custom">Özəl</string>
    <string name="home_support_content">KernelSU pulsuz və açıq mənbəlidir,həmişə belə olacaqdır. Bununla belə, ianə etməklə bizə qayğı göstərdiyinizi göstərə bilərsiniz.</string>
    <string name="about_source_code">Mənbə kodlarımıza baxın %1$s<br/>
Kanalımıza %2$s qoşulun</string>
    <string name="profile_name">Profil adı</string>
    <string name="profile_capabilities">Bacarıqlar</string>
    <string name="profile_umount_modules">Modulları umount et</string>
    <string name="profile_namespace_inherited">Miras qalmış</string>
    <string name="profile_namespace_global">Qlobal</string>
    <string name="profile_namespace">Bölmənin ad sahəsi</string>
    <string name="profile_namespace_individual">Fərdi</string>
    <string name="profile_groups">Qruplar</string>
    <string name="settings_umount_modules_default">Defolt olaraq modulları umount et</string>
    <string name="profile_selinux_context">SELinux konteksi</string>
    <string name="failed_to_update_app_profile">%s görə tətbiq profillərini güncəlləmək mümkün olmadı</string>
    <string name="settings_umount_modules_default_summary">Tətbiq Profillərində \"Umount modulları\" üçün qlobal standart dəyər. Aktivləşdirilərsə, o, Profil dəsti olmayan proqramlar üçün sistemdəki bütün modul dəyişikliklərini siləcək.</string>
    <string name="profile_selinux_domain">Domen</string>
    <string name="profile_selinux_rules">Qaydalar</string>
    <string name="module_update">Güncəllə</string>
    <string name="module_start_downloading">Endirməni başlat: %s</string>
    <string name="new_version_available">Yeni versiya: %s əlçatandır, endirmək üçün toxunun</string>
    <string name="module_downloading">Modul yüklənir: %s</string>
    <string name="profile_umount_modules_summary">Bu seçimi aktivləşdirmək KernelSU-ya bu proqram üçün modullar tərəfindən hər hansı dəyişdirilmiş faylları bərpa etməyə imkan verəcək.</string>
    <string name="launch_app">Aç</string>
    <string name="force_stop_app">Məcburi dayandır</string>
    <string name="restart_app">Təkrar başlat</string>
    <string name="failed_to_update_sepolicy">%s görə SELinux qaydalarını güncəlləmək mümkün olmadı</string>
    <string name="save_log">Girişləri Saxla</string>
    <string name="require_kernel_version">Cari KernelSU versiyası %1$d menecerin düzgün işləməsi üçün çox aşağıdır. Lütfən, %2$d və ya daha yüksək versiyaya təkmilləşdirin!</string>
    <string name="module_install_prompt_with_name">Aşağıdakı modullar quraşdırılacaq: %1$s</string>
    <string name="confirm">Təsdiq edin</string>
    <string name="module_sort_action_first">Sıralama (ilk hərəkət)</string>
    <string name="module_sort_enabled_first">Sıralama (Əvvəlcə aktivdir)</string>
    <string name="module_changelog">Dəyişikliklər jurnalı</string>
    <string name="settings_profile_template">Tətbiq Profil Şablonu</string>
    <string name="settings_profile_template_summary">Tətbiq Profilinə aid yerli və onlayn şablonların idarə olunması</string>
    <string name="app_profile_template_create">Şablon yarat</string>
    <string name="app_profile_template_edit">Şablonu redaktə et</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Etibarsız şablon ID-si</string>
    <string name="app_profile_template_name">Ad</string>
    <string name="app_profile_template_description">Açıqlama</string>
    <string name="su_not_allowed">%s üçün Superistifadəçi girişi vermək mümkün olmadı.</string>
    <string name="app_profile_template_save">Yadda saxla</string>
    <string name="app_profile_template_delete">Sil</string>
    <string name="app_profile_template_view">Şablonu göstər</string>
    <string name="app_profile_template_id_exist">Şablon ID-si artıq mövcuddur!</string>
    <string name="settings_sucompat">su binary yönləndirmə</string>
    <string name="settings_sucompat_summary">Tətbiq Profilinə Superuser icazəsi verilmiş proqramları /system/bin/su vasitəsilə superuser shell əldə etməyə icazə verir; yalnız yeni proseslər üçün effektivdir.</string>
    <string name="settings_kernel_umount">Nüvə umount</string>
    <string name="settings_kernel_umount_summary">KernelSU tərəfindən idarə olunan nüvə səviyyəsində umount davranışı</string>
</resources>

```

`manager/app/src/main/res/values-bg/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Начало</string>
    <string name="home_not_installed">Не е инсталирано</string>
    <string name="home_click_to_install">Натиснете да инсталирате</string>
    <string name="home_working">Работи</string>
    <string name="home_working_version">Версия: %d</string>
    <string name="home_unsupported">Неподдържано</string>
    <string name="home_unsupported_reason">KernelSU само поддържа GKI кернели за сега.</string>
    <string name="home_kernel">Версия на кернела</string>
    <string name="home_manager_version">Версия на мениджъра</string>
    <string name="home_fingerprint">Пръстов отпечатък</string>
    <string name="home_selinux_status">SELinux статус</string>
    <string name="selinux_status_disabled">Деактивиран</string>
    <string name="selinux_status_enforcing">Налагащ</string>
    <string name="selinux_status_permissive">Разрешителен</string>
    <string name="selinux_status_unknown">Неизвестен</string>
    <string name="superuser">Суперпотребител</string>
    <string name="module_failed_to_enable">Неуспешно включване на модула: %s</string>
    <string name="module_failed_to_disable">Неуспешно изключване на модула: %s</string>
    <string name="module_empty">Няма инсталирани модули</string>
    <string name="module">Модул</string>
    <string name="module_install_prompt_with_name">Следните модули ще бъдат инсталирани: %1$s</string>
    <string name="module_sort_action_first">Първо действие</string>
    <string name="module_sort_enabled_first">Първо включено</string>
    <string name="confirm">Потвърди</string>
    <string name="uninstall">Деинсталиране</string>
    <string name="module_install">Инсалирай</string>
    <string name="install">Инсталирай</string>
    <string name="reboot">Рестартирай</string>
    <string name="settings">Настройки</string>
    <string name="reboot_userspace">Меко рестартиране</string>
    <string name="reboot_recovery">Рестартирай във възстановяване</string>
    <string name="reboot_bootloader">Рестартирай в Booloader</string>
    <string name="reboot_download">Рестартирай в Download</string>
    <string name="reboot_edl">Рестартирай в EDL</string>
    <string name="about">Относно</string>
    <string name="module_uninstall_confirm">Сигурни ли сте че искате да премахнете модула %s?</string>
    <string name="metamodule_uninstall_confirm">Сигурни ли сте, че искате да деинсталирате модула %s? Това действие ще засегне всички модули и някои функции, предоставяни от метамодула (като например \"mounting\"), вече няма да работят.</string>
    <string name="module_uninstall_success">%s премахнат</string>
    <string name="module_uninstall_failed">Неуспешно премахване на: %s</string>
    <string name="module_version">Версия</string>
    <string name="module_author">Автор</string>
    <string name="show_system_apps">Покажи системно приложения</string>
    <string name="send_log">Прати логове</string>
    <string name="safe_mode">Безопасен режим</string>
    <string name="reboot_to_apply">Рестартирай за да приеме ефект</string>
    <string name="module_magisk_conflict">Модулите не са налични поради конфликт с Magisk!</string>
    <string name="home_learn_kernelsu">Научи KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Научи как да изтеглите KernelSU и да използвате модули.</string>
    <string name="home_support_title">Помогнете Ни</string>
    <string name="home_support_content">KernelSU си е, и винаги ще е безплатен, и с отворен код. Обаче, можете да ни покажете че се интересувате като ни направите дарение.</string>
    <string name="about_source_code"><![CDATA[View source code at %1$s<br/>Присъединете се към нашия%2$s канал]]></string>
    <string name="profile_default">По подразбиране</string>
    <string name="profile_template">Шаблон</string>
    <string name="profile_custom">По избор</string>
    <string name="profile_name">Име на профил</string>
    <string name="profile_namespace">Прикачи Namespace</string>
    <string name="profile_namespace_inherited">Наследени</string>
    <string name="profile_namespace_global">Глобален</string>
    <string name="profile_namespace_individual">Индивид</string>
    <string name="profile_groups">Групи</string>
    <string name="profile_capabilities">Възможности</string>
    <string name="profile_selinux_context">SELinux контекст</string>
    <string name="profile_umount_modules">Разкачи модули по подразбиране</string>
    <string name="failed_to_update_app_profile">Неуспешно актуализиране на App Profile за %s</string>
    <string name="require_kernel_version">Текущата версия %1$d на KernelSU е твърде ниска, за да работи правилно мениджърът. Моля, актуализирайте към версия %2$d или по-висока!</string>
    <string name="settings_umount_modules_default">Разкачи модули</string>
    <string name="settings_umount_modules_default_summary">Глобалната стойност по подразбиране за „Разкачи модули“ в профила на приложението. Ако е активирана, ще премахне всички модификации на модулите в системата за приложения, които нямат зададен профил.</string>
    <string name="profile_umount_modules_summary">Активирането на тази опция ще позволи на KernelSU да възстанови всички модифицирани файлове от модулите за това приложение.</string>
    <string name="profile_selinux_domain">Домейн</string>
    <string name="profile_selinux_rules">Правила</string>
    <string name="module_update">Актуализиране</string>
    <string name="module_downloading">Изтегляне на модул: %s</string>
    <string name="module_start_downloading">Започни изтегляне: %s</string>
    <string name="new_version_available">Нова версия %s е налична, натисни да актуализирате!</string>
    <string name="launch_app">Стартирай</string>
    <string name="force_stop_app">Принудително спиране</string>
    <string name="restart_app">Радтартирай</string>
    <string name="failed_to_update_sepolicy">Неуспешно актуализиране на SELinux правила за %s</string>
    <string name="su_not_allowed">Даването на Суперпотребителски права на %s не беше успешно</string>
    <string name="module_changelog">Списък с промени</string>
    <string name="settings_profile_template">Шаблон за профил на приложение</string>
    <string name="settings_profile_template_summary">Управлявайте локален и онлайн шаблон на профил на приложението.</string>
    <string name="app_profile_template_create">Създаване на шаблон</string>
    <string name="app_profile_template_edit">Модифициране на шаблон</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Невалидно шаблонено ID</string>
    <string name="app_profile_template_name">Име</string>
    <string name="app_profile_template_description">Описание</string>
    <string name="app_profile_template_save">Запази</string>
    <string name="app_profile_template_delete">Премахни</string>
    <string name="app_profile_template_view">Разгледай шаблон</string>
    <string name="app_profile_template_id_exist">Шаблонно ID вече съществува!</string>
    <string name="app_profile_import_export">Внасяне/Изкарване</string>
    <string name="app_profile_import_from_clipboard">Внасяне от клипборда</string>
    <string name="app_profile_export_to_clipboard">Изнасяне във клипборда</string>
    <string name="app_profile_template_export_empty">Не може да се намери локален шаблон за изнасяне!</string>
    <string name="app_profile_template_import_success">Внасяне успешно</string>
    <string name="app_profile_template_save_failed">Неуспешно запазване на шаблон</string>
    <string name="app_profile_template_import_empty">Клипборда е празен!</string>
    <string name="app_profile_affects_following_apps">Засегва следните приложения</string>
    <string name="settings_check_update">Провери за актуализаций</string>
    <string name="settings_check_update_summary">Автоматично провери за актуализаций когато отворите приложението.</string>
    <string name="settings_module_check_update">Провери за актуализаций на модулите</string>
    <string name="grant_root_failed">Неуспешно даване на root права!</string>
    <string name="action">Действие</string>
    <string name="open">Отвори</string>
    <string name="enable_web_debugging">Отстраняване на грешки на WebView</string>
    <string name="enable_web_debugging_summary">Може да се използва за отстраняване на грешки в WebUI. Моля активирайте само когато е необходимо.</string>
    <string name="direct_install">Директно изтегляне (Препоръчано)</string>
    <string name="select_file">Изберете файл</string>
    <string name="install_inactive_slot">Изтеглете в неактивния слот (След софтуерна актуализация)</string>
    <string name="install_inactive_slot_warning">Устройството ви ще бъде **ПРИНУДЕНО** да се стартира от неактивния слот след рестартиране!\nИзползвайте тази опция само след като софтуерната актуализация приключи.\nИскате ли да продължите?</string>
    <string name="install_next">Следваш</string>
    <string name="install_select_partition">Избери раздел</string>
    <string name="install_upload_lkm_file">Използвай локален LKM файл</string>
    <string name="install_only_support_ko_file">Само .ko файлове се поддържат</string>
    <string name="select_file_tip">Препоръчва се образ на дял %1$s</string>
    <string name="select_kmi">Изберете KMI</string>
    <string name="settings_uninstall">Премахнете</string>
    <string name="settings_uninstall_temporary">Премахнете временно</string>
    <string name="settings_uninstall_permanent">Премахнете завинаги</string>
    <string name="settings_restore_stock_image">Възстановяване на стоков .img фаил</string>
    <string name="settings_uninstall_temporary_message">Временно премахнете KernelSU, ще се върне в нормално състояние след следващото рестартиране.</string>
    <string name="settings_uninstall_permanent_message">Премахване на KernelSU (root и всички модули) напълно, завинаги.</string>
    <string name="settings_restore_stock_image_message">Възстановете фабричното копие (ако съществува резервно копие), обикновено използвано преди софтуерна актуализация; ако трябва да премахнете KernelSU, моля, използвайте „Премахване завинаги“.</string>
    <string name="flashing">Флашване</string>
    <string name="flash_success">Флашване успешно</string>
    <string name="flash_failed">Флашване не бе успешно</string>
    <string name="selected_lkm">Избран LKM: %s</string>
    <string name="save_log">Запази логове</string>
    <string name="log_saved">Логовете бяха запазени</string>
    <string name="feature_status_unsupported_summary">Кърнълът не поддържа тази функция.</string>
    <string name="feature_status_managed_summary">Тази функция е управлявана от модул.</string>
    <string name="settings_sucompat">Пренасочване на su бинарния файл</string>
    <string name="settings_sucompat_summary">Позволяет приложениям с предоставени права на Superuser в профила на приложението да получат superuser shell чрез изпълнение на /system/bin/su; в сила само за нови процеси.</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">Поведение за umount на ниво ядро, контролирано от KernelSU</string>
    <string name="processing">Обработва се…</string>
    <string name="refresh_pulling">Опънете надолу за да обновите</string>
    <string name="refresh_release">Пуснете за да обновите</string>
    <string name="refresh_refresh">Обновяване…</string>
    <string name="refresh_complete">Обновено успешно</string>
    <string name="undo">Откажи</string>
    <string name="module_undo_uninstall_success">Успешно отказано премахването на %s</string>
    <string name="module_undo_uninstall_failed">Неуспешно отказване на премахване: %s</string>
    <string name="group_contains_apps">Съдържа %d приложения</string>
    <string name="settings_theme">Тема</string>
    <string name="settings_theme_summary">Изберете режима на темата на приложението.</string>
    <string name="settings_theme_mode_system">Следвай системата</string>
    <string name="settings_theme_mode_light">Светъл</string>
    <string name="settings_theme_mode_dark">Тъмен</string>
    <string name="settings_theme_mode_monet_system">Monet (Следвай системата)</string>
    <string name="settings_theme_mode_monet_light">Monet (Светъл)</string>
    <string name="settings_theme_mode_monet_dark">Monet (Тъмен)</string>
    <string name="settings_key_color">Цвят на копчето</string>
    <string name="settings_key_color_summary">Персонализирайте акцента, когато използвате Monet.</string>
    <string name="settings_key_color_default">По подразбиране</string>
    <string name="color_blue">Син</string>
    <string name="color_red">Червен</string>
    <string name="color_green">Зелен</string>
    <string name="color_purple">Лилав</string>
    <string name="color_orange">Оранжево</string>
    <string name="color_teal">Тил</string>
    <string name="color_pink">Розово</string>
    <string name="color_brown">Кафяво</string>
    <string name="module_repos">Репота</string>
    <string name="module_repos_sort_name">По име (А → Я)</string>
    <string name="module_repos_source_code">Изходен код</string>
    <string name="home_gki_warning">Започвайки от v3.0.0, работният режим на GKI ще се използва само в тестови среди. Не го препоръчваме за ежедневна употреба и файлове с изображения вече няма да се предоставят.</string>
    <string name="network_offline">Не е свързан с интернет</string>
    <string name="network_retry">Пробвай отново</string>
    <string name="tab_readme">ПРОЧЕТИ МЕ</string>
    <string name="tab_releases">Версии</string>
    <string name="tab_info">Информация</string>
</resources>

```

`manager/app/src/main/res/values-bn-rBD/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_unsupported_reason">কর্নেল এস ইউ কেবল মাত্র জিকআই কর্নেল সাপোর্ট করে</string>
    <string name="home_selinux_status">এসইলিনাক্স স্টেটাস</string>
    <string name="selinux_status_unknown">আননোন</string>
    <string name="module_failed_to_enable">মোডিউল ইনেবল করা যায়নি: %s</string>
    <string name="home_click_to_install">ইন্সটল করটে চাপুন</string>
    <string name="home_working">কাজ করছে</string>
    <string name="home_unsupported">অমূলক</string>
    <string name="home_kernel">কর্নেল</string>
    <string name="home_manager_version">ম্যানেজার ভারসন</string>
    <string name="home_fingerprint">ফিঙ্গারপ্রিন্ট</string>
    <string name="selinux_status_disabled">ডিসেবল</string>
    <string name="selinux_status_enforcing">এনফোর্সিং</string>
    <string name="superuser">সুপার ইউজার</string>
    <string name="module">মোডিউল</string>
    <string name="uninstall">আনইন্সটল</string>
    <string name="module_install">ইন্সটল</string>
    <string name="install">ইন্সটল</string>
    <string name="reboot">রিবুট</string>
    <string name="settings">সেটিংস</string>
    <string name="reboot_userspace">সফট রিবুট</string>
    <string name="profile_namespace_global">গ্লোবাল</string>
    <string name="profile_groups">গ্রুপস</string>
    <string name="profile_selinux_context">এসইলিনাক্স কন্টেক্সট</string>
    <string name="failed_to_update_app_profile">%s এর জন্য অ্যাপ প্রফাইল আপডেট করা যায়নি</string>
    <string name="settings_umount_modules_default">বাইডিফল্ট মোডিউল আনমাউন্ট</string>
    <string name="home">হোম</string>
    <string name="home_not_installed">ইন্সটল হয়নী</string>
    <string name="selinux_status_permissive">পারমিসিভ</string>
    <string name="module_failed_to_disable">মোডিউল ডিসেবল করা যায়নি: %s</string>
    <string name="module_empty">কোনো মোডিউল ইন্সটল করা নেই</string>
    <string name="home_working_version">সংস্করণ: %d</string>
    <string name="profile_namespace">নেইম স্পেস মাউন্ট</string>
    <string name="profile_namespace_inherited">ইনহেরিটেড</string>
    <string name="profile_namespace_individual">ইন্ডিভিজুয়াল</string>
    <string name="profile_capabilities">ক্যাপাবিলিটিস</string>
    <string name="profile_umount_modules">আনমাউন্ট মোডিউলস</string>
    <string name="reboot_recovery">রিকভারিতে বুট</string>
    <string name="reboot_bootloader">বুটলোডারে বুট</string>
    <string name="reboot_download">ডাউনলোড মডে বুট</string>
    <string name="reboot_edl">ইমারজেন্সি ডাউনলোড মডে বুট</string>
    <string name="about">অ্যাবাউট</string>
    <string name="module_uninstall_confirm">%s মোডিউল আনইনস্টলের বেপারে নিশ্চিৎ\?</string>
    <string name="module_uninstall_success">%s আনইনস্টলড</string>
    <string name="module_uninstall_failed">%s আনইনস্টল করা যায়নি</string>
    <string name="module_version">ভার্সন</string>
    <string name="module_author">অথার</string>
    <string name="save_log">লগ সংরক্ষণ করুন</string>
    <string name="settings_sucompat">su বাইনারি পুনর্নির্দেশ করুন</string>
    <string name="settings_sucompat_summary">অ্যাপ প্রোফাইলে সুপারইউজার অনুমতি সহ অ্যাপের জন্য /system/bin/su কে ksud-এ পুনর্নির্দেশ করুন; শুধুমাত্র নতুন প্রক্রিয়ার জন্য কার্যকর।</string>
    <string name="settings_kernel_umount">কার্নেল আনমাউন্ট</string>
    <string name="settings_kernel_umount_summary">KernelSU দ্বারা নিয়ন্ত্রিত কার্নেল-লেভেল আনমাউন্ট আচরণ</string>
</resources>

```

`manager/app/src/main/res/values-bn/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">হোম</string>
    <string name="home_not_installed">ইনস্টল করা হয়নি</string>
    <string name="home_click_to_install">ইনস্টল করার জন্য ক্লিক করুন</string>
    <string name="home_working"> ওয়ার্কিং</string>
    <string name="home_working_version">ওয়ার্কিং সংস্করণ: %d</string>
    <string name="home_unsupported">অসমর্থিত</string>
    <string name="home_unsupported_reason">KernelSU শুধুমাত্র GKI কার্নেল সমর্থন করে</string>
    <string name="home_kernel">কার্নেল সংস্করণ</string>
    <string name="home_manager_version">ম্যানেজার সংস্করণ</string>
    <string name="home_fingerprint">ফিঙ্গারপ্রিন্ট</string>
    <string name="home_selinux_status">SELinux স্টেটাস</string>
    <string name="selinux_status_disabled">ডিজেবল</string>
    <string name="selinux_status_enforcing">কার্যকর</string>
    <string name="selinux_status_permissive">অনুমতিমূলক</string>
    <string name="selinux_status_unknown">অজানা</string>
    <string name="superuser">সুপার ইউজার</string>
    <string name="module_failed_to_enable">মডিউল সক্ষম করতে ব্যর্থ হয়েছে: %s</string>
    <string name="module_failed_to_disable">মডিউল নিষ্ক্রিয় করতে ব্যর্থ হয়েছে: %s</string>
    <string name="module_empty">কোন মডিউল ইনস্টল করা নেই</string>
    <string name="module">মডিউল</string>
    <string name="uninstall">আনইন্সটল</string>
    <string name="module_install">মডিউল ইনস্টল</string>
    <string name="install">ইনস্টল</string>
    <string name="reboot">রিবুট</string>
    <string name="settings">সেটিংস</string>
    <string name="reboot_userspace">সফট রিবুট</string>
    <string name="reboot_recovery">রিবুট রিকোভারি</string>
    <string name="reboot_bootloader">রিবুট বুটলোডার</string>
    <string name="reboot_download">রিবুট ডাউনলোড</string>
    <string name="reboot_edl">রিবুট ইডিএল</string>
    <string name="about">এবাউট</string>
    <string name="module_uninstall_confirm">মডিউল আনইনস্টল নিশ্চিত করুন %s?</string>
    <string name="module_uninstall_success">%s আনইনস্টল সফল</string>
    <string name="module_uninstall_failed">আনইন্সটল ব্যর্থ: %s</string>
    <string name="module_version">ভার্সন</string>
    <string name="module_author">লেখক</string>
    <string name="show_system_apps">শো সিস্টেম অ্যাপস</string>
    <string name="send_log">সেন্ড লগ</string>
    <string name="safe_mode">সেইফ মোড</string>
    <string name="reboot_to_apply">রিবুট এপ্লাই</string>
    <string name="module_magisk_conflict">মডিউলগুলি অক্ষম কারণ তারা ম্যাজিস্কের সাথে বিরোধিতা করে!</string>
    <string name="home_learn_kernelsu">লার্ন কার্নেলএসইউ</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">কিভাবে কার্নেলএসইউ ইনস্টল করতে হয় এবং মডিউল ব্যবহার করতে হয় তা শিখুন।</string>
    <string name="home_support_title">সাপোর্ট টাইটেল</string>
    <string name="home_support_content">কার্নেলএসইউ ফ্রি ও ওপেন সোর্স, এবং সবসময় এমনই থাকবে। তবে, আপনি অনুদান দিয়ে আপনার কৃতজ্ঞতা প্রদর্শন করতে পারেন।</string>
    <string name="about_source_code"><![CDATA[Bekijk source code op %1$s<br/>আমাদের %2$s চ্যানেল মার্জ করুন]]></string>
    <string name="profile_name">প্রফাইলের নাম</string>
    <string name="profile_namespace">নেমস্পেস মাউন্ট</string>
    <string name="profile_groups">গ্রুপস</string>
    <string name="profile_capabilities">যোগ্যতা</string>
    <string name="profile_selinux_context">এসই লিনাক্স কনটেক্সট</string>
    <string name="profile_default">ডিফল্ট</string>
    <string name="profile_template">টেমপ্লেট</string>
    <string name="profile_custom">কাস্টম</string>
    <string name="profile_namespace_global">গ্লোবাল</string>
    <string name="profile_namespace_individual">আলাদাভাবে</string>
    <string name="profile_umount_modules">আনমাউন্ট মোডিউল</string>
    <string name="require_kernel_version">ম্যানেজার সঠিকভাবে কাজ করার জন্য বর্তমান KernelSU সংস্করণ %1$d খুবই কম। অনুগ্রহ করে %2$d বা উচ্চতর সংস্করণে আপগ্রেড করুন!</string>
    <string name="save_log">লগ সংরক্ষণ করুন</string>
    <string name="module_install_prompt_with_name">এই মডিউলগুলো ইনস্টল করা হবেঃ %1$s</string>
    <string name="module_sort_enabled_first">চালুগুলো আগে</string>
    <string name="module_repos_source_code">সোর্স কোড</string>
    <string name="confirm">নিশ্চিত</string>
    <string name="metamodule_uninstall_confirm">আপনি কি নিশ্চিত আপনি মডিউল %s আনইনস্টল করতে চান? এটি সকল মডিউলকে প্রভাবিত করবে, এবং মেটামডিউল দ্বারা প্রদত্ত কিছু বৈশিষ্ট্য (যেমন মাউন্ট করা) আর কাজ করবে না।</string>
    <string name="home_gki_warning">v3.0.0 থেকে শুরু করে, GKI মোড শুধুমাত্র নিরীক্ষণ এর জন্য ব্যবহার করা যাবে। আমরা দৈনন্দিন ব্যবহারের জন্য এটি সুপারিশ করি না, এবং ইমেজ ফাইল আর প্রদান করা হবে না।</string>
    <string name="failed_to_update_app_profile">%s এর জন্য অ্যাপ প্রোফাইল আপডেট করতে ব্যর্থ হয়েছে</string>
    <string name="settings_sucompat">su বাইনারি রি-রুট করুন</string>
    <string name="settings_sucompat_summary">অ্যাপ প্রোফাইলে সুপার ইউজার অনুমতি প্রাপ্ত অ্যাপগুলির জন্য /system/bin/su কে ksud এ রিডাইরেক্ট করুন; শুধুমাত্র নতুন প্রসেসের জন্য কার্যকর।</string>
    <string name="settings_kernel_umount">কার্নেল আনমাউন্ট</string>
    <string name="settings_kernel_umount_summary">KernelSU দ্বারা নিয়ন্ত্রিত কার্নেল-লেভেল আনমাউন্ট আচরণ</string>
</resources>

```

`manager/app/src/main/res/values-bs/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="profile_namespace">Imenski prostor nosača</string>
    <string name="profile_namespace_inherited">Naslijeđen</string>
    <string name="profile_namespace_global">Globalan</string>
    <string name="profile_namespace_individual">Pojedinačan</string>
    <string name="profile_groups">Grupe</string>
    <string name="profile_capabilities">Sposobnosti</string>
    <string name="profile_selinux_context">SELinux kontekst</string>
    <string name="profile_umount_modules">Umount module</string>
    <string name="failed_to_update_app_profile">Ažuriranje Profila Aplikacije za %s nije uspjelo</string>
    <string name="require_kernel_version">Trenutna KernelSU verzija %1$d je preniska da bi upravitelj ispravno radio. Molimo vas da nadogradite na verziju %2$d ili noviju!</string>
    <string name="settings_umount_modules_default">Umount module po zadanom</string>
    <string name="settings_umount_modules_default_summary">Globalna zadana vrijednost za \"Umount module\" u Profilima Aplikacije. Ako je omogućeno, uklonit će sve izmjene modula na sistemu za aplikacije koje nemaju postavljen Profil.</string>
    <string name="profile_umount_modules_summary">Uključivanjem ove opcije omogućit će KernelSU-u da vrati sve izmjenute datoteke od strane modula za ovu aplikaciju.</string>
    <string name="module_update">Ažuriranje</string>
    <string name="module_downloading">Skidanje module: %s</string>
    <string name="module_start_downloading">Započnite sa skidanjem: %s</string>
    <string name="new_version_available">Nova verzija: %s je dostupna, kliknite da skinete</string>
    <string name="launch_app">Pokrenite</string>
    <string name="force_stop_app">Prisilno Zaustavite</string>
    <string name="restart_app">Resetujte</string>
    <string name="selinux_status_enforcing">U Provođenju</string>
    <string name="home">Početna</string>
    <string name="home_not_installed">Nije instalirano</string>
    <string name="home_click_to_install">Kliknite da instalirate</string>
    <string name="home_unsupported">Nepodržano</string>
    <string name="home_unsupported_reason">KernelSU samo podržava GKI kernele sad</string>
    <string name="home_manager_version">Verzija Upravitelja</string>
    <string name="home_fingerprint">Otisak prsta</string>
    <string name="home_selinux_status">SELinux stanje</string>
    <string name="module_install">Instalirajte</string>
    <string name="install">Instalirajte</string>
    <string name="reboot">Ponovo pokrenite</string>
    <string name="settings">Podešavanja</string>
    <string name="module_version">Verzija</string>
    <string name="module_author">Autor</string>
    <string name="show_system_apps">Prikažite sistemske aplikacije</string>
    <string name="safe_mode">Sigurnosni mod</string>
    <string name="reboot_to_apply">Ponovo pokrenite da bi proradilo</string>
    <string name="module_magisk_conflict">"Moduli su nedostupni  jer su u sukobu sa Magisk-om!"</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Naučite kako da instalirate KernelSU i da koristite module</string>
    <string name="home_support_title">Podržite Nas</string>
    <string name="send_log">Pošaljite Izvještaj</string>
    <string name="home_learn_kernelsu">Naučite KernelSU</string>
    <string name="about_source_code">Pogledajte izvornu kodu na %1$s<br/>Pridružite nam se na %2$s kanalu</string>
    <string name="profile_selinux_domain">Domena</string>
    <string name="profile_selinux_rules">Pravila</string>
    <string name="failed_to_update_sepolicy">Neuspješno ažuriranje SELinux pravila za: %s</string>
    <string name="home_working">Radi</string>
    <string name="home_working_version">Verzija: %d</string>
    <string name="home_kernel">Kernel verzija</string>
    <string name="selinux_status_permissive">Permisivno</string>
    <string name="uninstall">Deinstalirajte</string>
    <string name="selinux_status_unknown">Nepoznato</string>
    <string name="module_empty">Nema instaliranih modula</string>
    <string name="superuser">Superkorisnik</string>
    <string name="module">Modula</string>
    <string name="reboot_bootloader">Ponovo pokrenite u Pogonski Učitavatelj</string>
    <string name="reboot_recovery">Ponovo pokrenite u Oporavu</string>
    <string name="module_uninstall_success">%s deinstalirana</string>
    <string name="reboot_userspace">Lagano Ponovo pokretanje</string>
    <string name="module_failed_to_enable">Neuspješno uključivanje module: %s</string>
    <string name="reboot_download">Ponovo pokrenite u Preuzimanje</string>
    <string name="module_failed_to_disable">Neuspješno isključivanje module: %s</string>
    <string name="reboot_edl">Ponovo pokrenite u EDL</string>
    <string name="module_uninstall_failed">Neuspješna deinstalacija: %s</string>
    <string name="selinux_status_disabled">Isključeno</string>
    <string name="about">O</string>
    <string name="module_uninstall_confirm">Jeste li sigurni da želite deinstalirati modulu %s\?</string>
    <string name="home_support_content">KernelSU je, i uvijek če biti, besplatan, i otvorenog izvora. Možete nam međutim pokazati da vas je briga s time da napravite donaciju.</string>
    <string name="profile_default">Zadano</string>
    <string name="profile_template">Šablon</string>
    <string name="profile_custom">Prilagođeno</string>
    <string name="profile_name">Naziv profila</string>
    <string name="save_log">Sačuvaj Dnevnike</string>
    <string name="module_install_prompt_with_name">Modul će biti instaliran</string>
    <string name="module_sort_action_first">Sortiraj</string>
    <string name="confirm">Potvrdi</string>
    <string name="settings_sucompat">Preusmjeri su binarnu datoteku</string>
    <string name="settings_sucompat_summary">Preusmjeri /system/bin/su na ksud za aplikacije kojima je dodijeljeno dopuštenje Superuser u Profilu aplikacije; učinkovito samo za nove procese.</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">Ponašanje umount na razini kernela kontrolira KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-da/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_working">Arbejder</string>
    <string name="home_unsupported">Ikke understøttet</string>
    <string name="home_kernel">Kernel-version</string>
    <string name="home_unsupported_reason">KernelSU understøtter nu kun GKI-kerner.</string>
    <string name="home_manager_version">Manager version</string>
    <string name="home_selinux_status">SELinux-status</string>
    <string name="selinux_status_disabled">Deaktiveret</string>
    <string name="selinux_status_permissive">Tilladende</string>
    <string name="superuser">Superbruger</string>
    <string name="selinux_status_enforcing">Håndhævende</string>
    <string name="module_failed_to_disable">Deaktivering af modul fejlede: %s</string>
    <string name="module_empty">Intet modul installeret</string>
    <string name="uninstall">Afinstaller</string>
    <string name="module_install">Installer</string>
    <string name="install">Installer</string>
    <string name="reboot">Genstart</string>
    <string name="settings">Indstillinger</string>
    <string name="reboot_userspace">Blød genstart</string>
    <string name="reboot_download">Genstart til Download</string>
    <string name="reboot_edl">Genstart til EDL</string>
    <string name="about">Om</string>
    <string name="module_uninstall_confirm">Er du sikker på, at du vil afinstallere modulet %s\?</string>
    <string name="module_uninstall_success">%s afinstalleret</string>
    <string name="module_uninstall_failed">Afinstallation af: %s fejlede</string>
    <string name="send_log">Send logfiler</string>
    <string name="safe_mode">Sikker tilstand</string>
    <string name="reboot_to_apply">Genstart for at tage effekt</string>
    <string name="home_learn_kernelsu">Lær KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Lær hvordan man installerer KernelSU og moduler.</string>
    <string name="about_source_code"><![CDATA[View source code at %1$s<br/>Join our %2$s channel]]></string>
    <string name="profile_default">Standard</string>
    <string name="profile_template">Skabelon</string>
    <string name="profile_namespace">Monter namespace</string>
    <string name="profile_namespace_inherited">Arvet</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_groups">Grupper</string>
    <string name="profile_capabilities">Evner</string>
    <string name="profile_selinux_context">SELinux-kontext</string>
    <string name="profile_umount_modules">Afmonteret moduler</string>
    <string name="settings_umount_modules_default">Afmontere moduler</string>
    <string name="profile_umount_modules_summary">Hvis denne indstilling aktiveres, kan KernelSU gendanne alle ændrede filer af modulerne til denne app.</string>
    <string name="module_update">Opdatering</string>
    <string name="module_downloading">Downloader modulet: %s</string>
    <string name="new_version_available">Ny version %s er tilgængelig, klik for at opgradere!</string>
    <string name="launch_app">Start</string>
    <string name="force_stop_app">Tving stop</string>
    <string name="failed_to_update_sepolicy">Opdatering af SELinux-regler mislykkedes for %s</string>
    <string name="module_start_downloading">Start download: %s</string>
    <string name="home_click_to_install">Klik for at installere</string>
    <string name="home_working_version">Version: %d</string>
    <string name="home">Hjem</string>
    <string name="home_not_installed">Ikke installeret</string>
    <string name="home_fingerprint">Fingeraftryk</string>
    <string name="selinux_status_unknown">Ukendt</string>
    <string name="module_failed_to_enable">Aktivering af modul fejlede: %s</string>
    <string name="reboot_recovery">Genstart til Recovery</string>
    <string name="module">Modul</string>
    <string name="module_author">Forfatter</string>
    <string name="reboot_bootloader">Genstart til Bootloader</string>
    <string name="module_version">Version</string>
    <string name="show_system_apps">Vis system-apps</string>
    <string name="module_magisk_conflict">Moduler er utilgængelige på grund af en konflikt med Magisk!</string>
    <string name="home_support_title">Støt Os</string>
    <string name="home_support_content">KernelSU er, og vil altid være, gratis og åben kildekode. Du kan dog vise os, at du holder af os, ved at give en donation.</string>
    <string name="profile_custom">Brugerdefineret</string>
    <string name="profile_name">Profilnavn</string>
    <string name="profile_namespace_individual">Individuel</string>
    <string name="failed_to_update_app_profile">Opdatering af App Profil for %s fejlede</string>
    <string name="settings_umount_modules_default_summary">Den globale standardværdi for \"Umount moduler\" i App Profile. Hvis aktiveret, fjernes alle modulændringer til systemet for apps, der ikke har en profil angivet.</string>
    <string name="profile_selinux_domain">Domæne</string>
    <string name="profile_selinux_rules">Regler</string>
    <string name="restart_app">Genstart</string>
    <string name="require_kernel_version">Den nuværende KernelSU-version %1$d er for lav til, at manageren fungerer korrekt. Opgrader venligst til version %2$d eller højere!</string>
    <string name="save_log">Gem logs</string>
    <string name="module_install_prompt_with_name">Følgende moduler installeres: %1$s</string>
    <string name="module_sort_action_first">Sorter (Handling først)</string>
    <string name="module_sort_enabled_first">Sorter (Aktiveret først)</string>
    <string name="confirm">Bekræft</string>
    <string name="su_not_allowed">Kunne ikke tildele superbruger-adgang til %s</string>
    <string name="module_changelog">Ændringslog</string>
    <string name="settings_profile_template">App-profilskabelon</string>
    <string name="settings_profile_template_summary">Administrer lokale og online skabeloner til App-profil.</string>
    <string name="app_profile_template_create">Opret skabelon</string>
    <string name="app_profile_template_edit">Rediger skabelon</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Ugyldigt skabelon-ID</string>
    <string name="app_profile_template_name">Navn</string>
    <string name="app_profile_template_description">Beskrivelse</string>
    <string name="app_profile_template_save">Gem</string>
    <string name="app_profile_template_delete">Slet</string>
    <string name="app_profile_template_view">Visningsskabelon</string>
    <string name="app_profile_template_id_exist">Skabelon-ID findes allerede!</string>
    <string name="app_profile_import_export">Import/Eksport</string>
    <string name="app_profile_import_from_clipboard">Importér fra udklipsholder</string>
    <string name="app_profile_export_to_clipboard">Eksporter til udklipsholder</string>
    <string name="app_profile_template_export_empty">Kan ikke finde lokal skabelon til eksport!</string>
    <string name="app_profile_template_import_success">Importér med succes</string>
    <string name="app_profile_template_save_failed">Kunne ikke gemme skabelon</string>
    <string name="app_profile_template_import_empty">Udklipsholderen er tom!</string>
    <string name="settings_check_update">Check for opdateringer</string>
    <string name="settings_check_update_summary">Søg automatisk efter opdateringer, når appen åbnes.</string>
    <string name="grant_root_failed">Kunne ikke tildelle root!</string>
    <string name="action">Handling</string>
    <string name="open">Åbn</string>
    <string name="enable_web_debugging">WebView-fejlsøgning</string>
    <string name="enable_web_debugging_summary">Kan bruges til at fejlfinde af WebUI. Aktiver kun når det er nødvendigt.</string>
    <string name="direct_install">Direkte installation (Anbefalet)</string>
    <string name="select_file">Vælg en fil</string>
    <string name="install_inactive_slot">Installer på inaktiv slot (efter OTA-opdatering)</string>
    <string name="install_inactive_slot_warning">Din enhed vil blive **TVUNGET** til at starte op fra det aktuelt inaktive slot efter en genstart!\nBrug kun denne mulighed, når OTA er færdig.\nFortsæt?</string>
    <string name="install_next">Næste</string>
    <string name="select_file_tip">%1$s partitionsbillede anbefales</string>
    <string name="select_kmi">Vælg KMI</string>
    <string name="settings_uninstall">Afinstaller</string>
    <string name="settings_uninstall_temporary">Afinstaller midlertidigt</string>
    <string name="settings_uninstall_permanent">Afinstaller permanent</string>
    <string name="settings_restore_stock_image">Gendan systemets standardbillede</string>
    <string name="settings_uninstall_temporary_message">Afinstaller KernelSU midlertidigt, og gendan til den oprindelige tilstand efter næste genstart.</string>
    <string name="settings_uninstall_permanent_message">Afinstallation af KernelSU (root og alle moduler) fuldstændigt og permanent.</string>
    <string name="settings_restore_stock_image_message">Gendan det originale fabriksbillede (hvis en sikkerhedskopi eksisterer), hvilket normalt bruges før en OTA-opdatering; hvis du skal afinstallere KernelSU, skal du bruge \"Afinstaller permanent\".</string>
    <string name="flashing">Flashing</string>
    <string name="flash_success">Flash-succes</string>
    <string name="flash_failed">Flash mislykkedes</string>
    <string name="selected_lkm">Valgt LKM: %s</string>
    <string name="log_saved">Logs gemt</string>
    <string name="settings_module_check_update">Søg efter modulopdateringer</string>
    <string name="install_upload_lkm_file">Brug lokal KLM-fil</string>
    <string name="install_only_support_ko_file">Kun .ko-filer understøttes</string>
    <string name="settings_sucompat">Omdiriger su binary</string>
    <string name="settings_sucompat_summary">Tillader apps med Superuser-tilladelse i App Profile at få superuser shell ved at udføre /system/bin/su; gælder kun for nye processer.</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">Kernel-niveau umount adfærd kontrolleret af KernelSU</string>
    <string name="processing">Behandler…</string>
    <string name="refresh_pulling">Træk ned for at opdatere</string>
    <string name="refresh_release">Slip for at opdatere</string>
    <string name="refresh_refresh">Opdaterer…</string>
    <string name="refresh_complete">Opdateret</string>
</resources>

```

`manager/app/src/main/res/values-de/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Startseite</string>
    <string name="home_not_installed">Nicht installiert</string>
    <string name="selinux_status_permissive">Permissiv</string>
    <string name="home_working">Funktioniert</string>
    <string name="home_working_version">Version: %d</string>
    <string name="superuser">Superuser</string>
    <string name="home_click_to_install">Tippe zum Installieren</string>
    <string name="selinux_status_unknown">Unbekannt</string>
    <string name="selinux_status_enforcing">Erzwingen</string>
    <string name="reboot_bootloader">In den Bootloader-Modus neustarten</string>
    <string name="reboot_download">In den Download-Modus neustarten</string>
    <string name="reboot_edl">In den EDL-Modus neustarten</string>
    <string name="module_author">Autor</string>
    <string name="about">Über KernelSU</string>
    <string name="module_magisk_conflict">Module sind aufgrund eines Konfliktes mit Magisk nicht verfügbar!</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Erfahre, wie KernelSU installiert wird und wie Module verwendet werden.</string>
    <string name="home_support_title">Unterstütze uns</string>
    <string name="home_support_content">KernelSU ist und wird immer frei und quelloffen sein. Du kannst uns jedoch deine Unterstützung zeigen, indem du eine Spende tätigst.</string>
    <string name="profile_selinux_context">SELinux-Kontext</string>
    <string name="settings_umount_modules_default">Module standardmäßig aushängen</string>
    <string name="settings_umount_modules_default_summary">Globaler Standardwert für \"Module aushängen\" im App-Profil. Falls er aktiviert ist, werden alle Moduländerungen im System für alle Apps entfernt, für die kein Profil festgelegt ist.</string>
    <string name="profile_default">Standard</string>
    <string name="profile_template">Vorlage</string>
    <string name="profile_custom">Benutzerdefiniert</string>
    <string name="failed_to_update_app_profile">App-Profilaktualisierung für %s fehlgeschlagen</string>
    <string name="profile_namespace_inherited">Geerbt</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individuell</string>
    <string name="profile_selinux_domain">Domäne</string>
    <string name="module_update">Aktualisieren</string>
    <string name="profile_umount_modules_summary">Wenn du diese Option aktivierst, kann KernelSU alle von den Modulen für diese App geänderten Dateien wiederherstellen.</string>
    <string name="profile_selinux_rules">Regeln</string>
    <string name="module_start_downloading">Starte Download: %s</string>
    <string name="failed_to_update_sepolicy">Aktualisieren der SELinux-Regeln schlug fehl für %s</string>
    <string name="launch_app">Starten</string>
    <string name="new_version_available">Neue Version %s verfügbar, tippen zum Aktualisieren!</string>
    <string name="force_stop_app">Stopp erzwingen</string>
    <string name="restart_app">Neustarten</string>
    <string name="home_manager_version">Manager-Version</string>
    <string name="home_selinux_status">SELinux Status</string>
    <string name="selinux_status_disabled">Deaktiviert</string>
    <string name="module_failed_to_enable">Modulaktivierung fehlgeschlagen: %s</string>
    <string name="module_failed_to_disable">Moduldeaktivierung fehlgeschlagen: %s</string>
    <string name="module_empty">Keine Modul installiert</string>
    <string name="module">Modul</string>
    <string name="uninstall">Deinstallieren</string>
    <string name="install">Installieren</string>
    <string name="reboot">Neustarten</string>
    <string name="settings">Einstellungen</string>
    <string name="reboot_recovery">In den Recovery-Modus neustarten</string>
    <string name="module_uninstall_success">%s deinstalliert</string>
    <string name="module_version">Version</string>
    <string name="show_system_apps">System-Apps anzeigen</string>
    <string name="send_log">Protokoll senden</string>
    <string name="home_learn_kernelsu">KernelSU verstehen</string>
    <string name="safe_mode">Sicherer Modus</string>
    <string name="reboot_to_apply">Neustarten, damit Änderungen wirksam werden</string>
    <string name="about_source_code"><![CDATA[Quellcode einsehen unter %1$s<br/>Unserem %2$s-Kanal beitreten]]></string>
    <string name="profile_name">Profilname</string>
    <string name="profile_namespace">Namespace einhängen</string>
    <string name="profile_groups">Gruppen</string>
    <string name="profile_capabilities">Fähigkeiten</string>
    <string name="profile_umount_modules">Module aushängen</string>
    <string name="module_downloading">Lädt Modul %s herunter</string>
    <string name="home_unsupported">Nicht unterstützt</string>
    <string name="home_unsupported_reason">KernelSU unterstützt derzeit nur GKI-Kernel.</string>
    <string name="home_kernel">Kernelversion</string>
    <string name="home_fingerprint">Fingerabdruck</string>
    <string name="module_install">Installieren</string>
    <string name="reboot_userspace">Soft Reboot</string>
    <string name="module_uninstall_confirm">Möchtest du wirklich Modul %s deinstallieren?</string>
    <string name="module_uninstall_failed">Deinstallation fehlgeschlagen: %s</string>
    <string name="require_kernel_version">Die aktuelle KernelSU-Version %1$d ist zu alt für diese Manager-Version. Bitte auf Version %2$d oder höher aktualisieren!</string>
    <string name="module_changelog">Änderungsprotokoll</string>
    <string name="app_profile_template_import_success">Erfolgreich importiert</string>
    <string name="app_profile_export_to_clipboard">In Zwischenablage exportieren</string>
    <string name="app_profile_template_export_empty">Kann lokale Vorlage nicht finden!</string>
    <string name="app_profile_template_id_exist">Vorlagen-ID existiert bereits!</string>
    <string name="app_profile_import_from_clipboard">Aus Zwischenablage importieren</string>
    <string name="app_profile_template_name">Name</string>
    <string name="app_profile_template_id_invalid">Ungültige Vorlagen-ID</string>
    <string name="app_profile_template_create">Vorlage erstellen</string>
    <string name="app_profile_import_export">Import/Export</string>
    <string name="app_profile_template_save_failed">Schlug beim Speichern der Vorlage fehl</string>
    <string name="app_profile_template_edit">Vorlage bearbeiten</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">App Profil-Vorlage</string>
    <string name="app_profile_template_description">Beschreibung</string>
    <string name="app_profile_template_save">Speichern</string>
    <string name="settings_profile_template_summary">Verwalte die lokale und online Vorlage des App-Profils.</string>
    <string name="app_profile_template_delete">Löschen</string>
    <string name="app_profile_template_import_empty">Zwischenablage ist leer!</string>
    <string name="app_profile_template_view">Vorlage ansehen</string>
    <string name="enable_web_debugging">WebView-Debugging</string>
    <string name="enable_web_debugging_summary">Kann zum Fehlerbeheben der WebUI verwendet werden. Bitte nur im Notfall aktivieren.</string>
    <string name="select_file_tip">%1$s Partitionsabbild empfohlen</string>
    <string name="select_kmi">KMI auswählen</string>
    <string name="install_next">Weiter</string>
    <string name="direct_install">Direkte Installation (empfohlen)</string>
    <string name="select_file">Datei auswählen</string>
    <string name="install_inactive_slot">In inaktiven Slot installieren (nach OTA)</string>
    <string name="install_inactive_slot_warning">Nach einem Neustart wird dein Gerät **GEZWUNGEN** in den derzeit inaktiven Slot zu starten!
\nBenutze dies nur nach Fertigstellung des OTA.
\nFortfahren?</string>
    <string name="grant_root_failed">Root-Zugriff konnte nicht gewährt werden!</string>
    <string name="open">Öffnen</string>
    <string name="settings_check_update">Auf Aktualisierungen prüfen</string>
    <string name="settings_check_update_summary">Prüfe automatisch auf Aktualisierungen, wenn die App geöffnet wird.</string>
    <string name="settings_uninstall_temporary">Temporär deinstallieren</string>
    <string name="settings_uninstall">Deinstallieren</string>
    <string name="settings_uninstall_permanent_message">KernelSU (Root und alle Module) vollständig und dauerhaft deinstallieren.</string>
    <string name="save_log">Protokolle Speichern</string>
    <string name="settings_uninstall_permanent">Permanent deinstallieren</string>
    <string name="settings_restore_stock_image">Standard-Abbild wiederherstellen</string>
    <string name="settings_uninstall_temporary_message">KernelSU temporär deinstallieren, originalen Status nach dem nächsten Neustart wiederherstellen.</string>
    <string name="settings_restore_stock_image_message">Das Standard Werksabbild wiederherstellen (falls ein Backup existiert), normalerweise vor einem OTA zu verwenden; falls Sie KernelSU deinstallieren müssen, nutzen Sie bitte \"Permanent deinstallieren\".</string>
    <string name="flashing">Schreibt</string>
    <string name="flash_success">Schreiben erfolgreich</string>
    <string name="flash_failed">Schreiben fehlgeschlagen</string>
    <string name="selected_lkm">Wähle LKM: %s</string>
    <string name="action">Aktion</string>
    <string name="log_saved">Protokolle gespeichert</string>
    <string name="module_install_prompt_with_name">Folgende Module werden installiert: %1$s</string>
    <string name="confirm">Bestätigen</string>
    <string name="module_sort_action_first">Aktion zuerst</string>
    <string name="module_sort_enabled_first">Aktiviert zuerst</string>
    <string name="module_repos">Repos</string>
    <string name="module_repos_sort_name">Name (A → Z)</string>
    <string name="module_repos_source_code">Quellcode</string>
    <string name="metamodule_uninstall_confirm">Sind Sie sich sicher, das Modul %s zu deinstallieren? Diese Aktion wirkt sich auf alle Module aus und spezielle Funktionen, welche von dem Metamodul bereitgestellt werden (sowie montieren), werden nicnt mehr funktioneren.</string>
    <string name="safe_mode_module_disabled">Modulinstallation ist im sicheren Modus deaktiviert</string>
    <string name="home_gki_warning">Ab v3.0.0 wird der GKI Arbeitsmodus nur in Testumgebungen genutzt werden. Wir empfehlen es nicht für die tägliche Nutzung und Bilddateien werden nicht mehr bereitgestellt werden.</string>
    <string name="su_not_allowed">Es konnte für %s keine Superuser-Berechtigung gegeben werden</string>
    <string name="app_profile_affects_following_apps">Wirkt sich auf folgende Apps aus</string>
    <string name="settings_sucompat">Su-Binärdatei umleiten</string>
    <string name="settings_sucompat_summary">Ermöglicht Anwendungen mit Superuser-Berechtigung im App-Profil, eine Superuser-Shell durch Ausführung von /system/bin/su zu erhalten; wirksam nur für neue Prozesse.</string>
    <string name="settings_module_check_update">Auf Modulaktualisierungen prüfen</string>
    <string name="install_select_partition">Partition wählen</string>
    <string name="install_upload_lkm_file">Nutze lokale LKM Datei</string>
    <string name="install_only_support_ko_file">Nur .ko Dateien unterstützt</string>
</resources>

```

`manager/app/src/main/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Inicio</string>
    <string name="home_not_installed">No instalado</string>
    <string name="home_click_to_install">Haz clic para instalar</string>
    <string name="home_working">Funcionando</string>
    <string name="home_working_version">Versión: %d</string>
    <string name="home_unsupported">Sin soporte</string>
    <string name="home_unsupported_reason">KernelSU solo admite kernels GKI por ahora</string>
    <string name="home_kernel">Versión del kernel</string>
    <string name="home_manager_version">Versión del gestor</string>
    <string name="home_fingerprint">Huella del dispositivo</string>
    <string name="home_selinux_status">Estado de SELinux</string>
    <!-- It may be better to leave SELinux statuses untranslated -->
    <string name="selinux_status_disabled">Desactivado</string>
    <string name="selinux_status_enforcing">Estricto</string>
    <string name="selinux_status_permissive">Permisivo</string>
    <string name="selinux_status_unknown">Desconocido</string>
    <string name="superuser">Superusuario</string>
    <string name="module_failed_to_enable">Error al activar el módulo: %s</string>
    <string name="module_failed_to_disable">Error al desactivar el módulo: %s</string>
    <string name="module_empty">Ningún módulo instalado</string>
    <string name="module">Módulo</string>
    <string name="uninstall">Desinstalar</string>
    <string name="module_install">Instalar</string>
    <string name="install">Instalar</string>
    <string name="reboot">Reiniciar</string>
    <string name="settings">Ajustes</string>
    <string name="reboot_userspace">Reinicio suave</string>
    <string name="reboot_recovery">Reiniciar en modo de recuperación</string>
    <string name="reboot_bootloader">Reiniciar en modo de arranque</string>
    <string name="reboot_download">Reiniciar en modo Download</string>
    <string name="reboot_edl">Reiniciar en modo EDL</string>
    <string name="about">Acerca de</string>
    <string name="module_uninstall_confirm">¿Está seguro de que desea desinstalar el módulo %s?</string>
    <string name="module_uninstall_success">%s desinstalado</string>
    <string name="module_uninstall_failed">Fallo al desinstalar: %s</string>
    <string name="module_version">Versión</string>
    <string name="module_author">Autor</string>
    <string name="show_system_apps">Mostrar aplicaciones del sistema</string>
    <string name="send_log">Enviar registros</string>
    <string name="safe_mode">Modo seguro</string>
    <string name="reboot_to_apply">Reinicia para aplicar cambios</string>
    <string name="module_magisk_conflict">¡Los módulos no están disponibles debido a un conflicto con Magisk!</string>
    <string name="home_learn_kernelsu">Aprende KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Aprende a instalar KernelSU y a utilizar módulos</string>
    <string name="home_support_title">Apóyanos</string>
    <string name="home_support_content">KernelSU es, y siempre será, gratuito y de código abierto. Sin embargo, puedes demostrarnos que te importamos haciendo una donación.</string>
    <string name="about_source_code">Ver código fuente en %1$s<br/>
Únete a nuestro canal %2$s</string>
    <string name="profile_default">Predeterminado</string>
    <string name="profile_template">Plantilla</string>
    <string name="profile_custom">Personalizado</string>
    <string name="profile_name">Nombre de perfil</string>
    <string name="profile_namespace">Montaje del espacio de nombres</string>
    <string name="profile_namespace_inherited">Heredado</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Grupos</string>
    <string name="profile_capabilities">Capacidades</string>
    <string name="profile_selinux_context">Contexto SELinux</string>
    <string name="profile_umount_modules">Desmontar módulos</string>
    <string name="failed_to_update_app_profile">Error al actualizar el perfil de la aplicación para %s</string>
    <string name="settings_umount_modules_default">Desmontar módulos por defecto</string>
    <string name="settings_umount_modules_default_summary">El valor global predeterminado para \"Umount modules\" en App Profile. Si está activado, eliminará todas las modificaciones de módulos del sistema para las apps que no tengan un perfil establecido.</string>
    <string name="profile_umount_modules_summary">Activar esta opción permitirá a KernelSU restaurar cualquier archivo modificado por los módulos para esta aplicación.</string>
    <string name="profile_selinux_domain">Dominio</string>
    <string name="profile_selinux_rules">Reglas</string>
    <string name="module_update">Actualizar</string>
    <string name="module_downloading">Descargando módulo: %s</string>
    <string name="module_start_downloading">Iniciar descarga: %s</string>
    <string name="new_version_available">La nueva versión %s está disponible, haga clic para actualizar.</string>
    <string name="launch_app">Iniciar</string>
    <string name="force_stop_app">Forzar detención</string>
    <string name="restart_app">Reiniciar</string>
    <string name="failed_to_update_sepolicy">Error al actualizar las reglas SELinux para: %s</string>
    <string name="require_kernel_version">La versión %1$d actual de KernelSU es demasiado baja para que el gestor funcione correctamente. Por favor, ¡actualice a la versión %2$d o superior!</string>
    <string name="module_changelog">Registro de cambios</string>
    <string name="app_profile_template_import_success">Importado con éxito</string>
    <string name="app_profile_export_to_clipboard">Exportar al portapapeles</string>
    <string name="app_profile_template_export_empty">¡No se encuentra la plantilla local para exportar!</string>
    <string name="app_profile_template_id_exist">¡El ID de plantilla ya existe!</string>
    <string name="app_profile_import_from_clipboard">Importar desde el portapapeles</string>
    <string name="app_profile_template_name">Nombre</string>
    <string name="app_profile_template_id_invalid">ID de plantilla no válida</string>
    <string name="app_profile_template_create">Crear plantilla</string>
    <string name="app_profile_import_export">Importar/Exportar</string>
    <string name="app_profile_template_save_failed">No se ha podido guardar la plantilla</string>
    <string name="app_profile_template_edit">Editar plantilla</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">Plantilla de perfil de aplicación</string>
    <string name="app_profile_template_description">Descripción</string>
    <string name="app_profile_template_save">Guardar</string>
    <string name="settings_profile_template_summary">Gestionar la plantilla local y en línea de App Profile</string>
    <string name="app_profile_template_delete">Eliminar</string>
    <string name="app_profile_template_import_empty">¡El portapapeles está vacío!</string>
    <string name="app_profile_template_view">Ver plantilla</string>
    <string name="save_log">Guardar registros</string>
    <string name="enable_web_debugging">Activar la depuración de WebView</string>
    <string name="select_file_tip">Se recomienda la imagen de partición %1$s</string>
    <string name="select_kmi">Selecciona KMI</string>
    <string name="install_next">Siguiente</string>
    <string name="direct_install">Instalación directa (Recomendada)</string>
    <string name="install_inactive_slot_warning">¡Su dispositivo será **FORZADO** a arrancar en la ranura inactiva actual después de un reinicio!\nUtilice esta opción sólo después de que la OTA se haya realizado.\n¿Continuar?</string>
    <string name="settings_uninstall">Desinstalar</string>
    <string name="settings_restore_stock_image">Restaurar imagen de archivo</string>
    <string name="settings_uninstall_temporary_message">Desinstalar temporalmente KernelSU, restaurar al estado original tras el siguiente reinicio.</string>
    <string name="selected_lkm">LKM seleccionado: %s</string>
    <string name="flash_failed">Flash falló</string>
    <string name="flash_success">Éxito de Flash</string>
    <string name="grant_root_failed">¡No se ha podido conceder el acceso root!</string>
    <string name="open">Abrir</string>
    <string name="select_file">Seleccione un archivo</string>
    <string name="install_inactive_slot">Instalar en ranura inactiva (Después de OTA)</string>
    <string name="settings_uninstall_temporary">Desinstalar temporalmente</string>
    <string name="settings_uninstall_permanent">Desinstalar permanentemente</string>
    <string name="settings_uninstall_permanent_message">Desinstalar KernelSU (Root y todos los módulos) completa y permanentemente.</string>
    <string name="settings_check_update">Comprobar actualización</string>
    <string name="settings_check_update_summary">Comprobación automática de actualizaciones al abrir la aplicación</string>
    <string name="enable_web_debugging_summary">Puede ser usado para depurar WebUI, por favor habilítalo sólo cuando sea necesario.</string>
    <string name="settings_restore_stock_image_message">Restaurar la imagen de fábrica stock (Si existe una copia de seguridad), por lo general se utiliza antes de OTA; si necesita desinstalar KernelSU, por favor, utilice \"Desinstalar permanentemente\".</string>
    <string name="settings_sucompat">Redirigir binario su</string>
    <string name="settings_sucompat_summary">Permite que las aplicaciones con permiso de Superusuario en el perfil de la aplicación obtengan un shell de superusuario ejecutando /system/bin/su; efectivo solo para nuevos procesos.</string>
    <string name="settings_kernel_umount">Desmontaje del kernel</string>
    <string name="settings_kernel_umount_summary">Comportamiento de desmontaje a nivel de kernel controlado por KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-et/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_working">Töötamine</string>
    <string name="home_working_version">Versioon: %d</string>
    <string name="home_kernel">Tuum</string>
    <string name="home_manager_version">Manageri versioon</string>
    <string name="home_fingerprint">Sõrmejälg</string>
    <string name="selinux_status_permissive">Lubav</string>
    <string name="module_failed_to_enable">Mooduli lubamine ebaõnnestus: %s</string>
    <string name="module_empty">Mooduleid pole paigaldatud</string>
    <string name="reboot">Taaskäivita</string>
    <string name="reboot_recovery">Taaskäivita taastusesse</string>
    <string name="module_uninstall_confirm">Kas soovid kindlasti eemaldada mooduli %s?</string>
    <string name="module_uninstall_success">%s eemaldatud</string>
    <string name="send_log">Saada logid</string>
    <string name="safe_mode">Turvarežiim</string>
    <string name="reboot_to_apply">Muudatuste rakendamiseks taaskäivita</string>
    <string name="home_learn_kernelsu">Õpi KernelSUd</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="profile_default">Vaikimisi</string>
    <string name="profile_namespace">Haagi nimeruum</string>
    <string name="profile_umount_modules">Lahtihaagitud moodulid</string>
    <string name="failed_to_update_app_profile">Rakenduseprofiili uuendamine %s jaoks ebaõnnestus</string>
    <string name="settings_umount_modules_default">Haagi moodulid vaikimisi lahti</string>
    <string name="module_start_downloading">Allalaadimise alustamine: %s</string>
    <string name="failed_to_update_sepolicy">SELinux reeglite uuendamine ebaõnnestus: %s</string>
    <string name="app_profile_template_edit">Muuda malli</string>
    <string name="settings_profile_template">Rakenduseprofiili mall</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_exist">Malli ID juba eksisteerib!</string>
    <string name="app_profile_export_to_clipboard">Ekspordi lõikelauale</string>
    <string name="home">Kodu</string>
    <string name="home_click_to_install">Klõpsa paigaldamiseks</string>
    <string name="home_not_installed">Pole paigaldatud</string>
    <string name="home_unsupported">Mittetoetatud</string>
    <string name="home_unsupported_reason">KernelSU toetab hetkel vaid GSI tuumasid</string>
    <string name="home_selinux_status">SELinuxi olek</string>
    <string name="selinux_status_disabled">Keelatud</string>
    <string name="selinux_status_enforcing">Jõustav</string>
    <string name="selinux_status_unknown">Teadmata</string>
    <string name="superuser">Superkasutaja</string>
    <string name="module_failed_to_disable">Mooduli keelamine ebaõnnestus: %s</string>
    <string name="module">Moodul</string>
    <string name="reboot_bootloader">Taaskäivita käivituslaadurisse</string>
    <string name="uninstall">Eemalda</string>
    <string name="install">Paigalda</string>
    <string name="about">Teave</string>
    <string name="module_install">Paigalda</string>
    <string name="settings">Seaded</string>
    <string name="reboot_userspace">Pehme taaskäivitus</string>
    <string name="reboot_download">Taaskäivita allalaadimisrežiimi</string>
    <string name="reboot_edl">Taaskäivita EDL-i</string>
    <string name="module_author">Autor</string>
    <string name="module_uninstall_failed">Eemaldamine ebaõnnestus: %s</string>
    <string name="module_version">Versioon</string>
    <string name="show_system_apps">Kuva süsteemirakendused</string>
    <string name="module_magisk_conflict">Moodulid pole saadaval Magiski konflikti tõttu!</string>
    <string name="home_click_to_learn_kernelsu">Õpi KernelSUd paigaldama ja mooduleid kasutama</string>
    <string name="home_support_title">Toeta meid</string>
    <string name="profile_groups">Grupid</string>
    <string name="home_support_content">KernelSU on, ja alati jääb, tasuta ning avatud lähtekoodiga kättesaadavaks. Sellegipoolest võid sa näidata, et hoolid, ning teha annetuse.</string>
    <string name="profile_template">Mall</string>
    <string name="about_source_code">Vaata lähtekoodi %1$sis<br/>
Liitu meie %2$si kanaliga</string>
    <string name="profile_name">Profiili nimi</string>
    <string name="profile_custom">Kohandatud</string>
    <string name="profile_namespace_inherited">Päritud</string>
    <string name="profile_namespace_global">Globaalne</string>
    <string name="profile_namespace_individual">Individuaalne</string>
    <string name="profile_capabilities">Võimekused</string>
    <string name="app_profile_template_id_invalid">Sobimatu malli ID</string>
    <string name="profile_selinux_context">SELinux kontekst</string>
    <string name="require_kernel_version">Praegune KernelSU versioon %1$d on liiga madal, haldur ei saa korrektselt töötada. Palun täienda versioonile %2$d või kõrgem!</string>
    <string name="profile_selinux_domain">Domeen</string>
    <string name="launch_app">Käivita</string>
    <string name="force_stop_app">Sundpeata</string>
    <string name="profile_selinux_rules">Reeglid</string>
    <string name="module_update">Uuenda</string>
    <string name="module_downloading">Mooduli allalaadimine: %s</string>
    <string name="new_version_available">Uus versioon %s on saadaval, klõpsa täiendamiseks.</string>
    <string name="restart_app">Taaskäivita</string>
    <string name="module_changelog">Muudatuste logi</string>
    <string name="app_profile_template_name">Nimi</string>
    <string name="app_profile_template_description">Kirjeldus</string>
    <string name="app_profile_template_import_success">Edukalt imporditud</string>
    <string name="app_profile_template_save">Salvesta</string>
    <string name="app_profile_template_import_empty">Lõikelaud on tühi!</string>
    <string name="app_profile_template_delete">Kustuta</string>
    <string name="app_profile_template_view">Vaata malli</string>
    <string name="app_profile_import_export">Impordi/ekspordi</string>
    <string name="app_profile_import_from_clipboard">Impordi lõikelaualt</string>
    <string name="app_profile_template_save_failed">Malli salvestamine ebaõnnestus</string>
    <string name="app_profile_template_create">Loo mall</string>
    <string name="settings_profile_template_summary">Halda kohalikke ja võrgusolevaid rakenduseprofiili malle</string>
    <string name="profile_umount_modules_summary">Selle valiku lubamine lubab KernelSU-l taastada selle rakenduse moodulite poolt mistahes muudetud faile.</string>
    <string name="app_profile_template_export_empty">Ei saa eksportida, kohalikku malli ei leitud!</string>
    <string name="settings_umount_modules_default_summary">Globaalne vaikeväärtus \"Lahtihaagitud moodulitele\" rakenduseprofiilis. Lubamisel eemaldab see kõik moodulite süsteemimuudatused rakendustele, millel ei ole profiili määratud.</string>
    <string name="enable_web_debugging_summary">Saab kasutada WebUI silumiseks, palun luba ainult vajadusel.</string>
    <string name="grant_root_failed">Juurkasutaja andmine ebaõnnestus!</string>
    <string name="settings_check_update">Kontrolli uuendusi</string>
    <string name="settings_check_update_summary">Rakenduse avamisel kontrolli automaatselt uuendusi</string>
    <string name="open">Ava</string>
    <string name="enable_web_debugging">Luba WebView silumine</string>
    <string name="save_log">Salvesta Logid</string>
    <string name="select_kmi">Vali KMI</string>
    <string name="select_file_tip">%1$s partitsioonitõmmis on soovitatud</string>
    <string name="install_next">Edasi</string>
    <string name="install_inactive_slot_warning">Sinu seade **SUNNITAKSE** pärast taaskäivitust ebaaktiivsesse lahtrisse käivituma!\nKasuta seda valikut vaid siis, kui tegid üle-õhu uuenduse.\nJätkad?</string>
    <string name="settings_uninstall">Eemalda</string>
    <string name="settings_uninstall_temporary_message">Eemalda KernelSU ajutiselt, taasta pärast taaskäivitust algseisu.</string>
    <string name="settings_uninstall_permanent_message">KernelSU eemaldamine (juurkasutaja ja kõik moodulid) täielikult ja püsivalt.</string>
    <string name="settings_restore_stock_image_message">Taasta tehase-vaiketõmmis (kui varundus eksisteerib), tavaliselt kasutatakse enne üle-õhu uuendust; kui soovid KernelSU-d eemaldada, palun kasuta \"Eemalda püsivalt\".</string>
    <string name="flashing">Välgutamine</string>
    <string name="flash_success">Välgutamine õnnestus</string>
    <string name="flash_failed">Välgutamine ebaõnnestus</string>
    <string name="selected_lkm">Valitud LKM: %s</string>
    <string name="direct_install">Otsene paigaldus (soovitatud)</string>
    <string name="select_file">Vali fail</string>
    <string name="install_inactive_slot">Paigalda ebaaktiivsesse lahtrisse (pärast üle-õhu uuendust)</string>
    <string name="settings_uninstall_temporary">Eemalda ajutiselt</string>
    <string name="settings_uninstall_permanent">Eemalda püsivalt</string>
    <string name="settings_restore_stock_image">Taasta vaikimisi tõmmis</string>
    <string name="settings_sucompat">Suuna su binaarfail ümber</string>
    <string name="settings_sucompat_summary">Võimaldab rakendustel, kellele on antud Superuser luba rakenduse profiilis, saada superuser shell, käivitades /system/bin/su; kehtib ainult uute protsesside puhul.</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">Kerneli tasemel lahtihaakimise käitumine, mida kontrollib KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-fa/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">خانه</string>
    <string name="home_not_installed">نصب نشده است</string>
    <string name="home_click_to_install">برای نصب ضربه بزنید</string>
    <string name="home_working">به درستی کار می‌کند</string>
    <string name="home_working_version">نسخه: %d</string>
    <string name="home_unsupported">پشتیبانی نشده</string>
    <string name="home_unsupported_reason">کرنل اس یو فقط هسته های gki را پشتیبانی میکند</string>
    <string name="home_kernel">هسته</string>
    <string name="home_manager_version">نسخه برنامه</string>
    <string name="home_fingerprint">اثرانگشت</string>
    <string name="home_selinux_status">وضعیت SELinux</string>
    <string name="selinux_status_disabled">غیرفعال</string>
    <string name="selinux_status_enforcing">قانونمند</string>
    <string name="selinux_status_permissive">آزاد</string>
    <string name="selinux_status_unknown">ناشناخته</string>
    <string name="superuser">دسترسی روت</string>
    <string name="module_failed_to_enable">فعال کردن ماژول ناموفق بود: %s</string>
    <string name="module_failed_to_disable">غیرفعال کردن ماژول ناموفق بود: %s</string>
    <string name="module_empty">هیچ ماژولی نصب نشده است</string>
    <string name="module">ماژول</string>
    <string name="uninstall">لغو نصب</string>
    <string name="module_install">نصب</string>
    <string name="install">نصب</string>
    <string name="reboot">راه اندازی دوباره</string>
    <string name="settings">تنظیمات</string>
    <string name="reboot_userspace">راه اندازی نرم</string>
    <string name="reboot_recovery">راه اندازی به ریکاوری </string>
    <string name="reboot_bootloader">راه اندازی به بوتلودر</string>
    <string name="reboot_download">راه اندازی به حالت دانلود</string>
    <string name="reboot_edl">راه اندازی به EDL</string>
    <string name="about">درباره</string>
    <string name="module_uninstall_confirm">آیا مطمئنید که میخواهید ماژول %s را پاک کنید؟</string>
    <string name="module_uninstall_success">%s پاک شد</string>
    <string name="module_uninstall_failed">پاک کردن ناموفق بود: %s</string>
    <string name="module_version">نسخه</string>
    <string name="module_author">سازنده</string>
    <string name="show_system_apps">نمایش برنامه های سیستمی</string>
    <string name="send_log">ارسال وقایع</string>
    <string name="safe_mode">حالت امن</string>
    <string name="reboot_to_apply">راه‌اندازی مجدد برای تاثیرگذاری</string>
    <string name="module_magisk_conflict">مازول به دلیل تعارض با مجیسک غیرفعال شده اند\'s!</string>
    <string name="home_learn_kernelsu">یادگیری کرنل اس یو</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">یاد بگیرید چگونه از کرنل اس یو و ماژول ها استفاده کنید</string>
    <string name="home_support_title">از ما حمایت کنید</string>
    <string name="home_support_content">KernelSU رایگان است و همیشه خواهد بود و منبع باز است. با این حال، می توانید با اهدای کمک مالی به ما نشان دهید که برایتان مهم است.</string>
    <string name="about_source_code">
<![CDATA[ View source code at %1$s<br/>Join our %2$s channel ]]>
</string>
    <string name="profile">پروفایل برنامه</string>
    <string name="profile_default">پیش‌فرض</string>
    <string name="profile_template">قالب</string>
    <string name="profile_custom">شخصی سازی شده</string>
    <string name="profile_name">اسم پروفایل</string>
    <string name="profile_namespace">Mount namespace</string>
    <string name="profile_namespace_inherited">اثر گرفته</string>
    <string name="profile_namespace_global">گلوبال</string>
    <string name="profile_namespace_individual">تکی</string>
    <string name="profile_umount_modules">جداکردن ماژول ها</string>
    <string name="save_log">ذخیره گزارش‌ها</string>
    <string name="settings_sucompat">تغییر مسیر باینری su</string>
    <string name="settings_sucompat_summary">تغییر مسیر /system/bin/su به ksud برای برنامه‌هایی که مجوز Superuser در پروفایل برنامه دارند؛ فقط برای فرآیندهای جدید موثر است.</string>
    <string name="settings_kernel_umount">جداسازی هسته</string>
    <string name="settings_kernel_umount_summary">رفتار جداسازی در سطح هسته که توسط KernelSU کنترل می‌شود</string>
</resources>

```

`manager/app/src/main/res/values-fil/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_selinux_status">Katayuan ng SELinux</string>
    <string name="selinux_status_disabled">Naka-disable</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="home_not_installed">Hindi naka-install</string>
    <string name="home">Panimula</string>
    <string name="home_click_to_install">I-click para i-install</string>
    <string name="home_working">Gumagana</string>
    <string name="home_working_version">Bersyon: %d</string>
    <string name="selinux_status_unknown">Hindi matukoy</string>
    <string name="home_unsupported">Hindi Suportado</string>
    <string name="home_unsupported_reason">Sinusuportahan lamang ng KernelSU ang mga GKI na kernel.</string>
    <string name="module_failed_to_enable">Nabigong paganahin ang module: %s</string>
    <string name="module_failed_to_disable">Nabigong i-disable ang module: %s</string>
    <string name="module_empty">Walang naka-install na modyul</string>
    <string name="module">Modyul</string>
    <string name="module_install">I-install</string>
    <string name="install">I-install</string>
    <string name="reboot">I-reboot</string>
    <string name="reboot_userspace">I-soft reboot</string>
    <string name="reboot_download">I-reboot sa Download</string>
    <string name="reboot_edl">I-reboot sa EDL</string>
    <string name="about">Tungkol</string>
    <string name="module_uninstall_confirm">Sigurado ka bang gusto mong i-uninstall ang module na %s?</string>
    <string name="module_uninstall_success">Na-uninstall ang %s</string>
    <string name="module_uninstall_failed">Nabigong i-uninstall: %s</string>
    <string name="module_author">May-akda</string>
    <string name="show_system_apps">Ipakita ang mga application ng system</string>
    <string name="send_log">Ipadala ang mga log</string>
    <string name="reboot_to_apply">I-reboot para umepekto</string>
    <string name="module_magisk_conflict">Hindi magagamit ang mga module dahil sa isang salungatan sa Magisk!</string>
    <string name="home_learn_kernelsu">Alamin ang KernelSU</string>
    <string name="home_click_to_learn_kernelsu">Matuto kung paano i-install ang KernelSU at gumamit ng mga module</string>
    <string name="home_support_title">Suportahan Kami</string>
    <string name="home_support_content">Ang KernelSU ay, at palaging magiging, libre, at open source. Gayunpaman, maaari mong ipakita sa amin na nagmamalasakit ka sa pamamagitan ng pagbibigay ng donasyon.</string>
    <string name="about_source_code"><![CDATA[Tignan ang source code sa %1$s<br/>Sumali sa aming %2$s channel]]></string>
    <string name="profile_namespace">I-mount ang namespace</string>
    <string name="profile_namespace_individual">Indibidwal</string>
    <string name="profile_groups">Mga Grupo</string>
    <string name="profile_capabilities">Mga Kakayanan</string>
    <string name="profile_selinux_context">Konteksto ng SELinux</string>
    <string name="profile_umount_modules">I-unmount ang mga module</string>
    <string name="failed_to_update_app_profile">Nabigong i-update ang App Profile para sa %s</string>
    <string name="require_kernel_version">Ang kasalukuyang bersyon ng KernelSU %1$d ay masyadong mababa para gumana nang maayos ang manager. Mangyaring mag-upgrade sa bersyon %2$d o mas mataas!</string>
    <string name="profile_umount_modules_summary">Ang pag-enable sa opsyong ito ay magbibigay-daan sa KernelSU na ibalik ang anumang binagong file ng mga module para sa app na ito.</string>
    <string name="profile_selinux_rules">Mga Tuntunin</string>
    <string name="module_downloading">Nagda-download ng modyul: %s</string>
    <string name="module_start_downloading">Simulan ang pag-download: %s</string>
    <string name="new_version_available">Bagong bersyon: Available ang %s, i-click para mag-upgrade.</string>
    <string name="launch_app">Ilunsad</string>
    <string name="force_stop_app">Sapilitang itigil</string>
    <string name="restart_app">I-restart</string>
    <string name="failed_to_update_sepolicy">Nabigong i-update ang mga panuntunan ng SELinux para sa: %s</string>
    <string name="home_manager_version">Bersyon ng manager</string>
    <string name="settings">Mga setting</string>
    <string name="reboot_recovery">I-reboot sa Recovery</string>
    <string name="reboot_bootloader">I-reboot sa Bootloader</string>
    <string name="module_version">Bersyon</string>
    <string name="uninstall">I-uninstall</string>
    <string name="profile_name">Pangalan ng profile</string>
    <string name="profile_namespace_inherited">Minana</string>
    <string name="settings_umount_modules_default_summary">Ang pangkalahatang default na halaga para sa \"Umount modules\" sa Mga Profile ng App. Kung pinagana, aalisin nito ang lahat ng mga pagbabago sa modyul sa system para sa mga aplikasyon na walang hanay ng Profile.</string>
    <string name="save_log">I-save ang mga Log</string>
    <string name="home_kernel">Bersyon ng kernel</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="superuser">Superuser</string>
    <string name="module_install_prompt_with_name">Ii-install ang mga sumusunod na module: %1$s</string>
    <string name="module_sort_action_first">Aksyon muna</string>
    <string name="module_sort_enabled_first">Pinagana muna</string>
    <string name="confirm">Kumpirmahin</string>
    <string name="safe_mode">Safe mode</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="profile_default">Default</string>
    <string name="profile_template">Template</string>
    <string name="profile_custom">Pasadya</string>
    <string name="profile_namespace_global">Global</string>
    <string name="settings_umount_modules_default">I-unmount ang mga module bilang default</string>
    <string name="profile_selinux_domain">Domain</string>
    <string name="module_update">I-update</string>
    <string name="su_not_allowed">Hindi mabigay ang Superuser access sa %s</string>
    <string name="module_changelog">Mga pagbabago</string>
    <string name="settings_profile_template">Template ng App Profile</string>
    <string name="settings_profile_template_summary">Ipamahala ang lokal at online na template ng App Profile</string>
    <string name="app_profile_template_create">Gumawa ng template</string>
    <string name="app_profile_template_edit">I-edit ang template</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Hindi wastong template ID</string>
    <string name="app_profile_template_name">Pangalan</string>
    <string name="app_profile_template_description">Paksa</string>
    <string name="app_profile_template_save">I-save</string>
    <string name="app_profile_template_delete">Burahin</string>
    <string name="app_profile_template_view">Tignan ang template</string>
    <string name="app_profile_template_id_exist">Umiiral na ang Template ID!</string>
    <string name="app_profile_import_export">I-import/I-export</string>
    <string name="app_profile_import_from_clipboard">Mag-import mula sa clipboard</string>
    <string name="app_profile_export_to_clipboard">I-export sa clipboard</string>
    <string name="app_profile_template_export_empty">Hindi makahanap ng lokal na template na ie-export!</string>
    <string name="app_profile_template_import_success">Matagumpay na na-import</string>
    <string name="app_profile_template_save_failed">Nabigong i-save ang template</string>
    <string name="app_profile_template_import_empty">Walang laman ang clipboard!</string>
    <string name="settings_check_update">Tumingin para sa mga update</string>
    <string name="settings_check_update_summary">Awtomatikong tumingin para sa mga update kapag binubuksan ang app</string>
    <string name="grant_root_failed">Nabigong ibigay ang root!</string>
    <string name="action">Aksyon</string>
    <string name="open">Buksan</string>
    <string name="enable_web_debugging">I-enable ang pag-debug ng WebView</string>
    <string name="enable_web_debugging_summary">Maaaring gamitin para i-debug ang WebUI. Mangyaring paganahin kung kinakailangan lang.</string>
    <string name="direct_install">Direktang pag-install (Inirerekomenda)</string>
    <string name="select_file">Pumili ng file</string>
    <string name="install_inactive_slot">I-install sa hindi aktibong slot (Pagkatapos ng OTA)</string>
    <string name="install_inactive_slot_warning">Ang iyong device ay **PIPILITIN** na i-boot sa kasalukuyang hindi aktibong slot pagkatapos ng reboot!\nGamitin lamang ang opsyon na ito kung tapos na ang OTA.\nMagpatuloy?</string>
    <string name="install_next">Susunod</string>
    <string name="select_file_tip">Inirerekomenda ang %1$s partition image</string>
    <string name="select_kmi">Pumili ng KMI</string>
    <string name="settings_uninstall">I-uninstall</string>
    <string name="settings_uninstall_temporary">Pansamantalang i-uninstall</string>
    <string name="settings_uninstall_permanent">Permanenteng i-uninstall</string>
    <string name="settings_restore_stock_image">Ibalik ang stock image</string>
    <string name="settings_uninstall_temporary_message">Pansamantalang i-uninstall ang KernelSU, ibabalik sa orihinal na kalagayan pagkatapos ng susunod na reboot.</string>
    <string name="settings_uninstall_permanent_message">Ina-uninstall ang KernelSU (root at lahat ng mga module) nang tuluyan at permanente.</string>
    <string name="settings_restore_stock_image_message">Ibalik ang stock factory image (kung may umiiral na backup), kadalasan na ginagamit bago ng OTA; kung kailangan mong i-uninstall ang KernelSU, mangyaring gamitin ang \"Permanenteng i-uninstall\".</string>
    <string name="flashing">Nagfa-flash</string>
    <string name="flash_success">Matagumpay ang pag-flash</string>
    <string name="flash_failed">Nabigo ang pag-flash</string>
    <string name="selected_lkm">Piniling LKM: %s</string>
    <string name="log_saved">Nai-save ang mga log</string>
    <string name="settings_sucompat">Klasikong su command</string>
    <string name="settings_sucompat_summary">Payagan ang root access gamit ang /system/bin/su, sa mga bagong proseso.</string>
    <string name="module_repos">Mga Repo</string>
    <string name="module_repos_sort_name">Pangalan (A → Z)</string>
    <string name="module_repos_source_code">Source code</string>
    <string name="metamodule_uninstall_confirm">Sigurado ka ba gusto mong i-uninstall ang module na %s? Aapektuhan ng aksyon na ito ang lahat ng mga module, at hindi na gagana ang mga feature na ibinigay ng metamodule (tulad ng pag-mount).</string>
    <string name="safe_mode_module_disabled">Naka-disable sa safe mode ang pag-install ng mga module</string>
</resources>

```

`manager/app/src/main/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_not_installed">Non installé</string>
    <string name="home_working">Fonctionnel</string>
    <string name="home_working_version">Version : %d</string>
    <string name="home_unsupported_reason">KernelSU prend désormais en charge seulement les noyaux GKI, mais vous pouvez patcher l\'image pour les appareils GKI.</string>
    <string name="home_kernel">Version du noyau</string>
    <string name="home_fingerprint">Empreinte</string>
    <string name="home_selinux_status">Statut SELinux</string>
    <string name="selinux_status_disabled">Désactivé</string>
    <string name="selinux_status_permissive">Permissif (permissive)</string>
    <string name="selinux_status_unknown">Inconnu</string>
    <string name="superuser">Super-utilisateur</string>
    <string name="module_empty">Aucun module installé</string>
    <string name="home">Accueil</string>
    <string name="home_click_to_install">Appuyez pour installer</string>
    <string name="home_unsupported">Non pris en charge</string>
    <string name="module_uninstall_failed">Échec de la désinstallation : %s</string>
    <string name="module_version">Version</string>
    <string name="home_manager_version">Version du gestionnaire</string>
    <string name="selinux_status_enforcing">Imposition (enforcing)</string>
    <string name="module_failed_to_enable">Échec de l\'activation du module : %s</string>
    <string name="module">Module</string>
    <string name="uninstall">Désinstaller</string>
    <string name="module_install">Installer</string>
    <string name="module_failed_to_disable">Échec de la désactivation du module : %s</string>
    <string name="reboot">Redémarrer</string>
    <string name="install">Installer</string>
    <string name="settings">Paramètres</string>
    <string name="reboot_bootloader">Redémarrer vers le bootloader</string>
    <string name="reboot_userspace">Redémarrage logiciel</string>
    <string name="reboot_recovery">Redémarrer en mode Recovery</string>
    <string name="reboot_edl">Redémarrer en mode EDL</string>
    <string name="about">À propos</string>
    <string name="module_uninstall_success">%s désinstallé</string>
    <string name="reboot_download">Redémarrer en mode Download</string>
    <string name="module_author">Auteur</string>
    <string name="module_uninstall_confirm">Voulez-vous vraiment désinstaller le module %s ?</string>
    <string name="home_learn_kernelsu">Apprenez à utiliser KernelSU</string>
    <string name="show_system_apps">Afficher les applications système</string>
    <string name="safe_mode">Mode sans échec</string>
    <string name="send_log">Envoyer les journaux</string>
    <string name="reboot_to_apply">Redémarrez pour appliquer les modifications</string>
    <string name="module_magisk_conflict">Les modules sont indisponibles en raison d\'un conflit avec Magisk !</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_support_title">Soutenez-nous</string>
    <string name="home_click_to_learn_kernelsu">Découvrez comment installer KernelSU et utiliser les modules.</string>
    <string name="home_support_content">KernelSU est, et restera toujours, gratuit et open-source. Néanmoins, vous pouvez nous témoigner de votre soutien en nous faisant un don.</string>
    <string name="about_source_code"><![CDATA[Voir le code source à %1$s<br/>Rejoignez notre canal %2$s]]></string>
    <string name="profile_template">Modèle</string>
    <string name="profile_default">Par défaut</string>
    <string name="profile_custom">Personnalisé</string>
    <string name="profile_name">Nom du profil</string>
    <string name="profile_namespace">Espace de noms de montage</string>
    <string name="profile_namespace_inherited">Hérité</string>
    <string name="profile_namespace_individual">Individuel</string>
    <string name="profile_selinux_context">Contexte SELinux</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_groups">Groupes</string>
    <string name="profile_capabilities">Capacités</string>
    <string name="profile_umount_modules">Démonter les modules</string>
    <string name="failed_to_update_app_profile">Échec de la modification du profil d\'application pour %s</string>
    <string name="profile_umount_modules_summary">Activer cette option autorisera KernelSU à restaurer tous les fichiers de cette application qui ont été modifiés par les modules.</string>
    <string name="settings_umount_modules_default">Démonter par défaut les modules</string>
    <string name="settings_umount_modules_default_summary">Valeur globale par défaut pour l\'option \"Démonter les modules\" dans les profils d\'application. Lorsque l\'option est activée, les modifications apportées au système par les modules sont supprimées pour les applications qui n\'ont pas de profil défini.</string>
    <string name="profile_selinux_domain">Domaine</string>
    <string name="profile_selinux_rules">Règles</string>
    <string name="module_update">Mettre à jour</string>
    <string name="module_downloading">Téléchargement du module : %s</string>
    <string name="launch_app">Lancer</string>
    <string name="new_version_available">La nouvelle version %s est disponible, appuyez pour mettre à jour !</string>
    <string name="module_start_downloading">Début du téléchargement de : %s</string>
    <string name="force_stop_app">Forcer l\'arrêt</string>
    <string name="restart_app">Relancer l\'application</string>
    <string name="failed_to_update_sepolicy">Échec de la mise à jour des règles SELinux pour %s</string>
    <string name="require_kernel_version">La version actuelle de KernelSU (%1$d) est trop ancienne pour que le gestionnaire puisse fonctionner correctement. Veuillez passer à la version %2$d ou ultérieure.</string>
    <string name="app_profile_template_import_success">Importation réussie</string>
    <string name="app_profile_export_to_clipboard">Exporter vers le presse-papiers</string>
    <string name="app_profile_template_export_empty">Impossible de trouver un modèle local à exporter !</string>
    <string name="app_profile_template_id_exist">L\'ID du modèle existe déjà !</string>
    <string name="module_changelog">Historique</string>
    <string name="app_profile_import_from_clipboard">Importer à partir du presse-papiers</string>
    <string name="app_profile_template_name">Nom</string>
    <string name="app_profile_template_id_invalid">ID de modèle invalide</string>
    <string name="app_profile_template_create">Créez un modèle</string>
    <string name="app_profile_import_export">Importer/Exporter</string>
    <string name="app_profile_template_save_failed">Échec de l\'enregistrement du modèle</string>
    <string name="app_profile_template_edit">Modifier le modèle</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">Modèles de profils d\'application</string>
    <string name="app_profile_template_description">Description</string>
    <string name="app_profile_template_save">Enregistrer</string>
    <string name="settings_profile_template_summary">Gérez les modèles de profils d\'application locaux et en ligne.</string>
    <string name="app_profile_template_delete">Supprimer</string>
    <string name="app_profile_template_import_empty">Le presse-papiers est vide !</string>
    <string name="app_profile_template_view">Voir le modèle</string>
    <string name="settings_check_update_summary">Rechercher automatiquement des mises à jour à l\'ouverture de l\'application.</string>
    <string name="settings_check_update">Rechercher des mises à jour</string>
    <string name="enable_web_debugging">Débogage WebView</string>
    <string name="enable_web_debugging_summary">Peut être utilisé pour déboguer WebUI. Activez uniquement cette option si nécessaire.</string>
    <string name="grant_root_failed">Impossible d\'accorder les privilèges root !</string>
    <string name="open">Ouvrir</string>
    <string name="direct_install">Installation directe (recommandé)</string>
    <string name="select_file">Sélectionner un fichier</string>
    <string name="install_inactive_slot">Installer dans l\'emplacement inactif (après OTA)</string>
    <string name="install_inactive_slot_warning">Votre appareil sera **FORCÉ** à démarrer sur l\'emplacement inactif actuel après un redémarrage ! \nN\'utilisez cette option qu\'une fois la mise à jour OTA terminée. \nContinuer ?</string>
    <string name="install_next">Suivant</string>
    <string name="select_file_tip">L\'image de la partition %1$s est recommandée</string>
    <string name="select_kmi">Sélectionner une KMI</string>
    <string name="settings_uninstall">Désinstaller</string>
    <string name="settings_uninstall_temporary">Désinstaller temporairement</string>
    <string name="settings_uninstall_permanent">Désinstaller définitivement</string>
    <string name="settings_restore_stock_image">Restaurer l\'image d\'origine</string>
    <string name="settings_restore_stock_image_message">Restaurer l\'image d\'origine d\'usine (s\'il en existe une sauvegarde). Utilisé généralement avant une mise à jour OTA ; si vous devez désinstaller KernelSU, utilisez plutôt l\'option \"Désinstaller définitivement\".</string>
    <string name="flashing">Flash en cours</string>
    <string name="flash_success">Flash réussi</string>
    <string name="flash_failed">Échec du flash</string>
    <string name="selected_lkm">LKM sélectionné : %s</string>
    <string name="settings_uninstall_permanent_message">Désinstallation complète et permanente de KernelSU (root et tous les modules).</string>
    <string name="settings_uninstall_temporary_message">Désinstaller temporairement KernelSU, et rétablir l\'état original au redémarrage suivant.</string>
    <string name="save_log">Enregistrer les journaux</string>
    <string name="module_sort_action_first">Par action</string>
    <string name="module_sort_enabled_first">Par activation</string>
    <string name="action">Action</string>
    <string name="log_saved">Journaux enregistrés</string>
    <string name="module_install_prompt_with_name">Les modules suivants seront installés : %1$s</string>
    <string name="su_not_allowed">Impossible d\'accorder les autorisations superutilisateur à %s</string>
    <string name="confirm">Confirmer</string>
    <string name="install_upload_lkm_file">Utiliser un fichier LKM local</string>
    <string name="install_only_support_ko_file">Seuls les fichiers .ko sont pris en charge</string>
    <string name="processing">Traitement…</string>
    <string name="refresh_pulling">Tirez pour actualiser</string>
    <string name="refresh_release">Relâchez pour actualiser</string>
    <string name="refresh_refresh">Actualisation…</string>
    <string name="refresh_complete">Actualisé avec succès</string>
    <string name="settings_module_check_update">Rechercher des mises à jour des modules</string>
    <string name="settings_sucompat">Commande SU classique</string>
    <string name="settings_sucompat_summary">Permettre l\'accès root via /system/bin/su, dans les nouveaux processus.</string>
    <string name="settings_kernel_umount">Démonter les modules (niveau noyau)</string>
    <string name="settings_kernel_umount_summary">Démontez les modules noyau dans le profil d\'application.</string>
    <string name="install_select_partition">Sélectionner une partition</string>
    <string name="metamodule_uninstall_confirm">Voulez-vous vraiment désinstaller le module %s ? Cette action affectera tous les modules, et certaines fonctionnalités fournies par le métamodule (telles que le montage) ne fonctionneront plus.</string>
    <string name="app_profile_affects_following_apps">Affecte les applis suivantes</string>
    <string name="group_contains_apps">Contient %d applis</string>
    <string name="undo">Annuler</string>
    <string name="module_undo_uninstall_success">Désinstallation de %s annulée avec succès</string>
    <string name="module_undo_uninstall_failed">Échec de l\'annulation de la désinstallation : %s</string>
    <string name="settings_theme">Thème</string>
    <string name="settings_theme_summary">Choisissez le thème de l\'application.</string>
    <string name="settings_theme_mode_system">Suivre le système</string>
    <string name="settings_theme_mode_light">Clair</string>
    <string name="settings_theme_mode_dark">Sombre</string>
    <string name="settings_theme_mode_monet_system">Monet (suivre le système)</string>
    <string name="settings_theme_mode_monet_light">Monet (clair)</string>
    <string name="settings_theme_mode_monet_dark">Monet (sombre)</string>
    <string name="settings_key_color">Couleur clé</string>
    <string name="settings_key_color_summary">Personnalisez la couleur d\'accentuation Monet.</string>
    <string name="settings_key_color_default">Par défaut</string>
    <string name="color_blue">Bleu</string>
    <string name="color_red">Rouge</string>
    <string name="color_green">Vert</string>
    <string name="color_purple">Violet</string>
    <string name="color_orange">Orange</string>
    <string name="color_teal">Turquoise</string>
    <string name="color_pink">Rose</string>
    <string name="color_brown">Marron</string>
    <string name="feature_status_unsupported_summary">Le noyau ne prend pas en charge cette fonctionnalité</string>
    <string name="feature_status_managed_summary">Cette fonctionnalité est gérée par un module</string>
    <string name="module_repos">Dépôts</string>
    <string name="module_repos_sort_name">Nom (A → Z)</string>
    <string name="module_repos_source_code">Code source</string>
    <string name="home_gki_warning">À partir de la version 3.0.0, le mode de fonctionnement GKI sera utilisé uniquement dans les environnements de test. Nous vous le déconseillons pour une utilisation quotidienne, et les fichiers images ne seront plus fournis.</string>
    <string name="network_offline">Non connecté au réseau</string>
    <string name="network_retry">Réessayer</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">Versions</string>
    <string name="tab_info">Infos</string>
    <string name="safe_mode_module_disabled">L\'installation de modules est désactivée en mode sans échec</string>
    <string name="module_action_success">Action de module exécutée avec succès.</string>
    <string name="settings_mode_enable_by_default">Activer (par défaut)</string>
    <string name="settings_mode_disable_until_reboot">Désactiver jusqu\'au redémarrage</string>
    <string name="settings_mode_disable_always">Toujours désactiver</string>
    <string name="module_shortcut_title">Créer un raccourci</string>
    <string name="module_shortcut_name_label">Nom du raccourci</string>
    <string name="module_shortcut_icon_pick">Choisir une icône personnalisée</string>
    <string name="module_shortcut_add">Ajouter le raccourci</string>
    <string name="module_shortcut_not_supported">Le lanceur d\'application ne prend pas en charge les raccourcis.</string>
    <string name="module_shortcut_created">Raccourci créé sur le bureau.</string>
    <string name="module_shortcut_updated">Raccourci mis à jour.</string>
    <string name="module_shortcut_delete">Supprimer le raccourci</string>
    <string name="module_shortcut_type_title">Sélectionner un type</string>
    <string name="module_shortcut_permission_tip_xiaomi">Activez pour cette application l\'autorisation \"Créer des raccourcis de bureau\" dans les paramètres Xiaomi.</string>
    <string name="module_shortcut_permission_tip_oppo">Activez pour cette application l\'autorisation \"Raccourci de bureau\" dans les paramètres OPPO.</string>
    <string name="module_shortcut_permission_tip_default">Si la création du raccourci échoue, veuillez activer pour cette application l\'autorisation relative aux raccourcis de bureau dans les paramètres du système.</string>
    <string name="no_such_module">Le module %s n\'existe pas</string>
    <string name="module_unavailable">Le module %s est désactivé, en cours de mise à jour, ou en attente de suppression</string>
    <string name="select_file_tip_nogki">Sélectionnez le fichier image d\'appareil GKI que vous souhaitez patcher</string>
    <string name="current_kmi">Version KMI de cet appareil : %s</string>
    <string name="current_device_kmi">KMI de cet appareil</string>
</resources>

```

`manager/app/src/main/res/values-gl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Inicio</string>
    <string name="settings_sucompat">Redirixir o binario su</string>
    <string name="settings_sucompat_summary">Permite que as aplicacións con permiso de Superusuario no perfil da aplicación obteñan un shell de superusuario executando /system/bin/su; efectivo só para novos procesos.</string>
    <string name="settings_kernel_umount">Desmontar núcleo</string>
    <string name="settings_kernel_umount_summary">Comportamento de desmontaxe a nivel de núcleo controlado por KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-hi/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="reboot_to_apply">प्रभाव में होने के लिए रीबूट करें</string>
    <string name="home_click_to_learn_kernelsu">जानें कि KernelSU कैसे स्थापित करें और मॉड्यूल का उपयोग कैसे करें</string>
    <string name="selinux_status_unknown">अज्ञात</string>
    <string name="show_system_apps">सिस्टम एप्प दिखाए</string>
    <string name="module_uninstall_success">%s अनइंस्टॉल सफल हुआ</string>
    <string name="profile_umount_modules">मॉड्यूल्स अनमाउंट करें</string>
    <string name="send_log">लॉग भेजे</string>
    <string name="selinux_status_disabled">डिसेबल्ड (बंद)</string>
    <string name="home_support_title">हमें प्रोत्साहन दें</string>
    <string name="profile_namespace_inherited">Inherited</string>
    <string name="module_magisk_conflict">मॉड्यूल बंद कर दिए गए हैं क्योंकि यह मैजिक के साथ टकरा रहे है!</string>
    <string name="module_changelog">क्या बदलाव हुए है</string>
    <string name="selinux_status_permissive">पर्मिसिव</string>
    <string name="reboot_download">डाउनलोड में रिबूट करें</string>
    <string name="settings_umount_modules_default">डिफ़ॉल्ट रूप से मॉड्यूल अनमाउन्ट करें</string>
    <string name="profile_umount_modules_summary">इस विकल्प को चालू करने से KernelSU को इस एप्लिकेशन के लिए मॉड्यूल द्वारा किसी भी मोडिफाइड फ़ाइल को रिस्टोर करें।</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="module_failed_to_enable">%s मॉड्यूल चालू करने में विफल</string>
    <string name="force_stop_app">जबर्दस्ती बंद करें</string>
    <string name="reboot_edl">EDL मोड में रिबूट करें</string>
    <string name="restart_app">फिर से चालू करें</string>
    <string name="profile_capabilities">क्षमताएं</string>
    <string name="module_start_downloading">%s की डाउनलोडिंग स्टार्ट करें</string>
    <string name="profile_namespace_global">Global</string>
    <string name="settings_umount_modules_default_summary">ऐप प्रोफाइल में \"अनमाउंट मॉड्यूल\" के लिए ग्लोबल डिफ़ॉल्ट वैल्यू। यदि चालू किया गया है, तो यह एप्लीकेशंस के लिऐ सिस्टम के सभी मॉड्यूल मोडिफिकेशन को हटा देगा जिनकी प्रोफ़ाइल सेट नहीं है।</string>
    <string name="selinux_status_enforcing">एनफोर्सिंग</string>
    <string name="profile_selinux_context">SELinux context</string>
    <string name="home_fingerprint">फिंगरप्रिंट</string>
    <string name="profile_default">डिफॉल्ट</string>
    <string name="launch_app">लॉन्च करें</string>
    <string name="safe_mode">सेफ मोड</string>
    <string name="require_kernel_version">मैनेजर के ठीक से काम करने के लिए वर्तमान KernelSU वर्जन %1$d बहुत कम है। कृपया वर्जन %2$d या उच्चतर में अपग्रेड करें!</string>
    <string name="reboot_recovery">रिकवरी में रिबूट करें</string>
    <string name="reboot_userspace">सॉफ्ट रिबूट</string>
    <string name="profile_name">प्रोफाइल का नाम</string>
    <string name="home_support_content">KernelSU मुफ़्त और ओपन सोर्स और हमेशा रहेगा। हालाँकि आप दान देकर हमें दिखा सकते हैं कि आप संरक्षण करते हैं।</string>
    <string name="uninstall">अनइंस्टॉल करें</string>
    <string name="profile_namespace">Namspace माउंट करें</string>
    <string name="module_install">इंस्टाल करें</string>
    <string name="home_click_to_install">इंस्टाल करने के लिए क्लिक करें</string>
    <string name="profile_selinux_rules">नियम</string>
    <string name="profile_groups">समूह</string>
    <string name="module">मॉड्यूल</string>
    <string name="module_author">निर्माता</string>
    <string name="about">हमारे बारे में</string>
    <string name="home_working_version">वर्जन: %d</string>
    <string name="reboot">रीबूट करें</string>
    <string name="home_unsupported_reason">KernelSU अभी केवल GKI कर्नल्स को सपोर्ट करता है</string>
    <string name="home_selinux_status">SELinux स्थिति</string>
    <string name="module_version">वर्जन</string>
    <string name="home_unsupported">सपोर्ट नहीं करता है</string>
    <string name="profile_selinux_domain">डोमेन</string>
    <string name="home">होम</string>
    <string name="profile_custom">कस्टम</string>
    <string name="profile_template">टेम्पलेट</string>
    <string name="module_downloading">%s मॉड्यूल डाउनलोड हो रहा है</string>
    <string name="module_update">अपडेट</string>
    <string name="home_learn_kernelsu">KernelSU सीखें</string>
    <string name="module_uninstall_confirm">क्या आप सच में मॉड्यूल %s को अनइंस्टॉल करना चाहते हैं\?</string>
    <string name="module_uninstall_failed">%s अनइंस्टल करने में असफल</string>
    <string name="superuser">सुपरयूजर</string>
    <string name="settings">सेटिंग</string>
    <string name="home_working">काम कर रहा है</string>
    <string name="module_failed_to_disable">%s मॉड्यूल बंद करने में विफल</string>
    <string name="module_empty">कोई मॉड्यूल इंस्टाल नहीं हुआ</string>
    <string name="install">इंस्टाल करें</string>
    <string name="home_kernel">कर्नल</string>
    <string name="home_not_installed">इंस्टाल नहीं हुआ</string>
    <string name="failed_to_update_app_profile">%s के लिए ऐप प्रोफ़ाइल अपडेट करने में विफल</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="failed_to_update_sepolicy">%s के लिए SELinux नियमों को अपटेड करने में विफल</string>
    <string name="reboot_bootloader">बुटलोडर में रिबूट करें</string>
    <string name="about_source_code">%1$s पर स्रोत कोड देखें<br/>
हमारे %2$s चैनल से जुड़ें</string>
    <string name="home_manager_version">मैनेजर वर्जन</string>
    <string name="new_version_available">नया वर्जन: %s उपलब्ध है,अपग्रेड के लिए क्लिक करें</string>
    <string name="save_log">लॉग सहेजें</string>
    <string name="settings_sucompat">su बाइनरी को फिर से रूट करें</string>
    <string name="settings_sucompat_summary">ऐप प्रोफ़ाइल में सुपरयूज़र अनुमति दिए गए ऐप्स को /system/bin/su को निष्पादित करके सुपरयूज़र शेल प्राप्त करने की अनुमति देता है; केवल नई प्रक्रियाओं के लिए प्रभावी।</string>
    <string name="settings_kernel_umount">कर्नेल अनमाउंट</string>
    <string name="settings_kernel_umount_summary">KernelSU द्वारा नियंत्रित कर्नेल-स्तरीय अनमाउंट व्यवहार</string>
</resources>

```

`manager/app/src/main/res/values-hr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="show_system_apps">Prikažite sistemske aplikacije</string>
    <string name="send_log">Pošaljite izvještaje</string>
    <string name="safe_mode">Sigurnosni mod</string>
    <string name="reboot_to_apply">Ponovno pokrenite da bi proradilo</string>
    <string name="failed_to_update_sepolicy">Nije uspjelo ažuriranje SELinux pravila za %s</string>
    <string name="home">Početna</string>
    <string name="home_not_installed">Nije instalirano</string>
    <string name="home_working_version">Verzija: %d</string>
    <string name="home_click_to_install">Kliknite da instalirate</string>
    <string name="home_working">Radi</string>
    <string name="home_unsupported">Nepodržano</string>
    <string name="home_unsupported_reason">KernelSU sada samo podržava GKI kernele.</string>
    <string name="home_kernel">Verzija kernela</string>
    <string name="home_manager_version">Verzija voditelja</string>
    <string name="home_fingerprint">Otisak prsta</string>
    <string name="selinux_status_disabled">Isključeno</string>
    <string name="selinux_status_enforcing">U Provođenju</string>
    <string name="selinux_status_permissive">Permisivno</string>
    <string name="home_selinux_status">SELinux stanje</string>
    <string name="selinux_status_unknown">Nepoznato</string>
    <string name="superuser">Superkorisnik</string>
    <string name="module_failed_to_enable">Neuspješno uključivanje module: %s</string>
    <string name="module_failed_to_disable">Neuspješno isključivanje module: %s</string>
    <string name="module_empty">Nema instaliranih modula</string>
    <string name="module">Br. modula</string>
    <string name="uninstall">Deinstalirajte</string>
    <string name="module_install">Instalirajte</string>
    <string name="install">Instalirajte</string>
    <string name="reboot">Ponovno pokrenite</string>
    <string name="settings">Postavke</string>
    <string name="reboot_userspace">Lagano ponovno pokretanje</string>
    <string name="reboot_recovery">Ponovno pokrenite u Oporavu</string>
    <string name="reboot_bootloader">Ponovno pokrenite u Pogonski Učitavalac</string>
    <string name="reboot_download">Ponovno pokrenite u Preuzimanje</string>
    <string name="reboot_edl">Ponovo pokrenite u EDL</string>
    <string name="about">O</string>
    <string name="module_uninstall_confirm">Jeste li sigurni da želite deinstalirati modulu %s\?</string>
    <string name="module_uninstall_success">%s deinstalirana</string>
    <string name="module_uninstall_failed">Neuspješna deinstalacija: %s</string>
    <string name="module_version">Verzija</string>
    <string name="module_author">Autor</string>
    <string name="module_magisk_conflict">Module su isključene jer je u sukobu sa Magisk-om!</string>
    <string name="home_learn_kernelsu">Naučite KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Naučite kako da instalirate KernelSU i da koristite module.</string>
    <string name="home_support_title">Podržite Nas</string>
    <string name="home_support_content">KernelSU je i uvijek će biti besplatan i otvorenog koda. Međutim, možete nam pokazati da vam je stalo donacijom.</string>
    <string name="about_source_code"><![CDATA[Pogledajte izvor na %1$s<br/>Pridružite se našem %2$s kanalu]]></string>
    <string name="profile_default">Zadano</string>
    <string name="profile_template">Šablon</string>
    <string name="profile_custom">Prilagođeno</string>
    <string name="profile_name">Naziv profila</string>
    <string name="profile_namespace_inherited">Naslijeđen</string>
    <string name="profile_namespace">Imenski prostor nosača</string>
    <string name="failed_to_update_app_profile">Ažuriranje Profila Aplikacije za %s nije uspjelo</string>
    <string name="profile_namespace_global">Globalan</string>
    <string name="profile_namespace_individual">Pojedinačan</string>
    <string name="profile_umount_modules">Umount module</string>
    <string name="profile_groups">Grupe</string>
    <string name="profile_capabilities">Sposobnosti</string>
    <string name="profile_selinux_context">SELinux kontekst</string>
    <string name="require_kernel_version">Trenutna verzija KernelSU-a %1$d je preniska da bi upravitelj ispravno radio. Molimo vas da nadogradite na verziju %2$d ili noviju!</string>
    <string name="settings_umount_modules_default">Umontiraj module prema zadanim postavkama</string>
    <string name="settings_umount_modules_default_summary">Globalna zadana vrijednost za \"Umontiraj module\" u profilu aplikacije. Ako je omogućeno, uklonit će sve modifikacije modula sustava za aplikacije koje nemaju postavljen profil.</string>
    <string name="profile_selinux_domain">Domena</string>
    <string name="profile_umount_modules_summary">Omogućavanje ove opcije omogućit će KernelSU-u da vrati sve izmijenjene datoteke od strane modula za ovu aplikaciju.</string>
    <string name="profile_selinux_rules">Pravila</string>
    <string name="module_update">Ažuriranje</string>
    <string name="module_downloading">Preuzimanje module: %s</string>
    <string name="module_start_downloading">Započnite sa preuzimanjem: %s</string>
    <string name="new_version_available">Nova verzija %s je dostupna, kliknite za nadogradnju!</string>
    <string name="launch_app">Pokrenite</string>
    <string name="force_stop_app">Prisilno zaustavi</string>
    <string name="restart_app">Resetujte</string>
    <string name="save_log">Spremi zapise</string>
    <string name="module_install_prompt_with_name">Sljedeći moduli će biti instalirani: %1$s</string>
    <string name="module_sort_action_first">Prvo radnja</string>
    <string name="module_sort_enabled_first">Prvo omogućeno</string>
    <string name="confirm">Potvrdi</string>
    <string name="settings_profile_template">Predložak profila aplikacije</string>
    <string name="settings_profile_template_summary">Upravljanje lokalnim i online predloškom profila aplikacije.</string>
    <string name="app_profile_template_create">Izradi predložak</string>
    <string name="app_profile_template_edit">Uredi predložak</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Nevažeći ID predloška</string>
    <string name="app_profile_template_name">Naziv</string>
    <string name="app_profile_template_description">Opis</string>
    <string name="app_profile_template_save">Spremi</string>
    <string name="app_profile_template_delete">Izbriši</string>
    <string name="app_profile_template_view">Prikaži predložak</string>
    <string name="app_profile_template_id_exist">ID predloška već postoji!</string>
    <string name="app_profile_import_export">Uvoz/Izvoz</string>
    <string name="app_profile_import_from_clipboard">Uvezi iz međuspremnika</string>
    <string name="app_profile_export_to_clipboard">Izvezi u međuspremnik</string>
    <string name="app_profile_template_export_empty">Nije moguće pronaći lokalni predložak za izvoz!</string>
    <string name="app_profile_template_import_success">Uspješno uvezeno</string>
    <string name="app_profile_template_save_failed">Spremanje predloška nije uspjelo</string>
    <string name="app_profile_template_import_empty">Međuspremnik je prazan!</string>
    <string name="settings_check_update">Provjeri za ažuriranja</string>
    <string name="settings_check_update_summary">Automatski provjeri za ažuriranja prilikom otvaranja aplikacije.</string>
    <string name="grant_root_failed">Dodjeljivanje root pristupa nije uspjelo!</string>
    <string name="action">Radnja</string>
    <string name="open">Otvori</string>
    <string name="enable_web_debugging">WebView otklanjanje pogrešaka</string>
    <string name="enable_web_debugging_summary">Može se koristiti za otklanjanje pogrešaka u WebUI-ju. Omogućite samo kada je potrebno.</string>
    <string name="direct_install">Izravna instalacija (preporučeno)</string>
    <string name="select_file">Odaberite datoteku</string>
    <string name="install_inactive_slot">Instaliraj u neaktivni utor (nakon OTA)</string>
    <string name="install_inactive_slot_warning">Vaš će uređaj biti **PRISILNO** pokrenuti se u trenutno neaktivni utor nakon ponovnog pokretanja!\nKoristite ovu opciju tek nakon što je OTA završen.\nNastaviti?</string>
    <string name="install_next">Dalje</string>
    <string name="install_upload_lkm_file">Koristi lokalnu LKM datoteku</string>
    <string name="install_only_support_ko_file">Podržane su samo .ko datoteke</string>
    <string name="select_file_tip">Preporučuje se particija %1$s</string>
    <string name="select_kmi">Odaberi KMI</string>
    <string name="settings_uninstall">Deinstaliraj</string>
    <string name="settings_uninstall_temporary">Privremeno deinstaliraj</string>
    <string name="settings_uninstall_permanent">Trajno deinstaliraj</string>
    <string name="settings_restore_stock_image">Vrati stock image</string>
    <string name="settings_uninstall_temporary_message">Privremeno deinstaliraj KernelSU, vrati u izvorno stanje nakon sljedećeg ponovnog pokretanja.</string>
    <string name="settings_uninstall_permanent_message">Potpuno i trajno deinstaliranje KernelSU-a (root i svi moduli).</string>
    <string name="settings_restore_stock_image_message">Vrati stock factory image (ako postoji sigurnosna kopija), obično se koristi prije OTA-e; ako trebate deinstalirati KernelSU, koristite \"Trajno deinstaliraj\".</string>
    <string name="flashing">Flešanje</string>
    <string name="flash_success">Uspješno flešano</string>
    <string name="flash_failed">Neuspješno flešanje</string>
    <string name="selected_lkm">Odabrani LKM: %s</string>
    <string name="log_saved">Zapisi spremljeni</string>
    <string name="processing">Obrada…</string>
    <string name="refresh_pulling">Povuci dolje za osvježiti</string>
    <string name="refresh_release">Otpusti za osvježiti</string>
    <string name="refresh_refresh">Osvježavanje…</string>
    <string name="refresh_complete">Uspješno osvježeno</string>
    <string name="su_not_allowed">Nije moguće odobriti Superuser pristup za %s</string>
    <string name="module_changelog">Zapis promjena</string>
    <string name="metamodule_uninstall_confirm">Jeste li sigurni da želite deinstalirati modul %s? Ova radnja će utjecati na sve module, a određene značajke koje pruža metamodul (poput montiranja) više neće raditi.</string>
    <string name="app_profile_affects_following_apps">Utječe na sljedeće aplikacije</string>
    <string name="settings_module_check_update">Provjerite ažuriranja modula</string>
    <string name="install_select_partition">Odaberite particiju</string>
    <string name="feature_status_unsupported_summary">Kernel ne podržava ovu značajku.</string>
    <string name="feature_status_managed_summary">Ovom značajkom upravlja modul.</string>
    <string name="settings_sucompat">Preusmjeri su binarnu datoteku</string>
    <string name="settings_sucompat_summary">Omogućava aplikacijama kojima je dodijeljeno dopuštenje Superuser u Profilu aplikacije da dobiju superuser shell izvršavanjem /system/bin/su; učinkovito samo za nove procese.</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">Ponašanje umount na razini kernela koje kontrolira KernelSU</string>
    <string name="undo">Poništi</string>
    <string name="module_undo_uninstall_success">Deinstalacija %s uspješno otkazana</string>
    <string name="module_undo_uninstall_failed">Poništavanje deinstalacije nije uspjelo: %s</string>
    <string name="group_contains_apps">Sadrži %d aplikacija</string>
    <string name="settings_theme">Tema</string>
    <string name="settings_theme_summary">Odaberite temu aplikacije.</string>
    <string name="settings_theme_mode_system">Prati sustav</string>
    <string name="settings_theme_mode_light">Svijetla</string>
    <string name="settings_theme_mode_dark">Tamna</string>
    <string name="settings_theme_mode_monet_system">Monet (Prati sustav)</string>
    <string name="settings_theme_mode_monet_light">Monet (Svijetla)</string>
    <string name="settings_theme_mode_monet_dark">Monet (Tamna)</string>
    <string name="settings_key_color">Boja ključa</string>
    <string name="settings_key_color_summary">Prilagodi naglasak prilikom korištenja Moneta.</string>
    <string name="settings_key_color_default">Zadano</string>
    <string name="color_blue">Plava</string>
    <string name="color_red">Crvena</string>
    <string name="color_green">Zelena</string>
    <string name="color_purple">Ljubičasta</string>
    <string name="color_orange">Narančasta</string>
    <string name="color_teal">Tirkizna</string>
    <string name="color_pink">Ružičasta</string>
    <string name="color_brown">Smeđa</string>
    <string name="module_repos">Repozitoriji</string>
    <string name="module_repos_sort_name">Naziv (A → Z)</string>
    <string name="module_repos_source_code">Izvorni kod</string>
    <string name="safe_mode_module_disabled">Instalacija modula je onemogućena u sigurnom načinu rada</string>
    <string name="home_gki_warning">Počevši od verzije 3.0.0, GKI način rada koristit će se samo u testnim okruženjima. Ne preporučujemo ga za svakodnevnu upotrebu, a image datoteke više neće biti dostupne.</string>
    <string name="network_offline">Nije povezano s mrežom</string>
    <string name="network_retry">Pokušaj ponovno</string>
    <string name="tab_readme">PROČITAJ ME</string>
    <string name="tab_releases">Izdanja</string>
    <string name="tab_info">Info</string>
</resources>

```

`manager/app/src/main/res/values-hu/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_working">Működik</string>
    <string name="home_working_version">Verzió: %d</string>
    <string name="home_unsupported_reason">A KernelSU jelenleg csak GKI kerneleket támogat</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Alkalmazás verziója</string>
    <string name="home_fingerprint">Ujjlenyomat</string>
    <string name="selinux_status_disabled">Letiltva</string>
    <string name="reboot_download">Újraindítás letöltő módba</string>
    <string name="reboot_edl">Újraindítás EDL-be</string>
    <string name="about">Névjegy</string>
    <string name="module_uninstall_confirm">Biztos benne hogy eltávolítja a következő modult: %s?</string>
    <string name="module_uninstall_failed">Nem sikerült eltávolítani: %s</string>
    <string name="module_author">Készítő</string>
    <string name="show_system_apps">Rendszeralkalmazások megjelenítése</string>
    <string name="safe_mode">Biztonságos mód</string>
    <string name="module_magisk_conflict">A modulok nem érhetők el a Magiskkel való ütközés miatt!</string>
    <string name="home_learn_kernelsu">Tudjon meg többet a KernelSU-ról</string>
    <string name="home_click_to_learn_kernelsu">Ismerje meg a KernelSU telepítését és a modulok használatát</string>
    <string name="home_support_title">Támogasson minket</string>
    <string name="about_source_code">Tekintse meg a forráskódot a %1$s-on<br/>
Csatlakozzon a %2$s csatornánkhoz</string>
    <string name="profile_default">Alapértelmezett</string>
    <string name="profile_template">Sablon</string>
    <string name="profile_custom">Egyedi</string>
    <string name="profile_name">Profil neve</string>
    <string name="profile_namespace">Névtér csatlakoztatása</string>
    <string name="profile_namespace_inherited">Örökölt</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="profile_namespace_individual">Különálló</string>
    <string name="profile_groups">Csoportok</string>
    <string name="profile_capabilities">Jogosultságok</string>
    <string name="profile_selinux_context">SELinux kontextus</string>
    <string name="settings_umount_modules_default">Modulok leválasztása alapértelmezetten</string>
    <string name="profile_umount_modules_summary">Ha engedélyezi ezt az opciót, a KernelSU visszaállíthatja az alkalmazás moduljai által módosított fájlokat.</string>
    <string name="profile_selinux_domain">Tartomány</string>
    <string name="profile_selinux_rules">Szabályok</string>
    <string name="module_update">Frissítés</string>
    <string name="module_downloading">Modul letöltése: %s</string>
    <string name="module_start_downloading">Letöltés indítása: %s</string>
    <string name="launch_app">Indítás</string>
    <string name="force_stop_app">Kényszerített leállítás</string>
    <string name="restart_app">újraindítás</string>
    <string name="home">Kezdőlap</string>
    <string name="home_not_installed">Nincs telepítve</string>
    <string name="home_click_to_install">Kattintson a telepítéshez</string>
    <string name="home_unsupported">Nem támogatott</string>
    <string name="home_selinux_status">SELinux állapot</string>
    <string name="selinux_status_enforcing">Kényszerített</string>
    <string name="selinux_status_permissive">Engedélyezett</string>
    <string name="selinux_status_unknown">Ismeretlen</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Nem sikerült engedélyezni a következő modult: %s</string>
    <string name="module_failed_to_disable">Nem sikerült letiltani a következő modult: %s</string>
    <string name="module_empty">Nincs telepített modul</string>
    <string name="module">Modulok</string>
    <string name="uninstall">Eltávolítás</string>
    <string name="module_install">Telepítés</string>
    <string name="install">Telepítés</string>
    <string name="reboot">Újraindítás</string>
    <string name="settings">Beállítások</string>
    <string name="reboot_userspace">Rendszerfelület újraindítása</string>
    <string name="reboot_recovery">Újraindítás recovery-módba</string>
    <string name="reboot_bootloader">Újraindítás bootloader-módba</string>
    <string name="module_uninstall_success">%s eltávolítva</string>
    <string name="module_version">Verzió</string>
    <string name="send_log">Naplók küldése</string>
    <string name="reboot_to_apply">Indítsa újra a készüléket a változások érvényesítéséhez</string>
    <string name="home_support_content">A KernelSU ingyenes, nyílt forráskódú és mindig is az lesz. Ön azonban adományozással megmutathatja, hogy törődik a projekttel.</string>
    <string name="profile_namespace_global">Globális</string>
    <string name="profile_umount_modules">Modulok leválasztása</string>
    <string name="failed_to_update_app_profile">Nem sikerült frissíteni az App Profilt ehhez: %s</string>
    <string name="settings_umount_modules_default_summary">A \"Modulok leválasztása\" globális alapértelmezett értéke az App Profile-ban. Ha engedélyezve van, eltávolít minden modulmódosítást a rendszerből azon alkalmazások esetében, amelyeknek nincs profilja beállítva.</string>
    <string name="new_version_available">Elérhető az új, %s verzió, kattintson a frissítéshez.</string>
    <string name="failed_to_update_sepolicy">Nem sikerült frissíteni az SELinux szabályokat a következőhöz: %s</string>
    <string name="require_kernel_version">A jelenlegi KernelSU verzió %1$d túlságosan elavult a megfelelő működéshez. Kérjük frissítsen a %2$d verzióra vagy újabbra!</string>
    <string name="app_profile_template_import_success">Sikeresen importálva</string>
    <string name="app_profile_export_to_clipboard">Exportálás a vágólapról</string>
    <string name="app_profile_template_export_empty">Nem található helyi sablon az exportáláshoz!</string>
    <string name="app_profile_template_id_exist">A sablon ID már létezik!</string>
    <string name="module_changelog">Változások</string>
    <string name="app_profile_import_from_clipboard">Importálás a vágólapról</string>
    <string name="app_profile_template_name">Név</string>
    <string name="app_profile_template_id_invalid">Hibás sablon ID</string>
    <string name="app_profile_template_create">Sablon készítése</string>
    <string name="app_profile_import_export">Import/Export</string>
    <string name="app_profile_template_save_failed">A sablon mentése sikertelen</string>
    <string name="app_profile_template_edit">Sablon szerkesztése</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">App Profile sablon</string>
    <string name="app_profile_template_description">Leírás</string>
    <string name="app_profile_template_save">Mentés</string>
    <string name="settings_profile_template_summary">Az App Profile helyi és online sablonjának kezelése</string>
    <string name="app_profile_template_delete">Törlés</string>
    <string name="app_profile_template_import_empty">A vágólap üres!</string>
    <string name="app_profile_template_view">Sablon megtekintése</string>
    <string name="save_log">Naplók mentése</string>
    <string name="enable_web_debugging_summary">A WebUI hibakeresésére használható, csak szükség esetén engedélyezze.</string>
    <string name="enable_web_debugging">WebView hibakeresés engedélyezése</string>
    <string name="open">Megnyitás</string>
    <string name="settings_uninstall_permanent">Végleges eltávolítás</string>
    <string name="select_file_tip">%1$s partíció képfájl ajánlott</string>
    <string name="select_kmi">KMI kiválasztása</string>
    <string name="install_next">Következő</string>
    <string name="settings_uninstall_temporary">Ideiglenes eltávolítás</string>
    <string name="settings_uninstall_temporary_message">A KernelSU ideiglenes eltávolítása, az eredeti állapot visszaállítása a következő újraindítás után.</string>
    <string name="settings_uninstall">Eltávolítás</string>
    <string name="flashing">Telepítés</string>
    <string name="flash_success">Sikeres telepítés</string>
    <string name="selected_lkm">Kiválasztott LKM: %s</string>
    <string name="flash_failed">Sikertelen telepítés</string>
    <string name="grant_root_failed">A root jog megadása sikertelen!</string>
    <string name="install_inactive_slot">Telepítés inaktív helyre (OTA után)</string>
    <string name="select_file">Fájl kiválasztása</string>
    <string name="settings_uninstall_permanent_message">A KernelSU eltávolítása (root és az összes modul) teljesen és véglegesen.</string>
    <string name="settings_restore_stock_image">Eredeti képfájl visszaállítása</string>
    <string name="action">Művelet</string>
    <string name="direct_install">Közvetlen telepítés (Ajánlott)</string>
    <string name="install_inactive_slot_warning">Az eszköze **KÉNYSZERÍTETTEN** a jelenleg inaktív helyről fog indulni újraindítás után!\nCsak az OTA befejezése után használja.\nFolytatja?</string>
    <string name="settings_restore_stock_image_message">Állítsa vissza a gyári képfájlt (ha létezik biztonsági mentés). Általában OTA előtt használják. Ha a KernelSU-t szeretné eltávolítani, használja a végleges eltávolítás opciót.</string>
    <string name="settings_check_update">Frissítés ellenőrzése</string>
    <string name="settings_check_update_summary">Automatikusan keressen frissítéseket az alkalmazás megnyitásakor</string>
    <string name="log_saved">Mentett naplók</string>
    <string name="settings_sucompat">su bináris átirányítása</string>
    <string name="settings_sucompat_summary">Lehetővé teszi az App Profile-ban Superuser engedéllyel rendelkező alkalmazások számára, hogy superuser shell-t kapjanak a /system/bin/su végrehajtásával; csak új folyamatoknál hatékony.</string>
    <string name="settings_kernel_umount">Kernel leválasztása</string>
    <string name="settings_kernel_umount_summary">KernelSU által vezérelt kernel szintű leválasztási viselkedés</string>
</resources>

```

`manager/app/src/main/res/values-in/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Beranda</string>
    <string name="home_not_installed">Tidak terpasang</string>
    <string name="home_click_to_install">Ketuk untuk memasang</string>
    <string name="home_working">Berfungsi</string>
    <string name="home_working_version">Versi: %d</string>
    <string name="home_unsupported">Tidak didukung</string>
    <string name="home_unsupported_reason">KernelSU sekarang hanya mendukung kernel GKI, tetapi Anda dapat menambal image untuk perangkat GKI.</string>
    <string name="home_kernel">Versi kernel</string>
    <string name="home_manager_version">Versi manajer</string>
    <string name="home_fingerprint">Identitas</string>
    <string name="home_selinux_status">Status SELinux</string>
    <string name="selinux_status_disabled">Dinonaktifkan</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permisif</string>
    <string name="selinux_status_unknown">Tidak diketahui</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Gagal mengaktifkan modul: %s</string>
    <string name="module_failed_to_disable">Gagal menonaktifkan modul: %s</string>
    <string name="module_empty">Tidak ada modul yang terpasang</string>
    <string name="module">Modul</string>
    <string name="uninstall">Hapus</string>
    <string name="module_install">Pasang</string>
    <string name="install">Pasang</string>
    <string name="reboot">Reboot</string>
    <string name="settings">Setelan</string>
    <string name="reboot_userspace">Reboot secara halus</string>
    <string name="reboot_recovery">Reboot ke Recovery</string>
    <string name="reboot_bootloader">Reboot ke Bootloader</string>
    <string name="reboot_download">Reboot ke Download</string>
    <string name="reboot_edl">Reboot ke EDL</string>
    <string name="about">Tentang</string>
    <string name="module_uninstall_confirm">Yakin ingin menghapus modul %s?</string>
    <string name="module_uninstall_success">%s berhasil dihapus</string>
    <string name="module_uninstall_failed">Gagal menghapus: %s</string>
    <string name="module_version">Versi</string>
    <string name="module_author">Oleh</string>
    <string name="show_system_apps">Tampilkan apl sistem</string>
    <string name="send_log">Kirim Log</string>
    <string name="safe_mode">Mode aman</string>
    <string name="reboot_to_apply">Reboot agar berfungsi</string>
    <string name="module_magisk_conflict">Modul tidak tersedia karena konflik dengan Magisk!</string>
    <string name="home_learn_kernelsu">Pelajari KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/id_ID/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Pelajari cara memasang KernelSU dan menggunakan modul.</string>
    <string name="home_support_title">Dukung Kami</string>
    <string name="home_support_content">KernelSU akan selalu menjadi aplikasi gratis dan terbuka. Anda dapat memberikan donasi sebagai bentuk dukungan.</string>
    <string name="about_source_code"><![CDATA[Lihat sumber kode di %1$s<br/>Gabung saluran %2$s kami]]></string>
    <string name="profile">Profil Apl</string>
    <string name="profile_default">Default</string>
    <string name="profile_template">Templat</string>
    <string name="profile_custom">Khusus</string>
    <string name="profile_name">Nama profil</string>
    <string name="profile_namespace">Mount namespace</string>
    <string name="profile_namespace_inherited">Diwariskan</string>
    <string name="profile_namespace_global">Universal</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Kelompok</string>
    <string name="profile_capabilities">Kemampuan</string>
    <string name="profile_selinux_context">Konteks SELinux</string>
    <string name="profile_umount_modules">Umount modul</string>
    <string name="failed_to_update_app_profile">Gagal memperbarui Profil Apl untuk %s</string>
    <string name="settings_umount_modules_default">Umount modul secara default</string>
    <string name="settings_umount_modules_default_summary">Nilai default universal untuk \"Umount modul\" pada Profil Aplikasi. Jika diaktifkan, akan menghapus semua modifikasi sistem untuk aplikasi yang tidak memiliki set profil.</string>
    <string name="profile_umount_modules_summary">Aktifkan opsi ini agar KernelSU dapat memulihkan kembali berkas termodifikasi oleh modul pada aplikasi ini.</string>
    <string name="profile_selinux_domain">Domain</string>
    <string name="profile_selinux_rules">Aturan</string>
    <string name="module_update">Perbarui</string>
    <string name="module_downloading">Mengunduh modul: %s</string>
    <string name="module_start_downloading">Mulai mengunduh: %s</string>
    <string name="new_version_available">Versi baru %s tersedia, klik untuk memperbarui!</string>
    <string name="launch_app">Luncurkan</string>
    <string name="force_stop_app">Paksa berhenti</string>
    <string name="restart_app">Mulai ulang apl</string>
    <string name="failed_to_update_sepolicy">Gagal memperbarui aturan SELinux untuk %s</string>
    <string name="require_kernel_version">Versi KernelSU saat ini %1$d terlalu rendah untuk manajer berfungsi normal. Harap memperbarui ke versi %2$d atau di atasnya!</string>
    <string name="module_changelog">Catatan perubahan</string>
    <string name="app_profile_template_import_success">Berhasil diimpor</string>
    <string name="app_profile_export_to_clipboard">Ekspor ke papan klip</string>
    <string name="app_profile_template_export_empty">Tidak ditemukan templat lokal untuk diekspor!</string>
    <string name="app_profile_template_id_exist">ID templat sudah ada!</string>
    <string name="app_profile_import_from_clipboard">Impor dari papan klip</string>
    <string name="app_profile_template_name">Nama</string>
    <string name="app_profile_template_id_invalid">ID templat tidak valid</string>
    <string name="app_profile_template_create">Buat templat</string>
    <string name="app_profile_import_export">Impor/Ekspor</string>
    <string name="app_profile_template_save_failed">Gagal menyimpan templat</string>
    <string name="app_profile_template_edit">Edit templat</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">Templat Profil Aplikasi</string>
    <string name="app_profile_template_description">Deskripsi</string>
    <string name="app_profile_template_save">Simpan</string>
    <string name="settings_profile_template_summary">Kelola templat lokal dan online dari Profil Aplikasi.</string>
    <string name="app_profile_template_delete">Hapus</string>
    <string name="app_profile_template_import_empty">Papan klip kosong!</string>
    <string name="app_profile_template_view">Lihat templat</string>
    <string name="enable_web_debugging">Debugging WebView</string>
    <string name="enable_web_debugging_summary">Dapat digunakan untuk mendebug antarmuka web (WebUI). Harap aktifkan hanya saat diperlukan.</string>
    <string name="select_file_tip">%1$s partisi image disarankan</string>
    <string name="select_kmi">Pilih KMI</string>
    <string name="install_next">Selanjutnya</string>
    <string name="install_inactive_slot_warning">Perangkatmu akan **DIPAKSA** untuk boot ke slot nonaktif saat ini setelah reboot! \nGunakan hanya setelah proses OTA selesai. \nLanjutkan?</string>
    <string name="direct_install">Langsung pasang (Disarankan)</string>
    <string name="select_file">Pilih berkas</string>
    <string name="install_inactive_slot">Pasang ke slot nonaktif (setelah OTA)</string>
    <string name="grant_root_failed">Gagal memberikan akses root!</string>
    <string name="open">Buka</string>
    <string name="settings_check_update">Periksa pembaruan</string>
    <string name="settings_check_update_summary">Memeriksa pembaruan secara otomatis saat membuka aplikasi.</string>
    <string name="settings_uninstall_permanent_message">Menghapus KernelSU (root dan semua modul) secara menyeluruh dan permanen.</string>
    <string name="settings_uninstall_temporary">Hapus sementara</string>
    <string name="settings_restore_stock_image">Pulihkan image bawaan</string>
    <string name="settings_uninstall">Hapus</string>
    <string name="settings_uninstall_temporary_message">Hapus KernelSU untuk sementara, memulihkan ke kondisi asal setelah reboot berikutnya.</string>
    <string name="settings_uninstall_permanent">Hapus permanen</string>
    <string name="settings_restore_stock_image_message">Pulihkan image bawaan pabrik (jika dicadangkan), biasanya digunakan sebelum pembaruan OTA; jika Anda perlu menghapus KernelSU, silakan gunakan \"Hapus secara permanen\".</string>
    <string name="flash_success">Pemasangan berhasil</string>
    <string name="selected_lkm">LKM dipilih: %s</string>
    <string name="flashing">Memasang</string>
    <string name="flash_failed">Pemasangan gagal</string>
    <string name="save_log">Simpan Log</string>
    <string name="action">Aksi</string>
    <string name="log_saved">Log disimpan</string>
    <string name="module_sort_enabled_first">Diaktifkan dahulu</string>
    <string name="module_sort_action_first">Aksi lebih dulu</string>
    <string name="module_install_prompt_with_name">Modul berikut akan dipasang: %1$s</string>
    <string name="confirm">Oke</string>
    <string name="su_not_allowed">Gagal memberikan akses SU untuk %s</string>
    <string name="settings_module_check_update">Periksa pembaruan modul</string>
    <string name="install_upload_lkm_file">Gunakan berkas LKM lokal</string>
    <string name="install_only_support_ko_file">Hanya berkas .ko yang didukung</string>
    <string name="settings_sucompat">Perintah SU klasik</string>
    <string name="settings_sucompat_summary">Mengizinkan akses root melalui /system/bin/su, pada proses baru yang dibuat.</string>
    <string name="settings_kernel_umount">Unmount modul (tingkat kernel)</string>
    <string name="settings_kernel_umount_summary">Unmount modul dari kernel pada Profil Aplikasi.</string>
    <string name="processing">Memproses…</string>
    <string name="refresh_pulling">Tarik ke bawah untuk menyegarkan</string>
    <string name="refresh_release">Lepas untuk menyegarkan</string>
    <string name="refresh_refresh">Menyegarkan…</string>
    <string name="refresh_complete">Penyegaran berhasil</string>
    <string name="module_repos">Repositori</string>
    <string name="module_repos_sort_name">Nama (A → Z)</string>
    <string name="module_repos_source_code">Sumber kode</string>
    <string name="metamodule_uninstall_confirm">Yakin ingin menghapus modul %s? Tindakan ini akan memengaruhi semua modul, dan fitur tertentu yang disediakan oleh metamodul (seperti mounting) tidak akan berfungsi lagi.</string>
    <string name="home_gki_warning">Mulai dari v3.0.0, fungsi mode GKI dibatasi untuk lingkungan pengujian. Kami tidak menyarankan untuk penggunaan harian, dan berkas image tidak akan lagi disediakan.</string>
    <string name="app_profile_affects_following_apps">Mempengaruhi apl berikut</string>
    <string name="install_select_partition">Pilih partisi</string>
    <string name="feature_status_unsupported_summary">Kernel tidak mendukung fitur ini</string>
    <string name="feature_status_managed_summary">Fitur ini dikelola oleh modul</string>
    <string name="undo">Batalkan</string>
    <string name="module_undo_uninstall_success">Berhasil membatalkan penghapusan %s</string>
    <string name="module_undo_uninstall_failed">Gagal membatalkan penghapusan: %s</string>
    <string name="group_contains_apps">Berisi %d aplikasi</string>
    <string name="settings_theme">Tema</string>
    <string name="settings_theme_summary">Pilih mode tema aplikasi.</string>
    <string name="settings_theme_mode_system">Ikuti sistem</string>
    <string name="settings_theme_mode_light">Terang</string>
    <string name="settings_theme_mode_dark">Gelap</string>
    <string name="settings_theme_mode_monet_system">Monet (Ikuti sistem)</string>
    <string name="settings_theme_mode_monet_light">Monet (Terang)</string>
    <string name="settings_theme_mode_monet_dark">Monet (Gelap)</string>
    <string name="settings_key_color">Warna utama</string>
    <string name="settings_key_color_summary">Sesuaikan aksen saat menggunakan Monet.</string>
    <string name="settings_key_color_default">Default</string>
    <string name="color_blue">Biru</string>
    <string name="color_red">Merah</string>
    <string name="color_green">Hijau</string>
    <string name="color_purple">Ungu</string>
    <string name="color_orange">Jingga</string>
    <string name="color_teal">Hijau kebiruan</string>
    <string name="color_pink">Merah muda</string>
    <string name="color_brown">Coklat</string>
    <string name="network_offline">Tidak terhubung ke jaringan</string>
    <string name="network_retry">Coba lagi</string>
    <string name="tab_readme">Baca Aku</string>
    <string name="tab_releases">Rilis</string>
    <string name="tab_info">Informasi</string>
    <string name="safe_mode_module_disabled">Pemasangan modul dinonaktifkan pada mode aman</string>
    <string name="module_action_success">Tindakan modul berhasil dieksekusi.</string>
    <string name="settings_mode_enable_by_default">Aktif (Default)</string>
    <string name="settings_mode_disable_until_reboot">Nonaktif hingga Reboot</string>
    <string name="settings_mode_disable_always">Selalu nonaktif</string>
    <string name="module_shortcut_title">Buat pintasan</string>
    <string name="module_shortcut_name_label">Nama pintasan</string>
    <string name="module_shortcut_icon_pick">Pilih ikon khusus</string>
    <string name="module_shortcut_add">Tambahkan pintasan</string>
    <string name="module_shortcut_not_supported">Launcher tidak mendukung pintasan layar utama.</string>
    <string name="module_shortcut_created">Pintasan dibuat di layar utama.</string>
    <string name="module_shortcut_updated">Pintasan diperbarui.</string>
    <string name="module_shortcut_delete">Hapus pintasan</string>
    <string name="module_shortcut_type_title">Pilih tipe</string>
    <string name="module_shortcut_permission_tip_xiaomi">Harap aktifkan izin \"Buat pintasan layar utama\" untuk aplikasi ini di pengaturan Xiaomi.</string>
    <string name="module_shortcut_permission_tip_oppo">Harap aktifkan izin \"Pintasan layar utama\" untuk aplikasi ini di pengaturan OPPO.</string>
    <string name="module_shortcut_permission_tip_default">Jika pembuatan pintasan gagal, harap aktifkan izin pintasan layar utama untuk aplikasi ini di pengaturan sistem.</string>
    <string name="no_such_module">Modul %s tidak tersedia</string>
    <string name="module_unavailable">Modul %s dinonaktifkan, diperbarui, atau menunggu penghapusan</string>
    <string name="select_file_tip_nogki">Silakan pilih berkas image perangkat GKI yang ingin Anda tambal.</string>
    <string name="current_kmi">Versi KMI perangkat ini: %s</string>
    <string name="current_device_kmi">Ini perangkat KMI</string>
</resources>

```

`manager/app/src/main/res/values-it/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Home</string>
    <string name="home_not_installed">Non installato</string>
    <string name="home_click_to_install">Clicca per installare</string>
    <string name="home_working">In esecuzione</string>
    <string name="home_working_version">Versione: %d</string>
    <string name="home_unsupported">Non supportato</string>
    <string name="home_unsupported_reason">KernelSU ora supporta solo i kernel GKI</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Versione del manager</string>
    <string name="home_fingerprint">Impronta della build di Android</string>
    <string name="home_selinux_status">Stato di SELinux</string>
    <string name="selinux_status_disabled">Disabilitato</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Sconosciuto</string>
    <string name="superuser">Accesso root</string>
    <string name="module_failed_to_enable">Impossibile abilitare il modulo: %s</string>
    <string name="module_failed_to_disable">Impossibile disabilitare il modulo: %s</string>
    <string name="module_empty">Nessun modulo installato</string>
    <string name="module">Modulo</string>
    <string name="uninstall">Disinstalla</string>
    <string name="module_install">Installa</string>
    <string name="install">Installa</string>
    <string name="reboot">Riavvia</string>
    <string name="settings">Impostazioni</string>
    <string name="reboot_userspace">Riavvio rapido</string>
    <string name="reboot_recovery">Riavvia in modalità Recovery</string>
    <string name="reboot_bootloader">Riavvia in modalità Bootloader</string>
    <string name="reboot_download">Riavvia in modalità Download</string>
    <string name="reboot_edl">Riavvia in modalità EDL</string>
    <string name="about">Informazioni</string>
    <string name="module_uninstall_confirm">Sei sicuro di voler disinstallare il modulo %s?</string>
    <string name="module_uninstall_success">%s disinstallato</string>
    <string name="module_uninstall_failed">Impossibile disinstallare: %s</string>
    <string name="module_version">Versione</string>
    <string name="module_author">Autore</string>
    <string name="show_system_apps">Mostra app di sistema</string>
    <string name="send_log">Invia log</string>
    <string name="safe_mode">Modalità provvisoria</string>
    <string name="reboot_to_apply">Riavvia per applicare la modifica</string>
    <string name="module_magisk_conflict">I moduli sono disabilitati perché in conflitto con Magisk!</string>
    <string name="home_learn_kernelsu">Scopri KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Scopri come installare KernelSU e utilizzare i moduli</string>
    <string name="home_support_title">Supportaci</string>
    <string name="home_support_content">KernelSU è, e sempre sarà, gratuito e open source. Puoi comunque mostrarci il tuo apprezzamento facendo una donazione.</string>
    <string name="about_source_code"><![CDATA[Visualizza il codice sorgente su %1$s<br/>Unisciti al nostro canale %2$s]]></string>
    <string name="profile_name">Nome profilo</string>
    <string name="profile_namespace">Spazio dei nomi del mount</string>
    <string name="profile_namespace_global">Globale</string>
    <string name="profile_groups">Gruppi</string>
    <string name="profile_namespace_inherited">Ereditato</string>
    <string name="profile_namespace_individual">Individuale</string>
    <string name="profile_default">Predefinito</string>
    <string name="profile_custom">Personalizzato</string>
    <string name="profile_template">Modello</string>
    <string name="profile_umount_modules">Scollega moduli</string>
    <string name="profile_selinux_context">Contesto SELinux</string>
    <string name="failed_to_update_app_profile">Aggiornamento App Profile per %s fallito</string>
    <string name="module_update">Aggiorna</string>
    <string name="launch_app">Apri</string>
    <string name="profile_capabilities">Capacità</string>
    <string name="settings_umount_modules_default">Scollega moduli da default</string>
    <string name="profile_selinux_rules">Regole</string>
    <string name="module_downloading">Sto scaricando il modulo: %s</string>
    <string name="module_start_downloading">Inizia a scaricare:%s</string>
    <string name="new_version_available">Nuova versione: %s disponibile, tocca per aggiornare</string>
    <string name="force_stop_app">Arresto forzato</string>
    <string name="restart_app">Riavvia</string>
    <string name="failed_to_update_sepolicy">Aggiornamento regole SELinux per %s fallito</string>
    <string name="profile_umount_modules_summary">Attivando questa opzione permetterai a KernelSU di ripristinare ogni file modificato dai moduli per questa app.</string>
    <string name="profile_selinux_domain">Dominio</string>
    <string name="settings_umount_modules_default_summary">Il valore predefinito per \"Scollega moduli\" in App Profile. Se attivato, rimuoverà tutte le modifiche al sistema da parte dei moduli per le applicazioni che non hanno un profilo impostato.</string>
    <string name="require_kernel_version">La versione attualmente installata di KernelSU (%1$d) è troppo vecchia ed il gestore non può funzionare correttamente. Si prega di aggiornare alla versione %2$d o successiva!</string>
    <string name="module_changelog">Registro aggiornamenti</string>
    <string name="app_profile_template_create">Crea modello</string>
    <string name="app_profile_template_edit">Modifica modello</string>
    <string name="app_profile_template_id">identificatore</string>
    <string name="app_profile_template_id_invalid">Identificativo modello non valido</string>
    <string name="app_profile_template_name">Nome</string>
    <string name="app_profile_template_view">Visualizza modello</string>
    <string name="app_profile_template_id_exist">L\'identificatore del modello è già in uso!</string>
    <string name="app_profile_import_export">Importa/Esporta</string>
    <string name="app_profile_import_from_clipboard">Importa dagli appunti</string>
    <string name="app_profile_export_to_clipboard">Esporta negli appunti</string>
    <string name="app_profile_template_export_empty">Impossibile trovare un modello locale da esportare!</string>
    <string name="app_profile_template_import_success">Importato con successo</string>
    <string name="app_profile_template_import_empty">Gli appunti sono vuoti!</string>
    <string name="grant_root_failed">Impossibile ottenere l\'accesso root!</string>
    <string name="settings_profile_template">Modelli App Profile</string>
    <string name="settings_profile_template_summary">Gestisci i modelli locali e remoti di App Profile</string>
    <string name="app_profile_template_delete">Elimina</string>
    <string name="app_profile_template_description">Descrizione</string>
    <string name="app_profile_template_save">Salva</string>
    <string name="app_profile_template_save_failed">Impossibile salvare il modello</string>
    <string name="open">Apri</string>
    <string name="settings_check_update">Controlla aggiornamenti</string>
    <string name="settings_check_update_summary">Controlla automaticamente la disponibilità di aggiornamenti all\'apertura dell\'applicazione</string>
    <string name="enable_web_debugging">Abilita il debug di WebView</string>
    <string name="enable_web_debugging_summary">Può essere usato per svolgere il debug di WebUI, è consigliato attivarlo solo quando necessario.</string>
    <string name="select_file_tip">È consigliato usare immagine della partizione %1$s</string>
    <string name="select_kmi">Scegli il KMI</string>
    <string name="install_next">Avanti</string>
    <string name="direct_install">Installazione diretta (Raccomandata)</string>
    <string name="select_file">Scegli un file</string>
    <string name="install_inactive_slot">Installa nello slot inattivo (dopo OTA)</string>
    <string name="install_inactive_slot_warning">Il tuo dispositivo sarà **FORZATO** ad avviarsi nello slot inattivo dopo il riavvio!
\nUsa questa opzione solo quando l\'applicazione dell\'aggiornamento OTA è terminata.
\nProcedere?</string>
    <string name="settings_uninstall">Disinstalla</string>
    <string name="settings_uninstall_temporary">Disinstalla temporaneamente</string>
    <string name="settings_uninstall_permanent">Disinstalla permanentemente</string>
    <string name="settings_restore_stock_image">Ripristina immagine originale del produttore</string>
    <string name="settings_uninstall_temporary_message">Disinstalla temporaneamente KernelSU, ripristina lo stato originale dopo il prossimo riavvio.</string>
    <string name="settings_uninstall_permanent_message">Disinstalla KernelSU (root e tutti i moduli) completamente e permanentemente.</string>
    <string name="flashing">Installazione</string>
    <string name="flash_success">Installazione completata</string>
    <string name="flash_failed">Installazione fallita</string>
    <string name="selected_lkm">LKM selezionato: %s</string>
    <string name="settings_restore_stock_image_message">Ripristina l\'immagine di fabbrica del produttore (se il backup è presente), solitamente usato prima di applicare l\'OTA; se devi disinstallare KernelSU, utilizza invece \"Disinstalla permanentemente\".</string>
    <string name="save_log">Salva Registri</string>
    <string name="settings_sucompat">Reindirizza binario su</string>
    <string name="settings_sucompat_summary">Consente alle app con autorizzazione Superuser nel profilo app di ottenere una shell superuser eseguendo /system/bin/su; efficace solo per i nuovi processi.</string>
    <string name="settings_kernel_umount">Umount del kernel</string>
    <string name="settings_kernel_umount_summary">Comportamento di umount a livello di kernel controllato da KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-iw/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="reboot_to_apply">הפעל מחדש כדי להכניס לתוקף</string>
    <string name="home_click_to_learn_kernelsu">למד כיצד להתקין את KernelSU ולהשתמש במודולים</string>
    <string name="selinux_status_unknown">לא ידוע</string>
    <string name="show_system_apps">הצג אפליקציות מערכת</string>
    <string name="module_uninstall_success">%s הוסר</string>
    <string name="profile_umount_modules">הסרת טעינת מודולים</string>
    <string name="send_log">שלח לוג</string>
    <string name="selinux_status_disabled">מושבת</string>
    <string name="home_support_title">תמכו בנו</string>
    <string name="profile_namespace_inherited">ירושה</string>
    <string name="module_magisk_conflict">מודולים מושבתים מכיוון שהם מתנגשים עם זה של Magisk!</string>
    <string name="module_changelog">יומן שינויים</string>
    <string name="selinux_status_permissive">התרים</string>
    <string name="reboot_download">הפעלה מחדש למצב הורדה</string>
    <string name="settings_umount_modules_default">טעינת מודולים כברירת מחדל</string>
    <string name="profile_umount_modules_summary">הפעלת אפשרות זו תאפשר ל-KernelSU לשחזר קבצים שהשתנו על ידי המודולים עבור יישום זה.</string>
    <string name="profile_namespace_individual">אישי</string>
    <string name="module_failed_to_enable">הפעלת המודל נכשלה: %s</string>
    <string name="force_stop_app">עצירה בכח</string>
    <string name="reboot_edl">הפעלה מחדש למצב EDL</string>
    <string name="restart_app">איתחול</string>
    <string name="profile_capabilities">יכולת</string>
    <string name="module_start_downloading">מפעיל מודל: %s</string>
    <string name="profile_namespace_global">גלובלי</string>
    <string name="settings_umount_modules_default_summary">ערך ברירת המחדל הגלובלי עבור \"טעינת מודולים\" בפרופילי אפליקציה. אם מופעל, זה יסיר את כל שינויי המודול למערכת עבור יישומים שאין להם ערכת פרופיל.</string>
    <string name="selinux_status_enforcing">אכיפה</string>
    <string name="profile_selinux_context">הקשר SELinux</string>
    <string name="home_fingerprint">טביעת אצבע</string>
    <string name="profile_default">ברירת מחדל</string>
    <string name="launch_app">להשיק</string>
    <string name="safe_mode">מצב בטוח</string>
    <string name="require_kernel_version">גרסת KernelSU הנוכחית %1$d נמוכה מדי כדי שהמנהל יפעל כראוי. אנא שדרג לגרסה %2$d ומעלה!</string>
    <string name="reboot_recovery">הפעלה מחדש לריקברי</string>
    <string name="reboot_userspace">רך Reboot</string>
    <string name="profile_name">שם פרופיל</string>
    <string name="home_support_content">KernelSU הוא, ותמיד יהיה, חינמי וקוד פתוח. עם זאת, תוכל להראות לנו שאכפת לך על ידי תרומה.</string>
    <string name="uninstall">הסרה</string>
    <string name="profile_namespace">טעינת מרחב שמות</string>
    <string name="module_install">התקנה</string>
    <string name="home_click_to_install">לחץ להתקנה</string>
    <string name="profile_selinux_rules">כללים</string>
    <string name="profile_groups">קבוצה</string>
    <string name="module">מודולים</string>
    <string name="module_author">יוצר</string>
    <string name="about">אודות</string>
    <string name="home_working_version">גרסה: %d</string>
    <string name="reboot">הפעלה מחדש</string>
    <string name="home_unsupported_reason">KernelSU תומך רק בליבת GKI כעת</string>
    <string name="home_selinux_status">סטטוס SELinux</string>
    <string name="module_version">גרסה</string>
    <string name="home_unsupported">אינו נתמך</string>
    <string name="profile_selinux_domain">תחום</string>
    <string name="home">בית</string>
    <string name="profile_custom">מותאם אישית</string>
    <string name="profile_template">תבנית</string>
    <string name="module_downloading">מוריד מודל: %s</string>
    <string name="module_update">עדכון</string>
    <string name="home_learn_kernelsu">למד אודות KernelSU</string>
    <string name="module_uninstall_confirm">האם אתה בטוח שברצונך להסיר את התקנת המודל %s\?</string>
    <string name="module_uninstall_failed">הסרת התקנת %s נכשלה:</string>
    <string name="superuser">משתמש על</string>
    <string name="settings">הגדרות</string>
    <string name="home_working">עובד</string>
    <string name="module_failed_to_disable">השבתת מודל %s נכשלה:</string>
    <string name="module_empty">אין מודלים מותקנים</string>
    <string name="install">להתקין</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_not_installed">לא מותקן</string>
    <string name="failed_to_update_app_profile">נכשל עדכון פרופיל האפליקציה עבור %s</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="failed_to_update_sepolicy">נכשל עדכון כללי SELinux עבור: %s</string>
    <string name="reboot_bootloader">הפעלה מחדש לבוטלאודר</string>
    <string name="about_source_code">ראה את קוד המקור ב%1$s<br/>הצטרף אלינו %2$s בערוץ</string>
    <string name="home_manager_version">גרסת מנהל</string>
    <string name="new_version_available">גרסה חדשה עבור: %s זמינה, לחץ כדי לשדרג</string>
    <string name="save_log">שמור יומנים</string>
    <string name="settings_sucompat">ניתוב מחדש של su binary</string>
    <string name="settings_sucompat_summary">הפנה מחדש את /system/bin/su ל-ksud עבור אפליקציות שקיבלו הרשאת Superuser בפרופיל האפליקציה; יעיל לתהליכים חדשים בלבד.</string>
    <string name="settings_kernel_umount">ביטול טעינת קרנל</string>
    <string name="settings_kernel_umount_summary">התנהגות ביטול טעינה ברמת הקרנל הנשלטת על ידי KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-ja/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">ホーム</string>
    <string name="home_not_installed">未インストール</string>
    <string name="home_click_to_install">タップでインストール</string>
    <string name="home_working">動作中</string>
    <string name="home_working_version">バージョン: %d</string>
    <string name="home_unsupported">非対応</string>
    <string name="home_unsupported_reason">KernelSU は現在 GKI カーネルのみをサポートしています。ただし、GKI デバイス向けにイメージにパッチを適用することは可能です。</string>
    <string name="home_kernel">カーネル</string>
    <string name="home_manager_version">アプリのバージョン</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">SELinux の状態</string>
    <string name="selinux_status_disabled">Disabled</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">不明</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">モジュールの有効化に失敗しました: %s</string>
    <string name="module_failed_to_disable">モジュールの無効化に失敗しました: %s</string>
    <string name="module_empty">モジュールがインストールされていません</string>
    <string name="module">モジュール</string>
    <string name="uninstall">アンインストール</string>
    <string name="module_install">インストール</string>
    <string name="install">インストール</string>
    <string name="reboot">再起動</string>
    <string name="settings">設定</string>
    <string name="reboot_userspace">通常の再起動</string>
    <string name="reboot_recovery">リカバリーへ再起動</string>
    <string name="reboot_bootloader">ブートローダー へ再起動</string>
    <string name="reboot_download">ダウンロードモードへ再起動</string>
    <string name="reboot_edl">EDL へ再起動</string>
    <string name="about">アプリについて</string>
    <string name="module_uninstall_confirm">モジュール %s をアンインストールしますか？</string>
    <string name="module_uninstall_success">%s はアンインストールされました</string>
    <string name="module_uninstall_failed">アンインストールに失敗しました: %s</string>
    <string name="module_version">バージョン</string>
    <string name="module_author">制作者</string>
    <string name="show_system_apps">システムアプリを表示</string>
    <string name="send_log">ログを送信</string>
    <string name="safe_mode">セーフモード</string>
    <string name="reboot_to_apply">再起動すると有効化されます</string>
    <string name="module_magisk_conflict">モジュールが Magisk との競合により利用できません!</string>
    <string name="home_learn_kernelsu">KernelSU について</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/ja_JP/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">KernelSU のインストール方法やモジュールの使い方はこちら</string>
    <string name="home_support_title">支援する</string>
    <string name="home_support_content">KernelSU はこれからもずっと無料でオープンソースです。寄付をして頂くことで、開発を支援していただけます。</string>
    <string name="about_source_code"><![CDATA[%1$s でソースコードを表示<br/>%2$s チャンネルに参加]]></string>
    <string name="profile">アプリのプロファイル</string>
    <string name="profile_default">既定</string>
    <string name="profile_template">テンプレート</string>
    <string name="profile_custom">カスタム</string>
    <string name="profile_name">プロファイル名</string>
    <string name="profile_namespace">名前空間のマウント</string>
    <string name="profile_namespace_inherited">継承</string>
    <string name="profile_namespace_global">共通</string>
    <string name="profile_namespace_individual">分離</string>
    <string name="profile_umount_modules">モジュールのアンマウント</string>
    <string name="profile_groups">グループ</string>
    <string name="profile_selinux_context">SELinux コンテキスト</string>
    <string name="failed_to_update_app_profile">%s のアプリのプロファイルの更新をできませでした</string>
    <string name="profile_selinux_domain">ドメイン</string>
    <string name="profile_selinux_rules">ルール</string>
    <string name="new_version_available">新しいバージョン %s が利用可能です。タップしてダウンロード!</string>
    <string name="module_update">アップデート</string>
    <string name="module_start_downloading">ダウンロードを開始: %s</string>
    <string name="launch_app">起動</string>
    <string name="force_stop_app">強制停止</string>
    <string name="restart_app">再起動</string>
    <string name="failed_to_update_sepolicy">SELinux ルールの更新に失敗しました %s</string>
    <string name="profile_capabilities">ケーパビリティ</string>
    <string name="module_downloading">モジュールをダウンロード中: %s</string>
    <string name="profile_umount_modules_summary">このオプションを有効にすると、KernelSU はこのアプリのモジュールによって変更されたファイルを復元できるようになります。</string>
    <string name="settings_umount_modules_default">デフォルトでモジュールをアンマウントする</string>
    <string name="settings_umount_modules_default_summary">アプリプロファイルの「モジュールのアンマウント」の共通のデフォルト値です。 有効にすると、プロファイルセットを持たないアプリのシステムに対するすべてのモジュールの変更が削除されます。</string>
    <string name="require_kernel_version">現在の KernelSU バージョン %1$d はマネージャーが適切に機能するには低すぎます。 バージョン %2$d 以降にアップグレードしてください！</string>
    <string name="module_changelog">変更履歴</string>
    <string name="app_profile_template_import_success">インポート成功</string>
    <string name="app_profile_export_to_clipboard">クリップボードからエクスポート</string>
    <string name="app_profile_template_export_empty">エクスポートするローカル テンプレートが見つかりません！</string>
    <string name="app_profile_template_id_exist">テンプレート ID はすでに存在します！</string>
    <string name="app_profile_import_from_clipboard">クリップボードからインポート</string>
    <string name="app_profile_template_name">名前</string>
    <string name="app_profile_template_id_invalid">無効なテンプレート ID</string>
    <string name="app_profile_template_create">テンプレートの作成</string>
    <string name="app_profile_import_export">インポート/エクスポート</string>
    <string name="app_profile_template_save_failed">テンプレートの保存に失敗しました</string>
    <string name="app_profile_template_edit">テンプレートの編集</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">アプリプロファイルのテンプレート</string>
    <string name="app_profile_template_description">説明</string>
    <string name="app_profile_template_save">保存</string>
    <string name="settings_profile_template_summary">アプリプロファイルのローカルおよびオンラインテンプレートを管理する。</string>
    <string name="app_profile_template_delete">消去</string>
    <string name="app_profile_template_import_empty">クリップボードが空です！</string>
    <string name="app_profile_template_view">テンプレートを表示</string>
    <string name="settings_check_update">アップデートを確認</string>
    <string name="settings_check_update_summary">アプリを開いたときにアップデートを自動的に確認する。</string>
    <string name="grant_root_failed">root の付与に失敗しました！</string>
    <string name="open">開く</string>
    <string name="enable_web_debugging">WebView デバッグ</string>
    <string name="enable_web_debugging_summary">WebUI のデバッグに使用できます。必要な場合にのみ有効にしてください。</string>
    <string name="select_file_tip">%1$s パーティション イメージが推奨されます</string>
    <string name="select_kmi">KMI を選択してください</string>
    <string name="install_next">次へ</string>
    <string name="install_inactive_slot">非アクティブなスロットにインストール (OTA 後)</string>
    <string name="install_inactive_slot_warning">再起動後、デバイスは**強制的に**、現在非アクティブなスロットから起動します。\nこのオプションは、OTA が完了した後にのみ使用してください。\n続行しますか？</string>
    <string name="direct_install">直接インストール (推奨)</string>
    <string name="select_file">ファイルを選択してください</string>
    <string name="settings_uninstall_permanent">完全にアンインストールする</string>
    <string name="settings_restore_stock_image">ストックイメージを復元</string>
    <string name="settings_uninstall_temporary">一時的にアンインストールする</string>
    <string name="settings_uninstall">アンインストール</string>
    <string name="settings_uninstall_temporary_message">KernelSU を一時的にアンインストールし、次回の再起動後に元の状態に戻します。</string>
    <string name="settings_uninstall_permanent_message">KernelSU (ルートおよびすべてのモジュール) を完全かつ永久にアンインストールします。</string>
    <string name="settings_restore_stock_image_message">バックアップが存在する場合、工場出荷時のイメージを復元できます (OTA の前に使用してください)。KernelSU をアンインストールする必要がある場合は、「完全にアンインストールする」を使用してください。</string>
    <string name="flashing">フラッシュ</string>
    <string name="flash_success">フラッシュ成功</string>
    <string name="flash_failed">フラッシュ失敗</string>
    <string name="selected_lkm">選択された LKM: %s</string>
    <string name="save_log">ログを保存</string>
    <string name="action">アクション</string>
    <string name="log_saved">保存されたログ</string>
    <string name="module_sort_enabled_first">並べ替え（最初に有効）</string>
    <string name="module_sort_action_first">並べ替え（アクション優先）</string>
    <string name="su_not_allowed">%s に superuser アクセスを許可できませんでした</string>
    <string name="module_install_prompt_with_name">次のモジュールがインストールされます: %1$s</string>
    <string name="confirm">確認</string>
    <string name="settings_module_check_update">モジュールの更新を確認する</string>
    <string name="install_upload_lkm_file">ローカル LKM ファイルを使用する</string>
    <string name="install_only_support_ko_file">.ko ファイルのみサポートされています</string>
    <string name="settings_sucompat">従来の SU コマンド</string>
    <string name="settings_sucompat_summary">新規プロセスで /system/bin/su 経由での root アクセスを許可します。</string>
    <string name="settings_kernel_umount">モジュールのアンマウント (カーネルレベル)</string>
    <string name="settings_kernel_umount_summary">アプリプロファイルに基づいて、カーネルからモジュールをアンマウントします。</string>
    <string name="processing">処理中…</string>
    <string name="refresh_pulling">下に引いて更新</string>
    <string name="refresh_release">リリースして更新</string>
    <string name="refresh_refresh">更新中…</string>
    <string name="refresh_complete">更新に成功しました</string>
    <string name="module_repos">リポジトリ</string>
    <string name="module_repos_sort_name">名前（A→Z）</string>
    <string name="module_repos_source_code">ソースコード</string>
    <string name="metamodule_uninstall_confirm">モジュール %s をアンインストールしてもよろしいですか? この操作はすべてのモジュールに影響し、メタモジュールによって提供される特定の機能 (マウントなど) は動作しなくなります。</string>
    <string name="home_gki_warning">バージョン 3.0.0 以降、GKI ワークモードはテスト環境でのみ使用されます。日常的な使用には推奨されません。また、イメージファイルの提供も停止されます。</string>
    <string name="app_profile_affects_following_apps">以下のアプリに影響します</string>
    <string name="install_select_partition">パーティションを選択</string>
    <string name="feature_status_unsupported_summary">カーネルはこの機能をサポートしていません</string>
    <string name="safe_mode_module_disabled">セーフモードではモジュールのインストールが無効になっています</string>
    <string name="feature_status_managed_summary">この機能はモジュールによって管理されます</string>
    <string name="undo">元に戻す</string>
    <string name="module_undo_uninstall_success">%s のアンインストールを正常にキャンセルしました</string>
    <string name="module_undo_uninstall_failed">アンインストールを元に戻すことができませんでした: %s</string>
    <string name="group_contains_apps">%d 個のアプリが含まれています</string>
    <string name="settings_theme">テーマ</string>
    <string name="settings_theme_summary">アプリのテーマモードを選択します。</string>
    <string name="settings_theme_mode_system">システムに従う</string>
    <string name="settings_theme_mode_light">ライト</string>
    <string name="settings_theme_mode_dark">ダーク</string>
    <string name="settings_theme_mode_monet_system">Monet (システムに従う)</string>
    <string name="settings_theme_mode_monet_light">Monet (ライト)</string>
    <string name="settings_theme_mode_monet_dark">Monet (ダーク)</string>
    <string name="settings_key_color">キーカラー</string>
    <string name="settings_key_color_summary">Monet を使用するときのアクセントカラーをカスタマイズします。</string>
    <string name="settings_key_color_default">デフォルト</string>
    <string name="color_blue">ブルー</string>
    <string name="color_red">レッド</string>
    <string name="color_green">グリーン</string>
    <string name="color_purple">パープル</string>
    <string name="color_orange">オレンジ</string>
    <string name="color_teal">ティール</string>
    <string name="color_pink">ピンク</string>
    <string name="color_brown">ブラウン</string>
    <string name="network_offline">ネットワークに接続されていません</string>
    <string name="network_retry">再試行</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">リリース</string>
    <string name="tab_info">情報</string>
    <string name="module_action_success">モジュールのアクションが正常に実行されました。</string>
    <string name="settings_mode_enable_by_default">有効 (デフォルト)</string>
    <string name="settings_mode_disable_until_reboot">再起動するまで無効</string>
    <string name="settings_mode_disable_always">常に無効</string>
    <string name="module_shortcut_title">ショートカットを作成</string>
    <string name="module_shortcut_name_label">ショートカット名</string>
    <string name="module_shortcut_icon_pick">カスタムアイコンを選択</string>
    <string name="module_shortcut_add">ショートカットを追加</string>
    <string name="module_shortcut_not_supported">ランチャーはホーム画面ショートカットをサポートしていません。</string>
    <string name="module_shortcut_created">ホーム画面にショートカットを作成しました。</string>
    <string name="module_shortcut_updated">ショートカットが更新されました。</string>
    <string name="module_shortcut_delete">ショートカットを削除</string>
    <string name="module_shortcut_type_title">タイプを選択</string>
    <string name="module_shortcut_permission_tip_xiaomi">Xiaomi の設定で、このアプリに対して「ホーム画面ショートカット」権限を有効にしてください。</string>
    <string name="module_shortcut_permission_tip_oppo">OPPO の設定で、このアプリに対して「ホーム画面ショートカット」権限を有効にしてください。</string>
    <string name="module_shortcut_permission_tip_default">ショートカットの作成に失敗した場合は、システム設定でこのアプリに対してホーム画面ショートカットの権限を有効にしてください。</string>
    <string name="no_such_module">モジュール %s は存在しません</string>
    <string name="module_unavailable">モジュール %s は無効、更新中、または削除の待機状態にあります</string>
    <string name="select_file_tip_nogki">パッチを適用する GKI デバイスのイメージファイルを選択してください</string>
    <string name="current_kmi">このデバイスの KMI バージョン: %s</string>
    <string name="current_device_kmi">このデバイスの KMI</string>
</resources>

```

`manager/app/src/main/res/values-km/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">ទំព័រដើម</string>
    <string name="home_not_installed">មិនទាន់បានដំឡើង</string>
    <string name="home_click_to_install">ចុចដើម្បីដំឡើង</string>
    <string name="settings_sucompat">កែផ្លូវ su binary</string>
    <string name="settings_sucompat_summary">បញ្ជូន /system/bin/su ទៅកាន់ ksud សម្រាប់កម្មវិធីដែលបានទទួលសិទ្ធិ Superuser នៅក្នុងទម្រង់កម្មវិធី; មានប្រសិទ្ធភាពសម្រាប់ដំណើរការថ្មីប៉ុណ្ណោះ។</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">ឥរិយាបថ umount កម្រិតខឺណែលគ្រប់គ្រងដោយ KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-kn/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="reboot_to_apply">ಪರಿಣಾಮ ಬೀರಲು ರೀಬೂಟ್ ಮಾಡಿ</string>
    <string name="home_click_to_learn_kernelsu">KernelSU ಅನ್ನು ಹೇಗೆ ಸ್ಥಾಪಿಸಬೇಕು ಮತ್ತು ಮಾಡ್ಯೂಲ್‌ಗಳನ್ನು ಬಳಸುವುದು ಹೇಗೆ ಎಂದು ತಿಳಿಯಿರಿ</string>
    <string name="selinux_status_unknown">ತಿಳಿಯದ</string>
    <string name="show_system_apps">ಸಿಸ್ಟಮ್ ಅಪ್ಲಿಕೇಶನ್‌ಗಳನ್ನು ತೋರಿಸಿ</string>
    <string name="module_uninstall_success">%s ಅನ್‌ಇನ್‌ಸ್ಟಾಲ್ ಮಾಡಲಾಗಿದೆ</string>
    <string name="profile_umount_modules">Umount ಮಾಡ್ಯೂಲ್‌ಗಳು</string>
    <string name="send_log">ಲಾಗ್ ಕಳುಹಿಸಿ</string>
    <string name="home_support_title">ನಮ್ಮನ್ನು ಬೆಂಬಲಿಸಿ</string>
    <string name="profile_namespace_inherited">ಪಿತ್ರಾರ್ಜಿತ</string>
    <string name="module_magisk_conflict">ಮಾಡ್ಯೂಲ್‌ಗಳನ್ನು ನಿಷ್ಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ ಏಕೆಂದರೆ ಇದು ಮ್ಯಾಜಿಸ್ಕ್‌ನೊಂದಿಗೆ ಸಂಘರ್ಷವಾಗಿದೆ!</string>
    <string name="module_changelog">ಚೇಂಜ್ಲಾಗ್</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="settings_umount_modules_default">ಡೀಫಾಲ್ಟ್ ಆಗಿ Umount ಮಾಡ್ಯೂಲ್</string>
    <string name="profile_umount_modules_summary">ಈ ಆಯ್ಕೆಯನ್ನು ಸಕ್ರಿಯಗೊಳಿಸುವುದರಿಂದ ಈ ಅಪ್ಲಿಕೇಶನ್‌ಗಾಗಿ ಮಾಡ್ಯೂಲ್‌ಗಳ ಮೂಲಕ ಯಾವುದೇ ಮಾರ್ಪಡಿಸಿದ ಫೈಲ್‌ಗಳನ್ನು ಮರುಸ್ಥಾಪಿಸಲು KernelSU ಗೆ ಅನುಮತಿಸುತ್ತದೆ.</string>
    <string name="profile_namespace_individual">ವೈಯಕ್ತಿಕ</string>
    <string name="module_failed_to_enable">ಮಾಡ್ಯೂಲ್ ಅನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು ವಿಫಲವಾಗಿದೆ: %s</string>
    <string name="force_stop_app">ಫೋರ್ಸ್ ಸ್ಟಾಪ್</string>
    <string name="reboot_edl">EDL ಗೆ ರೀಬೂಟ್</string>
    <string name="profile_capabilities">ಸಾಮರ್ಥ್ಯಗಳು</string>
    <string name="module_start_downloading">ಡೌನ್‌ಲೋಡ್ ಮಾಡುವುದನ್ನು ಪ್ರಾರಂಭಿಸಿ: %s</string>
    <string name="profile_namespace_global">ಜಾಗತಿಕ</string>
    <string name="settings_umount_modules_default_summary">ಅಪ್ಲಿಕೇಶನ್ ಪ್ರೊಫೈಲ್‌ಗಳಲ್ಲಿ \"Umount ಮಾಡ್ಯೂಲ್\" ಗಾಗಿ ಜಾಗತಿಕ ಡೀಫಾಲ್ಟ್ ಮೌಲ್ಯ. ಸಕ್ರಿಯಗೊಳಿಸಿದರೆ, ಪ್ರೊಫೈಲ್ ಸೆಟ್ ಅನ್ನು ಹೊಂದಿರದ ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗಾಗಿ ಸಿಸ್ಟಮ್‌ಗೆ ಎಲ್ಲಾ ಮಾಡ್ಯೂಲ್ ಮಾರ್ಪಾಡುಗಳನ್ನು ಇದು ತೆಗೆದುಹಾಕುತ್ತದೆ.</string>
    <string name="profile_selinux_context">SELinux ಸಂದರ್ಭ</string>
    <string name="profile_default">ಡೀಫಾಲ್ಟ್</string>
    <string name="launch_app">ಲಾಂಚ್</string>
    <string name="safe_mode">ಸುರಕ್ಷಿತ ಮೋಡ್</string>
    <string name="require_kernel_version">ಪ್ರಸ್ತುತ KernelSU ಆವೃತ್ತಿ %1$d ಮ್ಯಾನೇಜರ್ ಸರಿಯಾಗಿ ಕಾರ್ಯನಿರ್ವಹಿಸಲು ತುಂಬಾ ಕಡಿಮೆಯಾಗಿದೆ. ದಯವಿಟ್ಟು ಆವೃತ್ತಿ %2$d ಅಥವಾ ಹೆಚ್ಚಿನದಕ್ಕೆ ಅಪ್‌ಗ್ರೇಡ್ ಮಾಡಿ!</string>
    <string name="reboot_userspace">ಸಾಫ್ಟ್ ರೀಬೂಟ್</string>
    <string name="profile_name">ಪ್ರೊಫೈಲ್ ಹೆಸರು</string>
    <string name="home_support_content">KernelSU ಉಚಿತ ಮತ್ತು ಮುಕ್ತ ಮೂಲವಾಗಿದೆ ಮತ್ತು ಯಾವಾಗಲೂ ಇರುತ್ತದೆ. ಆದಾಗ್ಯೂ ನೀವು ದೇಣಿಗೆ ನೀಡುವ ಮೂಲಕ ನೀವು ಕಾಳಜಿ ವಹಿಸುತ್ತೀರಿ ಎಂದು ನಮಗೆ ತೋರಿಸಬಹುದು.</string>
    <string name="uninstall">ಅನ್‌ಇನ್‌ಸ್ಟಾಲ್</string>
    <string name="profile_namespace">ಮೌಂಟ್ ನೇಮ್‌ಸ್ಪೇಸ್</string>
    <string name="profile_selinux_rules">ನಿಯಮಗಳು</string>
    <string name="profile_groups">ಗುಂಪುಗಳು</string>
    <string name="module">ಮಾಡ್ಯೂಲ್</string>
    <string name="module_author">ಲೇಖಕ</string>
    <string name="about">ಬಗ್ಗೆ</string>
    <string name="home_working_version">ವರ್ಷನ್: %d</string>
    <string name="reboot">ರೀಬೂಟ್</string>
    <string name="home_unsupported_reason">KernelSU ಈಗ GKI ಕರ್ನಲ್‌ಗಳನ್ನು ಮಾತ್ರ ಬೆಂಬಲಿಸುತ್ತದೆ</string>
    <string name="home_selinux_status">SELinux ಸ್ಥಿತಿ</string>
    <string name="module_version">ವರ್ಷನ್</string>
    <string name="home_unsupported">ಬೆಂಬಲಿತವಾಗಿಲ್ಲ</string>
    <string name="profile_selinux_domain">ಡೊಮೇನ್</string>
    <string name="home">ಮನೆ</string>
    <string name="profile_custom">ಕಸ್ಟಮ್</string>
    <string name="profile_template">ಟೆಂಪ್ಲೇಟ್</string>
    <string name="module_downloading">ಮಾಡ್ಯೂಲ್ ಅನ್ನು ಡೌನ್‌ಲೋಡ್ ಮಾಡಲಾಗುತ್ತಿದೆ: %s</string>
    <string name="home_learn_kernelsu">KernelSU ಕಲಿಯಿರಿ</string>
    <string name="module_uninstall_confirm">%s ಮಾಡ್ಯೂಲ್ ಅನ್ನು ಅಸ್ಥಾಪಿಸಲು ನೀವು ಖಚಿತವಾಗಿ ಬಯಸುವಿರಾ\?</string>
    <string name="module_uninstall_failed">ಅನ್‌ಇನ್‌ಸ್ಟಾಲ್ ಮಾಡಲು ವಿಫಲವಾಗಿದೆ: %s</string>
    <string name="superuser">ಸೂಪರ್ಯೂಸರ್</string>
    <string name="home_working">ಕೆಲಸ ಮಾಡುತ್ತಿದೆ</string>
    <string name="module_failed_to_disable">ಮಾಡ್ಯೂಲ್ ಅನ್ನು ನಿಷ್ಕ್ರಿಯಗೊಳಿಸಲು ವಿಫಲವಾಗಿದೆ: %s</string>
    <string name="module_empty">ಮಾಡ್ಯೂಲ್ ಅನ್ನು ಸ್ಥಾಪಿಸಲಾಗಿಲ್ಲ</string>
    <string name="home_kernel">ಕರ್ನಲ್</string>
    <string name="failed_to_update_app_profile">%s ಗಾಗಿ ಅಪ್ಲಿಕೇಶನ್ ಪ್ರೊಫೈಲ್ ಅನ್ನು ನವೀಕರಿಸಲು ವಿಫಲವಾಗಿದೆ</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="about_source_code">%1$s ನಲ್ಲಿ ಮೂಲ ಕೋಡ್ ಅನ್ನು ವೀಕ್ಷಿಸಿ<br/>ನಮ್ಮ %2$s ಚಾನಲ್‌ಗೆ ಸೇರಿ</string>
    <string name="home_manager_version">ಮ್ಯಾನೇಜರ್ ವರ್ಷನ್</string>
    <string name="new_version_available">ಹೊಸ ಆವೃತ್ತಿ: %s ಲಭ್ಯವಿದೆ, ಅಪ್‌ಗ್ರೇಡ್ ಮಾಡಲು ಕ್ಲಿಕ್ ಮಾಡಿ</string>
    <string name="save_log">ಲಾಗ್ಗಳನ್ನು ಉಳಿಸಿ</string>
    <string name="settings_sucompat">su ಬೈನರಿ ಮರುಮಾರ್ಗಗೊಳಿಸಿ</string>
    <string name="settings_sucompat_summary">ಆಪ್ ಪ್ರೊಫೈಲ್‌ನಲ್ಲಿ ಸೂಪರ್‌ಯೂಸರ್ ಅನುಮತಿ ಪಡೆದ ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ /system/bin/su ಅನ್ನು ksud ಗೆ ಮರು ನಿರ್ದೇಶಿಸಿ; ಹೊಸ ಪ್ರಕ್ರಿಯೆಗಳಿಗೆ ಮಾತ್ರ ಪರಿಣಾಮಕಾರಿ.</string>
    <string name="settings_kernel_umount">ಕರ್ನಲ್ ಅನ್‌ಮೌಂಟ್</string>
    <string name="settings_kernel_umount_summary">KernelSU ನಿಂದ ನಿಯಂತ್ರಿಸಲ್ಪಡುವ ಕರ್ನಲ್-ಮಟ್ಟದ ಅನ್‌ಮೌಂಟ್ ನಡವಳಿಕೆ</string>
</resources>

```

`manager/app/src/main/res/values-ko/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">홈</string>
    <string name="home_not_installed">설치되지 않음</string>
    <string name="home_click_to_install">이 곳을 눌러 설치하기</string>
    <string name="home_working">작동 중</string>
    <string name="home_working_version">버전: %d</string>
    <string name="home_unsupported">지원되지 않음</string>
    <string name="home_unsupported_reason">KernelSU는 현재 GKI 커널만 지원합니다.</string>
    <string name="home_kernel">커널 버전</string>
    <string name="home_manager_version">매니저 버전</string>
    <string name="home_fingerprint">핑거프린트</string>
    <string name="home_selinux_status">SELinux 상태</string>
    <string name="selinux_status_disabled">비활성화됨</string>
    <string name="selinux_status_enforcing">강제</string>
    <string name="selinux_status_permissive">허용</string>
    <string name="selinux_status_unknown">알 수 없음</string>
    <string name="superuser">슈퍼유저</string>
    <string name="module_failed_to_enable">모듈 활성화 실패: %s</string>
    <string name="module_failed_to_disable">모듈 비활성화 실패: %s</string>
    <string name="module_empty">설치된 모듈 없음</string>
    <string name="module">모듈</string>
    <string name="uninstall">제거</string>
    <string name="module_install">설치</string>
    <string name="install">설치</string>
    <string name="reboot">다시 시작</string>
    <string name="settings">설정</string>
    <string name="reboot_userspace">빠른 다시 시작</string>
    <string name="reboot_recovery">리커버리로 다시 시작</string>
    <string name="reboot_bootloader">부트로더로 다시 시작</string>
    <string name="reboot_download">다운로드 모드로 다시 시작</string>
    <string name="reboot_edl">EDL 모드로 다시 시작</string>
    <string name="about">정보</string>
    <string name="module_uninstall_confirm">%s 모듈을 삭제할까요?</string>
    <string name="module_uninstall_success">%s 모듈 삭제됨</string>
    <string name="module_uninstall_failed">모듈 삭제 실패: %s</string>
    <string name="module_version">버전</string>
    <string name="module_author">제작자</string>
    <string name="show_system_apps">시스템 앱 표시</string>
    <string name="send_log">로그 보내기</string>
    <string name="safe_mode">안전 모드</string>
    <string name="reboot_to_apply">다시 시작하여 변경 사항 적용</string>
    <string name="module_magisk_conflict">Magisk와 충돌로 모듈을 사용할 수 없습니다!</string>
    <string name="home_learn_kernelsu">KernelSU 알아보기</string>
    <string name="home_click_to_learn_kernelsu">KernelSU 설치 및 모듈 사용 방법을 확인합니다.</string>
    <string name="home_support_title">지원하기</string>
    <string name="home_support_content">KernelSU는 현재와 미래에도 항상 무료이며 오픈 소스입니다. 기부를 통해 여러분의 관심과 지원을 표현해 주세요.</string>
    <string name="about_source_code"><![CDATA[%1$s에서 소스 코드 보기<br/>%2$s 채널 참가하기]]></string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="settings_umount_modules_default_summary">앱 프로필 메뉴의 \"모듈 마운트 해제\" 설정에 대한 전역 기본값을 지정합니다. 활성화하면 개별 프로필이 설정되지 않은 앱에는 시스템에 대한 모듈의 모든 수정 사항이 제외됩니다.</string>
    <string name="restart_app">다시 시작</string>
    <string name="profile_selinux_rules">규칙</string>
    <string name="new_version_available">새 %s 버전을 사용할 수 있습니다, 여기를 눌러 업그레이드하세요!</string>
    <string name="module_start_downloading">다운로드 시작: %s</string>
    <string name="force_stop_app">강제 중지</string>
    <string name="profile_default">기본값</string>
    <string name="profile_custom">사용자 지정</string>
    <string name="profile_template">템플릿</string>
    <string name="profile_name">프로필 이름</string>
    <string name="profile_namespace">마운트 대상 네임스페이스</string>
    <string name="profile_namespace_inherited">상속</string>
    <string name="profile_namespace_global">전역</string>
    <string name="profile_namespace_individual">개별</string>
    <string name="profile_groups">사용자 그룹</string>
    <string name="profile_umount_modules">모듈 마운트 해제를 기본값으로</string>
    <string name="profile_selinux_context">SELinux 컨텍스트</string>
    <string name="profile_capabilities">권한</string>
    <string name="failed_to_update_app_profile">%s에 대한 앱 프로필 업데이트 실패</string>
    <string name="settings_umount_modules_default">모듈 마운트 해제를 기본값으로</string>
    <string name="profile_umount_modules_summary">이 옵션이 활성화되면 KernelSU는 이 앱에 대한 모듈의 모든 수정 사항을 복구합니다.</string>
    <string name="module_update">업데이트</string>
    <string name="module_downloading">모듈 다운로드 중: %s</string>
    <string name="profile_selinux_domain">도메인</string>
    <string name="launch_app">실행</string>
    <string name="failed_to_update_sepolicy">%s 앱에 대한 SELinux 규칙 업데이트 실패</string>
    <string name="save_log">로그 저장</string>
    <string name="module_changelog">업데이트 내역</string>
    <string name="enable_web_debugging_summary">WebUI 디버깅에 사용 가능, 필요한 경우에만 활성화하세요.</string>
    <string name="flashing">플래싱 중</string>
    <string name="selected_lkm">선택된 LKM: %s</string>
    <string name="select_file_tip">%1$s 파티션 이미지가 권장됩니다</string>
    <string name="select_kmi">KMI 선택</string>
    <string name="install_next">다음</string>
    <string name="settings_uninstall_permanent_message">완전하고 영구적으로 KernelSU(루트 권한 및 모든 모듈)를 제거합니다.</string>
    <string name="enable_web_debugging">WebView 디버깅</string>
    <string name="require_kernel_version">현재 KernelSU %1$d 버전은 매니저가 정상 작동하기에 너무 낮습니다. %2$d 버전 이상으로 업그레이드하세요!</string>
    <string name="action">액션</string>
    <string name="settings_uninstall_temporary">임시 제거</string>
    <string name="open">열기</string>
    <string name="install_inactive_slot_warning">재부팅 후 기기가 **강제로** 비활성 슬롯으로 부팅합니다!\nOTA가 완료된 후에만 이 옵션을 사용하세요.\n계속할까요?</string>
    <string name="flash_success">플래싱 성공</string>
    <string name="flash_failed">플래싱 실패</string>
    <string name="settings_uninstall">제거</string>
    <string name="settings_uninstall_permanent">영구 제거</string>
    <string name="settings_uninstall_temporary_message">임시적으로 KernelSU를 제거하고, 다음 재부팅 이후 기존 상태로 복구합니다.</string>
    <string name="settings_profile_template">앱 프로필 템플릿</string>
    <string name="settings_profile_template_summary">로컬 및 온라인의 앱 프로필 템플릿을 관리합니다.</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">잘못된 템플릿 ID</string>
    <string name="app_profile_template_name">이름</string>
    <string name="app_profile_template_description">설명</string>
    <string name="app_profile_template_save">저장</string>
    <string name="app_profile_template_delete">삭제</string>
    <string name="app_profile_template_id_exist">템플릿 ID가 이미 존재합니다!</string>
    <string name="app_profile_import_export">불러오기/내보내기</string>
    <string name="app_profile_import_from_clipboard">클립보드에서 불러오기</string>
    <string name="app_profile_export_to_clipboard">클립보드로 내보내기</string>
    <string name="app_profile_template_import_success">불러오기 성공</string>
    <string name="app_profile_template_save_failed">템플릿 저장 실패</string>
    <string name="app_profile_template_import_empty">클립보드가 비어 있습니다!</string>
    <string name="grant_root_failed">루트 권한 부여 실패!</string>
    <string name="app_profile_template_create">템플릿 생성</string>
    <string name="app_profile_template_edit">템플릿 편집</string>
    <string name="app_profile_template_view">템플릿 보기</string>
    <string name="app_profile_template_export_empty">내보낼 로컬 템플릿을 찾을 수 없습니다!</string>
    <string name="select_file">파일 선택</string>
    <string name="direct_install">직접 설치 (권장)</string>
    <string name="install_inactive_slot">비활성 슬롯에 설치 (OTA 이후)</string>
    <string name="settings_restore_stock_image">제조사 이미지로 복구</string>
    <string name="settings_restore_stock_image_message">제조사 이미지로 복구 (백업 존재 시), OTA 이전에 사용합니다. KernelSU를 제거해야 하는 경우, \"영구 삭제\"를 사용하세요.</string>
    <string name="settings_check_update">업데이트 확인</string>
    <string name="settings_check_update_summary">앱 실행 시 자동으로 업데이트를 확인합니다.</string>
    <string name="log_saved">로그 저장됨</string>
    <string name="module_sort_enabled_first">활성화 우선</string>
    <string name="module_sort_action_first">액션 우선</string>
    <string name="module_install_prompt_with_name">다음 모듈이 설치됩니다: %1$s</string>
    <string name="confirm">확인</string>
    <string name="su_not_allowed">%s에 슈퍼유저 권한을 부여할 수 없습니다</string>
    <string name="settings_module_check_update">모듈 업데이트 확인</string>
    <string name="install_upload_lkm_file">로컬 LKM 파일 사용</string>
    <string name="install_only_support_ko_file">.ko 파일만 지원됩니다</string>
    <string name="processing">처리 중…</string>
    <string name="refresh_pulling">당겨서 새로 고침</string>
    <string name="refresh_release">놓아서 새로 고침</string>
    <string name="refresh_refresh">새로 고침 중…</string>
    <string name="refresh_complete">새로 고침 성공</string>
    <string name="install_select_partition">파티션 선택</string>
    <string name="module_repos">리포지토리</string>
    <string name="module_repos_sort_name">이름 (A → Z)</string>
    <string name="module_repos_source_code">소스 코드</string>
    <string name="metamodule_uninstall_confirm">정말 %s 모듈을 제거할까요? 이 동작은 모든 모듈에 영향을 미치며, 메타모듈에서 제공하는 일부 기능(마운트 등)은 더 이상 작동하지 않습니다.</string>
    <string name="home_gki_warning">v3.0.0 부터, GKI 동작 모드는 테스트 환경에서만 사용됩니다. 일상적인 사용은 권장하지 않으며, 이미지 파일은 더 이상 제공되지 않습니다.</string>
    <string name="app_profile_affects_following_apps">다음 앱에 영향</string>
    <string name="feature_status_unsupported_summary">커널이 이 기능을 지원하지 않습니다.</string>
    <string name="feature_status_managed_summary">이 기능은 모듈에 의해 관리됩니다.</string>
    <string name="undo">되돌리기</string>
    <string name="module_undo_uninstall_success">%s 제거 취소 성공</string>
    <string name="module_undo_uninstall_failed">제거 취소 실패: %s</string>
    <string name="group_contains_apps">%d 앱을 포함</string>
    <string name="settings_theme">테마</string>
    <string name="settings_theme_summary">앱 테마 모드를 선택합니다.</string>
    <string name="settings_theme_mode_system">시스템 설정에 따름</string>
    <string name="settings_theme_mode_light">라이트</string>
    <string name="settings_theme_mode_dark">다크</string>
    <string name="settings_theme_mode_monet_system">Monet (시스템 설정에 따름)</string>
    <string name="settings_theme_mode_monet_light">Monet (라이트)</string>
    <string name="settings_theme_mode_monet_dark">Monet (다크)</string>
    <string name="settings_key_color">주 색상</string>
    <string name="settings_key_color_summary">Monet 사용 시 강조 색상을 사용자 지정합니다.</string>
    <string name="settings_key_color_default">기본값</string>
    <string name="color_blue">파랑</string>
    <string name="color_red">빨강</string>
    <string name="color_green">초록</string>
    <string name="color_purple">보라</string>
    <string name="color_orange">주황</string>
    <string name="color_teal">청록</string>
    <string name="color_pink">분홍</string>
    <string name="color_brown">갈색</string>
    <string name="network_offline">네트워크에 연결되지 않음</string>
    <string name="network_retry">재시도</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">릴리즈</string>
    <string name="tab_info">정보</string>
    <string name="safe_mode_module_disabled">안전 모드에서 모듈 설치가 비활성화됨</string>
    <string name="settings_sucompat">기존 su 명령</string>
    <string name="settings_sucompat_summary">/system/bin/su를 통한 루트 권한 획득 허용 (새 프로세스 전용)</string>
    <string name="settings_kernel_umount">모듈 언마운트</string>
    <string name="settings_kernel_umount_summary">앱 프로필에 따라 커널에서 모듈을 언마운트합니다</string>
</resources>

```

`manager/app/src/main/res/values-lt/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_fingerprint">Pirštų atspaudas</string>
    <string name="selinux_status_disabled">Išjungta</string>
    <string name="selinux_status_enforcing">Priverstinas</string>
    <string name="selinux_status_unknown">Nežinomas</string>
    <string name="superuser">Supernaudotojai</string>
    <string name="module_failed_to_enable">Nepavyko įjungti modulio: %s</string>
    <string name="module_failed_to_disable">Nepavyko išjungti modulio: %s</string>
    <string name="selinux_status_permissive">Leistinas</string>
    <string name="module_empty">Nėra įdiegtų modulių</string>
    <string name="module">Moduliai</string>
    <string name="reboot_userspace">Perkrovimas neišjungus</string>
    <string name="reboot_recovery">Perkrauti į atkūrimo rėžimą</string>
    <string name="reboot_bootloader">Perkrauti į įkrovos tvarkyklę</string>
    <string name="reboot_download">Perkrauti į atsisiuntimo rėžimą</string>
    <string name="about">Apie</string>
    <string name="module_uninstall_failed">Nepavyko išdiegti: %s</string>
    <string name="module_uninstall_success">%s išdiegtas</string>
    <string name="module_version">Versija</string>
    <string name="module_author">Autorius</string>
    <string name="show_system_apps">Rodyti sistemos programas</string>
    <string name="send_log">Siųsti žurnalą</string>
    <string name="reboot">Paleisti iš naujo</string>
    <string name="safe_mode">Saugus rėžimas</string>
    <string name="reboot_to_apply">Paleiskite iš naujo, kad įsigaliotų</string>
    <string name="module_magisk_conflict">Moduliai yra išjungti, nes jie konfliktuoja su Magisk\'s!</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_learn_kernelsu">Sužinokite apie KernelSU</string>
    <string name="home_click_to_learn_kernelsu">Sužinokite, kaip įdiegti KernelSU ir naudoti modulius</string>
    <string name="about_source_code">Peržiūrėkite šaltinio kodą %1$s<br/>Prisijunkite prie mūsų %2$s kanalo</string>
    <string name="profile_default">Numatytas</string>
    <string name="profile_template">Šablonas</string>
    <string name="profile_custom">Pasirinktinis</string>
    <string name="profile_name">Profilio pavadinimas</string>
    <string name="profile_namespace">Prijungti vardų erdvę</string>
    <string name="profile_namespace_inherited">Paveldėtas</string>
    <string name="profile_namespace_global">Globalus</string>
    <string name="profile_namespace_individual">Individualus</string>
    <string name="profile_groups">Grupės</string>
    <string name="profile_capabilities">Galimybės</string>
    <string name="profile_selinux_context">SELinux kontekstas</string>
    <string name="profile_umount_modules">Atjungti modulius</string>
    <string name="settings_umount_modules_default">Atjungti modulius pagal numatytuosius parametrus</string>
    <string name="profile_umount_modules_summary">Įjungus šią parinktį, KernelSU galės atkurti visus modulių modifikuotus failus šiai programai.</string>
    <string name="profile_selinux_domain">Domenas</string>
    <string name="profile_selinux_rules">Taisyklės</string>
    <string name="module_update">Atnaujinti</string>
    <string name="module_downloading">Atsisiunčiamas modulis: %s</string>
    <string name="module_start_downloading">Pradedamas atsisiuntimas: %s</string>
    <string name="new_version_available">Nauja versija: %s pasiekiama, spustelėkite norėdami atsinaujinti</string>
    <string name="launch_app">Paleisti</string>
    <string name="force_stop_app">Priversti sustoti</string>
    <string name="restart_app">Perkrauti</string>
    <string name="failed_to_update_sepolicy">Nepavyko atnaujinti SELinux taisyklių: %s</string>
    <string name="home">Namai</string>
    <string name="home_not_installed">Neįdiegta</string>
    <string name="home_unsupported_reason">KernelSU dabar palaiko tik GKI branduolius</string>
    <string name="home_click_to_install">Spustelėkite norėdami įdiegti</string>
    <string name="home_working">Veikia</string>
    <string name="home_working_version">Versija: %d</string>
    <string name="home_unsupported">Nepalaikoma</string>
    <string name="home_manager_version">Tvarkyklės versija</string>
    <string name="home_kernel">Branduolys</string>
    <string name="home_selinux_status">SELinux statusas</string>
    <string name="uninstall">Išdiegti</string>
    <string name="module_install">Įdiegti</string>
    <string name="install">Įdiegti</string>
    <string name="settings">Parametrai</string>
    <string name="reboot_edl">Perkrauti į EDL</string>
    <string name="module_uninstall_confirm">Ar tikrai norite išdiegti modulį %s\?</string>
    <string name="home_support_title">Paremkite mus</string>
    <string name="home_support_content">KernelSU yra ir visada bus nemokamas ir atvirojo kodo. Tačiau galite parodyti, kad jums rūpi, paaukodami mums.</string>
    <string name="failed_to_update_app_profile">Nepavyko atnaujinti programos profilio %s</string>
    <string name="settings_umount_modules_default_summary">Visuotinė numatytoji „Modulių atjungimo“ reikšmė programų profiliuose. Jei įjungta, ji pašalins visus sistemos modulio pakeitimus programoms, kurios neturi profilio.</string>
    <string name="module_changelog">Keitimų žurnalas</string>
    <string name="require_kernel_version">Ši KernelSU versija %1$d yra per žema, kad šis vadybininkas galėtų tinkamai funkcionuoti. Prašome atsinaujinti į versiją %2$d ar aukščiau!</string>
    <string name="save_log">Saglabāt Žurnālus</string>
    <string name="settings_sucompat">Nukreipti su dvejetainį failą</string>
    <string name="settings_sucompat_summary">Nukreipti /system/bin/su į ksud programoms, kurioms suteiktas Superuser leidimas programos profilyje; veiksminga tik naujiems procesams.</string>
    <string name="settings_kernel_umount">Branduolio atjungimas</string>
    <string name="settings_kernel_umount_summary">Branduolio lygio atjungimo elgsena, valdoma KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-lv/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="profile_umount_modules_summary">Iespējojot šo opciju, KernelSU varēs atjaunot visus moduļos šīs lietojumprogrammas modificētos failus.</string>
    <string name="failed_to_update_sepolicy">Neizdevās atjaunināt SELinux noteikumus: %s</string>
    <string name="settings_profile_template_summary">Pārvaldiet vietējo un tiešsaistes lietotņu profila veidni</string>
    <string name="app_profile_template_id_invalid">Nederīgs veidnes id</string>
    <string name="app_profile_template_id_exist">veidnes id jau pastāv!</string>
    <string name="app_profile_export_to_clipboard">Eksportēt starpliktuvē</string>
    <string name="app_profile_import_from_clipboard">Importēt no starpliktuves</string>
    <string name="app_profile_template_import_success">Importēts veiksmīgi</string>
    <string name="home">Sākums</string>
    <string name="home_not_installed">Nav uzstādīts</string>
    <string name="home_click_to_install">Noklikšķiniet, lai uzstādītu</string>
    <string name="home_working">Darbojas</string>
    <string name="home_working_version">Versija: %d</string>
    <string name="home_unsupported">Neatbalstīts</string>
    <string name="home_unsupported_reason">KernelSU pagaidām atbalsta tikai GKI kodolus</string>
    <string name="home_kernel">Kodols</string>
    <string name="home_manager_version">Pārvaldnieka versija</string>
    <string name="home_fingerprint">Pirkstu nospiedums</string>
    <string name="home_selinux_status">SELinux statuss</string>
    <string name="selinux_status_enforcing">Piespiests</string>
    <string name="selinux_status_disabled">Atspējots</string>
    <string name="selinux_status_unknown">Nezināms</string>
    <string name="superuser">Superlietotājs</string>
    <string name="module_failed_to_disable">Neizdevās atspējot moduli: %s</string>
    <string name="module_empty">Nav uzstādīts neviens modulis</string>
    <string name="module">Moduļi</string>
    <string name="uninstall">Noņemt</string>
    <string name="install">Uzstādīšana</string>
    <string name="reboot">Restartēt</string>
    <string name="settings">Iestatījumi</string>
    <string name="reboot_userspace">Ātri restartēt</string>
    <string name="reboot_bootloader">Restartēt uz Sāknēšanas režīmu</string>
    <string name="reboot_recovery">Restartēt uz Atkopšanas režīmu</string>
    <string name="reboot_download">Restartēt uz Lejupielādes režīmu</string>
    <string name="reboot_edl">Restartēt uz EDL režīmu</string>
    <string name="about">Par lietotni</string>
    <string name="module_uninstall_success">%s noņemts</string>
    <string name="module_uninstall_failed">Neizdevās noņemt: %s</string>
    <string name="module_author">Autors</string>
    <string name="show_system_apps">Rādīt sistēmas lietotnes</string>
    <string name="send_log">Sūtīt žurnālus</string>
    <string name="reboot_to_apply">Restartējiet, lai stātos spēkā</string>
    <string name="home_learn_kernelsu">Uzzināt par KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Uzzināt, kā instalēt KernelSU un izmantot moduļus</string>
    <string name="home_support_title">Atbalsti mūs</string>
    <string name="about_source_code">Skatiet avota kodu vietnē %1$s<br/> Pievienojies mūsu %2$s kanālam</string>
    <string name="profile_default">Noklusējums</string>
    <string name="profile_template">Veidne</string>
    <string name="profile_custom">Pielāgots</string>
    <string name="profile_name">Profila vārds</string>
    <string name="profile_namespace">Mount nosaukumvieta</string>
    <string name="profile_namespace_individual">Individuāls</string>
    <string name="profile_capabilities">Iespējas</string>
    <string name="profile_selinux_context">SELinux konteksts</string>
    <string name="profile_umount_modules">Atvienot moduļus</string>
    <string name="failed_to_update_app_profile">Neizdevās atjaunināt lietotnes profilu %s</string>
    <string name="settings_umount_modules_default">Pēc noklusējuma atvienot moduļus</string>
    <string name="settings_umount_modules_default_summary">Globālā noklusējuma vērtība vienumam “Atvienot moduļus” lietotņu profilos. Ja tas ir iespējots, lietojumprogrammām, kurām nav iestatīts profils, tiks noņemtas visas sistēmas moduļu modifikācijas.</string>
    <string name="profile_selinux_domain">Domēns</string>
    <string name="profile_selinux_rules">Noteikumi</string>
    <string name="module_update">Atjaunināt</string>
    <string name="module_downloading">Lejupielādē moduli: %s</string>
    <string name="module_start_downloading">Sākt lejupielādi: %s</string>
    <string name="new_version_available">Jaunā versija: %s ir pieejama, noklikšķiniet, lai atjauninātu</string>
    <string name="launch_app">Palaist</string>
    <string name="force_stop_app">Piespiedu apstāšana</string>
    <string name="restart_app">Restartēt aplikāciju</string>
    <string name="module_changelog">Izmaiņu žurnāls</string>
    <string name="settings_profile_template">Lietotnes profila veidne</string>
    <string name="app_profile_template_create">Izveidot veidni</string>
    <string name="app_profile_template_edit">Rediģēt veidni</string>
    <string name="app_profile_template_id">id</string>
    <string name="app_profile_template_name">Vārds</string>
    <string name="app_profile_template_description">Apraksts</string>
    <string name="app_profile_template_save">Saglabāt</string>
    <string name="app_profile_template_delete">Dzēst</string>
    <string name="app_profile_template_view">Skatīt veidni</string>
    <string name="app_profile_import_export">Importēt/Eksportēt</string>
    <string name="app_profile_template_export_empty">Nevar atrast vietējo eksportējamo veidni!</string>
    <string name="app_profile_template_save_failed">Neizdevās saglabāt veidni</string>
    <string name="app_profile_template_import_empty">Starpliktuve ir tukša!</string>
    <string name="selinux_status_permissive">Visatļautība</string>
    <string name="module_failed_to_enable">Neizdevās iespējot moduli: %s</string>
    <string name="module_install">Uzstādīt</string>
    <string name="module_uninstall_confirm">Vai tiešām vēlaties noņemt %s moduli?</string>
    <string name="module_version">Versija</string>
    <string name="safe_mode">Drošais režīms</string>
    <string name="module_magisk_conflict">Moduļi nav pieejami dēļ konflikta ar Magisk!</string>
    <string name="home_support_content">KernelSU ir un vienmēr būs bezmaksas un atvērtā koda. Tomēr jūs varat parādīt mums, ka jums rūp, veicot ziedojumu.</string>
    <string name="profile_groups">Grupas</string>
    <string name="profile_namespace_global">Globāli</string>
    <string name="require_kernel_version">Pašreizējā KernelSU versija %1$d ir pārāk zema, lai pārvaldnieks darbotos pareizi. Lūdzu, atjauniniet uz versiju %2$d vai jaunāku!</string>
    <string name="enable_web_debugging">Iespējot WebView atkļūdošanu</string>
    <string name="select_file_tip">Ieteicams %1$s nodalījuma attēls</string>
    <string name="install_next">Nākamais</string>
    <string name="profile_namespace_inherited">Mantots</string>
    <string name="select_file">Izvēlieties failu</string>
    <string name="install_inactive_slot">Instalēt neaktīvajā slotā (pēc OTA)</string>
    <string name="install_inactive_slot_warning">Pēc restartēšanas jūsu ierīce tiks **PIESPIESTI** palaista pašreizējā neaktīvajā slotā!
\nIzmantojiet šo opciju tikai pēc OTA pabeigšanas
\nTurpināt?</string>
    <string name="direct_install">Tiešā instalēšana (Ieteicams)</string>
    <string name="settings_uninstall">Atinstalēt</string>
    <string name="settings_uninstall_temporary">Pagaidu atinstalēšana</string>
    <string name="settings_restore_stock_image">Atjaunot oriģinālo attēlu</string>
    <string name="settings_uninstall_temporary_message">Īslaicīgi atinstalēt KernelSU, pēc nākamās restartēšanas atjaunot sākotnējo stāvokli.</string>
    <string name="settings_uninstall_permanent_message">KernelSU (saknes un visu moduļu) pilnīga atinstalēšana.</string>
    <string name="settings_restore_stock_image_message">Atjaunojot rūpnīcas attēlu (ja ir dublējums), ko parasti izmanto pirms OTA; ja nepieciešams atinstalēt KernelSU, lūdzu, izmantojiet \"Neatgriezeniski atinstalēt\".</string>
    <string name="selected_lkm">Izvēlētais lkm: %s</string>
    <string name="grant_root_failed">Neizdevās piešķirt sakni!</string>
    <string name="open">Atvērt</string>
    <string name="settings_check_update">Pārbaudīt atjauninājumus</string>
    <string name="settings_check_update_summary">Automātiski pārbaudīt atjauninājumus atverot aplikāciju</string>
    <string name="enable_web_debugging_summary">Var izmantot WebUI atkļūdošanai, lūdzu, izmantot tikai tad, kad tas ir nepieciešams.</string>
    <string name="select_kmi">Izvēlieties KMI</string>
    <string name="settings_uninstall_permanent">Neatgriezeniski atinstalēt</string>
    <string name="flashing">Instalē</string>
    <string name="flash_success">Instalēts veiksmīgi</string>
    <string name="flash_failed">Instalēšana neizdevās</string>
    <string name="save_log">Išsaugoti Žurnalus</string>
    <string name="module_sort_enabled_first">Kārtot (Iespējotie augšgalā)</string>
    <string name="confirm">Apstiprināt</string>
    <string name="module_install_prompt_with_name">Tiks uzstādīti šādi moduļi : %1$s</string>
    <string name="settings_sucompat">Pārvirzīt su bināro failu</string>
    <string name="settings_sucompat_summary">Pārvirzīt /system/bin/su uz ksud lietotnēm, kurām piešķirta Superuser atļauja lietotnes profilā; efektīva tikai jauniem procesiem.</string>
    <string name="settings_kernel_umount">Kodola atvienošana</string>
    <string name="settings_kernel_umount_summary">Kodola līmeņa atvienošanas uzvedība, ko kontrolē KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-mr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_not_installed">इंस्टॉल केले नाही</string>
    <string name="home">होम</string>
    <string name="home_click_to_install">इंस्टॉल साठी क्लिक करा</string>
    <string name="home_working">कार्यरत</string>
    <string name="home_working_version">आवृत्ती: %d</string>
    <string name="home_unsupported">असमर्थित</string>
    <string name="home_unsupported_reason">KernelSU आता फक्त GKI कर्नलचे समर्थन करते</string>
    <string name="home_kernel">कर्नल</string>
    <string name="home_fingerprint">फिंगरप्रिंट</string>
    <string name="home_manager_version">व्यवस्थापक आवृत्ती</string>
    <string name="home_selinux_status">SELinux स्थिती</string>
    <string name="selinux_status_disabled">अक्षम</string>
    <string name="selinux_status_enforcing">एनफोर्सिंग</string>
    <string name="selinux_status_permissive">परमिसिव</string>
    <string name="selinux_status_unknown">अज्ञात</string>
    <string name="install">स्थापित करा</string>
    <string name="module_empty">कोणतेही मॉड्यूल स्थापित केलेले नाही</string>
    <string name="reboot">रीबूट करा</string>
    <string name="superuser">सुपरयुझर</string>
    <string name="module_failed_to_enable">मॉड्यूल सक्षम करण्यात अयशस्वी: %s</string>
    <string name="uninstall">विस्थापित करा</string>
    <string name="module_failed_to_disable">मॉड्यूल अक्षम करण्यात अयशस्वी: %s</string>
    <string name="module">मॉड्यूल</string>
    <string name="module_install">स्थापित करा</string>
    <string name="settings">सेटिंग्ज</string>
    <string name="reboot_userspace">सॉफ्ट रीबूट</string>
    <string name="about">बद्दल</string>
    <string name="reboot_edl">EDL वर रीबूट करा</string>
    <string name="module_uninstall_confirm">तुमची खात्री आहे की तुम्ही मॉड्यूल %s विस्थापित करू इच्छिता\?</string>
    <string name="module_uninstall_failed">विस्थापित करण्यात अयशस्वी: %s</string>
    <string name="show_system_apps">सिस्टम अॅप्स दाखवा</string>
    <string name="reboot_bootloader">बूटलोडरवर रीबूट करा</string>
    <string name="module_uninstall_success">%s विस्थापित</string>
    <string name="module_version">आवृत्ती</string>
    <string name="module_author">लेखक</string>
    <string name="reboot_recovery">रिकवरी मध्ये रिबुट करा</string>
    <string name="reboot_download">डाउनलोड करण्यासाठी रीबूट करा</string>
    <string name="send_log">लॉग पाठवा</string>
    <string name="safe_mode">सुरक्षित मोड</string>
    <string name="reboot_to_apply">प्रभावी होण्यासाठी रीबूट करा</string>
    <string name="home_learn_kernelsu">KernelSU शिका</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="module_magisk_conflict">मॉड्यूल अक्षम केले आहेत कारण ते Magisk च्या विरोधाभास आहे!</string>
    <string name="home_click_to_learn_kernelsu">KernelSU कसे स्थापित करायचे आणि मॉड्यूल कसे वापरायचे ते शिका</string>
    <string name="home_support_content">KernelSU विनामूल्य आणि मुक्त स्रोत आहे, आणि नेहमीच असेल. तथापि, देणगी देऊन तुम्ही आम्हाला दाखवू शकता की तुमची काळजी आहे.</string>
    <string name="home_support_title">आम्हाला पाठिंबा द्या</string>
    <string name="profile_custom">कस्टम</string>
    <string name="profile_namespace">माउंट नेमस्पेस</string>
    <string name="profile_default">डीफॉल्ट</string>
    <string name="profile_template">साचा</string>
    <string name="profile_namespace_individual">वैयक्तिक</string>
    <string name="profile_capabilities">क्षमता</string>
    <string name="about_source_code">%1$s वर स्रोत कोड पहा<br/>आमच्या %2$s चॅनेलमध्ये सामील व्हा</string>
    <string name="profile_name">प्रोफाइल नाव</string>
    <string name="profile_namespace_inherited">इनहेरीटेड</string>
    <string name="profile_namespace_global">जागतिक</string>
    <string name="profile_groups">गट</string>
    <string name="profile_selinux_context">SELinux संदर्भ</string>
    <string name="profile_umount_modules">उमाउंट मॉड्यूल्स</string>
    <string name="failed_to_update_app_profile">%s साठी अॅप प्रोफाइल अपडेट करण्यात अयशस्वी</string>
    <string name="settings_umount_modules_default">डीफॉल्टनुसार मॉड्यूल्स उमाउंट करा</string>
    <string name="settings_umount_modules_default_summary">अॅप प्रोफाइलमधील \"उमाउंट मॉड्यूल्स\" साठी जागतिक डीफॉल्ट मूल्य. सक्षम असल्यास, ते प्रोफाइल सेट नसलेल्या ॲप्लिकेशनचे सिस्टममधील सर्व मॉड्यूल बदल काढून टाकेल.</string>
    <string name="profile_umount_modules_summary">हा पर्याय सक्षम केल्याने KernelSU ला या ऍप्लिकेशनसाठी मॉड्यूल्सद्वारे कोणत्याही सुधारित फाइल्स पुनर्संचयित करण्यास अनुमती मिळेल.</string>
    <string name="failed_to_update_sepolicy">यासाठी SELinux नियम अपडेट करण्यात अयशस्वी: %s</string>
    <string name="profile_selinux_rules">नियम</string>
    <string name="module_update">अपडेट करा</string>
    <string name="profile_selinux_domain">डोमेन</string>
    <string name="module_downloading">मॉड्यूल डाउनलोड करत आहे: %s</string>
    <string name="module_start_downloading">डाउनलोड करणे सुरू करा: %s</string>
    <string name="new_version_available">नवीन आवृत्ती: %s उपलब्ध आहे, डाउनलोड करण्यासाठी क्लिक करा</string>
    <string name="force_stop_app">सक्तीने थांबा</string>
    <string name="launch_app">लाँच करा</string>
    <string name="restart_app">पुन्हा सुरू करा</string>
    <string name="save_log">लॉग जतन करा</string>
    <string name="settings_sucompat">su बाइनरी पुन्हा मार्गस्थ करा</string>
    <string name="settings_sucompat_summary">ॲप प्रोफाईलमध्ये सुपरयुझर परवानगी दिलेल्या ॲप्ससाठी /system/bin/su ला ksud वर पुनर्निर्देशित करा; फक्त नवीन प्रक्रियांसाठी प्रभावी.</string>
    <string name="settings_kernel_umount">कर्नल अनमाउंट</string>
    <string name="settings_kernel_umount_summary">KernelSU द्वारे नियंत्रित कर्नल-स्तरीय अनमाउंट वर्तन</string>
</resources>

```

`manager/app/src/main/res/values-ms/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="selinux_status_unknown">Tidak Diketahui</string>
    <string name="selinux_status_disabled">Lumpuhkan</string>
    <string name="selinux_status_permissive">Permisif</string>
    <string name="reboot_download">Reboot ke Download</string>
    <string name="module_failed_to_enable">Modul tidak berjaya diaktifkan: %s</string>
    <string name="reboot_edl">Reboot ke EDL</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="home_fingerprint">Cap Jari</string>
    <string name="reboot_recovery">Reboot ke Recovery</string>
    <string name="reboot_userspace">Soft Reboot</string>
    <string name="uninstall">Padam</string>
    <string name="module_install">Pasang</string>
    <string name="home_click_to_install">Tekan untuk memasang</string>
    <string name="module">Modul</string>
    <string name="about">Tentang</string>
    <string name="home_working_version">Versi: %d</string>
    <string name="reboot">Reboot</string>
    <string name="home_unsupported_reason">KernelSU ketika ini hanya menyokong kernel GKI</string>
    <string name="home_selinux_status">Status SELinux</string>
    <string name="home_unsupported">Tidak Disokong</string>
    <string name="home">Layar Utama</string>
    <string name="module_uninstall_confirm">Apakah anda pasti ingin membuang modul %s\?</string>
    <string name="superuser">Superuser</string>
    <string name="settings">Tetapan</string>
    <string name="home_working">Berjalan</string>
    <string name="module_failed_to_disable">Gagal mematikan modul: %s</string>
    <string name="module_empty">Tiada modul dipasang</string>
    <string name="install">Pasang</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_not_installed">Tidak terpasang</string>
    <string name="reboot_bootloader">Reboot ke Bootloader</string>
    <string name="home_manager_version">Versi manager</string>
    <string name="save_log">Simpan Log</string>
    <string name="settings_sucompat">Ubaḥ hala binari su</string>
    <string name="settings_sucompat_summary">Ubaḥ hala /system/bin/su ke ksud untuk aplikasi yang diberikan kebenaran Superuser dalam Profil Aplikasi; berkesan untuk proses baharu sahaja.</string>
    <string name="settings_kernel_umount">Umount kernel</string>
    <string name="settings_kernel_umount_summary">Tingkah laku umount peringkat kernel dikawal oleh KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-my/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="settings_sucompat">su binary လမ်းကြောင်းပြောင်းမည်</string>
    <string name="settings_sucompat_summary">အက်ပ်ပရိုဖိုင်တွင် Superuser ခွင့်ပြုချက် ပေးထားသော အက်ပ်များအတွက် /system/bin/su ကို ksud သို့ လမ်းကြောင်းပြောင်းမည်; လုပ်ငန်းစဉ်အသစ်များအတွက်သာ ထိရောက်မှုရှိသည်။</string>
    <string name="settings_kernel_umount">Kernel ဖြုတ်မည်</string>
    <string name="settings_kernel_umount_summary">KernelSU မှ ထိန်းချုပ်ထားသော Kernel အဆင့် ဖြုတ်မည့် အပြုအမူ</string>
</resources>

```

`manager/app/src/main/res/values-night/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">

    <style name="Theme.KernelSU" parent="android:Theme.Material.NoActionBar">
        <item name="android:windowLayoutInDisplayCutoutMode" tools:targetApi="o_mr1">shortEdges</item>
    </style>

    <style name="Theme.KernelSU.WebUI" parent="Theme.KernelSU" />

</resources>
```

`manager/app/src/main/res/values-nl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Home</string>
    <string name="home_not_installed">Niet geïnstalleerd</string>
    <string name="home_click_to_install">Klik om te installeren</string>
    <string name="home_working">Werkend</string>
    <string name="home_working_version">Versie: %d</string>
    <string name="home_unsupported">Niet ondersteund</string>
    <string name="home_unsupported_reason">KernelSU ondersteunt alleen GKI kernels</string>
    <string name="home_kernel">Kernel version</string>
    <string name="home_manager_version">Manager versie</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">SELinux status</string>
    <string name="selinux_status_disabled">Uitgeschakeld</string>
    <string name="selinux_status_enforcing">Afgedwongen</string>
    <string name="selinux_status_permissive">Permissief</string>
    <string name="selinux_status_unknown">Niet gekend</string>
    <string name="superuser">Supergebruiker</string>
    <string name="module_failed_to_enable">Mislukt om module in te schakelen: %s</string>
    <string name="module_failed_to_disable">Mislukt om module uit te schakelen: %s</string>
    <string name="module_empty">Geen module geïnstalleerde</string>
    <string name="module">Module</string>
    <string name="uninstall">Verwijderen</string>
    <string name="module_install">Installeren</string>
    <string name="install">Installeren</string>
    <string name="reboot">Herstart</string>
    <string name="settings">Instellingen</string>
    <string name="reboot_userspace">Soft herstart</string>
    <string name="reboot_recovery">Herstart naar Recovery</string>
    <string name="reboot_bootloader">Herstart naar Bootloader</string>
    <string name="reboot_download">Herstart om te downloaden</string>
    <string name="reboot_edl">Herstart naar EDL</string>
    <string name="about">Over</string>
    <string name="module_uninstall_confirm">Zeker van het verwijderen van module %s?</string>
    <string name="module_uninstall_success">%s verwijderd</string>
    <string name="module_uninstall_failed">Mislukt om te verwijderen: %s</string>
    <string name="module_version">Versie</string>
    <string name="module_author">Auteur</string>
    <string name="show_system_apps">Toon systeem apps</string>
    <string name="send_log">Verzenden Logs</string>
    <string name="safe_mode">Safe mode</string>
    <string name="reboot_to_apply">Herstart om effect te hebben</string>
    <string name="module_magisk_conflict">Modules zijn niet beschikbaar vanwege een conflict met Magisk!</string>
    <string name="home_learn_kernelsu">Leer KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Leer hoe KernelSU te installeren en modules te gebruiken</string>
    <string name="home_support_title">Ondersteun ons</string>
    <string name="home_support_content">KernelSU is en blijft gratis en open source. U kunt ons echter laten zien dat u ons steunt door een donatie te doen.</string>
    <string name="about_source_code"><![CDATA[Bekijk source code op %1$s<br/>Vervoeg ons %2$s kanaal]]></string>
    <string name="profile" translatable="false">App profiel</string>
    <string name="profile_default">Standaard</string>
    <string name="profile_template">Sjabloon</string>
    <string name="profile_custom">Aangepast</string>
    <string name="profile_name">Profiel naam</string>
    <string name="profile_namespace">Koppel naamruimte</string>
    <string name="profile_namespace_inherited">Overgenomen</string>
    <string name="profile_namespace_global">Globaal</string>
    <string name="profile_namespace_individual">Individuëel</string>
    <string name="profile_groups">Groepen</string>
    <string name="profile_capabilities">Mogelijkheden</string>
    <string name="profile_selinux_context">SELinux context</string>
    <string name="profile_umount_modules">Ontkoppel modules</string>
    <string name="failed_to_update_app_profile">Mislukt om App Profiel te updaten voor %s</string>
    <string name="settings_umount_modules_default">Ontkoppel standaard de modules</string>
    <string name="settings_umount_modules_default_summary">De globale standaardwaarde voor \"Umount modules\" in App Profile. Als dit is ingeschakeld, worden alle modulewijzigingen in het systeem verwijderd voor apps waarvoor geen profiel is ingesteld.</string>
    <string name="profile_umount_modules_summary">Met deze optie ingeschakeld zal KernelSU toelaten om alle gewijzigde bestanden door de modules voor deze app te herstellen.</string>
    <string name="profile_selinux_domain">Domein</string>
    <string name="profile_selinux_rules">Regels</string>
    <string name="module_update">Update</string>
    <string name="module_downloading">Downloaden van module: %s</string>
    <string name="new_version_available">Nieuwe versie %s is beschikbaar,klik om te upgraden!</string>
    <string name="launch_app">Start</string>
    <string name="force_stop_app">Forceer stop</string>
    <string name="restart_app">Herstart</string>
    <string name="module_start_downloading">Begin met downloaden: %s</string>
    <string name="failed_to_update_sepolicy">Kan SELinux-regels niet bijwerken voor %s</string>
    <string name="require_kernel_version">De huidige KernelSU-versie %1$d is te laag voor de manager om goed te werken. Upgrade naar versie %2$d of hoger!</string>
    <string name="module_changelog">wijzigings logboek</string>
    <string name="settings_profile_template">App-profiel sjabloon</string>
    <string name="app_profile_template_create">Maken sjabloon</string>
    <string name="app_profile_template_edit">Bewerkin sjabloon</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Ongeldige sjabloon ID</string>
    <string name="app_profile_template_name">Naam</string>
    <string name="app_profile_template_save">Redde</string>
    <string name="app_profile_template_view">Bekijken sjabloon</string>
    <string name="app_profile_template_description">Beschrijving</string>
    <string name="settings_profile_template_summary">Beheer lokale en online sjabloon van app-profiel.</string>
    <string name="app_profile_template_delete">Verwijderen</string>
    <string name="app_profile_template_id_exist">Sjabloon ID bestaat al!</string>
    <string name="app_profile_template_save_failed">Mislukt naar opslaan sjabloon</string>
    <string name="app_profile_template_import_empty">Klembord is leeg!</string>
    <string name="app_profile_import_export">Importeren/Exporteren</string>
    <string name="app_profile_import_from_clipboard">Importeren vanaf klembord</string>
    <string name="app_profile_export_to_clipboard">Exporteren naar klembord</string>
    <string name="settings_check_update">Controleer for updates</string>
    <string name="enable_web_debugging">WebView foutopsporing</string>
    <string name="enable_web_debugging_summary">Kan worden gebruikt om WebUI te debuggen. Schakel dit alleen in als dat nodig is.</string>
    <string name="app_profile_template_export_empty">Kan niet geen lokale sjabloon vinden om te exporteren!</string>
    <string name="app_profile_template_import_success">Succesvol geïmporteerd</string>
    <string name="open">Open</string>
    <string name="settings_check_update_summary">Controleer automatisch op updates bij het openen van de app.</string>
    <string name="direct_install">Directe installatie (aanbevolen)</string>
    <string name="select_file">Selecteer een bestand</string>
    <string name="grant_root_failed">Kan geen root verlenen!</string>
    <string name="select_file_tip">%1$s partitie-image wordt aanbevolen</string>
    <string name="install_next">Naast</string>
    <string name="install_inactive_slot_warning">Uw apparaat wordt **GEFORCEERD** om na een herstart op te starten naar het huidige inactieve slot!
\nGebruik deze optie alleen nadat OTA is voltooid.
\nDoorgaan?</string>
    <string name="install_inactive_slot">Installeren in inactief slot (na OTA)</string>
    <string name="select_kmi">KMI selecteren</string>
    <string name="settings_uninstall">Desinstalleren</string>
    <string name="settings_uninstall_temporary">Tijdelijk verwijderen</string>
    <string name="settings_uninstall_permanent">Permanent verwijderen</string>
    <string name="settings_restore_stock_image">Herstel stockafbeelding</string>
    <string name="settings_uninstall_temporary_message">Verwijder KernelSU tijdelijk en herstel het naar de oorspronkelijke staat na de volgende herstart.</string>
    <string name="settings_uninstall_permanent_message">Het verwijderen van KernelSU (root en alle modules) volledig en permanent.</string>
    <string name="settings_restore_stock_image_message">Herstel de standaard fabrieksimage (als er een back-up bestaat), die normaal gesproken vóór OTA wordt gebruikt. Als u KernelSU moet verwijderen, gebruikt u permanent verwijderen.</string>
    <string name="flashing">Knipperen</string>
    <string name="save_log">Logboeken Opslaan</string>
    <string name="flash_success">Flash-succes</string>
    <string name="flash_failed">Flash is mislukt</string>
    <string name="selected_lkm">Geselecteerde LKM: %s</string>
    <string name="action">Actie</string>
    <string name="log_saved">Logs opgeslagen</string>
    <string name="module_sort_enabled_first">Sorteren (eerst ingeschakeld)</string>
    <string name="module_sort_action_first">Sorteren (actie eerst)</string>
    <string name="module_install_prompt_with_name">De volgende modules worden geïnstalleerd: %1$s</string>
    <string name="su_not_allowed">Kan geen Superuser-toegang verlenen aan %s</string>
    <string name="confirm">Bevestigen</string>
    <string name="settings_module_check_update">Controleer op module-updates</string>
    <string name="install_upload_lkm_file">Gebruik lokaal LKM-bestand</string>
    <string name="install_only_support_ko_file">Alleen .ko bestanden worden ondersteund</string>
    <string name="settings_sucompat">su binary omleiden</string>
    <string name="settings_sucompat_summary">Stelt apps met Superuser-toestemming in App Profiel in staat om een superuser-shell te verkrijgen door /system/bin/su uit te voeren; alleen effectief voor nieuwe processen.</string>
    <string name="settings_kernel_umount">Kernel ontkoppelen</string>
    <string name="settings_kernel_umount_summary">Kernel-niveau ontkoppelgedrag beheerd door KernelSU</string>
    <string name="processing">Verwerken…</string>
    <string name="refresh_pulling">Trek omlaag om te vernieuwen</string>
    <string name="refresh_release">Vrijgeven om te vernieuwen</string>
    <string name="refresh_refresh">Verfrissend…</string>
    <string name="refresh_complete">Succesvol vernieuwd</string>
</resources>

```

`manager/app/src/main/res/values-pl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name" translatable="false">KernelSU</string>
    <string name="home">Strona główna</string>
    <string name="home_not_installed">Nie zainstalowano</string>
    <string name="home_click_to_install">Kliknij, aby zainstalować</string>
    <string name="home_working">Działa</string>
    <string name="home_working_version">Wersja: %d</string>
    <string name="home_unsupported">Nieobsługiwany</string>
    <string name="home_unsupported_reason">KernelSU obsługuje obecnie tylko jądra GKI.</string>
    <string name="home_kernel">Wersja jądra</string>
    <string name="home_manager_version">Wersja menedżera</string>
    <string name="home_fingerprint">Odcisk</string>
    <string name="home_selinux_status">Status SELinux</string>
    <string name="selinux_status_disabled">Wyłączony</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Dozwolony</string>
    <string name="selinux_status_unknown">Nieznany</string>
    <string name="superuser">Superużytkownik</string>
    <string name="module_failed_to_enable">Nie udało się włączyć modułu: %s</string>
    <string name="module_failed_to_disable">Nie udało się wyłączyć modułu: %s</string>
    <string name="module_empty">Brak zainstalowanych modułów</string>
    <string name="module">Moduły</string>
    <string name="uninstall">Odinstaluj</string>
    <string name="module_install">Instaluj</string>
    <string name="install">Instaluj</string>
    <string name="reboot">Uruchom ponownie</string>
    <string name="settings">Ustawienia</string>
    <string name="reboot_userspace">Miękki restart</string>
    <string name="reboot_recovery">Restart do trybu Recovery</string>
    <string name="reboot_bootloader">Restart do trybu Bootloader</string>
    <string name="reboot_download">Restart do trybu Download</string>
    <string name="reboot_edl">Restart do trybu EDL</string>
    <string name="about">Informacje</string>
    <string name="module_uninstall_confirm">Czy na pewno chcesz odinstalować moduł %s?</string>
    <string name="module_uninstall_success">Odinstalowano %s</string>
    <string name="module_uninstall_failed">Nie udało się odinstalować: %s</string>
    <string name="module_version">Wersja</string>
    <string name="module_author">Autor</string>
    <string name="show_system_apps">Pokaż aplikacje systemowe</string>
    <string name="send_log">Wyślij logi</string>
    <string name="safe_mode">Tryb bezpieczny</string>
    <string name="reboot_to_apply">Uruchom ponownie, aby zastosować zmiany</string>
    <string name="module_magisk_conflict">Moduły są niedostępne z powodu konfliktu z Magiskiem!</string>
    <string name="home_learn_kernelsu">Poznaj KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Dowiedz się jak zainstalować KernelSU i jak korzystać z modułów.</string>
    <string name="home_support_title">Wesprzyj nas</string>
    <string name="home_support_content">KernelSU jest i zawsze będzie darmowy oraz otwarty. Niemniej jednak możesz nam pokazać, że Ci zależy, wysyłając darowiznę.</string>
    <string name="about_source_code"><![CDATA[Przejrzyj kod źródłowy na %1$s<br/>Dołącz do kanału %2$s]]></string>
    <string name="profile" translatable="false">Profil aplikacji</string>
    <string name="profile_default">Domyślny</string>
    <string name="profile_template">Szablon</string>
    <string name="profile_custom">Własny</string>
    <string name="profile_name">Nazwa profilu</string>
    <string name="profile_namespace">Przestrzeń nazw montowania</string>
    <string name="profile_namespace_inherited">Odziedziczona</string>
    <string name="profile_namespace_global">Globalna</string>
    <string name="profile_namespace_individual">Indywidualna</string>
    <string name="profile_groups">Grupy</string>
    <string name="profile_capabilities">Uprawnienia</string>
    <string name="profile_selinux_context">Kontekst SELinux</string>
    <string name="profile_umount_modules">Odmontuj moduły</string>
    <string name="failed_to_update_app_profile">Nie udało się zaktualizować profilu aplikacji dla %s</string>
    <string name="settings_umount_modules_default">Domyślnie odmontowuj moduły</string>
    <string name="settings_umount_modules_default_summary">Globalna wartość domyślna opcji \"Odmontuj moduły\" w profilu aplikacji. Jeśli jest włączona, wycofuje wszystkie modyfikacje dokonane przez moduły dla aplikacji, które nie mają ustawionego profilu.</string>
    <string name="profile_umount_modules_summary">Włączenie tej opcji umożliwi KernelSU przywrócenie wszelkich zmodyfikowanych plików przez moduły dla tej aplikacji.</string>
    <string name="profile_selinux_domain">Domena</string>
    <string name="profile_selinux_rules">Reguły</string>
    <string name="module_update">Zaktualizuj</string>
    <string name="module_downloading">Pobieranie modułu: %s</string>
    <string name="module_start_downloading">Rozpocznij pobieranie: %s</string>
    <string name="new_version_available">Nowa wersja %s jest dostępna. Kliknij, aby zaktualizować!</string>
    <string name="launch_app">Uruchom</string>
    <string name="force_stop_app">Wymuś zatrzymanie</string>
    <string name="restart_app">Restartuj</string>
    <string name="failed_to_update_sepolicy">Nie udało się zaktualizować reguł SELinux dla %s</string>
    <string name="require_kernel_version">Obecna wersja KernelSU %1$d jest zbyt stara, aby menedżer działał poprawnie. Prosimy o aktualizację do wersji %2$d lub nowszej!</string>
    <string name="module_changelog">Dziennik zmian</string>
    <string name="enable_web_debugging">Debugowanie WebView</string>
    <string name="enable_web_debugging_summary">Może być użyte do debugowania WebUI. Włącz tylko w razie potrzeby.</string>
    <string name="select_file_tip">Obraz partycji %1$s jest zalecany</string>
    <string name="select_kmi">Wybierz KMI</string>
    <string name="install_next">Dalej</string>
    <string name="direct_install">Instalacja bezpośrednia (zalecane)</string>
    <string name="select_file">Wybierz plik</string>
    <string name="install_inactive_slot">Zainstaluj do nieaktywnego slotu (po aktualizcji OTA)</string>
    <string name="install_inactive_slot_warning">Po ponownym uruchomieniu Twoje urządzenie zostanie **ZMUSZONE** do uruchomia się z obecnie nieaktywnego slotu!
\nUżyj tej opcji dopiero po zakończeniu aktualizacji OTA.
\nCzy chcesz kontynuować?</string>
    <string name="app_profile_template_create">Stwórz szablon</string>
    <string name="app_profile_template_edit">Edytuj szablon</string>
    <string name="app_profile_template_name">Nazwa</string>
    <string name="app_profile_template_description">Opis</string>
    <string name="app_profile_template_save">Zapisz</string>
    <string name="app_profile_template_delete">Usuń</string>
    <string name="app_profile_import_export">Importuj/Eksportuj</string>
    <string name="app_profile_import_from_clipboard">Importuj ze schowka</string>
    <string name="app_profile_export_to_clipboard">Eksportuj do schowka</string>
    <string name="app_profile_template_export_empty">Nie można znaleźć lokalnego szablonu do eksportu!</string>
    <string name="app_profile_template_import_success">Zaimportowano pomyślnie</string>
    <string name="app_profile_template_save_failed">Nie udało się zapisać szablonu</string>
    <string name="app_profile_template_import_empty">Schowek jest pusty!</string>
    <string name="settings_profile_template_summary">Zarządzaj lokalnym i internetowym szablonem profilu aplikacji.</string>
    <string name="app_profile_template_view">Zobacz szablon</string>
    <string name="app_profile_template_id_invalid">Błędny identyfikator szablonu</string>
    <string name="settings_profile_template">Szablon profilu aplikacji</string>
    <string name="app_profile_template_id">Identyfikator</string>
    <string name="app_profile_template_id_exist">Szablon o takim identyfikatorze już istnieje!</string>
    <string name="grant_root_failed">Nie udało się przyznać roota!</string>
    <string name="open">Otwórz</string>
    <string name="settings_check_update">Wyszukaj aktualizacje</string>
    <string name="settings_check_update_summary">Wyszukuj aktualizacje automatycznie przy otwieraniu aplikacji.</string>
    <string name="settings_uninstall_permanent">Odinstaluj zupełnie</string>
    <string name="settings_restore_stock_image">Przywróć obraz fabryczny</string>
    <string name="settings_uninstall_temporary">Odinstaluj tymczasowo</string>
    <string name="settings_uninstall">Odinstaluj</string>
    <string name="settings_uninstall_temporary_message">Tymczasowo odinstaluj KernelSU, przywróć do oryginalnego stanu po następnym ponownym uruchomieniu.</string>
    <string name="settings_uninstall_permanent_message">Całkowite i trwałe odinstalowanie KernelSU (root i wszystkich modułów).</string>
    <string name="settings_restore_stock_image_message">Przywróć obraz fabryczny (jeśli istnieje kopia zapasowa), zwykle używany przed OTA; jeśli chcesz odinstalować KernelSU, użyj opcji \"Odinstaluj całkowicie\".</string>
    <string name="flashing">Flashowanie</string>
    <string name="flash_success">Flashowanie ukończone pomyślnie</string>
    <string name="flash_failed">Flashowanie nieudane</string>
    <string name="selected_lkm">Wybrano LKM: %s</string>
    <string name="save_log">Zapisz dzienniki</string>
    <string name="action">Akcja</string>
    <string name="log_saved">Dzienniki zapisane</string>
    <string name="module_sort_action_first">Działania najpierw</string>
    <string name="module_sort_enabled_first">Włączone najpierw</string>
    <string name="confirm">Potwierdź</string>
    <string name="module_install_prompt_with_name">Zainstalowane zostaną następujące moduły: %1$s</string>
    <string name="su_not_allowed">Nie można przyznać dostępu superużytkownika do %s</string>
    <string name="install_upload_lkm_file">Użyj lokalnego pliku LKM</string>
    <string name="install_only_support_ko_file">Obsługiwane są wyłącznie pliki .ko</string>
    <string name="processing">Przetwarzanie…</string>
    <string name="refresh_pulling">Przeciągnij w dół, aby odświeżyć</string>
    <string name="refresh_release">Uwolnij, aby odświeżyć</string>
    <string name="refresh_refresh">Odświeżanie…</string>
    <string name="refresh_complete">Odświeżono pomyślnie</string>
    <string name="settings_module_check_update">Sprawdź aktualizację modułów</string>
    <string name="settings_sucompat">Przekieruj binarkę su</string>
    <string name="settings_sucompat_summary">Pozwala aplikacjom z uprawnieniami Superużytkownika w profilu aplikacji uzyskać shell superużytkownika przez wykonanie /system/bin/su; skuteczne tylko dla nowych procesów.</string>
    <string name="settings_kernel_umount">Odmontowanie jądra</string>
    <string name="settings_kernel_umount_summary">Zachowanie odmontowania na poziomie jądra kontrolowane przez KernelSU</string>
    <string name="app_profile_affects_following_apps">Wpływa na następujące aplikacje</string>
    <string name="install_select_partition">Wybierz partycję</string>
    <string name="group_contains_apps">Zawiera %d aplikacji</string>
    <string name="metamodule_uninstall_confirm">Czy na pewno chcesz odinstalować moduł %s? Ta czynność wpłynie na wszystkie moduły, a niektóre funkcje zapewniane przez moduł meta (takie jak montowanie) przestaną działać.</string>
    <string name="undo">Cofnij</string>
    <string name="module_undo_uninstall_success">Pomyślnie anulowano odinstalowywanie %s</string>
    <string name="module_undo_uninstall_failed">Nie udało się cofnąć dezinstalacji: %s</string>
    <string name="feature_status_unsupported_summary">Jądro nie obsługuje tej funkcji.</string>
    <string name="feature_status_managed_summary">Ta funkcja jest zarządzana przez moduł.</string>
    <string name="settings_theme">Motyw</string>
    <string name="settings_theme_summary">Wybierz tryb motywu aplikacji.</string>
    <string name="settings_theme_mode_system">Taki jak w systemie</string>
    <string name="settings_theme_mode_light">Jasny</string>
    <string name="settings_theme_mode_dark">Ciemny</string>
    <string name="settings_theme_mode_monet_system">Monet (jak w systemie)</string>
    <string name="settings_theme_mode_monet_light">Monet (jasny)</string>
    <string name="settings_theme_mode_monet_dark">Monet (ciemny)</string>
    <string name="settings_key_color">Kolor przycisków</string>
    <string name="settings_key_color_summary">Dostosuj akcent gdy używany jest Monet.</string>
    <string name="settings_key_color_default">Domyślny</string>
    <string name="color_blue">Niebieski</string>
    <string name="color_red">Czerwony</string>
    <string name="color_green">Zielony</string>
    <string name="color_purple">Purpurowy</string>
    <string name="color_orange">Pomarańczowy</string>
    <string name="color_teal">Turkusowy</string>
    <string name="color_pink">Różowy</string>
    <string name="color_brown">Brązowy</string>
    <string name="module_repos">Repozytoria</string>
    <string name="module_repos_sort_name">Nazwa (A → Z)</string>
    <string name="module_repos_source_code">Kod źródłowy</string>
    <string name="home_gki_warning">Począwszy od wersji 3.0.0, tryb pracy GKI będzie używany wyłącznie w środowiskach testowych. Nie zalecamy jego stosowania w codziennym użytkowaniu, a pliki obrazów nie będą już udostępniane.</string>
    <string name="network_offline">Brak połączenia z siecią</string>
    <string name="network_retry">Ponów</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">Wydania</string>
    <string name="tab_info">Informacje</string>
    <string name="safe_mode_module_disabled">Instalacja modułów jest wyłączona w trybie awaryjnym</string>
</resources>

```

`manager/app/src/main/res/values-pt-rBR/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Início</string>
    <string name="home_not_installed">Não instalado</string>
    <string name="home_click_to_install">Clique para instalar</string>
    <string name="home_working">Em execução</string>
    <string name="home_working_version">Versão: %d</string>
    <string name="home_unsupported">Sem suporte</string>
    <string name="home_unsupported_reason">KernelSU suporta apenas kernels GKI agora</string>
    <string name="home_kernel">Versão do kernel</string>
    <string name="home_manager_version">Versão do gerenciador</string>
    <string name="home_fingerprint">Impressão digital</string>
    <string name="home_selinux_status">Status do SELinux</string>
    <string name="selinux_status_disabled">Desativado</string>
    <string name="selinux_status_enforcing">Impondo</string>
    <string name="selinux_status_permissive">Permissivo</string>
    <string name="selinux_status_unknown">Desconhecido</string>
    <string name="superuser">SuperUsuário</string>
    <string name="module_failed_to_enable">Não foi possível ativar o módulo %s</string>
    <string name="module_failed_to_disable">Não foi possível desativar o módulo %s</string>
    <string name="module_empty">Nenhum módulo instalado</string>
    <string name="module">Módulo</string>
    <string name="uninstall">Desinstalar</string>
    <string name="module_install">Instalar</string>
    <string name="install">Instalar</string>
    <string name="reboot">Reiniciar</string>
    <string name="settings">Configurações</string>
    <string name="reboot_userspace">Reinicialização suave</string>
    <string name="reboot_recovery">Reiniciar em modo Recovery</string>
    <string name="reboot_bootloader">Reiniciar em modo Bootloader</string>
    <string name="reboot_download">Reiniciar em modo Download</string>
    <string name="reboot_edl">Reiniciar em modo EDL</string>
    <string name="about">Sobre</string>
    <string name="module_uninstall_confirm">Tem certeza que deseja desinstalar o módulo %s?</string>
    <string name="module_uninstall_success">%s desinstalado</string>
    <string name="module_uninstall_failed">Não foi possível desinstalar %s</string>
    <string name="module_version">Versão</string>
    <string name="module_author">Autor</string>
    <string name="show_system_apps">Mostrar apps do sistema</string>
    <string name="send_log">Reportar registros</string>
    <string name="safe_mode">Modo de segurança</string>
    <string name="reboot_to_apply">Reinicie para entrar em vigor</string>
    <string name="module_magisk_conflict">Os módulos estão indisponíveis devido a um conflito com Magisk!</string>
    <string name="home_learn_kernelsu">Saiba mais sobre o KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/pt_BR/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Saiba como instalar o KernelSU e usar os módulos</string>
    <string name="home_support_title">Apoie-nos</string>
    <string name="home_support_content">KernelSU sempre foi e sempre será, gratuito e de código aberto. No entanto, você pode nos ajudar enviando uma pequena doação.</string>
    <string name="about_source_code"><![CDATA[Veja o código-fonte no %1$s<br/>Junte-se ao nosso canal do %2$s]]></string>
    <string name="profile" translatable="false">Perfil do Aplicativo</string>
    <string name="profile_default">Padrão</string>
    <string name="profile_template">Modelo</string>
    <string name="profile_custom">Personalizado</string>
    <string name="profile_name">Nome do perfil</string>
    <string name="profile_namespace">Montar namespace</string>
    <string name="profile_namespace_inherited">Herdado</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Grupos</string>
    <string name="profile_capabilities">Capacidades</string>
    <string name="profile_selinux_context">Contexto do SELinux</string>
    <string name="profile_umount_modules">Desmontar módulos</string>
    <string name="failed_to_update_app_profile">Falha ao atualizar o Perfil do Aplicativo para %s</string>
    <string name="settings_umount_modules_default">Desmontar módulos por padrão</string>
    <string name="settings_umount_modules_default_summary">O valor padrão global para \"Desmontar módulos\" em Perfil do Aplicativo. Se ativado, ele removerá todas as modificações do módulo no sistema para apps que não possuem um perfil definido.</string>
    <string name="profile_umount_modules_summary">Ativar esta opção permitirá que o KernelSU restaure quaisquer arquivos modificados pelos módulos para este app.</string>
    <string name="profile_selinux_domain">Domínio</string>
    <string name="profile_selinux_rules">Regras</string>
    <string name="module_update">Atualizar</string>
    <string name="module_downloading">Baixando módulo %s</string>
    <string name="module_start_downloading">Começando a baixar %s</string>
    <string name="new_version_available">Nova versão %s está disponível, clique para atualizar.</string>
    <string name="launch_app">Iniciar</string>
    <string name="force_stop_app">Forçar parada</string>
    <string name="restart_app">Reiniciar</string>
    <string name="failed_to_update_sepolicy">Falha ao atualizar as regras do SELinux para %s</string>
    <string name="require_kernel_version">A versão atual do KernelSU %1$d é muito baixa para o gerenciador funcionar corretamente. Por favor, atualize para a versão %2$d ou superior!</string>
    <string name="module_changelog">Registro de alterações</string>
    <string name="app_profile_template_import_success">Importado com sucesso</string>
    <string name="app_profile_export_to_clipboard">Exportar para a área de transferência</string>
    <string name="app_profile_template_export_empty">Não foi possível encontrar o modelo local para exportar!</string>
    <string name="app_profile_template_id_exist">O ID do modelo já existe!</string>
    <string name="app_profile_import_from_clipboard">Importar da área de transferência</string>
    <string name="app_profile_template_name">Nome</string>
    <string name="app_profile_template_id_invalid">ID do modelo inválido</string>
    <string name="app_profile_template_create">Criar modelo</string>
    <string name="app_profile_import_export">Importar/Exportar</string>
    <string name="app_profile_template_save_failed">Falha ao salvar o modelo</string>
    <string name="app_profile_template_edit">Editar modelo</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">Modelo do Perfil do Aplicativo</string>
    <string name="app_profile_template_description">Descrição</string>
    <string name="app_profile_template_save">Salvar</string>
    <string name="settings_profile_template_summary">Gerencie o modelo local e online do Perfil do Aplicativo</string>
    <string name="app_profile_template_delete">Excluir</string>
    <string name="app_profile_template_import_empty">A área de transferência está vazia!</string>
    <string name="app_profile_template_view">Ver modelo</string>
    <string name="settings_check_update">Verificar por atualizações</string>
    <string name="settings_check_update_summary">Verifique automaticamente se há atualizações ao abrir o app</string>
    <string name="grant_root_failed">Falha ao conceder acesso root!</string>
    <string name="open">Abrir</string>
    <string name="enable_web_debugging">Ativar depuração do WebView</string>
    <string name="enable_web_debugging_summary">Pode ser usado para depurar o WebUI. Por favor, ative somente quando necessário.</string>
    <string name="select_file">Selecione um arquivo</string>
    <string name="direct_install">Instalação direta (recomendada)</string>
    <string name="install_inactive_slot">Instalar no slot inativo (após o OTA)</string>
    <string name="install_inactive_slot_warning">Seu dispositivo será **FORÇADO** a inicializar no slot inativo atual após uma reinicialização!
\nSó use esta opção após a conclusão do OTA.
\nDeseja continuar?</string>
    <string name="install_next">Próximo</string>
    <string name="select_file_tip">A imagem da partição %1$s é recomendada</string>
    <string name="select_kmi">Selecionar KMI</string>
    <string name="settings_uninstall">Desinstalar</string>
    <string name="settings_uninstall_temporary">Desinstalar temporariamente</string>
    <string name="settings_uninstall_permanent">Desinstalar permanentemente</string>
    <string name="settings_restore_stock_image">Restaurar imagem de fábrica</string>
    <string name="settings_restore_stock_image_message">Restaure a imagem de fábrica (se existir um backup), geralmente usada antes do OTA. Se você precisar desinstalar o KernelSU, use \"Desinstalar permanentemente\".</string>
    <string name="settings_uninstall_temporary_message">Desinstale temporariamente o KernelSU e restaure ao estado original após a próxima reinicialização.</string>
    <string name="settings_uninstall_permanent_message">Desinstale o KernelSU (root e todos os módulos) completamente e permanentemente.</string>
    <string name="selected_lkm">LKM selecionado: %s</string>
    <string name="flash_failed">Flash falhou</string>
    <string name="flashing">Flashando</string>
    <string name="flash_success">Flash bem-sucedido</string>
    <string name="save_log">Salvar registros</string>
    <string name="action">Ação</string>
    <string name="log_saved">Registros salvos</string>
    <string name="module_sort_action_first">Ordenar (Ação primeiro)</string>
    <string name="module_sort_enabled_first">Ordenar (Ativado primeiro)</string>
    <string name="confirm">Confirmar</string>
    <string name="su_not_allowed">Não foi possível conceder acesso de SuperUsuário a %s</string>
    <string name="module_install_prompt_with_name">Os seguintes módulos serão instalados: %1$s</string>
    <string name="settings_sucompat">Redirecionar binário su</string>
    <string name="settings_sucompat_summary">Permite que aplicativos com permissão de Superusuário no Perfil do App obtenham um shell de superusuário executando /system/bin/su; efetivo apenas para novos processos.</string>
    <string name="settings_kernel_umount">Desmontar kernel</string>
    <string name="settings_kernel_umount_summary">Comportamento de desmontagem no nível do kernel controlado pelo KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-pt/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_not_installed">Não instalado</string>
    <string name="home">Início</string>
    <string name="home_click_to_install">Clique para instalar</string>
    <string name="home_working">Funcionando</string>
    <string name="home_working_version">Versão: %d</string>
    <string name="home_kernel">Kernel</string>
    <string name="install">Instalar</string>
    <string name="home_unsupported">Sem suporte</string>
    <string name="home_unsupported_reason">KernelSU suporta apenas kernels GKI agora</string>
    <string name="home_selinux_status">Status do SELinux</string>
    <string name="home_manager_version">Versão do aplicativo</string>
    <string name="module_failed_to_disable">Falha ao desativar o módulo: %s</string>
    <string name="home_fingerprint">Impressão digital</string>
    <string name="selinux_status_disabled">Desabilitado</string>
    <string name="selinux_status_enforcing">Impondo</string>
    <string name="selinux_status_permissive">Permissivo</string>
    <string name="selinux_status_unknown">Desconhecido</string>
    <string name="superuser">Super Usuário</string>
    <string name="module_failed_to_enable">Falha ao ativar o módulo: %s</string>
    <string name="module_empty">Nenhum módulo instalado</string>
    <string name="uninstall">Desinstalar</string>
    <string name="module">Modulos</string>
    <string name="reboot">Reiniciar</string>
    <string name="module_install">Instalar</string>
    <string name="reboot_userspace">Reinicialização Suave</string>
    <string name="settings">Configurações</string>
    <string name="reboot_bootloader">Reinicializar modo Bootloader</string>
    <string name="reboot_recovery">Reiniciar modo recuperação</string>
    <string name="module_uninstall_failed">Falha ao desinstalar: %s</string>
    <string name="module_version">Versão</string>
    <string name="module_author">Autor</string>
    <string name="reboot_download">Reiniciar para baixar</string>
    <string name="reboot_edl">Reiniciar em EDL</string>
    <string name="module_uninstall_confirm">Tem certeza de que deseja desinstalar o módulo %s\?</string>
    <string name="about">Sobre</string>
    <string name="send_log">Enviar log</string>
    <string name="module_uninstall_success">%s desinstalado</string>
    <string name="show_system_apps">Mostrar aplicativos do sistema</string>
    <string name="home_click_to_learn_kernelsu">Aprenda a instalar o KernelSU e usar os módulos</string>
    <string name="home_support_content">O KernelSU é, e sempre será, gratuito e de código aberto. No entanto, você pode nos mostrar que se importa fazendo uma doação.</string>
    <string name="about_source_code">Veja o código-fonte em %1$s<br/>
Junte-se ao nosso canal %2$s</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_inherited">Herdado</string>
    <string name="profile_default">Padrão</string>
    <string name="profile_template">Modelo</string>
    <string name="profile_custom">Personalizado</string>
    <string name="profile_name">Nome do perfil</string>
    <string name="profile_namespace">Montar namespace</string>
    <string name="safe_mode">Modo de segurança</string>
    <string name="reboot_to_apply">Reinicie para entrar em vigor</string>
    <string name="home_learn_kernelsu">Aprender KernelSU</string>
    <string name="module_magisk_conflict">Os módulos estão desativados porque estão em conflito com os do Magisk!</string>
    <string name="home_support_title">Apoie-nos</string>
    <string name="profile_groups">Grupos</string>
    <string name="profile_capabilities">Capacidades</string>
    <string name="profile_selinux_context">contexto SELinux</string>
    <string name="profile_selinux_domain">Domínio</string>
    <string name="module_update">Atualização</string>
    <string name="profile_umount_modules">Desativar modulos</string>
    <string name="failed_to_update_app_profile">Falha ao atualizar o perfil do aplicativo para %s</string>
    <string name="settings_umount_modules_default">Módulos desativados por padrão</string>
    <string name="settings_umount_modules_default_summary">O valor padrão global para \"Módulos Umount\" em Perfis de Aplicativos. Se ativado, removerá todas as modificações de módulo do sistema para aplicativos que não possuem um Perfil definido.</string>
    <string name="profile_selinux_rules">Regras</string>
    <string name="profile_umount_modules_summary">Ativar esta opção permitirá que o KernelSU restaure quaisquer arquivos modificados pelos módulos para este aplicativo.</string>
    <string name="module_start_downloading">Iniciar o download: %s</string>
    <string name="module_downloading">Baixando módulo: %s</string>
    <string name="failed_to_update_sepolicy">Falha ao atualizar as regras do SELinux para: %s</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="restart_app">Reiniciar</string>
    <string name="launch_app">Lançar</string>
    <string name="force_stop_app">Forçar parada</string>
    <string name="new_version_available">Nova versão: %s está disponível, clique para baixar</string>
    <string name="require_kernel_version">A versão atual do KernelSU %1$d é muito baixa para o gerenciador funcionar corretamente. Atualize para a versão %2$d ou superior!</string>
    <string name="save_log">Salvar Registros</string>
    <string name="settings_sucompat">Redirecionar binário su</string>
    <string name="settings_sucompat_summary">Permite que apps com permissão de Superutilizador no Perfil da App obtenham um shell de superutilizador executando /system/bin/su; eficaz apenas para novos processos.</string>
    <string name="settings_kernel_umount">Desmontar kernel</string>
    <string name="settings_kernel_umount_summary">Comportamento de desmontagem ao nível do kernel controlado pelo KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-ro/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Acasă</string>
    <string name="home_not_installed">Nu este instalat</string>
    <string name="home_click_to_install">Click pentru a instala</string>
    <string name="home_working">Funcționează</string>
    <string name="home_working_version">Versiune: %d</string>
    <string name="home_unsupported">Necompatibil</string>
    <string name="home_unsupported_reason">KernelSU suportă doar nuclee GKI acum</string>
    <string name="home_kernel">Nucleu</string>
    <string name="home_manager_version">Versiune Manager</string>
    <string name="home_fingerprint">Amprentă</string>
    <string name="home_selinux_status">Stare SELinux</string>
    <string name="selinux_status_disabled">Dezactivat</string>
    <string name="selinux_status_enforcing">Obligatoriu</string>
    <string name="selinux_status_permissive">Permisiv</string>
    <string name="selinux_status_unknown">Necunoscut</string>
    <string name="superuser">Super-Utilizator</string>
    <string name="module_failed_to_enable">Activarea modulului %s a eșuat</string>
    <string name="module_failed_to_disable">Dezactivarea modulului %s a eșuat</string>
    <string name="module_empty">Niciun modul instalat</string>
    <string name="module">Module</string>
    <string name="uninstall">Dezinstalează</string>
    <string name="module_install">Instalează</string>
    <string name="install">Instalează</string>
    <string name="reboot">Repornește</string>
    <string name="settings">Setări</string>
    <string name="reboot_userspace">Repornire rapidă</string>
    <string name="reboot_recovery">Repornire în Recuperare</string>
    <string name="reboot_bootloader">Repornire în Bootloader</string>
    <string name="reboot_download">Repornire în Download</string>
    <string name="reboot_edl">Repornire în EDL</string>
    <string name="about">Despre</string>
    <string name="module_uninstall_confirm">Sigur dorești să dezinstalezi modulul %s?</string>
    <string name="module_uninstall_success">%s dezinstalat</string>
    <string name="module_uninstall_failed">Dezinstalare eșuată: %s</string>
    <string name="module_version">Versiune</string>
    <string name="module_author">Autor</string>
    <string name="show_system_apps">Arată aplicațiile de sistem</string>
    <string name="send_log">Raportează jurnal</string>
    <string name="safe_mode">Mod sigur</string>
    <string name="reboot_to_apply">Repornește pentru ca modificările să intre în vigoare</string>
    <string name="module_magisk_conflict">Modulele sunt dezactivate deoarece sunt în conflict cu cele ale Magisk-ului!</string>
    <string name="home_learn_kernelsu">Află mai multe despre KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Află cum să instalezi KernelSU și să utilizezi module</string>
    <string name="home_support_title">Suport</string>
    <string name="home_support_content">KernelSU este, și va fi întotdeauna, gratuit și cu codul sursă deschis. Cu toate acestea, ne poți arăta că îți pasă făcând o donație.</string>
    <string name="about_source_code"><![CDATA[Vezi codul sursă la %1$s<br/>Alătură-te canalului nostru %2$s]]></string>
    <string name="profile_default">Implicit</string>
    <string name="profile_template">Șablon</string>
    <string name="profile_custom">Personalizat</string>
    <string name="profile_name">Nume profil</string>
    <string name="profile_namespace">Montare spațiu de nume</string>
    <string name="profile_namespace_inherited">Moștenit</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Grupuri</string>
    <string name="profile_capabilities">Capabilități</string>
    <string name="profile_selinux_context">Context SELinux</string>
    <string name="profile_umount_modules">Module u-montate</string>
    <string name="failed_to_update_app_profile">Nu s-a putut actualiza profilul aplicației pentru %s</string>
    <string name="settings_umount_modules_default">U-montează modulele în mod implicit</string>
    <string name="settings_umount_modules_default_summary">Valoarea implicită globală pentru „Module u-montate” în Profilurile aplicațiilor. Dacă este activat, va elimina toate modificările modulelor aduse sistemului pentru aplicațiile care nu au un profil setat.</string>
    <string name="profile_umount_modules_summary">Activarea acestei opțiuni va permite KernelSU să restaureze orice fișiere modificate de către modulele pentru această aplicație.</string>
    <string name="profile_selinux_domain">Domeniu</string>
    <string name="profile_selinux_rules">Reguli</string>
    <string name="module_update">Actualizează</string>
    <string name="module_downloading">Se descarcă modulul: %s</string>
    <string name="module_start_downloading">Începe descărcarea: %s</string>
    <string name="new_version_available">Versiune nouă: %s este disponibilă, clic pentru a actualiza</string>
    <string name="failed_to_update_sepolicy">Nu s-au reușit actualizările regulilor SELinux pentru: %s</string>
    <string name="launch_app">Lansare</string>
    <string name="force_stop_app">Oprire forțată</string>
    <string name="restart_app">Repornește</string>
    <string name="require_kernel_version">Versiunea actuală a KernelSU %1$d este prea mică pentru ca managerul să funcționeze corect. Actualizează la versiunea %2$d sau o versiune superioară!</string>
    <string name="module_changelog">Jurnalul modificărilor</string>
    <string name="app_profile_template_import_success">Importat cu succes</string>
    <string name="app_profile_export_to_clipboard">Export în clipboard</string>
    <string name="app_profile_template_export_empty">Nu există șabloane locale de exportat!</string>
    <string name="app_profile_template_id_exist">ID-ul șablonului există deja!</string>
    <string name="app_profile_import_from_clipboard">Import din clipboard</string>
    <string name="app_profile_template_name">Nume</string>
    <string name="app_profile_template_id_invalid">ID șablon nevalid</string>
    <string name="app_profile_template_create">Creează un șablon</string>
    <string name="app_profile_import_export">Import/Export</string>
    <string name="app_profile_template_save_failed">Nu s-a salvat șablonul</string>
    <string name="app_profile_template_edit">Editează șablonul</string>
    <string name="app_profile_template_id">ID</string>
    <string name="settings_profile_template">Șablon de profil al aplicației</string>
    <string name="app_profile_template_description">Descriere</string>
    <string name="app_profile_template_save">Salvează</string>
    <string name="settings_profile_template_summary">Gestionează șablonul local și online al Profilului aplicației</string>
    <string name="app_profile_template_delete">Șterge</string>
    <string name="app_profile_template_import_empty">Clipboard-ul este gol!</string>
    <string name="app_profile_template_view">Vizualizare șablon</string>
    <string name="settings_check_update">Verifică actualizarea</string>
    <string name="settings_check_update_summary">Se verifică automat actualizările când deschizi aplicația</string>
    <string name="enable_web_debugging">Activează depanarea WebView</string>
    <string name="enable_web_debugging_summary">Poate fi folosit pentru a depana WebUI, activează numai când este necesar.</string>
    <string name="grant_root_failed">Nu s-a acordat acces root!</string>
    <string name="open">Deschide</string>
    <string name="select_file_tip">Se recomandă imaginea partiției %1$s</string>
    <string name="install_next">Înainte</string>
    <string name="install_inactive_slot_warning">Dispozitivul va fi **FORȚAT** să pornească în slot-ul inactiv curent după o repornire!
\nFolosește această opțiune numai după finisarea OTA.
\nContinui?</string>
    <string name="select_kmi">Selectează KMI</string>
    <string name="direct_install">Instalare directă (recomandat)</string>
    <string name="select_file">Selectează un fișier</string>
    <string name="install_inactive_slot">Instalează într-un slot inactiv (după OTA)</string>
    <string name="settings_uninstall">Dezinstalează</string>
    <string name="settings_restore_stock_image">Restaurare imagine stoc</string>
    <string name="settings_uninstall_temporary_message">Dezinstalează temporar KernelSU, se revine la starea inițială după următoarea repornire.</string>
    <string name="selected_lkm">Lkm selectat: %s</string>
    <string name="settings_uninstall_temporary">Dezinstalează temporar</string>
    <string name="settings_uninstall_permanent">Dezinstalează definitiv</string>
    <string name="settings_uninstall_permanent_message">Dezinstalare KernelSU (Root și toate modulele) complet și permanent.</string>
    <string name="settings_restore_stock_image_message">Restaurează imaginea stoc din fabrică (dacă există o copie de rezervă), utilizată de obicei înainte de OTA; dacă trebuie să dezinstalezi KernelSU, utilizează „Dezinstalare permanentă”.</string>
    <string name="flashing">Instalare</string>
    <string name="flash_success">Instalare reușită</string>
    <string name="flash_failed">Instalarea a eșuat</string>
    <string name="save_log">Salvează Jurnale</string>
    <string name="settings_sucompat">Redirecționare binar su</string>
    <string name="settings_sucompat_summary">Permite aplicațiilor cu permisiune de Superutilizator în Profilul Aplicației să obțină un shell de superutilizator executând /system/bin/su; eficient doar pentru procesele noi.</string>
    <string name="settings_kernel_umount">Demontare kernel</string>
    <string name="settings_kernel_umount_summary">Comportament de demontare la nivel de kernel controlat de KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-ru/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Главная</string>
    <string name="home_not_installed">Не установлен</string>
    <string name="home_click_to_install">Нажмите, чтобы установить</string>
    <string name="home_working">Работает</string>
    <string name="home_working_version">Версия: %d</string>
    <!--Don't translate this string!-->
    <string name="home_unsupported">Не поддерживается</string>
    <string name="home_unsupported_reason">Теперь KernelSU поддерживает только ядра GKI, однако вы всё ещё можете пропатчить образ для GKI-устройств.</string>
    <string name="home_kernel">Версия ядра</string>
    <string name="home_manager_version">Версия менеджера</string>
    <string name="home_fingerprint">Подпись</string>
    <string name="home_selinux_status">Состояние SELinux</string>
    <string name="selinux_status_disabled">Выключен</string>
    <string name="selinux_status_enforcing">Принудительный</string>
    <string name="selinux_status_permissive">Разрешающий</string>
    <string name="selinux_status_unknown">Неизвестно</string>
    <string name="superuser">Суперюзеры</string>
    <!--Don't translate this string!-->
    <string name="module_failed_to_enable">Не удалось включить модуль %s</string>
    <string name="module_failed_to_disable">Не удалось отключить модуль %s</string>
    <string name="module_empty">Нет установленных модулей</string>
    <string name="module">Модули</string>
    <string name="uninstall">Удалить</string>
    <string name="module_install">Установить</string>
    <string name="install">Установка</string>
    <string name="reboot">Перезагрузить</string>
    <string name="settings">Настройки</string>
    <string name="reboot_userspace">Мягкая перезагрузка</string>
    <string name="reboot_recovery">Перезагрузить в Recovery</string>
    <string name="reboot_bootloader">Перезагрузить в Bootloader</string>
    <string name="reboot_download">Перезагрузить в Download</string>
    <string name="reboot_edl">Перезагрузить в EDL</string>
    <string name="about">О приложении</string>
    <string name="module_uninstall_confirm">Вы уверены, что хотите удалить модуль %s?</string>
    <string name="module_uninstall_success">%s удалён</string>
    <string name="module_uninstall_failed">Не удалось удалить %s</string>
    <string name="module_version">Версия</string>
    <string name="module_author">Автор</string>
    <string name="show_system_apps">Показать системные приложения</string>
    <string name="send_log">Отправить логи</string>
    <string name="safe_mode">Безопасный режим</string>
    <string name="reboot_to_apply">Перезагрузите, чтобы изменения вступили в силу</string>
    <string name="module_magisk_conflict">Модули недоступны из-за конфликта с Magisk!</string>
    <string name="home_learn_kernelsu">Узнайте о KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/ru_RU/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Узнайте, как установить KernelSU и использовать модули.</string>
    <string name="home_support_title">Поддержите нас</string>
    <string name="home_support_content">KernelSU был и всегда будет бесплатным и открытым проектом. Однако Вы всегда можете поддержать нас, отправив небольшое пожертвование.</string>
    <string name="about_source_code"><![CDATA[Посмотреть исходный код на %1$s<br/>Присоединяйтесь к нашему %2$s каналу]]></string>
    <string name="profile" translatable="false">App Profile</string>
    <!--Don't translate this string!-->
    <string name="profile_default">По умолчанию</string>
    <string name="profile_template">Шаблон</string>
    <string name="profile_custom">Пользовательский</string>
    <string name="profile_name">Название профиля</string>
    <string name="profile_namespace">Монтировать пространство имен</string>
    <string name="profile_namespace_inherited">Унаследованный</string>
    <string name="profile_namespace_global">Глобальный</string>
    <string name="profile_namespace_individual">Индивидуальный</string>
    <string name="profile_groups">Группы</string>
    <string name="profile_capabilities">Возможности</string>
    <string name="profile_selinux_context">Контекст SELinux</string>
    <string name="profile_umount_modules">Размонтировать модули</string>
    <string name="failed_to_update_app_profile">Не удалось обновить App Profile для %s</string>
    <string name="settings_umount_modules_default">Размонтировать модули по умолчанию</string>
    <string name="settings_umount_modules_default_summary">Глобальное значение по умолчанию для \"Размонтировать модули\" в App Profile. При включении будут удалены все модификации модулей в системе для приложений, у которых не задан Profile.</string>
    <string name="profile_umount_modules_summary">Включение этой опции позволит KernelSU восстанавливать любые изменённые модулями файлы для данного приложения.</string>
    <string name="profile_selinux_domain">Домен</string>
    <string name="profile_selinux_rules">Правила</string>
    <string name="module_update">Обновить</string>
    <string name="module_downloading">Скачивание модуля: %s</string>
    <string name="module_start_downloading">Начало скачивания: %s</string>
    <string name="new_version_available">Новая версия: %s доступна, нажмите чтобы скачать!</string>
    <string name="force_stop_app">Остановить принудительно</string>
    <string name="failed_to_update_sepolicy">Не удалось обновить правила SELinux для %s</string>
    <string name="launch_app">Запустить</string>
    <string name="restart_app">Перезапустить</string>
    <string name="require_kernel_version">Текущая версия KernelSU %1$d слишком низкая для правильной работы менеджера. Пожалуйста, обновите до версии %2$d или выше!</string>
    <string name="module_changelog">Список изменений</string>
    <string name="app_profile_template_import_success">Успешный импорт</string>
    <string name="app_profile_export_to_clipboard">Экспортировать в буфер обмена</string>
    <string name="app_profile_template_export_empty">Нет локальных шаблонов для экспорта!</string>
    <string name="app_profile_template_id_exist">Шаблон с таким ID уже существует!</string>
    <string name="app_profile_import_from_clipboard">Импортировать из буфера обмена</string>
    <string name="app_profile_template_name">Название</string>
    <string name="app_profile_template_id_invalid">Неверный ID шаблона</string>
    <string name="app_profile_template_create">Создать шаблон</string>
    <string name="app_profile_import_export">Импорт/Экспорт</string>
    <string name="app_profile_template_save_failed">Не удалось сохранить шаблон</string>
    <string name="app_profile_template_edit">Редактирование шаблона</string>
    <string name="app_profile_template_id">Идентификационный номер</string>
    <string name="settings_profile_template">Шаблон профиля приложения</string>
    <string name="app_profile_template_description">Описание</string>
    <string name="app_profile_template_save">Сохранить</string>
    <string name="settings_profile_template_summary">Управление локальным и онлайн-шаблоном профиля приложения.</string>
    <string name="app_profile_template_delete">Удалить</string>
    <string name="app_profile_template_import_empty">Буфер обмена пуст!</string>
    <string name="app_profile_template_view">Просмотр шаблона</string>
    <string name="settings_check_update">Проверять наличие обновлений</string>
    <string name="settings_check_update_summary">Автоматическая проверка обновлений при открытии приложения.</string>
    <string name="grant_root_failed">Не удалось выдать root!</string>
    <string name="open">Открыть</string>
    <string name="enable_web_debugging">Отладка WebView</string>
    <string name="enable_web_debugging_summary">Используется для отладки WebUI. Пожалуйста, включайте только при необходимости.</string>
    <string name="direct_install">Прямая установка (Рекомендуется)</string>
    <string name="install_inactive_slot">Установка в неактивный слот (После OTA)</string>
    <string name="install_next">Далее</string>
    <string name="select_file">Выбрать файл</string>
    <string name="install_inactive_slot_warning">Ваше устройство будет **ПРИНУДИТЕЛЬНО** загружено в текущий неактивный слот после перезагрузки!
\n Используйте эту опцию только после завершения OTA.
\n Продолжить?</string>
    <string name="select_kmi">Выбрать KMI</string>
    <string name="select_file_tip">%1$s образ раздела рекомендуется</string>
    <string name="settings_uninstall_temporary">Удалить на время</string>
    <string name="settings_uninstall_permanent_message">Удалить KernelSU (root и все модули) полностью.</string>
    <string name="settings_uninstall_permanent">Удалить полностью</string>
    <string name="settings_uninstall_temporary_message">Временно удалить KernelSU, восстановить исходное состояние после следующей перезагрузки.</string>
    <string name="settings_uninstall">Удалить</string>
    <string name="settings_restore_stock_image">Восстановить сток образ</string>
    <string name="settings_restore_stock_image_message">Восстановить исходный заводской образ (если существует резервная копия), обычно используется перед OTA; если вам нужно удалить KernelSU, используйте «Удалить полностью».</string>
    <string name="flash_success">Установка выполнена</string>
    <string name="flashing">Установка</string>
    <string name="flash_failed">Установка не выполнена</string>
    <string name="selected_lkm">Выбран LKM: %s</string>
    <string name="save_log">Сохранить логи</string>
    <string name="action">Действие</string>
    <string name="log_saved">Логи сохранены</string>
    <string name="module_sort_action_first">Сначала с действием</string>
    <string name="module_sort_enabled_first">Сначала включённые</string>
    <string name="module_install_prompt_with_name">Будут установлены следующие модули: %1$s</string>
    <string name="confirm">Подтвердить</string>
    <string name="su_not_allowed">Не удалось предоставить права Суперпользователя к %s</string>
    <string name="refresh_complete">Обновлено успешно</string>
    <string name="refresh_refresh">Обновление…</string>
    <string name="refresh_release">Отпустите чтобы обновить</string>
    <string name="refresh_pulling">Потяните вниз чтобы обновить</string>
    <string name="processing">Обработка…</string>
    <string name="install_upload_lkm_file">Использовать локальный LKM файл</string>
    <string name="install_only_support_ko_file">Поддерживаются только .ko файлы</string>
    <string name="settings_sucompat">Классическая команда su</string>
    <string name="settings_sucompat_summary">Разрешить root-доступ через /system/bin/su в новых процессах.</string>
    <string name="settings_kernel_umount">Размонтирование модулей</string>
    <string name="settings_kernel_umount_summary">Размонтировать модули в ядре для профиля приложения</string>
    <string name="settings_module_check_update">Проверять обновления модулей</string>
    <string name="install_select_partition">Выбрать раздел</string>
    <string name="app_profile_affects_following_apps">Влияет на следующие приложения</string>
    <string name="group_contains_apps">Содержит %d приложений</string>
    <string name="metamodule_uninstall_confirm">Вы уверены, что хотите удалить модуль %s? Это действие повлияет на все модули, и некоторые функции метамодуля (например, монтирование) перестанут работать.</string>
    <string name="undo">Отменить</string>
    <string name="module_undo_uninstall_failed">не удалось отменить удаление: %s</string>
    <string name="module_undo_uninstall_success">Удаление %s успешно отменено</string>
    <string name="settings_theme">Тема</string>
    <string name="settings_theme_summary">Выберите режим темы приложения.</string>
    <string name="settings_theme_mode_system">Как в системе</string>
    <string name="feature_status_managed_summary">Эта функция управляется модулем.</string>
    <string name="feature_status_unsupported_summary">Ядро не поддерживает эту функцию.</string>
    <string name="settings_key_color">Ключевой цвет</string>
    <string name="settings_key_color_summary">Настройте акцент при использовании Monet.</string>
    <string name="settings_key_color_default">По умолчанию</string>
    <string name="color_blue">Синий</string>
    <string name="color_red">Красный</string>
    <string name="color_green">Зеленый</string>
    <string name="color_purple">Фиолетовый</string>
    <string name="color_orange">Оранжевый</string>
    <string name="color_teal">Бирюзовый</string>
    <string name="color_pink">Розовый</string>
    <string name="color_brown">Коричневый</string>
    <string name="settings_theme_mode_monet_system">Monet (Как в системе)</string>
    <string name="settings_theme_mode_monet_light">Monet (Светлая)</string>
    <string name="settings_theme_mode_monet_dark">Monet (Тёмная)</string>
    <string name="settings_theme_mode_light">Светлая</string>
    <string name="settings_theme_mode_dark">Тёмная</string>
    <string name="module_repos">Репозиторий</string>
    <string name="module_repos_sort_name">Имя (А → Я)</string>
    <string name="module_repos_source_code">Исходный код</string>
    <string name="home_gki_warning">Начиная с версии 3.0.0, режим работы GKI будет использоваться только в тестовых средах. Мы не рекомендуем его для ежедневного использования, а image файлы больше предоставляться не будут.</string>
    <string name="network_offline">Нет подключения к сети</string>
    <string name="network_retry">Повторить</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">Релизы</string>
    <string name="tab_info">Инфо</string>
    <string name="safe_mode_module_disabled">В безопасном режиме установка модулей отключена</string>
    <string name="module_action_success">Действие модуля выполнено успешно.</string>
    <string name="settings_mode_enable_by_default">Включена (По умолчанию)</string>
    <string name="settings_mode_disable_until_reboot">Отключить до перезагрузки</string>
    <string name="settings_mode_disable_always">Всегда отключена</string>
    <string name="module_shortcut_title">Создать ярлык</string>
    <string name="module_shortcut_name_label">Название ярлыка</string>
    <string name="module_shortcut_icon_pick">Выбрать пользовательскую иконку</string>
    <string name="module_shortcut_add">Добавить ярлык</string>
    <string name="module_shortcut_not_supported">Лаунчер не поддерживает ярлыки на рабочем столе.</string>
    <string name="module_shortcut_created">Ярлык создан на рабочем столе.</string>
    <string name="module_shortcut_updated">Ярлык обновлен.</string>
    <string name="module_shortcut_delete">Удалить ярлык</string>
    <string name="module_shortcut_type_title">Выберите тип</string>
    <string name="module_shortcut_permission_tip_xiaomi">Пожалуйста, включите разрешение «Ярлыки на рабочем столе» для этого приложения в настройках Xiaomi.</string>
    <string name="module_shortcut_permission_tip_oppo">Пожалуйста, включите разрешение «Ярлыки на рабочем столе» для этого приложения в настройках OPPO.</string>
    <string name="module_shortcut_permission_tip_default">Если создание ярлыка не удалось, пожалуйста, включите разрешение на создание ярлыков на рабочем столе для этого приложения в системных настройках.</string>
    <string name="no_such_module">Модуль %s не существует</string>
    <string name="module_unavailable">Модуль %s отключен, обновляется или ожидает удаления</string>
    <string name="select_file_tip_nogki">Пожалуйста, выберите файл образа GKI устройства, который вы хотите пропатчить</string>
    <string name="current_kmi">Версия KMI этого устройства: %s</string>
    <string name="current_device_kmi">KMI этого устройства</string>
</resources>

```

`manager/app/src/main/res/values-sl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_click_to_install">Klikni za namestitev</string>
    <string name="home_working">V obdelavi</string>
    <string name="home_working_version">Verzija: %d</string>
    <string name="home_unsupported_reason">KernelSU podpira samo GKI kernele</string>
    <string name="home_kernel">Kernel</string>
    <string name="home_manager_version">Verzija upravitelja</string>
    <string name="home_fingerprint">Prstni odtis</string>
    <string name="home_selinux_status">SELinux status</string>
    <string name="selinux_status_disabled">Onemogočeno</string>
    <string name="selinux_status_unknown">Neznano</string>
    <string name="module_failed_to_disable">Napaka pri onemogočanju modula: %s</string>
    <string name="module_empty">Ni nameščenih modulov</string>
    <string name="module">Modul</string>
    <string name="uninstall">Odmesti</string>
    <string name="module_install">Namesti</string>
    <string name="install">Namesti</string>
    <string name="reboot_userspace">Mehki ponovni zagon</string>
    <string name="reboot_recovery">Ponovni zagon v Recovery</string>
    <string name="reboot_bootloader">Ponovni zagon v Bootloader</string>
    <string name="reboot_edl">Ponovni zagon v EDL</string>
    <string name="module_uninstall_confirm">Ste prepričani, da želite odstraniti modul %s?</string>
    <string name="module_uninstall_success">%s je odmeščen</string>
    <string name="module_author">Avtor</string>
    <string name="send_log">Prijavite dnevnik</string>
    <string name="home_learn_kernelsu">Naučite se KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Naučite se, kako namestiti KernelSU in uporabiti module</string>
    <string name="about_source_code">Glej odprto kodo na %1$s<br/>Pridružite se našem %2$s kanalu</string>
    <string name="profile_default">Privzeto</string>
    <string name="profile_template">Predloga</string>
    <string name="profile_namespace">Imenski prostor vmestitve</string>
    <string name="profile_namespace_inherited">Podedovano</string>
    <string name="profile_namespace_global">Globalno</string>
    <string name="profile_namespace_individual">Pozameznik</string>
    <string name="profile_capabilities">Zmožnosti</string>
    <string name="profile_umount_modules">Izvrzi module</string>
    <string name="settings_umount_modules_default">Po privzetem izvrzi module</string>
    <string name="profile_selinux_domain">Domena</string>
    <string name="module_update">Posodobitev</string>
    <string name="module_downloading">Nalaganje modula: %s</string>
    <string name="launch_app">Zaženi</string>
    <string name="restart_app">Ponovni zagon</string>
    <string name="module_changelog">Dnevnik sprememb</string>
    <string name="settings_profile_template">Predloga za aplikacijski profil</string>
    <string name="home">Domov</string>
    <string name="home_unsupported">Ne podpira</string>
    <string name="superuser">SuperUporabnik</string>
    <string name="module_failed_to_enable">Napaka pri omogočanju modula: %s</string>
    <string name="reboot">Znova zaženi</string>
    <string name="settings">Nastavitve</string>
    <string name="reboot_download">Ponovni zagon v Download</string>
    <string name="about">O nas</string>
    <string name="module_version">Verzija</string>
    <string name="module_uninstall_failed">Napaka pri odmeščanju: %s</string>
    <string name="safe_mode">Varni način</string>
    <string name="reboot_to_apply">Za uveljavitev je potreben ponovni zagon</string>
    <string name="show_system_apps">Prikaz sistemskih aplikacij</string>
    <string name="module_magisk_conflict">Moduli so onemogočeni, ker so v konfliktu z Magiskovimi!</string>
    <string name="home_support_title">Podprite nas</string>
    <string name="profile_custom">Po meri</string>
    <string name="profile_name">Ime profila</string>
    <string name="profile_groups">Skupine</string>
    <string name="profile_selinux_context">SELinux kontekst</string>
    <string name="home_support_content">KernelSU je, in bo vedno brezplačen in odprtokoden. Kljub temu, nam lahko z donacijo pokažete, da vam je mar.</string>
    <string name="failed_to_update_app_profile">Napaka pri posodobitvi aplikacijskega profila za %s</string>
    <string name="require_kernel_version">Za pravilno funkionalnost upravitelja je trenutna KernelSU verzija %1$d prenizka. Potrebna je nadgradnja na verzijo %2$d ali več!</string>
    <string name="settings_umount_modules_default_summary">Globalno privzeta vrednost za \"Izvrzi module\" v aplikacijskih profilih. Če je omogočena, bo to odstranilo vse sistemske modifikacije modulov za aplikacije, ki nimajo nastavljenega profila.</string>
    <string name="profile_umount_modules_summary">Omogočanje te opcije bo dovolilo KernelSU, da obnovi vse zaradi modulov spremenjene datoteke za to aplikacijo.</string>
    <string name="force_stop_app">Prisilna ustavitev</string>
    <string name="profile_selinux_rules">Pravila</string>
    <string name="module_start_downloading">Začni z nalaganjem: %s</string>
    <string name="new_version_available">Na voljo je nova verzija: %s, kliknite za nadgradnjo</string>
    <string name="failed_to_update_sepolicy">Napaka pri posodobitvi SELinux pravil za: %s</string>
    <string name="home_not_installed">Ni nameščeno</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="app_profile_template_create">Ustvari predlogo</string>
    <string name="app_profile_template_edit">Uredi predlogo</string>
    <string name="app_profile_template_id_invalid">Neveljaven id predloge</string>
    <string name="app_profile_template_description">Opis</string>
    <string name="app_profile_template_save">Shrani</string>
    <string name="app_profile_template_delete">Odstrani</string>
    <string name="app_profile_template_id_exist">id predloge že obstaja!</string>
    <string name="app_profile_import_from_clipboard">Uvoz iz odložišča</string>
    <string name="app_profile_export_to_clipboard">Izvoz v odložišče</string>
    <string name="app_profile_template_export_empty">Lokalna predloga za izvoz ni bila najdena!</string>
    <string name="app_profile_template_save_failed">Napaka pri shranjevanju predloge</string>
    <string name="app_profile_template_import_empty">Odložišče je prazno!</string>
    <string name="settings_profile_template_summary">Upravljaj z lokalnimi in spletnimi predlogami za aplikacijski profil</string>
    <string name="app_profile_template_id">id</string>
    <string name="app_profile_template_name">Ime</string>
    <string name="app_profile_template_view">Ogled predloge</string>
    <string name="app_profile_template_import_success">Uvoz uspešen</string>
    <string name="app_profile_import_export">Uvoz/Izvoz</string>
    <string name="save_log">Shrani Dnevnike</string>
    <string name="settings_sucompat">Preusmeri su binarno datoteko</string>
    <string name="settings_sucompat_summary">Preusmeri /system/bin/su na ksud za aplikacije z dovoljenjem Superuporabnika v profilu aplikacije; velja samo za nove procese.</string>
    <string name="settings_kernel_umount">Jedrno odklapljanje</string>
    <string name="settings_kernel_umount_summary">Vedenje odklapljanja na ravni jedra, ki ga nadzoruje KernelSU</string>
</resources>

```

`manager/app/src/main/res/values-sr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home_click_to_install">Додирните да бисте инсталирали</string>
    <string name="home">Почетна</string>
    <string name="home_not_installed">Није инсталирано</string>
    <string name="home_working_version">Верзија: %d</string>
    <string name="home_working">Ради</string>
    <string name="save_log">Сачувај Дневнике</string>
    <string name="settings_sucompat">Preusmeri su binarni fajl</string>
    <string name="settings_sucompat_summary">Preusmeri /system/bin/su na ksud za aplikacije sa dozvolom Superkorisnika u Profilu aplikacije; efektivno samo za nove procese.</string>
    <string name="settings_kernel_umount">Kernel umount</string>
    <string name="settings_kernel_umount_summary">Ponašanje umount-a na nivou kernela kontrolisano od strane KernelSU-a</string>
</resources>

```

`manager/app/src/main/res/values-te/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="selinux_status_unknown">తెలియదు</string>
    <string name="module_failed_to_enable">మాడ్యూల్‌ని ప్రారంభించడంలో విఫలమైంది: %s</string>
    <string name="force_stop_app">బలవంతంగా ఆపడం</string>
    <string name="restart_app">పునఃప్రారంభించండి</string>
    <string name="module">మాడ్యూల్</string>
    <string name="about">గురించి</string>
    <string name="home_selinux_status">SELinux స్థితి</string>
    <string name="home">హోమ్</string>
    <string name="superuser">సూపర్యూజర్</string>
    <string name="module_failed_to_disable">మాడ్యూల్‌ని నిలిపివేయడంలో విఫలమైంది: %s</string>
    <string name="module_empty">మాడ్యూల్ ఏదీ ఇన్‌స్టాల్ చేయబడలేదు</string>
    <string name="home_not_installed">ఇన్‌స్టాల్ చేయలేదు</string>
    <string name="home_click_to_install">ఇన్‌స్టాల్ చేయడానికి క్లిక్ చేయండి</string>
    <string name="home_working">పని చేస్తోంది</string>
    <string name="home_working_version">వెర్షన్: %d</string>
    <string name="save_log">లాగ్‌లు సేవ్ చేయండి</string>
    <string name="settings_sucompat">su బైనరీని మళ్ళించండి</string>
    <string name="settings_sucompat_summary">యాప్ ప్రొఫైల్‌లో సూపర్‌యూజర్ అనుమతి ఉన్న యాప్‌ల కోసం /system/bin/su ని ksud కి మళ్ళించండి; కొత్త ప్రాసెస్‌లకు మాత్రమే పని చేస్తుంది.</string>
    <string name="settings_kernel_umount">కెర్నల్ అన్‌మౌంట్</string>
    <string name="settings_kernel_umount_summary">KernelSU ద్వారా నియంత్రించబడే కెర్నల్-స్థాయి అన్‌మౌంట్ ప్రవర్తన</string>
</resources>

```

`manager/app/src/main/res/values-th/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">หน้าหลัก</string>
    <string name="home_not_installed">ยังไม่ได้ติดตั้ง</string>
    <string name="home_click_to_install">กดเพื่อติดตั้ง</string>
    <string name="home_working">กำลังทำงาน</string>
    <string name="home_working_version">เวอร์ชัน: %d</string>
    <string name="home_manager_version">เวอร์ชันตัวจัดการ</string>
    <string name="home_unsupported">ไม่รองรับ</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="reboot_recovery">รีบูตเข้าสู่โหมดกู้คืน</string>
    <string name="reboot_userspace">ซอฟต์รีบูต</string>
    <string name="home_unsupported_reason">KernelSU รองรับเคอร์เนลประเภท GKI เท่านั้น</string>
    <string name="home_kernel">เวอร์ชันเคอร์เนล</string>
    <string name="selinux_status_disabled">ปิดใช้งาน</string>
    <string name="home_fingerprint">ลายนิ้วมือ</string>
    <string name="home_selinux_status">สถานะ SELinux</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">ไม่ทราบ</string>
    <string name="superuser">สิทธิ์ผู้ใช้ขั้นสูง</string>
    <string name="module_failed_to_enable">ล้มเหลวในการเปิดใช้งานโมดูล %s</string>
    <string name="module_failed_to_disable">ล้มเหลวในการปิดใช้งานโมดูล: %s</string>
    <string name="module_empty">ไม่มีโมดูลที่ติดตั้ง</string>
    <string name="module">โมดูล</string>
    <string name="uninstall">ถอนการติดตั้ง</string>
    <string name="settings">ตั้งค่า</string>
    <string name="module_install">ติดตั้ง</string>
    <string name="install">ติดตั้ง</string>
    <string name="reboot">รีบูต</string>
    <string name="reboot_bootloader">รีบูตเข้าสู่โหมด Bootloader</string>
    <string name="about">เกี่ยวกับ</string>
    <string name="reboot_download">รีบูตเข้าสู่โหมด Download</string>
    <string name="reboot_edl">รีบูตเข้าสู่โหมด EDL</string>
    <string name="module_uninstall_success">%s ถอนการติดตั้งสำเร็จ</string>
    <string name="module_uninstall_failed">ถอนการติดตั้ง %s ล้มเหลว</string>
    <string name="module_uninstall_confirm">คุณแน่ใจว่าจะถอนการติดตั้งโมดูล %s หรือไม่\?</string>
    <string name="module_author">ผู้สร้าง</string>
    <string name="module_version">เวอร์ชัน</string>
    <string name="show_system_apps">แสดงแอประบบ</string>
    <string name="send_log">ส่ง logs</string>
    <string name="safe_mode">โหมดปลอดภัย</string>
    <string name="reboot_to_apply">รีบูตเพื่อให้มีผล</string>
    <string name="module_magisk_conflict">โมดูลไม่สามารถใช้งานได้ เนื่องจากขัดแย้งกับ Magisk!</string>
    <string name="home_learn_kernelsu">เรียนรู้เกี่ยวกับ KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">เรียนรู้วิธีการติดตั้ง KernelSU และวิธีใช้งานโมดูลต่าง ๆ</string>
    <string name="home_support_title">สนับสนุนพวกเรา</string>
    <string name="home_support_content">KernelSU จะเป็นโอเพ่นซอร์สฟรีเสมอ อย่างไรก็ตาม คุณสามารถแสดงความห่วงใยได้ด้วยการบริจาค</string>
    <string name="about_source_code"><![CDATA[ดูซอร์สโค้ดได้ที่ %1$s<br/>เข้าร่วม %2$s channel]]></string>
    <string name="profile_custom">กำหนดเอง</string>
    <string name="profile_default">ค่าเริ่มต้น</string>
    <string name="profile_template">เทมเพลต</string>
    <string name="profile_name">ชื่อโปรไฟล์</string>
    <string name="profile_namespace">Mount เนมสเปซ</string>
    <string name="profile_namespace_global">ทั่วไป</string>
    <string name="profile_namespace_inherited">สืบทอด</string>
    <string name="profile_namespace_individual">ส่วนบุคคล</string>
    <string name="profile_groups">หมวดหมู่</string>
    <string name="profile_capabilities">ความสามารถของแอป</string>
    <string name="profile_umount_modules_summary">การเปิดใช้งานตัวเลือกนี้จะทำให้ KernelSU สามารถกู้คืนไฟล์ที่แก้ไขโดยโมดูลสำหรับแอปนี้ได้</string>
    <string name="profile_selinux_context">บริบท SELinux</string>
    <string name="profile_umount_modules">Umount โมดูล</string>
    <string name="failed_to_update_app_profile">ไม่สามารถอัปเดตโปรไฟล์แอปสำหรับ %s ได้</string>
    <string name="settings_umount_modules_default">Umount โมดูลตามค่าเริ่มต้น</string>
    <string name="profile_selinux_domain">โดเมน</string>
    <string name="module_update">อัปเดต</string>
    <string name="profile_selinux_rules">กฎ</string>
    <string name="module_downloading">กำลังดาวน์โหลดโมดูล: %s</string>
    <string name="module_start_downloading">กำลังเริ่มดาวน์โหลด: %s</string>
    <string name="new_version_available">เวอร์ชัน %s พร้อมใช้งาน คลิกเพื่ออัปเกรด !</string>
    <string name="force_stop_app">บังคับหยุด</string>
    <string name="restart_app">รีสตาร์ท</string>
    <string name="settings_umount_modules_default_summary">หากเปิดใช้งานค่าเริ่มต้นโดยทั่วไปสำหรับ \"Umount โมดูล\" ในโปรไฟล์แอป จะเป็นการลบการแก้ไขโมดูลทั้งหมดในระบบสำหรับแอปพลิเคชันที่ไม่มีการตั้งค่าโปรไฟล์</string>
    <string name="launch_app">เปิด</string>
    <string name="failed_to_update_sepolicy">ไม่สามารถอัปเดตกฎ SElinux สำหรับ %s</string>
    <string name="require_kernel_version">KernelSU เวอร์ชัน %1$d ต่ำเกินไป ทำให้ตัวจัดการไม่สามารถทำงานได้อย่างถูกต้อง โปรดอัปเกรดเป็นเวอร์ชัน %2$d หรือสูงกว่า!</string>
    <string name="module_changelog">บันทึกการเปลี่ยนแปลง</string>
    <string name="app_profile_template_import_success">นำเข้าเสร็จสิ้น</string>
    <string name="app_profile_export_to_clipboard">ส่งออกไปยังคลิปบอร์ด</string>
    <string name="app_profile_template_export_empty">ไม่พบเทมเพลตในเครื่องที่จะส่งออก!</string>
    <string name="app_profile_template_id_exist">มีไอดีเทมเพลตนี้อยู่แล้ว!</string>
    <string name="app_profile_import_from_clipboard">นำเข้าจากคลิปบอร์ด</string>
    <string name="app_profile_template_name">ชื่อ</string>
    <string name="app_profile_template_id_invalid">ไอดีเทมเพลตไม่ถูกต้อง</string>
    <string name="app_profile_template_create">สร้างเทมเพลต</string>
    <string name="app_profile_import_export">นำเข้า/ส่งออก</string>
    <string name="app_profile_template_save_failed">ไม่สามารถบันทึกเทมเพลต</string>
    <string name="app_profile_template_edit">แก้ไขเทมเพลต</string>
    <string name="app_profile_template_id">ไอดี</string>
    <string name="settings_profile_template">เทมเพลตโปรไฟล์แอป</string>
    <string name="app_profile_template_description">คำอธิบาย</string>
    <string name="app_profile_template_save">บันทึก</string>
    <string name="settings_profile_template_summary">จัดการเทมเพลตโปรไฟล์แอปในเครื่องและเทมเพลตออนไลน์</string>
    <string name="app_profile_template_delete">ลบ</string>
    <string name="app_profile_template_import_empty">คลิปบอร์ดว่างเปล่า!</string>
    <string name="app_profile_template_view">ดูเทมเพลต</string>
    <string name="open">เปิด</string>
    <string name="grant_root_failed">ไม่สามารถให้สิทธิ์รูทได้!</string>
    <string name="settings_check_update">ตรวจสอบการอัปเดต</string>
    <string name="settings_check_update_summary">ตรวจสอบการอัปเดตโดยอัตโนมัติเมื่อเปิดแอป</string>
    <string name="enable_web_debugging">การแก้ไขข้อบกพร่อง WebView</string>
    <string name="select_kmi">เลือก KMI</string>
    <string name="install_next">ต่อไป</string>
    <string name="select_file">เลือกไฟล์</string>
    <string name="install_inactive_slot">ติดตั้งลงในสล็อตที่ไม่ใช้งาน (หลังจาก OTA)</string>
    <string name="direct_install">ติดตั้งโดยตรง (แนะนำ)</string>
    <string name="select_file_tip">แนะนำให้ใช้อิมเมจพาร์ติชัน %1$s</string>
    <string name="enable_web_debugging_summary">ใช้เพื่อดีบัก WebUI เท่านั้น โปรดเปิดใช้งานเมื่อจำเป็น</string>
    <string name="install_inactive_slot_warning">อุปกรณ์ของคุณจะถูก **บังคับ** ให้บูตไปยังสล็อตที่ไม่ได้ใช้งานหลังจากรีบูต!
\nโปรดใช้ตัวเลือกนี้หลังจาก OTA เสร็จแล้วเท่านั้น
\nดำเนินการต่อหรือไม่?</string>
    <string name="settings_uninstall_permanent">ถอนการติดตั้งถาวร</string>
    <string name="settings_restore_stock_image">เรียกคืนอิมเมจดั้งเดิม</string>
    <string name="settings_uninstall_temporary_message">ถอนการติดตั้ง KernelSU ชั่วคราว จะคืนค่าเป็นสถานะดั้งเดิมหลังจากรีบูตในครั้งถัดไป</string>
    <string name="flashing">กำลังแฟลช</string>
    <string name="flash_success">แฟลชสำเร็จ</string>
    <string name="flash_failed">แฟลชล้มเหลว</string>
    <string name="selected_lkm">เลือก LKM: %s</string>
    <string name="settings_uninstall">ถอนการติดตั้ง</string>
    <string name="settings_uninstall_temporary">ถอนการติดตั้งชั่วคราว</string>
    <string name="settings_uninstall_permanent_message">การถอนการติดตั้ง KernelSU (การรูทและโมดูลทั้งหมด) อย่างสมบูรณ์</string>
    <string name="settings_restore_stock_image_message">คืนค่าโรงงานอิมเมจดั้งเดิม (หากมีข้อมูลสำรอง) ส่วนใหญ่มักใช้ก่อนทำการ OTA ซึ่งหากคุณต้องการถอนการติดตั้ง KernelSU โปรดใช้ \"ถอนการติดตั้งถาวร\"</string>
    <string name="save_log">บันทึก logs</string>
    <string name="action">คำสั่ง</string>
    <string name="log_saved">บันทึก logs แล้ว</string>
    <string name="module_sort_action_first">รันคำสั่งขึ้นก่อน</string>
    <string name="module_sort_enabled_first">เปิดใช้งานขึ้นก่อน</string>
    <string name="module_install_prompt_with_name">โมดูล %1$s จะถูกติดตั้ง</string>
    <string name="confirm">ยืนยัน</string>
    <string name="su_not_allowed">ไม่สามารถให้สิทธิ์ผู้ใช้ขั้นสูงกับ %s ได้</string>
    <string name="settings_module_check_update">ตรวจสอบการอัปเดตโมดูล</string>
    <string name="install_upload_lkm_file">ใช้ไฟล์ LKM ในเครื่อง</string>
    <string name="install_only_support_ko_file">รองรับเฉพาะไฟล์ .ko เท่านั้น</string>
    <string name="settings_sucompat">เปลี่ยนเส้นทางไบนารี su</string>
    <string name="settings_sucompat_summary">อนุญาตให้แอปที่ได้รับอนุญาต Superuser ในโปรไฟล์แอปได้รับเชล superuser โดยการเรียกใช้ /system/bin/su; มีผลเฉพาะกับกระบวนการใหม่เท่านั้น</string>
    <string name="settings_kernel_umount">การเลิกเมานต์เคอร์เนล</string>
    <string name="settings_kernel_umount_summary">พฤติกรรมการเลิกเมานต์ระดับเคอร์เนลที่ควบคุมโดย KernelSU</string>
    <string name="processing">กำลังประมวลผล…</string>
    <string name="refresh_pulling">ดึงลงเพื่อรีเฟรช</string>
    <string name="refresh_release">ปล่อยเพื่อรีเฟรช</string>
    <string name="refresh_refresh">กำลังรีเฟรช…</string>
    <string name="refresh_complete">รีเฟรชสำเร็จ</string>
    <string name="install_select_partition">เลือกพาร์ทิชัน</string>
    <string name="app_profile_affects_following_apps">ส่งผลต่อแอปดังต่อไปนี้</string>
    <string name="group_contains_apps">มีแอป %d รายการ</string>
    <string name="metamodule_uninstall_confirm">คุณแน่ใจหรือไม่ว่าต้องการถอนการติดตั้งโมดูล %s? การดำเนินการนี้จะส่งผลต่อโมดูลทั้งหมด และฟีเจอร์บางอย่างที่เมตาโมดูลจัดเตรียมไว้ (เช่น การ mount) จะไม่ทำงานอีกต่อไป</string>
    <string name="undo">เลิกทำ</string>
    <string name="module_undo_uninstall_success">ยกเลิกการถอนการติดตั้ง %s สำเร็จ</string>
    <string name="module_undo_uninstall_failed">ไม่สามารถยกเลิกการถอนการติดตั้ง %s ได้</string>
    <string name="settings_theme">ธีม</string>
    <string name="settings_theme_summary">เลือกธีมของแอป</string>
    <string name="settings_theme_mode_system">ตามระบบ</string>
    <string name="settings_theme_mode_light">สว่าง</string>
    <string name="settings_theme_mode_dark">มืด</string>
    <string name="settings_theme_mode_monet_system">โมเนต์ (ตามระบบ)</string>
    <string name="settings_theme_mode_monet_light">โมเนต์ (สว่าง)</string>
    <string name="settings_theme_mode_monet_dark">โมเนต์ (มืด)</string>
    <string name="settings_key_color">สีหลัก</string>
    <string name="settings_key_color_summary">ปรับแต่งสีที่เน้นเมื่อใช้ธีมโมเนต์</string>
    <string name="settings_key_color_default">ค่าเริ่มต้น</string>
    <string name="color_blue">สีน้ำเงิน</string>
    <string name="color_red">สีแดง</string>
    <string name="color_green">สีเขียว</string>
    <string name="color_purple">สีม่วง</string>
    <string name="color_orange">สีส้ม</string>
    <string name="color_teal">สีเขียวอมน้ำเงิน</string>
    <string name="color_pink">สีชมพู</string>
    <string name="color_brown">สีน้ำตาล</string>
    <string name="feature_status_unsupported_summary">เคอร์เนลของคุณไม่รองรับฟีเจอร์นี้</string>
    <string name="feature_status_managed_summary">คุณสมบัตินี้ถูกจัดการโดยโมดูล</string>
    <string name="module_repos">พื้นที่จัดเก็บโมดูล</string>
    <string name="module_repos_sort_name">เรียงตามชื่อ (A → Z)</string>
    <string name="module_repos_source_code">ซอร์สโค้ด</string>
    <string name="home_gki_warning">ตั้งแต่เวอร์ชัน 3.0.0 เป็นต้นไป โหมด GKI จะถูกใช้สำหรับการทดสอบเท่านั้น เราไม่แนะนำให้ใช้โหมดนี้ในชีวิตประจำวัน และจะไม่มีไฟล์อิมเมจให้ดาวน์โหลดอีกต่อไป</string>
    <string name="network_offline">ไม่ได้เชื่อมต่อกับเครือข่าย</string>
    <string name="network_retry">ลองอีกครั้ง</string>
    <string name="tab_readme">โปรดอ่าน</string>
    <string name="tab_info">ข้อมูล</string>
    <string name="tab_releases">รายการที่เผยแพร่</string>
    <string name="safe_mode_module_disabled">ไม่สามารถติดตั้งโมดูลได้ในโหมดปลอดภัย</string>
</resources>

```

`manager/app/src/main/res/values-tr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name" translatable="false">KernelSU</string>
    <string name="home">Ana Sayfa</string>
    <string name="home_not_installed">Kurulmadı</string>
    <string name="home_click_to_install">Kurmak için tıklayın</string>
    <string name="home_working">Çalışıyor</string>
    <string name="home_working_version">Sürüm: %d</string>
    <string name="home_unsupported">Desteklenmiyor</string>
    <string name="home_unsupported_reason">KernelSU şimdilik sadece GKI çekirdeklerini destekliyor</string>
    <string name="home_kernel">Çekirdek Versiyonu</string>
    <string name="home_manager_version">Yönetici sürümü</string>
    <string name="home_fingerprint">Parmak izi</string>
    <string name="home_selinux_status">SELinux durumu</string>
    <string name="selinux_status_disabled">Devre dışı</string>
    <string name="selinux_status_enforcing">Etkin (Enforcing)</string>
    <string name="selinux_status_permissive">Serbest (Permissive)</string>
    <string name="selinux_status_unknown">Bilinmiyor</string>
    <string name="superuser">Süper kullanıcı</string>
    <string name="module_failed_to_enable">Modül etkinleştirilemedi: %s</string>
    <string name="module_failed_to_disable">Modül devre dışı bırakılamadı: %s</string>
    <string name="module_empty">Kurulu modül yok</string>
    <string name="module">Modül</string>
    <string name="uninstall">Kaldır</string>
    <string name="module_install">Kur</string>
    <string name="install">Kur</string>
    <string name="reboot">Cihazı yeniden başlat</string>
    <string name="settings">Ayarlar</string>
    <string name="reboot_userspace">Hızlı yeniden başlat</string>
    <string name="reboot_recovery">Kurtarma modunda yeniden başlat</string>
    <string name="reboot_bootloader">Önyükleyici modunda yeniden başlat</string>
    <string name="reboot_download">İndirme modunda yeniden başlat</string>
    <string name="reboot_edl">EDL modunda yeniden başlat</string>
    <string name="about">Hakkında</string>
    <string name="module_uninstall_confirm">%s modülünü kaldırmak istediğinizden emin misiniz?</string>
    <string name="module_uninstall_success">%s kaldırıldı</string>
    <string name="module_uninstall_failed">Kaldırma başarısız: %s</string>
    <string name="module_version">Sürüm</string>
    <string name="module_author">Geliştirici</string>
    <string name="show_system_apps">Sistem uygulamalarını göster</string>
    <string name="send_log">Günlükleri gönder</string>
    <string name="safe_mode">Güvenli mod</string>
    <string name="reboot_to_apply">Değişikliklerin uygulanması için cihazı yeniden başlat</string>
    <string name="module_magisk_conflict">Magisk ile çakışma nedeniyle modüller kullanılamıyor!</string>
    <string name="home_learn_kernelsu">KernelSU\'yu öğrenin</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">KernelSU\'nun nasıl kurulacağını ve modüllerin nasıl kullanılacağını öğrenin</string>
    <string name="home_support_title">Bizi Destekleyin</string>
    <string name="home_support_content">KernelSU ücretsiz ve açık kaynaklı bir yazılımdır ve her zaman öyle kalacaktır. Ancak bağış yaparak bize destek olduğunuzu gösterebilirsiniz.</string>
    <string name="about_source_code"><![CDATA[%1$s adresinde kaynak kodunu görüntüleyin.<br/>%2$s kanalımıza katılın.]]></string>
    <string name="profile" translatable="false">Uygulama profili</string>
    <string name="profile_default">Varsayılan</string>
    <string name="profile_template">Şablon</string>
    <string name="profile_custom">Özel</string>
    <string name="profile_name">Profil adı</string>
    <string name="profile_namespace">Ad alanını bağla</string>
    <string name="profile_namespace_inherited">Kalıtsal</string>
    <string name="profile_namespace_global">Küresel</string>
    <string name="profile_namespace_individual">Bireysel</string>
    <string name="profile_groups">Gruplar</string>
    <string name="profile_capabilities">Yetkinlikler</string>
    <string name="profile_selinux_context">SELinux içeriği</string>
    <string name="profile_umount_modules">Modüllerin bağlantısını kes</string>
    <string name="failed_to_update_app_profile">%s için uygulama profili güncellenemedi</string>
    <string name="require_kernel_version">Mevcut KernelSU sürümü %1$d, yöneticinin düzgün çalışabilmesi için çok düşük. Lütfen %2$d sürümüne veya daha yüksek bir sürüme güncelleyin!</string>
    <string name="settings_umount_modules_default">Varsayılan olarak modüllerin bağlantısını kes</string>
    <string name="settings_umount_modules_default_summary">Uygulama profilindeki \"Modüllerin bağlantısını kes\" seçeneği için varsayılan değer. Etkinleştirilirse, profil ayarı yapılmamış uygulamalar için modüllerin sistemde yaptığı tüm değişiklikler kaldırılacaktır</string>
    <string name="profile_umount_modules_summary">Bu seçeneği etkinleştirmek, KernelSU\'nun bu uygulama için modüller tarafından değiştirilen dosyaları geri yüklemesine izin verir</string>
    <string name="profile_selinux_domain">İsim alanı</string>
    <string name="profile_selinux_rules">Kurallar</string>
    <string name="module_update">Güncelle</string>
    <string name="module_downloading">Modül indiriliyor: %s</string>
    <string name="module_start_downloading">İndirme başladı: %s</string>
    <string name="new_version_available">Yeni sürüm: %s kullanılabilir, güncellemek için tıklayın</string>
    <string name="launch_app">Uygulamayı başlat</string>
    <string name="force_stop_app">Uygulamayı durmaya zorla</string>
    <string name="restart_app">Uygulamayı yeniden başlat</string>
    <string name="failed_to_update_sepolicy">%s için SELinux kuralları güncellenemedi</string>
    <string name="module_changelog">Değişiklik geçmişi</string>
    <string name="settings_profile_template">Uygulama profili şablonu</string>
    <string name="settings_profile_template_summary">Yerel ve çevrimiçi uygulama profili şablonlarını yönetin</string>
    <string name="app_profile_template_create">Şablon oluştur</string>
    <string name="app_profile_template_edit">Şablonu düzenle</string>
    <string name="app_profile_template_id">Kimlik</string>
    <string name="app_profile_template_id_invalid">Geçersiz şablon kimliği</string>
    <string name="app_profile_template_name">İsim</string>
    <string name="app_profile_template_description">Açıklama</string>
    <string name="app_profile_template_save">Kaydet</string>
    <string name="app_profile_template_delete">Sil</string>
    <string name="app_profile_template_view">Şablonu görüntüle</string>
    <string name="app_profile_template_id_exist">Şablon kimliği zaten var!</string>
    <string name="app_profile_import_export">İçe aktar/Dışa aktar</string>
    <string name="app_profile_import_from_clipboard">Panodan içe aktar</string>
    <string name="app_profile_export_to_clipboard">Panodan dışa aktar</string>
    <string name="app_profile_template_export_empty">Dışa aktarmak için yerel şablon bulunamadı!</string>
    <string name="app_profile_template_import_success">Başarıyla içe aktarıldı</string>
    <string name="app_profile_template_save_failed">Şablon kaydedilemedi</string>
    <string name="app_profile_template_import_empty">Pano boş!</string>
    <string name="settings_check_update">Güncellemeleri denetle</string>
    <string name="settings_check_update_summary">Uygulamayı açarken güncellemeleri otomatik denetle</string>
    <string name="grant_root_failed">Root izni verilemedi!</string>
    <string name="open">Aç</string>
    <string name="enable_web_debugging">Web görünümü hata ayıklamasını etkinleştir</string>
    <string name="enable_web_debugging_summary">Web kullanıcı arayüzünde hata ayıklamak için kullanılabilir, lütfen yalnızca gerektiğinde etkinleştirin</string>
    <string name="direct_install">Doğrudan kur (Tavsiye edilen)</string>
    <string name="select_file">Bir dosya seçin</string>
    <string name="install_inactive_slot">Etkin olmayan yuvaya kur (OTA\'dan sonra)</string>
    <string name="install_inactive_slot_warning">Cihazınız geçerli etkin olmayan yuvaya **ZORLA** yeniden başlatılacaktır!
\nBu seçeneği yalnızca OTA tamamlandıktan sonra kullanın.
\nDevam edilsin mi?</string>
    <string name="install_next">Sonraki</string>
    <string name="select_kmi">KMI seçin</string>
    <string name="select_file_tip">%1$s bölüm imajı önerilir</string>
    <string name="settings_uninstall_temporary">Geçici olarak kaldır</string>
    <string name="settings_uninstall_permanent">Kalıcı olarak kaldır</string>
    <string name="settings_restore_stock_image">Stok imajı geri yükle</string>
    <string name="settings_uninstall_temporary_message">KernelSU\'yu geçici olarak kaldır, bir sonraki yeniden başlatmadan sonra orijinal durumuna geri yükle</string>
    <string name="settings_uninstall">Kaldır</string>
    <string name="settings_uninstall_permanent_message">KernelSU (Root ve tüm modüller) tamamen ve kalıcı olarak kaldırılıyor</string>
    <string name="settings_restore_stock_image_message">Stok fabrika imajını geri yükler (eğer yedek varsa), genellikle OTA\'dan önce kullanılır; KernelSU\'yu kaldırmanız gerekiyorsa, lütfen \"Kalıcı olarak kaldır\" seçeneğini kullanın</string>
    <string name="flash_success">Flaşlama başarılı</string>
    <string name="selected_lkm">Seçili LKM: %s</string>
    <string name="flashing">Flaşlanıyor</string>
    <string name="flash_failed">Flaşlama başarısız</string>
    <string name="save_log">Günlükleri Kaydet</string>
    <string name="action">Aksiyon</string>
    <string name="log_saved">Günlükler kaydedildi</string>
    <string name="confirm">Onayla</string>
    <string name="su_not_allowed">%s için Superuser erişimi verilemedi</string>
    <string name="module_install_prompt_with_name">Aşağıdaki modüller yüklenecek: %1$s</string>
    <string name="module_sort_action_first">Sırala (Action önce)</string>
    <string name="module_sort_enabled_first">Sırala (Etkin olanlar önce)</string>
    <string name="module_repos">Depolar</string>
    <string name="module_repos_sort_name">Ad (A → Z)</string>
    <string name="module_repos_source_code">Kaynak kodu</string>
    <string name="metamodule_uninstall_confirm">%s modülünü kaldırmak istediğinizden emin misiniz? Bu eylem tüm modülleri etkileyecek ve metamodül (örneğin bağlama özelliği) tarafından sunulan belli özellikler artık çalışmayacaktır.</string>
    <string name="home_gki_warning">v3.0.0 sürümünden itibaren GKI çalışma modu yalnızca test ortamlarında kullanılacaktır. Günlük kullanım için tavsiye etmiyoruz ve imaj dosyaları artık sunulmayacaktır.</string>
    <string name="settings_sucompat">su ikili dosyasını yeniden yönlendir</string>
    <string name="settings_sucompat_summary">Uygulama Profilinde Süper Kullanıcı izni verilen uygulamaların /system/bin/su yürütülerek süper kullanıcı kabuğu almasına izin verir; yalnızca yeni işlemler için etkilidir.</string>
    <string name="settings_kernel_umount">Çekirdek bağlantısını kes</string>
    <string name="settings_kernel_umount_summary">KernelSU tarafından kontrol edilen çekirdek seviyesinde bağlantı kesme davranışı</string>
</resources>

```

`manager/app/src/main/res/values-uk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">Головна</string>
    <string name="home_not_installed">Не встановлено</string>
    <string name="home_click_to_install">Натисніть щоб встановити</string>
    <string name="home_working">Працює</string>
    <string name="home_working_version">Версія: %d</string>
    <string name="home_unsupported">Не підтримується</string>
    <string name="home_unsupported_reason">KernelSU зараз підтримує лише ядра GKI.</string>
    <string name="home_kernel">Версія ядра</string>
    <string name="home_manager_version">Версія менеджера</string>
    <string name="home_fingerprint">Відбиток</string>
    <string name="home_selinux_status">Статус SELinux</string>
    <string name="selinux_status_disabled">Вимкнено</string>
    <string name="selinux_status_enforcing">Примусовий</string>
    <string name="selinux_status_permissive">Дозвільний</string>
    <string name="selinux_status_unknown">Невідомо</string>
    <string name="superuser">Суперкористувач</string>
    <string name="module_failed_to_enable">Не вдалося ввімкнути модуль: %s</string>
    <string name="module_failed_to_disable">Не вдалося вимкнути модуль: %s</string>
    <string name="module_empty">Модуль не встановлено</string>
    <string name="module">Модулі</string>
    <string name="uninstall">Видалити</string>
    <string name="module_install">Встановити</string>
    <string name="install">Встановити</string>
    <string name="reboot">Перезавантажити</string>
    <string name="settings">Налаштування</string>
    <string name="reboot_userspace">М\'яке перезавантаження</string>
    <string name="reboot_recovery">Перезавантажити до Recovery</string>
    <string name="reboot_bootloader">Перезавантажити до Bootloader</string>
    <string name="reboot_download">Перезавантажити до Download</string>
    <string name="reboot_edl">Перезавантажити до EDL</string>
    <string name="about">Про додаток</string>
    <string name="module_uninstall_confirm">Ви впевнені, що хочете видалити модуль %s?</string>
    <string name="module_uninstall_success">%s невстановлено</string>
    <string name="module_uninstall_failed">Не вдалося видалити: %s</string>
    <string name="module_version">Версія</string>
    <string name="module_author">Автор</string>
    <string name="show_system_apps">Показати системні додатки</string>
    <string name="send_log">Надіслати журнали</string>
    <string name="safe_mode">Безпечний режим</string>
    <string name="reboot_to_apply">Перезавантажте, щоб застосувати</string>
    <string name="module_magisk_conflict">Модулі недоступні через конфлікт з Magisk!</string>
    <string name="home_learn_kernelsu">Дізнайтеся про KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Дізнайтеся, як інсталювати KernelSU і використовувати модулі.</string>
    <string name="home_support_title">Підтримати нас</string>
    <string name="home_support_content">KernelSU є і завжди буде безкоштовним програмним забезпеченням з відкритим вихідним кодом. Однак ви можете показати нам, що вам небайдужа наша допомога, зробивши пожертву.</string>
    <string name="about_source_code"><![CDATA[Переглянути вихідний код на %1$s<br/>Приєднуйтесь до нашого каналу %2$s]]></string>
    <string name="profile">Профіль додатка</string>
    <string name="profile_default">Типовий</string>
    <string name="profile_template">Шаблон</string>
    <string name="profile_custom">Власний</string>
    <string name="profile_name">Назва профілю</string>
    <string name="profile_namespace">Змонтувати простір імен</string>
    <string name="profile_namespace_inherited">Наслідуваний</string>
    <string name="profile_namespace_global">Глобальний</string>
    <string name="profile_namespace_individual">Індивідуальний</string>
    <string name="profile_groups">Групи</string>
    <string name="profile_capabilities">Можливості</string>
    <string name="profile_selinux_context">Контекст SELinux</string>
    <string name="profile_umount_modules">Розмонтування модулів</string>
    <string name="failed_to_update_app_profile">Не вдалося оновити профіль додатка для %s</string>
    <string name="settings_umount_modules_default">Розмонтування модулів за замовчуванням</string>
    <string name="settings_umount_modules_default_summary">Загальне значення за замовчуванням для \"Розмонтувати модулі\" у профілях додатків. Якщо ввімкнено, буде видалено всі модифікації модулів у системі для додатків, які не мають встановленого профілю.</string>
    <string name="profile_umount_modules_summary">Увімкнення цієї опції дозволить KernelSU відновити будь-які змінені файли модулями для цієї програми.</string>
    <string name="profile_selinux_domain">Домен</string>
    <string name="profile_selinux_rules">Правила</string>
    <string name="module_update">Оновити</string>
    <string name="module_downloading">Завантаження модуля: %s</string>
    <string name="module_start_downloading">Початок завантаження: %s</string>
    <string name="launch_app">Запустити</string>
    <string name="force_stop_app">Примусова зупинка</string>
    <string name="restart_app">Перезапустити</string>
    <string name="new_version_available">Доступна нова версія %s, натисніть, щоб оновити!</string>
    <string name="failed_to_update_sepolicy">Не вдалося оновити правила SELinux для %s</string>
    <string name="module_changelog">Журнал змін</string>
    <string name="require_kernel_version">Поточна версія KernelSU %1$d занадто низька для належної роботи менеджера. Будь ласка, оновіть його до версії %2$d або вище!</string>
    <string name="app_profile_template_import_success">Успішно імпортовано</string>
    <string name="app_profile_export_to_clipboard">Експортувати в буфер обміну</string>
    <string name="app_profile_template_export_empty">Не вдається знайти локальний шаблон для експорту!</string>
    <string name="app_profile_template_id_exist">Ідентифікатор шаблону вже існує!</string>
    <string name="app_profile_import_from_clipboard">Імпортувати з буферу обміну</string>
    <string name="app_profile_template_name">Ім\'я</string>
    <string name="app_profile_template_id_invalid">Недійсний ідентифікатор шаблону</string>
    <string name="app_profile_template_create">Створити шаблон</string>
    <string name="app_profile_import_export">Імпорт/Експорт</string>
    <string name="app_profile_template_save_failed">Помилка при збереженні шаблону</string>
    <string name="app_profile_template_edit">Редагувати шаблон</string>
    <string name="app_profile_template_id">Ідентифікатор</string>
    <string name="settings_profile_template">Шаблон профілю програми</string>
    <string name="app_profile_template_description">Опис</string>
    <string name="app_profile_template_save">Зберегти</string>
    <string name="settings_profile_template_summary">Керувати локальними та мережевими шаблонами профілів додатків.</string>
    <string name="app_profile_template_delete">Видалити</string>
    <string name="app_profile_template_import_empty">Буфер обміну пустий!</string>
    <string name="app_profile_template_view">Переглянути шаблон</string>
    <string name="enable_web_debugging">Налагодження WebView</string>
    <string name="select_kmi">Виберіть KMI</string>
    <string name="install_next">Далі</string>
    <string name="settings_check_update">Перевірити наявність оновлень</string>
    <string name="settings_check_update_summary">Автоматична перевірка оновлень під час відкриття програми.</string>
    <string name="enable_web_debugging_summary">Можна використовувати для налагодження веб-інтерфейсу. Вмикайте лише за потреби.</string>
    <string name="direct_install">Пряме встановлення (рекомендовано)</string>
    <string name="select_file">Виберіть файл</string>
    <string name="install_inactive_slot">Встановити в неактивний слот (після OTA)</string>
    <string name="install_inactive_slot_warning">Ваш пристрій буде **ПРИМУСОВО** завантажено в поточний неактивний слот після перезавантаження!
\n Використовуйте цю опцію тільки після завершення OTA.
\n Продовжити?</string>
    <string name="select_file_tip">%1$s образ розділу рекомендується</string>
    <string name="grant_root_failed">Не вдалося отримати root!</string>
    <string name="open">Відкрити</string>
    <string name="settings_uninstall_temporary">Тимчасово видалити</string>
    <string name="settings_uninstall_permanent">Видалити назавжди</string>
    <string name="settings_restore_stock_image">Відновити стокове зображення</string>
    <string name="settings_uninstall_temporary_message">Тимчасово видалити KernelSU, відновити початковий стан після наступного перезавантаження.</string>
    <string name="settings_uninstall">Видалити</string>
    <string name="flashing">Прошивка</string>
    <string name="flash_success">Прошивку виконано</string>
    <string name="flash_failed">Прошивка не виконана</string>
    <string name="selected_lkm">Вибраний ЛКМ: %s</string>
    <string name="settings_uninstall_permanent_message">Повне та остаточне видалення KernelSU (root та всіх модулів).</string>
    <string name="settings_restore_stock_image_message">Відновити стоковий заводський образ (якщо є резервна копія), зазвичай використовується перед OTA; якщо вам потрібно видалити KernelSU, використовуйте \"Назавжди видалити\".</string>
    <string name="save_log">Зберегти Журнали</string>
    <string name="module_install_prompt_with_name">Будуть встановлені такі модулі: %1$s</string>
    <string name="module_sort_action_first">Дія спочатку</string>
    <string name="module_sort_enabled_first">Увімкнено першим</string>
    <string name="confirm">Підтвердити</string>
    <string name="su_not_allowed">Не вдалося надати доступ суперкористувачу для %s</string>
    <string name="action">Дія</string>
    <string name="log_saved">Журнали збережено</string>
    <string name="settings_module_check_update">Перевірити наявність оновлень модулів</string>
    <string name="install_upload_lkm_file">Використовувати локальний LKM-файл</string>
    <string name="install_only_support_ko_file">Підтримуються лише файли .ko</string>
    <string name="settings_sucompat">Перенаправлення бінарного файлу su</string>
    <string name="settings_sucompat_summary">Дозволяє програмам з правами Суперкористувача в профілі програми отримати оболонку суперкористувача шляхом виконання /system/bin/su; діє тільки для нових процесів.</string>
    <string name="settings_kernel_umount">Розмонтування ядра</string>
    <string name="settings_kernel_umount_summary">Поведінка розмонтування на рівні ядра, контрольована KernelSU</string>
    <string name="processing">Обробка…</string>
    <string name="refresh_pulling">Потягніть униз, щоб оновити</string>
    <string name="refresh_release">Відпустіть для оновлення</string>
    <string name="refresh_refresh">Оновлення…</string>
    <string name="refresh_complete">Оновлено успішно</string>
    <string name="install_select_partition">Виберіть розділ</string>
    <string name="metamodule_uninstall_confirm">Ви впевнені, що хочете видалити модуль %s? Ця дія вплине на всі модулі, а деякі функції, що надаються метамодулем (наприклад, монтування), більше не працюватимуть.</string>
    <string name="app_profile_affects_following_apps">Впливає на такі програми</string>
    <string name="group_contains_apps">Містить %d програм</string>
    <string name="settings_theme">Тема</string>
    <string name="settings_theme_summary">Виберіть режим теми програми.</string>
    <string name="settings_theme_mode_system">Слідкувати за системою</string>
    <string name="settings_theme_mode_light">Світло</string>
    <string name="settings_theme_mode_dark">Темний</string>
    <string name="settings_theme_mode_monet_system">Моне (система підписок)</string>
    <string name="settings_theme_mode_monet_light">Моне (Світло)</string>
    <string name="settings_theme_mode_monet_dark">Моне (Темний)</string>
    <string name="settings_key_color">Ключовий колір</string>
    <string name="settings_key_color_summary">Налаштуйте акцент під час використання Monet.</string>
    <string name="settings_key_color_default">За замовчуванням</string>
    <string name="color_blue">Синій</string>
    <string name="color_red">Червоний</string>
    <string name="color_green">Зелений</string>
    <string name="color_purple">Фіолетовий</string>
    <string name="color_orange">Помаранчевий</string>
    <string name="color_teal">Бірюзовий</string>
    <string name="color_pink">Рожевий</string>
    <string name="color_brown">Коричневий</string>
    <string name="feature_status_unsupported_summary">Ядро не підтримує цю функцію.</string>
    <string name="feature_status_managed_summary">Цією функцією керує модуль.</string>
    <string name="module_repos">Репозиторій модулів</string>
    <string name="module_repos_sort_name">Ім\'я (А → Я)</string>
    <string name="module_repos_source_code">Вихідний код</string>
    <string name="home_gki_warning">Починаючи з версії 3.0.0, робочий режим GKI використовуватиметься лише в тестових середовищах. Ми не рекомендуємо його для щоденного використання, а файли зображень більше не надаватимуться.</string>
    <string name="undo">Відмінити</string>
    <string name="module_undo_uninstall_success">Видалення %s успішно скасовано</string>
    <string name="module_undo_uninstall_failed">Не вдалося відмінити видалення: %s</string>
    <string name="network_offline">Не підключено до мережі</string>
    <string name="network_retry">Повторити спробу</string>
    <string name="tab_readme">Файл README</string>
    <string name="tab_releases">Релізи</string>
    <string name="tab_info">Інформація</string>
    <string name="safe_mode_module_disabled">Встановлення модулів вимкнено в безпечному режимі</string>
</resources>

```

`manager/app/src/main/res/values-vi/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="profile">Hồ sơ ứng dụng</string>
    <string name="profile_default">Mặc định</string>
    <string name="profile_template">Bản mẫu</string>
    <string name="profile_custom">Tuỳ chỉnh</string>
    <string name="profile_name">Tên hồ sơ</string>
    <string name="profile_groups">Nhóm</string>
    <string name="failed_to_update_app_profile">Cập nhật Hồ sơ ứng dụng cho %s thất bại</string>
    <string name="settings_umount_modules_default">Umount modules</string>
    <string name="settings_umount_modules_default_summary">Giá trị mặc định chung cho \"Umount modules\" trong Hồ sơ ứng dụng. Nếu được bật, mọi thay đổi hệ thống do các module gây ra sẽ bị gỡ bỏ khỏi hệ thống và các ứng dụng chưa thiết lập hồ sơ.</string>
    <string name="profile_umount_modules_summary">Bật tùy chọn này sẽ cho phép KernelSU khôi phục mọi file đã được các module sửa đổi trong ứng dụng này.</string>
    <string name="module_update">Cập nhật</string>
    <string name="module_downloading">Đang tải xuống module: %s</string>
    <string name="module_start_downloading">Bắt đầu tải xuống: %s</string>
    <string name="new_version_available">Phiên bản mới %s đã có sẵn, nhấn để cập nhật!</string>
    <string name="home_learn_kernelsu">Tìm hiểu về KernelSU</string>
    <string name="home_click_to_learn_kernelsu">Tìm hiểu cách cài đặt KernelSU và sử dụng các module.</string>
    <string name="home_support_title">Ủng hộ chúng tôi</string>
    <string name="home_support_content">KernelSU sẽ luôn là miễn phí và mã nguồn mở. Tuy nhiên, bạn có thể cho chúng tôi thấy rằng bạn quan tâm bằng cách quyên góp!</string>
    <string name="about_source_code"><![CDATA[Xem mã nguồn tại %1$s<br/>Tham gia kênh %2$s của chúng tôi]]></string>
    <string name="module_magisk_conflict">Các module bị vô hiệu hoá do xung đột với Magisk!</string>
    <string name="module_uninstall_confirm">Bạn có THẬT SỰ muốn gỡ cài đặt module %s không?</string>
    <string name="send_log">Gửi nhật ký</string>
    <string name="home">Trang chủ</string>
    <string name="home_not_installed">Chưa cài đặt</string>
    <string name="home_click_to_install">Nhấn để cài đặt</string>
    <string name="home_working">Đang hoạt động</string>
    <string name="home_working_version">Phiên bản: %d</string>
    <string name="home_unsupported">Không được hỗ trợ</string>
    <string name="home_unsupported_reason">KernelSU hiện tại chỉ hỗ trợ Kernel GKI, nhưng bạn có thể patch file .img của thiết bị GKI mà bạn cần.</string>
    <string name="home_kernel">Phiên bản Kernel</string>
    <string name="home_manager_version">Phiên bản Trình quản lý</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">Trạng thái SELinux</string>
    <string name="selinux_status_disabled">Vô hiệu hoá</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Không xác định</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Không thể kích hoạt module: %s</string>
    <string name="module_failed_to_disable">Không thể vô hiệu hoá module: %s</string>
    <string name="module_empty">Chưa có module nào được cài đặt</string>
    <string name="module">Module</string>
    <string name="uninstall">Gỡ cài đặt</string>
    <string name="module_install">Cài đặt</string>
    <string name="install">Cài đặt</string>
    <string name="reboot">Khởi động lại</string>
    <string name="settings">Cài đặt</string>
    <string name="reboot_userspace">Khởi động lại mềm</string>
    <string name="reboot_recovery">Khởi động lại vào Recovery</string>
    <string name="reboot_bootloader">Khởi động lại vào Bootloader</string>
    <string name="reboot_download">Khởi động lại vào Download</string>
    <string name="reboot_edl">Khởi động lại vào EDL</string>
    <string name="about">Thông tin</string>
    <string name="module_uninstall_success">%s đã được gỡ cài đặt</string>
    <string name="module_uninstall_failed">Gỡ cài đặt thất bại: %s</string>
    <string name="module_version">Phiên bản</string>
    <string name="module_author">Tác giả</string>
    <string name="show_system_apps">Hiển thị các ứng dụng hệ thống</string>
    <string name="safe_mode">Chế độ an toàn</string>
    <string name="reboot_to_apply">Khởi động lại để có hiệu lực</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="profile_selinux_domain">Tên miền</string>
    <string name="profile_selinux_rules">Quy tắc</string>
    <string name="launch_app">Khởi chạy</string>
    <string name="restart_app">Khởi động lại</string>
    <string name="profile_namespace">Không gian tên</string>
    <string name="profile_capabilities">Tính tương thích</string>
    <string name="failed_to_update_sepolicy">Cập nhật quy tắc SELinux cho %s thất bại</string>
    <string name="force_stop_app">Buộc dừng</string>
    <string name="profile_namespace_inherited">Thừa hưởng</string>
    <string name="profile_namespace_global">Toàn cục</string>
    <string name="profile_namespace_individual">Riêng biệt</string>
    <string name="profile_selinux_context">Bối cảnh SELinux</string>
    <string name="profile_umount_modules">Umount modules</string>
    <string name="require_kernel_version">Phiên bản KernelSU hiện tại %1$d quá thấp để Trình quản lý hoạt động bình thường. Vui lòng cập nhật lên phiên bản %2$d hoặc cao hơn!</string>
    <string name="app_profile_template_import_success">Đã nhập thành công</string>
    <string name="app_profile_export_to_clipboard">Xuất vào bộ nhớ tạm</string>
    <string name="app_profile_template_export_empty">Không tìm thấy mẫu cục bộ để xuất!</string>
    <string name="app_profile_template_id_exist">ID mẫu đã tồn tại!</string>
    <string name="module_changelog">Nhật ký thay đổi</string>
    <string name="app_profile_import_from_clipboard">Nhập từ bộ nhớ tạm</string>
    <string name="app_profile_template_name">Tên</string>
    <string name="app_profile_template_id_invalid">ID mẫu không hợp lệ</string>
    <string name="app_profile_template_create">Tạo mẫu</string>
    <string name="app_profile_import_export">Nhập/Xuất</string>
    <string name="app_profile_template_save_failed">Lưu mẫu thất bại</string>
    <string name="app_profile_template_edit">Chỉnh sửa mẫu</string>
    <string name="settings_profile_template">Mẫu Hồ sơ ứng dụng</string>
    <string name="app_profile_template_description">Mô tả</string>
    <string name="app_profile_template_save">Lưu</string>
    <string name="settings_profile_template_summary">Quản lý mẫu cục bộ và trực tuyến của Hồ sơ ứng dụng.</string>
    <string name="app_profile_template_delete">Xóa</string>
    <string name="app_profile_template_import_empty">Bộ nhớ tạm đang trống!</string>
    <string name="app_profile_template_view">Xem mẫu</string>
    <string name="app_profile_template_id">ID</string>
    <string name="enable_web_debugging">Gỡ lỗi WebView</string>
    <string name="enable_web_debugging_summary">Có thể sử dụng để gỡ lỗi WebUI. Vui lòng chỉ bật khi cần thiết.</string>
    <string name="grant_root_failed">Cấp quyền root thất bại!</string>
    <string name="settings_check_update">Kiểm tra cập nhật</string>
    <string name="settings_check_update_summary">Tự động kiểm tra cập nhật khi mở ứng dụng.</string>
    <string name="open">Mở</string>
    <string name="install_inactive_slot">Cài đặt vào phân vùng không hoạt động (Sau OTA)</string>
    <string name="install_inactive_slot_warning">Thiết bị của bạn sẽ **BUỘC** phải khởi động vào phân vùng không hoạt động hiện tại sau khi khởi động lại!\nChỉ dùng tùy chọn này khi cập nhật OTA đã hoàn tất!\nTiếp tục?</string>
    <string name="settings_uninstall_temporary_message">Gỡ cài đặt tạm thời KernelSU, khôi phục lại trạng thái ban đầu sau lần khởi động lại tiếp theo.</string>
    <string name="select_kmi">Chọn KMI</string>
    <string name="install_next">Kế tiếp</string>
    <string name="direct_install">Cài đặt trực tiếp (Khuyến nghị)</string>
    <string name="select_file">Chọn file</string>
    <string name="settings_uninstall">Gỡ cài đặt</string>
    <string name="settings_uninstall_temporary">Gỡ cài đặt tạm thời</string>
    <string name="settings_uninstall_permanent">Gỡ cài đặt vĩnh viễn</string>
    <string name="settings_restore_stock_image">Khôi phục image gốc</string>
    <string name="settings_uninstall_permanent_message">Gỡ cài đặt KernelSU (root và tất cả các module) sạch hoàn toàn, trả về trạng thái ban đầu.</string>
    <string name="settings_restore_stock_image_message">Khôi phục lại image gốc (nếu có bản sao lưu), thường được sử dụng trước OTA; nếu bạn cần gỡ hẳn KernelSU, hãy sử dụng \"Gỡ cài đặt vĩnh viễn\".</string>
    <string name="flashing">Đang Flash...</string>
    <string name="flash_success">Flash thành công</string>
    <string name="flash_failed">Flash thất bại</string>
    <string name="selected_lkm">LKM đã chọn: %s</string>
    <string name="select_file_tip">Phân vùng image %1$s được khuyến nghị</string>
    <string name="save_log">Lưu nhật ký</string>
    <string name="module_sort_action_first">Khởi chạy trước</string>
    <string name="module_install_prompt_with_name">Các module sau đây sẽ được cài đặt: %1$s</string>
    <string name="confirm">Xác nhận</string>
    <string name="module_sort_enabled_first">Bật trước</string>
    <string name="su_not_allowed">Không thể cấp quyền Superuser cho %s</string>
    <string name="action">Khởi chạy</string>
    <string name="log_saved">Đã lưu nhật ký</string>
    <string name="settings_module_check_update">Kiểm tra cập nhật module</string>
    <string name="install_upload_lkm_file">Sử dụng file LKM cục bộ</string>
    <string name="install_only_support_ko_file">Chỉ hỗ trợ các file .ko</string>
    <string name="settings_sucompat">Lệnh SU cổ điển</string>
    <string name="settings_sucompat_summary">Cho phép truy cập root thông qua /system/bin/su, trong các tiến trình mới.</string>
    <string name="settings_kernel_umount">Umount modules (Kernel)</string>
    <string name="settings_kernel_umount_summary">Umount modules khỏi Kernel trong Hồ sơ ứng dụng.</string>
    <string name="processing">Đang xử lý…</string>
    <string name="refresh_pulling">Kéo xuống để làm mới</string>
    <string name="refresh_release">Thả để làm mới</string>
    <string name="refresh_refresh">Đang làm mới…</string>
    <string name="refresh_complete">Đã làm mới thành công</string>
    <string name="install_select_partition">Chọn phân vùng</string>
    <string name="app_profile_affects_following_apps">Ảnh hưởng đến các ứng dụng sau</string>
    <string name="group_contains_apps">Chứa %d ứng dụng</string>
    <string name="metamodule_uninstall_confirm">Bạn có chắc chắn muốn gỡ cài đặt module %s không? Thao tác này sẽ ảnh hưởng đến tất cả các module và một số tính năng do siêu module cung cấp (chẳng hạn như mount) sẽ không còn hoạt động nữa.</string>
    <string name="undo">Hoàn tác</string>
    <string name="module_undo_uninstall_success">Đã huỷ việc gỡ cài đặt %s thành công</string>
    <string name="module_undo_uninstall_failed">Hoàn tác gỡ cài đặt: %s thất bại</string>
    <string name="settings_theme">Chủ đề</string>
    <string name="settings_theme_summary">Chọn chủ đề ứng dụng.</string>
    <string name="settings_theme_mode_system">Mặc định theo hệ thống</string>
    <string name="settings_theme_mode_light">Sáng</string>
    <string name="settings_theme_mode_dark">Tối</string>
    <string name="settings_theme_mode_monet_system">Monet (Theo hệ thống)</string>
    <string name="settings_theme_mode_monet_light">Monet (Sáng)</string>
    <string name="settings_theme_mode_monet_dark">Monet (Tối)</string>
    <string name="settings_key_color_summary">Tùy chỉnh màu nhấn khi sử dụng Monet.</string>
    <string name="settings_key_color_default">Mặc định</string>
    <string name="color_blue">Xanh dương</string>
    <string name="color_red">Đỏ</string>
    <string name="color_green">Xanh lục</string>
    <string name="color_purple">Tím</string>
    <string name="color_orange">Cam</string>
    <string name="color_teal">Xanh mòng két</string>
    <string name="color_pink">Hồng</string>
    <string name="color_brown">Nâu</string>
    <string name="settings_key_color">Màu nhấn</string>
    <string name="feature_status_managed_summary">Tính năng này được quản lý bởi một module</string>
    <string name="feature_status_unsupported_summary">Kernel không hỗ trợ tính năng này</string>
    <string name="module_repos">Thư viện</string>
    <string name="module_repos_sort_name">Tên (A → Z)</string>
    <string name="module_repos_source_code">Mã nguồn</string>
    <string name="home_gki_warning">Bắt đầu từ v3.0.0, chế độ GKI sẽ chỉ được sử dụng trong môi trường thử nghiệm. Chúng tôi không khuyến nghị sử dụng chế độ này và các file image sẽ không còn được cung cấp nữa.</string>
    <string name="network_offline">Không có kết nối Internet</string>
    <string name="network_retry">Thử lại</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">Releases</string>
    <string name="tab_info">Info</string>
    <string name="safe_mode_module_disabled">Việc cài đặt module bị vô hiệu hoá ở chế độ an toàn</string>
    <string name="settings_mode_enable_by_default">Bật (Mặc định)</string>
    <string name="settings_mode_disable_until_reboot">Tắt cho đến khi Khởi động lại</string>
    <string name="settings_mode_disable_always">Luôn Tắt</string>
    <string name="module_shortcut_title">Tạo shortcut</string>
    <string name="module_shortcut_name_label">Tên shortcut</string>
    <string name="module_shortcut_icon_pick">Chọn icon tuỳ chỉnh</string>
    <string name="module_shortcut_add">Thêm shortcut</string>
    <string name="module_shortcut_not_supported">Launcher không hỗ trợ shortcut.</string>
    <string name="module_shortcut_created">Shortcut đã được tạo.</string>
    <string name="module_shortcut_updated">Shortcut đã được cập nhật.</string>
    <string name="module_shortcut_delete">Xoá shortcut</string>
    <string name="module_shortcut_type_title">Chọn loại</string>
    <string name="module_shortcut_permission_tip_xiaomi">Vui lòng bật quyền \"Shortcut trên màn hình\" cho ứng dụng này trong Cài đặt Xiaomi.</string>
    <string name="module_shortcut_permission_tip_oppo">Vui lòng bật quyền \"Shortcut trên màn hình\" cho ứng dụng này trong Cài đặt OPPO.</string>
    <string name="module_shortcut_permission_tip_default">Nếu việc tạo shortcut thất bại! Vui lòng bật quyền \"Shortcut trên màn hình\" cho ứng dụng này trong Cài đặt hệ thống.</string>
    <string name="no_such_module">Module %s không tồn tại</string>
    <string name="module_unavailable">Module %s đã bị Vô hiệu hoá, Chờ cập nhật hoặc Gỡ cài đặt</string>
    <string name="select_file_tip_nogki">Vui lòng chọn file .img của thiết bị GKI mà bạn muốn patch</string>
    <string name="current_kmi">Phiên bản KMI của thiết bị này: %s</string>
    <string name="current_device_kmi">KMI của thiết bị này</string>
    <string name="module_action_success">Khởi chạy module đã được thực thi.</string>
    <string name="color_deep_purple">Tím đậm</string>
    <string name="color_indigo">Chàm</string>
    <string name="color_cyan">Xanh lam</string>
    <string name="color_yellow">Vàng</string>
    <string name="color_amber">Hổ phách</string>
    <string name="color_blue_grey">Xám xanh</string>
    <string name="color_sakura">Hoa anh đào</string>
</resources>

```

`manager/app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">主页</string>
    <string name="home_not_installed">未安装</string>
    <string name="home_click_to_install">点击安装</string>
    <string name="home_working">工作中</string>
    <string name="home_working_version">版本：%d</string>
    <string name="home_unsupported">不支持</string>
    <string name="home_unsupported_reason">KernelSU 现在只支持 GKI 内核，但是你可以为 GKI 设备补丁镜像。</string>
    <string name="home_kernel">内核版本</string>
    <string name="home_manager_version">管理器版本</string>
    <string name="home_fingerprint">系统指纹</string>
    <string name="home_selinux_status">SELinux 状态</string>
    <string name="selinux_status_disabled">被禁用</string>
    <string name="selinux_status_enforcing">强制执行</string>
    <string name="selinux_status_permissive">宽容模式</string>
    <string name="selinux_status_unknown">未知</string>
    <string name="superuser">超级用户</string>
    <string name="module_failed_to_enable">无法启用模块：%s</string>
    <string name="module_failed_to_disable">无法禁用模块：%s</string>
    <string name="module_empty">没有安装模块</string>
    <string name="module">模块</string>
    <string name="module_sort_action_first">可执行优先</string>
    <string name="module_sort_enabled_first">已启用优先</string>
    <string name="module_repos">模块仓库</string>
    <string name="module_repos_sort_name">按名称排序</string>
    <string name="module_repos_source_code">源码</string>
    <string name="uninstall">卸载</string>
    <string name="module_install">安装</string>
    <string name="install">安装</string>
    <string name="reboot">重启</string>
    <string name="settings">设置</string>
    <string name="reboot_userspace">软重启</string>
    <string name="reboot_recovery">重启到 Recovery</string>
    <string name="reboot_bootloader">重启到 BootLoader</string>
    <string name="reboot_download">重启到 Download</string>
    <string name="reboot_edl">重启到 EDL</string>
    <string name="about">关于</string>
    <string name="module_uninstall_confirm">确定要卸载模块 %s 吗？</string>
    <string name="metamodule_uninstall_confirm">您确定要卸载模块 %s 吗？此操作将影响所有模块，并且元模块提供的某些功能（如挂载）将不再工作。</string>
    <string name="module_uninstall_success">%s 已卸载</string>
    <string name="module_uninstall_failed">卸载失败：%s</string>
    <string name="module_version">版本</string>
    <string name="module_author">作者</string>
    <string name="show_system_apps">显示系统应用</string>
    <string name="send_log">发送日志</string>
    <string name="safe_mode">安全模式</string>
    <string name="safe_mode_module_disabled">处于安全模式下，禁止安装模块</string>
    <string name="reboot_to_apply">重启生效</string>
    <string name="module_magisk_conflict">因与 Magisk 有冲突，所有模块不可用！</string>
    <string name="home_learn_kernelsu">了解 KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/zh_CN/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">了解如何安装 KernelSU 以及如何开发模块。</string>
    <string name="home_support_title">支持开发</string>
    <string name="home_support_content">KernelSU 将保持免费开源，向开发者捐赠以表示支持。</string>
    <string name="home_gki_warning">自 v3.0.0 起 GKI 工作模式将仅用于测试环境，我们不建议用于日常使用，也不再提供镜像文件。</string>
    <string name="about_source_code"><![CDATA[在 %1$s 查看源码<br/>加入我们的 %2$s 频道<br/>加入我们的 <b><a href="https://pd.qq.com/s/8lipl1brp">QQ</a></b> 频道]]></string>
    <string name="profile_default">默认</string>
    <string name="profile_template">模版</string>
    <string name="profile_custom">自定义</string>
    <string name="profile_name">名称</string>
    <string name="profile_namespace">挂载命名空间</string>
    <string name="profile_namespace_inherited">继承</string>
    <string name="profile_namespace_global">全局</string>
    <string name="profile_namespace_individual">独立</string>
    <string name="profile_groups">组</string>
    <string name="profile_capabilities">权能</string>
    <string name="profile_selinux_context">SELinux</string>
    <string name="profile_umount_modules">卸载模块</string>
    <string name="failed_to_update_app_profile">为 %s 更新 App Profile 失败</string>
    <string name="require_kernel_version">当前 KernelSU 版本 %1$d 过低，管理器无法正常工作，请将内核 KernelSU 版本升级至 %2$d 或以上！</string>
    <string name="settings_umount_modules_default">默认卸载模块</string>
    <string name="settings_umount_modules_default_summary">App Profile 中「卸载模块」的全局默认值，如果启用，会将未自定义 Profile 的应用移除所有模块针对系统的修改。</string>
    <string name="profile_umount_modules_summary">启用该选项后将允许 KernelSU 为本应用还原被模块修改过的文件。</string>
    <string name="profile_selinux_domain">域</string>
    <string name="profile_selinux_rules">规则</string>
    <string name="module_update">更新</string>
    <string name="module_downloading">正在下载模块：%s</string>
    <string name="module_start_downloading">开始下载：%s</string>
    <string name="new_version_available">发现新版本：%s，点击升级！</string>
    <string name="launch_app">启动</string>
    <string name="force_stop_app">强制停止</string>
    <string name="restart_app">重新启动</string>
    <string name="failed_to_update_sepolicy">为 %s 更新 SELinux 策略失败</string>
    <string name="su_not_allowed">无法授予 %s 超级用户权限</string>
    <string name="module_changelog">更新日志</string>
    <string name="settings_profile_template">App Profile 模版</string>
    <string name="settings_profile_template_summary">管理本地和在线的 App Profile 模版。</string>
    <string name="app_profile_template_create">创建模版</string>
    <string name="app_profile_template_edit">编辑模版</string>
    <string name="app_profile_template_id">模版 ID</string>
    <string name="app_profile_template_id_invalid">模版 ID 不合法</string>
    <string name="app_profile_template_name">名字</string>
    <string name="app_profile_template_description">描述</string>
    <string name="app_profile_template_save">保存</string>
    <string name="app_profile_template_delete">删除</string>
    <string name="app_profile_template_view">查看模版</string>
    <string name="app_profile_template_id_exist">模版 ID 已存在！</string>
    <string name="app_profile_import_export">导入/导出</string>
    <string name="app_profile_import_from_clipboard">从剪切板导入</string>
    <string name="app_profile_export_to_clipboard">导出到剪切板</string>
    <string name="app_profile_template_export_empty">没有可以导出的本地模板！</string>
    <string name="app_profile_template_import_success">导入成功</string>
    <string name="app_profile_template_save_failed">模版保存失败</string>
    <string name="app_profile_template_import_empty">剪切板为空！</string>
    <string name="app_profile_affects_following_apps">影响以下应用</string>
    <string name="settings_check_update">检查更新</string>
    <string name="settings_check_update_summary">在应用启动后自动检查是否有最新版。</string>
    <string name="settings_enable_predictive_back">预测性返回手势</string>
    <string name="settings_enable_predictive_back_summary">启用对预测性返回手势的支持。</string>
    <string name="settings_module_check_update">检查模块更新</string>
    <string name="grant_root_failed">获取 root 失败！</string>
    <string name="action">执行</string>
    <string name="open">打开</string>
    <string name="enable_web_debugging">WebView 调试</string>
    <string name="enable_web_debugging_summary">可用于调试 WebUI，请仅在需要时启用。</string>
    <string name="direct_install">直接安装（推荐）</string>
    <string name="select_file">选择一个文件</string>
    <string name="install_inactive_slot">安装到未使用的槽位（OTA 后）</string>
    <string name="install_inactive_slot_warning">将在重启后强制切换到另一个槽位！注意只能在 OTA 更新完成后的重启之前使用。</string>
    <string name="install_next">下一步</string>
    <string name="install_select_partition">选择分区</string>
    <string name="install_upload_lkm_file">使用本地 LKM 文件</string>
    <string name="install_only_support_ko_file">仅支持选择 .ko 文件</string>
    <string name="select_file_tip">建议选择 %1$s 分区镜像</string>
    <string name="select_kmi">选择 KMI</string>
    <string name="settings_uninstall">卸载</string>
    <string name="settings_uninstall_temporary">临时卸载</string>
    <string name="settings_uninstall_permanent">永久卸载</string>
    <string name="settings_restore_stock_image">恢复原厂镜像</string>
    <string name="settings_uninstall_temporary_message">临时卸载 KernelSU，下次重启后恢复至原始状态。</string>
    <string name="settings_uninstall_permanent_message">完全并永久卸载 KernelSU（Root 权限和所有模块）。</string>
    <string name="settings_restore_stock_image_message">恢复原厂镜像（若存在备份），一般在 OTA 前使用；如果你需要卸载 KernelSU，请使用「永久卸载」。</string>
    <string name="flashing">刷写中</string>
    <string name="flash_success">刷写完成</string>
    <string name="flash_failed">刷写失败</string>
    <string name="selected_lkm">已选择的 LKM：%s</string>
    <string name="save_log">保存日志</string>
    <string name="log_saved">日志已保存</string>
    <string name="settings_mode_enable_by_default">启用（默认）</string>
    <string name="settings_mode_disable_until_reboot">禁用直到下次重启</string>
    <string name="settings_mode_disable_always">始终禁用</string>
    <string name="settings_sucompat">传统 su 命令支持</string>
    <string name="settings_sucompat_summary">允许通过 /system/bin/su 获取 Root 权限。</string>
    <string name="settings_kernel_umount">内核处理卸载模块</string>
    <string name="settings_kernel_umount_summary">在内核给需要的应用卸载模块。</string>
    <string name="module_install_prompt_with_name">将安装以下模块：%1$s</string>
    <string name="confirm">确认</string>
    <string name="processing">处理中…</string>
    <string name="refresh_pulling">下拉刷新</string>
    <string name="refresh_release">松开刷新</string>
    <string name="refresh_refresh">正在刷新…</string>
    <string name="refresh_complete">刷新成功</string>
    <string name="undo">撤销</string>
    <string name="module_undo_uninstall_success">成功撤销卸载 %s</string>
    <string name="module_undo_uninstall_failed">撤销卸载 %s 失败</string>
    <string name="group_contains_apps">包含 %d 个应用</string>
    <string name="settings_theme">主题</string>
    <string name="settings_theme_summary">选择应用的主题模式。</string>
    <string name="settings_theme_mode_system">跟随系统</string>
    <string name="settings_theme_mode_light">浅色</string>
    <string name="settings_theme_mode_dark">深色</string>
    <string name="settings_theme_mode_monet_system">Monet（跟随系统）</string>
    <string name="settings_theme_mode_monet_light">Monet（浅色）</string>
    <string name="settings_theme_mode_monet_dark">Monet（深色）</string>
    <string name="settings_key_color">强调色</string>
    <string name="settings_key_color_summary">在使用 Monet 时自定义种子色。</string>
    <string name="settings_key_color_default">默认</string>
    <string name="settings_page_scale">界面缩放</string>
    <string name="settings_page_scale_summary">调整全局显示比例。</string>
    <string name="color_blue">蓝色</string>
    <string name="color_red">红色</string>
    <string name="color_green">绿色</string>
    <string name="color_purple">紫色</string>
    <string name="color_orange">橙色</string>
    <string name="color_teal">青绿</string>
    <string name="color_pink">粉色</string>
    <string name="color_brown">棕色</string>
    <string name="color_sakura">樱花</string>
    <string name="color_deep_purple">深紫</string>
    <string name="color_indigo">靛青</string>
    <string name="color_cyan">青色</string>
    <string name="color_yellow">黄色</string>
    <string name="color_amber">琥珀</string>
    <string name="color_blue_grey">灰蓝</string>
    <string name="network_offline">未连接到网络</string>
    <string name="network_retry">重试</string>
    <string name="tab_readme">自述</string>
    <string name="tab_releases">版本</string>
    <string name="tab_info">信息</string>
    <string name="feature_status_unsupported_summary">内核不支持此特性。</string>
    <string name="feature_status_managed_summary">此功能由一个模块管理。</string>
    <string name="module_shortcut_title">创建快捷方式</string>
    <string name="module_shortcut_name_label">快捷方式名称</string>
    <string name="module_shortcut_icon_pick">选择自定义图标</string>
    <string name="module_shortcut_add">添加快捷方式</string>
    <string name="module_shortcut_not_supported">启动器不支持桌面快捷方式。</string>
    <string name="module_shortcut_created">已在桌面创建快捷方式。</string>
    <string name="module_shortcut_updated">快捷方式已更新。</string>
    <string name="module_shortcut_delete">删除快捷方式</string>
    <string name="module_shortcut_type_title">选择类型</string>
    <string name="module_shortcut_permission_tip_xiaomi">请在 Xiaomi 设置中为本应用启用「桌面快捷方式」权限。</string>
    <string name="module_shortcut_permission_tip_oppo">请在 OPPO 设置中为本应用启用「创建桌面快捷方式」权限。</string>
    <string name="module_shortcut_permission_tip_default">若创建快捷方式失败，请在系统设置中为本应用启用桌面快捷方式权限。</string>
    <string name="no_such_module">模块 %s 不存在</string>
    <string name="module_unavailable">模块 %s 被禁用，待更新或待卸载</string>
    <string name="select_file_tip_nogki">请选择要修补的 GKI 设备镜像文件</string>
    <string name="current_kmi">本设备 KMI 版本: %s</string>
    <string name="current_device_kmi">当前设备的 KMI</string>
    <string name="module_action_success">模块 action 执行成功。</string>
</resources>

```

`manager/app/src/main/res/values-zh-rHK/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">首頁</string>
    <string name="home_not_installed">未安裝</string>
    <string name="home_click_to_install">按一下以安裝</string>
    <string name="home_working">運作中</string>
    <string name="home_working_version">KernelSU 版本：%d</string>
    <string name="home_unsupported">不支援</string>
    <string name="home_unsupported_reason">KernelSU 現在僅支援 GKI 核心</string>
    <string name="home_kernel">核心</string>
    <string name="home_manager_version">管理器版本</string>
    <string name="home_fingerprint">指紋</string>
    <string name="home_selinux_status">SELinux 狀態</string>
    <string name="selinux_status_disabled">已停用</string>
    <string name="selinux_status_enforcing">強制</string>
    <string name="selinux_status_permissive">寬鬆</string>
    <string name="selinux_status_unknown">未知</string>
    <string name="superuser">超級使用者</string>
    <string name="module_failed_to_enable">無法啟用模組：%s</string>
    <string name="module_failed_to_disable">無法停用模組：%s</string>
    <string name="module_empty">尚未安裝模組</string>
    <string name="module">模組</string>
    <string name="uninstall">解除安裝</string>
    <string name="module_install">安裝</string>
    <string name="install">安裝</string>
    <string name="reboot">重新啟動</string>
    <string name="settings">設定</string>
    <string name="reboot_userspace">軟啟動</string>
    <string name="reboot_recovery">重新啟動至 Recovery</string>
    <string name="reboot_bootloader">重新啟動至 Bootloader</string>
    <string name="reboot_download">重新啟動至 Download</string>
    <string name="reboot_edl">重新啟動至 EDL</string>
    <string name="about">關於</string>
    <string name="module_uninstall_confirm">您確定要解除安裝模組「%s」嗎？</string>
    <string name="module_uninstall_success">「%s」已解除安裝</string>
    <string name="module_uninstall_failed">無法解除安裝：%s</string>
    <string name="module_version">版本</string>
    <string name="module_author">作者</string>
    <string name="show_system_apps">顯示系統應用程式</string>
    <string name="send_log">傳送記錄</string>
    <string name="safe_mode">安全模式</string>
    <string name="reboot_to_apply">重新啟動以生效</string>
    <string name="module_magisk_conflict">模組已停用，因其與 Magisk 的模組存在衝突！</string>
    <string name="home_learn_kernelsu">深入瞭解 KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/zh_TW/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">瞭解如何安裝 KernelSU 以及如何開發模組</string>
    <string name="home_support_title">支援開發</string>
    <string name="home_support_content">KernelSU 將保持免費和開源，您可以考慮向開發人員贊助以表示支持。</string>
    <string name="about_source_code"><![CDATA[在 %1$s 中檢視原始碼<br/>加入我們的 %2$s 頻道]]></string>
    <string name="profile_default">預設</string>
    <string name="profile_name">設定檔名稱</string>
    <string name="profile_template">範本</string>
    <string name="profile_namespace_inherited">繼承</string>
    <string name="profile_namespace_global">全域</string>
    <string name="profile_capabilities">功能</string>
    <string name="profile_umount_modules">卸載模組</string>
    <string name="failed_to_update_app_profile">無法更新 %s 應用程式設定檔</string>
    <string name="profile_selinux_rules">規則</string>
    <string name="require_kernel_version">目前 KernelSU 版本 %1$d 過低，管理器無法正常運作。請升級至 %2$d 或更高版本！</string>
    <string name="settings_umount_modules_default_summary">應用程式設定檔中「解除安裝模組」的全域預設值，如果啟用，將會為沒有設定檔的應用程式移除所有模組針對系統的修改。</string>
    <string name="profile_umount_modules_summary">啟用此選項將允許 KernelSU 為這個應用程式還原任何被模組修改過的檔案。</string>
    <string name="profile_selinux_domain">網域</string>
    <string name="module_update">更新</string>
    <string name="profile_custom">自訂</string>
    <string name="profile_namespace">掛載命名空間</string>
    <string name="profile_namespace_individual">個人</string>
    <string name="profile_groups">群組</string>
    <string name="profile_selinux_context">SELinux 環境</string>
    <string name="settings_umount_modules_default">預設解除安裝模組</string>
    <string name="module_downloading">正在下載模組：%s</string>
    <string name="module_start_downloading">開始下載：%s</string>
    <string name="new_version_available">新版本：%s 已可供使用，按一下以升級</string>
    <string name="launch_app">啟動</string>
    <string name="force_stop_app">強制停止</string>
    <string name="restart_app">重新啟動</string>
    <string name="failed_to_update_sepolicy">無法為 %s 更新 SELinux 規則</string>
    <string name="module_changelog">變更記錄</string>
    <string name="app_profile_template_import_success">成功匯出</string>
    <string name="app_profile_export_to_clipboard">導出到剪貼板</string>
    <string name="app_profile_template_export_empty">本地沒有模板可匯出！</string>
    <string name="app_profile_template_id_exist">模板 ID 已存在！</string>
    <string name="app_profile_import_from_clipboard">從剪貼簿匯入</string>
    <string name="app_profile_template_name">名字</string>
    <string name="app_profile_template_id_invalid">模板 ID 無效</string>
    <string name="app_profile_template_create">創建模板</string>
    <string name="app_profile_import_export">匯出 / 匯入</string>
    <string name="app_profile_template_save_failed">模板儲存失敗</string>
    <string name="app_profile_template_edit">編輯模板</string>
    <string name="app_profile_template_id">模板 ID</string>
    <string name="settings_profile_template">App Profile 模板</string>
    <string name="app_profile_template_description">描述</string>
    <string name="app_profile_template_save">儲存</string>
    <string name="settings_profile_template_summary">管理本地和線上的 App Profile 模板</string>
    <string name="app_profile_template_delete">刪除</string>
    <string name="app_profile_template_import_empty">剪貼簿沒有內容！</string>
    <string name="app_profile_template_view">查看模板</string>
    <string name="enable_web_debugging">WebView 除錯模式</string>
    <string name="enable_web_debugging_summary">可用於 WebUI 除錯。請僅在需要時啟用。</string>
    <string name="direct_install">直接安裝（建議）</string>
    <string name="select_file">選取檔案</string>
    <string name="install_inactive_slot">安裝至非活動插槽（OTA 後）</string>
    <string name="install_inactive_slot_warning">重新啟動後將強制由目前非活動插槽開機！請僅在 OTA 完成後才使用此選項。</string>
    <string name="install_next">下一個</string>
    <string name="select_kmi">選取 KMI</string>
    <string name="select_file_tip">建議使用 %1$s 分割區映像</string>
    <string name="grant_root_failed">授予root權限失敗！</string>
    <string name="open">開啟</string>
    <string name="settings_check_update">檢查更新</string>
    <string name="settings_check_update_summary">開啟程式時自動檢查更新。</string>
    <string name="settings_uninstall">解除安裝</string>
    <string name="save_log">儲存日誌</string>
    <string name="processing">處理中…</string>
    <string name="refresh_pulling">下拉刷新</string>
    <string name="refresh_release">鬆開刷新</string>
    <string name="refresh_refresh">正在刷新…</string>
    <string name="refresh_complete">刷新成功</string>
    <string name="settings_sucompat">傳統 su 命令支援</string>
    <string name="settings_sucompat_summary">允許透過 /system/bin/su 獲取 Root 權限，僅對新行程生效。</string>
    <string name="settings_kernel_umount">核心處理解除掛載模組</string>
    <string name="settings_kernel_umount_summary">在核心為需要的應用程式解除掛載模組</string>
    <string name="module_shortcut_title">建立捷徑</string>
    <string name="module_shortcut_name_label">捷徑名稱</string>
    <string name="module_shortcut_icon_pick">選擇自訂圖示</string>
    <string name="module_shortcut_add">新增捷徑</string>
    <string name="module_shortcut_not_supported">啟動器不支援桌面捷徑。</string>
    <string name="module_shortcut_created">已在桌面建立捷徑。</string>
    <string name="module_shortcut_updated">捷徑已更新。</string>
    <string name="module_shortcut_delete">刪除捷徑</string>
    <string name="module_shortcut_type_title">選擇類型</string>
    <string name="module_shortcut_permission_tip_xiaomi">請在 Xiaomi 設定中為此程式啟用「建立桌面捷徑」權限。</string>
    <string name="module_shortcut_permission_tip_oppo">請在 OPPO 設定中為此程式啟用「桌面捷徑」權限。</string>
    <string name="module_shortcut_permission_tip_default">如未能建立捷徑，請在系統設定中為此程式開啟桌面捷徑權限。</string>
    <string name="current_device_kmi">此裝置 KMI</string>
    <string name="current_kmi">此裝置的 KMI 版本：%s</string>
    <string name="settings_key_color_default">預設</string>
    <string name="color_blue">藍色</string>
    <string name="color_red">紅色</string>
    <string name="color_green">綠色</string>
    <string name="color_purple">紫色</string>
    <string name="color_orange">橙色</string>
    <string name="color_teal">藍綠色</string>
    <string name="color_pink">粉紅色</string>
    <string name="color_brown">啡色</string>
    <string name="network_offline">未連接網絡</string>
    <string name="network_retry">重試</string>
    <string name="tab_readme">自述文件</string>
    <string name="tab_releases">版本</string>
    <string name="tab_info">資訊</string>
    <string name="no_such_module">模組 %s 不存在</string>
    <string name="module_unavailable">模組 %s 已停用、更新中或正等待移除</string>
    <string name="select_file_tip_nogki">請選擇需要修補的 GKI 裝置映像檔</string>
    <string name="settings_theme_summary">選擇主題模式。</string>
    <string name="settings_theme_mode_system">跟隨系統</string>
    <string name="settings_theme_mode_light">淺色模式</string>
    <string name="settings_theme_mode_dark">深色模式</string>
    <string name="settings_theme_mode_monet_system">Monet（跟隨系統）</string>
    <string name="settings_theme_mode_monet_light">Monet（淺色）</string>
    <string name="settings_theme_mode_monet_dark">Monet（深色）</string>
    <string name="settings_key_color">主題色</string>
    <string name="settings_key_color_summary">使用 Monet 時自訂強調色。</string>
    <string name="group_contains_apps">內含 %d 個應用程式</string>
    <string name="app_profile_affects_following_apps">受影響程式如下</string>
    <string name="settings_module_check_update">檢查模組更新</string>
    <string name="action">執行</string>
    <string name="settings_theme">介面主題</string>
    <string name="install_select_partition">選取分割區</string>
    <string name="install_upload_lkm_file">使用本地 LKM 檔案</string>
    <string name="install_only_support_ko_file">僅支援 .ko 格式檔案</string>
    <string name="settings_uninstall_temporary">暫時解除安裝</string>
    <string name="settings_uninstall_permanent">永久解除安裝</string>
    <string name="settings_restore_stock_image">恢復原廠映像</string>
    <string name="settings_uninstall_temporary_message">暫時解除安裝 KernelSU，下次重新啟動後恢復原狀。</string>
    <string name="settings_uninstall_permanent_message">徹底永久解除安裝 KernelSU（Root 權限及所有模組）。</string>
    <string name="settings_restore_stock_image_message">恢復原廠映像（如有備份），通常用於 OTA 前；如需解除安裝 KernelSU，請使用「永久解除安裝」。</string>
    <string name="flashing">正在刷入</string>
    <string name="flash_success">刷入成功</string>
    <string name="flash_failed">刷入失敗</string>
    <string name="selected_lkm">已選取 LKM：%s</string>
    <string name="log_saved">日誌已儲存</string>
</resources>

```

`manager/app/src/main/res/values-zh-rTW/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="home">首頁</string>
    <string name="home_not_installed">尚未安裝</string>
    <string name="home_click_to_install">點選開始安裝</string>
    <string name="home_working">已開始運作</string>
    <string name="home_working_version">版本：%d</string>
    <string name="home_unsupported">未受支援</string>
    <string name="home_unsupported_reason">KernelSU 目前僅支援 GKI 核心</string>
    <string name="home_kernel">核心版本</string>
    <string name="home_manager_version">管理工具</string>
    <string name="home_fingerprint">指紋資訊</string>
    <string name="home_selinux_status">SELinux 狀態</string>
    <string name="selinux_status_disabled">已停用</string>
    <string name="selinux_status_enforcing">強制執行</string>
    <string name="selinux_status_permissive">容許執行</string>
    <string name="selinux_status_unknown">不明</string>
    <string name="superuser">授權</string>
    <string name="module_failed_to_enable">無法啟用模組：%s</string>
    <string name="module_failed_to_disable">無法停用模組：%s</string>
    <string name="module_empty">查無已安裝的模組</string>
    <string name="module">模組</string>
    <string name="uninstall">解除安裝</string>
    <string name="module_install">安裝</string>
    <string name="install">安裝</string>
    <string name="reboot">重新啟動</string>
    <string name="settings">設定</string>
    <string name="reboot_userspace">軟重啟</string>
    <string name="reboot_recovery">重新啟動至 Recovery</string>
    <string name="reboot_bootloader">重新啟動至 Bootloader</string>
    <string name="reboot_download">重新啟動至 Download</string>
    <string name="reboot_edl">重新啟動至 EDL</string>
    <string name="about">關於</string>
    <string name="module_uninstall_confirm">你是否要解除安裝「%s」模組？</string>
    <string name="module_uninstall_success">「%s」已解除安裝</string>
    <string name="module_uninstall_failed">無法解除安裝：%s</string>
    <string name="module_version">版本</string>
    <string name="module_author">作者</string>
    <string name="show_system_apps">顯示系統程式</string>
    <string name="send_log">傳送日誌</string>
    <string name="safe_mode">安全模式</string>
    <string name="reboot_to_apply">將在重新啟動時生效</string>
    <string name="module_magisk_conflict">與 Magisk 發生衝突，無法使用模組功能！</string>
    <string name="home_learn_kernelsu">深入瞭解 KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/zh_TW/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">知曉安裝、使用 KernelSU 本體與其模組功能的方法</string>
    <string name="home_support_title">協助發展</string>
    <string name="home_support_content">KernelSU 一向以免費與開放原始碼自居，矢志不渝。若想協助我們，可以用小額捐款表達你對專案發展的大力支持。</string>
    <string name="about_source_code"><![CDATA[前往 %1$s 檢閱原始碼<br/>前往 %2$s 加入頻道]]></string>
    <string name="profile_umount_modules">解除掛載模組功能</string>
    <string name="failed_to_update_app_profile">無法更新「%s」App Profile</string>
    <string name="require_kernel_version">管理工具無法以老舊的 KernelSU %1$d 版本正常運作。請升級至 %2$d 以上的版本！</string>
    <string name="settings_umount_modules_default">預設解除掛載模組功能</string>
    <string name="settings_umount_modules_default_summary">將 App Profile 的全域預設行為設作「解除掛載模組功能」。啟用後，將向未指派 Profile 的應用程式移除模組功能。</string>
    <string name="profile_umount_modules_summary">啟用選項後，KernelSU 會將應用程式內遭模組修改的檔案恢復原狀。</string>
    <string name="profile_default">預設</string>
    <string name="profile_custom">自訂</string>
    <string name="profile_capabilities">權限</string>
    <string name="profile_selinux_rules">規則</string>
    <string name="module_downloading">正在下載模組：%s</string>
    <string name="restart_app">重新執行</string>
    <string name="profile_template">範本</string>
    <string name="profile_name">Profile 名稱</string>
    <string name="profile_namespace">命名空間掛載</string>
    <string name="profile_namespace_inherited">繼承</string>
    <string name="profile_namespace_global">全域</string>
    <string name="profile_namespace_individual">個體</string>
    <string name="profile_groups">群組</string>
    <string name="profile_selinux_context">SELinux 上下文</string>
    <string name="profile_selinux_domain">定域</string>
    <string name="module_update">更新</string>
    <string name="module_start_downloading">準備下載模組：%s</string>
    <string name="new_version_available">版本 %s 現已開放下載，點選開始更新。</string>
    <string name="launch_app">開始執行</string>
    <string name="force_stop_app">強制停止</string>
    <string name="failed_to_update_sepolicy">無法為「%s」更新 SELinux 規則</string>
    <string name="module_changelog">更新說明</string>
    <string name="app_profile_template_id_invalid">範本編號無效</string>
    <string name="app_profile_template_create">建立範本</string>
    <string name="app_profile_template_edit">編輯範本</string>
    <string name="app_profile_template_id">編號</string>
    <string name="settings_profile_template">App Profile 範本</string>
    <string name="settings_profile_template_summary">管理 App Profile 的本地、線上範本</string>
    <string name="app_profile_template_import_success">已成功匯入</string>
    <string name="app_profile_export_to_clipboard">匯出至剪貼簿</string>
    <string name="app_profile_template_export_empty">查無可供匯出的本地範本！</string>
    <string name="app_profile_template_id_exist">編號已由其他範本領有！</string>
    <string name="app_profile_import_from_clipboard">自剪貼簿匯入</string>
    <string name="app_profile_template_name">名稱</string>
    <string name="app_profile_import_export">匯入／匯出</string>
    <string name="app_profile_template_save_failed">無法儲存範本</string>
    <string name="app_profile_template_description">說明</string>
    <string name="app_profile_template_save">儲存</string>
    <string name="app_profile_template_delete">刪除</string>
    <string name="app_profile_template_import_empty">查無剪貼簿內容！</string>
    <string name="app_profile_template_view">檢視範本</string>
    <string name="enable_web_debugging_summary">旨在偵錯 WebUI。請依自身狀況適時啟用。</string>
    <string name="enable_web_debugging">啟用 WebView 偵錯</string>
    <string name="grant_root_failed">無法獲取 Root 權限！</string>
    <string name="open">開啟</string>
    <string name="settings_check_update">檢查更新</string>
    <string name="settings_check_update_summary">開啟本應用程式時，自動檢查更新</string>
    <string name="select_file">選擇檔案</string>
    <string name="install_inactive_slot">安裝至非作用擴充槽（適用於 OTA 更新過後）</string>
    <string name="install_inactive_slot_warning">你的裝置將在重新啟動時**強制**開機至目前的非作用擴充槽！\n確保僅在 OTA 更新過後選擇此選項。\n是否繼續？</string>
    <string name="direct_install">直接安裝（推薦）</string>
    <string name="install_next">繼續</string>
    <string name="select_kmi">選擇 KMI</string>
    <string name="select_file_tip">建議選擇 %1$s 分區的映像檔</string>
    <string name="settings_uninstall">解除安裝</string>
    <string name="settings_uninstall_temporary">暫時性解除安裝</string>
    <string name="settings_restore_stock_image">恢復原廠映像檔</string>
    <string name="settings_uninstall_temporary_message">暫時解除安裝 KernelSU。會在下次重新啟動時恢復原狀。</string>
    <string name="settings_uninstall_permanent">永久性解除安裝</string>
    <string name="settings_uninstall_permanent_message">徹底解除安裝 KernelSU（含 Root 授權與所有的模組）。</string>
    <string name="flashing">正在閃刷</string>
    <string name="flash_success">閃刷成功</string>
    <string name="settings_restore_stock_image_message">若裝置內含有備份檔案，遂以 OTA 更新前的原廠系統映像檔進行復原。若需要解除安裝 KernelSU，請選擇「永久性解除安裝」。</string>
    <string name="flash_failed">閃刷失敗</string>
    <string name="selected_lkm">已選定 LKM：%s</string>
    <string name="save_log">儲存日誌</string>
    <string name="action">執行</string>
    <string name="module_sort_enabled_first">啟用優先</string>
    <string name="module_sort_action_first">執行優先</string>
    <string name="module_install_prompt_with_name">將安裝以下模組：%1$s</string>
    <string name="confirm">確認</string>
    <string name="su_not_allowed">無法授予「%s」超級使用者存取</string>
    <string name="log_saved">已儲存運作日誌</string>
    <string name="processing">處理中…</string>
    <string name="refresh_pulling">下拉刷新</string>
    <string name="refresh_release">鬆開刷新</string>
    <string name="refresh_refresh">正在刷新…</string>
    <string name="refresh_complete">刷新成功</string>
    <string name="module_repos">模組倉庫</string>
    <string name="module_repos_source_code">源碼</string>
    <string name="module_repos_sort_name">按名稱排序</string>
    <string name="undo">撤銷</string>
    <string name="settings_theme">主題</string>
    <string name="settings_theme_mode_system">跟隨系統</string>
    <string name="settings_theme_mode_monet_system">Monet (跟隨系統)</string>
    <string name="settings_theme_mode_light">淺色</string>
    <string name="settings_theme_mode_monet_light">Monet (淺色)</string>
    <string name="settings_theme_mode_dark">深色</string>
    <string name="settings_theme_mode_monet_dark">Monet (深色)</string>
    <string name="settings_theme_summary">選擇應用的主題模式。</string>
    <string name="settings_sucompat">傳統 su 命令支援</string>
    <string name="settings_sucompat_summary">允許透過 /system/bin/su 獲取 Root 權限，僅對新行程生效。</string>
    <string name="settings_kernel_umount">核心處理解除掛載模組</string>
    <string name="settings_kernel_umount_summary">在核心為需要的應用程式解除掛載模組</string>
    <string name="module_shortcut_title">建立捷徑</string>
    <string name="module_shortcut_name_label">捷徑名稱</string>
    <string name="module_shortcut_icon_pick">選擇自訂圖示</string>
    <string name="module_shortcut_add">新增捷徑</string>
    <string name="module_shortcut_not_supported">啟動器不支援桌面捷徑。</string>
    <string name="module_shortcut_created">已在桌面建立捷徑。</string>
    <string name="module_shortcut_updated">捷徑已更新。</string>
    <string name="module_shortcut_delete">刪除捷徑</string>
    <string name="module_shortcut_type_title">選擇類型</string>
    <string name="module_shortcut_permission_tip_xiaomi">請在 Xiaomi 設定中為此應用啟用「建立桌面捷徑」權限。</string>
    <string name="module_shortcut_permission_tip_oppo">請在 OPPO 設定中為此應用啟用「桌面捷徑」權限。</string>
    <string name="module_shortcut_permission_tip_default">若建立捷徑失敗，請在系統設定中為此應用啟用桌面捷徑權限。</string>
    <string name="safe_mode_module_disabled">處於安全模式下，禁止安裝模組</string>
    <string name="settings_module_check_update">檢查模組更新</string>
</resources>

```

`manager/app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFFFF</color>
</resources>
```

`manager/app/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name" translatable="false">KernelSU</string>
    <string name="home">Home</string>
    <string name="home_not_installed">Not installed</string>
    <string name="home_click_to_install">Tap to install</string>
    <string name="home_working">Working</string>
    <string name="home_working_version">Version: %d</string>
    <string name="home_unsupported">Unsupported</string>
    <string name="home_unsupported_reason">KernelSU only supports GKI kernels now, but you can patch the image for GKI devices.</string>
    <string name="home_kernel">Kernel version</string>
    <string name="home_manager_version">Manager version</string>
    <string name="home_fingerprint">Fingerprint</string>
    <string name="home_selinux_status">SELinux status</string>
    <string name="selinux_status_disabled">Disabled</string>
    <string name="selinux_status_enforcing">Enforcing</string>
    <string name="selinux_status_permissive">Permissive</string>
    <string name="selinux_status_unknown">Unknown</string>
    <string name="superuser">Superuser</string>
    <string name="module_failed_to_enable">Failed to enable module: %s</string>
    <string name="module_failed_to_disable">Failed to disable module: %s</string>
    <string name="module_empty">No module installed</string>
    <string name="module">Module</string>
    <string name="module_install_prompt_with_name">The following modules will be installed: %1$s</string>
    <string name="module_sort_action_first">Action first</string>
    <string name="module_sort_enabled_first">Enabled first</string>
    <string name="module_repos">Repos</string>
    <string name="module_repos_sort_name">Name (A → Z)</string>
    <string name="module_repos_source_code">Source code</string>
    <string name="confirm">Confirm</string>
    <string name="uninstall">Uninstall</string>
    <string name="module_install">Install</string>
    <string name="install">Install</string>
    <string name="reboot">Reboot</string>
    <string name="settings">Settings</string>
    <string name="reboot_userspace">Soft reboot</string>
    <string name="reboot_recovery">Reboot to Recovery</string>
    <string name="reboot_bootloader">Reboot to Bootloader</string>
    <string name="reboot_download">Reboot to Download</string>
    <string name="reboot_edl">Reboot to EDL</string>
    <string name="about">About</string>
    <string name="module_uninstall_confirm">Are you sure you want to uninstall module %s?</string>
    <string name="metamodule_uninstall_confirm">Are you sure you want to uninstall module %s? This action will affect all modules, and certain features provided by the metamodule (such as mounting) will no longer work.</string>
    <string name="module_uninstall_success">%s uninstalled</string>
    <string name="module_uninstall_failed">Failed to uninstall: %s</string>
    <string name="module_version">Version</string>
    <string name="module_author">Author</string>
    <string name="show_system_apps">Show system apps</string>
    <string name="send_log">Send logs</string>
    <string name="safe_mode">Safe mode</string>
    <string name="safe_mode_module_disabled">Module installation is disabled in safe mode</string>
    <string name="reboot_to_apply">Reboot to take effect</string>
    <string name="module_magisk_conflict">Modules are unavailable due to a conflict with Magisk!</string>
    <string name="home_learn_kernelsu">Learn KernelSU</string>
    <string name="home_learn_kernelsu_url">https://kernelsu.org/guide/what-is-kernelsu.html</string>
    <string name="home_click_to_learn_kernelsu">Learn how to install KernelSU and use modules.</string>
    <string name="home_support_title">Support Us</string>
    <string name="home_support_content">KernelSU is, and always will be, free, and open source. However, you can show us that you care by making a donation.</string>
    <string name="home_gki_warning">Starting from v3.0.0, the GKI work mode will be used only in testing environments. We do not recommend it for daily use, and image files will no longer be provided.</string>
    <string name="about_source_code"><![CDATA[View source code at %1$s<br/>Join our %2$s channel]]></string>
    <string name="profile" translatable="false">App Profile</string>
    <string name="profile_default">Default</string>
    <string name="profile_template">Template</string>
    <string name="profile_custom">Custom</string>
    <string name="profile_name">Profile name</string>
    <string name="profile_namespace">Mount namespace</string>
    <string name="profile_namespace_inherited">Inherited</string>
    <string name="profile_namespace_global">Global</string>
    <string name="profile_namespace_individual">Individual</string>
    <string name="profile_groups">Groups</string>
    <string name="profile_capabilities">Capabilities</string>
    <string name="profile_selinux_context">SELinux context</string>
    <string name="profile_umount_modules">Umount modules</string>
    <string name="failed_to_update_app_profile">Failed to update App Profile for %s</string>
    <string name="require_kernel_version">The current KernelSU version %1$d is too low for the manager to work properly. Please upgrade to version %2$d or higher!</string>
    <string name="settings_umount_modules_default">Umount modules by default</string>
    <string name="settings_umount_modules_default_summary">The global default value for \"Umount modules\" in App Profile. If enabled, it will remove all module modifications to the system for apps that don\'t have a profile set.</string>
    <string name="profile_umount_modules_summary">Enabling this option will allow KernelSU to restore any modified files by the modules for this app.</string>
    <string name="profile_selinux_domain">Domain</string>
    <string name="profile_selinux_rules">Rules</string>
    <string name="module_update">Update</string>
    <string name="module_downloading">Downloading module: %s</string>
    <string name="module_start_downloading">Start downloading: %s</string>
    <string name="module_action_success">Module action executed successfully.</string>
    <string name="new_version_available">New version %s is available, click to upgrade!</string>
    <string name="launch_app">Launch</string>
    <string name="force_stop_app">Force stop</string>
    <string name="restart_app">Restart</string>
    <string name="failed_to_update_sepolicy">Failed to update SELinux rules for %s</string>
    <string name="su_not_allowed">Couldn\'t grant Superuser access to %s</string>
    <string name="module_changelog">Changelog</string>
    <string name="settings_profile_template">App Profile template</string>
    <string name="settings_profile_template_summary">Manage local and online template of App Profile.</string>
    <string name="app_profile_template_create">Create template</string>
    <string name="app_profile_template_edit">Edit template</string>
    <string name="app_profile_template_id">ID</string>
    <string name="app_profile_template_id_invalid">Invalid template ID</string>
    <string name="app_profile_template_name">Name</string>
    <string name="app_profile_template_description">Description</string>
    <string name="app_profile_template_save">Save</string>
    <string name="app_profile_template_delete">Delete</string>
    <string name="app_profile_template_view">View template</string>
    <string name="app_profile_template_id_exist">Template ID already exists!</string>
    <string name="app_profile_import_export">Import/Export</string>
    <string name="app_profile_import_from_clipboard">Import from clipboard</string>
    <string name="app_profile_export_to_clipboard">Export to clipboard</string>
    <string name="app_profile_template_export_empty">Cannot find local template to export!</string>
    <string name="app_profile_template_import_success">Imported successfully</string>
    <string name="app_profile_template_save_failed">Failed to save template</string>
    <string name="app_profile_template_import_empty">Clipboard is empty!</string>
    <string name="app_profile_affects_following_apps">Affects the following apps</string>
    <string name="settings_check_update">Check for updates</string>
    <string name="settings_check_update_summary">Automatically check for updates when opening the app.</string>
    <string name="settings_enable_predictive_back">Predictive back gesture</string>
    <string name="settings_enable_predictive_back_summary">Enable predictive back gesture support.</string>
    <string name="settings_module_check_update">Check for module updates</string>
    <string name="grant_root_failed">Failed to grant root!</string>
    <string name="action">Action</string>
    <string name="open">Open</string>
    <string name="enable_web_debugging">WebView debugging</string>
    <string name="enable_web_debugging_summary">Can be used to debug WebUI. Please enable only when needed.</string>
    <string name="direct_install">Direct install (Recommended)</string>
    <string name="select_file">Select a file</string>
    <string name="install_inactive_slot">Install to inactive slot (After OTA)</string>
    <string name="install_inactive_slot_warning">Your device will be **FORCED** to boot to the current inactive slot after a reboot!\nOnly use this option after OTA is done.\nContinue?</string>
    <string name="install_next">Next</string>
    <string name="install_select_partition">Select partition</string>
    <string name="install_upload_lkm_file">Use local LKM file</string>
    <string name="install_only_support_ko_file">Only .ko files are supported</string>
    <string name="select_file_tip">%1$s partition image is recommended</string>
    <string name="select_kmi">Select KMI</string>
    <string name="settings_uninstall">Uninstall</string>
    <string name="settings_uninstall_temporary">Uninstall temporarily</string>
    <string name="settings_uninstall_permanent">Uninstall permanently</string>
    <string name="settings_restore_stock_image">Restore stock image</string>
    <string name="settings_uninstall_temporary_message">Temporarily uninstall KernelSU, restore to original state after next reboot.</string>
    <string name="settings_uninstall_permanent_message">Uninstalling KernelSU (root and all modules) completely and permanently.</string>
    <string name="settings_restore_stock_image_message">Restore the stock factory image (if a backup exists), usually used before OTA; if you need to uninstall KernelSU, please use \"Uninstall permanently\".</string>
    <string name="flashing">Flashing</string>
    <string name="flash_success">Flash success</string>
    <string name="flash_failed">Flash failed</string>
    <string name="selected_lkm">Selected LKM: %s</string>
    <string name="save_log">Save logs</string>
    <string name="log_saved">Logs saved</string>
    <string name="settings_sucompat">Classic SU command</string>
    <string name="settings_sucompat_summary">Allow root access via /system/bin/su, in new processes.</string>
    <string name="settings_kernel_umount">Umount modules (kernel-level)</string>
    <string name="settings_kernel_umount_summary">Unmount modules from kernel in App Profile.</string>
    <string name="feature_status_unsupported_summary">Kernel does not support this feature</string>
    <string name="feature_status_managed_summary">This feature is managed by a module</string>
    <string name="settings_mode_enable_by_default">Enable (Default)</string>
    <string name="settings_mode_disable_until_reboot">Disable until Reboot</string>
    <string name="settings_mode_disable_always">Always disable</string>
    <string name="processing">Processing…</string>
    <string name="refresh_pulling">Pull down to refresh</string>
    <string name="refresh_release">Release to refresh</string>
    <string name="refresh_refresh">Refreshing…</string>
    <string name="refresh_complete">Refreshed successfully</string>
    <string name="undo">Undo</string>
    <string name="module_undo_uninstall_success">Successfully canceled uninstall of %s</string>
    <string name="module_undo_uninstall_failed">Failed to undo uninstall: %s</string>
    <string name="group_contains_apps">Contains %d apps</string>
    <string name="settings_theme">Theme</string>
    <string name="settings_theme_summary">Choose the app theme mode.</string>
    <string name="settings_theme_mode_system">Follow system</string>
    <string name="settings_theme_mode_light">Light</string>
    <string name="settings_theme_mode_dark">Dark</string>
    <string name="settings_theme_mode_monet_system">Monet (Follow system)</string>
    <string name="settings_theme_mode_monet_light">Monet (Light)</string>
    <string name="settings_theme_mode_monet_dark">Monet (Dark)</string>
    <string name="settings_key_color">Key color</string>
    <string name="settings_key_color_summary">Customize accent when using Monet.</string>
    <string name="settings_key_color_default">Default</string>
    <string name="settings_page_scale">Page Scale</string>
    <string name="settings_page_scale_summary">Adjust the global display scale.</string>
    <string name="color_blue">Blue</string>
    <string name="color_red">Red</string>
    <string name="color_green">Green</string>
    <string name="color_purple">Purple</string>
    <string name="color_orange">Orange</string>
    <string name="color_teal">Teal</string>
    <string name="color_pink">Pink</string>
    <string name="color_brown">Brown</string>
    <string name="color_deep_purple">Deep Purple</string>
    <string name="color_indigo">Indigo</string>
    <string name="color_cyan">Cyan</string>
    <string name="color_yellow">Yellow</string>
    <string name="color_amber">Amber</string>
    <string name="color_blue_grey">Blue Grey</string>
    <string name="color_sakura">Sakura</string>
    <string name="network_offline">Not connected to network</string>
    <string name="network_retry">Retry</string>
    <string name="tab_readme">README</string>
    <string name="tab_releases">Releases</string>
    <string name="tab_info">Info</string>
    <string name="module_shortcut_title">Create shortcut</string>
    <string name="module_shortcut_name_label">Shortcut name</string>
    <string name="module_shortcut_icon_pick">Choose custom icon</string>
    <string name="module_shortcut_add">Add shortcut</string>
    <string name="module_shortcut_not_supported">Launcher does not support desktop shortcuts.</string>
    <string name="module_shortcut_created">Shortcut created on desktop.</string>
    <string name="module_shortcut_updated">Shortcut updated.</string>
    <string name="module_shortcut_delete">Delete shortcut</string>
    <string name="module_shortcut_type_title">Select type</string>
    <string name="module_shortcut_permission_tip_xiaomi">Please enable \"Home screen shortcuts\" permission for this app in Xiaomi settings.</string>
    <string name="module_shortcut_permission_tip_oppo">Please enable \"Create Home screen shortcuts\" permission for this app in OPPO settings.</string>
    <string name="module_shortcut_permission_tip_default">If shortcut creation fails, please enable desktop shortcut permission for this app in system settings.</string>
    <string name="no_such_module">Module %s does not exist</string>
    <string name="module_unavailable">Module %s is disabled, updating, or pending removal</string>
    <string name="select_file_tip_nogki">Please select the GKI device image file you want to patch</string>
    <string name="current_kmi">KMI version of this device: %s</string>
    <string name="current_device_kmi">This device KMI</string>
</resources>

```

`manager/app/src/main/res/values/themes.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">

    <style name="Theme.KernelSU" parent="android:Theme.Material.Light.NoActionBar">
        <item name="android:windowLayoutInDisplayCutoutMode" tools:targetApi="o_mr1">shortEdges</item>
    </style>

    <style name="Theme.KernelSU.WebUI" parent="Theme.KernelSU">
        <item name="android:windowLightStatusBar">true</item>
        <item name="android:windowLightNavigationBar" tools:targetApi="o_mr1">true</item>
    </style>

</resources>
```

`manager/app/src/main/res/xml/backup_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
```

`manager/app/src/main/res/xml/data_extraction_rules.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
```

`manager/app/src/main/res/xml/filepaths.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<paths>
    <cache-path name="cache" path="."/>
    <root-path name="root" path="." />
</paths>

```

`manager/app/src/main/res/xml/network_security_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">127.0.0.1</domain>
        <domain includeSubdomains="true">0.0.0.0</domain>
        <domain includeSubdomains="true">::1</domain>
    </domain-config>
</network-security-config>

```

`manager/build.gradle.kts`:

```kts
plugins {
    alias(libs.plugins.agp.app) apply false
    alias(libs.plugins.kotlin) apply false
    alias(libs.plugins.compose.compiler) apply false
}

val androidMinSdkVersion by extra(26)
val androidTargetSdkVersion by extra(36)
val androidCompileSdkVersion by extra(36)
val androidBuildToolsVersion by extra("36.1.0")
val androidCompileNdkVersion by extra(libs.versions.ndk.get())
val androidSourceCompatibility by extra(JavaVersion.VERSION_21)
val androidTargetCompatibility by extra(JavaVersion.VERSION_21)
val managerVersionCode by extra(getVersionCode())
val managerVersionName by extra(getVersionName())

fun getGitCommitCount(): Int {
    val process = Runtime.getRuntime().exec(arrayOf("git", "rev-list", "--count", "HEAD"))
    return process.inputStream.bufferedReader().use { it.readText().trim().toInt() }
}

fun getGitDescribe(): String {
    val process = Runtime.getRuntime().exec(arrayOf("git", "describe", "--tags", "--always"))
    return process.inputStream.bufferedReader().use { it.readText().trim() }
}

fun getVersionCode(): Int {
    val commitCount = getGitCommitCount()
    return 30000 + commitCount
}

fun getVersionName(): String {
    return getGitDescribe()
}

```

`manager/gradle.properties`:

```properties
android.experimental.enableNewResourceShrinker.preciseShrinking=true
android.enableAppCompileTimeRClass=true
android.useAndroidX=true
org.gradle.jvmargs=-Xmx2048m
org.gradle.parallel=true
org.gradle.vfs.watch=true
android.r8.maxWorkers=4
android.native.buildOutput=verbose

```

`manager/gradle/libs.versions.toml`:

```toml
[versions]
agp = "9.0.0"
kotlin = "2.3.10"
compose-bom = "2026.01.01"
lifecycle = "2.10.0"
activity-compose = "1.12.3"
kotlinx-coroutines = "1.10.2"
navigation3 = "1.1.0-alpha03"
navigationevent = "1.0.2"
markwon = "4.6.2"
webkit = "1.15.0"
parcelablelist = "2.0.1"
ndk = "29.0.14206865"
libsu = "6.0.0"
apksign = "1.4"
miuix = "0.8.1"
haze = "1.7.1"
capsule = "2.1.3"
okhttp = "5.3.2"
hiddenapibypass = "6.1"

[plugins]
agp-app = { id = "com.android.application", version.ref = "agp" }

kotlin = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
kotlin-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }

lsplugin-apksign = { id = "org.lsposed.lsplugin.apksign", version.ref = "apksign" }

[libraries]
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activity-compose" }

androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "compose-bom" }
androidx-compose-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended" }
androidx-compose-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-compose-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-compose-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }

androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycle" }
androidx-lifecycle-runtime-compose = { group = "androidx.lifecycle", name = "lifecycle-runtime-compose", version.ref = "lifecycle" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycle" }
androidx-lifecycle-viewmodel-navigation3 = { module = "androidx.lifecycle:lifecycle-viewmodel-navigation3", version.ref = "lifecycle" }

androidx-webkit = { module = "androidx.webkit:webkit", version.ref = "webkit" }

com-github-topjohnwu-libsu-core = { group = "com.github.topjohnwu.libsu", name = "core", version.ref = "libsu" }
com-github-topjohnwu-libsu-service = { group = "com.github.topjohnwu.libsu", name = "service", version.ref = "libsu" }
com-github-topjohnwu-libsu-io = { group = "com.github.topjohnwu.libsu", name = "io", version.ref = "libsu" }

dev-rikka-rikkax-parcelablelist = { module = "dev.rikka.rikkax.parcelablelist:parcelablelist", version.ref = "parcelablelist" }

kotlinx-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version.ref = "kotlinx-coroutines" }

androidx-navigation3-runtime = { module = "androidx.navigation3:navigation3-runtime", version.ref = "navigation3" }
androidx-navigationevent-compose = { module = "androidx.navigationevent:navigationevent-compose", version.ref = "navigationevent" }

markwon = { group = "io.noties.markwon", name = "core", version.ref = "markwon" }

lsposed-cxx = { module = "org.lsposed.libcxx:libcxx", version.ref = "ndk" }

miuix = { module = "top.yukonga.miuix.kmp:miuix-android", version.ref = "miuix" }
miuix-icons = { module = "top.yukonga.miuix.kmp:miuix-icons-android", version.ref = "miuix" }
miuix-navigation3-ui = { module = "top.yukonga.miuix.kmp:miuix-navigation3-ui-android", version.ref = "miuix" }

haze = { module = "dev.chrisbanes.haze:haze-android", version.ref = "haze" }

capsule = { module = "io.github.kyant0:capsule", version.ref = "capsule" }

okhttp = { module = "com.squareup.okhttp3:okhttp" }
okhttp-bom = { module = "com.squareup.okhttp3:okhttp-bom", version.ref = "okhttp" }

hiddenapibypass = { module = "org.lsposed.hiddenapibypass:hiddenapibypass", version.ref = "hiddenapibypass" }


```

`manager/gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-9.2.0-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`manager/gradlew`:

```
#!/bin/sh

#
# Copyright © 2015 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac



# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`manager/gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line



@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`manager/settings.gradle.kts`:

```kts
@file:Suppress("UnstableApiUsage")

enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")

pluginManagement {
    repositories {
        google()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }
}

rootProject.name = "KernelSU"
include(":app")

```

`manager/sign.example.properties`:

```properties
KEYSTORE_FILE=
KEYSTORE_PASSWORD=
KEY_ALIAS=
KEY_PASSWORD=
```

`scripts/allowlist.bt`:

```bt
// Define constants as per the provided structure.
#define KSU_MAX_PACKAGE_NAME 256
#define KSU_MAX_GROUPS 32
#define KSU_SELINUX_DOMAIN 64

// Define the root_profile structure with padding for 64-bit alignment.
struct root_profile {
    uint32 uid;
    uint32 gid;

    uint32 groups_count;
    uint32 groups[KSU_MAX_GROUPS];
    char padding1[4]; // Padding for 64-bit alignment.

    struct {
        uint64 effective;
        uint64 permitted;
        uint64 inheritable;
    } capabilities;

    char selinux_domain[KSU_SELINUX_DOMAIN];
    
    uint32 namespaces;
    char padding2[4]; // Padding for 64-bit alignment.
};

// Define the non_root_profile structure with padding for 64-bit alignment.
struct non_root_profile {
    byte umount_modules;
    char padding[7]; // Padding to make the total size a multiple of 8.
};

// Define the rp_config structure with padding for 64-bit alignment.
struct rp_config_t {
    byte use_default;
    
    char template_name[KSU_MAX_PACKAGE_NAME];
    char padding[7]; // Padding to make the total size a multiple of 8.

    struct root_profile profile;
};

// Define the nrp_config structure with padding for 64-bit alignment.
struct nrp_config_t {
    byte use_default;
    char padding1[7]; // Padding to make the total size a multiple of 8.

    struct non_root_profile profile;
    char padding2[488]; // Padding to align the union
};

// Define the main app_profile structure
typedef struct {
    uint32 version;
    char key[KSU_MAX_PACKAGE_NAME];
    int32 current_uid;
    int64 allow_su;

    // Based on allow_su, decide which profile to use
    if (allow_su != 0) {
        rp_config_t rp_config;
    } else {
        nrp_config_t nrp_config;
    }

} app_profile;

// Define the file header with magic number and version
typedef struct {
    uint32 magic;
    uint32 version;
} file_header;

// Main entry for parsing the file
file_header header;

if (header.magic != 0x7f4b5355) {
    Printf("Invalid file magic number.\n");
    return;
}

FSeek(8); // Skip the header


// Continually read app_profile instances until end of file
while (!FEof()) {
    app_profile profile;
}


```

`scripts/ksubot.py`:

```py
import asyncio
import os
import sys
from telethon import TelegramClient
from telethon.tl.functions.help import GetConfigRequest

API_ID = 611335
API_HASH = "d524b414d21f4d37f08684c1df41ac9c"


BOT_TOKEN = os.environ.get("BOT_TOKEN")
CHAT_ID = os.environ.get("CHAT_ID")
MESSAGE_THREAD_ID = os.environ.get("MESSAGE_THREAD_ID")
COMMIT_URL = os.environ.get("COMMIT_URL")
COMMIT_MESSAGE = os.environ.get("COMMIT_MESSAGE")
RUN_URL = os.environ.get("RUN_URL")
TITLE = os.environ.get("TITLE")
VERSION = os.environ.get("VERSION")
BRANCH = os.environ.get("BRANCH")
MSG_TEMPLATE = """
**{title}**
Branch: {branch}
#ci_{version}
```
{commit_message}
```
[Commit]({commit_url})
[Workflow run]({run_url})
""".strip()


def get_caption():
    msg = MSG_TEMPLATE.format(
        title=TITLE,
        branch=BRANCH,
        version=VERSION,
        commit_message=COMMIT_MESSAGE,
        commit_url=COMMIT_URL,
        run_url=RUN_URL,
    )
    if len(msg) > 1024:
        msg = COMMIT_URL
    if BRANCH == "dev":
        msg += "\n⚠️⚠️**DEV VERSION, PLEASE BACKUP BEFORE INSTALLATION**⚠️⚠️"
        msg += "\n⚠️⚠️**测试版，安装前请备份**⚠️⚠️"
    return msg


def check_environ():
    global CHAT_ID, MESSAGE_THREAD_ID
    if BOT_TOKEN is None:
        print("[-] Invalid BOT_TOKEN")
        exit(1)
    if CHAT_ID is None:
        print("[-] Invalid CHAT_ID")
        exit(1)
    else:
        CHAT_ID = int(CHAT_ID)
    if COMMIT_URL is None:
        print("[-] Invalid COMMIT_URL")
        exit(1)
    if COMMIT_MESSAGE is None:
        print("[-] Invalid COMMIT_MESSAGE")
        exit(1)
    if RUN_URL is None:
        print("[-] Invalid RUN_URL")
        exit(1)
    if TITLE is None:
        print("[-] Invalid TITLE")
        exit(1)
    if VERSION is None:
        print("[-] Invalid VERSION")
        exit(1)
    if BRANCH is None:
        print("[-] Invalid BRANCH")
        exit(1)
    if MESSAGE_THREAD_ID is None:
        print("[-] Invaild MESSAGE_THREAD_ID")
        exit(1)
    else:
        MESSAGE_THREAD_ID = int(MESSAGE_THREAD_ID)


async def main():
    print("[+] Uploading to telegram")
    check_environ()
    files = sys.argv[1:]
    print("[+] Files:", files)
    if len(files) <= 0:
        print("[-] No files to upload")
        exit(1)
    print("[+] Logging in Telegram with bot")
    script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    session_dir = os.path.join(script_dir, "ksubot")
    async with await TelegramClient(session=session_dir, api_id=API_ID, api_hash=API_HASH).start(bot_token=BOT_TOKEN) as bot:
        caption = [""] * len(files)
        caption[-1] = get_caption()
        print("[+] Caption: ")
        print("---")
        print(caption)
        print("---")
        print("[+] Sending")
        await bot.send_file(entity=CHAT_ID, file=files, caption=caption, reply_to=MESSAGE_THREAD_ID, parse_mode="markdown")
        print("[+] Done!")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        print(f"[-] An error occurred: {e}")

```

`userspace/ksud/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "adler32"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aae1277d39aeec15cb388266ecc24b11c80469deae6067e17a1a7aa9e5c1f234"

[[package]]
name = "aho-corasick"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android_log-sys"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84521a3cf562bc62942e294181d9eef17eb38ceb8c68677bc49f144e4c3d4f8d"

[[package]]
name = "android_logger"
version = "0.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbb4e440d04be07da1f1bf44fb4495ebd58669372fe0cffa6e48595ac5bd88a3"
dependencies = [
 "android_log-sys",
 "env_filter",
 "log",
]

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.61.2",
]

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "arbitrary"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d036a3c4ab069c7b410a2ce876bd74808d2d0888a82667669f8e783a898bf1"
dependencies = [
 "derive_arbitrary",
]

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bstr"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63044e1ae8e69f3b5a92c736ca6269b8d12fa7efe39bf34ddb06d102cf0e2cab"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "bumpalo"
version = "3.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dd9dc738b7a8311c7ade152424974d8115f2cdad61e8dab8dac9f2362298510"

[[package]]
name = "bytes"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b35204fbdc0b3f4446b89fc1ac2cf84a8a68971995d0bf2e925ec7cd960f9cb3"

[[package]]
name = "cc"
version = "1.2.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f50d563227a1c37cc0a263f64eca3334388c01c5e4c4861a9def205c614383c"
dependencies = [
 "find-msvc-tools",
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "chrono"
version = "0.4.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
dependencies = [
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "clap"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e340e012a1bf4935f5282ed1436d1489548e8f72308207ea5df0e23d2d03f8"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d76b5d13eaa18c901fd2f7fca939fefe3a0727a953561fefdf3b2922b8569d00"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "clap_lex"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d728cc89cf3aee9ff92b05e62b19ee65a02b5702cff7d5a377e32c6ae29d8d"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "const_format"
version = "0.2.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7faa7469a93a566e9ccc1c73fe783b4a65c274c5ace346038dca9c39fe0030ad"
dependencies = [
 "const_format_proc_macros",
]

[[package]]
name = "const_format_proc_macros"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d57c2eccfb16dbac1f4e61e206105db5820c9d26c3c472bc17c774259ef7744"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "core2"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b49ba7ef1ad6107f8824dbe97de947cbaac53c44e7f9756a1fba0d37c1eec505"
dependencies = [
 "memchr",
]

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9710d3b3739c2e349eb44fe848ad0b7c8cb1e42bd87ee49371df2f7acaf3e675"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8"
dependencies = [
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-epoch",
 "crossbeam-queue",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crypto-common"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78c8292055d1c1df0cce5d180393dc8cce0abec0a7102adb6c7b1eef6016d60a"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "dary_heap"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06d2e3287df1c007e74221c49ca10a95d557349e54b3a75dc2fb14712c751f04"

[[package]]
name = "deflate64"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26bf8fc351c5ed29b5c2f0cbbac1b209b74f60ecd62e675a998df72c49af5204"

[[package]]
name = "deranged"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ececcb659e7ba858fb4f10388c250a7252eb0a27373f1a72b8748afdd248e587"
dependencies = [
 "powerfmt",
]

[[package]]
name = "derive-new"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2cdc8d50f426189eef89dac62fabfa0abb27d5cc008f25bf4156a0203325becc"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "derive_arbitrary"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e567bd82dcff979e4b03460c307b3cdc9e96fde3d73bed1496d2bc75d9dd62a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "env_filter"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bf3c259d255ca70051b30e2e95b5446cdb8949ac4cd22c0d7fd634d89f568e2"
dependencies = [
 "log",
]

[[package]]
name = "env_home"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7f84e12ccf0a7ddc17a6c41c93326024c42920d7ee630d04950e6926645c0fe"

[[package]]
name = "env_logger"
version = "0.11.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c863f0904021b108aa8b2f55046443e6b1ebde8fd4a15c399893aae4fa069f"
dependencies = [
 "env_filter",
 "log",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f639046355ee4f37944e44f60642c6f3a7efa3cf6b78c78a0d989a8ce6c396a1"
dependencies = [
 "errno-dragonfly",
 "libc",
 "winapi",
]

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.2",
]

[[package]]
name = "errno-dragonfly"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "extattr"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b59f8a77817ff1b795adafc535941bdf664184f5f95e0b6d1d77dd6d12815dc"
dependencies = [
 "bitflags 1.3.2",
 "errno 0.2.8",
 "libc",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "find-msvc-tools"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a3076410a55c90011c298b04d0cfa770b00fa04e1e3c97d3f6c9de105a03844"

[[package]]
name = "flate2"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfe33edd8e85a12a67454e37f8c75e730830d83e313556ab9ebf9ee7fbeb3bfb"
dependencies = [
 "crc32fast",
 "libz-rs-sys",
 "miniz_oxide",
]

[[package]]
name = "foldhash"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77ce24cb58228fbb8aa041425bb1050850ac19177686ea6e0f41a70416f56fdb"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getopts"
version = "0.2.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe4fbac503b8d1f88e6676011885f34b7174f46e59956bba534ba83abded4df"
dependencies = [
 "unicode-width",
]

[[package]]
name = "getrandom"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasip2",
]

[[package]]
name = "globset"
version = "0.4.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52dfc19153a48bde0cbd630453615c8151bce3a5adfac7a0aebfbf0a1e1f57e3"
dependencies = [
 "aho-corasick",
 "bstr",
 "log",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "hashbrown"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "humansize"
version = "2.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6cb51c9a029ddc91b07a787f1d86b53ccfa49b0e86688c946ebe8d3555685dd7"
dependencies = [
 "libm",
]

[[package]]
name = "iana-time-zone"
version = "0.1.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "ignore"
version = "0.4.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3d782a365a015e0f5c04902246139249abf769125006fbe7649e2ee88169b4a"
dependencies = [
 "crossbeam-deque",
 "globset",
 "log",
 "memchr",
 "regex-automata",
 "same-file",
 "walkdir",
 "winapi-util",
]

[[package]]
name = "include-flate"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e01b7cb6ca682a621e7cda1c358c9724b53a7b4409be9be1dd443b7f3a26f998"
dependencies = [
 "include-flate-codegen",
 "include-flate-compress",
 "libflate",
 "zstd",
]

[[package]]
name = "include-flate-codegen"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4f49bf5274aebe468d6e6eba14a977eaf1efa481dc173f361020de70c1c48050"
dependencies = [
 "include-flate-compress",
 "libflate",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 2.0.111",
 "zstd",
]

[[package]]
name = "include-flate-compress"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eae6a40e716bcd5931f5dbb79cd921512a4f647e2e9413fded3171fca3824dbc"
dependencies = [
 "libflate",
 "zstd",
]

[[package]]
name = "indexmap"
version = "2.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ad4bb2b565bca0645f4d68c5c9af97fba094e9791da685bf83cb5f3ce74acf2"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "is_executable"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baabb8b4867b26294d818bf3f651a454b6901431711abb96e296245888d6e8c4"
dependencies = [
 "windows-sys 0.60.2",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "itoa"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ee5b5339afb4c41626dde77b7a611bd4f2c202b897852b4bcf5d03eddc61010"

[[package]]
name = "java-properties"
version = "2.0.0"
source = "git+https://github.com/Kernel-SU/java-properties.git?branch=master#42a4aa941b70ded2dd3be9e9f892471023e70229"
dependencies = [
 "encoding_rs",
 "lazy_static",
 "regex-lite",
]

[[package]]
name = "jobserver"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
dependencies = [
 "getrandom",
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "464a3709c7f55f1f721e5389aa6ea4e3bc6aba669353300af094b29ffbdde1d8"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "jwalk"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2735847566356cd2179a2a38264839308f7079fa96e6bd5a42d740460e003c56"
dependencies = [
 "crossbeam",
 "rayon",
]

[[package]]
name = "ksud"
version = "0.1.0"
dependencies = [
 "android-properties",
 "android_logger",
 "anyhow",
 "chrono",
 "clap",
 "const_format",
 "derive-new",
 "encoding_rs",
 "env_logger",
 "extattr",
 "getopts",
 "humansize",
 "is_executable",
 "java-properties",
 "jwalk",
 "libc",
 "log",
 "nom",
 "regex-lite",
 "rust-embed",
 "rustix",
 "serde_json",
 "sha1",
 "sha256",
 "tempfile",
 "which",
 "zip 7.0.0",
 "zip-extensions",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.178"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37c93d8daa9d8a012fd8ab92f088405fb202ea0b6ab73ee2482ae66af4f42091"

[[package]]
name = "libflate"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3248b8d211bd23a104a42d81b4fa8bb8ac4a3b75e7a43d85d2c9ccb6179cd74"
dependencies = [
 "adler32",
 "core2",
 "crc32fast",
 "dary_heap",
 "libflate_lz77",
]

[[package]]
name = "libflate_lz77"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a599cb10a9cd92b1300debcef28da8f70b935ec937f44fcd1b70a7c986a11c5c"
dependencies = [
 "core2",
 "hashbrown",
 "rle-decode-fast",
]

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libz-rs-sys"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c10501e7805cee23da17c7790e59df2870c0d4043ec6d03f67d31e2b53e77415"
dependencies = [
 "zlib-rs",
]

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "lzma-rust2"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c60a23ffb90d527e23192f1246b14746e2f7f071cb84476dd879071696c18a4a"
dependencies = [
 "crc",
 "sha2",
]

[[package]]
name = "lzma-rust2"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48172246aa7c3ea28e423295dd1ca2589a24617cc4e588bb8cfe177cb2c54d95"
dependencies = [
 "crc",
 "sha2",
]

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "nom"
version = "8.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df9761775871bdef83bee530e60050f7e54b1105350d6884eb0fb4f46c2f9405"
dependencies = [
 "memchr",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ee95bc4ef87b8d5ba32e8b7714ccc834865276eab0aed5c9958d00ec45f49e8"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a338cc41d27e6cc6dce6cefc13a0729dfbb81c262b1f519331575dd80ef3067f"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rayon"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "regex-automata"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5276caf25ac86c8d810222b3dbb938e512c55c6831a10f3e6ed1c93b84041f1c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-lite"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d942b98df5e658f56f20d592c7f868833fe38115e65c33003d8cd224b0155da"

[[package]]
name = "regex-syntax"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"

[[package]]
name = "rle-decode-fast"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3582f63211428f83597b51b2ddb88e2a91a9d52d12831f9d08f5e624e8977422"

[[package]]
name = "rust-embed"
version = "8.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "947d7f3fad52b283d261c4c99a084937e2fe492248cb9a68a8435a861b8798ca"
dependencies = [
 "include-flate",
 "rust-embed-impl",
 "rust-embed-utils",
 "walkdir",
]

[[package]]
name = "rust-embed-impl"
version = "8.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5fa2c8c9e8711e10f9c4fd2d64317ef13feaab820a4c51541f1a8c8e2e851ab2"
dependencies = [
 "proc-macro2",
 "quote",
 "rust-embed-utils",
 "syn 2.0.111",
 "walkdir",
]

[[package]]
name = "rust-embed-utils"
version = "8.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b161f275cb337fe0a44d924a5f4df0ed69c2c39519858f931ce61c779d3475"
dependencies = [
 "sha2",
 "walkdir",
]

[[package]]
name = "rustix"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "146c9e247ccc180c1f61615433868c99f3de3ae256a30a43b49f67c2d9171f34"
dependencies = [
 "bitflags 2.10.0",
 "errno 0.3.14",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.61.2",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62049b2877bf12821e8f9ad256ee38fdc31db7387ec2d3b3f403024de2034aea"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "serde_json"
version = "1.0.146"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "217ca874ae0207aac254aa02c957ded05585a90892cc8d87f9e5fa49669dadd8"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
 "serde_core",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha256"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f880fc8562bdeb709793f00eb42a2ad0e672c4f883bbe59122b926eca935c8f6"
dependencies = [
 "async-trait",
 "bytes",
 "hex",
 "sha2",
 "tokio",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "simd-adler32"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e320a6c5ad31d271ad523dcf3ad13e2767ad8b1cb8f047f75a8aeaf8da139da2"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.111"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "390cc9a294ab71bdb1aa2e99d13be9c753cd2d7bd6560c77118597410c4d2e87"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.23.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d31c77bdf42a745371d260a26ca7163f1e0924b64afa0b688e61b5a9fa02f16"
dependencies = [
 "fastrand",
 "getrandom",
 "once_cell",
 "rustix",
 "windows-sys 0.61.2",
]

[[package]]
name = "time"
version = "0.3.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e7d9e3bb61134e77bde20dd4825b97c010155709965fedf0f49bb138e52a9d"
dependencies = [
 "deranged",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
]

[[package]]
name = "time-core"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40868e7c1d2f0b8d73e4a8c7f0ff63af4f6d19be117e90bd73eb1d62cf831c6b"

[[package]]
name = "tokio"
version = "1.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff360e02eab121e0bc37a2d3b4d4dc622e6eda3a8e5253d5435ecf5bd4c68408"
dependencies = [
 "bytes",
 "pin-project-lite",
]

[[package]]
name = "typenum"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "562d481066bde0658276a35467c4af00bdc6ee726305698a55b86e61d7ad82bb"

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "unicode-width"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4ac048d71ede7ee76d585517add45da530660ef4390e49b098733c6e897f254"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasip2"
version = "1.0.1+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0562428422c63773dad2c345a1882263bbf4d65cf3f42e90921f787ef5ad58e7"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d759f433fa64a2d763d1340820e46e111a7a5ab75f993d1852d70b03dbb80fd"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48cb0d2638f8baedbc542ed444afc0644a29166f1595371af4fecf8ce1e7eeb3"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cefb59d5cd5f92d9dcf80e4683949f15ca4b511f4ac0a6e14d4e1ac60c6ecd40"
dependencies = [
 "bumpalo",
 "proc-macro2",
 "quote",
 "syn 2.0.111",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbc538057e648b67f72a982e708d485b2efa771e1ac05fec311f9f63e5800db4"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "which"
version = "8.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3fabb953106c3c8eea8306e4393700d7657561cb43122571b172bbfb7c7ba1d"
dependencies = [
 "env_home",
 "rustix",
 "winsafe",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.62.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8e83a14d34d0623b51dce9581199302a221863196a1dde71a7663a4c2be9deb"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-implement"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053e2e040ab57b9dc951b72c264860db7eb3b0200ba345b4e4c3b14f67855ddf"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "windows-interface"
version = "0.59.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f316c4a2570ba26bbec722032c4099d8c8bc095efccdc15688708623367e358"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.111",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-result"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7781fa89eaf60850ac3d2da7af8e5242a5ea78d1a11c49bf2910bb5a73853eb5"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7837d08f69c77cf6b07689544538e017c1bfcf57e34b4c0ff58e6c2cd3b37091"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"

[[package]]
name = "windows_i686_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"

[[package]]
name = "windows_i686_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"

[[package]]
name = "winsafe"
version = "0.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d135d17ab770252ad95e9a872d365cf3090e3be864a34ab46f48555993efc904"

[[package]]
name = "wit-bindgen"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f17a85883d4e6d00e8a97c586de764dabcc06133f7f1d55dce5cdc070ad7fe59"

[[package]]
name = "zip"
version = "6.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb2a05c7c36fde6c09b08576c9f7fb4cda705990f73b58fe011abf7dfb24168b"
dependencies = [
 "arbitrary",
 "crc32fast",
 "flate2",
 "indexmap",
 "lzma-rust2 0.13.0",
 "memchr",
 "zopfli",
]

[[package]]
name = "zip"
version = "7.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdd8a47718a4ee5fe78e07667cd36f3de80e7c2bfe727c7074245ffc7303c037"
dependencies = [
 "arbitrary",
 "crc32fast",
 "deflate64",
 "flate2",
 "indexmap",
 "lzma-rust2 0.15.4",
 "memchr",
 "time",
 "zopfli",
]

[[package]]
name = "zip-extensions"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9bb4da4a220bfb79c2b7bfa88466181778892ddaffaca9f06d5e9cc5de0b46f"
dependencies = [
 "ignore",
 "zip 6.0.0",
]

[[package]]
name = "zlib-rs"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40990edd51aae2c2b6907af74ffb635029d5788228222c4bb811e9351c0caad3"

[[package]]
name = "zopfli"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f05cd8797d63865425ff89b5c4a48804f35ba0ce8d125800027ad6017d2b5249"
dependencies = [
 "bumpalo",
 "crc32fast",
 "log",
 "simd-adler32",
]

[[package]]
name = "zstd"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e91ee311a569c327171651566e07972200e76fcfe2242a4fa446149a3881c08a"
dependencies = [
 "zstd-safe",
]

[[package]]
name = "zstd-safe"
version = "7.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f49c4d5f0abb602a93fb8736af2a4f4dd9512e36f7f570d66e65ff867ed3b9d"
dependencies = [
 "zstd-sys",
]

[[package]]
name = "zstd-sys"
version = "2.0.16+zstd.1.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e19ebc2adc8f83e43039e79776e3fda8ca919132d68a1fed6a5faca2683748"
dependencies = [
 "cc",
 "pkg-config",
]

```

`userspace/ksud/Cargo.toml`:

```toml
[package]
name = "ksud"
version = "0.1.0"
edition = "2024"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1"
clap = { version = "4", features = ["derive"] }
const_format = "0.2"
log = "0.4"
env_logger = { version = "0.11", default-features = false }
rust-embed = { version = "8", features = [
    "debug-embed",
    "compression", # must clean build after updating binaries
] }
which = "8"
sha1 = "0.10"
sha256 = "1"
tempfile = "3"
chrono = "0.4"
regex-lite = "0.1"

[target.'cfg(target_os = "android")'.dependencies]
rustix = { version = "1", features = [
    "all-apis",
] }
android-properties = { version = "0.2", features = ["bionic-deprecated"] }
android_logger = { version = "0.15", default-features = false }
zip = { version = "7",  features = [
    "deflate",
    "deflate64",
    "time",
    "lzma",
    "xz",
], default-features = false }
zip-extensions = { version = "0.13", features = [
    "deflate",
    "lzma",
    "xz",
], default-features = false }
java-properties = { git = "https://github.com/Kernel-SU/java-properties.git", branch = "master", default-features = false }
serde_json = "1"
encoding_rs = "0.8"
humansize = "2"
libc = "0.2"
extattr = "1"
jwalk = "0.8"
is_executable = "1"
nom = "8"
derive-new = "0.7"
getopts = "0.2"

[profile.release]
strip = true
opt-level = "z"
lto = true
codegen-units = 1

```

`userspace/ksud/build.rs`:

```rs
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;

fn get_git_version() -> Result<(u32, String), std::io::Error> {
    let output = Command::new("git")
        .args(["rev-list", "--count", "HEAD"])
        .output()?;

    let output = output.stdout;
    let version_code = String::from_utf8(output).expect("Failed to read git count stdout");
    let version_code: u32 = version_code
        .trim()
        .parse()
        .map_err(|_| std::io::Error::other("Failed to parse git count"))?;
    let version_code = 30000 + version_code;

    let version_name = String::from_utf8(
        Command::new("git")
            .args(["describe", "--tags", "--always"])
            .output()?
            .stdout,
    )
    .map_err(|_| std::io::Error::other("Failed to read git describe stdout"))?;
    let version_name = version_name.trim_start_matches('v').to_string();
    Ok((version_code, version_name))
}

fn main() {
    let (code, name) = match get_git_version() {
        Ok((code, name)) => (code, name),
        Err(_) => {
            // show warning if git is not installed
            println!("cargo:warning=Failed to get git version, using 0.0.0");
            (0, "0.0.0".to_string())
        }
    };
    let out_dir = env::var("OUT_DIR").expect("Failed to get $OUT_DIR");
    let out_dir = Path::new(&out_dir);
    File::create(Path::new(out_dir).join("VERSION_CODE"))
        .expect("Failed to create VERSION_CODE")
        .write_all(code.to_string().as_bytes())
        .expect("Failed to write VERSION_CODE");

    File::create(Path::new(out_dir).join("VERSION_NAME"))
        .expect("Failed to create VERSION_NAME")
        .write_all(name.trim().as_bytes())
        .expect("Failed to write VERSION_NAME");
}

```

`userspace/ksud/src/apk_sign.rs`:

```rs
use anyhow::{Result, ensure};
use std::io::{Read, Seek, SeekFrom};

pub fn get_apk_signature(apk: &str) -> Result<(u32, String)> {
    let mut buffer = [0u8; 0x10];
    let mut size4 = [0u8; 4];
    let mut size8 = [0u8; 8];
    let mut size_of_block = [0u8; 8];

    let mut f = std::fs::File::open(apk)?;

    let mut i = 0;
    loop {
        let mut n = [0u8; 2];
        f.seek(SeekFrom::End(-i - 2))?;
        f.read_exact(&mut n)?;

        let n = u16::from_le_bytes(n);
        if i64::from(n) == i {
            f.seek(SeekFrom::Current(-22))?;
            f.read_exact(&mut size4)?;

            if u32::from_le_bytes(size4) ^ 0xcafe_babe_u32 == 0xccfb_f1ee_u32 {
                if i > 0 {
                    println!("warning: comment length is {i}");
                }
                break;
            }
        }

        ensure!(n != 0xffff, "not a zip file");

        i += 1;
    }

    f.seek(SeekFrom::Current(12))?;
    // offset
    f.read_exact(&mut size4)?;
    f.seek(SeekFrom::Start(u64::from(u32::from_le_bytes(size4)) - 0x18))?;

    f.read_exact(&mut size8)?;
    f.read_exact(&mut buffer)?;

    ensure!(&buffer == b"APK Sig Block 42", "Can not found sig block");

    let pos = u64::from(u32::from_le_bytes(size4)) - (u64::from_le_bytes(size8) + 0x8);
    f.seek(SeekFrom::Start(pos))?;
    f.read_exact(&mut size_of_block)?;

    ensure!(size_of_block == size8, "not a signed apk");

    let mut v2_signing: Option<(u32, String)> = None;
    let mut v3_signing_exist = false;
    let mut v3_1_signing_exist = false;

    loop {
        let mut id = [0u8; 4];
        let mut offset = 4u32;

        f.read_exact(&mut size8)?; // sequence length
        if size8 == size_of_block {
            break;
        }

        f.read_exact(&mut id)?; // id

        let id = u32::from_le_bytes(id);
        if id == 0x7109_871a_u32 {
            v2_signing = Some(calc_cert_sha256(&mut f, &mut size4, &mut offset)?);
        } else if id == 0xf053_68c0_u32 {
            // v3 signature scheme
            v3_signing_exist = true;
        } else if id == 0x1b93_ad61_u32 {
            // v3.1 signature scheme: credits to vvb2060
            v3_1_signing_exist = true;
        }

        f.seek(SeekFrom::Current(
            i64::from_le_bytes(size8) - i64::from(offset),
        ))?;
    }

    if v3_signing_exist || v3_1_signing_exist {
        return Err(anyhow::anyhow!("Unexpected v3 signature found!",));
    }

    v2_signing.ok_or_else(|| anyhow::anyhow!("No signature found!"))
}

fn calc_cert_sha256(
    f: &mut std::fs::File,
    size4: &mut [u8; 4],
    offset: &mut u32,
) -> Result<(u32, String)> {
    f.read_exact(size4)?; // signer-sequence length
    f.read_exact(size4)?; // signer length
    f.read_exact(size4)?; // signed data length
    *offset += 0x4 * 3;

    f.read_exact(size4)?; // digests-sequence length
    let pos = u32::from_le_bytes(*size4); // skip digests
    f.seek(SeekFrom::Current(i64::from(pos)))?;
    *offset += 0x4 + pos;

    f.read_exact(size4)?; // certificates length
    f.read_exact(size4)?; // certificate length
    *offset += 0x4 * 2;

    let cert_len = u32::from_le_bytes(*size4);
    let mut cert: Vec<u8> = vec![0; cert_len as usize];
    f.read_exact(&mut cert)?;
    *offset += cert_len;

    Ok((cert_len, sha256::digest(&cert)))
}

```

`userspace/ksud/src/assets.rs`:

```rs
use anyhow::Result;
use rust_embed::RustEmbed;
use std::path::Path;

#[cfg(target_os = "android")]
mod android {
    use crate::assets::Asset;
    use crate::defs::BINARY_DIR;
    use crate::utils::ensure_binary;
    use const_format::concatcp;

    pub const RESETPROP_PATH: &str = concatcp!(BINARY_DIR, "resetprop");
    pub const BUSYBOX_PATH: &str = concatcp!(BINARY_DIR, "busybox");
    pub const BOOTCTL_PATH: &str = concatcp!(BINARY_DIR, "bootctl");

    pub fn ensure_binaries(ignore_if_exist: bool) -> anyhow::Result<()> {
        for file in Asset::iter() {
            if file == "ksuinit" || file.ends_with(".ko") {
                // don't extract ksuinit and kernel modules
                continue;
            }
            let asset =
                Asset::get(&file).ok_or_else(|| anyhow::anyhow!("asset not found: {file}"))?;
            ensure_binary(format!("{BINARY_DIR}{file}"), &asset.data, ignore_if_exist)?;
        }
        Ok(())
    }
}

#[cfg(target_os = "android")]
pub use android::*;

#[cfg(all(target_arch = "x86_64", target_os = "android"))]
#[derive(RustEmbed)]
#[folder = "bin/x86_64"]
struct Asset;

// IF NOT x86_64 ANDROID, ie. macos, linux, windows, always use aarch64
#[cfg(not(all(target_arch = "x86_64", target_os = "android")))]
#[derive(RustEmbed)]
#[folder = "bin/aarch64"]
struct Asset;

pub fn copy_assets_to_file(name: &str, dst: impl AsRef<Path>) -> Result<()> {
    let asset = Asset::get(name).ok_or_else(|| anyhow::anyhow!("asset not found: {name}"))?;
    std::fs::write(dst, asset.data)?;
    Ok(())
}

pub fn list_supported_kmi() -> std::vec::Vec<std::string::String> {
    let mut list = Vec::new();
    for file in Asset::iter() {
        // kmi_name = "xxx_kernelsu.ko"
        if let Some(kmi) = file.strip_suffix("_kernelsu.ko") {
            list.push(kmi.to_string());
        }
    }
    list
}

```

`userspace/ksud/src/banner`:

```
  _  __                    _ ____  _   _ 
 | |/ /___ _ __ _ __   ___| / ___|| | | |
 | ' // _ \ '__| '_ \ / _ \ \___ \| | | |
 | . \  __/ |  | | | |  __/ |___) | |_| |
 |_|\_\___|_|  |_| |_|\___|_|____/ \___/ 

```

`userspace/ksud/src/boot_patch.rs`:

```rs
#![allow(clippy::ref_option, clippy::needless_pass_by_value)]
#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use std::path::PathBuf;
use std::process::Command;
use std::process::Stdio;

use anyhow::Context;
use anyhow::Result;
use anyhow::bail;
use anyhow::ensure;
use regex_lite::Regex;
use which::which;

use crate::assets;

#[cfg(target_os = "android")]
mod android {
    use super::{PermissionsExt, Result, do_cpio_cmd};
    pub(super) use crate::defs::{BACKUP_FILENAME, KSU_BACKUP_DIR, KSU_BACKUP_FILE_PREFIX};
    use anyhow::{Context, anyhow, bail, ensure};
    use regex_lite::Regex;
    use std::path::{Path, PathBuf};
    use std::process::{Command, Stdio};

    use crate::utils;

    pub(super) fn ensure_gki_kernel() -> Result<()> {
        let version = get_kernel_version()?;
        let is_gki = version.0 == 5 && version.1 >= 10 || version.2 > 5;
        ensure!(is_gki, "only support GKI kernel");
        Ok(())
    }

    pub fn get_kernel_version() -> Result<(i32, i32, i32)> {
        let uname = rustix::system::uname();
        let version = uname.release().to_string_lossy();
        let re = Regex::new(r"(\d+)\.(\d+)\.(\d+)")?;
        if let Some(captures) = re.captures(&version) {
            let major = captures
                .get(1)
                .and_then(|m| m.as_str().parse::<i32>().ok())
                .ok_or_else(|| anyhow!("Major version parse error"))?;
            let minor = captures
                .get(2)
                .and_then(|m| m.as_str().parse::<i32>().ok())
                .ok_or_else(|| anyhow!("Minor version parse error"))?;
            let patch = captures
                .get(3)
                .and_then(|m| m.as_str().parse::<i32>().ok())
                .ok_or_else(|| anyhow!("Patch version parse error"))?;
            Ok((major, minor, patch))
        } else {
            Err(anyhow!("Invalid kernel version string"))
        }
    }

    fn parse_kmi(version: &str) -> Result<String> {
        let re = Regex::new(r"(.* )?(\d+\.\d+)(\S+)?(android\d+)(.*)")?;
        let cap = re
            .captures(version)
            .ok_or_else(|| anyhow::anyhow!("Failed to get KMI from boot/modules"))?;
        let android_version = cap.get(4).map_or("", |m| m.as_str());
        let kernel_version = cap.get(2).map_or("", |m| m.as_str());
        Ok(format!("{android_version}-{kernel_version}"))
    }

    fn parse_kmi_from_uname() -> Result<String> {
        let uname = rustix::system::uname();
        let version = uname.release().to_string_lossy();
        parse_kmi(&version)
    }

    fn parse_kmi_from_modules() -> Result<String> {
        use std::io::BufRead;
        // find a *.ko in /vendor/lib/modules
        let modfile = std::fs::read_dir("/vendor/lib/modules")?
            .filter_map(Result::ok)
            .find(|entry| entry.path().extension().is_some_and(|ext| ext == "ko"))
            .map(|entry| entry.path())
            .ok_or_else(|| anyhow!("No kernel module found"))?;
        let output = Command::new("modinfo").arg(modfile).output()?;
        for line in output.stdout.lines().map_while(Result::ok) {
            if line.starts_with("vermagic") {
                return parse_kmi(&line);
            }
        }
        bail!("Parse KMI from modules failed")
    }

    pub fn get_current_kmi() -> Result<String> {
        parse_kmi_from_uname().or_else(|_| parse_kmi_from_modules())
    }

    fn calculate_sha1(file_path: impl AsRef<Path>) -> Result<String> {
        use sha1::Digest;
        use std::io::Read;
        let mut file = std::fs::File::open(file_path.as_ref())?;
        let mut hasher = sha1::Sha1::new();
        let mut buffer = [0; 1024];

        loop {
            let n = file.read(&mut buffer)?;
            if n == 0 {
                break;
            }
            hasher.update(&buffer[..n]);
        }

        let result = hasher.finalize();
        Ok(format!("{result:x}"))
    }

    pub(super) fn do_backup(
        magiskboot: &Path,
        workdir: &Path,
        cpio_path: &Path,
        image: &Path,
    ) -> Result<()> {
        let sha1 = calculate_sha1(image)?;
        let filename = format!("{KSU_BACKUP_FILE_PREFIX}{sha1}");

        println!("- Backup stock boot image");
        // magiskboot cpio ramdisk.cpio 'add 0755 $BACKUP_FILENAME'
        let target = format!("{KSU_BACKUP_DIR}{filename}");
        std::fs::copy(image, &target).with_context(|| format!("backup to {target}"))?;
        std::fs::write(workdir.join(BACKUP_FILENAME), sha1.as_bytes()).context("write sha1")?;
        do_cpio_cmd(
            magiskboot,
            workdir,
            cpio_path,
            &format!("add 0755 {BACKUP_FILENAME} {BACKUP_FILENAME}"),
        )?;
        println!("- Stock image has been backup to");
        println!("- {target}");
        Ok(())
    }

    pub(super) fn clean_backup(sha1: &str) -> Result<()> {
        println!("- Clean up backup");
        let backup_name = format!("{KSU_BACKUP_FILE_PREFIX}{sha1}");
        let dir = std::fs::read_dir(KSU_BACKUP_DIR)?;
        for entry in dir.flatten() {
            let path = entry.path();
            if !path.is_file() {
                continue;
            }
            if let Some(name) = path.file_name() {
                let name = name.to_string_lossy().to_string();
                if name != backup_name
                    && name.starts_with(KSU_BACKUP_FILE_PREFIX)
                    && std::fs::remove_file(path).is_ok()
                {
                    println!("- removed {name}");
                }
            }
        }
        Ok(())
    }

    pub(super) fn flash_boot(bootdevice: &Option<String>, new_boot: PathBuf) -> Result<()> {
        let Some(bootdevice) = bootdevice else {
            bail!("boot device not found")
        };
        let status = Command::new("blockdev")
            .arg("--setrw")
            .arg(bootdevice)
            .status()?;
        ensure!(status.success(), "set boot device rw failed");
        dd(new_boot, bootdevice).context("flash boot failed")?;
        Ok(())
    }

    pub fn choose_boot_partition(
        kmi: &str,
        is_replace_kernel: bool,
        partition: &Option<String>,
    ) -> String {
        let slot_suffix = get_slot_suffix(false);
        let skip_init_boot = kmi.starts_with("android12-");
        let init_boot_exist =
            Path::new(&format!("/dev/block/by-name/init_boot{slot_suffix}")).exists();

        // if specific partition is specified, use it
        if let Some(part) = partition {
            return match part.as_str() {
                "boot" | "init_boot" | "vendor_boot" => part.clone(),
                _ => "boot".to_string(),
            };
        }

        // if init_boot exists and not skipping it, use it
        if !is_replace_kernel && init_boot_exist && !skip_init_boot {
            return "init_boot".to_string();
        }

        "boot".to_string()
    }

    pub fn get_slot_suffix(ota: bool) -> String {
        let mut slot_suffix = utils::getprop("ro.boot.slot_suffix").unwrap_or_default();
        if !slot_suffix.is_empty() && ota {
            if slot_suffix == "_a" {
                slot_suffix = "_b".to_string();
            } else {
                slot_suffix = "_a".to_string();
            }
        }
        slot_suffix
    }

    #[cfg(target_os = "android")]
    pub fn list_available_partitions() -> Vec<String> {
        let slot_suffix = get_slot_suffix(false);
        let candidates = vec!["boot", "init_boot", "vendor_boot"];
        candidates
            .into_iter()
            .filter(|name| Path::new(&format!("/dev/block/by-name/{name}{slot_suffix}")).exists())
            .map(ToString::to_string)
            .collect()
    }

    #[cfg(target_os = "android")]
    pub(super) fn post_ota() -> Result<()> {
        use crate::assets::BOOTCTL_PATH;
        use crate::defs::ADB_DIR;
        let status = Command::new(BOOTCTL_PATH).arg("hal-info").status()?;
        if !status.success() {
            return Ok(());
        }

        let current_slot = Command::new(BOOTCTL_PATH)
            .arg("get-current-slot")
            .output()?
            .stdout;
        let current_slot = String::from_utf8(current_slot)?;
        let current_slot = current_slot.trim();
        let target_slot = i32::from(current_slot == "0");

        Command::new(BOOTCTL_PATH)
            .arg(format!("set-active-boot-slot {target_slot}"))
            .status()?;

        let post_fs_data = Path::new(ADB_DIR).join("post-fs-data.d");
        utils::ensure_dir_exists(&post_fs_data)?;
        let post_ota_sh = post_fs_data.join("post_ota.sh");

        let sh_content = format!(
            r"
{BOOTCTL_PATH} mark-boot-successful
rm -f {BOOTCTL_PATH}
rm -f /data/adb/post-fs-data.d/post_ota.sh
"
        );

        std::fs::write(&post_ota_sh, sh_content)?;
        #[cfg(unix)]
        std::fs::set_permissions(post_ota_sh, std::fs::Permissions::from_mode(0o755))?;

        Ok(())
    }

    pub(super) fn dd<P: AsRef<Path>, Q: AsRef<Path>>(ifile: P, ofile: Q) -> Result<()> {
        let status = Command::new("dd")
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .arg(format!("if={}", ifile.as_ref().display()))
            .arg(format!("of={}", ofile.as_ref().display()))
            .status()?;
        ensure!(
            status.success(),
            "dd if={} of={} failed",
            ifile.as_ref().display(),
            ofile.as_ref().display()
        );
        Ok(())
    }
}

#[cfg(target_os = "android")]
pub use android::*;

fn parse_kmi_from_kernel(kernel: &PathBuf, workdir: &Path) -> Result<String> {
    use std::fs::{File, copy};
    use std::io::{BufReader, Read};
    let kernel_path = workdir.join("kernel");
    copy(kernel, &kernel_path).context("Failed to copy kernel")?;

    let file = File::open(&kernel_path).context("Failed to open kernel file")?;
    let mut reader = BufReader::new(file);
    let mut buffer = Vec::new();
    reader
        .read_to_end(&mut buffer)
        .context("Failed to read kernel file")?;

    let printable_strings: Vec<&str> = buffer
        .split(|&b| b == 0)
        .filter_map(|slice| std::str::from_utf8(slice).ok())
        .filter(|s| s.chars().all(|c| c.is_ascii_graphic() || c == ' '))
        .collect();

    let re =
        Regex::new(r"(?:.* )?(\d+\.\d+)(?:\S+)?(android\d+)").context("Failed to compile regex")?;
    for s in printable_strings {
        if let Some(caps) = re.captures(s)
            && let (Some(kernel_version), Some(android_version)) = (caps.get(1), caps.get(2))
        {
            let kmi = format!("{}-{}", android_version.as_str(), kernel_version.as_str());
            return Ok(kmi);
        }
    }
    println!("- Failed to get KMI version");
    bail!("Try to choose LKM manually")
}

fn parse_kmi_from_boot(magiskboot: &Path, image: &PathBuf, workdir: &Path) -> Result<String> {
    let image_path = workdir.join("image");

    std::fs::copy(image, &image_path).context("Failed to copy image")?;

    let status = Command::new(magiskboot)
        .current_dir(workdir)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .arg("unpack")
        .arg(&image_path)
        .status()
        .context("Failed to execute magiskboot command")?;

    if !status.success() {
        bail!("magiskboot unpack failed with status: {status:?}");
    }

    parse_kmi_from_kernel(&image_path, workdir)
}

fn do_cpio_cmd(magiskboot: &Path, workdir: &Path, cpio_path: &Path, cmd: &str) -> Result<()> {
    let status = Command::new(magiskboot)
        .current_dir(workdir)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .arg("cpio")
        .arg(cpio_path)
        .arg(cmd)
        .status()?;
    ensure!(status.success(), "magiskboot cpio {cmd} failed");
    Ok(())
}

fn is_magisk_patched(magiskboot: &Path, workdir: &Path, cpio_path: &Path) -> Result<bool> {
    let status = Command::new(magiskboot)
        .current_dir(workdir)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .arg("cpio")
        .arg(cpio_path)
        .arg("test")
        .status()?;
    // 0: stock, 1: magisk
    Ok(status.code() == Some(1))
}

fn is_kernelsu_patched(magiskboot: &Path, workdir: &Path, cpio_path: &Path) -> Result<bool> {
    let status = Command::new(magiskboot)
        .current_dir(workdir)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .arg("cpio")
        .arg(cpio_path)
        .arg("exists kernelsu.ko")
        .status()?;

    Ok(status.success())
}

fn find_magiskboot(magiskboot_path: Option<PathBuf>, workdir: &Path) -> Result<PathBuf> {
    let magiskboot = {
        if which("magiskboot").is_ok() {
            #[cfg(target_os = "android")]
            let _ = assets::ensure_binaries(true);
            "magiskboot".into()
        } else {
            // magiskboot is not in $PATH, use builtin or specified one
            let magiskboot = if let Some(magiskboot_path) = magiskboot_path {
                std::fs::canonicalize(magiskboot_path)?
            } else {
                let magiskboot_path = workdir.join("magiskboot");
                assets::copy_assets_to_file("magiskboot", &magiskboot_path)
                    .context("copy magiskboot failed")?;
                magiskboot_path
            };
            ensure!(magiskboot.exists(), "{} is not exist", magiskboot.display());
            #[cfg(unix)]
            let _ = std::fs::set_permissions(&magiskboot, std::fs::Permissions::from_mode(0o755));
            magiskboot
        }
    };
    Ok(magiskboot)
}

fn find_boot_image(
    image: &Option<PathBuf>,
    kmi: &str,
    ota: bool,
    is_replace_kernel: bool,
    workdir: &Path,
    partition: &Option<String>,
) -> Result<(PathBuf, Option<String>)> {
    let bootimage;
    let mut bootdevice = None;
    if let Some(ref image) = *image {
        ensure!(image.exists(), "boot image not found");
        bootimage = std::fs::canonicalize(image)?;
    } else {
        #[cfg(not(target_os = "android"))]
        {
            println!("- Current OS is not android, refusing auto bootimage/bootdevice detection");
            bail!("Please specify a boot image");
        }

        #[cfg(target_os = "android")]
        {
            let slot_suffix = get_slot_suffix(ota);
            let boot_partition_name = choose_boot_partition(kmi, is_replace_kernel, partition);
            let boot_partition = format!("/dev/block/by-name/{boot_partition_name}{slot_suffix}");

            println!("- Bootdevice: {boot_partition}");
            let tmp_boot_path = workdir.join("boot.img");

            dd(&boot_partition, &tmp_boot_path)?;

            ensure!(tmp_boot_path.exists(), "boot image not found");

            bootimage = tmp_boot_path;
            bootdevice = Some(boot_partition);
        }
    }
    Ok((bootimage, bootdevice))
}

#[derive(clap::Args, Debug)]
pub struct BootPatchArgs {
    /// boot image path, if not specified, will try to find the boot image automatically
    #[arg(short, long)]
    pub boot: Option<PathBuf>,

    /// kernel image path to replace
    #[arg(short, long)]
    pub kernel: Option<PathBuf>,

    /// LKM module path to replace, if not specified, will use the builtin one
    #[arg(short, long)]
    pub module: Option<PathBuf>,

    /// init to be replaced
    #[arg(short, long, requires("module"))]
    pub init: Option<PathBuf>,

    /// will use another slot when boot image is not specified
    #[cfg(target_os = "android")]
    #[arg(short = 'u', long, default_value = "false")]
    pub ota: bool,

    /// Flash it to boot partition after patch
    #[cfg(target_os = "android")]
    #[arg(short, long, default_value = "false")]
    pub flash: bool,

    /// output path, if not specified, will use current directory
    #[arg(short, long, default_value = None)]
    pub out: Option<PathBuf>,

    /// magiskboot path, if not specified, will search from $PATH
    #[arg(long, default_value = None)]
    pub magiskboot: Option<PathBuf>,

    /// KMI version, if specified, will use the specified KMI
    #[arg(long, default_value = None)]
    pub kmi: Option<String>,

    /// target partition override (init_boot | boot | vendor_boot)
    #[cfg(target_os = "android")]
    #[arg(long, default_value = None)]
    pub partition: Option<String>,

    /// File name of the output.
    #[arg(long, default_value = None)]
    pub out_name: Option<String>,
}

pub fn patch(args: BootPatchArgs) -> Result<()> {
    let inner = move || {
        let BootPatchArgs {
            boot: image,
            init,
            kernel,
            module: kmod,
            out,
            magiskboot: magiskboot_path,
            kmi,
            out_name,
            ..
        } = args;
        #[cfg(target_os = "android")]
        let BootPatchArgs {
            ota,
            flash,
            partition,
            ..
        } = args;

        println!(include_str!("banner"));

        let patch_file = image.is_some();

        #[cfg(target_os = "android")]
        if !patch_file {
            ensure_gki_kernel()?;
        }

        let is_replace_kernel = kernel.is_some();

        if is_replace_kernel {
            ensure!(
                init.is_none() && kmod.is_none(),
                "init and module must not be specified."
            );
        }

        let tmpdir = tempfile::Builder::new()
            .prefix("KernelSU")
            .tempdir()
            .context("create temp dir failed")?;
        let workdir = tmpdir.path();

        // extract magiskboot
        let magiskboot = find_magiskboot(magiskboot_path, workdir)?;

        let kmi = kmi.map_or_else(
            || -> Result<_> {
                if kmod.is_some() {
                    return Ok(String::new());
                }
                #[cfg(target_os = "android")]
                match get_current_kmi() {
                    Ok(value) => {
                        return Ok(value);
                    }
                    Err(e) => {
                        println!("- {e}");
                    }
                }
                Ok(if let Some(image_path) = &image {
                    println!(
                        "- Trying to auto detect KMI version for {}",
                        image_path.display()
                    );
                    parse_kmi_from_boot(&magiskboot, image_path, tmpdir.path())?
                } else if let Some(kernel_path) = &kernel {
                    println!(
                        "- Trying to auto detect KMI version for {}",
                        kernel_path.display()
                    );
                    parse_kmi_from_kernel(kernel_path, tmpdir.path())?
                } else {
                    String::new()
                })
            },
            Ok,
        )?;

        #[cfg(target_os = "android")]
        let (bootimage, bootdevice) =
            find_boot_image(&image, &kmi, ota, is_replace_kernel, workdir, &partition)?;

        #[cfg(not(target_os = "android"))]
        let (bootimage, _) =
            find_boot_image(&image, &kmi, false, is_replace_kernel, workdir, &None)?;

        let bootimage = bootimage.as_path();

        // try extract magiskboot/bootctl
        #[cfg(target_os = "android")]
        let _ = assets::ensure_binaries(false);

        if let Some(kernel) = kernel {
            std::fs::copy(kernel, workdir.join("kernel")).context("copy kernel from failed")?;
        }

        println!("- Preparing assets");

        let kmod_file = workdir.join("kernelsu.ko");
        if let Some(kmod) = kmod {
            std::fs::copy(kmod, kmod_file).context("copy kernel module failed")?;
        } else {
            // If kmod is not specified, extract from assets
            println!("- KMI: {kmi}");
            let name = format!("{kmi}_kernelsu.ko");
            assets::copy_assets_to_file(&name, kmod_file)
                .with_context(|| format!("Failed to copy {name}"))?;
        }

        let init_file = workdir.join("init");
        if let Some(init) = init {
            std::fs::copy(init, init_file).context("copy init failed")?;
        } else {
            assets::copy_assets_to_file("ksuinit", init_file).context("copy ksuinit failed")?;
        }

        println!("- Unpacking boot image");
        let status = Command::new(&magiskboot)
            .current_dir(workdir)
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .arg("unpack")
            .arg(bootimage)
            .status()?;
        ensure!(status.success(), "magiskboot unpack failed");

        let mut ramdisk = workdir.join("ramdisk.cpio");
        if !ramdisk.exists() {
            ramdisk = workdir.join("vendor_ramdisk").join("init_boot.cpio");
        }
        if !ramdisk.exists() {
            ramdisk = workdir.join("vendor_ramdisk").join("ramdisk.cpio");
        }
        if !ramdisk.exists() {
            println!("- No ramdisk, create by default");
            ramdisk = "ramdisk.cpio".into();
        }
        let ramdisk = ramdisk.as_path();
        let is_magisk_patched = is_magisk_patched(&magiskboot, workdir, ramdisk)?;
        ensure!(!is_magisk_patched, "Cannot work with Magisk patched image");

        println!("- Adding KernelSU LKM");
        let is_kernelsu_patched = is_kernelsu_patched(&magiskboot, workdir, ramdisk)?;

        if !is_kernelsu_patched {
            // kernelsu.ko is not exist, backup init if necessary
            let status = do_cpio_cmd(&magiskboot, workdir, ramdisk, "exists init");
            if status.is_ok() {
                do_cpio_cmd(&magiskboot, workdir, ramdisk, "mv init init.real")?;
            }
        }

        do_cpio_cmd(&magiskboot, workdir, ramdisk, "add 0755 init init")?;
        do_cpio_cmd(
            &magiskboot,
            workdir,
            ramdisk,
            "add 0755 kernelsu.ko kernelsu.ko",
        )?;

        #[cfg(target_os = "android")]
        if !is_kernelsu_patched
            && flash
            && let Err(e) = do_backup(&magiskboot, workdir, ramdisk, bootimage)
        {
            println!("- Backup stock image failed: {e}");
        }

        println!("- Repacking boot image");
        // magiskboot repack boot.img
        let status = Command::new(&magiskboot)
            .current_dir(workdir)
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .arg("repack")
            .arg(bootimage)
            .status()?;
        ensure!(status.success(), "magiskboot repack failed");
        let new_boot = workdir.join("new-boot.img");

        if patch_file {
            // if image is specified, write to output file
            let output_dir = out.unwrap_or(std::env::current_dir()?);
            let name = out_name.unwrap_or_else(|| {
                let now = chrono::Utc::now();
                format!("kernelsu_patched_{}.img", now.format("%Y%m%d_%H%M%S"))
            });
            let output_image = output_dir.join(name);
            if std::fs::rename(&new_boot, &output_image).is_err() {
                std::fs::copy(&new_boot, &output_image).context("copy out new boot failed")?;
            }
            println!("- Output file is written to");
            println!("- {}", output_image.display().to_string().trim_matches('"'));
        }

        #[cfg(target_os = "android")]
        if flash {
            println!("- Flashing new boot image");
            flash_boot(&bootdevice, new_boot)?;

            if ota {
                post_ota()?;
            }
        }

        println!("- Done!");
        Ok(())
    };

    let result = inner();
    if let Err(ref e) = result {
        println!("- Patch Error: {e}");
    }
    result
}

#[derive(clap::Args, Debug)]
pub struct BootRestoreArgs {
    /// boot image path, if not specified, will try to find the boot image automatically
    #[arg(short, long)]
    pub boot: Option<PathBuf>,

    /// Flash it to boot partition after restore
    #[cfg(target_os = "android")]
    #[arg(short, long, default_value = "false")]
    pub flash: bool,

    /// magiskboot path, if not specified, will search from $PATH
    #[arg(long, default_value = None)]
    pub magiskboot: Option<PathBuf>,

    /// File name of the output.
    #[arg(long, default_value = None)]
    pub out_name: Option<String>,
}

pub fn restore(args: BootRestoreArgs) -> Result<()> {
    let BootRestoreArgs {
        boot: image,
        magiskboot: magiskboot_path,
        out_name,
        ..
    } = args;
    #[cfg(target_os = "android")]
    let BootRestoreArgs { flash, .. } = args;

    let tmpdir = tempfile::Builder::new()
        .prefix("KernelSU")
        .tempdir()
        .context("create temp dir failed")?;
    let workdir = tmpdir.path();
    let magiskboot = find_magiskboot(magiskboot_path, workdir)?;

    #[cfg(target_os = "android")]
    let kmi = get_current_kmi().unwrap_or_default();

    #[cfg(target_os = "android")]
    let (bootimage, bootdevice) = find_boot_image(&image, &kmi, false, false, workdir, &None)?;
    #[cfg(not(target_os = "android"))]
    let (bootimage, _) = find_boot_image(&image, "", false, false, workdir, &None)?;

    println!("- Unpacking boot image");
    let status = Command::new(&magiskboot)
        .current_dir(workdir)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .arg("unpack")
        .arg(bootimage.display().to_string())
        .status()?;
    ensure!(status.success(), "magiskboot unpack failed");

    let mut ramdisk = workdir.join("ramdisk.cpio");
    if !ramdisk.exists() {
        ramdisk = workdir.join("vendor_ramdisk").join("init_boot.cpio");
    }
    if !ramdisk.exists() {
        ramdisk = workdir.join("vendor_ramdisk").join("ramdisk.cpio");
    }
    if !ramdisk.exists() {
        bail!("No compatible ramdisk found.")
    }
    let ramdisk = ramdisk.as_path();
    let is_kernelsu_patched = is_kernelsu_patched(&magiskboot, workdir, ramdisk)?;
    ensure!(is_kernelsu_patched, "boot image is not patched by KernelSU");

    #[cfg(target_os = "android")]
    let mut new_boot = None;
    #[cfg(target_os = "android")]
    let mut from_backup = false;
    #[cfg(not(target_os = "android"))]
    let from_backup = false;

    #[cfg(target_os = "android")]
    if do_cpio_cmd(
        &magiskboot,
        workdir,
        ramdisk,
        &format!("exists {BACKUP_FILENAME}"),
    )
    .is_ok()
    {
        do_cpio_cmd(
            &magiskboot,
            workdir,
            ramdisk,
            &format!("extract {BACKUP_FILENAME} {BACKUP_FILENAME}"),
        )?;
        let sha = std::fs::read(workdir.join(BACKUP_FILENAME))?;
        let sha = String::from_utf8(sha)?;
        let sha = sha.trim();
        let backup_path =
            PathBuf::from(KSU_BACKUP_DIR).join(format!("{KSU_BACKUP_FILE_PREFIX}{sha}"));
        if backup_path.is_file() {
            new_boot = Some(backup_path);
            from_backup = true;
        } else {
            println!("- Warning: no backup {} found!", backup_path.display());
        }

        if let Err(e) = clean_backup(sha) {
            println!("- Warning: Cleanup backup image failed: {e}");
        }
    } else {
        println!("- Backup info is absent!");
    }

    let remove_ksu = || -> Result<_> {
        // remove kernelsu.ko
        do_cpio_cmd(&magiskboot, workdir, ramdisk, "rm kernelsu.ko")?;

        // if init.real exists, restore it
        let status = do_cpio_cmd(&magiskboot, workdir, ramdisk, "exists init.real").is_ok();
        if status {
            do_cpio_cmd(&magiskboot, workdir, ramdisk, "mv init.real init")?;
        }

        println!("- Repacking boot image");
        let status = Command::new(&magiskboot)
            .current_dir(workdir)
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .arg("repack")
            .arg(&bootimage)
            .status()?;
        ensure!(status.success(), "magiskboot repack failed");
        Ok(workdir.join("new-boot.img"))
    };
    #[cfg(target_os = "android")]
    let new_boot = new_boot.map_or_else(remove_ksu, Ok)?;
    #[cfg(not(target_os = "android"))]
    let new_boot = remove_ksu()?;

    if image.is_some() {
        // if image is specified, write to output file
        let output_dir = std::env::current_dir()?;
        let name = out_name.unwrap_or_else(|| {
            let now = chrono::Utc::now();
            format!("kernelsu_restore_{}.img", now.format("%Y%m%d_%H%M%S"))
        });
        let output_image = output_dir.join(name);

        if from_backup || std::fs::rename(&new_boot, &output_image).is_err() {
            std::fs::copy(&new_boot, &output_image).context("copy out new boot failed")?;
        }
        println!("- Output file is written to");
        println!("- {}", output_image.display().to_string().trim_matches('"'));
    }
    #[cfg(target_os = "android")]
    if flash {
        if from_backup {
            println!("- Flashing new boot image from {}", new_boot.display());
        } else {
            println!("- Flashing new boot image");
        }
        flash_boot(&bootdevice, new_boot)?;
    }
    println!("- Done!");
    Ok(())
}

```

`userspace/ksud/src/cli.rs`:

```rs
use anyhow::{Context, Ok, Result};
use clap::Parser;
use std::path::PathBuf;

use android_logger::Config;
use log::LevelFilter;

use crate::boot_patch::{BootPatchArgs, BootRestoreArgs};
use crate::{apk_sign, assets, debug, defs, init_event, ksucalls, module, module_config, utils};

/// KernelSU userspace cli
#[derive(Parser, Debug)]
#[command(author, version = defs::VERSION_NAME, about, long_about = None)]
struct Args {
    #[command(subcommand)]
    command: Commands,
}

#[derive(clap::Subcommand, Debug)]
enum Commands {
    /// Manage KernelSU modules
    Module {
        #[command(subcommand)]
        command: Module,
    },

    /// Trigger `post-fs-data` event
    PostFsData,

    /// Trigger `service` event
    Services,

    /// Trigger `boot-complete` event
    BootCompleted,

    /// Install KernelSU userspace component to system
    Install {
        #[arg(long, default_value = None)]
        magiskboot: Option<PathBuf>,
    },

    /// Uninstall KernelSU modules and itself(LKM Only)
    Uninstall {
        /// magiskboot path, if not specified, will search from $PATH
        #[arg(long, default_value = None)]
        magiskboot: Option<PathBuf>,
    },

    /// SELinux policy Patch tool
    Sepolicy {
        #[command(subcommand)]
        command: Sepolicy,
    },

    /// Manage App Profiles
    Profile {
        #[command(subcommand)]
        command: Profile,
    },

    /// Manage kernel features
    Feature {
        #[command(subcommand)]
        command: Feature,
    },

    /// Patch boot or init_boot images to apply KernelSU
    BootPatch(BootPatchArgs),

    /// Restore boot or init_boot images patched by KernelSU
    BootRestore(BootRestoreArgs),

    /// Show boot information
    BootInfo {
        #[command(subcommand)]
        command: BootInfo,
    },
    /// For developers
    Debug {
        #[command(subcommand)]
        command: Debug,
    },
    /// Kernel interface
    Kernel {
        #[command(subcommand)]
        command: Kernel,
    },
}

#[derive(clap::Subcommand, Debug)]
enum BootInfo {
    /// show current kmi version
    CurrentKmi,

    /// show supported kmi versions
    SupportedKmis,

    /// check if device is A/B capable
    IsAbDevice,

    /// show auto-selected boot partition name
    DefaultPartition,

    /// list available partitions for current or OTA toggled slot
    AvailablePartitions,

    /// show slot suffix for current or OTA toggled slot
    SlotSuffix {
        /// toggle to another slot
        #[arg(short = 'u', long, default_value = "false")]
        ota: bool,
    },
}

#[derive(clap::Subcommand, Debug)]
enum Debug {
    /// Set the manager app, kernel CONFIG_KSU_DEBUG should be enabled.
    SetManager {
        /// manager package name
        #[arg(default_value_t = String::from("me.weishu.kernelsu"))]
        apk: String,
    },

    /// Get apk size and hash
    GetSign {
        /// apk path
        apk: String,
    },

    /// Root Shell
    Su {
        /// switch to gloabl mount namespace
        #[arg(short, long, default_value = "false")]
        global_mnt: bool,
    },

    /// Get kernel version
    Version,

    /// For testing
    Test,

    /// Process mark management
    Mark {
        #[command(subcommand)]
        command: MarkCommand,
    },
}

#[derive(clap::Subcommand, Debug)]
enum MarkCommand {
    /// Get mark status for a process (or all)
    Get {
        /// target pid (0 for total count)
        #[arg(default_value = "0")]
        pid: i32,
    },

    /// Mark a process
    Mark {
        /// target pid (0 for all processes)
        #[arg(default_value = "0")]
        pid: i32,
    },

    /// Unmark a process
    Unmark {
        /// target pid (0 for all processes)
        #[arg(default_value = "0")]
        pid: i32,
    },

    /// Refresh mark for all running processes
    Refresh,
}

#[derive(clap::Subcommand, Debug)]
enum Sepolicy {
    /// Patch sepolicy
    Patch {
        /// sepolicy statements
        sepolicy: String,
    },

    /// Apply sepolicy from file
    Apply {
        /// sepolicy file path
        file: String,
    },

    /// Check if sepolicy statement is supported/valid
    Check {
        /// sepolicy statements
        sepolicy: String,
    },
}

#[derive(clap::Subcommand, Debug)]
enum Module {
    /// Install module <ZIP>
    Install {
        /// module zip file path
        zip: String,
    },

    /// Undo module uninstall mark <id>
    UndoUninstall {
        /// module id
        id: String,
    },

    /// Uninstall module <id>
    Uninstall {
        /// module id
        id: String,
    },

    /// enable module <id>
    Enable {
        /// module id
        id: String,
    },

    /// disable module <id>
    Disable {
        // module id
        id: String,
    },

    /// run action for module <id>
    Action {
        // module id
        id: String,
    },

    /// list all modules
    List,

    /// manage module configuration
    Config {
        #[command(subcommand)]
        command: ModuleConfigCmd,
    },
}

#[derive(clap::Subcommand, Debug)]
enum ModuleConfigCmd {
    /// Get a config value
    Get {
        /// config key
        key: String,
    },

    /// Set a config value
    Set {
        /// config key
        key: String,
        /// config value (omit to read from stdin)
        value: Option<String>,
        /// read value from stdin (default if value not provided)
        #[arg(long)]
        stdin: bool,
        /// use temporary config (cleared on reboot)
        #[arg(short, long)]
        temp: bool,
    },

    /// List all config entries
    List,

    /// Delete a config entry
    Delete {
        /// config key
        key: String,
        /// delete from temporary config
        #[arg(short, long)]
        temp: bool,
    },

    /// Clear all config entries
    Clear {
        /// clear temporary config
        #[arg(short, long)]
        temp: bool,
    },
}

#[derive(clap::Subcommand, Debug)]
enum Profile {
    /// get root profile's selinux policy of <package-name>
    GetSepolicy {
        /// package name
        package: String,
    },

    /// set root profile's selinux policy of <package-name> to <profile>
    SetSepolicy {
        /// package name
        package: String,
        /// policy statements
        policy: String,
    },

    /// get template of <id>
    GetTemplate {
        /// template id
        id: String,
    },

    /// set template of <id> to <template string>
    SetTemplate {
        /// template id
        id: String,
        /// template string
        template: String,
    },

    /// delete template of <id>
    DeleteTemplate {
        /// template id
        id: String,
    },

    /// list all templates
    ListTemplates,
}

#[derive(clap::Subcommand, Debug)]
enum Feature {
    /// Get feature value and support status
    Get {
        /// Feature ID or name (su_compat, kernel_umount)
        id: String,
        /// Read from config file
        #[arg(long, default_value_t = false)]
        config: bool,
    },

    /// Set feature value
    Set {
        /// Feature ID or name
        id: String,
        /// Feature value (0=disable, 1=enable)
        value: u64,
    },

    /// List all available features
    List,

    /// Check feature status (supported/unsupported/managed)
    Check {
        /// Feature ID or name (su_compat, kernel_umount)
        id: String,
    },

    /// Load configuration from file and apply to kernel
    Load,

    /// Save current kernel feature states to file
    Save,
}

#[derive(clap::Subcommand, Debug)]
enum Kernel {
    /// Nuke ext4 sysfs
    NukeExt4Sysfs {
        /// mount point
        mnt: String,
    },
    /// Manage umount list
    Umount {
        #[command(subcommand)]
        command: UmountOp,
    },
    /// Notify that module is mounted
    NotifyModuleMounted,
}

#[derive(clap::Subcommand, Debug)]
enum UmountOp {
    /// Add mount point to umount list
    Add {
        /// mount point path
        mnt: String,
        /// umount flags (default: 0, MNT_DETACH: 2)
        #[arg(short, long, default_value = "0")]
        flags: u32,
    },
    /// Delete mount point from umount list
    Del {
        /// mount point path
        mnt: String,
    },
    /// Wipe all entries from umount list
    Wipe,
}

pub fn run() -> Result<()> {
    android_logger::init_once(
        Config::default()
            .with_max_level(crate::debug_select!(LevelFilter::Trace, LevelFilter::Info))
            .with_tag("KernelSU"),
    );

    // the kernel executes su with argv[0] = "su" and replace it with us
    let arg0 = std::env::args().next().unwrap_or_default();
    if arg0 == "su" || arg0 == "/system/bin/su" {
        return crate::su::root_shell();
    }

    let cli = Args::parse();

    log::info!("command: {:?}", cli.command);

    let result = match cli.command {
        Commands::PostFsData => init_event::on_post_data_fs(),
        Commands::BootCompleted => {
            init_event::on_boot_completed();
            Ok(())
        }

        Commands::Module { command } => {
            utils::switch_mnt_ns(1)?;
            match command {
                Module::Install { zip } => module::install_module(&zip),
                Module::UndoUninstall { id } => module::undo_uninstall_module(&id),
                Module::Uninstall { id } => module::uninstall_module(&id),
                Module::Enable { id } => module::enable_module(&id),
                Module::Disable { id } => module::disable_module(&id),
                Module::Action { id } => module::run_action(&id),
                Module::List => module::list_modules(),
                Module::Config { command } => {
                    // Get module ID from environment variable
                    let module_id = std::env::var("KSU_MODULE").map_err(|_| {
                        anyhow::anyhow!("This command must be run in the context of a module")
                    })?;

                    match command {
                        ModuleConfigCmd::Get { key } => {
                            // Use merge_configs to respect priority (temp overrides persist)
                            let config = module_config::merge_configs(&module_id)?;
                            match config.get(&key) {
                                Some(value) => {
                                    println!("{value}");
                                    Ok(())
                                }
                                None => anyhow::bail!("Key '{key}' not found"),
                            }
                        }
                        ModuleConfigCmd::Set {
                            key,
                            value,
                            stdin,
                            temp,
                        } => {
                            // Validate key at CLI layer for better user experience
                            module_config::validate_config_key(&key)?;

                            // Read value from stdin or argument
                            let value_str = match value {
                                Some(v) if !stdin => v,
                                _ => {
                                    // Read from stdin
                                    use std::io::Read;
                                    let mut buffer = String::new();
                                    std::io::stdin()
                                        .read_to_string(&mut buffer)
                                        .context("Failed to read from stdin")?;
                                    buffer
                                }
                            };

                            // Validate value
                            module_config::validate_config_value(&value_str)?;

                            let config_type = if temp {
                                module_config::ConfigType::Temp
                            } else {
                                module_config::ConfigType::Persist
                            };
                            module_config::set_config_value(
                                &module_id,
                                &key,
                                &value_str,
                                config_type,
                            )
                        }
                        ModuleConfigCmd::List => {
                            let config = module_config::merge_configs(&module_id)?;
                            if config.is_empty() {
                                println!("No config entries found");
                            } else {
                                for (key, value) in config {
                                    println!("{key}={value}");
                                }
                            }
                            Ok(())
                        }
                        ModuleConfigCmd::Delete { key, temp } => {
                            let config_type = if temp {
                                module_config::ConfigType::Temp
                            } else {
                                module_config::ConfigType::Persist
                            };
                            module_config::delete_config_value(&module_id, &key, config_type)
                        }
                        ModuleConfigCmd::Clear { temp } => {
                            let config_type = if temp {
                                module_config::ConfigType::Temp
                            } else {
                                module_config::ConfigType::Persist
                            };
                            module_config::clear_config(&module_id, config_type)
                        }
                    }
                }
            }
        }
        Commands::Install { magiskboot } => utils::install(magiskboot),
        Commands::Uninstall { magiskboot } => utils::uninstall(magiskboot),
        Commands::Sepolicy { command } => match command {
            Sepolicy::Patch { sepolicy } => crate::sepolicy::live_patch(&sepolicy),
            Sepolicy::Apply { file } => crate::sepolicy::apply_file(file),
            Sepolicy::Check { sepolicy } => crate::sepolicy::check_rule(&sepolicy),
        },
        Commands::Services => {
            init_event::on_services();
            Ok(())
        }
        Commands::Profile { command } => match command {
            Profile::GetSepolicy { package } => crate::profile::get_sepolicy(package),
            Profile::SetSepolicy { package, policy } => {
                crate::profile::set_sepolicy(package, policy)
            }
            Profile::GetTemplate { id } => crate::profile::get_template(id),
            Profile::SetTemplate { id, template } => crate::profile::set_template(id, template),
            Profile::DeleteTemplate { id } => crate::profile::delete_template(id),
            Profile::ListTemplates => crate::profile::list_templates(),
        },

        Commands::Feature { command } => match command {
            Feature::Get { id, config } => {
                if config {
                    crate::feature::get_feature_config(&id)
                } else {
                    crate::feature::get_feature(&id)
                }
            }
            Feature::Set { id, value } => crate::feature::set_feature(&id, value),
            Feature::List => {
                crate::feature::list_features();
                Ok(())
            }
            Feature::Check { id } => crate::feature::check_feature(&id),
            Feature::Load => crate::feature::load_config_and_apply(),
            Feature::Save => crate::feature::save_config(),
        },

        Commands::Debug { command } => match command {
            Debug::SetManager { apk } => debug::set_manager(&apk),
            Debug::GetSign { apk } => {
                let sign = apk_sign::get_apk_signature(&apk)?;
                println!("size: {:#x}, hash: {}", sign.0, sign.1);
                Ok(())
            }
            Debug::Version => {
                println!("Kernel Version: {}", ksucalls::get_version());
                Ok(())
            }
            Debug::Su { global_mnt } => crate::su::grant_root(global_mnt),
            Debug::Test => assets::ensure_binaries(false),
            Debug::Mark { command } => match command {
                MarkCommand::Get { pid } => debug::mark_get(pid),
                MarkCommand::Mark { pid } => debug::mark_set(pid),
                MarkCommand::Unmark { pid } => debug::mark_unset(pid),
                MarkCommand::Refresh => debug::mark_refresh(),
            },
        },

        Commands::BootPatch(boot_patch) => crate::boot_patch::patch(boot_patch),

        Commands::BootInfo { command } => match command {
            BootInfo::CurrentKmi => {
                let kmi = crate::boot_patch::get_current_kmi()?;
                println!("{kmi}");
                // return here to avoid printing the error message
                return Ok(());
            }
            BootInfo::SupportedKmis => {
                let kmi = crate::assets::list_supported_kmi();
                for kmi in &kmi {
                    println!("{kmi}");
                }
                return Ok(());
            }
            BootInfo::IsAbDevice => {
                let val = crate::utils::getprop("ro.build.ab_update")
                    .unwrap_or_else(|| String::from("false"));
                let is_ab = val.trim().to_lowercase() == "true";
                println!("{}", if is_ab { "true" } else { "false" });
                return Ok(());
            }
            BootInfo::DefaultPartition => {
                let kmi = crate::boot_patch::get_current_kmi().unwrap_or_else(|_| String::new());
                let name = crate::boot_patch::choose_boot_partition(&kmi, false, &None);
                println!("{name}");
                return Ok(());
            }
            BootInfo::SlotSuffix { ota } => {
                let suffix = crate::boot_patch::get_slot_suffix(ota);
                println!("{suffix}");
                return Ok(());
            }
            BootInfo::AvailablePartitions => {
                let parts = crate::boot_patch::list_available_partitions();
                for p in &parts {
                    println!("{p}");
                }
                return Ok(());
            }
        },
        Commands::BootRestore(boot_restore) => crate::boot_patch::restore(boot_restore),
        Commands::Kernel { command } => match command {
            Kernel::NukeExt4Sysfs { mnt } => ksucalls::nuke_ext4_sysfs(&mnt),
            Kernel::Umount { command } => match command {
                UmountOp::Add { mnt, flags } => ksucalls::umount_list_add(&mnt, flags),
                UmountOp::Del { mnt } => ksucalls::umount_list_del(&mnt),
                UmountOp::Wipe => ksucalls::umount_list_wipe().map_err(Into::into),
            },
            Kernel::NotifyModuleMounted => {
                ksucalls::report_module_mounted();
                Ok(())
            }
        },
    };

    if let Err(e) = &result {
        log::error!("Error: {e:?}");
    }
    result
}

```

`userspace/ksud/src/cli_non_android.rs`:

```rs
use anyhow::Result;
use clap::Parser;

use crate::boot_patch::{BootPatchArgs, BootRestoreArgs};
use crate::{apk_sign, defs};

/// KernelSU cli for non-android
#[derive(Parser, Debug)]
#[command(author, version = defs::VERSION_NAME, about, long_about = None)]
struct Args {
    #[command(subcommand)]
    command: Commands,
}

#[derive(clap::Subcommand, Debug)]
enum Commands {
    /// Patch boot or init_boot images to apply KernelSU
    BootPatch(BootPatchArgs),

    /// Restore boot or init_boot images patched by KernelSU
    BootRestore(BootRestoreArgs),

    /// Get apk size and hash
    GetSign {
        /// apk path
        apk: String,
    },

    /// show supported kmi versions
    SupportedKmis,
}

pub fn run() -> Result<()> {
    env_logger::init();

    let cli = Args::parse();

    log::info!("command: {:?}", cli.command);

    let result = match cli.command {
        Commands::GetSign { apk } => {
            let sign = apk_sign::get_apk_signature(&apk)?;
            println!("size: {:#x}, hash: {}", sign.0, sign.1);
            Ok(())
        }

        Commands::BootPatch(boot_patch) => crate::boot_patch::patch(boot_patch),

        Commands::BootRestore(boot_restore) => crate::boot_patch::restore(boot_restore),

        Commands::SupportedKmis => {
            let kmi = crate::assets::list_supported_kmi();
            for kmi in &kmi {
                println!("{kmi}");
            }
            Ok(())
        }
    };

    if let Err(e) = &result {
        log::error!("Error: {e:?}");
    }
    result
}

```

`userspace/ksud/src/debug.rs`:

```rs
use anyhow::{Context, Ok, Result, bail, ensure};
use std::{
    path::{Path, PathBuf},
    process::Command,
};

use crate::ksucalls;

const KERNEL_PARAM_PATH: &str = "/sys/module/kernelsu";

fn read_u32(path: &PathBuf) -> Result<u32> {
    let content = std::fs::read_to_string(path)?;
    let content = content.trim();
    let content = content.parse::<u32>()?;
    Ok(content)
}

fn set_kernel_param(uid: u32) -> Result<()> {
    let kernel_param_path = Path::new(KERNEL_PARAM_PATH).join("parameters");

    let ksu_debug_manager_uid = kernel_param_path.join("ksu_debug_manager_uid");
    let before_uid = read_u32(&ksu_debug_manager_uid)?;
    std::fs::write(&ksu_debug_manager_uid, uid.to_string())?;
    let after_uid = read_u32(&ksu_debug_manager_uid)?;

    println!("set manager uid: {before_uid} -> {after_uid}");

    Ok(())
}

fn get_pkg_uid(pkg: &str) -> Result<u32> {
    // stat /data/data/<pkg>
    let uid = rustix::fs::stat(format!("/data/data/{pkg}"))
        .with_context(|| format!("stat /data/data/{pkg}"))?
        .st_uid;
    Ok(uid)
}

pub fn set_manager(pkg: &str) -> Result<()> {
    ensure!(
        Path::new(KERNEL_PARAM_PATH).exists(),
        "CONFIG_KSU_DEBUG is not enabled"
    );

    let uid = get_pkg_uid(pkg)?;
    set_kernel_param(uid)?;
    // force-stop it
    let _ = Command::new("am").args(["force-stop", pkg]).status();
    Ok(())
}

/// Get mark status for a process
pub fn mark_get(pid: i32) -> Result<()> {
    let result = ksucalls::mark_get(pid)?;
    if pid == 0 {
        bail!("Please specify a pid to get its mark status");
    }
    println!(
        "Process {pid} mark status: {}",
        if result != 0 { "marked" } else { "unmarked" }
    );
    Ok(())
}

/// Mark a process
pub fn mark_set(pid: i32) -> Result<()> {
    ksucalls::mark_set(pid)?;
    if pid == 0 {
        println!("All processes marked successfully");
    } else {
        println!("Process {pid} marked successfully");
    }
    Ok(())
}

/// Unmark a process
pub fn mark_unset(pid: i32) -> Result<()> {
    ksucalls::mark_unset(pid)?;
    if pid == 0 {
        println!("All processes unmarked successfully");
    } else {
        println!("Process {pid} unmarked successfully");
    }
    Ok(())
}

/// Refresh mark for all running processes
pub fn mark_refresh() -> Result<()> {
    ksucalls::mark_refresh()?;
    println!("Refreshed mark for all running processes");
    Ok(())
}

```

`userspace/ksud/src/defs.rs`:

```rs
#[cfg(target_os = "android")]
mod android {
    use const_format::concatcp;

    pub const ADB_DIR: &str = "/data/adb/";
    pub const WORKING_DIR: &str = concatcp!(ADB_DIR, "ksu/");
    pub const BINARY_DIR: &str = concatcp!(WORKING_DIR, "bin/");
    pub const LOG_DIR: &str = concatcp!(WORKING_DIR, "log/");

    pub const PROFILE_DIR: &str = concatcp!(WORKING_DIR, "profile/");
    pub const PROFILE_SELINUX_DIR: &str = concatcp!(PROFILE_DIR, "selinux/");
    pub const PROFILE_TEMPLATE_DIR: &str = concatcp!(PROFILE_DIR, "templates/");

    pub const KSURC_PATH: &str = concatcp!(WORKING_DIR, ".ksurc");
    pub const DAEMON_PATH: &str = concatcp!(ADB_DIR, "ksud");
    pub const MAGISKBOOT_PATH: &str = concatcp!(BINARY_DIR, "magiskboot");

    pub const DAEMON_LINK_PATH: &str = concatcp!(BINARY_DIR, "ksud");

    pub const MODULE_DIR: &str = concatcp!(ADB_DIR, "modules/");
    pub const MODULE_UPDATE_DIR: &str = concatcp!(ADB_DIR, "modules_update/");
    pub const METAMODULE_DIR: &str = concatcp!(ADB_DIR, "metamodule/");

    pub const MODULE_WEB_DIR: &str = "webroot";
    pub const MODULE_ACTION_SH: &str = "action.sh";
    pub const DISABLE_FILE_NAME: &str = "disable";
    pub const UPDATE_FILE_NAME: &str = "update";
    pub const REMOVE_FILE_NAME: &str = "remove";

    // Module config system
    pub const MODULE_CONFIG_DIR: &str = concatcp!(WORKING_DIR, "module_configs/");
    pub const PERSIST_CONFIG_NAME: &str = "persist.config";
    pub const TEMP_CONFIG_NAME: &str = "tmp.config";

    // Metamodule support
    pub const METAMODULE_MOUNT_SCRIPT: &str = "metamount.sh";
    pub const METAMODULE_METAINSTALL_SCRIPT: &str = "metainstall.sh";
    pub const METAMODULE_METAUNINSTALL_SCRIPT: &str = "metauninstall.sh";

    pub const KSU_BACKUP_DIR: &str = WORKING_DIR;
    pub const KSU_BACKUP_FILE_PREFIX: &str = "ksu_backup_";
    pub const BACKUP_FILENAME: &str = "stock_image.sha1";
}

pub const VERSION_CODE: &str = include_str!(concat!(env!("OUT_DIR"), "/VERSION_CODE"));
pub const VERSION_NAME: &str = include_str!(concat!(env!("OUT_DIR"), "/VERSION_NAME"));

#[cfg(target_os = "android")]
pub use android::*;

```

`userspace/ksud/src/feature.rs`:

```rs
use anyhow::{Context, Result, bail};
use const_format::concatcp;
use std::collections::HashMap;
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;

use crate::defs;

const FEATURE_CONFIG_PATH: &str = concatcp!(defs::WORKING_DIR, ".feature_config");
#[allow(clippy::unreadable_literal)]
const FEATURE_MAGIC: u32 = 0x7f4b5355;
const FEATURE_VERSION: u32 = 1;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum FeatureId {
    SuCompat = 0,
    KernelUmount = 1,
}

impl FeatureId {
    pub const fn from_u32(id: u32) -> Option<Self> {
        match id {
            0 => Some(Self::SuCompat),
            1 => Some(Self::KernelUmount),
            _ => None,
        }
    }

    pub const fn name(self) -> &'static str {
        match self {
            Self::SuCompat => "su_compat",
            Self::KernelUmount => "kernel_umount",
        }
    }

    pub const fn description(self) -> &'static str {
        match self {
            Self::SuCompat => {
                "SU Compatibility Mode - allows authorized apps to gain root via traditional 'su' command"
            }
            Self::KernelUmount => {
                "Kernel Umount - controls whether kernel automatically unmounts modules when not needed"
            }
        }
    }
}

fn parse_feature_id(name: &str) -> Result<FeatureId> {
    match name {
        "su_compat" | "0" => Ok(FeatureId::SuCompat),
        "kernel_umount" | "1" => Ok(FeatureId::KernelUmount),
        _ => bail!("Unknown feature: {name}"),
    }
}

pub fn load_binary_config() -> Result<HashMap<u32, u64>> {
    let path = Path::new(FEATURE_CONFIG_PATH);
    if !path.exists() {
        log::info!("Feature config not found, using defaults");
        return Ok(HashMap::new());
    }

    let mut file = File::open(path).with_context(|| "Failed to open feature config")?;

    let mut magic_buf = [0u8; 4];
    file.read_exact(&mut magic_buf)
        .with_context(|| "Failed to read magic")?;
    let magic = u32::from_le_bytes(magic_buf);

    if magic != FEATURE_MAGIC {
        bail!("Invalid feature config magic: expected 0x{FEATURE_MAGIC:08x}, got 0x{magic:08x}",);
    }

    let mut version_buf = [0u8; 4];
    file.read_exact(&mut version_buf)
        .with_context(|| "Failed to read version")?;
    let version = u32::from_le_bytes(version_buf);

    if version != FEATURE_VERSION {
        log::warn!(
            "Feature config version mismatch: expected {FEATURE_VERSION}, got {version
            }",
        );
    }

    let mut count_buf = [0u8; 4];
    file.read_exact(&mut count_buf)
        .with_context(|| "Failed to read count")?;
    let count = u32::from_le_bytes(count_buf);

    let mut features = HashMap::new();
    for _ in 0..count {
        let mut id_buf = [0u8; 4];
        let mut value_buf = [0u8; 8];

        file.read_exact(&mut id_buf)
            .with_context(|| "Failed to read feature id")?;
        file.read_exact(&mut value_buf)
            .with_context(|| "Failed to read feature value")?;

        let id = u32::from_le_bytes(id_buf);
        let value = u64::from_le_bytes(value_buf);

        features.insert(id, value);
    }

    log::info!("Loaded {} features from config", features.len());
    Ok(features)
}

pub fn save_binary_config(features: &HashMap<u32, u64>) -> Result<()> {
    crate::utils::ensure_dir_exists(Path::new(defs::WORKING_DIR))?;

    let path = Path::new(FEATURE_CONFIG_PATH);
    let mut file = File::create(path).with_context(|| "Failed to create feature config")?;

    file.write_all(&FEATURE_MAGIC.to_le_bytes())
        .with_context(|| "Failed to write magic")?;

    file.write_all(&FEATURE_VERSION.to_le_bytes())
        .with_context(|| "Failed to write version")?;

    let count = features.len() as u32;
    file.write_all(&count.to_le_bytes())
        .with_context(|| "Failed to write count")?;

    for (&id, &value) in features {
        file.write_all(&id.to_le_bytes())
            .with_context(|| format!("Failed to write feature id {id}"))?;
        file.write_all(&value.to_le_bytes())
            .with_context(|| format!("Failed to write feature value for id {id}"))?;
    }

    file.sync_all()
        .with_context(|| "Failed to sync feature config")?;

    log::info!("Saved {} features to config", features.len());
    Ok(())
}

pub fn apply_config(features: &HashMap<u32, u64>) {
    log::info!("Applying feature configuration to kernel...");

    let mut applied = 0;
    for (&id, &value) in features {
        match crate::ksucalls::set_feature(id, value) {
            Ok(()) => {
                if let Some(feature_id) = FeatureId::from_u32(id) {
                    log::info!("Set feature {} to {value}", feature_id.name());
                } else {
                    log::info!("Set feature {id} to {value}");
                }
                applied += 1;
            }
            Err(e) => {
                log::warn!("Failed to set feature {id}: {e}");
            }
        }
    }

    log::info!("Applied {applied} features successfully");
}

pub fn get_feature(id: &str) -> Result<()> {
    let feature_id = parse_feature_id(id)?;
    let (value, supported) = crate::ksucalls::get_feature(feature_id as u32)
        .with_context(|| format!("Failed to get feature {id}"))?;

    if !supported {
        println!("Feature '{id}' is not supported by kernel");
        return Ok(());
    }

    println!("Feature: {} ({})", feature_id.name(), feature_id as u32);
    println!("Description: {}", feature_id.description());
    println!("Value: {value}");
    println!(
        "Status: {}",
        if value != 0 { "enabled" } else { "disabled" }
    );

    Ok(())
}

pub fn get_feature_config(id: &str) -> Result<()> {
    let feature_id = parse_feature_id(id)?;

    let features = load_binary_config()?;
    let id_u32 = feature_id as u32;

    println!("Feature: {} ({})", feature_id.name(), id_u32);
    println!("Description: {}", feature_id.description());

    if let Some(value) = features.get(&id_u32) {
        println!("Value: {value}");
        println!(
            "Status: {}",
            if *value != 0 { "enabled" } else { "disabled" }
        );
    } else {
        println!("Not set in config");
    }

    Ok(())
}

pub fn set_feature(id: &str, value: u64) -> Result<()> {
    let feature_id = parse_feature_id(id)?;

    // Check if this feature is managed by any module
    if let Ok(managed_features_map) = crate::module::get_managed_features() {
        // Find which modules manage this feature
        let managing_modules: Vec<&String> = managed_features_map
            .iter()
            .filter(|(_, features)| features.iter().any(|f| f == feature_id.name()))
            .map(|(module_id, _)| module_id)
            .collect();

        if !managing_modules.is_empty() {
            // Feature is managed, check if caller is an authorized module
            let caller_module = std::env::var("KSU_MODULE").unwrap_or_default();

            if caller_module.is_empty() || !managing_modules.contains(&&caller_module) {
                bail!(
                    "Feature '{}' is managed by module(s): {}. Direct modification is not allowed.",
                    feature_id.name(),
                    managing_modules
                        .iter()
                        .map(|s| s.as_str())
                        .collect::<Vec<_>>()
                        .join(", ")
                );
            }

            log::info!(
                "Module '{caller_module}' is setting managed feature '{}'",
                feature_id.name()
            );
        }
    }

    crate::ksucalls::set_feature(feature_id as u32, value)
        .with_context(|| format!("Failed to set feature {id} to {value}"))?;

    println!(
        "Feature '{}' set to {value} ({})",
        feature_id.name(),
        if value != 0 { "enabled" } else { "disabled" }
    );

    Ok(())
}

pub fn list_features() {
    println!("Available Features:");
    println!("{}", "=".repeat(80));

    // Get managed features from modules
    let managed_features_map = crate::module::get_managed_features().unwrap_or_default();

    // Build a reverse map: feature_name -> Vec<module_id>
    let mut feature_to_modules: HashMap<String, Vec<String>> = HashMap::new();
    for (module_id, feature_list) in &managed_features_map {
        for feature_name in feature_list {
            feature_to_modules
                .entry(feature_name.clone())
                .or_default()
                .push(module_id.clone());
        }
    }

    let all_features = [FeatureId::SuCompat, FeatureId::KernelUmount];

    for feature_id in &all_features {
        let id = *feature_id as u32;
        let (value, supported) = crate::ksucalls::get_feature(id).unwrap_or((0, false));

        let status = if !supported {
            "NOT_SUPPORTED".to_string()
        } else if value != 0 {
            format!("ENABLED ({value})")
        } else {
            "DISABLED".to_string()
        };

        let managed_by = feature_to_modules.get(feature_id.name());
        let managed_mark = if managed_by.is_some() {
            " [MODULE_MANAGED]"
        } else {
            ""
        };

        println!(
            "[{}] {} (ID={}){}",
            status,
            feature_id.name(),
            id,
            managed_mark
        );
        println!("    {}", feature_id.description());

        if let Some(modules) = managed_by {
            println!(
                "    ⚠️  Managed by module(s): {} (forced to 0 on initialization)",
                modules.join(", ")
            );
        }

        println!();
    }
}

pub fn load_config_and_apply() -> Result<()> {
    let features = load_binary_config()?;

    if features.is_empty() {
        println!("No features found in config file");
        return Ok(());
    }

    apply_config(&features);
    println!("Feature configuration loaded and applied");
    Ok(())
}

pub fn save_config() -> Result<()> {
    let mut features = HashMap::new();

    let all_features = [FeatureId::SuCompat, FeatureId::KernelUmount];

    for feature_id in &all_features {
        let id = *feature_id as u32;
        if let Ok((value, supported)) = crate::ksucalls::get_feature(id)
            && supported
        {
            features.insert(id, value);
            log::info!("Saved feature {} = {value}", feature_id.name());
        }
    }

    save_binary_config(&features)?;
    println!(
        "Current feature states saved to config file ({} features)",
        features.len()
    );
    Ok(())
}

pub fn check_feature(id: &str) -> Result<()> {
    let feature_id = parse_feature_id(id)?;

    // Check if this feature is managed by any module
    let managed_features_map = crate::module::get_managed_features().unwrap_or_default();
    let is_managed = managed_features_map
        .values()
        .any(|features| features.iter().any(|f| f == feature_id.name()));

    if is_managed {
        println!("managed");
        return Ok(());
    }

    // Check if the feature is supported by kernel
    let (_value, supported) = crate::ksucalls::get_feature(feature_id as u32)
        .with_context(|| format!("Failed to get feature {id}"))?;

    if supported {
        println!("supported");
    } else {
        println!("unsupported");
    }

    Ok(())
}

pub fn init_features() -> Result<()> {
    log::info!("Initializing features from config...");

    let mut features = load_binary_config()?;

    // Get managed features from active modules and skip them during init
    if let Ok(managed_features_map) = crate::module::get_managed_features() {
        if !managed_features_map.is_empty() {
            log::info!(
                "Found {} modules managing features",
                managed_features_map.len()
            );

            // Build a set of all managed feature IDs to skip
            for (module_id, feature_list) in &managed_features_map {
                log::info!(
                    "Module '{module_id}' manages {} feature(s)",
                    feature_list.len()
                );

                for feature_name in feature_list {
                    if let Ok(feature_id) = parse_feature_id(feature_name) {
                        let feature_id_u32 = feature_id as u32;
                        // Remove managed features from config, let modules control them
                        if features.remove(&feature_id_u32).is_some() {
                            log::info!(
                                "  - Skipping managed feature '{feature_name}' (controlled by module: {module_id})",
                            );
                        } else {
                            log::info!(
                                "  - Feature '{feature_name}' is managed by module '{module_id}', skipping",
                            );
                        }
                    } else {
                        log::warn!(
                            "  - Unknown managed feature '{feature_name}' from module '{module_id}', ignoring",
                        );
                    }
                }
            }
        }
    } else {
        log::warn!(
            "Failed to get managed features from modules, continuing with normal initialization"
        );
    }

    if features.is_empty() {
        log::info!("No features to apply, skipping initialization");
        return Ok(());
    }

    apply_config(&features);

    // Save the configuration (excluding managed features)
    save_binary_config(&features)?;
    log::info!("Saved feature configuration to file");

    Ok(())
}

```

`userspace/ksud/src/init_event.rs`:

```rs
use anyhow::{Context, Result};
use log::{info, warn};
use std::path::Path;

use crate::module::{handle_updated_modules, prune_modules};
use crate::utils::is_safe_mode;
use crate::{
    assets, defs, ksucalls, metamodule, restorecon,
    utils::{self},
};

pub fn on_post_data_fs() -> Result<()> {
    ksucalls::report_post_fs_data();

    utils::umask(0);

    // Clear all temporary module configs early
    if let Err(e) = crate::module_config::clear_all_temp_configs() {
        warn!("clear temp configs failed: {e}");
    }

    #[cfg(unix)]
    let _ = catch_bootlog("logcat", &["logcat", "-b", "all"]);
    #[cfg(unix)]
    let _ = catch_bootlog("dmesg", &["dmesg", "-w", "-r"]);

    if utils::has_magisk() {
        warn!("Magisk detected, skip post-fs-data!");
        return Ok(());
    }

    let safe_mode = crate::utils::is_safe_mode();

    if safe_mode {
        // we should still ensure module directory exists in safe mode
        // because we may need to operate the module dir in safe mode
        warn!("safe mode, skip common post-fs-data.d scripts");
    } else {
        // Then exec common post-fs-data scripts
        if let Err(e) = crate::module::exec_common_scripts("post-fs-data.d", true) {
            warn!("exec common post-fs-data scripts failed: {e}");
        }
    }

    let module_dir = defs::MODULE_DIR;

    assets::ensure_binaries(true).with_context(|| "Failed to extract bin assets")?;

    // if we are in safe mode, we should disable all modules
    if safe_mode {
        warn!("safe mode, skip post-fs-data scripts and disable all modules!");
        if let Err(e) = crate::module::disable_all_modules() {
            warn!("disable all modules failed: {e}");
        }
        return Ok(());
    }

    if let Err(e) = handle_updated_modules() {
        warn!("handle updated modules failed: {e}");
    }

    if let Err(e) = prune_modules() {
        warn!("prune modules failed: {e}");
    }

    if let Err(e) = restorecon::restorecon() {
        warn!("restorecon failed: {e}");
    }

    // load sepolicy.rule
    if crate::module::load_sepolicy_rule().is_err() {
        warn!("load sepolicy.rule failed");
    }

    if let Err(e) = crate::profile::apply_sepolies() {
        warn!("apply root profile sepolicy failed: {e}");
    }

    // load feature config
    if is_safe_mode() {
        warn!("safe mode, skip load feature config");
    } else if let Err(e) = crate::feature::init_features() {
        warn!("init features failed: {e}");
    }

    // execute metamodule post-fs-data script first (priority)
    if let Err(e) = metamodule::exec_stage_script("post-fs-data", true) {
        warn!("exec metamodule post-fs-data script failed: {e}");
    }

    // exec modules post-fs-data scripts
    // TODO: Add timeout
    if let Err(e) = crate::module::exec_stage_script("post-fs-data", true) {
        warn!("exec post-fs-data scripts failed: {e}");
    }

    // load system.prop
    if let Err(e) = crate::module::load_system_prop() {
        warn!("load system.prop failed: {e}");
    }

    // execute metamodule mount script
    if let Err(e) = metamodule::exec_mount_script(module_dir) {
        warn!("execute metamodule mount failed: {e}");
    }

    run_stage("post-mount", true);

    std::env::set_current_dir("/").with_context(|| "failed to chdir to /")?;

    Ok(())
}

fn run_stage(stage: &str, block: bool) {
    utils::umask(0);

    if utils::has_magisk() {
        warn!("Magisk detected, skip {stage}");
        return;
    }

    if crate::utils::is_safe_mode() {
        warn!("safe mode, skip {stage} scripts");
        return;
    }

    if let Err(e) = crate::module::exec_common_scripts(&format!("{stage}.d"), block) {
        warn!("Failed to exec common {stage} scripts: {e}");
    }

    // execute metamodule stage script first (priority)
    if let Err(e) = metamodule::exec_stage_script(stage, block) {
        warn!("Failed to exec metamodule {stage} script: {e}");
    }

    // execute regular modules stage scripts
    if let Err(e) = crate::module::exec_stage_script(stage, block) {
        warn!("Failed to exec {stage} scripts: {e}");
    }
}

pub fn on_services() {
    info!("on_services triggered!");
    run_stage("service", false);
}

pub fn on_boot_completed() {
    ksucalls::report_boot_complete();
    info!("on_boot_completed triggered!");

    run_stage("boot-completed", false);
}

#[cfg(unix)]
fn catch_bootlog(logname: &str, command: &[&str]) -> Result<()> {
    use std::os::unix::process::CommandExt;
    use std::process::Stdio;

    let logdir = Path::new(defs::LOG_DIR);
    utils::ensure_dir_exists(logdir)?;
    let bootlog = logdir.join(format!("{logname}.log"));
    let oldbootlog = logdir.join(format!("{logname}.old.log"));

    if bootlog.exists() {
        std::fs::rename(&bootlog, oldbootlog)?;
    }

    let bootlog = std::fs::File::create(bootlog)?;

    let mut args = vec!["-s", "9", "30s"];
    args.extend_from_slice(command);
    // timeout -s 9 30s logcat > boot.log
    let result = unsafe {
        std::process::Command::new("timeout")
            .process_group(0)
            .pre_exec(|| {
                utils::switch_cgroups();
                Ok(())
            })
            .args(args)
            .stdout(Stdio::from(bootlog))
            .spawn()
    };

    if let Err(e) = result {
        warn!("Failed to start logcat: {e:#}");
    }

    Ok(())
}

```

`userspace/ksud/src/installer.sh`:

```sh
#!/system/bin/sh
############################################
# KernelSU installer script
# mostly from module_installer.sh
# and util_functions.sh in Magisk
############################################

umask 022

ui_print() {
  if $BOOTMODE; then
    echo "$1"
  else
    echo -e "ui_print $1\nui_print" >> /proc/self/fd/$OUTFD
  fi
}

toupper() {
  echo "$@" | tr '[:lower:]' '[:upper:]'
}

grep_cmdline() {
  local REGEX="s/^$1=//p"
  { echo $(cat /proc/cmdline)$(sed -e 's/[^"]//g' -e 's/""//g' /proc/cmdline) | xargs -n 1; \
    sed -e 's/ = /=/g' -e 's/, /,/g' -e 's/"//g' /proc/bootconfig; \
  } 2>/dev/null | sed -n "$REGEX"
}

grep_prop() {
  local REGEX="s/$1=//p"
  shift
  local FILES=$@
  [ -z "$FILES" ] && FILES='/system/build.prop'
  cat $FILES 2>/dev/null | dos2unix | sed -n "$REGEX" | head -n 1 | xargs
}

grep_get_prop() {
  local result=$(grep_prop $@)
  if [ -z "$result" ]; then
    # Fallback to getprop
    getprop "$1"
  else
    echo $result
  fi
}

is_mounted() {
  grep -q " $(readlink -f $1) " /proc/mounts 2>/dev/null
  return $?
}

abort() {
  ui_print "$1"
  $BOOTMODE || recovery_cleanup
  [ ! -z $MODPATH ] && rm -rf $MODPATH
  rm -rf $TMPDIR
  exit 1
}

print_title() {
  local len line1len line2len bar
  line1len=$(echo -n $1 | wc -c)
  line2len=$(echo -n $2 | wc -c)
  len=$line2len
  [ $line1len -gt $line2len ] && len=$line1len
  len=$((len + 2))
  bar=$(printf "%${len}s" | tr ' ' '*')
  ui_print "$bar"
  ui_print " $1 "
  [ "$2" ] && ui_print " $2 "
  ui_print "$bar"
}

check_sepolicy() {
    /data/adb/ksud sepolicy check "$1"
    return $?
}

######################
# Environment Related
######################

setup_flashable() {
  ensure_bb
  $BOOTMODE && return
  if [ -z $OUTFD ] || readlink /proc/$$/fd/$OUTFD | grep -q /tmp; then
    # We will have to manually find out OUTFD
    for FD in `ls /proc/$$/fd`; do
      if readlink /proc/$$/fd/$FD | grep -q pipe; then
        if ps | grep -v grep | grep -qE " 3 $FD |status_fd=$FD"; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  recovery_actions
}

ensure_bb() {
  :
}

recovery_actions() {
  :
}

recovery_cleanup() {
  :
}

#######################
# Installation Related
#######################

# find_block [partname...]
find_block() {
  local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
  for BLOCK in "$@"; do
    DEVICE=`find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK | head -n 1` 2>/dev/null
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done
  # Fallback by parsing sysfs uevents
  for UEVENT in /sys/dev/block/*/uevent; do
    DEVNAME=`grep_prop DEVNAME $UEVENT`
    PARTNAME=`grep_prop PARTNAME $UEVENT`
    for BLOCK in "$@"; do
      if [ "$(toupper $BLOCK)" = "$(toupper $PARTNAME)" ]; then
        echo /dev/block/$DEVNAME
        return 0
      fi
    done
  done
  # Look just in /dev in case we're dealing with MTD/NAND without /dev/block devices/links
  for DEV in "$@"; do
    DEVICE=`find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV | head -n 1` 2>/dev/null
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done
  return 1
}

# setup_mntpoint <mountpoint>
setup_mntpoint() {
  local POINT=$1
  [ -L $POINT ] && mv -f $POINT ${POINT}_link
  if [ ! -d $POINT ]; then
    rm -f $POINT
    mkdir -p $POINT
  fi
}

# mount_name <partname(s)> <mountpoint> <flag>
mount_name() {
  local PART=$1
  local POINT=$2
  local FLAG=$3
  setup_mntpoint $POINT
  is_mounted $POINT && return
  # First try mounting with fstab
  mount $FLAG $POINT 2>/dev/null
  if ! is_mounted $POINT; then
    local BLOCK=$(find_block $PART)
    mount $FLAG $BLOCK $POINT || return
  fi
  ui_print "- Mounting $POINT"
}

# mount_ro_ensure <partname(s)> <mountpoint>
mount_ro_ensure() {
  # We handle ro partitions only in recovery
  $BOOTMODE && return
  local PART=$1
  local POINT=$2
  mount_name "$PART" $POINT '-o ro'
  is_mounted $POINT || abort "! Cannot mount $POINT"
}

mount_partitions() {
  # Check A/B slot
  SLOT=`grep_cmdline androidboot.slot_suffix`
  if [ -z $SLOT ]; then
    SLOT=`grep_cmdline androidboot.slot`
    [ -z $SLOT ] || SLOT=_${SLOT}
  fi
  [ -z $SLOT ] || ui_print "- Current boot slot: $SLOT"

  # Mount ro partitions
  if is_mounted /system_root; then
    umount /system 2&>/dev/null
    umount /system_root 2&>/dev/null
  fi
  mount_ro_ensure "system$SLOT app$SLOT" /system
  if [ -f /system/init -o -L /system/init ]; then
    SYSTEM_ROOT=true
    setup_mntpoint /system_root
    if ! mount --move /system /system_root; then
      umount /system
      umount -l /system 2>/dev/null
      mount_ro_ensure "system$SLOT app$SLOT" /system_root
    fi
    mount -o bind /system_root/system /system
  else
    SYSTEM_ROOT=false
    grep ' / ' /proc/mounts | grep -qv 'rootfs' || grep -q ' /system_root ' /proc/mounts && SYSTEM_ROOT=true
  fi
  # /vendor is used only on some older devices for recovery AVBv1 signing so is not critical if fails
  [ -L /system/vendor ] && mount_name vendor$SLOT /vendor '-o ro'
  $SYSTEM_ROOT && ui_print "- Device is system-as-root"

  # Mount sepolicy rules dir locations in recovery (best effort)
  if ! $BOOTMODE; then
    mount_name "cache cac" /cache
    mount_name metadata /metadata
    mount_name persist /persist
  fi
}

api_level_arch_detect() {
  API=$(grep_get_prop ro.build.version.sdk)
  ABI=$(grep_get_prop ro.product.cpu.abi)
  if [ "$ABI" = "x86" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ "$ABI" = "arm64-v8a" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ "$ABI" = "x86_64" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi
}

#################
# Module Related
#################

check_managed_features() {
  local PROP_FILE=$1
  local MANAGED_FEATURES=$(grep_prop managedFeatures "$PROP_FILE")

  [ -z "$MANAGED_FEATURES" ] && return 0

  ui_print "- Checking managed features: $MANAGED_FEATURES"

  # Split features by comma
  echo "$MANAGED_FEATURES" | tr ',' '\n' | while read -r feature; do
    # Trim whitespace
    feature=$(echo "$feature" | xargs)
    [ -z "$feature" ] && continue

    # Check feature status using ksud
    local status=$(/data/adb/ksud feature check "$feature" 2>/dev/null)

    case "$status" in
      "unsupported")
        ui_print "! WARNING: Feature '$feature' is NOT SUPPORTED by kernel"
        ui_print "!          This module may not work correctly!"
        ;;
      "managed")
        ui_print "! WARNING: Feature '$feature' is already MANAGED by another module"
        ui_print "!          Feature conflicts may occur!"
        ;;
      "supported")
        ui_print "- Feature '$feature' is supported and available"
        ;;
      *)
        ui_print "! WARNING: Unable to check feature '$feature' status"
        ;;
    esac
  done
}

set_perm() {
  chown $2:$3 $1 || return 1
  chmod $4 $1 || return 1
  local CON=$5
  [ -z $CON ] && CON=u:object_r:system_file:s0
  chcon $CON $1 || return 1
}

set_perm_recursive() {
  find $1 -type d 2>/dev/null | while read dir; do
    set_perm $dir $2 $3 $4 $6
  done
  find $1 -type f -o -type l 2>/dev/null | while read file; do
    set_perm $file $2 $3 $5 $6
  done
}

mktouch() {
  mkdir -p ${1%/*} 2>/dev/null
  [ -z $2 ] && touch $1 || echo $2 > $1
  chmod 644 $1
}

mark_remove() {
  mkdir -p ${1%/*} 2>/dev/null
  mknod $1 c 0 0
  chmod 644 $1
}

request_size_check() {
  reqSizeM=`du -ms "$1" | cut -f1`
}

request_zip_size_check() {
  reqSizeM=`unzip -l "$1" | tail -n 1 | awk '{ print int(($1 - 1) / 1048576 + 1) }'`
}

boot_actions() { return; }

# Require ZIPFILE to be set
is_legacy_script() {
  unzip -l "$ZIPFILE" install.sh | grep -q install.sh
  return $?
}

handle_partition() {
    # if /system/vendor is a symlink, we need to move it out of $MODPATH/system
    # if /system/vendor is a normal directory, no special handling is needed.
    if [ ! -e $MODPATH/system/$1 ]; then
        # no partition found
        return;
    fi

    # we move the folder to / only if it is a native folder that is not a symlink
    if [ -d "/$1" ] && [ ! -L "/$1" ]; then
        ui_print "- Handle partition /$1"
        # we create a symlink if module want to access $MODPATH/system/$1
        # but it doesn't always work(ie. write it in post-fs-data.sh would fail because it is readonly)
        mv -f $MODPATH/system/$1 $MODPATH/$1 && ln -sf ../$1 $MODPATH/system/$1
    fi
}

# Require OUTFD, ZIPFILE to be set
install_module() {
  rm -rf $TMPDIR
  mkdir -p $TMPDIR
  chcon u:object_r:system_file:s0 $TMPDIR
  cd $TMPDIR

  mount_partitions
  api_level_arch_detect

  # Setup busybox and binaries
  if $BOOTMODE; then
    boot_actions
  else
    recovery_actions
  fi

  # Extract prop file
  unzip -o "$ZIPFILE" module.prop -d $TMPDIR >&2
  [ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"

  local MODDIRNAME=modules
  $BOOTMODE && MODDIRNAME=modules_update
  local MODULEROOT=$NVBASE/$MODDIRNAME
  MODID=`grep_prop id $TMPDIR/module.prop`
  MODNAME=`grep_prop name $TMPDIR/module.prop`
  MODAUTH=`grep_prop author $TMPDIR/module.prop`
  MODPATH=$MODULEROOT/$MODID

  # Check managed features
  check_managed_features $TMPDIR/module.prop

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH

  if is_legacy_script; then
    unzip -oj "$ZIPFILE" module.prop install.sh uninstall.sh 'common/*' -d $TMPDIR >&2

    # Load install script
    . $TMPDIR/install.sh

    # Callbacks
    print_modname
    on_install

    [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh
    $SKIPMOUNT && touch $MODPATH/skip_mount
    $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop
    cp -af $TMPDIR/module.prop $MODPATH/module.prop
    $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh
    $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

    ui_print "- Setting permissions"
    set_permissions
  else
    print_title "$MODNAME" "by $MODAUTH"
    print_title "Powered by KernelSU"

    unzip -o "$ZIPFILE" customize.sh -d $MODPATH >&2

    if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
      ui_print "- Extracting module files"
      unzip -o "$ZIPFILE" -x 'META-INF/*' -d $MODPATH >&2

      # Default permissions
      set_perm_recursive $MODPATH 0 0 0755 0644
      set_perm_recursive $MODPATH/system/bin 0 2000 0755 0755
      set_perm_recursive $MODPATH/system/xbin 0 2000 0755 0755
      set_perm_recursive $MODPATH/system/system_ext/bin 0 2000 0755 0755
      set_perm_recursive $MODPATH/system/vendor 0 2000 0755 0755 u:object_r:vendor_file:s0
    fi

    # Load customization script
    [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
  fi

  # Handle replace folders
  for TARGET in $REPLACE; do
    ui_print "- Replace target: $TARGET"
    mark_replace $MODPATH$TARGET
  done

  # Handle remove files
  for TARGET in $REMOVE; do
    ui_print "- Remove target: $TARGET"
    mark_remove $MODPATH$TARGET
  done

  handle_partition vendor
  handle_partition system_ext
  handle_partition product
  handle_partition odm

  if $BOOTMODE; then
    mktouch $NVBASE/modules/$MODID/update
    rm -rf $NVBASE/modules/$MODID/remove 2>/dev/null
    rm -rf $NVBASE/modules/$MODID/disable 2>/dev/null
    cp -af $MODPATH/module.prop $NVBASE/modules/$MODID/module.prop
  fi

  # Remove stuff that doesn't belong to modules and clean up any empty directories
  rm -rf \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rmdir -p $MODPATH 2>/dev/null

  cd /
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

  ui_print "- Done"
}

##########
# Presets
##########

# Detect whether in boot mode
[ -z $BOOTMODE ] && ps | grep zygote | grep -qv grep && BOOTMODE=true
[ -z $BOOTMODE ] && ps -A 2>/dev/null | grep zygote | grep -qv grep && BOOTMODE=true
[ -z $BOOTMODE ] && BOOTMODE=false

NVBASE=/data/adb
TMPDIR=/dev/tmp
POSTFSDATAD=$NVBASE/post-fs-data.d
SERVICED=$NVBASE/service.d

# Some modules dependents on this
export MAGISK_VER=25.2
export MAGISK_VER_CODE=25200

```

`userspace/ksud/src/ksucalls.rs`:

```rs
#![allow(clippy::unreadable_literal)]
use libc::{_IO, _IOR, _IOW, _IOWR};
use std::fs;
use std::os::fd::RawFd;
use std::sync::OnceLock;

// Event constants
const EVENT_POST_FS_DATA: u32 = 1;
const EVENT_BOOT_COMPLETED: u32 = 2;
const EVENT_MODULE_MOUNTED: u32 = 3;

const K: u32 = b'K' as u32;
const KSU_IOCTL_GRANT_ROOT: i32 = _IO(K, 1);
const KSU_IOCTL_GET_INFO: i32 = _IOR::<()>(K, 2);
const KSU_IOCTL_REPORT_EVENT: i32 = _IOW::<()>(K, 3);
const KSU_IOCTL_SET_SEPOLICY: i32 = _IOWR::<()>(K, 4);
const KSU_IOCTL_CHECK_SAFEMODE: i32 = _IOR::<()>(K, 5);
const KSU_IOCTL_GET_FEATURE: i32 = _IOWR::<()>(K, 13);
const KSU_IOCTL_SET_FEATURE: i32 = _IOW::<()>(K, 14);
const KSU_IOCTL_GET_WRAPPER_FD: i32 = _IOW::<()>(K, 15);
const KSU_IOCTL_MANAGE_MARK: i32 = _IOWR::<()>(K, 16);
const KSU_IOCTL_NUKE_EXT4_SYSFS: i32 = _IOW::<()>(K, 17);
const KSU_IOCTL_ADD_TRY_UMOUNT: i32 = _IOW::<()>(K, 18);

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct GetInfoCmd {
    version: u32,
    flags: u32,
}

#[repr(C)]
struct ReportEventCmd {
    event: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct SetSepolicyCmd {
    pub cmd: u64,
    pub arg: u64,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct CheckSafemodeCmd {
    in_safe_mode: u8,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct GetFeatureCmd {
    feature_id: u32,
    value: u64,
    supported: u8,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct SetFeatureCmd {
    feature_id: u32,
    value: u64,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct GetWrapperFdCmd {
    fd: i32,
    flags: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct ManageMarkCmd {
    operation: u32,
    pid: i32,
    result: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct NukeExt4SysfsCmd {
    pub arg: u64,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
struct AddTryUmountCmd {
    arg: u64,   // char ptr, this is the mountpoint
    flags: u32, // this is the flag we use for it
    mode: u8,   // denotes what to do with it 0:wipe_list 1:add_to_list 2:delete_entry
}

// Mark operation constants
const KSU_MARK_GET: u32 = 1;
const KSU_MARK_MARK: u32 = 2;
const KSU_MARK_UNMARK: u32 = 3;
const KSU_MARK_REFRESH: u32 = 4;

// Umount operation constants
const KSU_UMOUNT_WIPE: u8 = 0;
const KSU_UMOUNT_ADD: u8 = 1;
const KSU_UMOUNT_DEL: u8 = 2;

// Global driver fd cache
static DRIVER_FD: OnceLock<RawFd> = OnceLock::new();
static INFO_CACHE: OnceLock<GetInfoCmd> = OnceLock::new();

const KSU_INSTALL_MAGIC1: u32 = 0xDEADBEEF;
const KSU_INSTALL_MAGIC2: u32 = 0xCAFEBABE;

fn scan_driver_fd() -> Option<RawFd> {
    let fd_dir = fs::read_dir("/proc/self/fd").ok()?;

    for entry in fd_dir.flatten() {
        if let Ok(fd_num) = entry.file_name().to_string_lossy().parse::<i32>() {
            let link_path = format!("/proc/self/fd/{fd_num}");
            if let Ok(target) = fs::read_link(&link_path) {
                let target_str = target.to_string_lossy();
                if target_str.contains("[ksu_driver]") {
                    return Some(fd_num);
                }
            }
        }
    }

    None
}

// Get cached driver fd
fn init_driver_fd() -> Option<RawFd> {
    let fd = scan_driver_fd();
    if fd.is_none() {
        let mut fd = -1;
        unsafe {
            libc::syscall(
                libc::SYS_reboot,
                KSU_INSTALL_MAGIC1,
                KSU_INSTALL_MAGIC2,
                0,
                &mut fd,
            );
        };
        if fd >= 0 { Some(fd) } else { None }
    } else {
        fd
    }
}

// ioctl wrapper using libc
fn ksuctl<T>(request: i32, arg: *mut T) -> std::io::Result<i32> {
    use std::io;

    let fd = *DRIVER_FD.get_or_init(|| init_driver_fd().unwrap_or(-1));
    unsafe {
        let ret = libc::ioctl(fd as libc::c_int, request, arg);
        if ret < 0 {
            Err(io::Error::last_os_error())
        } else {
            Ok(ret)
        }
    }
}

// API implementations
fn get_info() -> GetInfoCmd {
    *INFO_CACHE.get_or_init(|| {
        let mut cmd = GetInfoCmd {
            version: 0,
            flags: 0,
        };
        let _ = ksuctl(KSU_IOCTL_GET_INFO, &raw mut cmd);
        cmd
    })
}

pub fn get_version() -> i32 {
    get_info().version as i32
}

pub fn grant_root() -> std::io::Result<()> {
    ksuctl(KSU_IOCTL_GRANT_ROOT, std::ptr::null_mut::<u8>())?;
    Ok(())
}

fn report_event(event: u32) {
    let mut cmd = ReportEventCmd { event };
    let _ = ksuctl(KSU_IOCTL_REPORT_EVENT, &raw mut cmd);
}

pub fn report_post_fs_data() {
    report_event(EVENT_POST_FS_DATA);
}

pub fn report_boot_complete() {
    report_event(EVENT_BOOT_COMPLETED);
}

pub fn report_module_mounted() {
    report_event(EVENT_MODULE_MOUNTED);
}

pub fn check_kernel_safemode() -> bool {
    let mut cmd = CheckSafemodeCmd { in_safe_mode: 0 };
    let _ = ksuctl(KSU_IOCTL_CHECK_SAFEMODE, &raw mut cmd);
    cmd.in_safe_mode != 0
}

pub fn set_sepolicy(cmd: &SetSepolicyCmd) -> std::io::Result<()> {
    let mut ioctl_cmd = *cmd;
    ksuctl(KSU_IOCTL_SET_SEPOLICY, &raw mut ioctl_cmd)?;
    Ok(())
}

/// Get feature value and support status from kernel
/// Returns (value, supported)
pub fn get_feature(feature_id: u32) -> std::io::Result<(u64, bool)> {
    let mut cmd = GetFeatureCmd {
        feature_id,
        value: 0,
        supported: 0,
    };
    ksuctl(KSU_IOCTL_GET_FEATURE, &raw mut cmd)?;
    Ok((cmd.value, cmd.supported != 0))
}

/// Set feature value in kernel
pub fn set_feature(feature_id: u32, value: u64) -> std::io::Result<()> {
    let mut cmd = SetFeatureCmd { feature_id, value };
    ksuctl(KSU_IOCTL_SET_FEATURE, &raw mut cmd)?;
    Ok(())
}

pub fn get_wrapped_fd(fd: RawFd) -> std::io::Result<RawFd> {
    let mut cmd = GetWrapperFdCmd { fd, flags: 0 };
    let result = ksuctl(KSU_IOCTL_GET_WRAPPER_FD, &raw mut cmd)?;
    Ok(result)
}

/// Get mark status for a process (pid=0 returns total marked count)
pub fn mark_get(pid: i32) -> std::io::Result<u32> {
    let mut cmd = ManageMarkCmd {
        operation: KSU_MARK_GET,
        pid,
        result: 0,
    };
    ksuctl(KSU_IOCTL_MANAGE_MARK, &raw mut cmd)?;
    Ok(cmd.result)
}

/// Mark a process (pid=0 marks all processes)
pub fn mark_set(pid: i32) -> std::io::Result<()> {
    let mut cmd = ManageMarkCmd {
        operation: KSU_MARK_MARK,
        pid,
        result: 0,
    };
    ksuctl(KSU_IOCTL_MANAGE_MARK, &raw mut cmd)?;
    Ok(())
}

/// Unmark a process (pid=0 unmarks all processes)
pub fn mark_unset(pid: i32) -> std::io::Result<()> {
    let mut cmd = ManageMarkCmd {
        operation: KSU_MARK_UNMARK,
        pid,
        result: 0,
    };
    ksuctl(KSU_IOCTL_MANAGE_MARK, &raw mut cmd)?;
    Ok(())
}

/// Refresh mark for all running processes
pub fn mark_refresh() -> std::io::Result<()> {
    let mut cmd = ManageMarkCmd {
        operation: KSU_MARK_REFRESH,
        pid: 0,
        result: 0,
    };
    ksuctl(KSU_IOCTL_MANAGE_MARK, &raw mut cmd)?;
    Ok(())
}

pub fn nuke_ext4_sysfs(mnt: &str) -> anyhow::Result<()> {
    let c_mnt = std::ffi::CString::new(mnt)?;
    let mut ioctl_cmd = NukeExt4SysfsCmd {
        arg: c_mnt.as_ptr() as u64,
    };
    ksuctl(KSU_IOCTL_NUKE_EXT4_SYSFS, &raw mut ioctl_cmd)?;
    Ok(())
}

/// Wipe all entries from umount list
pub fn umount_list_wipe() -> std::io::Result<()> {
    let mut cmd = AddTryUmountCmd {
        arg: 0,
        flags: 0,
        mode: KSU_UMOUNT_WIPE,
    };
    ksuctl(KSU_IOCTL_ADD_TRY_UMOUNT, &raw mut cmd)?;
    Ok(())
}

/// Add mount point to umount list
pub fn umount_list_add(path: &str, flags: u32) -> anyhow::Result<()> {
    let c_path = std::ffi::CString::new(path)?;
    let mut cmd = AddTryUmountCmd {
        arg: c_path.as_ptr() as u64,
        flags,
        mode: KSU_UMOUNT_ADD,
    };
    ksuctl(KSU_IOCTL_ADD_TRY_UMOUNT, &raw mut cmd)?;
    Ok(())
}

/// Delete mount point from umount list
pub fn umount_list_del(path: &str) -> anyhow::Result<()> {
    let c_path = std::ffi::CString::new(path)?;
    let mut cmd = AddTryUmountCmd {
        arg: c_path.as_ptr() as u64,
        flags: 0,
        mode: KSU_UMOUNT_DEL,
    };
    ksuctl(KSU_IOCTL_ADD_TRY_UMOUNT, &raw mut cmd)?;
    Ok(())
}

```

`userspace/ksud/src/main.rs`:

```rs
#![deny(clippy::all, clippy::pedantic)]
#![warn(clippy::nursery)]
#![allow(
    clippy::module_name_repetitions,
    clippy::cast_possible_truncation,
    clippy::cast_sign_loss,
    clippy::cast_precision_loss,
    clippy::doc_markdown,
    clippy::too_many_lines,
    clippy::cast_possible_wrap
)]

mod apk_sign;
mod assets;
mod boot_patch;
#[cfg(target_os = "android")]
mod cli;
#[cfg(not(target_os = "android"))]
mod cli_non_android;
#[cfg(target_os = "android")]
mod debug;
mod defs;
#[cfg(target_os = "android")]
mod feature;
#[cfg(target_os = "android")]
mod init_event;
#[cfg(target_os = "android")]
mod ksucalls;
#[cfg(target_os = "android")]
mod metamodule;
#[cfg(target_os = "android")]
mod module;
#[cfg(target_os = "android")]
mod module_config;
#[cfg(target_os = "android")]
mod profile;
#[cfg(target_os = "android")]
mod restorecon;
#[cfg(target_os = "android")]
mod sepolicy;
#[cfg(target_os = "android")]
mod su;
#[cfg(target_os = "android")]
mod utils;

fn main() -> anyhow::Result<()> {
    #[cfg(target_os = "android")]
    {
        cli::run()
    }
    #[cfg(not(target_os = "android"))]
    {
        cli_non_android::run()
    }
}

```

`userspace/ksud/src/metamodule.rs`:

```rs
//! Metamodule management
//!
//! This module handles all metamodule-related functionality.
//! Metamodules are special modules that manage how regular modules are mounted
//! and provide hooks for module installation/uninstallation.

use anyhow::{Context, Result, ensure};
use log::{info, warn};
use std::{
    collections::HashMap,
    path::{Path, PathBuf},
    process::Command,
};

use crate::module::ModuleType::All;
use crate::{assets, defs};

/// Determine whether the provided module properties mark it as a metamodule
pub fn is_metamodule(props: &HashMap<String, String>) -> bool {
    props.get("metamodule").is_some_and(|s| {
        let trimmed = s.trim();
        trimmed == "1" || trimmed.eq_ignore_ascii_case("true")
    })
}

/// Get metamodule path if it exists
/// The metamodule is stored in /data/adb/modules/{id} with a symlink at /data/adb/metamodule
pub fn get_metamodule_path() -> Option<PathBuf> {
    let path = Path::new(defs::METAMODULE_DIR);

    // Check if symlink exists and resolve it
    if path.is_symlink()
        && let Ok(target) = std::fs::read_link(path)
    {
        // If target is relative, resolve it
        let resolved = if target.is_absolute() {
            target
        } else {
            path.parent()?.join(target)
        };

        if resolved.exists() && resolved.is_dir() {
            return Some(resolved);
        }
        warn!(
            "Metamodule symlink points to non-existent path: {}",
            resolved.display()
        );
    }

    // Fallback: search for metamodule=1 in modules directory
    let mut result = None;
    let _ = crate::module::foreach_module(All, |module_path| {
        if let Ok(props) = crate::module::read_module_prop(module_path)
            && is_metamodule(&props)
        {
            info!(
                "Found metamodule in modules directory: {}",
                module_path.display()
            );
            result = Some(module_path.to_path_buf());
        }
        Ok(())
    });

    result
}

/// Check if metamodule exists
pub fn has_metamodule() -> bool {
    get_metamodule_path().is_some()
}

/// Check if it's safe to install a regular module
/// Returns Ok(()) if safe, Err(is_disabled) if blocked
/// - Err(true) means metamodule is disabled
/// - Err(false) means metamodule is in other unstable state
pub fn check_install_safety() -> Result<(), bool> {
    // No metamodule → safe
    let Some(metamodule_path) = get_metamodule_path() else {
        return Ok(());
    };

    // No metainstall.sh → safe (uses default installer)
    // The staged update directory may contain the latest scripts, so check both locations
    let has_metainstall = metamodule_path
        .join(defs::METAMODULE_METAINSTALL_SCRIPT)
        .exists()
        || metamodule_path.file_name().is_some_and(|module_id| {
            Path::new(defs::MODULE_UPDATE_DIR)
                .join(module_id)
                .join(defs::METAMODULE_METAINSTALL_SCRIPT)
                .exists()
        });
    if !has_metainstall {
        return Ok(());
    }

    // Check for marker files
    let has_update = metamodule_path.join(defs::UPDATE_FILE_NAME).exists();
    let has_remove = metamodule_path.join(defs::REMOVE_FILE_NAME).exists();
    let has_disable = metamodule_path.join(defs::DISABLE_FILE_NAME).exists();

    // Stable state (no markers) → safe
    if !has_update && !has_remove && !has_disable {
        return Ok(());
    }

    // Return true if disabled, false for other unstable states
    Err(has_disable && !has_update && !has_remove)
}

/// Create or update the metamodule symlink
/// Points /data/adb/metamodule -> /data/adb/modules/{module_id}
pub fn ensure_symlink(module_path: &Path) -> Result<()> {
    // METAMODULE_DIR might have trailing slash, so we need to trim it
    let symlink_path = Path::new(defs::METAMODULE_DIR.trim_end_matches('/'));

    info!(
        "Creating metamodule symlink: {} -> {}",
        symlink_path.display(),
        module_path.display()
    );

    // Remove existing symlink if it exists
    if symlink_path.exists() || symlink_path.is_symlink() {
        info!("Removing old metamodule symlink/path");
        if symlink_path.is_symlink() {
            std::fs::remove_file(symlink_path).with_context(|| "Failed to remove old symlink")?;
        } else {
            // Could be a directory, remove it
            std::fs::remove_dir_all(symlink_path)
                .with_context(|| "Failed to remove old directory")?;
        }
    }

    // Create symlink
    #[cfg(unix)]
    std::os::unix::fs::symlink(module_path, symlink_path)
        .with_context(|| format!("Failed to create symlink to {}", module_path.display()))?;

    info!("Metamodule symlink created successfully");
    Ok(())
}

/// Remove the metamodule symlink
pub fn remove_symlink() -> Result<()> {
    let symlink_path = Path::new(defs::METAMODULE_DIR.trim_end_matches('/'));

    if symlink_path.is_symlink() {
        std::fs::remove_file(symlink_path)
            .with_context(|| "Failed to remove metamodule symlink")?;
        info!("Metamodule symlink removed");
    }

    Ok(())
}

/// Get the install script content, using metainstall.sh from metamodule if available
/// Returns the script content to be executed
pub fn get_install_script(
    is_metamodule: bool,
    installer_content: &str,
    install_module_script: &str,
) -> Result<String> {
    // Check if there's a metamodule with metainstall.sh
    // Only apply this logic for regular modules (not when installing metamodule itself)
    let install_script = if is_metamodule {
        info!("Installing metamodule, using default installer");
        install_module_script.to_string()
    } else if let Some(metamodule_path) = get_metamodule_path() {
        if metamodule_path.join(defs::DISABLE_FILE_NAME).exists() {
            info!("Metamodule is disabled, using default installer");
            install_module_script.to_string()
        } else {
            let metainstall_path = metamodule_path.join(defs::METAMODULE_METAINSTALL_SCRIPT);

            if metainstall_path.exists() {
                info!("Using metainstall.sh from metamodule");
                let metamodule_content = std::fs::read_to_string(&metainstall_path)
                    .with_context(|| "Failed to read metamodule metainstall.sh")?;
                format!("{installer_content}\n{metamodule_content}\nexit 0\n")
            } else {
                info!("Metamodule exists but has no metainstall.sh, using default installer");
                install_module_script.to_string()
            }
        }
    } else {
        info!("No metamodule found, using default installer");
        install_module_script.to_string()
    };

    Ok(install_script)
}

/// Check if metamodule script exists and is ready to execute
/// Returns None if metamodule doesn't exist, is disabled, or script is missing
/// Returns Some(script_path) if script is ready to execute
fn check_metamodule_script(script_name: &str) -> Option<PathBuf> {
    // Check if metamodule exists
    let metamodule_path = get_metamodule_path()?;

    // Check if metamodule is disabled
    if metamodule_path.join(defs::DISABLE_FILE_NAME).exists() {
        info!("Metamodule is disabled, skipping {script_name}");
        return None;
    }

    // Check if script exists
    let script_path = metamodule_path.join(script_name);
    if !script_path.exists() {
        return None;
    }

    Some(script_path)
}

/// Execute metamodule's metauninstall.sh for a specific module
pub fn exec_metauninstall_script(module_id: &str) -> Result<()> {
    let Some(metauninstall_path) = check_metamodule_script(defs::METAMODULE_METAUNINSTALL_SCRIPT)
    else {
        return Ok(());
    };

    info!("Executing metamodule metauninstall.sh for module: {module_id}",);

    let result = Command::new(assets::BUSYBOX_PATH)
        .args(["sh", metauninstall_path.to_str().unwrap()])
        .current_dir(metauninstall_path.parent().unwrap())
        .envs(crate::module::get_common_script_envs())
        .env("MODULE_ID", module_id)
        .status()?;

    ensure!(
        result.success(),
        "Metamodule metauninstall.sh failed for module {module_id}: {result:?}"
    );

    info!("Metamodule metauninstall.sh executed successfully for {module_id}",);
    Ok(())
}

/// Execute metamodule mount script
pub fn exec_mount_script(module_dir: &str) -> Result<()> {
    let Some(mount_script) = check_metamodule_script(defs::METAMODULE_MOUNT_SCRIPT) else {
        return Ok(());
    };

    info!("Executing mount script for metamodule");

    let result = Command::new(assets::BUSYBOX_PATH)
        .args(["sh", mount_script.to_str().unwrap()])
        .envs(crate::module::get_common_script_envs())
        .env("MODULE_DIR", module_dir)
        .status()?;

    ensure!(
        result.success(),
        "Metamodule mount script failed with status: {result:?}"
    );

    info!("Metamodule mount script executed successfully");
    Ok(())
}

/// Execute metamodule script for a specific stage
pub fn exec_stage_script(stage: &str, block: bool) -> Result<()> {
    let Some(script_path) = check_metamodule_script(&format!("{stage}.sh")) else {
        return Ok(());
    };

    info!("Executing metamodule {stage}.sh");
    crate::module::exec_script(&script_path, block)?;
    info!("Metamodule {stage}.sh executed successfully");
    Ok(())
}

```

`userspace/ksud/src/module.rs`:

```rs
#[allow(clippy::wildcard_imports)]
use crate::utils::*;
use crate::{
    assets, defs, ksucalls, metamodule,
    restorecon::{restore_syscon, setsyscon},
    sepolicy,
};

use anyhow::{Context, Result, anyhow, bail, ensure};
use const_format::concatcp;
use is_executable::is_executable;
use java_properties::PropertiesIter;
use log::{debug, info, warn};
use regex_lite::Regex;

use std::fs::{copy, rename};
use std::{
    collections::HashMap,
    env::var as env_var,
    fs::{File, Permissions, canonicalize, remove_dir_all, set_permissions},
    io::Cursor,
    path::{Path, PathBuf},
    process::Command,
    str::FromStr,
};
use zip_extensions::inflate::zip_extract::zip_extract_file_to_memory;

use crate::defs::{MODULE_DIR, MODULE_UPDATE_DIR, UPDATE_FILE_NAME};
use crate::module::ModuleType::{Active, All};
#[cfg(unix)]
use std::os::unix::{prelude::PermissionsExt, process::CommandExt};

const INSTALLER_CONTENT: &str = include_str!("./installer.sh");
const INSTALL_MODULE_SCRIPT: &str = concatcp!(
    INSTALLER_CONTENT,
    "\n",
    "install_module",
    "\n",
    "exit 0",
    "\n"
);

/// Validate module_id format and security
/// Module ID must match: ^[a-zA-Z][a-zA-Z0-9._-]+$
/// - Must start with a letter (a-zA-Z)
/// - Followed by one or more alphanumeric, dot, underscore, or hyphen characters
/// - Minimum length: 2 characters
pub fn validate_module_id(module_id: &str) -> Result<()> {
    let re = Regex::new(r"^[a-zA-Z][a-zA-Z0-9._-]+$")?;
    if re.is_match(module_id) {
        Ok(())
    } else {
        Err(anyhow!(
            "Invalid module ID: '{module_id}'. Must match /^[a-zA-Z][a-zA-Z0-9._-]+$/"
        ))
    }
}

/// Get common environment variables for script execution
pub fn get_common_script_envs() -> Vec<(&'static str, String)> {
    vec![
        ("ASH_STANDALONE", "1".to_string()),
        ("KSU", "true".to_string()),
        ("KSU_KERNEL_VER_CODE", ksucalls::get_version().to_string()),
        ("KSU_VER_CODE", defs::VERSION_CODE.to_string()),
        ("KSU_VER", defs::VERSION_NAME.to_string()),
        (
            "PATH",
            format!(
                "{}:{}",
                env_var("PATH").unwrap_or_default(),
                defs::BINARY_DIR.trim_end_matches('/')
            ),
        ),
    ]
}

fn exec_install_script(module_file: &str, is_metamodule: bool) -> Result<()> {
    let realpath = std::fs::canonicalize(module_file)
        .with_context(|| format!("realpath: {module_file} failed"))?;

    // Get install script from metamodule module
    let install_script =
        metamodule::get_install_script(is_metamodule, INSTALLER_CONTENT, INSTALL_MODULE_SCRIPT)?;

    let result = Command::new(assets::BUSYBOX_PATH)
        .args(["sh", "-c", &install_script])
        .envs(get_common_script_envs())
        .env("OUTFD", "1")
        .env("ZIPFILE", realpath)
        .status()?;
    ensure!(result.success(), "Failed to install module script");
    Ok(())
}

// Check if Android boot is completed before installing modules
fn ensure_boot_completed() -> Result<()> {
    // ensure getprop sys.boot_completed == 1
    if getprop("sys.boot_completed").as_deref() != Some("1") {
        bail!("Android is Booting!");
    }
    Ok(())
}

#[derive(PartialEq, Eq)]
pub enum ModuleType {
    All,
    Active,
    Updated,
}

#[allow(clippy::needless_pass_by_value)]
pub fn foreach_module(
    module_type: ModuleType,
    mut f: impl FnMut(&Path) -> Result<()>,
) -> Result<()> {
    let modules_dir = Path::new(match module_type {
        ModuleType::Updated => MODULE_UPDATE_DIR,
        _ => defs::MODULE_DIR,
    });
    let dir = std::fs::read_dir(modules_dir)?;
    for entry in dir.flatten() {
        let path = entry.path();
        if !path.is_dir() {
            warn!("{} is not a directory, skip", path.display());
            continue;
        }

        if module_type == Active && path.join(defs::DISABLE_FILE_NAME).exists() {
            info!("{} is disabled, skip", path.display());
            continue;
        }
        if module_type == Active && path.join(defs::REMOVE_FILE_NAME).exists() {
            warn!("{} is removed, skip", path.display());
            continue;
        }

        f(&path)?;
    }

    Ok(())
}

fn foreach_active_module(f: impl FnMut(&Path) -> Result<()>) -> Result<()> {
    foreach_module(Active, f)
}

pub fn load_sepolicy_rule() -> Result<()> {
    foreach_active_module(|path| {
        let rule_file = path.join("sepolicy.rule");
        if !rule_file.exists() {
            return Ok(());
        }
        info!("load policy: {}", &rule_file.display());

        if sepolicy::apply_file(&rule_file).is_err() {
            warn!("Failed to load sepolicy.rule for {}", &rule_file.display());
        }
        Ok(())
    })?;

    Ok(())
}

pub fn exec_script<T: AsRef<Path>>(path: T, wait: bool) -> Result<()> {
    info!("exec {}", path.as_ref().display());

    let is_module_script = path.as_ref().starts_with(defs::MODULE_DIR);
    // Extract module_id from path if it matches /data/adb/modules/{id}/...
    let module_id = if is_module_script {
        path.as_ref()
            .strip_prefix(defs::MODULE_DIR)
            .ok()
            .and_then(|p| p.components().next())
            .and_then(|c| c.as_os_str().to_str())
            .map(ToString::to_string)
    } else {
        None
    };

    // Validate and log module_id extraction
    let validated_module_id = module_id
        .as_ref()
        .and_then(|id| match validate_module_id(id) {
            Ok(()) => {
                debug!("Module ID extracted from script path: '{id}'");
                Some(id.as_str())
            }
            Err(e) => {
                warn!(
                    "Invalid module ID '{id}' extracted from script path '{}': {e}",
                    path.as_ref().display(),
                );
                None
            }
        });

    if is_module_script && module_id.is_none() {
        debug!(
            "Failed to extract module_id from script path '{}'. Script will run without KSU_MODULE environment variable.",
            path.as_ref().display()
        );
    }

    let mut command = &mut Command::new(assets::BUSYBOX_PATH);
    #[cfg(unix)]
    {
        command = command.process_group(0);
        command = unsafe {
            command.pre_exec(|| {
                // ignore the error?
                switch_cgroups();
                Ok(())
            })
        };
    }
    command = command
        .current_dir(path.as_ref().parent().unwrap())
        .arg("sh")
        .arg(path.as_ref())
        .envs(get_common_script_envs());

    // Set KSU_MODULE environment variable if module_id was validated successfully
    if let Some(id) = validated_module_id {
        command = command.env("KSU_MODULE", id);
    }

    let result = if wait {
        command.status().map(|_| ())
    } else {
        command.spawn().map(|_| ())
    };
    result.map_err(|e| anyhow!("Failed to exec {}: {e}", path.as_ref().display()))
}

pub fn exec_stage_script(stage: &str, block: bool) -> Result<()> {
    let metamodule_dir = metamodule::get_metamodule_path().and_then(|path| canonicalize(path).ok());

    foreach_active_module(|module| {
        if metamodule_dir.as_ref().is_some_and(|meta_dir| {
            canonicalize(module)
                .map(|resolved| resolved == *meta_dir)
                .unwrap_or(false)
        }) {
            return Ok(());
        }

        let script_path = module.join(format!("{stage}.sh"));
        if !script_path.exists() {
            return Ok(());
        }

        exec_script(&script_path, block)
    })?;

    Ok(())
}

pub fn exec_common_scripts(dir: &str, wait: bool) -> Result<()> {
    let script_dir = Path::new(defs::ADB_DIR).join(dir);
    if !script_dir.exists() {
        info!("{} not exists, skip", script_dir.display());
        return Ok(());
    }

    let dir = std::fs::read_dir(&script_dir)?;
    for entry in dir.flatten() {
        let path = entry.path();

        if !is_executable(&path) {
            warn!("{} is not executable, skip", path.display());
            continue;
        }

        exec_script(path, wait)?;
    }

    Ok(())
}

pub fn load_system_prop() -> Result<()> {
    foreach_active_module(|module| {
        let system_prop = module.join("system.prop");
        if !system_prop.exists() {
            return Ok(());
        }
        info!("load {} system.prop", module.display());

        // resetprop -n --file system.prop
        Command::new(assets::RESETPROP_PATH)
            .arg("-n")
            .arg("--file")
            .arg(&system_prop)
            .status()
            .with_context(|| format!("Failed to exec {}", system_prop.display()))?;

        Ok(())
    })?;

    Ok(())
}

pub fn prune_modules() -> Result<()> {
    foreach_module(All, |module| {
        if !module.join(defs::REMOVE_FILE_NAME).exists() {
            return Ok(());
        }

        info!("remove module: {}", module.display());

        // Execute metamodule's metauninstall.sh first
        let module_id = module.file_name().and_then(|n| n.to_str()).unwrap_or("");

        // Check if this is a metamodule
        let is_metamodule = read_module_prop(module)
            .map(|props| metamodule::is_metamodule(&props))
            .unwrap_or(false);

        if is_metamodule {
            info!("Removing metamodule symlink");
            if let Err(e) = metamodule::remove_symlink() {
                warn!("Failed to remove metamodule symlink: {e}");
            }
        } else if let Err(e) = metamodule::exec_metauninstall_script(module_id) {
            warn!("Failed to exec metamodule uninstall for {module_id}: {e}",);
        }

        // Then execute module's own uninstall.sh
        let uninstaller = module.join("uninstall.sh");
        if uninstaller.exists()
            && let Err(e) = exec_script(uninstaller, true)
        {
            warn!("Failed to exec uninstaller: {e}");
        }

        // Clear module configs before removing module directory
        if let Err(e) = crate::module_config::clear_module_configs(module_id) {
            warn!("Failed to clear configs for {module_id}: {e}");
        }

        // Finally remove the module directory
        if let Err(e) = remove_dir_all(module) {
            warn!("Failed to remove {}: {e}", module.display());
        }

        Ok(())
    })?;

    // collect remaining modules, if none, clean up metamodule record
    let remaining_modules: Vec<_> = std::fs::read_dir(defs::MODULE_DIR)?
        .filter_map(std::result::Result::ok)
        .filter(|entry| entry.path().join("module.prop").exists())
        .collect();

    if remaining_modules.is_empty() {
        info!("no remaining modules.");
    }

    Ok(())
}

pub fn handle_updated_modules() -> Result<()> {
    let modules_root = Path::new(MODULE_DIR);
    foreach_module(ModuleType::Updated, |updated_module| {
        if !updated_module.is_dir() {
            return Ok(());
        }

        if let Some(name) = updated_module.file_name() {
            let module_dir = modules_root.join(name);
            let mut disabled = false;
            let mut removed = false;
            if module_dir.exists() {
                // If the old module is disabled, we need to also disable the new one
                disabled = module_dir.join(defs::DISABLE_FILE_NAME).exists();
                removed = module_dir.join(defs::REMOVE_FILE_NAME).exists();
                remove_dir_all(&module_dir)?;
            }
            rename(updated_module, &module_dir)?;
            if removed {
                let path = module_dir.join(defs::REMOVE_FILE_NAME);
                if let Err(e) = ensure_file_exists(&path) {
                    warn!("Failed to create {}: {e}", path.display());
                }
            } else if disabled {
                let path = module_dir.join(defs::DISABLE_FILE_NAME);
                if let Err(e) = ensure_file_exists(&path) {
                    warn!("Failed to create {}: {e}", path.display());
                }
            }
        }
        Ok(())
    })?;
    Ok(())
}

fn install_module_to_system(zip: &str) -> Result<()> {
    ensure_boot_completed()?;

    // print banner
    println!(include_str!("banner"));

    assets::ensure_binaries(false).with_context(|| "Failed to extract assets")?;

    // first check if working dir is usable
    ensure_dir_exists(defs::WORKING_DIR).with_context(|| "Failed to create working dir")?;
    ensure_dir_exists(defs::BINARY_DIR).with_context(|| "Failed to create bin dir")?;

    // read the module_id from zip, if failed it will return early.
    let mut buffer: Vec<u8> = Vec::new();
    let entry_path = PathBuf::from_str("module.prop")?;
    let zip_path = PathBuf::from_str(zip)?;
    let zip_path = zip_path.canonicalize()?;
    zip_extract_file_to_memory(&zip_path, &entry_path, &mut buffer)?;

    let mut module_prop = HashMap::new();
    PropertiesIter::new_with_encoding(Cursor::new(buffer), encoding_rs::UTF_8).read_into(
        |k, v| {
            module_prop.insert(k, v);
        },
    )?;
    info!("module prop: {module_prop:?}");

    let Some(module_id) = module_prop.get("id") else {
        bail!("module id not found in module.prop!");
    };
    let module_id = module_id.trim();

    // Validate module_id format
    validate_module_id(module_id)
        .with_context(|| format!("Invalid module ID in module.prop: '{module_id}'"))?;

    // Check if this module is a metamodule
    let is_metamodule = metamodule::is_metamodule(&module_prop);

    // Check if it's safe to install regular module
    if !is_metamodule && let Err(is_disabled) = metamodule::check_install_safety() {
        println!("\n❌ Installation Blocked");
        println!("┌────────────────────────────────");
        println!("│ A metamodule with custom installer is active");
        println!("│");
        if is_disabled {
            println!("│ Current state: Disabled");
            println!("│ Action required: Re-enable or uninstall it, then reboot");
        } else {
            println!("│ Current state: Pending changes");
            println!("│ Action required: Reboot to apply changes first");
        }
        println!("└─────────────────────────────────\n");
        bail!("Metamodule installation blocked");
    }

    // All modules (including metamodules) are installed to MODULE_UPDATE_DIR
    let updated_dir = Path::new(defs::MODULE_UPDATE_DIR).join(module_id);

    if is_metamodule {
        info!("Installing metamodule: {module_id}");

        // Check if there's already a metamodule installed
        if metamodule::has_metamodule()
            && let Some(existing_path) = metamodule::get_metamodule_path()
        {
            let existing_id = read_module_prop(&existing_path)
                .ok()
                .and_then(|m| m.get("id").cloned())
                .unwrap_or_else(|| "unknown".to_string());

            if existing_id != module_id {
                println!("\n❌ Installation Failed");
                println!("┌────────────────────────────────");
                println!("│ A metamodule is already installed");
                println!("│   Current metamodule: {existing_id}");
                println!("│");
                println!("│ Only one metamodule can be active at a time.");
                println!("│");
                println!("│ To install this metamodule:");
                println!("│   1. Uninstall the current metamodule");
                println!("│   2. Reboot your device");
                println!("│   3. Install the new metamodule");
                println!("└─────────────────────────────────\n");
                bail!("Cannot install multiple metamodules");
            }
        }
    }

    let zip_uncompressed_size = get_zip_uncompressed_size(zip)?;
    info!(
        "zip uncompressed size: {}",
        humansize::format_size(zip_uncompressed_size, humansize::DECIMAL)
    );
    println!(
        "- Module size: {}",
        humansize::format_size(zip_uncompressed_size, humansize::DECIMAL)
    );

    // Ensure module directory exists and set SELinux context
    ensure_dir_exists(defs::MODULE_UPDATE_DIR)?;
    setsyscon(defs::MODULE_UPDATE_DIR)?;

    // Prepare target directory
    println!("- Installing to {}", updated_dir.display());
    ensure_clean_dir(&updated_dir)?;
    info!("target dir: {}", updated_dir.display());

    // Extract zip to target directory
    println!("- Extracting module files");
    let file = File::open(zip)?;
    let mut archive = zip::ZipArchive::new(file)?;
    archive.extract(&updated_dir)?;

    // Set permission and selinux context for $MOD/system
    let module_system_dir = updated_dir.join("system");
    if module_system_dir.exists() {
        #[cfg(unix)]
        set_permissions(&module_system_dir, Permissions::from_mode(0o755))?;
        restore_syscon(&module_system_dir)?;
    }

    // Execute install script
    println!("- Running module installer");
    exec_install_script(zip, is_metamodule)?;

    let module_dir = Path::new(MODULE_DIR).join(module_id);
    ensure_dir_exists(&module_dir)?;
    copy(
        updated_dir.join("module.prop"),
        module_dir.join("module.prop"),
    )?;
    ensure_file_exists(module_dir.join(UPDATE_FILE_NAME))?;

    // Create symlink for metamodule
    if is_metamodule {
        println!("- Creating metamodule symlink");
        metamodule::ensure_symlink(&module_dir)?;
    }

    println!("- Module installed successfully!");
    info!("Module {module_id} installed successfully!");

    Ok(())
}

pub fn install_module(zip: &str) -> Result<()> {
    let result = install_module_to_system(zip);
    if let Err(ref e) = result {
        println!("- Error: {e}");
    }
    result
}

pub fn undo_uninstall_module(id: &str) -> Result<()> {
    validate_module_id(id)?;

    let module_path = Path::new(defs::MODULE_DIR).join(id);
    ensure!(module_path.exists(), "Module {id} not found");

    // Remove the remove mark
    let remove_file = module_path.join(defs::REMOVE_FILE_NAME);
    if remove_file.exists() {
        std::fs::remove_file(&remove_file)
            .with_context(|| format!("Failed to delete remove file for module '{id}'"))?;
        info!("Removed the remove mark for module {id}");
    }

    Ok(())
}

pub fn uninstall_module(id: &str) -> Result<()> {
    validate_module_id(id)?;

    let module_path = Path::new(defs::MODULE_DIR).join(id);
    ensure!(module_path.exists(), "Module {id} not found");

    // Mark for removal
    let remove_file = module_path.join(defs::REMOVE_FILE_NAME);
    File::create(remove_file).with_context(|| "Failed to create remove file")?;

    info!("Module {id} marked for removal");

    Ok(())
}

pub fn run_action(id: &str) -> Result<()> {
    validate_module_id(id)?;

    let action_script_path = format!("/data/adb/modules/{id}/action.sh");
    exec_script(&action_script_path, true)
}

pub fn enable_module(id: &str) -> Result<()> {
    validate_module_id(id)?;

    let module_path = Path::new(defs::MODULE_DIR).join(id);
    ensure!(module_path.exists(), "Module {id} not found");

    let disable_path = module_path.join(defs::DISABLE_FILE_NAME);
    if disable_path.exists() {
        std::fs::remove_file(&disable_path).with_context(|| {
            format!("Failed to remove disable file: {}", disable_path.display())
        })?;
        info!("Module {id} enabled");
    }

    Ok(())
}

pub fn disable_module(id: &str) -> Result<()> {
    let module_path = Path::new(defs::MODULE_DIR).join(id);
    ensure!(module_path.exists(), "Module {id} not found");

    let disable_path = module_path.join(defs::DISABLE_FILE_NAME);
    ensure_file_exists(disable_path)?;

    info!("Module {id} disabled");

    Ok(())
}

pub fn disable_all_modules() -> Result<()> {
    mark_all_modules(defs::DISABLE_FILE_NAME)
}

pub fn uninstall_all_modules() -> Result<()> {
    info!("Uninstalling all modules");
    mark_all_modules(defs::REMOVE_FILE_NAME)
}

fn mark_all_modules(flag_file: &str) -> Result<()> {
    // we assume the module dir is already mounted
    let dir = std::fs::read_dir(defs::MODULE_DIR)?;
    for entry in dir.flatten() {
        let path = entry.path();
        let flag = path.join(flag_file);
        if let Err(e) = ensure_file_exists(flag) {
            warn!("Failed to mark module: {}: {e}", path.display());
        }
    }

    Ok(())
}

/// Read module.prop from the given module path and return as a HashMap
pub fn read_module_prop(module_path: &Path) -> Result<HashMap<String, String>> {
    let module_prop = module_path.join("module.prop");
    ensure!(
        module_prop.exists(),
        "module.prop not found in {}",
        module_path.display()
    );

    let content = std::fs::read(&module_prop)
        .with_context(|| format!("Failed to read module.prop: {}", module_prop.display()))?;

    let mut prop_map: HashMap<String, String> = HashMap::new();
    PropertiesIter::new_with_encoding(Cursor::new(content), encoding_rs::UTF_8)
        .read_into(|k, v| {
            prop_map.insert(k, v);
        })
        .with_context(|| format!("Failed to parse module.prop: {}", module_prop.display()))?;

    Ok(prop_map)
}

/// Resolve a module icon path to an absolute on-disk path
fn resolve_module_icon_path(
    module_prop_map: &mut HashMap<String, String>,
    key: &str,
    module_path: &Path,
) {
    if let Some(icon_value) = module_prop_map.get(key) {
        let icon_value = icon_value.trim();
        if icon_value.is_empty() {
            return;
        }
        let path = std::path::Path::new(icon_value);
        if path.is_absolute() {
            log::warn!(
                "Rejected {} with absolute path for module {}: {}",
                key,
                module_prop_map.get("id").map_or("", String::as_str),
                icon_value
            );
            return;
        }
        let has_parent = path
            .components()
            .any(|c| matches!(c, std::path::Component::ParentDir));
        if has_parent {
            log::warn!(
                "Rejected {} with parent traversal for module {}: {}",
                key,
                module_prop_map.get("id").map_or("", String::as_str),
                icon_value
            );
            return;
        }
        let candidate = module_path.join(path);
        if candidate.exists() && candidate.is_file() {
            if let Some(s) = candidate.to_str() {
                module_prop_map.insert(key.to_owned(), s.to_string());
            }
        } else {
            log::debug!(
                "{} not found for module {}: {}",
                key,
                module_prop_map.get("id").map_or("", String::as_str),
                candidate.display()
            );
        }
    }
}

fn list_module(path: &str) -> Vec<HashMap<String, String>> {
    // Load all module configs once to minimize I/O overhead
    let all_configs = match crate::module_config::get_all_module_configs() {
        Ok(configs) => configs,
        Err(e) => {
            warn!("Failed to load module configs: {e}");
            HashMap::new()
        }
    };

    // first check enabled modules
    let dir = std::fs::read_dir(path);
    let Ok(dir) = dir else {
        return Vec::new();
    };

    let mut modules: Vec<HashMap<String, String>> = Vec::new();

    for entry in dir.flatten() {
        let path = entry.path();
        info!("path: {}", path.display());

        if !path.join("module.prop").exists() {
            continue;
        }

        let mut module_prop_map = match read_module_prop(&path) {
            Ok(prop) => prop,
            Err(e) => {
                warn!("Failed to read module.prop for {}: {e}", path.display());
                continue;
            }
        };

        // If id is missing or empty, use directory name as fallback
        if !module_prop_map.contains_key("id") || module_prop_map["id"].is_empty() {
            if let Some(id) = entry.file_name().to_str() {
                info!("Use dir name as module id: {id}");
                module_prop_map.insert("id".to_owned(), id.to_owned());
            } else {
                info!("Failed to get module id from dir name");
                continue;
            }
        }

        // Add enabled, update, remove, web, action flags
        let enabled = !path.join(defs::DISABLE_FILE_NAME).exists();
        let update = path.join(defs::UPDATE_FILE_NAME).exists();
        let remove = path.join(defs::REMOVE_FILE_NAME).exists();
        let web = path.join(defs::MODULE_WEB_DIR).exists();
        let action = path.join(defs::MODULE_ACTION_SH).exists();
        let need_mount = path.join("system").exists() && !path.join("skip_mount").exists();

        module_prop_map.insert("enabled".to_owned(), enabled.to_string());
        module_prop_map.insert("update".to_owned(), update.to_string());
        module_prop_map.insert("remove".to_owned(), remove.to_string());
        module_prop_map.insert("web".to_owned(), web.to_string());
        module_prop_map.insert("action".to_owned(), action.to_string());
        module_prop_map.insert("mount".to_owned(), need_mount.to_string());

        resolve_module_icon_path(&mut module_prop_map, "actionIcon", &path);
        resolve_module_icon_path(&mut module_prop_map, "webuiIcon", &path);

        // Apply module config overrides and extract managed features
        if let Some(module_id) = module_prop_map.get("id")
            && let Some(config) = all_configs.get(module_id.as_str())
        {
            // Apply override.description
            if let Some(desc) = config.get("override.description") {
                module_prop_map.insert("description".to_owned(), desc.clone());
            }

            // Extract managed features from manage.* config entries
            let managed_features: Vec<String> = config
                .iter()
                .filter_map(|(k, v)| {
                    if k.starts_with("manage.") && crate::module_config::parse_bool_config(v) {
                        k.strip_prefix("manage.")
                            .map(std::string::ToString::to_string)
                    } else {
                        None
                    }
                })
                .collect();

            if !managed_features.is_empty() {
                module_prop_map.insert("managedFeatures".to_owned(), managed_features.join(","));
            }
        }

        modules.push(module_prop_map);
    }

    modules
}

pub fn list_modules() -> Result<()> {
    let modules = list_module(defs::MODULE_DIR);
    println!("{}", serde_json::to_string_pretty(&modules)?);
    Ok(())
}

/// Get all managed features from active modules
/// Modules declare managed features via config system (manage.<feature>=true)
/// Returns: HashMap<ModuleId, Vec<ManagedFeature>>
pub fn get_managed_features() -> Result<HashMap<String, Vec<String>>> {
    let mut managed_features_map: HashMap<String, Vec<String>> = HashMap::new();

    foreach_active_module(|module_path| {
        // Get module ID
        let Some(module_id) = module_path.file_name().and_then(|n| n.to_str()) else {
            warn!(
                "Failed to get module id from path: {}",
                module_path.display()
            );
            return Ok(());
        };

        // Read module config
        let config = match crate::module_config::merge_configs(module_id) {
            Ok(c) => c,
            Err(e) => {
                warn!("Failed to merge configs for module '{module_id}': {e}");
                return Ok(()); // Skip this module
            }
        };

        // Extract manage.* config entries
        let mut feature_list = Vec::new();
        for (key, value) in &config {
            if key.starts_with("manage.") {
                // Parse feature name
                if let Some(feature_name) = key.strip_prefix("manage.")
                    && crate::module_config::parse_bool_config(value)
                {
                    feature_list.push(feature_name.to_string());
                }
            }
        }

        if !feature_list.is_empty() {
            managed_features_map.insert(module_id.to_string(), feature_list);
        }

        Ok(())
    })?;

    Ok(managed_features_map)
}

```

`userspace/ksud/src/module_config.rs`:

```rs
use anyhow::{Context, Result, bail};
use log::{debug, warn};
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

use crate::defs;
use crate::utils::ensure_dir_exists;

#[allow(clippy::unreadable_literal)]
const MODULE_CONFIG_MAGIC: u32 = 0x4b53554d; // "KSUM"
const MODULE_CONFIG_VERSION: u32 = 1;

// Validation limits
pub const MAX_CONFIG_KEY_LEN: usize = 256;
pub const MAX_CONFIG_VALUE_LEN: usize = 1024 * 1024; // 1MB
pub const MAX_CONFIG_COUNT: usize = 32;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConfigType {
    Persist,
    Temp,
}

impl ConfigType {
    const fn filename(self) -> &'static str {
        match self {
            Self::Persist => defs::PERSIST_CONFIG_NAME,
            Self::Temp => defs::TEMP_CONFIG_NAME,
        }
    }
}

/// Parse a boolean config value
/// Accepts "true", "1" (case-insensitive) as true, everything else as false
pub fn parse_bool_config(value: &str) -> bool {
    let trimmed = value.trim();
    trimmed.eq_ignore_ascii_case("true") || trimmed == "1"
}

/// Validate config key
/// Uses the same validation rules as module_id: ^[a-zA-Z][a-zA-Z0-9._-]+$
/// - Must start with a letter (a-zA-Z)
/// - Followed by one or more alphanumeric, dot, underscore, or hyphen characters
/// - Minimum length: 2 characters
pub fn validate_config_key(key: &str) -> Result<()> {
    if key.is_empty() {
        bail!("Config key cannot be empty");
    }

    if key.len() > MAX_CONFIG_KEY_LEN {
        bail!(
            "Config key too long: {} bytes (max: {})",
            key.len(),
            MAX_CONFIG_KEY_LEN
        );
    }

    // Use same pattern as module_id for consistency
    let re = regex_lite::Regex::new(r"^[a-zA-Z][a-zA-Z0-9._-]+$")?;
    if !re.is_match(key) {
        bail!("Invalid config key: '{key}'. Must match /^[a-zA-Z][a-zA-Z0-9._-]+$/");
    }

    Ok(())
}

/// Validate config value
/// Only enforces maximum length - no character restrictions
/// Values are stored in binary format with length prefix, so any UTF-8 data is safe
pub fn validate_config_value(value: &str) -> Result<()> {
    if value.len() > MAX_CONFIG_VALUE_LEN {
        bail!(
            "Config value too long: {} bytes (max: {})",
            value.len(),
            MAX_CONFIG_VALUE_LEN
        );
    }

    // No character restrictions - binary storage format handles all UTF-8 safely
    Ok(())
}

/// Validate config count
fn validate_config_count(config: &HashMap<String, String>) -> Result<()> {
    if config.len() > MAX_CONFIG_COUNT {
        bail!(
            "Too many config entries: {} (max: {})",
            config.len(),
            MAX_CONFIG_COUNT
        );
    }
    Ok(())
}

/// Get the config directory path for a module
fn get_config_dir(module_id: &str) -> PathBuf {
    Path::new(defs::MODULE_CONFIG_DIR).join(module_id)
}

/// Get the config file path for a module
fn get_config_path(module_id: &str, config_type: ConfigType) -> PathBuf {
    get_config_dir(module_id).join(config_type.filename())
}

/// Ensure the config directory exists
fn ensure_config_dir(module_id: &str) -> Result<PathBuf> {
    let dir = get_config_dir(module_id);
    ensure_dir_exists(&dir)?;
    Ok(dir)
}

/// Load config from binary file
pub fn load_config(module_id: &str, config_type: ConfigType) -> Result<HashMap<String, String>> {
    crate::module::validate_module_id(module_id)?;

    let config_path = get_config_path(module_id, config_type);

    if !config_path.exists() {
        debug!("Config file not found: {}", config_path.display());
        return Ok(HashMap::new());
    }

    let mut file = File::open(&config_path)
        .with_context(|| format!("Failed to open config file: {}", config_path.display()))?;

    // Read magic
    let mut magic_buf = [0u8; 4];
    file.read_exact(&mut magic_buf)
        .with_context(|| "Failed to read magic")?;
    let magic = u32::from_le_bytes(magic_buf);

    if magic != MODULE_CONFIG_MAGIC {
        bail!("Invalid config magic: expected 0x{MODULE_CONFIG_MAGIC:08x}, got 0x{magic:08x}");
    }

    // Read version
    let mut version_buf = [0u8; 4];
    file.read_exact(&mut version_buf)
        .with_context(|| "Failed to read version")?;
    let version = u32::from_le_bytes(version_buf);

    if version != MODULE_CONFIG_VERSION {
        bail!("Unsupported config version: expected {MODULE_CONFIG_VERSION}, got {version}");
    }

    // Read count
    let mut count_buf = [0u8; 4];
    file.read_exact(&mut count_buf)
        .with_context(|| "Failed to read count")?;
    let count = u32::from_le_bytes(count_buf);

    // Read entries
    let mut config = HashMap::new();
    for i in 0..count {
        // Read key length
        let mut key_len_buf = [0u8; 4];
        file.read_exact(&mut key_len_buf)
            .with_context(|| format!("Failed to read key length for entry {i}"))?;
        let key_len = u32::from_le_bytes(key_len_buf) as usize;

        // Read key data
        let mut key_buf = vec![0u8; key_len];
        file.read_exact(&mut key_buf)
            .with_context(|| format!("Failed to read key data for entry {i}"))?;
        let key = String::from_utf8(key_buf)
            .with_context(|| format!("Invalid UTF-8 in key for entry {i}"))?;

        // Read value length
        let mut value_len_buf = [0u8; 4];
        file.read_exact(&mut value_len_buf)
            .with_context(|| format!("Failed to read value length for entry {i}"))?;
        let value_len = u32::from_le_bytes(value_len_buf) as usize;

        // Read value data
        let mut value_buf = vec![0u8; value_len];
        file.read_exact(&mut value_buf)
            .with_context(|| format!("Failed to read value data for entry {i}"))?;
        let value = String::from_utf8(value_buf)
            .with_context(|| format!("Invalid UTF-8 in value for entry {i}"))?;

        config.insert(key, value);
    }

    debug!(
        "Loaded {} entries from {}",
        config.len(),
        config_path.display()
    );
    Ok(config)
}

/// Save config to binary file
pub fn save_config(
    module_id: &str,
    config_type: ConfigType,
    config: &HashMap<String, String>,
) -> Result<()> {
    crate::module::validate_module_id(module_id)?;

    // Validate config count
    validate_config_count(config)?;

    // Validate all keys and values
    for (key, value) in config {
        validate_config_key(key).with_context(|| format!("Invalid config key: '{key}'"))?;
        validate_config_value(value)
            .with_context(|| format!("Invalid config value for key '{key}'"))?;
    }

    ensure_config_dir(module_id)?;

    let config_path = get_config_path(module_id, config_type);
    let temp_path = config_path.with_extension("tmp");

    // Write to temporary file first
    let mut file = File::create(&temp_path)
        .with_context(|| format!("Failed to create temp config file: {}", temp_path.display()))?;

    // Write magic
    file.write_all(&MODULE_CONFIG_MAGIC.to_le_bytes())
        .with_context(|| "Failed to write magic")?;

    // Write version
    file.write_all(&MODULE_CONFIG_VERSION.to_le_bytes())
        .with_context(|| "Failed to write version")?;

    // Write count
    let count = config.len() as u32;
    file.write_all(&count.to_le_bytes())
        .with_context(|| "Failed to write count")?;

    // Write entries
    for (key, value) in config {
        // Write key length
        let key_bytes = key.as_bytes();
        let key_len = key_bytes.len() as u32;
        file.write_all(&key_len.to_le_bytes())
            .with_context(|| format!("Failed to write key length for '{key}'"))?;

        // Write key data
        file.write_all(key_bytes)
            .with_context(|| format!("Failed to write key data for '{key}'"))?;

        // Write value length
        let value_bytes = value.as_bytes();
        let value_len = value_bytes.len() as u32;
        file.write_all(&value_len.to_le_bytes())
            .with_context(|| format!("Failed to write value length for '{key}'"))?;

        // Write value data
        file.write_all(value_bytes)
            .with_context(|| format!("Failed to write value data for '{key}'"))?;
    }

    file.sync_all()
        .with_context(|| "Failed to sync config file")?;

    // Atomic rename
    fs::rename(&temp_path, &config_path).with_context(|| {
        format!(
            "Failed to rename config file: {} -> {}",
            temp_path.display(),
            config_path.display()
        )
    })?;

    debug!(
        "Saved {} entries to {}",
        config.len(),
        config_path.display()
    );
    Ok(())
}

/// Get a single config value
#[allow(dead_code)]
pub fn get_config_value(
    module_id: &str,
    key: &str,
    config_type: ConfigType,
) -> Result<Option<String>> {
    let config = load_config(module_id, config_type)?;
    Ok(config.get(key).cloned())
}

/// Set a single config value
pub fn set_config_value(
    module_id: &str,
    key: &str,
    value: &str,
    config_type: ConfigType,
) -> Result<()> {
    // Validate input early for better error messages
    validate_config_key(key)?;
    validate_config_value(value)?;

    let mut config = load_config(module_id, config_type)?;
    config.insert(key.to_string(), value.to_string());

    // Note: save_config will also validate, but this provides earlier feedback
    save_config(module_id, config_type, &config)?;
    Ok(())
}

/// Delete a single config value
pub fn delete_config_value(module_id: &str, key: &str, config_type: ConfigType) -> Result<()> {
    let mut config = load_config(module_id, config_type)?;

    if config.remove(key).is_none() {
        bail!("Key '{key}' not found in config");
    }

    save_config(module_id, config_type, &config)?;
    Ok(())
}

/// Clear all config values
pub fn clear_config(module_id: &str, config_type: ConfigType) -> Result<()> {
    let config_path = get_config_path(module_id, config_type);

    if config_path.exists() {
        fs::remove_file(&config_path)
            .with_context(|| format!("Failed to remove config file: {}", config_path.display()))?;
        debug!("Cleared config: {}", config_path.display());
    }

    Ok(())
}

/// Merge persist and temp configs (temp takes priority)
pub fn merge_configs(module_id: &str) -> Result<HashMap<String, String>> {
    crate::module::validate_module_id(module_id)?;

    let mut merged = match load_config(module_id, ConfigType::Persist) {
        Ok(config) => config,
        Err(e) => {
            warn!("Failed to load persist config for module '{module_id}': {e}");
            HashMap::new()
        }
    };

    let temp = match load_config(module_id, ConfigType::Temp) {
        Ok(config) => config,
        Err(e) => {
            warn!("Failed to load temp config for module '{module_id}': {e}");
            HashMap::new()
        }
    };

    // Temp config overrides persist config
    for (key, value) in temp {
        merged.insert(key, value);
    }

    Ok(merged)
}

/// Get all module configs (for iteration)
/// Loads all configs in a single pass to minimize I/O overhead
pub fn get_all_module_configs() -> Result<HashMap<String, HashMap<String, String>>> {
    let config_root = Path::new(defs::MODULE_CONFIG_DIR);

    if !config_root.exists() {
        return Ok(HashMap::new());
    }

    let mut all_configs = HashMap::new();

    for entry in fs::read_dir(config_root)
        .with_context(|| format!("Failed to read config directory: {}", config_root.display()))?
    {
        let entry = entry?;
        let path = entry.path();

        if !path.is_dir() {
            continue;
        }

        if let Some(module_id) = path.file_name().and_then(|n| n.to_str()) {
            match merge_configs(module_id) {
                Ok(config) => {
                    if !config.is_empty() {
                        all_configs.insert(module_id.to_string(), config);
                    }
                }
                Err(e) => {
                    warn!("Failed to load config for module '{module_id}': {e}");
                    // Continue processing other modules
                }
            }
        }
    }

    Ok(all_configs)
}

/// Clear all temporary configs (called during post-fs-data)
pub fn clear_all_temp_configs() -> Result<()> {
    let config_root = Path::new(defs::MODULE_CONFIG_DIR);

    if !config_root.exists() {
        debug!("Config directory does not exist, nothing to clear");
        return Ok(());
    }

    let mut cleared_count = 0;

    for entry in fs::read_dir(config_root)
        .with_context(|| format!("Failed to read config directory: {}", config_root.display()))?
    {
        let entry = entry?;
        let path = entry.path();

        if !path.is_dir() {
            continue;
        }

        let temp_config = path.join(defs::TEMP_CONFIG_NAME);
        if temp_config.exists() {
            match fs::remove_file(&temp_config) {
                Ok(()) => {
                    debug!("Cleared temp config: {}", temp_config.display());
                    cleared_count += 1;
                }
                Err(e) => {
                    warn!("Failed to clear temp config {}: {e}", temp_config.display());
                }
            }
        }
    }

    if cleared_count > 0 {
        debug!("Cleared {cleared_count} temp config file(s)");
    }

    Ok(())
}

/// Clear all configs for a module (called during uninstall)
pub fn clear_module_configs(module_id: &str) -> Result<()> {
    crate::module::validate_module_id(module_id)?;

    let config_dir = get_config_dir(module_id);

    if config_dir.exists() {
        fs::remove_dir_all(&config_dir).with_context(|| {
            format!(
                "Failed to remove config directory: {}",
                config_dir.display()
            )
        })?;
        debug!("Cleared all configs for module: {module_id}");
    }

    Ok(())
}

```

`userspace/ksud/src/profile.rs`:

```rs
use crate::utils::ensure_dir_exists;
use crate::{defs, sepolicy};
use anyhow::{Context, Result};
use std::path::Path;

pub fn set_sepolicy(pkg: String, policy: String) -> Result<()> {
    ensure_dir_exists(defs::PROFILE_SELINUX_DIR)?;
    let policy_file = Path::new(defs::PROFILE_SELINUX_DIR).join(pkg);
    std::fs::write(&policy_file, policy)?;
    sepolicy::apply_file(&policy_file)?;
    Ok(())
}

pub fn get_sepolicy(pkg: String) -> Result<()> {
    let policy_file = Path::new(defs::PROFILE_SELINUX_DIR).join(pkg);
    let policy = std::fs::read_to_string(policy_file)?;
    println!("{policy}");
    Ok(())
}

// ksud doesn't guarteen the correctness of template, it just save
pub fn set_template(id: String, template: String) -> Result<()> {
    ensure_dir_exists(defs::PROFILE_TEMPLATE_DIR)?;
    let template_file = Path::new(defs::PROFILE_TEMPLATE_DIR).join(id);
    std::fs::write(template_file, template)?;
    Ok(())
}

pub fn get_template(id: String) -> Result<()> {
    let template_file = Path::new(defs::PROFILE_TEMPLATE_DIR).join(id);
    let template = std::fs::read_to_string(template_file)?;
    println!("{template}");
    Ok(())
}

pub fn delete_template(id: String) -> Result<()> {
    let template_file = Path::new(defs::PROFILE_TEMPLATE_DIR).join(id);
    std::fs::remove_file(template_file)?;
    Ok(())
}

pub fn list_templates() -> Result<()> {
    let templates = std::fs::read_dir(defs::PROFILE_TEMPLATE_DIR);
    let Ok(templates) = templates else {
        return Ok(());
    };
    for template in templates {
        let template = template?;
        let template = template.file_name();
        if let Some(template) = template.to_str() {
            println!("{template}");
        }
    }
    Ok(())
}

pub fn apply_sepolies() -> Result<()> {
    let path = Path::new(defs::PROFILE_SELINUX_DIR);
    if !path.exists() {
        log::info!("profile sepolicy dir not exists.");
        return Ok(());
    }

    let sepolicies =
        std::fs::read_dir(path).with_context(|| "profile sepolicy dir open failed.".to_string())?;
    for sepolicy in sepolicies {
        let Ok(sepolicy) = sepolicy else {
            log::info!("profile sepolicy dir read failed.");
            continue;
        };
        let sepolicy = sepolicy.path();
        if sepolicy::apply_file(&sepolicy).is_ok() {
            log::info!("profile sepolicy applied: {}", sepolicy.display());
        } else {
            log::info!("profile sepolicy apply failed: {}", sepolicy.display());
        }
    }
    Ok(())
}

```

`userspace/ksud/src/restorecon.rs`:

```rs
use crate::defs;
use anyhow::Result;
use jwalk::{Parallelism::Serial, WalkDir};
use std::path::Path;

use anyhow::{Context, Ok};
use extattr::{Flags as XattrFlags, lsetxattr};

pub const SYSTEM_CON: &str = "u:object_r:system_file:s0";
pub const ADB_CON: &str = "u:object_r:adb_data_file:s0";
pub const UNLABEL_CON: &str = "u:object_r:unlabeled:s0";

const SELINUX_XATTR: &str = "security.selinux";

pub fn lsetfilecon<P: AsRef<Path>>(path: P, con: &str) -> Result<()> {
    lsetxattr(&path, SELINUX_XATTR, con, XattrFlags::empty()).with_context(|| {
        format!(
            "Failed to change SELinux context for {}",
            path.as_ref().display()
        )
    })?;
    Ok(())
}

pub fn lgetfilecon<P: AsRef<Path>>(path: P) -> Result<String> {
    let con = extattr::lgetxattr(&path, SELINUX_XATTR).with_context(|| {
        format!(
            "Failed to get SELinux context for {}",
            path.as_ref().display()
        )
    })?;
    let con = String::from_utf8_lossy(&con);
    Ok(con.to_string())
}

pub fn setsyscon<P: AsRef<Path>>(path: P) -> Result<()> {
    lsetfilecon(path, SYSTEM_CON)
}

pub fn restore_syscon<P: AsRef<Path>>(dir: P) -> Result<()> {
    for dir_entry in WalkDir::new(dir).parallelism(Serial) {
        if let Some(path) = dir_entry.ok().map(|dir_entry| dir_entry.path()) {
            setsyscon(&path)?;
        }
    }
    Ok(())
}

fn restore_syscon_if_unlabeled<P: AsRef<Path>>(dir: P) -> Result<()> {
    for dir_entry in WalkDir::new(dir).parallelism(Serial) {
        if let Some(path) = dir_entry.ok().map(|dir_entry| dir_entry.path())
            && let anyhow::Result::Ok(con) = lgetfilecon(&path)
            && (con == UNLABEL_CON || con.is_empty())
        {
            lsetfilecon(&path, SYSTEM_CON)?;
        }
    }
    Ok(())
}

pub fn restorecon() -> Result<()> {
    lsetfilecon(defs::DAEMON_PATH, ADB_CON)?;
    restore_syscon_if_unlabeled(defs::MODULE_DIR)?;
    Ok(())
}

```

`userspace/ksud/src/sepolicy.rs`:

```rs
use anyhow::{Result, bail};
use derive_new::new;
use nom::{
    AsChar, IResult, Parser,
    branch::alt,
    bytes::complete::{tag, take_while, take_while_m_n, take_while1},
    character::complete::{space0, space1},
    combinator::map,
};
use std::{ffi, path::Path, vec};

type SeObject<'a> = Vec<&'a str>;

fn is_sepolicy_char(c: char) -> bool {
    c.is_alphanum() || c == '_' || c == '-'
}

fn parse_single_word(input: &str) -> IResult<&str, &str> {
    take_while1(is_sepolicy_char).parse(input)
}

fn parse_bracket_objs(input: &str) -> IResult<&str, SeObject<'_>> {
    let (input, (_, words, _)) = (
        tag("{"),
        take_while_m_n(1, 100, |c: char| is_sepolicy_char(c) || c.is_whitespace()),
        tag("}"),
    )
        .parse(input)?;
    Ok((input, words.split_whitespace().collect()))
}

fn parse_single_obj(input: &str) -> IResult<&str, SeObject<'_>> {
    let (input, word) = take_while1(is_sepolicy_char).parse(input)?;
    Ok((input, vec![word]))
}

fn parse_star(input: &str) -> IResult<&str, SeObject<'_>> {
    let (input, _) = tag("*").parse(input)?;
    Ok((input, vec!["*"]))
}

// 1. a single sepolicy word
// 2. { obj1 obj2 obj3 ...}
// 3. *
fn parse_seobj(input: &str) -> IResult<&str, SeObject<'_>> {
    let (input, strs) = alt((parse_single_obj, parse_bracket_objs, parse_star)).parse(input)?;
    Ok((input, strs))
}

fn parse_seobj_no_star(input: &str) -> IResult<&str, SeObject<'_>> {
    let (input, strs) = alt((parse_single_obj, parse_bracket_objs)).parse(input)?;
    Ok((input, strs))
}

trait SeObjectParser<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self>
    where
        Self: Sized;
}

#[derive(Debug, PartialEq, Eq, new)]
struct NormalPerm<'a> {
    op: &'a str,
    source: SeObject<'a>,
    target: SeObject<'a>,
    class: SeObject<'a>,
    perm: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct XPerm<'a> {
    op: &'a str,
    source: SeObject<'a>,
    target: SeObject<'a>,
    class: SeObject<'a>,
    operation: &'a str,
    perm_set: &'a str,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeState<'a> {
    op: &'a str,
    stype: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeAttr<'a> {
    stype: SeObject<'a>,
    sattr: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct Type<'a> {
    name: &'a str,
    attrs: SeObject<'a>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct Attr<'a> {
    name: &'a str,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeTransition<'a> {
    source: &'a str,
    target: &'a str,
    class: &'a str,
    default_type: &'a str,
    object_name: Option<&'a str>,
}

#[derive(Debug, PartialEq, Eq, new)]
struct TypeChange<'a> {
    op: &'a str,
    source: &'a str,
    target: &'a str,
    class: &'a str,
    default_type: &'a str,
}

#[derive(Debug, PartialEq, Eq, new)]
struct GenFsCon<'a> {
    fs_name: &'a str,
    partial_path: &'a str,
    fs_context: &'a str,
}

#[derive(Debug)]
enum PolicyStatement<'a> {
    // "allow *source_type *target_type *class *perm_set"
    // "deny *source_type *target_type *class *perm_set"
    // "auditallow *source_type *target_type *class *perm_set"
    // "dontaudit *source_type *target_type *class *perm_set"
    NormalPerm(NormalPerm<'a>),

    // "allowxperm *source_type *target_type *class operation xperm_set"
    // "auditallowxperm *source_type *target_type *class operation xperm_set"
    // "dontauditxperm *source_type *target_type *class operation xperm_set"
    XPerm(XPerm<'a>),

    // "permissive ^type"
    // "enforce ^type"
    TypeState(TypeState<'a>),

    // "type type_name ^(attribute)"
    Type(Type<'a>),

    // "typeattribute ^type ^attribute"
    TypeAttr(TypeAttr<'a>),

    // "attribute ^attribute"
    Attr(Attr<'a>),

    // "type_transition source_type target_type class default_type (object_name)"
    TypeTransition(TypeTransition<'a>),

    // "type_change source_type target_type class default_type"
    // "type_member source_type target_type class default_type"
    TypeChange(TypeChange<'a>),

    // "genfscon fs_name partial_path fs_context"
    GenFsCon(GenFsCon<'a>),
}

impl<'a> SeObjectParser<'a> for NormalPerm<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((
            tag("allow"),
            tag("deny"),
            tag("auditallow"),
            tag("dontaudit"),
        ))
        .parse(input)?;

        let (input, _) = space0(input)?;
        let (input, source) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, target) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, class) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, perm) = parse_seobj(input)?;
        Ok((input, NormalPerm::new(op, source, target, class, perm)))
    }
}

impl<'a> SeObjectParser<'a> for XPerm<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((
            tag("allowxperm"),
            tag("auditallowxperm"),
            tag("dontauditxperm"),
        ))
        .parse(input)?;

        let (input, _) = space0(input)?;
        let (input, source) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, target) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, class) = parse_seobj(input)?;
        let (input, _) = space0(input)?;
        let (input, operation) = parse_single_word(input)?;
        let (input, _) = space0(input)?;
        let (input, perm_set) = parse_single_word(input)?;

        Ok((
            input,
            XPerm::new(op, source, target, class, operation, perm_set),
        ))
    }
}

impl<'a> SeObjectParser<'a> for TypeState<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((tag("permissive"), tag("enforce"))).parse(input)?;

        let (input, _) = space1(input)?;
        let (input, stype) = parse_seobj_no_star(input)?;

        Ok((input, TypeState::new(op, stype)))
    }
}

impl<'a> SeObjectParser<'a> for Type<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = tag("type")(input)?;
        let (input, _) = space1(input)?;
        let (input, name) = parse_single_word(input)?;

        if input.is_empty() {
            return Ok((input, Type::new(name, vec!["domain"]))); // default to domain
        }

        let (input, _) = space1(input)?;
        let (input, attrs) = parse_seobj_no_star(input)?;

        Ok((input, Type::new(name, attrs)))
    }
}

impl<'a> SeObjectParser<'a> for TypeAttr<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = alt((tag("typeattribute"), tag("attradd"))).parse(input)?;
        let (input, _) = space1(input)?;
        let (input, stype) = parse_seobj_no_star(input)?;
        let (input, _) = space1(input)?;
        let (input, attr) = parse_seobj_no_star(input)?;

        Ok((input, TypeAttr::new(stype, attr)))
    }
}

impl<'a> SeObjectParser<'a> for Attr<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = tag("attribute")(input)?;
        let (input, _) = space1(input)?;
        let (input, attr) = parse_single_word(input)?;

        Ok((input, Attr::new(attr)))
    }
}

impl<'a> SeObjectParser<'a> for TypeTransition<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = alt((tag("type_transition"), tag("name_transition"))).parse(input)?;
        let (input, _) = space1(input)?;
        let (input, source) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, target) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, class) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, default) = parse_single_word(input)?;

        if input.is_empty() {
            return Ok((
                input,
                TypeTransition::new(source, target, class, default, None),
            ));
        }

        let (input, _) = space1(input)?;
        let (input, object) = parse_single_word(input)?;

        Ok((
            input,
            TypeTransition::new(source, target, class, default, Some(object)),
        ))
    }
}

impl<'a> SeObjectParser<'a> for TypeChange<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, op) = alt((tag("type_change"), tag("type_member"))).parse(input)?;
        let (input, _) = space1(input)?;
        let (input, source) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, target) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, class) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, default) = parse_single_word(input)?;

        Ok((input, TypeChange::new(op, source, target, class, default)))
    }
}

impl<'a> SeObjectParser<'a> for GenFsCon<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self>
    where
        Self: Sized,
    {
        let (input, _) = tag("genfscon")(input)?;
        let (input, _) = space1(input)?;
        let (input, fs) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, path) = parse_single_word(input)?;
        let (input, _) = space1(input)?;
        let (input, context) = parse_single_word(input)?;
        Ok((input, GenFsCon::new(fs, path, context)))
    }
}

impl<'a> PolicyStatement<'a> {
    fn parse(input: &'a str) -> IResult<&'a str, Self> {
        let (input, _) = space0(input)?;
        let (input, statement) = alt((
            map(NormalPerm::parse, PolicyStatement::NormalPerm),
            map(XPerm::parse, PolicyStatement::XPerm),
            map(TypeState::parse, PolicyStatement::TypeState),
            map(Type::parse, PolicyStatement::Type),
            map(TypeAttr::parse, PolicyStatement::TypeAttr),
            map(Attr::parse, PolicyStatement::Attr),
            map(TypeTransition::parse, PolicyStatement::TypeTransition),
            map(TypeChange::parse, PolicyStatement::TypeChange),
            map(GenFsCon::parse, PolicyStatement::GenFsCon),
        ))
        .parse(input)?;
        let (input, _) = space0(input)?;
        let (input, _) = take_while(|c| c == ';')(input)?;
        let (input, _) = space0(input)?;
        Ok((input, statement))
    }
}

fn parse_sepolicy<'a, 'b>(input: &'b str, strict: bool) -> Result<Vec<PolicyStatement<'a>>>
where
    'b: 'a,
{
    let mut statements = vec![];

    for line in input.split(['\n', ';']) {
        let trimmed_line = line.trim();
        if trimmed_line.is_empty() || trimmed_line.starts_with('#') {
            continue;
        }
        if let Ok((_, statement)) = PolicyStatement::parse(trimmed_line) {
            statements.push(statement);
        } else if strict {
            bail!("Failed to parse policy statement: {line}")
        }
    }
    Ok(statements)
}

const SEPOLICY_MAX_LEN: usize = 128;

const CMD_NORMAL_PERM: u32 = 1;
const CMD_XPERM: u32 = 2;
const CMD_TYPE_STATE: u32 = 3;
const CMD_TYPE: u32 = 4;
const CMD_TYPE_ATTR: u32 = 5;
const CMD_ATTR: u32 = 6;
const CMD_TYPE_TRANSITION: u32 = 7;
const CMD_TYPE_CHANGE: u32 = 8;
const CMD_GENFSCON: u32 = 9;

#[derive(Debug, Default)]
enum PolicyObject {
    All, // for "*", stand for all objects, and is NULL in ffi
    One([u8; SEPOLICY_MAX_LEN]),
    #[default]
    None,
}

impl TryFrom<&str> for PolicyObject {
    type Error = anyhow::Error;
    fn try_from(s: &str) -> Result<Self> {
        anyhow::ensure!(s.len() <= SEPOLICY_MAX_LEN, "policy object too long");
        if s == "*" {
            return Ok(Self::All);
        }
        let mut buf = [0u8; SEPOLICY_MAX_LEN];
        buf[..s.len()].copy_from_slice(s.as_bytes());
        Ok(Self::One(buf))
    }
}

/// atomic statement, such as: allow domain1 domain2:file1 read;
/// normal statement would be expand to atomic statement, for example:
/// allow domain1 domain2:file1 { read write }; would be expand to two atomic statement
/// allow domain1 domain2:file1 read;allow domain1 domain2:file1 write;
#[allow(clippy::too_many_arguments)]
#[derive(Debug, new)]
struct AtomicStatement {
    cmd: u32,
    subcmd: u32,
    sepol1: PolicyObject,
    sepol2: PolicyObject,
    sepol3: PolicyObject,
    sepol4: PolicyObject,
    sepol5: PolicyObject,
    sepol6: PolicyObject,
    sepol7: PolicyObject,
}

impl<'a> TryFrom<&'a NormalPerm<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a NormalPerm<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "allow" => 1,
            "deny" => 2,
            "auditallow" => 3,
            "dontaudit" => 4,
            _ => 0,
        };
        for &s in &perm.source {
            for &t in &perm.target {
                for &c in &perm.class {
                    for &p in &perm.perm {
                        result.push(AtomicStatement {
                            cmd: CMD_NORMAL_PERM,
                            subcmd,
                            sepol1: s.try_into()?,
                            sepol2: t.try_into()?,
                            sepol3: c.try_into()?,
                            sepol4: p.try_into()?,
                            sepol5: PolicyObject::None,
                            sepol6: PolicyObject::None,
                            sepol7: PolicyObject::None,
                        });
                    }
                }
            }
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a XPerm<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a XPerm<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "allowxperm" => 1,
            "auditallowxperm" => 2,
            "dontauditxperm" => 3,
            _ => 0,
        };
        for &s in &perm.source {
            for &t in &perm.target {
                for &c in &perm.class {
                    result.push(AtomicStatement {
                        cmd: CMD_XPERM,
                        subcmd,
                        sepol1: s.try_into()?,
                        sepol2: t.try_into()?,
                        sepol3: c.try_into()?,
                        sepol4: perm.operation.try_into()?,
                        sepol5: perm.perm_set.try_into()?,
                        sepol6: PolicyObject::None,
                        sepol7: PolicyObject::None,
                    });
                }
            }
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeState<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeState<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "permissive" => 1,
            "enforcing" => 2,
            _ => 0,
        };
        for &t in &perm.stype {
            result.push(AtomicStatement {
                cmd: CMD_TYPE_STATE,
                subcmd,
                sepol1: t.try_into()?,
                sepol2: PolicyObject::None,
                sepol3: PolicyObject::None,
                sepol4: PolicyObject::None,
                sepol5: PolicyObject::None,
                sepol6: PolicyObject::None,
                sepol7: PolicyObject::None,
            });
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a Type<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a Type<'a>) -> Result<Self> {
        let mut result = vec![];
        for &attr in &perm.attrs {
            result.push(AtomicStatement {
                cmd: CMD_TYPE,
                subcmd: 0,
                sepol1: perm.name.try_into()?,
                sepol2: attr.try_into()?,
                sepol3: PolicyObject::None,
                sepol4: PolicyObject::None,
                sepol5: PolicyObject::None,
                sepol6: PolicyObject::None,
                sepol7: PolicyObject::None,
            });
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeAttr<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeAttr<'a>) -> Result<Self> {
        let mut result = vec![];
        for &t in &perm.stype {
            for &attr in &perm.sattr {
                result.push(AtomicStatement {
                    cmd: CMD_TYPE_ATTR,
                    subcmd: 0,
                    sepol1: t.try_into()?,
                    sepol2: attr.try_into()?,
                    sepol3: PolicyObject::None,
                    sepol4: PolicyObject::None,
                    sepol5: PolicyObject::None,
                    sepol6: PolicyObject::None,
                    sepol7: PolicyObject::None,
                });
            }
        }
        Ok(result)
    }
}

impl<'a> TryFrom<&'a Attr<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a Attr<'a>) -> Result<Self> {
        let result = vec![AtomicStatement {
            cmd: CMD_ATTR,
            subcmd: 0,
            sepol1: perm.name.try_into()?,
            sepol2: PolicyObject::None,
            sepol3: PolicyObject::None,
            sepol4: PolicyObject::None,
            sepol5: PolicyObject::None,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        }];
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeTransition<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeTransition<'a>) -> Result<Self> {
        let mut result = vec![];
        let obj = match perm.object_name {
            Some(obj) => obj.try_into()?,
            None => PolicyObject::None,
        };
        result.push(AtomicStatement {
            cmd: CMD_TYPE_TRANSITION,
            subcmd: 0,
            sepol1: perm.source.try_into()?,
            sepol2: perm.target.try_into()?,
            sepol3: perm.class.try_into()?,
            sepol4: perm.default_type.try_into()?,
            sepol5: obj,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        });
        Ok(result)
    }
}

impl<'a> TryFrom<&'a TypeChange<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a TypeChange<'a>) -> Result<Self> {
        let mut result = vec![];
        let subcmd = match perm.op {
            "type_change" => 1,
            "type_member" => 2,
            _ => 0,
        };
        result.push(AtomicStatement {
            cmd: CMD_TYPE_CHANGE,
            subcmd,
            sepol1: perm.source.try_into()?,
            sepol2: perm.target.try_into()?,
            sepol3: perm.class.try_into()?,
            sepol4: perm.default_type.try_into()?,
            sepol5: PolicyObject::None,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        });
        Ok(result)
    }
}

impl<'a> TryFrom<&'a GenFsCon<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(perm: &'a GenFsCon<'a>) -> Result<Self> {
        let result = vec![AtomicStatement {
            cmd: CMD_GENFSCON,
            subcmd: 0,
            sepol1: perm.fs_name.try_into()?,
            sepol2: perm.partial_path.try_into()?,
            sepol3: perm.fs_context.try_into()?,
            sepol4: PolicyObject::None,
            sepol5: PolicyObject::None,
            sepol6: PolicyObject::None,
            sepol7: PolicyObject::None,
        }];
        Ok(result)
    }
}

impl<'a> TryFrom<&'a PolicyStatement<'a>> for Vec<AtomicStatement> {
    type Error = anyhow::Error;
    fn try_from(value: &'a PolicyStatement) -> Result<Self> {
        match value {
            PolicyStatement::NormalPerm(perm) => perm.try_into(),
            PolicyStatement::XPerm(perm) => perm.try_into(),
            PolicyStatement::TypeState(perm) => perm.try_into(),
            PolicyStatement::Type(perm) => perm.try_into(),
            PolicyStatement::TypeAttr(perm) => perm.try_into(),
            PolicyStatement::Attr(perm) => perm.try_into(),
            PolicyStatement::TypeTransition(perm) => perm.try_into(),
            PolicyStatement::TypeChange(perm) => perm.try_into(),
            PolicyStatement::GenFsCon(perm) => perm.try_into(),
        }
    }
}

////////////////////////////////////////////////////////////////
///  for C FFI to call kernel interface
///////////////////////////////////////////////////////////////

#[derive(Debug)]
#[repr(C)]
struct FfiPolicy {
    cmd: u32,
    subcmd: u32,
    sepol1: *const ffi::c_char,
    sepol2: *const ffi::c_char,
    sepol3: *const ffi::c_char,
    sepol4: *const ffi::c_char,
    sepol5: *const ffi::c_char,
    sepol6: *const ffi::c_char,
    sepol7: *const ffi::c_char,
}

const fn to_c_ptr(pol: &PolicyObject) -> *const ffi::c_char {
    match pol {
        PolicyObject::None | PolicyObject::All => std::ptr::null(),
        PolicyObject::One(s) => s.as_ptr().cast::<ffi::c_char>(),
    }
}

impl From<AtomicStatement> for FfiPolicy {
    fn from(policy: AtomicStatement) -> Self {
        Self {
            cmd: policy.cmd,
            subcmd: policy.subcmd,
            sepol1: to_c_ptr(&policy.sepol1),
            sepol2: to_c_ptr(&policy.sepol2),
            sepol3: to_c_ptr(&policy.sepol3),
            sepol4: to_c_ptr(&policy.sepol4),
            sepol5: to_c_ptr(&policy.sepol5),
            sepol6: to_c_ptr(&policy.sepol6),
            sepol7: to_c_ptr(&policy.sepol7),
        }
    }
}

fn apply_one_rule<'a>(statement: &'a PolicyStatement<'a>, strict: bool) -> Result<()> {
    let policies: Vec<AtomicStatement> = statement.try_into()?;

    for policy in policies {
        let ffi_policy = FfiPolicy::from(policy);
        let cmd = crate::ksucalls::SetSepolicyCmd {
            cmd: 0,
            arg: &raw const ffi_policy as u64,
        };
        if let Err(e) = crate::ksucalls::set_sepolicy(&cmd) {
            log::warn!("apply rule {statement:?} failed: {e}");
            if strict {
                return Err(anyhow::anyhow!("apply rule {statement:?} failed: {e}"));
            }
        }
    }

    Ok(())
}

pub fn live_patch(policy: &str) -> Result<()> {
    let result = parse_sepolicy(policy.trim(), false)?;
    for statement in result {
        println!("{statement:?}");
        apply_one_rule(&statement, false)?;
    }
    Ok(())
}

pub fn apply_file<P: AsRef<Path>>(path: P) -> Result<()> {
    let input = std::fs::read_to_string(path)?;
    live_patch(&input)
}

pub fn check_rule(policy: &str) -> Result<()> {
    let path = Path::new(policy);
    let policy = if path.exists() {
        std::fs::read_to_string(path)?
    } else {
        policy.to_string()
    };
    parse_sepolicy(policy.trim(), true)?;
    Ok(())
}

```

`userspace/ksud/src/su.rs`:

```rs
use crate::{
    defs,
    utils::{self, umask},
};
use anyhow::{Context, Ok, Result, bail};
use getopts::Options;
use libc::c_int;
use log::error;
use std::env;
#[cfg(unix)]
use std::os::unix::process::CommandExt;
use std::path::PathBuf;
use std::{
    ffi::{CStr, CString},
    process::Command,
};

use crate::ksucalls::get_wrapped_fd;
use rustix::{
    process::getuid,
    thread::{Gid, Uid, set_thread_res_gid, set_thread_res_uid},
};

pub fn grant_root(global_mnt: bool) -> Result<()> {
    crate::ksucalls::grant_root()?;

    let mut command = Command::new("sh");
    let command = unsafe {
        command.pre_exec(move || {
            if global_mnt {
                let _ = utils::switch_mnt_ns(1);
            }
            Result::Ok(())
        })
    };
    // add /data/adb/ksu/bin to PATH
    add_path_to_env(defs::BINARY_DIR)?;
    Err(command.exec().into())
}

fn print_usage(program: &str, opts: &Options) {
    let brief = format!("KernelSU\n\nUsage: {program} [options] [-] [user [argument...]]");
    print!("{}", opts.usage(&brief));
}

fn set_identity(uid: u32, gid: u32, groups: &[u32]) {
    rustix::thread::set_thread_groups(
        groups
            .iter()
            .map(|g| Gid::from_raw(*g))
            .collect::<Vec<_>>()
            .as_ref(),
    )
    .ok();
    let gid = Gid::from_raw(gid);
    let uid = Uid::from_raw(uid);
    set_thread_res_gid(gid, gid, gid).ok();
    set_thread_res_uid(uid, uid, uid).ok();
}

fn wrap_tty(fd: c_int) {
    let inner_fn = move || -> Result<()> {
        if unsafe { libc::isatty(fd) != 1 } {
            return Ok(());
        }
        let new_fd = get_wrapped_fd(fd).context("get_wrapped_fd")?;
        if unsafe { libc::dup2(new_fd, fd) } == -1 {
            bail!("dup {new_fd} -> {fd} errno: {}", unsafe {
                *libc::__errno()
            });
        }
        unsafe { libc::close(new_fd) };
        Ok(())
    };

    if let Err(e) = inner_fn() {
        error!("wrap tty {fd}: {e:?}");
    }
}

#[allow(clippy::similar_names)]
pub fn root_shell() -> Result<()> {
    // we are root now, this was set in kernel!

    use anyhow::anyhow;
    let env_args: Vec<String> = env::args().collect();
    let program = env_args[0].clone();
    let args = env_args.iter().position(|arg| arg == "-c").map_or_else(
        || env_args.clone(),
        |i| {
            let rest = env_args[i + 1..].to_vec();
            let mut new_args = env_args[..i].to_vec();
            new_args.push("-c".to_string());
            if !rest.is_empty() {
                new_args.push(rest.join(" "));
            }
            new_args
        },
    );

    let mut opts = Options::new();
    opts.optopt(
        "c",
        "command",
        "pass COMMAND to the invoked shell",
        "COMMAND",
    );
    opts.optflag("h", "help", "display this help message and exit");
    opts.optflag("l", "login", "pretend the shell to be a login shell");
    opts.optflag(
        "p",
        "preserve-environment",
        "preserve the entire environment",
    );
    opts.optopt(
        "s",
        "shell",
        "use SHELL instead of the default /system/bin/sh",
        "SHELL",
    );
    opts.optflag("v", "version", "display version number and exit");
    opts.optflag("V", "", "display version code and exit");
    opts.optflag(
        "M",
        "mount-master",
        "force run in the global mount namespace",
    );
    opts.optopt("g", "group", "Specify the primary group", "GROUP");
    opts.optmulti(
        "G",
        "supp-group",
        "Specify a supplementary group. The first specified supplementary group is also used as a primary group if the option -g is not specified.",
        "GROUP",
    );
    opts.optflag("W", "no-wrapper", "don't use ksu fd wrapper");

    // Replace -cn with -z, -mm with -M for supporting getopt_long
    let args = args
        .into_iter()
        .map(|e| {
            if e == "-mm" {
                "-M".to_string()
            } else if e == "-cn" {
                "-z".to_string()
            } else {
                e
            }
        })
        .collect::<Vec<String>>();

    let matches = match opts.parse(&args[1..]) {
        Result::Ok(m) => m,
        Err(f) => {
            println!("{f}");
            print_usage(&program, &opts);
            std::process::exit(-1);
        }
    };

    if matches.opt_present("h") {
        print_usage(&program, &opts);
        return Ok(());
    }

    if matches.opt_present("v") {
        println!("{}:KernelSU", defs::VERSION_NAME);
        return Ok(());
    }

    if matches.opt_present("V") {
        println!("{}", defs::VERSION_CODE);
        return Ok(());
    }

    let shell = matches
        .opt_str("s")
        .unwrap_or_else(|| "/system/bin/sh".to_string());
    let mut is_login = matches.opt_present("l");
    let preserve_env = matches.opt_present("p");
    let mount_master = matches.opt_present("M");
    let use_fd_wrapper = !matches.opt_present("W");

    let groups = matches
        .opt_strs("G")
        .into_iter()
        .map(|g| g.parse::<u32>().map_err(|_| anyhow!("Invalid GID: {g}")))
        .collect::<Result<Vec<_>, _>>()?;

    // if -g provided, use it.
    let mut gid = matches
        .opt_str("g")
        .map(|g| g.parse::<u32>().map_err(|_| anyhow!("Invalid GID: {g}")))
        .transpose()?;

    // otherwise, use the first gid of groups.
    if gid.is_none() && !groups.is_empty() {
        gid = Some(groups[0]);
    }

    // we've make sure that -c is the last option and it already contains the whole command, no need to construct it again
    let args = matches
        .opt_str("c")
        .map(|cmd| vec!["-c".to_string(), cmd])
        .unwrap_or_default();

    let mut free_idx = 0;
    if !matches.free.is_empty() && matches.free[free_idx] == "-" {
        is_login = true;
        free_idx += 1;
    }

    // use current uid if no user specified, these has been done in kernel!
    let mut uid = getuid().as_raw();
    if free_idx < matches.free.len() {
        let name = &matches.free[free_idx];
        uid = unsafe {
            let pw = CString::new(name.as_str())
                .ok()
                .and_then(|c_name| libc::getpwnam(c_name.as_ptr()).as_ref());

            pw.map_or_else(|| name.parse::<u32>().unwrap_or(0), |pw| pw.pw_uid)
        }
    }

    // if there is no gid provided, use uid.
    let gid = gid.unwrap_or(uid);
    // https://github.com/topjohnwu/Magisk/blob/master/native/src/su/su_daemon.cpp#L408
    let arg0 = if is_login { "-" } else { &shell };

    let mut command = &mut Command::new(&shell);

    if !preserve_env {
        // This is actually incorrect, i don't know why.
        // command = command.env_clear();

        let pw = unsafe { libc::getpwuid(uid).as_ref() };

        if let Some(pw) = pw {
            let home = unsafe { CStr::from_ptr(pw.pw_dir) };
            let pw_name = unsafe { CStr::from_ptr(pw.pw_name) };

            let home = home.to_string_lossy();
            let pw_name = pw_name.to_string_lossy();

            command = command
                .env("HOME", home.as_ref())
                .env("USER", pw_name.as_ref())
                .env("LOGNAME", pw_name.as_ref())
                .env("SHELL", &shell);
        }
    }

    // add /data/adb/ksu/bin to PATH
    add_path_to_env(defs::BINARY_DIR)?;

    // when KSURC_PATH exists and ENV is not set, set ENV to KSURC_PATH
    if PathBuf::from(defs::KSURC_PATH).exists() && env::var("ENV").is_err() {
        command = command.env("ENV", defs::KSURC_PATH);
    }

    // escape from the current cgroup and become session leader
    // WARNING!!! This cause some root shell hang forever!
    // command = command.process_group(0);
    command = unsafe {
        command.pre_exec(move || {
            umask(0o22);
            utils::switch_cgroups();

            // switch to global mount namespace
            if mount_master {
                let _ = utils::switch_mnt_ns(1);
            }

            if use_fd_wrapper {
                wrap_tty(0);
                wrap_tty(1);
                wrap_tty(2);
            }

            set_identity(uid, gid, &groups);

            Result::Ok(())
        })
    };

    command = command.args(args).arg0(arg0);
    Err(command.exec().into())
}

fn add_path_to_env(path: &str) -> Result<()> {
    let mut paths =
        env::var_os("PATH").map_or(Vec::new(), |val| env::split_paths(&val).collect::<Vec<_>>());
    let new_path = PathBuf::from(path.trim_end_matches('/'));
    paths.push(new_path);
    let new_path_env = env::join_paths(paths)?;
    unsafe { env::set_var("PATH", new_path_env) };
    Ok(())
}

```

`userspace/ksud/src/utils.rs`:

```rs
use anyhow::{Context, Error, Ok, Result, bail};
use std::{
    fs::{File, OpenOptions, create_dir_all, remove_file, write},
    io::{
        ErrorKind::{AlreadyExists, NotFound},
        Write,
    },
    path::Path,
    process::Command,
};

use crate::{assets, boot_patch, defs, ksucalls, module, restorecon};
#[allow(unused_imports)]
use std::fs::{Permissions, set_permissions};
#[cfg(unix)]
use std::os::unix::prelude::PermissionsExt;

use std::path::PathBuf;

use crate::boot_patch::BootRestoreArgs;

use rustix::{
    process,
    thread::{LinkNameSpaceType, move_into_link_name_space},
};

#[macro_export]
macro_rules! debug_select {
    ($debug:expr, $release:expr) => {{
        #[cfg(debug_assertions)]
        {
            $debug
        }
        #[cfg(not(debug_assertions))]
        {
            $release
        }
    }};
}

pub fn ensure_clean_dir(dir: impl AsRef<Path>) -> Result<()> {
    let path = dir.as_ref();
    log::debug!("ensure_clean_dir: {}", path.display());
    if path.exists() {
        log::debug!("ensure_clean_dir: {} exists, remove it", path.display());
        std::fs::remove_dir_all(path)?;
    }
    Ok(std::fs::create_dir_all(path)?)
}

pub fn ensure_file_exists<T: AsRef<Path>>(file: T) -> Result<()> {
    match File::options().write(true).create_new(true).open(&file) {
        std::result::Result::Ok(_) => Ok(()),
        Err(err) => {
            if err.kind() == AlreadyExists && file.as_ref().is_file() {
                Ok(())
            } else {
                Err(Error::from(err))
                    .with_context(|| format!("{} is not a regular file", file.as_ref().display()))
            }
        }
    }
}

pub fn ensure_dir_exists<T: AsRef<Path>>(dir: T) -> Result<()> {
    let result = create_dir_all(&dir);
    if dir.as_ref().is_dir() && result.is_ok() {
        Ok(())
    } else {
        bail!("{} is not a regular directory", dir.as_ref().display())
    }
}

pub fn ensure_binary<T: AsRef<Path>>(
    path: T,
    contents: &[u8],
    ignore_if_exist: bool,
) -> Result<()> {
    if ignore_if_exist && path.as_ref().exists() {
        return Ok(());
    }

    ensure_dir_exists(path.as_ref().parent().ok_or_else(|| {
        anyhow::anyhow!(
            "{} does not have parent directory",
            path.as_ref().to_string_lossy()
        )
    })?)?;

    if let Err(e) = remove_file(path.as_ref())
        && e.kind() != NotFound
    {
        return Err(Error::from(e))
            .with_context(|| format!("failed to unlink {}", path.as_ref().display()));
    }

    write(&path, contents)?;
    #[cfg(unix)]
    set_permissions(&path, Permissions::from_mode(0o755))?;
    Ok(())
}

pub fn getprop(prop: &str) -> Option<String> {
    android_properties::getprop(prop).value()
}

pub fn is_safe_mode() -> bool {
    let safemode = getprop("persist.sys.safemode")
        .filter(|prop| prop == "1")
        .is_some()
        || getprop("ro.sys.safemode")
            .filter(|prop| prop == "1")
            .is_some();
    log::info!("safemode: {safemode}");
    if safemode {
        return true;
    }
    let safemode = ksucalls::check_kernel_safemode();
    log::info!("kernel_safemode: {safemode}");
    safemode
}

pub fn get_zip_uncompressed_size(zip_path: &str) -> Result<u64> {
    let mut zip = zip::ZipArchive::new(std::fs::File::open(zip_path)?)?;
    let total: u64 = (0..zip.len())
        .map(|i| zip.by_index(i).unwrap().size())
        .sum();
    Ok(total)
}

pub fn switch_mnt_ns(pid: i32) -> Result<()> {
    use rustix::{
        fd::AsFd,
        fs::{Mode, OFlags, open},
    };
    let path = format!("/proc/{pid}/ns/mnt");
    let fd = open(path, OFlags::RDONLY, Mode::from_raw_mode(0))?;
    let current_dir = std::env::current_dir();
    move_into_link_name_space(fd.as_fd(), Some(LinkNameSpaceType::Mount))?;
    if let std::result::Result::Ok(current_dir) = current_dir {
        let _ = std::env::set_current_dir(current_dir);
    }
    Ok(())
}

fn switch_cgroup(grp: &str, pid: u32) {
    let path = Path::new(grp).join("cgroup.procs");
    if !path.exists() {
        return;
    }

    let fp = OpenOptions::new().append(true).open(path);
    if let std::result::Result::Ok(mut fp) = fp {
        let _ = write!(fp, "{pid}");
    }
}

pub fn switch_cgroups() {
    let pid = std::process::id();
    switch_cgroup("/acct", pid);
    switch_cgroup("/dev/cg2_bpf", pid);
    switch_cgroup("/sys/fs/cgroup", pid);

    if getprop("ro.config.per_app_memcg")
        .filter(|prop| prop == "false")
        .is_none()
    {
        switch_cgroup("/dev/memcg/apps", pid);
    }
}

pub fn umask(mask: u32) {
    process::umask(rustix::fs::Mode::from_raw_mode(mask));
}

pub fn has_magisk() -> bool {
    which::which("magisk").is_ok()
}

fn link_ksud_to_bin() -> Result<()> {
    let ksu_bin = PathBuf::from(defs::DAEMON_PATH);
    let ksu_bin_link = PathBuf::from(defs::DAEMON_LINK_PATH);
    if ksu_bin.exists() && !ksu_bin_link.exists() {
        std::os::unix::fs::symlink(&ksu_bin, &ksu_bin_link)?;
    }
    Ok(())
}

pub fn install(magiskboot: Option<PathBuf>) -> Result<()> {
    ensure_dir_exists(defs::ADB_DIR)?;
    std::fs::copy(
        std::env::current_exe().with_context(|| "Failed to get self exe path")?,
        defs::DAEMON_PATH,
    )?;
    restorecon::lsetfilecon(defs::DAEMON_PATH, restorecon::ADB_CON)?;
    // install binary assets
    assets::ensure_binaries(false).with_context(|| "Failed to extract assets")?;

    link_ksud_to_bin()?;

    if let Some(magiskboot) = magiskboot {
        ensure_dir_exists(defs::BINARY_DIR)?;
        let _ = std::fs::copy(magiskboot, defs::MAGISKBOOT_PATH);
    }

    Ok(())
}

pub fn uninstall(magiskboot_path: Option<PathBuf>) -> Result<()> {
    if Path::new(defs::MODULE_DIR).exists() {
        println!("- Uninstall modules..");
        module::uninstall_all_modules()?;
        module::prune_modules()?;
    }
    println!("- Removing directories..");
    std::fs::remove_dir_all(defs::WORKING_DIR).ok();
    std::fs::remove_file(defs::DAEMON_PATH).ok();
    std::fs::remove_dir_all(defs::MODULE_DIR).ok();
    println!("- Restore boot image..");
    boot_patch::restore(BootRestoreArgs {
        boot: None,
        flash: true,
        magiskboot: magiskboot_path,
        out_name: None,
    })?;
    println!("- Uninstall KernelSU manager..");
    Command::new("pm")
        .args(["uninstall", "me.weishu.kernelsu"])
        .spawn()?;
    println!("- Rebooting in 5 seconds..");
    std::thread::sleep(std::time::Duration::from_secs(5));
    Command::new("reboot").spawn()?;
    Ok(())
}

```

`userspace/ksuinit/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.2",
]

[[package]]
name = "goblin"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4db6758c546e6f81f265638c980e5e84dfbda80cfd8e89e02f83454c8e8124bd"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "kernlog"
version = "0.3.1"
source = "git+https://github.com/kstep/kernlog.rs#68caa7bf1e27baea35b00ebba786cafae0bca90f"
dependencies = [
 "libc",
 "log",
]

[[package]]
name = "ksuinit"
version = "2.0.0"
dependencies = [
 "anyhow",
 "goblin",
 "kernlog",
 "log",
 "rustix",
 "scroll",
 "syscalls",
]

[[package]]
name = "libc"
version = "0.2.178"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37c93d8daa9d8a012fd8ab92f088405fb202ea0b6ab73ee2482ae66af4f42091"

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "plain"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6"

[[package]]
name = "proc-macro2"
version = "1.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ee95bc4ef87b8d5ba32e8b7714ccc834865276eab0aed5c9958d00ec45f49e8"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a338cc41d27e6cc6dce6cefc13a0729dfbb81c262b1f519331575dd80ef3067f"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rustix"
version = "0.38.34"
source = "git+https://github.com/Kernel-SU/rustix.git?rev=4a53fbc#4a53fbc7cb7a07cabe87125cc21dbc27db316259"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "scroll"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1257cd4248b4132760d6524d6dda4e053bc648c9070b960929bf50cfb1e7add"
dependencies = [
 "scroll_derive",
]

[[package]]
name = "scroll_derive"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed76efe62313ab6610570951494bdaa81568026e0318eaa55f167de70eeea67d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "syn"
version = "2.0.111"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "390cc9a294ab71bdb1aa2e99d13be9c753cd2d7bd6560c77118597410c4d2e87"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syscalls"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90db46b5b4962319605d435986c775ea45a0ad2561c09e1d5372b89afeb49cf4"

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

```

`userspace/ksuinit/Cargo.toml`:

```toml
[package]
name = "ksuinit"
version = "2.0.0"
edition = "2024"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

# for elf parsing
goblin = "0.10"
scroll = "0.13"

anyhow = "1"
# If you want to use the following dependencies, please use aarch64-unknown-linux-musl & x86_64-unknown-linux-musl to compile statically
# rustix = { git = "https://github.com/bytecodealliance/rustix", rev = "7b44528", features = ["mount", "fs", "runtime", "system", "process"] }
rustix = { git = "https://github.com/Kernel-SU/rustix.git", rev = "4a53fbc", features = ["mount", "fs", "runtime", "system", "process"] }

syscalls = { version = "0.7", default-features = false, features = [
    "aarch64",
    "x86_64",
] }

# for kmsg logging
log = "0.4"
kernlog = { git = "https://github.com/kstep/kernlog.rs" }

[profile.release]
strip = true
lto = true
opt-level = "z"
panic = "abort"

```

`userspace/ksuinit/build.rs`:

```rs
fn main() {
    // Fix getauxval linking issue for aarch64-unknown-linux-musl
    // The compiler_builtins crate needs getauxval from libc, but due to link order
    // issues, we need to link libc again at the end
    let target = std::env::var("TARGET").unwrap();

    if target == "aarch64-unknown-linux-musl" || target == "x86_64-unknown-linux-musl" {
        // Link libc at the end to resolve symbols from compiler_builtins
        println!("cargo:rustc-link-arg=-lc");
    }
}

```

`userspace/ksuinit/src/init.rs`:

```rs
use std::io::{ErrorKind, Write};

use crate::loader::load_module;
use anyhow::Result;
use rustix::fs::{Mode, symlink, unlink};
use rustix::{
    fd::AsFd,
    fs::{Access, CWD, FileType, access, makedev, mkdir, mknodat},
    mount::{
        FsMountFlags, FsOpenFlags, MountAttrFlags, MoveMountFlags, UnmountFlags, fsconfig_create,
        fsmount, fsopen, move_mount, unmount,
    },
};

struct AutoUmount {
    mountpoints: Vec<String>,
}

impl Drop for AutoUmount {
    fn drop(&mut self) {
        for mountpoint in self.mountpoints.iter().rev() {
            if let Err(e) = unmount(mountpoint.as_str(), UnmountFlags::DETACH) {
                log::error!("Cannot umount {}: {}", mountpoint, e)
            }
        }
    }
}

fn mount_filesystem(name: &str, mountpoint: &str) -> Result<()> {
    mkdir(mountpoint, Mode::from_raw_mode(0o755)).or_else(|err| match err.kind() {
        ErrorKind::AlreadyExists => Ok(()),
        _ => Err(err),
    })?;
    let fs_fd = fsopen(name, FsOpenFlags::FSOPEN_CLOEXEC)?;
    fsconfig_create(fs_fd.as_fd())?;
    let mount_fd = fsmount(
        fs_fd.as_fd(),
        FsMountFlags::FSMOUNT_CLOEXEC,
        MountAttrFlags::empty(),
    )?;
    move_mount(
        mount_fd.as_fd(),
        "",
        CWD,
        mountpoint,
        MoveMountFlags::MOVE_MOUNT_F_EMPTY_PATH,
    )?;
    Ok(())
}

fn prepare_mount() -> AutoUmount {
    let mut mountpoints = vec![];

    // mount procfs
    match mount_filesystem("proc", "/proc") {
        Ok(_) => mountpoints.push("/proc".to_string()),
        Err(e) => log::error!("Cannot mount procfs: {:?}", e),
    }

    // mount sysfs
    match mount_filesystem("sysfs", "/sys") {
        Ok(_) => mountpoints.push("/sys".to_string()),
        Err(e) => log::error!("Cannot mount sysfs: {:?}", e),
    }

    AutoUmount { mountpoints }
}

fn setup_kmsg() {
    const KMSG: &str = "/dev/kmsg";
    let device = match access(KMSG, Access::EXISTS) {
        Ok(_) => KMSG,
        Err(_) => {
            // try to create it
            mknodat(
                CWD,
                "/kmsg",
                FileType::CharacterDevice,
                0o666.into(),
                makedev(1, 11),
            )
            .ok();
            "/kmsg"
        }
    };

    let _ = kernlog::init_with_device(device);
}

fn unlimit_kmsg() {
    // Disable kmsg rate limiting
    if let Ok(mut rate) = std::fs::File::options()
        .write(true)
        .open("/proc/sys/kernel/printk_devkmsg")
    {
        writeln!(rate, "on").ok();
    }
}

pub fn init() -> Result<()> {
    // Setup kernel log first
    setup_kmsg();

    log::info!("Hello, KernelSU!");

    // mount /proc and /sys to access kernel interface
    let _dontdrop = prepare_mount();

    // This relies on the fact that we have /proc mounted
    unlimit_kmsg();

    if has_kernelsu() {
        log::info!("KernelSU may be already loaded in kernel, skip!");
    } else {
        log::info!("Loading kernelsu.ko..");
        if let Err(e) = load_module("/kernelsu.ko") {
            log::error!("Cannot load kernelsu.ko: {:?}", e);
        }
    }

    // And now we should prepare the real init to transfer control to it
    unlink("/init")?;

    let real_init = match access("/init.real", Access::EXISTS) {
        Ok(_) => "init.real",
        Err(_) => "/system/bin/init",
    };

    log::info!("init is {}", real_init);
    symlink(real_init, "/init")?;

    Ok(())
}

fn has_kernelsu_legacy() -> bool {
    use syscalls::{Sysno, syscall};
    let mut version = 0;
    const CMD_GET_VERSION: i32 = 2;
    unsafe {
        let _ = syscall!(
            Sysno::prctl,
            0xDEADBEEF,
            CMD_GET_VERSION,
            std::ptr::addr_of_mut!(version)
        );
    }

    log::info!("KernelSU version: {}", version);

    version != 0
}

fn has_kernelsu_v2() -> bool {
    use syscalls::{Sysno, syscall};
    const KSU_INSTALL_MAGIC1: u32 = 0xDEADBEEF;
    const KSU_INSTALL_MAGIC2: u32 = 0xCAFEBABE;
    const KSU_IOCTL_GET_INFO: u32 = 0x80004b02; // _IOC(_IOC_READ, 'K', 2, 0)

    #[repr(C)]
    #[derive(Default)]
    struct GetInfoCmd {
        version: u32,
        flags: u32,
    }

    // Try new method: get driver fd using reboot syscall with magic numbers
    let mut fd: i32 = -1;
    unsafe {
        let _ = syscall!(
            Sysno::reboot,
            KSU_INSTALL_MAGIC1,
            KSU_INSTALL_MAGIC2,
            0,
            std::ptr::addr_of_mut!(fd)
        );
    }

    let version = if fd >= 0 {
        // New method: try to get version info via ioctl
        let mut cmd = GetInfoCmd::default();
        let version = unsafe {
            let ret = syscall!(Sysno::ioctl, fd, KSU_IOCTL_GET_INFO, &mut cmd as *mut _);

            match ret {
                Ok(_) => cmd.version,
                Err(_) => 0,
            }
        };

        unsafe {
            let _ = syscall!(Sysno::close, fd);
        }

        version
    } else {
        0
    };

    log::info!("KernelSU version: {}", version);

    version != 0
}

pub fn has_kernelsu() -> bool {
    has_kernelsu_v2() || has_kernelsu_legacy()
}

```

`userspace/ksuinit/src/loader.rs`:

```rs
use anyhow::{Context, Result};
use goblin::elf::{Elf, section_header, sym::Sym};
use rustix::{cstr, system::init_module};
use scroll::{Pwrite, ctx::SizeWith};
use std::collections::HashMap;
use std::fs;

struct Kptr {
    value: String,
}

impl Kptr {
    pub fn new() -> Result<Self> {
        let value = fs::read_to_string("/proc/sys/kernel/kptr_restrict")?;
        fs::write("/proc/sys/kernel/kptr_restrict", "1")?;
        Ok(Kptr { value })
    }
}

impl Drop for Kptr {
    fn drop(&mut self) {
        let _ = fs::write("/proc/sys/kernel/kptr_restrict", self.value.as_bytes());
    }
}

fn parse_kallsyms() -> Result<HashMap<String, u64>> {
    let _dontdrop = Kptr::new()?;

    let allsyms = fs::read_to_string("/proc/kallsyms")?
        .lines()
        .map(|line| line.split_whitespace())
        .filter_map(|mut splits| {
            splits
                .next()
                .and_then(|addr| u64::from_str_radix(addr, 16).ok())
                .and_then(|addr| splits.nth(1).map(|symbol| (symbol, addr)))
        })
        .map(|(symbol, addr)| {
            (
                symbol
                    .find("$")
                    .or_else(|| symbol.find(".llvm."))
                    .map_or(symbol, |pos| &symbol[0..pos])
                    .to_owned(),
                addr,
            )
        })
        .collect::<HashMap<_, _>>();

    Ok(allsyms)
}

pub fn load_module(path: &str) -> Result<()> {
    // check if self is init process(pid == 1)
    if !rustix::process::getpid().is_init() {
        anyhow::bail!("{}", "Invalid process");
    }

    let mut buffer = fs::read(path).with_context(|| format!("Cannot read file {}", path))?;
    let elf = Elf::parse(&buffer)?;

    let kernel_symbols = parse_kallsyms().context("Cannot parse kallsyms")?;

    let mut modifications = Vec::new();
    for (index, mut sym) in elf.syms.iter().enumerate() {
        if index == 0 {
            continue;
        }

        if sym.st_shndx != section_header::SHN_UNDEF as usize {
            continue;
        }

        let Some(name) = elf.strtab.get_at(sym.st_name) else {
            continue;
        };

        let offset = elf.syms.offset() + index * Sym::size_with(elf.syms.ctx());
        let Some(real_addr) = kernel_symbols.get(name) else {
            log::warn!("Cannot find symbol: {}", &name);
            continue;
        };
        sym.st_shndx = section_header::SHN_ABS as usize;
        sym.st_value = *real_addr;
        modifications.push((sym, offset));
    }

    let ctx = *elf.syms.ctx();
    for ele in modifications {
        buffer.pwrite_with(ele.0, ele.1, ctx)?;
    }
    init_module(&buffer, cstr!("")).context("init_module failed.")?;
    Ok(())
}

```

`userspace/ksuinit/src/main.rs`:

```rs
#![no_main]

mod init;
mod loader;

use rustix::{cstr, runtime::execve};
/// # Safety
/// This is the entry point of the program
/// We cannot use the main because rust will abort if we don't have std{in/out/err}
/// https://github.com/rust-lang/rust/blob/3071aefdb2821439e2e6f592f41a4d28e40c1e79/library/std/src/sys/unix/mod.rs#L80
/// So we use the C main function and call rust code from there
#[unsafe(no_mangle)]
pub unsafe extern "C" fn main(_argc: i32, argv: *const *const u8, envp: *const *const u8) -> i32 {
    let _ = init::init();
    unsafe {
        execve(cstr!("/init"), argv, envp);
    }
    0
}

```

`website/docs/guide/app-profile.md`:

```md
# App Profile

The App Profile is a mechanism provided by KernelSU for customizing the configuration of various apps.

For apps granted root permissions (i.e., able to use `su`), the App Profile can also be referred to as the Root Profile. It allows customization of the `uid`, `gid`, `groups`, `capabilities`, and `SELinux` rules of the `su` command, thereby restricting the privileges of the root user. For example, it can grant network permissions only to firewall apps while denying file access permissions, or it can grant shell permissions instead of full root access for freeze apps: **keeping the power confined with the principle of least privilege.**

For ordinary apps without root permissions, the App Profile can control the behavior of the kernel and module system towards these apps. For instance, it can determine whether modifications resulting from modules should be addressed. The kernel and module system can make decisions based on this configuration, such as performing operations akin to "hiding".

## Root Profile

### UID, GID, and Groups

Linux systems have two concepts: users and groups. Each user has a user ID (UID), and a user can belong to multiple groups, each with its own group ID (GID). These IDs are used to identify users in the system and determine which system resources they can access.

Users with a UID of 0 are known as root users, and groups with a GID of 0 are known as root groups. The root user group generally has the highest system privileges.

In the case of the Android system, each app functions as a separate user (except in cases of shared UIDs) with a unique UID. For example, `0` represents the root user, `1000` represents `system`, `2000` represents the ADB shell, and UIDs ranging from `10000` to `19999` represent ordinary apps.

::: info
Here, the UID mentioned isn't the same as the concept of multiple users or work profiles in the Android system. Work profiles are actually implemented by partitioning the UID range. For example, 10000-19999 represents the main user, while 110000-119999 represents a work profile. Each ordinary app among them has its own unique UID.
:::

Each app can have several groups, with the GID representing the primary group, which usually matches the UID. Other groups are known as supplementary groups. Certain permissions are controlled through groups, such as network access permissions or Bluetooth access.

For example, if we execute the `id` command in ADB shell, the output might look like this:

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

Here, the UID is `2000`, and the GID (primary group ID) is also `2000`. Additionally, it belongs to several supplementary groups, such as `inet` (indicating the ability to create `AF_INET` and `AF_INET6` sockets) and `sdcard_rw` (indicating read/write permissions for the SD card).

KernelSU's Root Profile allows customization of the UID, GID, and groups for the root process after executing `su`. For example, the Root Profile of a root app can set its UID to `2000`, which means that when using `su`, the app's actual permissions are at the ADB shell level. Additionally, the `inet` group can be removed, preventing the `su` command from accessing the network.

::: tip NOTE
The App Profile only controls the permissions of the root process after using `su` and doesn't control the app's own permissions. If an app has requested network access permission, it can still access the network even without using `su`. Removing the `inet` group from `su` only prevents `su` from accessing the network.
:::

Root Profile is enforced in the kernel and doesn't rely on the voluntary behavior of root apps, unlike switching users or groups through `su`. Granting `su` permissions is entirely controlled by the user, not the developer.

### Capabilities

Capabilities are a mechanism for privilege separation in Linux.

For the purpose of performing permission checks, traditional `UNIX` implementations distinguish two categories of processes: privileged processes (whose effective user ID is `0`, referred to as superuser or root) and unprivileged processes (whose effective UID is nonzero). Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (usually: effective UID, effective GID, and supplementary group list).

Starting with Linux 2.2, Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled.

Each capability represents one or more privileges. For example, `CAP_DAC_READ_SEARCH` represents the ability to bypass permission checks for file reading, as well as directory read and execute permissions. If a user with an effective UID of `0` (root user) doesn't have the `CAP_DAC_READ_SEARCH` capability or higher, this means that even as root, they cannot freely read files.

KernelSU's Root Profile allows customization of the capabilities of the root process after executing `su`, thus granting partial "root privileges". Unlike the UID and GID mentioned above, certain root apps require a UID of `0` after using `su`. In such cases, limiting the capabilities of this root user with UID `0` can restrict the operations they're allowed to perform.

::: tip STRONG RECOMMENDATION
Linux's capability [official documentation](https://man7.org/linux/man-pages/man7/capabilities.7.html) provides detailed explanations of the abilities represented by each capability. If you intend to customize capabilities, it's strongly recommended that you read this document first.
:::

### SELinux

SELinux is a powerful Mandatory Access Control (MAC) mechanism. It operates on the principle of **default deny**. Any action not explicitly allowed is denied.

SELinux can run in two global modes:

1. Permissive mode: Denial events are logged, but not enforced.
2. Enforcing mode: Denial events are logged and enforced.

::: warning
Modern Android systems heavily rely on SELinux to ensure overall system security. It's highly recommended not to use any custom systems running in "Permissive mode" since it provides no significant advantages over a completely open system.
:::

Explaining the full concept of SELinux is complex and beyond the scope of this document. It's recommended to first understand how it works through the following resources:

1. [Wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Red Hat: What Is SELinux?](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

KernelSU's Root Profile allows customization of the SELinux context of the root process after executing `su`. Specific access control rules can be set for this context, enabling fine-grained control over root permissions.

In typical scenarios, when an app executes `su`, it switches the process to a SELinux domain with **unrestricted access**, such as `u:r:su:s0`. Through the Root Profile, this domain can be switched to a custom domain, such as `u:r:app1:s0`, and a series of rules can be defined for this domain:

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

Note that the `allow app1 * * *` rule is used for demonstration purposes only. In practice, this rule shouldn't be used extensively, as it isn't much different from Permissive mode.

### Escalation

If the configuration of the Root Profile isn't set properly, an escalation scenario may occur. The restrictions imposed by the Root Profile can unintentionally fail.

For example, if you grant root permission to an ADB shell user (which is a common case) and then grant root permission to a regular app, but configure its Root Profile with UID 2000 (which is the UID of the ADB shell user), the app can obtain full root access by executing the `su` command twice:

1. The first execution of `su` will be subject to the App Profile and will switch to UID `2000` (ADB shell) instead of `0` (root).
2. The second execution of `su`, since the UID is `2000` and root access has been granted to UID `2000` (ADB shell) in the configuration, the app will gain full root privileges.

::: warning NOTE
This behavior is fully expected and isn't a bug. Therefore, we recommend the following:

If you genuinely need to grant root permissions to ADB (e.g., as a developer), it isn't advisable to change the UID to `2000` when configuring the Root Profile. Using `1000` (system) would be a better choice.
:::

## Non-root profile

### Umount modules

KernelSU provides a systemless mechanism to modify system partitions, achieved through the mounting of OverlayFS. However, some apps may be sensitive to this behavior. In this case, we can unload modules mounted in these apps by setting the "Umount modules" option.

Additionally, the KernelSU manager's settings interface provides the "Umount modules by default". By default, this option is **enabled**, which means that KernelSU or some modules will unload modules for this app unless additional settings are applied. If you don't prefer this setting or if it affects certain apps, you have the following options:

1. Keep the "Umount modules by default" option enabled and individually disable the "Umount modules" option in the App Profile for apps requiring module loading (acting as a "whitelist").
2. Disable the "Umount modules by default" option and individually enable the "Umount modules" option in the App Profile for apps requiring module loading (acting as a "blacklist").

::: info
In devices running kernel version 5.10 and above, the kernel performs without any further action the unloading of modules. However, for devices running kernel versions below 5.10, this option is merely a configuration setting, and KernelSU itself doesn't take any action. If you want to use the "Umount modules" option in kernel versions before 5.10 you need to backport the `path_umount` function in `fs/namespace.c`. You can get more information at the end of the [Integrate for non-GKI devices](https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#how-to-backport-path_umount) page. Some modules, such as Zygisksu, may also use this option to determine if module unloading is necessary.
:::

```

`website/docs/guide/difference-with-magisk.md`:

```md
# Difference with Magisk

Although KernelSU and Magisk modules have many similarities, there are inevitably some differences due to their completely different implementation mechanisms. If you want your module to work on both Magisk and KernelSU, it's essential to understand these differences.

## Similarities

- Module file format: Both use the ZIP format to organize modules, and the module format is practically the same.
- Module installation directory: Both are located at `/data/adb/modules`.
- Systemless: Both support modifying `/system` in a systemless way through modules.
- post-fs-data.sh: Execution time and semantics are exactly the same.
- service.sh: Execution time and semantics are exactly the same.
- system.prop: Completely the same.
- sepolicy.rule: Completely the same.
- BusyBox: Scripts are run in BusyBox with "Standalone Mode" enabled in both cases.

## Differences

Before understanding the differences, it's important to know how to identify whether your module is running in KernelSU or Magisk. You can use the environment variable `KSU` to differentiate it in all places where you can run module scripts (`customize.sh`, `post-fs-data.sh`, `service.sh`). In KernelSU, this environment variable will be set to `true`.

Here are some differences:

- KernelSU modules cannot be installed in Recovery mode.
- KernelSU modules don't have built-in support for Zygisk, but you can use Zygisk modules through [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).
- **Module mounting architecture**: KernelSU uses a [metamodule system](metamodule.md) where mounting is delegated to pluggable metamodules (e.g., `meta-overlayfs`), while Magisk has mounting built into its core. KernelSU requires installing a metamodule to enable module mounting.
- The method for replacing or deleting files in KernelSU modules is completely different from Magisk. KernelSU doesn't support the `.replace` method. Instead, you need to create a same-named file with `mknod filename c 0 0` to delete the corresponding file.
- The directories for BusyBox are different. The built-in BusyBox in KernelSU is located at `/data/adb/ksu/bin/busybox`, while in Magisk it is at `/data/adb/magisk/busybox`. **Note that this is an internal behavior of KernelSU and may change in the future!**
- KernelSU doesn't support `.replace` files, but it supports the `REMOVE` and `REPLACE` variables to remove or replace files and folders.
- KernelSU adds the `boot-completed` stage to run scripts after the boot process is finished.
- KernelSU adds the `post-mount` stage to run scripts after module mounting is complete.

```

`website/docs/guide/faq.md`:

```md
# FAQ

## Does KernelSU support my device?

KernelSU supports devices running Android with an unlocked bootloader. However, official support is only for GKI Linux Kernels 5.10+ (in practice, this means your device needs to have Android 12 out-of-the-box to be supported).

You can easily check the support for your device through the KernelSU manager, which is available [here](https://github.com/tiann/KernelSU/releases). 

If the app shows `Not installed`, it means your device is officially supported by KernelSU.

If the app shows `Unsupported`, it means your device isn't officially supported at present. However, you can build kernel source code and integrate KernelSU to make it work, or use [Unofficially supported devices](unofficially-support-devices).

## Do I need to unlock the bootloader to use KernelSU?

Yes. KernelSU requires an unlocked bootloader.

## Does KernelSU support modules?

Yes, most Magisk modules work on KernelSU. However, if your module needs to modify `/system` files, you need to install a [metamodule](metamodule.md) (such as `meta-overlayfs`). Other module features work without a metamodule. Check [Module guide](module.md) for more info.

## Does KernelSU support Xposed?

Yes, you can use LSPosed (or other modern Xposed derivative) with [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).

## Does KernelSU support Zygisk?

KernelSU has no built-in Zygisk support, but you can use a module like [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) to support it.

## Is KernelSU compatible with Magisk?

KernelSU's module system conflicts with Magisk's magic mount. If any module is enabled in KernelSU, Magisk will stop working entirely.

However, if you only use the `su` of KernelSU, it will work well with Magisk. KernelSU modifies the `kernel`, while Magisk modifies the `ramdisk`, allowing both to work together.

## Will KernelSU substitute Magisk?

No. Replacing Magisk isn't our goal. Magisk is already an excellent userspace root solution. KernelSU focuses on exposing kernel interfaces to users instead of supplanting Magisk.

## Can KernelSU support non-GKI devices?

It's possible. But you should download the kernel source, integrate KernelSU into the source tree, and compile the kernel yourself.

## Can KernelSU support devices below Android 12?

It's the device's kernel that affects KernelSU's compatibility, and it has nothing to do with the Android version. The only restriction is that devices launched with Android 12 must have a kernel version of 5.10+ (GKI devices). So:

1. Devices launched with Android 12 must be supported.
2. Devices with an older kernel (some devices with Android 12 also have the older kernel) are compatible (you should build kernel yourself).

## Can KernelSU support old kernel?

It's possible. KernelSU is backported to kernel 4.14 now. For older kernels, you need to backport it manually, and PRs are always welcome!

## How to integrate KernelSU for an older kernel?

Please check the [Integrate for non-GKI devices](how-to-integrate-for-non-gki) guide.

## Why my Android version is 13, and the kernel shows "android12-5.10"?

The kernel version has nothing to do with the Android version. If you need to flash kernel, always use the kernel version; the Android version isn't as important.

## I'm GKI 1.0, can I use this?

GKI 1.0 is completely different from GKI 2.0, you must compile kernel by yourself.

## How can I make `/system` RW?

We don't recommend that you modify the system partition directly. Please check [Module guide](module.md) to modify it systemlessly. If you insist on doing this, check [magisk_overlayfs](https://github.com/HuskyDG/magic_overlayfs).

## Can KernelSU modify hosts? How can I use AdAway？

Of course. But KernelSU doesn't have built-in hosts support, you can install a module like [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module) to do it.

## Why aren't my modules working after fresh install?

If your modules need to modify `/system` files, you need to install a [metamodule](metamodule.md) to mount the `system` directory. Other module features (scripts, sepolicy, system.prop) work without a metamodule.

**Solution**: See the [Metamodule Guide](metamodule.md) for installation instructions.

## What is a metamodule and why do I need one?

A metamodule is a special module that provides infrastructure for mounting regular modules. See the [Metamodule Guide](metamodule.md) for a complete explanation.

```

`website/docs/guide/hidden-features.md`:

```md
# Hidden features

## .ksurc

By default, `/system/bin/sh` loads `/system/etc/mkshrc`.

You can make su load customized rc file by creating a `/data/adb/ksu/.ksurc` file.

```

`website/docs/guide/how-to-build.md`:

```md
# How to build

::: warning
This document is for archival reference only and is no longer maintained.
Since KernelSU v3.0, we have dropped official support for GKI image mode for faster iteration and build speed. It is recommended to use `Ylarod/ddk` to build LKM.
:::

First, you should read the official Android documentation for building kernels:

1. [Build kernels](https://source.android.com/docs/setup/build/building-kernels)
2. [GKI release builds](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

::: warning
This page is for GKI devices; if you use an older kernel, please refer to [Integrate for non-GKI devices](how-to-integrate-for-non-gki).
:::

## Build kernel

### Sync the kernel source code

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

The `<kernel_manifest.xml>` file is a manifest that uniquely identifies a build, allowing you to make it reproducible. To do this, you should download the manifest file from [GKI release builds](https://source.android.com/docs/core/architecture/kernel/gki-release-builds).

### Build

Please check the [Building kernels](https://source.android.com/docs/setup/build/building-kernels) first.

For example, to build an `aarch64` kernel image:

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

Don't forget to add the `LTO=thin` flag; otherwise, the build may fail if your computer has less than 24 GB of memory.

Starting from Android 13, the kernel is built by `bazel`:

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

::: info
For some Android 14 kernels, to make Wi-Fi/Bluetooth work, it might be necessary to remove all GKI protected exports:

```sh
rm common/android/abi_gki_protected_exports_*
```
:::

## Build kernel with KernelSU

If you can successfully build the kernel, adding support for KernelSU will be relatively easy. In the root of kernel source directory, run any of the options listed below:

::: code-group

```sh[Latest tag (stable)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

```sh[main branch (dev)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

```sh[Select tag (such as v0.5.2)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

:::

Then, rebuild the kernel and you will get a kernel image with KernelSU!

```

`website/docs/guide/how-to-integrate-for-non-gki.md`:

```md
# Integrate for non-GKI devices

::: warning
This document is for archival reference only and is no longer maintained.
Since KernelSU v1.0, we have dropped official support for non-GKI devices.
:::

KernelSU can be integrated into non-GKI kernels and was backported to 4.14 and earlier versions.

Due to the fragmentation of non-GKI kernels, we don't have a universal way to build them; therefore, we cannot provide a non-GKI boot.img. However, you can build the kernel with KernelSU integrated on your own.

First, you should be able to build a bootable kernel from kernel source code. If the kernel isn't open source, then it is difficult to run KernelSU for your device.

If you're able to build a bootable kernel, there are two ways to integrate KernelSU into the kernel source code:

1. Automatically with `kprobe`
2. Manually

## Integrate with kprobe

KernelSU uses kprobe for its kernel hooks. If kprobe runs reliably on your kernel, we recommend integrating KernelSU this way.

First, add KernelSU to your kernel source tree:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

::: info
[KernelSU 1.0 and later versions no longer support non-GKI kernels](https://github.com/tiann/KernelSU/issues/1705). The last supported version is `v0.9.5`, so make sure to use the correct version.
:::

Then, you should check if kprobe is enabled in your kernel config. If it isn't, add these configs to it:

```txt
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

Now, when you re-build your kernel, KernelSU should work correctly.

If you find that KPROBES is still not enabled, you can try enabling `CONFIG_MODULES`. If that doesn't solve the issue, use `make menuconfig` to search for other KPROBES dependencies.

However, if you encounter a bootloop after integrating KernelSU, this may indicate that the **kprobe is broken in your kernel**, which means that you should fix the kprobe bug or use another way.

::: tip HOW TO CHECK IF KPROBE IS BROKEN？
Comment out `ksu_sucompat_init()` and `ksu_ksud_init()` in `KernelSU/kernel/ksu.c`. If the device boots normally, kprobe may be broken.
:::

::: info HOW TO GET MODULE UMOUNT FEATURE WORKING ON PRE-GKI?
If your kernel is older than 5.9, you should backport `path_umount` to `fs/namespace.c`. This is required to get "Umount module" feature work correctly. If you don't backport `path_umount`, "Umount module" feature won't work. You can get more info on how to achieve this at the end of this page.
:::

## Manually modify the kernel source

If kprobe doesn't work on your kernel—either because of an upstream bug or because your kernel is older than 4.8—you can try the following approach:

First, add KernelSU to your kernel source tree:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

Keep in mind that, on some devices, your defconfig may be located at `arch/arm64/configs` or in other cases, it may be at `arch/arm64/configs/vendor/your_defconfig`. Regardless of the defconfig you're using, make sure to enable `CONFIG_KSU` with `y` to enable or `n` to disable it. For example, if you choose to enable it, your defconfig should contain the following string:

```txt
# KernelSU
CONFIG_KSU=y
```

Next, add KernelSU calls to the kernel source. Below are some patches for reference:

::: code-group

```diff[exec.c]
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
+#endif
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
+   #endif
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff[open.c]
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
+#endif
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff[read_write.c]
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);

+#ifdef CONFIG_KSU
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
+#endif
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
+   #ifdef CONFIG_KSU 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+   #endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff[stat.c]
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;

+   #ifdef CONFIG_KSU
+	ksu_handle_stat(&dfd, &filename, &flags);
+   #endif
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```

:::

You should find the four functions in kernel source:

1. `do_faccessat`, usually in `fs/open.c`
2. `do_execveat_common`, usually in `fs/exec.c`
3. `vfs_read`, usually in `fs/read_write.c`
4. `vfs_statx`, usually in `fs/stat.c`

If your kernel doesn't have the `vfs_statx` function, use `vfs_fstatat` instead:

```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
+   #ifdef CONFIG_KSU 
+	ksu_handle_stat(&dfd, &filename, &flag);
+   #endif
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

For kernels eariler than 4.17, if you cannot find `do_faccessat`, just go to the definition of the `faccessat` syscall and place the call there:

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+#endif
+
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

### Safe Mode

To enable KernelSU's built-in Safe Mode, you should modify the `input_handle_event` function in `drivers/input/input.c`:

::: tip
It's strongly recommended to enable this feature, it's very useful for preventing bootloops!
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+#endif
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
+   #endif
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

::: info ENTERING SAFE MODE ACCIDENTALLY?
If you're using manual integration and don't disable `CONFIG_KPROBES`, the user will be able to trigger Safe Mode by pressing the volume down button after booting! Therefore, if you're using manual integration, it's necessary to disable `CONFIG_KPROBES`!
:::

### Failed to execute `pm` in terminal?

You should modify `fs/devpts/inode.c`. Reference:

```diff
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index 32f6f1c68..d69d8eca2 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -602,6 +602,8 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
        return dentry;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_devpts(struct inode*);
+#endif
+
 /**
  * devpts_get_priv -- get private data for a slave
  * @pts_inode: inode of the slave
@@ -610,6 +612,7 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
  */
 void *devpts_get_priv(struct dentry *dentry)
 {
+       #ifdef CONFIG_KSU
+       ksu_handle_devpts(dentry->d_inode);
+       #endif
        if (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)
                return NULL;
        return dentry->d_fsdata;
```

### How to backport path_umount

You can make the "Umount modules" feature work on pre-GKI kernels by manually backporting `path_umount` from 5.9. You can use this patch as reference:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

Finally, build your kernel again, and KernelSU should work correctly.

```

`website/docs/guide/installation.md`:

```md
# Installation

## Check if your device is supported

Download KernelSU manager from [GitHub Releases](https://github.com/tiann/KernelSU/releases) and install it on your device:

- If the app shows `Unsupported`, it means that **you should compile the kernel yourself**, KernelSU won't and never provide a boot.img file for you to flash.
- If the app shows `Not installed`, then your device is officially supported by KernelSU.

::: info
For devices showing `Unsupported`, you can check the list of [Unofficially supported devices](unofficially-support-devices.md). You can compile the kernel yourself.
:::

## Backup stock boot.img

Before flashing, it's essential that you back up your stock boot.img. If you encounter any bootloop, you can always restore the system by flashing back to the stock factory boot using fastboot.

::: warning
Flashing may cause data loss. Make sure to do this step well before proceeding to the next step! You can also back up all the data on your device if necessary.
:::

## Necessary knowledge

### ADB and fastboot

By default, you will use ADB and fastboot tools in this tutorial, so if you don't know them, we recommend using a search engine to learn about them first.

### KMI

Kernel Module Interface (KMI), kernel versions with the same KMI are **compatible**, this is what "general" means in GKI; conversely, if the KMI is different, then these kernels aren't compatible with each other, and flashing a kernel image with a different KMI than your device may cause a bootloop.

Specifically, for GKI devices, the kernel version format should be as follows:

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

`w.x-zzz-k` is the KMI version. For example, if a device kernel version is `5.10.101-android12-9-g30979850fc20`, then its KMI is `5.10-android12-9`. Theoretically, it can boot up normally with other KMI kernels.

::: tip
Note that the SubLevel in the kernel version isn't part of the KMI! This means that `5.10.101-android12-9-g30979850fc20` has the same KMI as `5.10.137-android12-9-g30979850fc20`!
:::

### Security patch level {#security-patch-level}

Newer Android devices may have anti-rollback mechanisms that prevent flashing a boot image with an old security patch level. For example, if your device kernel is `5.10.101-android12-9-g30979850fc20`, the security patch level is `2023-11`; even if you flash the kernel corresponding to the KMI, if the security patch level is older than `2023-11` (such as `2023-06`), it may cause a bootloop.

Therefore, kernels with latest security patch levels are preferred to maintain compatibility with the KMI.

### Kernel version vs Android version

Please note: **Kernel version and Android version aren't necessarily the same!**

If you find that your kernel version is `android12-5.10.101`, but your Android system version is Android 13 or other, don't be surprised, because the version number of the Android system isn't necessarily the same as the version number of the Linux kernel. The version number of the Linux kernel is generally correspondent to the version of the Android system that comes with the **device when it is shipped**. If the Android system is upgraded later, the kernel version will generally not change. So, before flashing anything, **always refer to the kernel version!**

## Introduction

Since version [0.9.0](https://github.com/tiann/KernelSU/releases/tag/v0.9.0), KernelSU supports two running modes on GKI devices:

1. `GKI`: Replace the original kernel of the device with the **Generic Kernel Image** (GKI) provided by KernelSU.
2. `LKM`: Load the **Loadable Kernel Module** (LKM) into the device kernel without replacing the original kernel.

These two modes are suitable for different scenarios, and you can choose the one according to your needs.

### GKI mode {#gki-mode}

In GKI mode, the original kernel of the device will be replaced with the generic kernel image provided by KernelSU. The advantages of GKI mode are:

1. Strong universality, suitable for most devices. For example, Samsung has enabled KNOX devices, and LKM mode cannot work. There are also some niche modified devices that can only use GKI mode.
2. Can be used without relying on official firmware, and there is no need to wait for official firmware updates, as long as the KMI is consistent, it can be used.

### LKM mode {#lkm-mode}

In LKM mode, the original kernel of the device won't be replaced, but the loadable kernel module will be loaded into the device kernel. The advantages of LKM mode are:

1. Won't replace the original kernel of the device. If you have special requirements for the original kernel of the device, or you want to use KernelSU while using a third-party kernel, you can use LKM mode.
2. It's more convenient to upgrade and OTA. When upgrading KernelSU, you can directly install it in the manager without flashing manually. After the system OTA, you can directly install it to the second slot without manual flashing.
3. Suitable for some special scenarios. For example, LKM can also be loaded with temporary root permissions. Since it doesn't need to replace the boot partition, it won't trigger AVB and won't cause the device to be bricked.
4. LKM can be temporarily uninstalled. If you want to temporarily disable root access, you can uninstall LKM. This process doesn't require flashing partitions, or even rebooting the device. If you want to enable root again, just reboot the device.

::: tip COEXISTENCE OF TWO MODES
After opening the manager, you can see the current mode of the device on the homepage. Note that the priority of GKI mode is higher than that of LKM. For example, if you use GKI kernel to replace the original kernel, and use LKM to patch the GKI kernel, the LKM will be ignored, and the device will always run in GKI mode.
:::

### Which one to choose? {#which-one}

If your device is a mobile phone, we recommend that you prioritize LKM mode. If your device is an emulator, WSA, or Waydroid, we recommend that you prioritize GKI mode.

## LKM installation

### Get the official firmware

To use LKM mode, you need to get the official firmware and patch it based on the official firmware. If you use a third-party kernel, you can use the `boot.img` of the third-party kernel as the official firmware.

There are many ways to get the official firmware. If your device supports `fastboot boot`, we recommend **the most recommended and simplest** method is to use `fastboot boot` to temporarily boot the GKI kernel provided by KernelSU, then install the manager, and finally install it directly in the manager. This method doesn't require manually downloading the official firmware or manually extracting the boot.

If your device doesn't support `fastboot boot`, you may need to manually download the official firmware package and extract the boot from it.

Unlike GKI mode, LKM mode modifies the `ramdisk`. Therefore, on devices with Android 13, it needs to patch the `init_boot` partition instead of the `boot` partition, while GKI mode always operates on the `boot` partition.

### Use the manager

Open the manager, click the installation icon in the upper right corner, and several options will appear:

1. Select a file. If your device doesn't have root privileges, you can choose this option and then select your official firmware. The manager will automatically patch it. After that, just flash this patched file to obtain root privileges permanently.
2. Direct install. If your device is already rooted, you can choose this option. The manager will automatically get your device information, and then automatically patch the official firmware, and flash it automatically. You can consider using `fastboot boot` KernelSU's GKI kernel to get temporary root and install the manager, and then use this option. This is also the main way to upgrade KernelSU.
3. Install to inactive slot. If your device supports A/B partition, you can choose this option. The manager will automatically patch the official firmware and install it to another partition. This method is suitable for devices after OTA, you can directly install it to another partition after OTA, and then restart the device.

### Use the command line

If you don't want to use the manager, you can also use the command line to install LKM. The `ksud` tool provided by KernelSU can help you quickly patch the official firmware and then flash it.

This tool supports macOS, Linux, and Windows. You can download the corresponding version from [GitHub Release](https://github.com/tiann/KernelSU/releases).

Usage: `ksud boot-patch` you can check the command line help for specific options.

```sh
oriole:/ # ksud boot-patch -h
Patch boot or init_boot images to apply KernelSU

Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              Boot image path. If not specified, it will try to find the boot image automatically
  -k, --kernel <KERNEL>          Kernel image path to be replaced
  -m, --module <MODULE>          LKM module path to be replaced. If not specified, the built-in module will be used
  -i, --init <INIT>              init to be replaced
  -u, --ota                      Will use another slot if the boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                Output path. If not specified, the current directory will be used
      --magiskboot <MAGISKBOOT>  magiskboot path. If not specified, the built-in version will be used
      --kmi <KMI>                KMI version. If specified, the indicated KMI will be used
  -h, --help                     Print help
```

A few options that need to be explained:

1. The `--magiskboot` option can specify the path of magiskboot. If not specified, ksud will look for it in the environment variables. If you don’t know how to get magiskboot, you can check [here](#patch-boot-image).
2. The `--kmi` option can specify the `KMI` version. If the kernel name of your device doesn't follow the KMI specification, you can specify it using this option.

The most common usage is:

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## GKI mode installation

There are several installation methods for GKI mode, each suitable for a different scenario, so please choose accordingly:

1. Install with fastboot using the boot.img provided by KernelSU.
2. Install with a kernel flash app, such as [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases).
3. Repair the boot.img manually and install it.
4. Install with custom Recovery (e.g., TWRP).

## Install with boot.img provided by KernelSU

If your device's `boot.img` uses a commonly used compression format, you can use the GKI images provided by KernelSU to flash it directly. This doesn't require TWRP or self-patching the image.

### Find proper boot.img

KernelSU provides a generic boot.img for GKI devices, and you should flash the boot.img to the device's boot partition.

You can download boot.img from [GitHub Release](https://github.com/tiann/KernelSU/releases). Please note that you should use the correct version of boot.img. If you don't know which file to download, carefully read the description of [KMI](#kmi) and [Security patch level](#security-patch-level) in this document.

Normally, there are three boot files in different formats for the same KMI and security patch level. They're identical except for the kernel compression format. Please check the kernel compression format of your original boot.img. You should use the correct format, such as `lz4`, `gz`. If you use an incorrect compression format, you may encounter bootloop after flashing boot.img.

::: info COMPRESSION FORMAT OF BOOT.IMG
1. You can use magiskboot to get the compression format of your original boot.img. Alternatively, you can also ask members or developers in the community who have the same device model. Also, the compression format of the kernel usually doesn't change, so if you boot successfully with a certain compression format, you can try that format later as well.
2. Xiaomi devices usually use `gz` or `uncompressed`.
3. For Pixel devices, follow the instructions below:
:::

### Flash boot.img to device

Use `adb` to connect your device, then execute `adb reboot bootloader` to enter fastboot mode, and use this command to flash KernelSU:

```sh
fastboot flash boot boot.img
```

::: info
If your device supports `fastboot boot`, you can first use `fastboot boot boot.img` to try to use boot.img to boot the system first. If something unexpected happens, restart it again to boot.
:::

### Reboot

After the flash is completed, you should reboot your device:

```sh
fastboot reboot
```

## Install with Kernel Flasher

Steps:

1. Download the AnyKernel3 ZIP. If you don't know which file to download, carefully read the description of [KMI](#kmi) and [Security patch level](#security-patch-level) in this document.
2. Open the Kernel Flasher app, grant necessary root permissions, and use the provided AnyKernel3 ZIP to flash.

This way requires the Kernel Flasher app to have root permissions. You can use the following methods to achieve this:

1. Your device is rooted. For example, you have installed KernelSU and want to upgrade to the latest version or you have rooted through other methods (such as Magisk).
2. If your device isn't rooted, but the device supports the temporary boot method of `fastboot boot boot.img`, you can use the GKI image provided by KernelSU to temporarily boot your device, obtain temporary root permissions, and then use the Kernel Flash app to obtain permanent root privileges.

Some of kernel flashing apps that can be used for this:

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

Note: This method is more convenient when upgrading KernelSU and can be done without a computer (make a backup first).

## Patch boot.img manually {#patch-boot-image}

For some devices, the boot.img format isn't as common as `lz4`, `gz`, and `uncompressed`. A typical example is the Pixel, where the boot.img is compressed in the `lz4_legacy` format, while the, ramdisk may be in `gz` or also compressed in `lz4_legacy`. Currently, if you directly flash the boot.img provided by KernelSU, the device may not be able to boot. In this case, you can manually patch the boot.img to achieve this.

It's always recommended to use `magiskboot` to patch images, there are two ways:

1. [magiskboot](https://github.com/topjohnwu/Magisk/releases)
2. [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci)

The official build of `magiskboot` can only run on Android devices, if you want to run it on PC, you can try the second option.

::: tip
Android-Image-Kitchen isn't recommended for now because it doesn't handle the boot metadata (such as security patch level) correctly. Therefore, it may not work on some devices.
:::

### Preparation

1. Get your device's stock boot.img. You can get it from your device manufacturers. You may need [payload-dumper-go](https://github.com/ssut/payload-dumper-go).
2. Download the AnyKernel3 ZIP file provided by KernelSU that matches the KMI version of your device. You can refer to [Install with custom Recovery](#install-with-custom-recovery).
3. Unpack the AnyKernel3 package and get the `Image` file, which is the kernel file of KernelSU.

### Using magiskboot on Android devices {#using-magiskboot-on-Android-devices}

1. Download latest Magisk from [GitHub Releases](https://github.com/topjohnwu/Magisk/releases).
2. Rename `Magisk-*(version).apk` to `Magisk-*.zip` and unzip it.
3. Push `Magisk-*/lib/arm64-v8a/libmagiskboot.so` to your device by ADB: `adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`
4. Push stock boot.img and Image in AnyKernel3 to your device.
5. Enter ADB shell and run `cd /data/local/tmp/` directory, then `chmod +x magiskboot`
6. Enter ADB shell and run `cd /data/local/tmp/` directory, execute `./magiskboot unpack boot.img` to unpack `boot.img`, you will get a `kernel` file, this is your stock kernel.
7. Replace `kernel` with `Image` by running the command: `mv -f Image kernel`.
8. Execute `./magiskboot repack boot.img` to repack boot image, and you will get a `new-boot.img` file, flash this file to device by fastboot.

### Using magiskboot on Windows/macOS/Linux PC {#using-magiskboot-on-PC}

1. Download the corresponding `magiskboot` binary for your OS from [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci).
2. Prepare stock `boot.img` and `Image` in your PC.
3. Run `chmod +x magiskboot`.
4. Enter the corresponding directory, execute `./magiskboot unpack boot.img` to unpack `boot.img`, you will get a `kernel` file, this is your stock kernel.
5. Replace `kernel` with `Image` by running the command: `mv -f Image kernel`.
6. Execute `./magiskboot repack boot.img` to repack the boot image, and you will get a `new-boot.img` file, flash this file to device by fastboot.

::: info
Official `magiskboot` can run in `Linux` environments normally, if you're a Linux user, you can use the official build.
:::

## Install with custom Recovery {#install-with-custom-recovery}

Prerequisite: Your device must have a custom Recovery, such as TWRP. If there is no custom Recovery available for your device, use another method.

Steps:

1. On [GitHub Releases](https://github.com/tiann/KernelSU/releases), download the ZIP package starting with `AnyKernel3` that matches your device's version. For example, if the device's kernel version is `android12-5.10.66`, then you should download the `AnyKernel3-android12-5.10.66_yyyy-MM.zip` file (where `yyyy` is the year and `MM` is the month).
2. Reboot the device into TWRP.
3. Use ADB to place AnyKernel3-*.zip into the device's `/sdcard` location and choose to install it in the TWRP GUI, or you can directly run `adb sideload AnyKernel-*.zip` to install.

Note: This method is suitable for any installation (not limited to initial installation or subsequent upgrades), as long as you're using TWRP.

## Other methods

In fact, all of these installation methods have only one main idea, which is to **replace the original kernel for the one provided by KernelSU**, as long as this can be achieved, it can be installed. The following are other possible methods:

1. First, install Magisk, get root privileges through Magisk, and then use the Kernel Flasher to flash the AnyKernel3 ZIP from KernelSU.
2. Use any flashing toolkit on PC to flash the kernel provided by KernelSU.

However, if it doesn't work, please try `magiskboot` approach.

## Post-Installation: Module Support

::: warning METAMODULE FOR SYSTEM FILE MODIFICATION
If you want to use modules that modify `/system` files, you need to install a **metamodule** after installing KernelSU. Modules that only use scripts, sepolicy, or system.prop work without a metamodule.
:::

**For `/system` modification support**, please see the [Metamodule Guide](metamodule.md) to:
- Understand what metamodules are and why they're needed
- Install the official `meta-overlayfs` metamodule
- Learn about other metamodule options

```

`website/docs/guide/metamodule.md`:

```md
# Metamodule

Metamodules are a revolutionary feature in KernelSU that transfers critical module system capabilities from the core to pluggable modules. This architectural shift maintains KernelSU's stability and security while unleashing greater innovation potential for the module ecosystem.

## What is a Metamodule?

A metamodule is a special type of KernelSU module that provides core infrastructure functionality for the module system. Unlike regular modules that modify system files, metamodules control *how* regular modules are installed and mounted.

Metamodules are a plugin-based extension mechanism that allows complete customization of KernelSU's module management infrastructure. By delegating mounting and installation logic to metamodules, KernelSU avoids being a fragile detection point while enabling diverse implementation strategies.

**Key characteristics:**

- **Infrastructure role**: Metamodules provide services that regular modules depend on
- **Single instance**: Only one metamodule can be installed at a time
- **Priority execution**: Metamodule scripts run before regular module scripts
- **Special hooks**: Provides three hook scripts for installation, mounting, and cleanup

## Why Metamodules?

Traditional root solutions bake mounting logic into their core, making them easier to detect and harder to evolve. KernelSU's metamodule architecture solves these problems through separation of concerns.

**Strategic advantages:**

- **Reduced detection surface**: KernelSU itself doesn't perform mounts, reducing detection vectors
- **Stability**: Core remains stable while mounting implementations can evolve
- **Innovation**: Community can develop alternative mounting strategies without forking KernelSU
- **Choice**: Users can select the implementation that best fits their needs

**Mounting flexibility:**

- **No mounting**: For users with mountless-only modules, avoid mounting overhead entirely
- **OverlayFS mounting**: Traditional approach with read-write layer support (via `meta-overlayfs`)
- **Magic mount**: Magisk-compatible mounting for better app compatibility
- **Custom implementations**: FUSE-based overlays, custom VFS mounts, or entirely new approaches

**Beyond mounting:**

- **Extensibility**: Add features like kernel module support without modifying core KernelSU
- **Modularity**: Update implementations independently of KernelSU releases
- **Customization**: Create specialized solutions for specific devices or use cases

::: warning IMPORTANT
Without a metamodule installed, modules will **NOT** be mounted. Fresh KernelSU installations require installing a metamodule (such as `meta-overlayfs`) for modules to function.
:::

## For Users

### Installing a Metamodule

Install a metamodule the same way as regular modules:

1. Download the metamodule ZIP file (e.g., `meta-overlayfs.zip`)
2. Open KernelSU Manager app
3. Tap the floating action button (➕)
4. Select the metamodule ZIP file
5. Reboot your device

The `meta-overlayfs` metamodule is the official reference implementation that provides traditional overlayfs-based module mounting with ext4 image support.

### Checking Active Metamodule

You can check which metamodule is currently active in the KernelSU Manager app's Module page. The active metamodule will be displayed in your module list with its special designation.

### Uninstalling a Metamodule

::: danger WARNING
Uninstalling a metamodule will affect **ALL** modules. After removal, modules will no longer be mounted until you install another metamodule.
:::

To uninstall:

1. Open KernelSU Manager
2. Find the metamodule in your module list
3. Tap uninstall (you'll see a special warning)
4. Confirm the action
5. Reboot your device

After uninstalling, you should install another metamodule if you want modules to continue working.

### Single Metamodule Constraint

Only one metamodule can be installed at a time. If you try to install a second metamodule, KernelSU will prevent the installation to avoid conflicts.

To switch metamodules:

1. Uninstall all regular modules
2. Uninstall the current metamodule
3. Reboot
4. Install the new metamodule
5. Reinstall your regular modules
6. Reboot again

## For Module Developers

If you're developing regular KernelSU modules, you don't need to worry much about metamodules. Your modules will work as long as users have a compatible metamodule installed (like `meta-overlayfs`).

**What you need to know:**

- **Mounting requires a metamodule**: The `system` directory in your module will only be mounted if the user has a metamodule installed that provides mounting functionality
- **No code changes needed**: Existing modules continue to work without modification

::: tip
If you're familiar with Magisk module development, your modules will work the same way in KernelSU when metamodule is installed, as it provides Magisk-compatible mounting.
:::

## For Metamodule Developers

Creating a metamodule allows you to customize how KernelSU handles module installation, mounting, and uninstallation.

### Basic Requirements

A metamodule is identified by a special property in its `module.prop`:

```txt
id=meta-example
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

**Key requirements:**

- The `metamodule=1` (or `metamodule=true`) property marks this as a metamodule. Without this property, the module will be treated as a regular module.
- **Naming convention**: It is strongly recommended to name your metamodule ID starting with `meta-` (e.g., `meta-overlayfs`, `meta-magicmount`, `meta-custom`). This helps users easily identify metamodules and prevents naming conflicts with regular modules.

### File Structure

A metamodule structure:

```txt
meta-example/
├── module.prop              (must include metamodule=1)
│
│      *** Metamodule-specific hooks ***
├── metamount.sh             (optional: custom mount handler)
├── metainstall.sh           (optional: installation hook for regular modules)
├── metauninstall.sh         (optional: cleanup hook for regular modules)
│
│      *** Standard module files (all optional) ***
├── customize.sh             (installation customization)
├── post-fs-data.sh          (post-fs-data stage script)
├── service.sh               (late_start service script)
├── boot-completed.sh        (boot completed script)
├── uninstall.sh             (metamodule's own uninstallation script)
└── [any additional files]
```

Metamodules can use all standard module features (lifecycle scripts, etc.) in addition to their special metamodule hooks.

### Hook Scripts

Metamodules can provide up to three special hook scripts:

#### 1. metamount.sh - Mount Handler

**Purpose**: Controls how modules are mounted during boot.

**When executed**: [Execution Order](#execution-order) below.

**Environment variables:**

- `MODDIR`: The metamodule's directory path (e.g., `/data/adb/modules/meta-example`)
- All standard KernelSU environment variables

**Responsibilities:**

- Mount all enabled modules systemlessly
- Check for `skip_mount` flags
- Handle module-specific mounting requirements

::: danger CRITICAL REQUIREMENT
When performing mount operations, you **MUST** set the source/device name to `"KSU"`. This identifies mounts as belonging to KernelSU.

**Example (correct):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**For modern mount APIs**, set the source string:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

This is essential for KernelSU to identify and manage its mounts properly.
:::

**Example script:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# Example: Simple bind mount implementation
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # Mount with source=KSU (REQUIRED!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - Installation Hook

**Purpose**: Customize how regular modules are installed.

**When executed**: During module installation, after files are extracted but before installation completes. This script is **sourced** (not executed) by the built-in installer, similar to how `customize.sh` works.

**Environment variables and functions:**

This script inherits all variables and functions from the built-in `install.sh`:

- **Variables**: `MODPATH`, `TMPDIR`, `ZIPFILE`, `ARCH`, `API`, `IS64BIT`, `KSU`, `KSU_VER`, `KSU_VER_CODE`, `BOOTMODE`, etc.
- **Functions**:
  - `ui_print <msg>` - Print message to console
  - `abort <msg>` - Print error and terminate installation
  - `set_perm <target> <owner> <group> <permission> [context]` - Set file permissions
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - Set permissions recursively
  - `install_module` - Call the built-in module installation process

**Use cases:**

- Process module files before or after built-in installation (call `install_module` when ready)
- Move module files
- Validate module compatibility
- Set up special directory structures
- Initialize module-specific resources

**Note**: This script is **NOT** called when installing the metamodule itself.

#### 3. metauninstall.sh - Cleanup Hook

**Purpose**: Clean up resources when regular modules are uninstalled.

**When executed**: During module uninstallation, before the module directory is removed.

**Environment variables:**

- `MODULE_ID`: The ID of the module being uninstalled

**Use cases:**

- Process files
- Clean up symlinks
- Free allocated resources
- Update internal tracking

**Example script:**

```sh
#!/system/bin/sh
# Called when uninstalling regular modules
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# Remove module files from image
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### Execution Order {#execution-order}

Understanding the boot execution order is crucial for metamodule development:

```txt
post-fs-data stage:
  1. Common post-fs-data.d scripts execute
  2. Prune modules, restorecon, load sepolicy.rule
  3. Metamodule's post-fs-data.sh executes (if exists)
  4. Regular modules' post-fs-data.sh execute
  5. Load system.prop
  6. Metamodule's metamount.sh executes
     └─> Mounts all modules systemlessly
  7. post-mount.d stage runs
     - Common post-mount.d scripts
     - Metamodule's post-mount.sh (if exists)
     - Regular modules' post-mount.sh

service stage:
  1. Common service.d scripts execute
  2. Metamodule's service.sh executes (if exists)
  3. Regular modules' service.sh execute

boot-completed stage:
  1. Common boot-completed.d scripts execute
  2. Metamodule's boot-completed.sh executes (if exists)
  3. Regular modules' boot-completed.sh execute
```

**Key points:**

- `metamount.sh` runs **AFTER** all post-fs-data scripts (both metamodule and regular modules)
- Metamodule lifecycle scripts (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`) always run before regular module scripts
- Common scripts in `.d` directories run before metamodule scripts
- The `post-mount` stage runs after mounting is complete

### Symlink Mechanism

When a metamodule is installed, KernelSU creates a symlink:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

This provides a stable path for accessing the active metamodule, regardless of its ID.

**Benefits:**

- Consistent access path
- Easy detection of active metamodule
- Simplifies configuration

### Real-World Example: meta-overlayfs

The `meta-overlayfs` metamodule is the official reference implementation. It demonstrates best practices for metamodule development.

#### Architecture

`meta-overlayfs` uses a **dual-directory architecture**:

1. **Metadata directory**: `/data/adb/modules/`
   - Contains `module.prop`, `disable`, `skip_mount` markers
   - Fast to scan during boot
   - Small storage footprint

2. **Content directory**: `/data/adb/metamodule/mnt/`
   - Contains actual module files (system, vendor, product, etc.)
   - Stored in an ext4 image (`modules.img`)
   - Space-optimized with ext4 features

#### metamount.sh Implementation

Here's how `meta-overlayfs` implements the mount handler:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# Mount ext4 image if not already mounted
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# Set environment variables for dual-directory support
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# Execute the mount binary
# (The actual mounting logic is in a Rust binary)
"$MODDIR/meta-overlayfs"
```

#### Key Features

**Overlayfs mounting:**

- Uses kernel overlayfs for true systemless modifications
- Supports multiple partitions (system, vendor, product, system_ext, odm, oem)
- Read-write layer support via `/data/adb/modules/.rw/`

**Source identification:**

```rust
// From meta-overlayfs/src/mount.rs
fsconfig_set_string(fs, "source", "KSU")?;  // REQUIRED!
```

This sets `dev=KSU` for all overlay mounts, enabling proper identification.

### Best Practices

When developing metamodules:

1. **Always set source to "KSU"** for mount operations - kernel umount and zygisksu umount need this to umount correctly
2. **Handle errors gracefully** - boot processes are time-sensitive
3. **Respect standard flags** - support `skip_mount` and `disable`
4. **Log operations** - use `echo` or logging for debugging
5. **Test thoroughly** - mounting errors can cause boot loops
6. **Document behavior** - clearly explain what your metamodule does
7. **Provide migration paths** - help users switch from other solutions

### Testing Your Metamodule

Before releasing:

1. **Test installation** on a clean KernelSU setup
2. **Verify mounting** with various module types
3. **Check compatibility** with common modules
4. **Test uninstallation** and cleanup
5. **Validate boot performance** (metamount.sh is blocking!)
6. **Ensure proper error handling** to avoid boot loops

## Frequently Asked Questions

### Do I need a metamodule?

**For users**: Only if you want to use modules that require mounting. If you only use modules that run scripts without modifying system files, you don't need a metamodule.

**For module developers**: No, you develop modules normally. Users need a metamodule only if your module requires mounting.

**For advanced users**: Only if you want to customize mounting behavior or create alternative mounting implementations.

### Can I have multiple metamodules?

No. Only one metamodule can be installed at a time. This prevents conflicts and ensures predictable behavior.

### What happens if I uninstall my only metamodule?

Modules will no longer be mounted. Your device will boot normally, but module modifications won't apply until you install another metamodule.

### Is meta-overlayfs required?

No. It provides standard overlayfs mounting compatible with most modules. You can create your own metamodule if you need different behavior.

## See Also

- [Module Guide](module.md) - General module development
- [Difference with Magisk](difference-with-magisk.md) - Comparing KernelSU and Magisk
- [How to Build](how-to-build.md) - Building KernelSU from source

```

`website/docs/guide/module-config.md`:

```md
# Module Configuration

KernelSU provides a built-in configuration system that allows modules to store persistent or temporary key-value settings. Configurations are stored in a binary format at `/data/adb/ksu/module_configs/<module_id>/` with the following characteristics:

## Configuration Types

- **Persist Config** (`persist.config`): Survives reboots and persists until explicitly deleted or the module is uninstalled
- **Temp Config** (`tmp.config`): Automatically cleared during the post-fs-data stage on every boot

When reading configurations, temporary values take priority over persistent values for the same key.

## Using Configuration in Module Scripts

All module scripts (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`, etc.) run with the `KSU_MODULE` environment variable set to the module ID. You can use the `ksud module config` commands to manage your module's configuration:

```bash
# Get a configuration value
value=$(ksud module config get my_setting)

# Set a persistent configuration value
ksud module config set my_setting "some value"

# Set a temporary configuration value (cleared on reboot)
ksud module config set --temp runtime_state "active"

# Set value from stdin (useful for multiline or complex data)
ksud module config set my_key <<EOF
multiline
text value
EOF

# Or pipe from command
echo "value" | ksud module config set my_key

# Explicit stdin flag
cat file.json | ksud module config set json_data --stdin

# List all configuration entries (merged persist + temp)
ksud module config list

# Delete a configuration entry
ksud module config delete my_setting

# Delete a temporary configuration entry
ksud module config delete --temp runtime_state

# Clear all persistent configurations
ksud module config clear

# Clear all temporary configurations
ksud module config clear --temp
```

## Validation Limits

The configuration system enforces the following limits:

- **Maximum key length**: 256 bytes
- **Maximum value length**: 1MB (1048576 bytes)
- **Maximum config entries**: 32 per module
- **Key format**: Must match `^[a-zA-Z][a-zA-Z0-9._-]+$` (same as module ID)
  - Must start with a letter (a-zA-Z)
  - Can contain letters, numbers, dots (`.`), underscores (`_`), or hyphens (`-`)
  - Minimum length: 2 characters
- **Value format**: No restrictions - can contain any UTF-8 characters including newlines, control characters, etc.
  - Stored in binary format with length prefix, ensuring safe handling of all data

## Lifecycle

- **On boot**: All temporary configurations are cleared during the post-fs-data stage
- **On module uninstall**: All configurations (both persist and temp) are removed automatically
- Configurations are stored in a binary format with magic number `0x4b53554d` ("KSUM") and version validation

## Use Cases

The configuration system is ideal for:

- **User preferences**: Store module settings that users configure through WebUI or action scripts
- **Feature flags**: Enable/disable module features without reinstalling
- **Runtime state**: Track temporary state that should reset on reboot (use temp config)
- **Installation settings**: Remember choices made during module installation
- **Complex data**: Store JSON, multiline text, Base64 encoded data, or any structured content (up to 1MB)

::: tip BEST PRACTICES
- Use persistent configs for user preferences that should survive reboots
- Use temporary configs for runtime state or feature toggles that should reset on boot
- Validate configuration values in your scripts before using them
- Use the `ksud module config list` command to debug configuration issues
:::

## Advanced Features

The module configuration system provides special configuration keys for advanced use cases:

### Overriding Module Description {#overriding-module-description}

You can dynamically override the `description` field from `module.prop` by setting the `override.description` configuration key:

```bash
# Override module description
ksud module config set override.description "Custom description shown in the manager"
```

When the module list is retrieved, if the `override.description` config exists, it will replace the original description from `module.prop`. This is useful for:
- Displaying dynamic status information in the module description
- Showing runtime configuration details to users
- Updating description based on module state without reinstalling

### Declaring Managed Features

Modules can declare which KernelSU features they manage using the `manage.<feature>` configuration pattern. The supported features correspond to KernelSU's internal `FeatureId` enum:

**Supported Features:**
- `su_compat` - SU compatibility mode
- `kernel_umount` - Kernel automatic unmount

```bash
# Declare that this module manages SU compatibility and enables it
ksud module config set manage.su_compat true

# Declare that this module manages kernel unmount and disables it
ksud module config set manage.kernel_umount false

# Remove feature management (module no longer controls this feature)
ksud module config delete manage.su_compat
```

**How it works:**
- The presence of a `manage.<feature>` key indicates the module is managing that feature
- The value indicates the desired state: `true`/`1` for enabled, `false`/`0` (or any other value) for disabled
- To stop managing a feature, delete the configuration key entirely

Managed features are exposed through the module list API as a `managedFeatures` field (comma-separated string). This allows:
- KernelSU manager to detect which modules manage which KernelSU features
- Prevention of conflicts when multiple modules try to manage the same feature
- Better coordination between modules and core KernelSU functionality

::: warning SUPPORTED FEATURES ONLY
Only use the predefined feature names listed above (`su_compat`, `kernel_umount`). These correspond to actual KernelSU internal features. Using other feature names will not cause errors but serves no functional purpose.
:::

```

`website/docs/guide/module-webui.md`:

```md
# Module WebUI

In addition to executing boot scripts and modifying system files, KernelSU modules can display user interfaces and interact directly with users.

Modules can define HTML + CSS + JavaScript pages with any web technology. KernelSU's manager displays these pages via WebView and exposes APIs for interacting with the system, such as executing shell commands.

## `webroot` directory

Web resource files should be placed in the `webroot` subdirectory of the module root directory, and there **MUST** be a file named `index.html`, which is the module page entry. The simplest module structure containing a web interface is as follows:

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

::: warning
When installing the module, KernelSU will automatically set the permissions and SELinux context for this directory. If you don't know what you're doing, do not set the permissions for this directory yourself!
:::

If your page contains CSS and JavaScript, you need to place it in this directory as well.

## JavaScript API

If it's just a display page, it will function like a regular web page. However, the most important thing is that KernelSU provides a series of system APIs, allowing the implementation of module-specific functions.

KernelSU provides a JavaScript library, which is published on [npm](https://www.npmjs.com/package/kernelsu) and can be used in the JavaScript code of your web pages.

For example, you can execute a shell command to obtain a specific configuration or modify a property:

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

You can also make the page full screen or display a toast.

[API documentation](https://www.npmjs.com/package/kernelsu)

If you find that the existing API doesn't meet your needs or is inconvenient to use, you're welcome to give us suggestions [here](https://github.com/tiann/KernelSU/issues)!

## Some tips

1. You can use `localStorage` as usual to store some data, but keep in mind that it will be lost if the manager app is uninstalled. If you need persistent storage, you will need to manually save the data in a specific directory.
2. For simple pages, we recommend using [parceljs](https://parceljs.org/) for packaging. It requires no initial configuration and is extremely easy to use. However, if you're a front-end expert or have your own preferences, feel free to use the tool of your choice!

```

`website/docs/guide/module.md`:

```md
# Module guide

KernelSU provides a module mechanism that achieves the effect of modifying the system directory while maintaining the integrity of the system partition. This mechanism is commonly known as "systemless".

The module mechanism of KernelSU is almost the same as that of Magisk. If you're familiar with Magisk module development, developing KernelSU modules is very similar. You can skip the introduction of modules below and just read [Difference with Magisk](difference-with-magisk.md).

::: warning METAMODULE ONLY NEEDED FOR SYSTEM FILE MODIFICATION
KernelSU uses a [metamodule](metamodule.md) architecture for mounting the `system` directory. **Only if your module needs to modify `/system` files** (via the `system` directory) do you need to install a metamodule (such as [meta-overlayfs](https://github.com/tiann/KernelSU/releases)). Other module features like scripts, sepolicy rules, and system.prop work without a metamodule.
:::

## WebUI

KernelSU's modules support displaying interfaces and interacting with users. For more details, refer to the [WebUI documentation](module-webui.md).

## Module Configuration

KernelSU provides a built-in configuration system that allows modules to store persistent or temporary key-value settings. For more details, refer to the [Module Configuration documentation](module-config.md).

## BusyBox

KernelSU ships with a feature-complete BusyBox binary (including full SELinux support). The executable is located at `/data/adb/ksu/bin/busybox`. KernelSU's BusyBox supports runtime toggle-able "ASH Standalone Shell Mode". What this Standalone Mode means is that when running in the `ash` shell of BusyBox, every single command will directly use the applet within BusyBox, regardless of what is set as `PATH`. For example, commands like `ls`, `rm`, `chmod` will **NOT** use what is in `PATH` (in the case of Android by default it will be `/system/bin/ls`, `/system/bin/rm`, and `/system/bin/chmod` respectively), but will instead directly call internal BusyBox applets. This makes sure that scripts always run in a predictable environment and always have the full suite of commands no matter which Android version it is running on. To force a command _not_ to use BusyBox, you have to call the executable with full paths.

Every single shell script running in the context of KernelSU will be executed in BusyBox's `ash` shell with Standalone Mode enabled. For what is relevant to 3rd party developers, this includes all boot scripts and module installation scripts.

For those who want to use this Standalone Mode feature outside of KernelSU, there are 2 ways to enable it:

1. Set environment variable `ASH_STANDALONE` to `1` <br>Example: `ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. Toggle with command-line options:<br>`/data/adb/ksu/bin/busybox sh -o standalone <script>`

To make sure all subsequent `sh` shell executed also runs in Standalone Mode, option 1 is the preferred method (and this is what KernelSU and the KernelSU manager use internally) as environment variables are inherited down to child processes.

::: tip DIFFERENCE WITH MAGISK
KernelSU's BusyBox is now using the binary file compiled directly from the Magisk project. **Thanks to Magisk!** Therefore, you don't need to worry about compatibility issues between BusyBox scripts in Magisk and KernelSU, as they're exactly the same!
:::

## KernelSU modules

A KernelSU module is a folder placed in `/data/adb/modules` with the structure below:

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- The folder is named with the ID of the module
│   │
│   │      *** Module Identity ***
│   │
│   ├── module.prop         <--- This file stores the metadata of the module
│   │
│   │      *** Main Contents ***
│   │
│   ├── system              <--- This folder will be mounted if skip_mount does not exist
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** Status Flags ***
│   │
│   ├── skip_mount          <--- If exists, KernelSU will NOT mount your system folder
│   ├── disable             <--- If exists, the module will be disabled
│   ├── remove              <--- If exists, the module will be removed next reboot
│   │
│   │      *** Optional Files ***
│   │
│   ├── post-fs-data.sh     <--- This script will be executed in post-fs-data
│   ├── post-mount.sh       <--- This script will be executed in post-mount
│   ├── service.sh          <--- This script will be executed in late_start service
│   ├── boot-completed.sh   <--- This script will be executed on boot completed
|   ├── uninstall.sh        <--- This script will be executed when KernelSU removes your module
|   ├── action.sh           <--- This script will be executed when user click the Action button in KernelSU app
│   ├── system.prop         <--- Properties in this file will be loaded as system properties by resetprop
│   ├── sepolicy.rule       <--- Additional custom sepolicy rules
│   │
│   │      *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY ***
│   │
│   ├── vendor              <--- A symlink to $MODID/system/vendor
│   ├── product             <--- A symlink to $MODID/system/product
│   ├── system_ext          <--- A symlink to $MODID/system/system_ext
│   │
│   │      *** Any additional files / folders are allowed ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip DIFFERENCE WITH MAGISK
KernelSU doesn't have built-in support for Zygisk, so there is no content related to Zygisk in the module. However, you can use [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) to support Zygisk modules. In this case, the content of the Zygisk module is identical to that supported by Magisk.
:::

### module.prop

`module.prop` is a configuration file for a module. In KernelSU, if a module doesn't contain this file, it won't be recognized as a module. The format of this file is as follows:

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
actionIcon=<path> (optional)
webuiIcon=<path> (optional)
```

- `id` has to match this regular expression: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
  Example: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
  This is the **unique identifier** of your module. You should not change it once published.
- `versionCode` has to be an **integer**. This is used to compare versions.
- Others that were not mentioned above can be any **single line** string.
- Make sure to use the `UNIX (LF)` line break type and not the `Windows (CR+LF)` or `Macintosh (CR)`.
- `actionIcon` and `webuiIcon` are optional icon paths used as the default
  icons for the module action shortcut and WebUI shortcut in the Manager. These
  paths must be relative to the module root directory. For example,
  `actionIcon=icon/icon.png` will be resolved as `<MODDIR>/icon/icon.png`.

::: tip DYNAMIC DESCRIPTION
The `description` field can be dynamically overridden at runtime using the module configuration system. See [Overriding Module Description](module-config.md#overriding-module-description) for details.
:::

### Shell scripts

Please read the [Boot scripts](#boot-scripts) section to understand the difference between `post-fs-data.sh` and `service.sh`. For most module developers, `service.sh` should be good enough if you just need to run a boot script, if you need to run the script after boot completed, please use `boot-completed.sh`. If you want to do something after mounting OverlayFS, please use `post-mount.sh`.

In all scripts of your module, please use `MODDIR=${0%/*}` to get your module's base directory path; do **NOT** hardcode your module path in scripts.

::: tip DIFFERENCE WITH MAGISK
You can use the environment variable `KSU` to determine if a script is running in KernelSU or Magisk. If running in KernelSU, this value will be set to `true`.
:::

### `system` directory

The contents of this directory will be overlaid on top of the system's `/system` partition after the system is booted. This means that:

::: tip METAMODULE REQUIREMENT
The `system` directory is only mounted if you have a metamodule installed that provides mounting functionality (such as `meta-overlayfs`). The metamodule handles how modules are mounted. See the [Metamodule Guide](metamodule.md) for more information.
:::

1. Files with the same name as those in the corresponding directory in the system will be overwritten by the files in this directory.
2. Folders with the same name as those in the corresponding directory in the system will be merged with the folders in this directory.

If you want to delete a file or folder in the original system directory, you need to create a file with the same name as the file/folder in the module directory using `mknod filename c 0 0`. This way, the OverlayFS system will automatically "whiteout" this file as if it has been deleted (the /system partition isn't actually changed).

You can also declare a variable named `REMOVE` containing a list of directories in `customize.sh` to execute removal operations, and KernelSU will automatically execute `mknod <TARGET> c 0 0` in the corresponding directories of the module. For example:

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

The above list will execute `mknod $MODPATH/system/app/YouTube c 0 0` and `mknod $MODPATH/system/app/Bloatware c 0 0`, `/system/app/YouTube` and `/system/app/Bloatware` will be removed after the module takes effect.

If you want to replace a directory in the system, you need to create a directory with the same path in your module directory, and then set the attribute `setfattr -n trusted.overlay.opaque -v y <TARGET>` for this directory. This way, the OverlayFS system will automatically replace the corresponding directory in the system (without changing the /system partition).

You can declare a variable named `REPLACE` in your `customize.sh` file, which includes a list of directories to be replaced, and KernelSU will automatically perform the corresponding operations in your module directory. For example:

```sh
REPLACE="
/system/app/YouTube
/system/app/Bloatware
"
```

This list will automatically create the directories `$MODPATH/system/app/YouTube` and `$MODPATH/system/app/Bloatware`, and then execute `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/YouTube` and `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/Bloatware`. After the module takes effect, `/system/app/YouTube` and `/system/app/Bloatware` will be replaced with empty directories.

::: tip DIFFERENCE WITH MAGISK
KernelSU uses a [metamodule architecture](metamodule.md) where mounting is delegated to pluggable metamodules. The official `meta-overlayfs` metamodule uses the kernel's OverlayFS for systemless modifications, while Magisk uses magic mount (bind mount) built directly into its core. Both achieve the same goal: modifying `/system` files without physically modifying the `/system` partition. KernelSU's approach provides more flexibility and reduces detection surface.
:::

If you're interested in OverlayFS, it's recommended to read the Linux Kernel's [documentation on OverlayFS](https://docs.kernel.org/filesystems/overlayfs.html). For details on KernelSU's metamodule system, see the [Metamodule Guide](metamodule.md).

### system.prop

This file follows the same format as `build.prop`. Each line comprises of `[key]=[value]`.

### sepolicy.rule

If your module requires some additional sepolicy patches, please add those rules into this file. Each line in this file will be treated as a policy statement.

## Module installer

A KernelSU module installer is a KernelSU module packaged in a ZIP file that can be flashed in the KernelSU manager. The simplest KernelSU module installer is just a KernelSU module packed as a ZIP file.

```txt
module.zip
│
├── customize.sh                       <--- (Optional, more details later)
│                                           This script will be sourced by update-binary
├── ...
├── ...  /* The rest of module's files */
│
```

::: warning
KernelSU module is **NOT** compatible for installation in a custom Recovery!
:::

### Customization

If you need to customize the module installation process, optionally you can create a script in the installer named `customize.sh`. This script will be **sourced** (not executed) by the module installer script after all files are extracted and default permissions and secontext are applied. This is very useful if your module requires additional setup based on the device ABI, or you need to set special permissions/secontext for some of your module files.

If you would like to fully control and customize the installation process, declare `SKIPUNZIP=1` in `customize.sh` to skip all default installation steps. By doing so, your `customize.sh` will be responsible to install everything by itself.

The `customize.sh` script runs in KernelSU's BusyBox `ash` shell with Standalone Mode enabled. The following variables and functions are available:

#### Variables

- `KSU` (bool): a variable to mark that the script is running in the KernelSU environment, and the value of this variable will always be true. You can use it to distinguish between KernelSU and Magisk.
- `KSU_VER` (string): the version string of currently installed KernelSU (e.g. `v0.4.0`).
- `KSU_VER_CODE` (int): the version code of currently installed KernelSU in userspace (e.g. `10672`).
- `KSU_KERNEL_VER_CODE` (int): the version code of currently installed KernelSU in kernel space (e.g. `10672`).
- `BOOTMODE` (bool): always be `true` in KernelSU.
- `MODPATH` (path): the path where your module files should be installed.
- `TMPDIR` (path): a place where you can temporarily store files.
- `ZIPFILE` (path): your module's installation ZIP.
- `ARCH` (string): the CPU architecture of the device. Value is either `arm`, `arm64`, `x86`, or `x64`.
- `IS64BIT` (bool): `true` if `$ARCH` is either `arm64` or `x64`.
- `API` (int): the API level (Android version) of the device (e.g., `23` for Android 6.0).

::: warning
In KernelSU, `MAGISK_VER_CODE` is always `25200`, and `MAGISK_VER` is always `v25.2`. Please don't use these two variables to determine whether KernelSU is running or not.
:::

#### Functions

```txt
ui_print <msg>
    print <msg> to console
    Avoid using 'echo' as it will not display in custom recovery's console

abort <msg>
    print error message <msg> to console and terminate the installation
    Avoid using 'exit' as it will skip the termination cleanup steps

set_perm <target> <owner> <group> <permission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    this function is a shorthand for the following commands:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    for all files in <directory>, it will call:
       set_perm file owner group filepermission context
    for all directories in <directory> (including itself), it will call:
       set_perm dir owner group dirpermission context
```

## Boot scripts

In KernelSU, scripts are divided into two types based on their running mode: post-fs-data mode and late_start service mode.

- post-fs-data mode
  - This stage is BLOCKING. The boot process is paused before execution is done or after 10 seconds.
  - Scripts run before any modules are mounted. This allows a module developer to dynamically adjust their modules before it gets mounted.
  - This stage happens before Zygote is started, which pretty much means everything in Android.
  - **WARNING:** Using `setprop` will deadlock the boot process! Please use `resetprop -n <prop_name> <prop_value>` instead.
  - **Only run scripts in this mode if necessary**.
- late_start service mode
  - This stage is NON-BLOCKING. Your script runs in parallel with the rest of the booting process.
  - **This is the recommended stage to run most scripts**.

In KernelSU, startup scripts are divided into two types based on their storage location: general scripts and module scripts.

- General scripts
  - Placed in `/data/adb/post-fs-data.d`, `/data/adb/service.d`, `/data/adb/post-mount.d` or `/data/adb/boot-completed.d`.
  - Only executed if the script is set as executable (`chmod +x script.sh`).
  - Scripts in `post-fs-data.d` runs in post-fs-data mode, and scripts in `service.d` runs in late_start service mode.
  - Modules should **NOT** add general scripts during installation.
- Module scripts
  - Placed in the module's own folder.
  - Only executed if the module is enabled.
  - `post-fs-data.sh` runs in post-fs-data mode, `service.sh` runs in late_start service mode, `boot-completed.sh` runs on boot completed, `post-mount.sh` runs on OverlayFS mounted.

All boot scripts will run in KernelSU's BusyBox `ash` shell with Standalone Mode enabled.

### Boot scripts process explanation

The following is the relevant boot process for Android (some parts are omitted), which includes the operation of KernelSU (with leading asterisks), and can help you better understand the purpose of these module scripts:

```txt
0. Bootloader (nothing on screen)
load patched boot.img
load kernel:
    - GKI mode: GKI kernel with KernelSU integrated
    - LKM mode: stock kernel
...

1. kernel exec init (OEM logo on screen):
    - GKI mode: stock init
    - LKM mode: exec ksuinit, insmod kernelsu.ko, exec stock init
mount /dev, /dev/pts, /proc, /sys, etc.
property-init -> read default props
read init.rc
...
early-init -> init -> late_init
early-fs
   start vold
fs
  mount /vendor, /system, /persist, etc.
post-fs-data
  *safe mode check
  *execute general scripts in post-fs-data.d/
  *load sepolicy.rule
  *execute metamodule's post-fs-data.sh (if exists)
  *execute module scripts post-fs-data.sh
    **(Zygisk)./bin/zygisk-ptrace64 monitor
  *(pre)load system.prop (same as resetprop -n)
  *execute metamodule's metamount.sh (mounts all modules)
  *execute general scripts in post-mount.d/
  *execute metamodule's post-mount.sh (if exists)
  *execute module scripts post-mount.sh
zygote-start
load_all_props_action
  *execute resetprop (actual set props for resetprop with -n option)
... -> boot
  class_start core
    start-service logd, console, vold, etc.
  class_start main
    start-service adb, netd (iptables), zygote, etc.

2. kernel2user init (ROM animation on screen, start by service bootanim)
*execute general scripts in service.d/
*execute metamodule's service.sh (if exists)
*execute module scripts service.sh
*set props for resetprop without -p option
  **(Zygisk) hook zygote (start zygiskd)
  **(Zygisk) mount zygisksu/module.prop
start system apps (autostart)
...
boot complete (broadcast ACTION_BOOT_COMPLETED event)
*execute general scripts in boot-completed.d/
*execute metamodule's boot-completed.sh (if exists)
*execute module scripts boot-completed.sh

3. User operable (lock screen)
input password to decrypt /data/data
*actual set props for resetprop with -p option
start user apps (autostart)
```

If you're interested in Android Init Language, it's recommended to read its [documentation](https://android.googlesource.com/platform/system/core/+/master/init/README.md).

```

`website/docs/guide/rescue-from-bootloop.md`:

```md
# Rescue from bootloop

When updating a device, situations may arise where the device becomes "bricked". In theory, if you only use fastboot to flash the boot partition or install incompatible modules that cause the device to fail during boot, it can be restored through appropriate operations. This document aims to provide emergency methods to help you recover a "bricked" device.

## Brick by flashing boot partition

In KernelSU, the following situations may cause boot brick when flashing the boot partition:

1. You flashed a boot image in the wrong format. For example, if your device's boot format is `gz`, but you flashed an image in `lz4` format, the device won't boot.
2. Your device needs to disable AVB verification to boot correctly, which usually requires wiping all data from the device.
3. Your kernel contains bugs or isn't compatible with your device's flash.

No matter the situation, you can recover by **flashing the stock boot image**. Therefore, at the beginning of the installation guide, we strongly recommend that you back up your stock boot before flashing. If you didn't back it up, you can obtain the original factory boot from other users with the same device or from the official firmware.

## Brick by modules

The installation of modules can be one of the most common causes of bricking your device, but we must seriously warn you: **DO NOT INSTALL MODULES FROM UNKNOWN SOURCES!** Since modules have root privileges, they can cause irreversible damage to your device!

### Normal modules

If you have flashed a module that has been proven to be safe but causes your device to fail to boot, then this situation is easily recoverable in KernelSU without any worries. KernelSU has built-in mechanisms to rescue your device, including the following:

1. AB update
2. Rescue by pressing Volume down button

#### AB update

KernelSU's module updates are based on the Android system's AB update mechanism used in OTA updates. When you install a new module or update an existing one, it won't directly modify the currently used module file. Instead, all modules are integrated into a new update image. After the system is restarted, it will attempt to boot using this new update image. If the Android system boots successfully, the modules will be effectively updated.

Therefore, the simplest and most commonly used method to rescue your device is to **force a reboot**. If you're unable to start your system after flashing a module, you can press and hold the power button for more than 10 seconds, and the system will automatically reboot. After rebooting, it will roll back to the state before the module update, and any previously updated modules will be automatically disabled.

#### Rescue by pressing Volume down button

If AB update hasn't yet resolved the issue, you can try using **Safe Mode**. In this mode, all modules are disabled.

There are two ways to enter Safe Mode:

1. The built-in Safe Mode of some systems: Some systems have a built-in Safe Mode that can be accessed by long-pressing the Volume down button. In other systems (such as HyperOS), Safe Mode can be activated from the Recovery. When entering the system's Safe Mode, KernelSU will also enter this mode and automatically disable the modules.
2. The built-in Safe Mode of KernelSU: In this case, the method is to **press the Volume down key continuously more than three times** after the first boot screen.

After entering Safe Mode, all modules on the Module page in the KernelSU manager will be disabled. However, you can still perform the "uninstall" operation to remove any modules that may be causing issues.

The built-in Safe Mode is implemented in the kernel, so there is no possibility of missing important events due to interception. However, for non-GKI kernels, manual code integration may be required. For this, refer to the official documentation for guidance.

### Malicious modules

If the above methods cannot rescue your device, it's highly likely that the module you installed has malicious operations or has damaged your device in some other way. In this case, there are only two suggestions:

1. Wipe the data and flash the official system.
2. Consult the after-sales service.

```

`website/docs/guide/unofficially-support-devices.md`:

```md
# Unofficially supported devices

::: warning
This document is for archival reference only and is no longer maintained.
Since KernelSU v1.0, we have dropped official support for non-GKI devices.
:::

::: warning
In this page, there are kernels for non-GKI devices supporting KernelSU maintained by other developers.
:::

::: warning
This page is intended only to help you find the source code corresponding to your device. It **DOES NOT** mean that the source code has been reviewed by KernelSU developers. You should use it at your own risk.
:::

<script setup>
import data from '../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>Maintainer</th>
         <th>Repository</th>
         <th>Support devices</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>

```

`website/docs/guide/what-is-kernelsu.md`:

```md
# What is KernelSU?

KernelSU is a root solution for Android GKI devices. It works in kernel mode and grants root permission to userspace apps directly in kernel space.

## Features

The main feature of KernelSU is that it's **kernel-based**. KernelSU works in kernel mode, enabling it to provide a kernel interface that we never had before. For example, it's possible to add hardware breakpoints to any process in kernel mode, access the physical memory of any process invisibly, intercept any system call (syscall) within the kernel space, among other functionalities.

Additionally, KernelSU provides a [metamodule system](metamodule.md), which is a pluggable architecture for module management. Unlike traditional root solutions that bake mounting logic into their core, KernelSU delegates this to metamodules. This allows you to install metamodules like [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs) to provide systemless modifications to the `/system` partition and other partitions.

## How to use KernelSU?

See [Installation](installation.md).

## How to build KernelSU?

See [How to build](how-to-build.md).

## Discussion

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/id_ID/guide/app-profile.md`:

```md
# App Profile

App Profile adalah mekanisme yang disediakan KernelSU untuk menyesuaikan konfigurasi beragam aplikasi.

Untuk aplikasi yang diberi izin root (misalnya dapat memakai `su`), App Profile juga dapat disebut Root Profile. Ia memungkinkan kita menyesuaikan `uid`, `gid`, `groups`, `capabilities`, dan aturan `SELinux` dari perintah `su`, sehingga hak istimewa pengguna root dapat dibatasi. Contohnya, hanya memberikan izin jaringan kepada aplikasi firewall sambil menolak izin akses berkas, atau memberikan izin shell alih-alih akses root penuh untuk aplikasi pembeku: **menjaga kekuatan agar tetap terkungkung dalam prinsip least privilege.**

Untuk aplikasi biasa tanpa izin root, App Profile dapat mengendalikan bagaimana kernel dan sistem modul bersikap terhadap aplikasi tersebut. Misalnya, App Profile bisa menentukan apakah perubahan yang disebabkan oleh modul harus tetap terlihat. Kernel dan sistem modul kemudian dapat membuat keputusan berdasarkan konfigurasi ini, seperti melakukan operasi serupa “menyembunyikan”.

## Root Profile

### UID, GID, dan Groups

Di sistem Linux ada dua konsep: pengguna dan grup. Setiap pengguna memiliki user ID (UID), dan seorang pengguna bisa menjadi anggota banyak grup yang masing-masing memiliki group ID (GID). ID inilah yang dipakai untuk mengenali pengguna di sistem dan menentukan sumber daya apa yang boleh mereka akses.

Pengguna dengan UID 0 disebut pengguna root, dan grup dengan GID 0 disebut grup root. Grup root biasanya memiliki hak istimewa tertinggi dalam sistem.

Dalam sistem Android, tiap aplikasi bertindak sebagai pengguna terpisah (kecuali pada kasus shared UID) dengan UID unik. Misalnya `0` adalah root, `1000` adalah `system`, `2000` adalah shell ADB, dan UID dari `10000` hingga `19999` mewakili aplikasi biasa.

::: info
UID yang dimaksud di sini berbeda dengan konsep multi-user atau work profile di Android. Work profile sebenarnya diimplementasikan dengan mempartisi rentang UID. Contohnya, 10000-19999 adalah pengguna utama, sementara 110000-119999 adalah work profile. Setiap aplikasi biasa di dalamnya tetap mempunyai UID unik.
:::

Setiap aplikasi dapat memiliki beberapa grup, dengan GID sebagai grup utama yang biasanya sama dengan UID. Grup lain disebut grup tambahan (supplementary groups). Sejumlah izin dikendalikan oleh keanggotaan grup, misalnya izin akses jaringan atau Bluetooth.

Sebagai contoh, apabila kita menjalankan perintah `id` di shell ADB, hasilnya mungkin seperti ini:

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

Di sini UID-nya `2000`, dan GID (ID grup utama) juga `2000`. Selain itu ia berada di beberapa grup tambahan seperti `inet` (boleh membuat soket `AF_INET` dan `AF_INET6`, artinya boleh mengakses jaringan) dan `sdcard_rw` (boleh baca/tulis kartu SD).

Root Profile milik KernelSU memungkinkan kita menyesuaikan UID, GID, dan grup untuk proses root setelah menjalankan `su`. Misalnya, Root Profile sebuah aplikasi root dapat mengatur UID menjadi `2000`, sehingga ketika menggunakan `su`, hak sebenarnya setara dengan shell ADB. Kita juga dapat menghapus grup `inet` agar perintah `su` tidak bisa mengakses jaringan.

::: tip CATATAN
App Profile hanya mengendalikan hak proses root setelah menggunakan `su`, bukan izin asli aplikasi. Jika aplikasi meminta izin akses jaringan, ia tetap dapat mengakses jaringan meski tidak menggunakan `su`. Menghapus grup `inet` dari `su` hanya membuat `su` tidak bisa mengakses jaringan.
:::

Root Profile dipaksakan oleh kernel dan tidak bergantung pada itikad aplikasi root, berbeda dengan mengganti pengguna atau grup secara manual melalui `su`. Pemberian izin `su` sepenuhnya berada di tangan pengguna, bukan pengembang.

### Capabilities

Capabilities adalah mekanisme pemisahan hak istimewa di Linux.

Untuk keperluan pemeriksaan izin, implementasi `UNIX` tradisional membedakan dua jenis proses: proses istimewa (effective UID `0`, disebut superuser atau root) dan proses biasa (effective UID bukan nol). Proses istimewa melewati semua pemeriksaan izin kernel, sedangkan proses biasa tunduk pada pemeriksaan penuh berdasarkan kredensial proses (biasanya effective UID, effective GID, dan daftar grup tambahan).

Sejak Linux 2.2, hak istimewa yang biasanya dimiliki superuser dipecah menjadi unit-unit terpisah yang disebut capability, dan masing-masing dapat diaktifkan atau dinonaktifkan secara independen.

Setiap capability mewakili satu atau lebih hak. Misalnya, `CAP_DAC_READ_SEARCH` mewakili kemampuan melewati pemeriksaan izin untuk membaca berkas serta izin baca dan eksekusi direktori. Jika seorang pengguna dengan effective UID `0` (root) tidak memiliki capability `CAP_DAC_READ_SEARCH` atau capability di atasnya, maka meskipun ia root ia tidak bisa sembarang membaca berkas.

Root Profile KernelSU memungkinkan kita menyesuaikan capability proses root setelah menjalankan `su`, sehingga yang diberikan hanyalah “hak root parsial”. Berbeda dengan UID dan GID di atas, beberapa aplikasi root memang membutuhkan UID `0` setelah memakai `su`. Pada kasus seperti ini, membatasi capability pengguna root dengan UID `0` dapat membatasi operasi yang boleh dilakukan.

::: tip SANGAT DISARANKAN
Dokumentasi resmi capability Linux [dapat dibaca di sini](https://man7.org/linux/man-pages/man7/capabilities.7.html) dan menjelaskan detail hak yang diwakili tiap capability. Jika Anda ingin menyesuaikan capability, sangat disarankan membaca dokumen ini terlebih dahulu.
:::

### SELinux

SELinux adalah mekanisme Mandatory Access Control (MAC) yang sangat kuat. Ia beroperasi berdasarkan prinsip **default deny**: tindakan apa pun yang tidak diizinkan secara eksplisit akan ditolak.

SELinux memiliki dua mode global:

1. Mode Permissive: penolakan hanya dicatat di log, tidak ditegakkan.
2. Mode Enforcing: penolakan dicatat dan ditegakkan.

::: warning
Android modern sangat bergantung pada SELinux untuk menjaga keamanan sistem secara keseluruhan. Sangat disarankan untuk tidak memakai sistem kustom yang berjalan dalam mode “Permissive”, karena hampir tidak menawarkan keuntungan dibanding sistem yang sepenuhnya terbuka.
:::

Menjelaskan SELinux secara tuntas sangatlah kompleks dan berada di luar cakupan dokumen ini. Disarankan mempelajari cara kerjanya melalui sumber berikut:

1. [Wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Red Hat: What Is SELinux?](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

Root Profile KernelSU memungkinkan kita menyesuaikan konteks SELinux dari proses root setelah menjalankan `su`. Kita bisa menetapkan aturan kontrol akses khusus untuk konteks ini sehingga hak root dapat diatur secara sangat granular.

Dalam skenario umum, ketika sebuah aplikasi menjalankan `su`, prosesnya berpindah ke domain SELinux dengan **akses tidak terbatas**, seperti `u:r:su:s0`. Melalui Root Profile, domain ini bisa diganti menjadi domain kustom seperti `u:r:app1:s0`, lalu serangkaian aturan dapat ditetapkan untuk domain tersebut:

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

Perlu dicatat, aturan `allow app1 * * *` di atas hanya untuk contoh. Dalam praktiknya aturan ini tidak boleh digunakan secara luas karena hampir sama saja dengan mode Permissive.

### Eskalasi

Jika konfigurasi Root Profile tidak ditetapkan dengan benar, skenario eskalasi bisa terjadi. Pembatasan yang diberikan App Profile bisa gagal tanpa sengaja.

Sebagai contoh, apabila Anda memberikan izin root kepada pengguna shell ADB (kasus yang cukup umum) dan kemudian memberikan izin root kepada aplikasi biasa, namun mengonfigurasi Root Profile aplikasi tersebut dengan UID 2000 (UID milik shell ADB), aplikasi itu bisa mendapatkan akses root penuh dengan menjalankan perintah `su` dua kali:

1. Eksekusi `su` pertama akan tunduk pada App Profile dan mengubah UID menjadi `2000` (shell ADB) alih-alih `0` (root).
2. Eksekusi `su` kedua, karena UID-nya sudah `2000` dan UID `2000` (shell ADB) memang diberikan akses root pada konfigurasi, maka aplikasi itu akan memperoleh hak root penuh.

::: warning CATATAN
Perilaku ini sepenuhnya sesuai ekspektasi dan bukan bug. Karena itu kami menyarankan hal berikut:

Jika Anda benar-benar perlu memberikan izin root kepada ADB (misalnya sebagai pengembang), jangan mengubah UID menjadi `2000` saat mengonfigurasi Root Profile. Gunakan `1000` (system) agar lebih aman.
:::

## Non-root profile

### Umount modules

KernelSU menyediakan mekanisme systemless untuk memodifikasi partisi sistem dengan memasang OverlayFS. Namun beberapa aplikasi peka terhadap perilaku ini. Dalam kasus tersebut, kita dapat membongkar (umount) modul yang dimuat di aplikasi tertentu dengan mengaktifkan opsi “Umount modules”.

Selain itu, antarmuka pengaturan KernelSU Manager menyediakan opsi “Umount modules by default”. Secara bawaan opsi ini **aktif**, artinya KernelSU atau modul tertentu akan membongkar modul untuk aplikasi ini kecuali ada pengaturan tambahan. Jika Anda tidak menginginkan perilaku ini atau jika aplikasi tertentu terpengaruh, ada dua pendekatan:

1. Biarkan “Umount modules by default” tetap aktif dan nonaktifkan opsi “Umount modules” di App Profile untuk aplikasi yang memang perlu memuat modul (berperan sebagai daftar putih).
2. Nonaktifkan “Umount modules by default” lalu aktifkan opsi “Umount modules” di App Profile hanya untuk aplikasi yang harus dibongkar modulnya (berperan sebagai daftar hitam).

::: info
Pada perangkat dengan kernel versi 5.10 ke atas, kernel akan membongkar modul tanpa tindakan tambahan. Namun di perangkat dengan kernel di bawah 5.10, opsi ini hanya berupa konfigurasi dan KernelSU sendiri tidak mengambil tindakan apa pun. Jika ingin memakai opsi “Umount modules” pada kernel sebelum 5.10 Anda harus backport fungsi `path_umount` di `fs/namespace.c`. Anda bisa menemukan info lebih lanjut di bagian akhir halaman [Integrate for non-GKI devices](https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#how-to-backport-path_umount). Beberapa modul seperti Zygisksu juga memakai opsi ini untuk menentukan apakah modul perlu dibongkar.
:::

```

`website/docs/id_ID/guide/difference-with-magisk.md`:

```md
# Perbedaan dengan Magisk

Meskipun ada banyak kesamaan antara modul KernelSU dan modul Magisk, pasti ada beberapa perbedaan karena mekanisme implementasinya yang sangat berbeda. Jika Anda ingin modul Anda berjalan di Magisk dan KernelSU, Anda harus memahami perbedaan ini.

## Kesamaan

- Format file modul: keduanya menggunakan format zip untuk mengatur modul, dan format modulnya hampir sama
- Direktori pemasangan modul: keduanya terletak di `/data/adb/modules`
- Tanpa sistem: keduanya mendukung modifikasi / sistem dengan cara tanpa sistem melalui modul
- post-fs-data.sh: waktu eksekusi dan semantiknya persis sama
- service.sh: waktu eksekusi dan semantiknya persis sama
- system.prop: sepenuhnya sama
- sepolicy.rule: sama persis
- BusyBox: skrip dijalankan di BusyBox dengan "mode mandiri" diaktifkan di kedua kasus

## Perbedaan

Sebelum memahami perbedaannya, Anda perlu mengetahui cara membedakan apakah modul Anda berjalan di KernelSU atau Magisk. Anda dapat menggunakan variabel lingkungan `KSU` untuk membedakannya di semua tempat di mana Anda dapat menjalankan skrip modul (`customize.sh`, `post-fs-data.sh`, `service.sh`). Di KernelSU, variabel lingkungan ini akan disetel ke `true`.

Berikut beberapa perbedaannya:

- Modul KernelSU tidak dapat diinstal dalam mode Pemulihan.
- Modul KernelSU tidak memiliki dukungan bawaan untuk Zygisk (tetapi Anda dapat menggunakan modul Zygisk melalui [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).
- Metode untuk mengganti atau menghapus file dalam modul KernelSU sama sekali berbeda dari Magisk. KernelSU tidak mendukung metode `.replace`. Sebagai gantinya, Anda perlu membuat file dengan nama yang sama dengan `mknod filename c 0 0` untuk menghapus file terkait.
- Direktori untuk BusyBox berbeda. BusyBox bawaan di KernelSU terletak di `/data/adb/ksu/bin/busybox`, sedangkan di Magisk terletak di `/data/adb/magisk/busybox`. **Perhatikan bahwa ini adalah perilaku internal KernelSU dan dapat berubah di masa mendatang!**
- KernelSU tidak mendukung file `.replace`; namun, KernelSU mendukung variabel `REMOVE` dan `REPLACE` untuk menghapus atau mengganti file dan folder.

```

`website/docs/id_ID/guide/faq.md`:

```md
# FAQ

## Apakah KernelSU mendukung perangkat saya?

KernelSU mendukung perangkat yang menjalankan Android dengan bootloader yang tidak terkunci. Namun, dukungan resmi hanya untuk GKI Linux Kernel 5.10+ (dalam praktiknya, ini berarti perangkat Anda harus memiliki Android 12 out-of-the-box agar didukung).

Anda dapat dengan mudah memeriksa dukungan untuk perangkat Anda melalui aplikasi manajer KernelSU, yang tersedia [di sini](https://github.com/tiann/KernelSU/releases).

Jika aplikasi menunjukkan `Not installed`, berarti perangkat Anda secara resmi didukung oleh KernelSU.

Jika aplikasi menunjukkan `Unsupported`, berarti perangkat Anda tidak didukung secara resmi saat ini. Namun, Anda dapat membangun kode sumber kernel dan mengintegrasikan KernelSU untuk membuatnya bekerja, atau gunakan [Perangkat yang didukung tidak resmi](unofficially-support-devices).

## Apakah KernelSU membutuhkan buka bootloader?

Ya, tentu saja.

## Apakah KernelSU mendukung modul?

Ya, sebagian besar modul Magisk bekerja di KernelSU. Namun, jika modul Anda perlu memodifikasi file `/system`, Anda perlu menginstal [metamodule](metamodule.md) (seperti `meta-overlayfs`). Fitur modul lainnya bekerja tanpa metamodule. Periksa [Panduan modul](module.md) untuk info lebih lanjut.

## Apakah KernelSU mendukung Xposed?

Ya, Anda dapat menggunakan LSPosed (atau turunan Xposed modern lainnya) dengan [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).

## Apakah KernelSU mendukung Zygisk?

KernelSU tidak memiliki dukungan Zygisk bawaan, tetapi Anda dapat menggunakan modul seperti [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) untuk mendukungnya.

## Apakah KernelSU kompatibel dengan Magisk?

Sistem modul KernelSU bertentangan dengan magic mount Magisk. Jika ada modul yang diaktifkan di KernelSU, maka seluruh Magisk akan berhenti bekerja.

Namun, jika Anda hanya menggunakan `su` dari KernelSU, ini akan bekerja dengan baik dengan Magisk. KernelSU memodifikasi `kernel`, sedangkan Magisk memodifikasi `ramdisk`, memungkinkan keduanya bekerja bersama.

## Akankah KernelSU menggantikan Magisk?

Kami percaya tidak, dan itu bukan tujuan kami. Magisk sudah cukup baik untuk solusi root userspace dan akan memiliki umur yang panjang. Tujuan KernelSU adalah untuk menyediakan antarmuka kernel kepada pengguna, bukan untuk menggantikan Magisk.

## Dapatkah KernelSU mendukung perangkat non-GKI?

Ada kemungkinan. Tetapi Anda harus mengunduh sumber kernel dan mengintegrasikan KernelSU ke dalam source tree, dan mengkompilasi kernel sendiri.

## Dapatkah KernelSU mendukung perangkat di bawah Android 12?

Kernel perangkat yang mempengaruhi kompatibilitas KernelSU, dan tidak ada hubungannya dengan versi Android. Satu-satunya batasan adalah bahwa perangkat yang diluncurkan dengan Android 12 harus memiliki versi kernel 5.10+ (perangkat GKI). Jadi:

1. Perangkat yang diluncurkan dengan Android 12 harus didukung.
2. Perangkat dengan kernel lama (beberapa perangkat dengan Android 12 juga memiliki kernel lama) kompatibel (Anda harus membangun kernel sendiri).

## Dapatkah KernelSU mendukung kernel lama?

Ada kemungkinan. KernelSU sekarang telah di-backport ke kernel 4.14. Untuk kernel yang lebih lama, Anda perlu melakukan backport secara manual, dan PR selalu diterima!

## Bagaimana cara mengintegrasikan KernelSU untuk kernel lama?

Silakan periksa panduan [Integrasi untuk perangkat non-GKI](how-to-integrate-for-non-gki).

## Mengapa versi Android saya 13, dan kernel menunjukkan "android12-5.10"?

Versi kernel tidak ada hubungannya dengan versi Android. Jika Anda perlu mem-flash kernel, selalu gunakan versi kernel; versi Android tidak sepenting itu.

## Saya GKI 1.0, bisakah saya menggunakan ini?

GKI 1.0 sama sekali berbeda dari GKI 2.0, Anda harus mengkompilasi kernel sendiri.

## Bagaimana cara membuat `/system` RW?

Kami tidak merekomendasikan Anda memodifikasi partisi sistem secara langsung. Silakan periksa [Panduan modul](module.md) untuk memodifikasinya secara systemless. Jika Anda bersikeras melakukan ini, periksa [magisk_overlayfs](https://github.com/HuskyDG/magic_overlayfs).

## Bisakah KernelSU memodifikasi hosts? Bagaimana cara menggunakan AdAway?

Tentu saja. Tetapi KernelSU tidak memiliki dukungan hosts bawaan, Anda dapat menginstal modul seperti [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module) untuk melakukannya.

## Mengapa modul saya tidak bekerja setelah instalasi baru?

Jika modul Anda perlu memodifikasi file `/system`, Anda perlu menginstal [metamodule](metamodule.md) untuk me-mount direktori `system`. Fitur modul lainnya (skrip, sepolicy, system.prop) bekerja tanpa metamodule.

**Solusi**: Lihat [Panduan Metamodule](metamodule.md) untuk instruksi instalasi.

## Apa itu metamodule dan mengapa saya membutuhkannya?

Metamodule adalah modul khusus yang menyediakan infrastruktur untuk me-mount modul reguler. Lihat [Panduan Metamodule](metamodule.md) untuk penjelasan lengkap.

```

`website/docs/id_ID/guide/hidden-features.md`:

```md
# Fitur tersembunyi

## .ksurc

Secara bawaan, `/system/bin/sh` akan memuat `/system/etc/mkshrc`.

Anda dapat membuat `su` memuat berkas rc khusus dengan membuat berkas `/data/adb/ksu/.ksurc`.

```

`website/docs/id_ID/guide/how-to-build.md`:

```md
# Bagaimana caranya untuk build KernelSU?

::: warning
Dokumen ini hanya untuk referensi arsip dan tidak lagi diperbarui.
Sejak KernelSU v3.0, kami telah menghentikan dukungan resmi untuk mode gambar GKI demi iterasi dan kecepatan build yang lebih cepat. Disarankan untuk menggunakan `Ylarod/ddk` untuk membangun LKM.
:::

Pertama, Anda harus membaca dokumen resmi Android untuk membangun kernel:

1. [Building Kernels](https://source.android.com/docs/setup/build/building-kernels)
2. [GKI Release Builds](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

> Halaman ini untuk perangkat GKI, jika Anda menggunakan kernel lama, silakan lihat [cara mengintegrasikan KernelSU untuk kernel lama](how-to-integrate-for-non-gki)

## Build Kernel

### Menyinkronkan source code kernel

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

`<kernel_manifest.xml>` adalah berkas manifes yang dapat menentukan build secara unik, Anda dapat menggunakan manifes tersebut untuk melakukan build yang dapat diprediksikan ulang. Anda harus mengunduh berkas manifes dari [Google GKI release builds](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

### Build

Silakan periksa [official docs](https://source.android.com/docs/setup/build/building-kernels) terlebih dahulu.

Sebagai contoh, kita perlu build image kernel aarch64:

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

Jangan lupa untuk menambahkan flag `LTO=thin`, jika tidak, maka build akan gagal jika memori komputer Anda kurang dari 24GB.

Mulai dari Android 13, kernel dibuild oleh `bazel`:

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

## Build Kernel dengan KernelSU

Jika Anda dapat build kernel dengan sukses, maka build KernelSU sangatlah mudah, jalankan perintah ini di root dir kernel source:

- Latest tag(stable)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

- main branch(dev)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

- Select tag(Such as v0.5.2)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

Dan kemudian build ulang kernel dan Anda akan mendapatkan image kernel dengan KernelSU!

```

`website/docs/id_ID/guide/how-to-integrate-for-non-gki.md`:

```md
# Bagaimana Caranya untuk mengintegrasikan KernelSU ke kernel non GKI?

::: warning
Dokumen ini hanya untuk referensi arsip dan tidak lagi diperbarui.
Sejak KernelSU v1.0, kami telah menghentikan dukungan resmi untuk perangkat non-GKI.
:::

KernelSU dapat diintegrasikan ke kernel non GKI, dan saat ini sudah di-backport ke 4.14, dan juga dapat dijalankan pada kernel di bawah 4.14.

Karena fragmentasi kernel non GKI, kami tidak memiliki cara yang seragam untuk membangunnya, sehingga kami tidak dapat menyediakan gambar boot non GKI. Tetapi Anda dapat membangun kernel sendiri dengan KernelSU yang terintegrasi.

Pertama, Anda harus dapat membangun kernel yang dapat di-boot dari kode sumber kernel, jika kernel tersebut tidak open source, maka akan sulit untuk menjalankan KernelSU untuk perangkat Anda.

Jika Anda dapat membuat kernel yang dapat di-booting, ada dua cara untuk mengintegrasikan KernelSU ke kode sumber kernel:

1. Secara otomatis dengan `kprobe`
2. Secara manual

## Integrasikan dengan kprobe

KernelSU menggunakan kprobe untuk melakukan hook kernel, jika *kprobe* berjalan dengan baik pada kernel Anda, maka disarankan untuk menggunakan cara ini.

Pertama, tambahkan KernelSU ke dalam berkas kernel source tree:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

:::info
[KernelSU 1.0 dan versi yang lebih baru tidak lagi mendukung kernel non-GKI](https://github.com/tiann/KernelSU/issues/1705). Versi terakhir yang didukung adalah `v0.9.5`, pastikan untuk menggunakan versi yang benar.
:::

Kemudian, Anda harus memeriksa apakah *kprobe* diaktifkan dalam konfigurasi kernel Anda, jika tidak, tambahkan konfigurasi ini ke dalamnya:

```
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

Dan build kernel Anda lagi, KernelSU seharusnya bekerja dengan baik.

Jika Anda menemukan bahwa KPROBES masih belum diaktifkan, Anda dapat mencoba mengaktifkan `CONFIG_MODULES`. (Jika masih belum berlaku, gunakan `make menuconfig` untuk mencari ketergantungan KPROBES yang lain)

etapi jika Anda mengalami boot loop saat mengintegrasikan KernelSU, itu mungkin *kprobe rusak di kernel Anda*, Anda harus memperbaiki bug kprobe atau menggunakan cara kedua.

## Memodifikasi sumber kernel secara manual

Jika kprobe tidak dapat bekerja pada kernel Anda (mungkin karena bug di upstream atau kernel di bawah 4.8), maka Anda dapat mencoba cara ini:

Pertama, tambahkan KernelSU ke dalam direktori kernel source tree:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

Kemudian, tambahkan panggilan KernelSU ke source kernel, berikut ini adalah patch yang dapat dirujuk:

```diff
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }
 
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);
 
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
 
+	ksu_handle_stat(&dfd, &filename, &flags);
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```

Anda harus menemukan empat fungsi dalam kernel source:

1. do_faccessat, usually in `fs/open.c`
2. do_execveat_common, usually in `fs/exec.c`
3. vfs_read, usually in `fs/read_write.c`
4. vfs_statx, usually in `fs/stat.c`

Jika kernel anda tidak memiliki `vfs_statx`, maka gunakan `vfs_fstatat` alih-alih:

```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
 
+	ksu_handle_stat(&dfd, &filename, &flag);
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

Untuk kernel lebih awal dari 4.17, jika anda menemukan `do_faccessat`, hanya pergi ke definisi yang sama `faccessat` syscall dan tempatkan pemanggil di sini:

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

Untuk mengaktifkan KernelSU yang dibangun dalam SafeMode, Anda juga harus memodifikasi `input_handle_event` di `drivers/input/input.c`:

:::tip
Fitur ini sangat direkomendasikan, serta sangat membantu untuk memulihkan pada saat bootloop!
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }
 
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

Terakhir, edit `KernelSU/kernel/ksu.c` dan beri komentar pada `enable_sucompat()` lalu build kernel Anda lagi, KernelSU akan bekerja dengan baik.

### How to backport path_umount

Anda dapat membuat fitur "Umount modules" berfungsi pada kernel pra-GKI dengan membackport `path_umount` secara manual dari versi 5.9. Anda dapat menggunakan patch ini sebagai referensi:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

Terakhir, build kembali kernel Anda, dan KernelSU akan berfungsi dengan benar.

```

`website/docs/id_ID/guide/installation.md`:

```md
# Instalasi

## Periksa apakah perangkat Anda didukung

Unduh manajer KernelSU dari [GitHub Releases](https://github.com/tiann/KernelSU/releases) dan instal ke perangkat Anda:

- Jika aplikasi menunjukkan `Unsupported`, itu berarti **Anda harus mengkompilasi kernel sendiri**, KernelSU tidak akan dan tidak pernah menyediakan file boot.img untuk Anda flash.
- Jika aplikasi menunjukkan `Not installed`, maka perangkat Anda secara resmi didukung oleh KernelSU.

::: info
Untuk perangkat yang menunjukkan `Unsupported`, Anda dapat memeriksa daftar [Perangkat yang didukung tidak resmi](unofficially-support-devices.md). Anda dapat mengkompilasi kernel sendiri.
:::

## Cadangkan boot.img stok

Sebelum flashing, sangat penting untuk mencadangkan boot.img stok Anda. Jika Anda mengalami bootloop, Anda selalu dapat memulihkan sistem dengan mem-flash kembali ke boot pabrik stok menggunakan fastboot.

::: warning
Flashing dapat menyebabkan kehilangan data. Pastikan untuk melakukan langkah ini dengan baik sebelum melanjutkan ke langkah berikutnya! Anda juga dapat mencadangkan semua data di perangkat Anda jika diperlukan.
:::

## Pengetahuan yang diperlukan

### ADB dan fastboot

Secara default, Anda akan menggunakan alat ADB dan fastboot dalam tutorial ini, jadi jika Anda tidak mengetahuinya, kami sarankan menggunakan mesin pencari untuk mempelajarinya terlebih dahulu.

### KMI

Kernel Module Interface (KMI), versi kernel dengan KMI yang sama **kompatibel**, inilah yang dimaksud dengan "general" dalam GKI; sebaliknya, jika KMI berbeda, maka kernel ini tidak kompatibel satu sama lain, dan mem-flash image kernel dengan KMI yang berbeda dari perangkat Anda dapat menyebabkan bootloop.

Secara khusus, untuk perangkat GKI, format versi kernel harus sebagai berikut:

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

`w.x-zzz-k` adalah versi KMI. Misalnya, jika versi kernel perangkat adalah `5.10.101-android12-9-g30979850fc20`, maka KMI-nya adalah `5.10-android12-9`. Secara teoritis, dapat boot secara normal dengan kernel KMI lainnya.

::: tip
Perhatikan bahwa SubLevel dalam versi kernel bukan bagian dari KMI! Ini berarti `5.10.101-android12-9-g30979850fc20` memiliki KMI yang sama dengan `5.10.137-android12-9-g30979850fc20`!
:::

### Tingkat patch keamanan {#security-patch-level}

Perangkat Android yang lebih baru mungkin memiliki mekanisme anti-rollback yang mencegah flashing image boot dengan tingkat patch keamanan lama. Misalnya, jika kernel perangkat Anda adalah `5.10.101-android12-9-g30979850fc20`, tingkat patch keamanan adalah `2023-11`; bahkan jika Anda mem-flash kernel yang sesuai dengan KMI, jika tingkat patch keamanan lebih lama dari `2023-11` (seperti `2023-06`), ini dapat menyebabkan bootloop.

Oleh karena itu, kernel dengan tingkat patch keamanan terbaru lebih disukai untuk menjaga kompatibilitas dengan KMI.

### Versi kernel vs versi Android

Harap dicatat: **Versi kernel dan versi Android tidak harus sama!**

Jika Anda menemukan bahwa versi kernel Anda adalah `android12-5.10.101`, tetapi versi sistem Android Anda adalah Android 13 atau lainnya, jangan heran, karena nomor versi sistem Android tidak harus sama dengan nomor versi kernel Linux. Nomor versi kernel Linux umumnya sesuai dengan versi sistem Android yang disertakan dengan **perangkat saat dikirim**. Jika sistem Android diupgrade nanti, versi kernel umumnya tidak akan berubah. Jadi, sebelum mem-flash apa pun, **selalu rujuk versi kernel!**

## Pendahuluan

Sejak versi [0.9.0](https://github.com/tiann/KernelSU/releases/tag/v0.9.0), KernelSU mendukung dua mode berjalan pada perangkat GKI:

1. `GKI`: Ganti kernel asli perangkat dengan **Generic Kernel Image** (GKI) yang disediakan oleh KernelSU.
2. `LKM`: Muat **Loadable Kernel Module** (LKM) ke dalam kernel perangkat tanpa mengganti kernel asli.

Kedua mode ini cocok untuk skenario yang berbeda, dan Anda dapat memilih salah satu sesuai kebutuhan Anda.

### Mode GKI {#gki-mode}

Dalam mode GKI, kernel asli perangkat akan diganti dengan image kernel generik yang disediakan oleh KernelSU. Keuntungan mode GKI adalah:

1. Universalitas yang kuat, cocok untuk sebagian besar perangkat. Misalnya, Samsung telah mengaktifkan perangkat KNOX, dan mode LKM tidak dapat berfungsi. Ada juga beberapa perangkat yang dimodifikasi khusus yang hanya dapat menggunakan mode GKI.
2. Dapat digunakan tanpa bergantung pada firmware resmi, dan tidak perlu menunggu pembaruan firmware resmi, selama KMI konsisten, dapat digunakan.

### Mode LKM {#lkm-mode}

Dalam mode LKM, kernel asli perangkat tidak akan diganti, tetapi loadable kernel module akan dimuat ke dalam kernel perangkat. Keuntungan mode LKM adalah:

1. Tidak akan mengganti kernel asli perangkat. Jika Anda memiliki persyaratan khusus untuk kernel asli perangkat, atau Anda ingin menggunakan KernelSU sambil menggunakan kernel pihak ketiga, Anda dapat menggunakan mode LKM.
2. Lebih nyaman untuk upgrade dan OTA. Saat mengupgrade KernelSU, Anda dapat langsung menginstalnya di manajer tanpa flashing manual. Setelah OTA sistem, Anda dapat langsung menginstalnya ke slot kedua tanpa flashing manual.
3. Cocok untuk beberapa skenario khusus. Misalnya, LKM juga dapat dimuat dengan izin root sementara. Karena tidak perlu mengganti partisi boot, tidak akan memicu AVB dan tidak akan menyebabkan perangkat menjadi brick.
4. LKM dapat di-uninstall sementara. Jika Anda ingin menonaktifkan akses root sementara, Anda dapat meng-uninstall LKM. Proses ini tidak memerlukan flashing partisi, atau bahkan me-reboot perangkat. Jika Anda ingin mengaktifkan root lagi, cukup reboot perangkat.

::: tip KOEKSISTENSI DUA MODE
Setelah membuka manajer, Anda dapat melihat mode perangkat saat ini di beranda. Perhatikan bahwa prioritas mode GKI lebih tinggi daripada LKM. Misalnya, jika Anda menggunakan kernel GKI untuk mengganti kernel asli, dan menggunakan LKM untuk mem-patch kernel GKI, LKM akan diabaikan, dan perangkat akan selalu berjalan dalam mode GKI.
:::

### Yang mana yang harus dipilih? {#which-one}

Jika perangkat Anda adalah ponsel, kami sarankan Anda memprioritaskan mode LKM. Jika perangkat Anda adalah emulator, WSA, atau Waydroid, kami sarankan Anda memprioritaskan mode GKI.

## Instalasi LKM

### Dapatkan firmware resmi

Untuk menggunakan mode LKM, Anda perlu mendapatkan firmware resmi dan mem-patch-nya berdasarkan firmware resmi. Jika Anda menggunakan kernel pihak ketiga, Anda dapat menggunakan `boot.img` dari kernel pihak ketiga sebagai firmware resmi.

Ada banyak cara untuk mendapatkan firmware resmi. Jika perangkat Anda mendukung `fastboot boot`, kami merekomendasikan **metode yang paling direkomendasikan dan paling sederhana** adalah menggunakan `fastboot boot` untuk boot sementara kernel GKI yang disediakan oleh KernelSU, lalu instal manajer, dan akhirnya instal langsung di manajer. Metode ini tidak memerlukan pengunduhan firmware resmi secara manual atau ekstraksi boot secara manual.

Jika perangkat Anda tidak mendukung `fastboot boot`, Anda mungkin perlu mengunduh paket firmware resmi secara manual dan mengekstrak boot darinya.

Tidak seperti mode GKI, mode LKM memodifikasi `ramdisk`. Oleh karena itu, pada perangkat dengan Android 13, perlu mem-patch partisi `init_boot` alih-alih partisi `boot`, sedangkan mode GKI selalu beroperasi pada partisi `boot`.

### Gunakan manajer

Buka manajer, klik ikon instalasi di sudut kanan atas, dan beberapa opsi akan muncul:

1. Pilih file. Jika perangkat Anda tidak memiliki hak root, Anda dapat memilih opsi ini lalu pilih firmware resmi Anda. Manajer akan secara otomatis mem-patch-nya. Setelah itu, flash file yang di-patch ini untuk mendapatkan hak root secara permanen.
2. Instalasi langsung. Jika perangkat Anda sudah di-root, Anda dapat memilih opsi ini. Manajer akan secara otomatis mendapatkan informasi perangkat Anda, lalu secara otomatis mem-patch firmware resmi, dan mem-flash-nya secara otomatis. Anda dapat mempertimbangkan menggunakan `fastboot boot` kernel GKI KernelSU untuk mendapatkan root sementara dan menginstal manajer, lalu gunakan opsi ini. Ini juga merupakan cara utama untuk mengupgrade KernelSU.
3. Instal ke slot yang tidak aktif. Jika perangkat Anda mendukung partisi A/B, Anda dapat memilih opsi ini. Manajer akan secara otomatis mem-patch firmware resmi dan menginstalnya ke partisi lain. Metode ini cocok untuk perangkat setelah OTA, Anda dapat langsung menginstalnya ke partisi lain setelah OTA, lalu restart perangkat.

### Gunakan baris perintah

Jika Anda tidak ingin menggunakan manajer, Anda juga dapat menggunakan baris perintah untuk menginstal LKM. Alat `ksud` yang disediakan oleh KernelSU dapat membantu Anda mem-patch firmware resmi dengan cepat lalu mem-flash-nya.

Alat ini mendukung macOS, Linux, dan Windows. Anda dapat mengunduh versi yang sesuai dari [GitHub Release](https://github.com/tiann/KernelSU/releases).

Penggunaan: `ksud boot-patch` Anda dapat memeriksa bantuan baris perintah untuk opsi spesifik.

```sh
oriole:/ # ksud boot-patch -h
Patch boot or init_boot images to apply KernelSU

Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              Boot image path. If not specified, it will try to find the boot image automatically
  -k, --kernel <KERNEL>          Kernel image path to be replaced
  -m, --module <MODULE>          LKM module path to be replaced. If not specified, the built-in module will be used
  -i, --init <INIT>              init to be replaced
  -u, --ota                      Will use another slot if the boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                Output path. If not specified, the current directory will be used
      --magiskboot <MAGISKBOOT>  magiskboot path. If not specified, the built-in version will be used
      --kmi <KMI>                KMI version. If specified, the indicated KMI will be used
  -h, --help                     Print help
```

Beberapa opsi yang perlu dijelaskan:

1. Opsi `--magiskboot` dapat menentukan path magiskboot. Jika tidak ditentukan, ksud akan mencarinya di variabel lingkungan. Jika Anda tidak tahu cara mendapatkan magiskboot, Anda dapat memeriksa [di sini](#patch-boot-image).
2. Opsi `--kmi` dapat menentukan versi `KMI`. Jika nama kernel perangkat Anda tidak mengikuti spesifikasi KMI, Anda dapat menentukannya menggunakan opsi ini.

Penggunaan paling umum adalah:

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## Instalasi mode GKI

Ada beberapa metode instalasi untuk mode GKI, masing-masing cocok untuk skenario yang berbeda, jadi pilih sesuai:

1. Instal dengan fastboot menggunakan boot.img yang disediakan oleh KernelSU.
2. Instal dengan aplikasi flash kernel, seperti [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases).
3. Perbaiki boot.img secara manual dan instal.
4. Instal dengan Recovery kustom (misalnya, TWRP).

## Instal dengan boot.img yang disediakan oleh KernelSU

Jika `boot.img` perangkat Anda menggunakan format kompresi yang umum digunakan, Anda dapat menggunakan image GKI yang disediakan oleh KernelSU untuk mem-flash-nya langsung. Ini tidak memerlukan TWRP atau self-patching image.

### Temukan boot.img yang tepat

KernelSU menyediakan boot.img generik untuk perangkat GKI, dan Anda harus mem-flash boot.img ke partisi boot perangkat.

Anda dapat mengunduh boot.img dari [GitHub Release](https://github.com/tiann/KernelSU/releases). Harap dicatat bahwa Anda harus menggunakan versi boot.img yang benar. Jika Anda tidak tahu file mana yang harus diunduh, baca dengan cermat deskripsi [KMI](#kmi) dan [Tingkat patch keamanan](#security-patch-level) dalam dokumen ini.

Biasanya, ada tiga file boot dalam format berbeda untuk KMI dan tingkat patch keamanan yang sama. Mereka identik kecuali format kompresi kernel. Harap periksa format kompresi kernel dari boot.img asli Anda. Anda harus menggunakan format yang benar, seperti `lz4`, `gz`. Jika Anda menggunakan format kompresi yang salah, Anda mungkin mengalami bootloop setelah mem-flash boot.img.

::: info FORMAT KOMPRESI BOOT.IMG
1. Anda dapat menggunakan magiskboot untuk mendapatkan format kompresi dari boot.img asli Anda. Atau, Anda juga dapat bertanya kepada anggota atau pengembang di komunitas yang memiliki model perangkat yang sama. Juga, format kompresi kernel biasanya tidak berubah, jadi jika Anda boot sukses dengan format kompresi tertentu, Anda dapat mencoba format itu nanti juga.
2. Perangkat Xiaomi biasanya menggunakan `gz` atau `uncompressed`.
3. Untuk perangkat Pixel, ikuti instruksi di bawah ini:
:::

### Flash boot.img ke perangkat

Gunakan `adb` untuk menghubungkan perangkat Anda, lalu jalankan `adb reboot bootloader` untuk masuk ke mode fastboot, dan gunakan perintah ini untuk mem-flash KernelSU:

```sh
fastboot flash boot boot.img
```

::: info
Jika perangkat Anda mendukung `fastboot boot`, Anda dapat terlebih dahulu menggunakan `fastboot boot boot.img` untuk mencoba menggunakan boot.img untuk boot sistem terlebih dahulu. Jika ada yang tidak terduga terjadi, restart lagi untuk boot.
:::

### Reboot

Setelah flash selesai, Anda harus me-reboot perangkat Anda:

```sh
fastboot reboot
```

## Instal dengan Kernel Flasher

Langkah-langkah:

1. Unduh ZIP AnyKernel3. Jika Anda tidak tahu file mana yang harus diunduh, baca dengan cermat deskripsi [KMI](#kmi) dan [Tingkat patch keamanan](#security-patch-level) dalam dokumen ini.
2. Buka aplikasi Kernel Flasher, berikan izin root yang diperlukan, dan gunakan ZIP AnyKernel3 yang disediakan untuk mem-flash.

Dengan cara ini memerlukan aplikasi Kernel Flasher memiliki izin root. Anda dapat menggunakan metode berikut untuk mencapai ini:

1. Perangkat Anda telah di-root. Misalnya, Anda telah menginstal KernelSU dan ingin mengupgrade ke versi terbaru atau Anda telah di-root melalui metode lain (seperti Magisk).
2. Jika perangkat Anda tidak di-root, tetapi perangkat mendukung metode boot sementara `fastboot boot boot.img`, Anda dapat menggunakan image GKI yang disediakan oleh KernelSU untuk boot sementara perangkat Anda, mendapatkan izin root sementara, lalu gunakan aplikasi Kernel Flash untuk mendapatkan hak root permanen.

Beberapa aplikasi flashing kernel yang dapat digunakan untuk ini:

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

Catatan: Metode ini lebih nyaman saat mengupgrade KernelSU dan dapat dilakukan tanpa komputer (buat cadangan terlebih dahulu).

## Patch boot.img secara manual {#patch-boot-image}

Untuk beberapa perangkat, format boot.img tidak seperti `lz4`, `gz`, dan `uncompressed` yang umum. Contoh khas adalah Pixel, di mana boot.img dikompresi dalam format `lz4_legacy`, sedangkan ramdisk mungkin dalam `gz` atau juga dikompresi dalam `lz4_legacy`. Saat ini, jika Anda langsung mem-flash boot.img yang disediakan oleh KernelSU, perangkat mungkin tidak dapat boot. Dalam hal ini, Anda dapat mem-patch boot.img secara manual untuk mencapai ini.

Selalu disarankan untuk menggunakan `magiskboot` untuk mem-patch image, ada dua cara:

1. [magiskboot](https://github.com/topjohnwu/Magisk/releases)
2. [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci)

Build resmi `magiskboot` hanya dapat berjalan di perangkat Android, jika Anda ingin menjalankannya di PC, Anda dapat mencoba opsi kedua.

::: tip
Android-Image-Kitchen tidak direkomendasikan untuk saat ini karena tidak menangani metadata boot (seperti tingkat patch keamanan) dengan benar. Oleh karena itu, mungkin tidak berfungsi pada beberapa perangkat.
:::

### Persiapan

1. Dapatkan boot.img stok perangkat Anda. Anda bisa mendapatkannya dari produsen perangkat Anda. Anda mungkin memerlukan [payload-dumper-go](https://github.com/ssut/payload-dumper-go).
2. Unduh file ZIP AnyKernel3 yang disediakan oleh KernelSU yang cocok dengan versi KMI perangkat Anda. Anda dapat merujuk ke [Instal dengan Recovery kustom](#install-with-custom-recovery).
3. Unpack paket AnyKernel3 dan dapatkan file `Image`, yang merupakan file kernel KernelSU.

### Menggunakan magiskboot di perangkat Android {#using-magiskboot-on-Android-devices}

1. Unduh Magisk terbaru dari [GitHub Releases](https://github.com/topjohnwu/Magisk/releases).
2. Ubah nama `Magisk-*(version).apk` menjadi `Magisk-*.zip` dan unzip.
3. Push `Magisk-*/lib/arm64-v8a/libmagiskboot.so` ke perangkat Anda melalui ADB: `adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`
4. Push stok boot.img dan Image di AnyKernel3 ke perangkat Anda.
5. Masuk ke shell ADB dan jalankan direktori `cd /data/local/tmp/`, lalu `chmod +x magiskboot`
6. Masuk ke shell ADB dan jalankan direktori `cd /data/local/tmp/`, jalankan `./magiskboot unpack boot.img` untuk unpack `boot.img`, Anda akan mendapatkan file `kernel`, ini adalah kernel stok Anda.
7. Ganti `kernel` dengan `Image` dengan menjalankan perintah: `mv -f Image kernel`.
8. Jalankan `./magiskboot repack boot.img` untuk repack image boot, dan Anda akan mendapatkan file `new-boot.img`, flash file ini ke perangkat melalui fastboot.

### Menggunakan magiskboot di Windows/macOS/Linux PC {#using-magiskboot-on-PC}

1. Unduh binary `magiskboot` yang sesuai untuk OS Anda dari [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci).
2. Siapkan stok `boot.img` dan `Image` di PC Anda.
3. Jalankan `chmod +x magiskboot`.
4. Masuk ke direktori yang sesuai, jalankan `./magiskboot unpack boot.img` untuk unpack `boot.img`, Anda akan mendapatkan file `kernel`, ini adalah kernel stok Anda.
5. Ganti `kernel` dengan `Image` dengan menjalankan perintah: `mv -f Image kernel`.
6. Jalankan `./magiskboot repack boot.img` untuk repack image boot, dan Anda akan mendapatkan file `new-boot.img`, flash file ini ke perangkat melalui fastboot.

::: info
`magiskboot` resmi dapat berjalan di lingkungan `Linux` secara normal, jika Anda pengguna Linux, Anda dapat menggunakan build resmi.
:::

## Instal dengan Recovery kustom {#install-with-custom-recovery}

Prasyarat: Perangkat Anda harus memiliki Recovery kustom, seperti TWRP. Jika tidak ada Recovery kustom yang tersedia untuk perangkat Anda, gunakan metode lain.

Langkah-langkah:

1. Di [GitHub Releases](https://github.com/tiann/KernelSU/releases), unduh paket ZIP yang dimulai dengan `AnyKernel3` yang cocok dengan versi perangkat Anda. Misalnya, jika versi kernel perangkat adalah `android12-5.10.66`, maka Anda harus mengunduh file `AnyKernel3-android12-5.10.66_yyyy-MM.zip` (di mana `yyyy` adalah tahun dan `MM` adalah bulan).
2. Reboot perangkat ke TWRP.
3. Gunakan ADB untuk menempatkan AnyKernel3-*.zip ke lokasi `/sdcard` perangkat dan pilih untuk menginstalnya di GUI TWRP, atau Anda dapat langsung menjalankan `adb sideload AnyKernel-*.zip` untuk menginstal.

Catatan: Metode ini cocok untuk instalasi apa pun (tidak terbatas pada instalasi awal atau upgrade selanjutnya), selama Anda menggunakan TWRP.

## Metode lain

Faktanya, semua metode instalasi ini hanya memiliki satu ide utama, yaitu **mengganti kernel asli dengan yang disediakan oleh KernelSU**, selama ini dapat dicapai, dapat diinstal. Berikut adalah metode lain yang mungkin:

1. Pertama, instal Magisk, dapatkan hak root melalui Magisk, lalu gunakan Kernel Flasher untuk mem-flash AnyKernel3 ZIP dari KernelSU.
2. Gunakan toolkit flashing apa pun di PC untuk mem-flash kernel yang disediakan oleh KernelSU.

Namun, jika tidak berhasil, coba pendekatan `magiskboot`.

## Pasca-Instalasi: Dukungan Modul

::: warning METAMODULE UNTUK MODIFIKASI FILE SISTEM
Jika Anda ingin menggunakan modul yang memodifikasi file `/system`, Anda perlu menginstal **metamodule** setelah menginstal KernelSU. Modul yang hanya menggunakan skrip, sepolicy, atau system.prop bekerja tanpa metamodule.
:::

**Untuk dukungan modifikasi `/system`**, silakan lihat [Panduan Metamodule](metamodule.md) untuk:
- Memahami apa itu metamodule dan mengapa diperlukan
- Menginstal metamodule `meta-overlayfs` resmi
- Pelajari tentang opsi metamodule lainnya

```

`website/docs/id_ID/guide/metamodule.md`:

```md
# Metamodul

Metamodul adalah fitur revolusioner di KernelSU yang mentransfer kemampuan sistem modul yang penting dari daemon inti ke modul yang dapat dipasang. Pergeseran arsitektur ini mempertahankan stabilitas dan keamanan KernelSU sambil melepaskan potensi inovasi yang lebih besar untuk ekosistem modul.

## Apa itu Metamodul?

Metamodul adalah jenis modul KernelSU khusus yang menyediakan fungsi infrastruktur inti untuk sistem modul. Tidak seperti modul biasa yang memodifikasi file sistem, metamodul mengontrol *bagaimana* modul biasa diinstal dan dipasang.

Metamodul adalah mekanisme ekstensi berbasis plugin yang memungkinkan kustomisasi lengkap infrastruktur manajemen modul KernelSU. Dengan mendelegasikan logika pemasangan dan instalasi ke metamodul, KernelSU menghindari menjadi titik deteksi yang rapuh sambil memungkinkan strategi implementasi yang beragam.

**Karakteristik utama:**

- **Peran infrastruktur**: Metamodul menyediakan layanan yang diandalkan modul biasa
- **Instans tunggal**: Hanya satu metamodul yang dapat diinstal pada satu waktu
- **Eksekusi prioritas**: Skrip metamodul berjalan sebelum skrip modul biasa
- **Hook khusus**: Menyediakan tiga skrip hook untuk instalasi, pemasangan, dan pembersihan

## Mengapa Metamodul?

Solusi root tradisional memasukkan logika pemasangan ke dalam inti mereka, membuat mereka lebih mudah dideteksi dan lebih sulit untuk berkembang. Arsitektur metamodul KernelSU memecahkan masalah ini melalui pemisahan perhatian.

**Keunggulan strategis:**

- **Mengurangi permukaan deteksi**: KernelSU sendiri tidak melakukan pemasangan, mengurangi vektor deteksi
- **Stabilitas**: Daemon inti tetap stabil sementara implementasi pemasangan dapat berkembang
- **Inovasi**: Komunitas dapat mengembangkan strategi pemasangan alternatif tanpa mem-fork KernelSU
- **Pilihan**: Pengguna dapat memilih implementasi yang paling sesuai dengan kebutuhan mereka

**Fleksibilitas pemasangan:**

- **Tanpa pemasangan**: Untuk pengguna dengan modul tanpa pemasangan saja, hindari overhead pemasangan sepenuhnya
- **Pemasangan OverlayFS**: Pendekatan tradisional dengan dukungan lapisan baca-tulis (melalui `meta-overlayfs`)
- **Magic mount**: Pemasangan kompatibel Magisk untuk kompatibilitas aplikasi yang lebih baik
- **Implementasi kustom**: Overlay berbasis FUSE, pemasangan VFS kustom, atau pendekatan yang sama sekali baru

**Melampaui pemasangan:**

- **Ekstensibilitas**: Tambahkan fitur seperti dukungan modul kernel tanpa memodifikasi inti KernelSU
- **Modularitas**: Perbarui implementasi secara independen dari rilis KernelSU
- **Kustomisasi**: Buat solusi khusus untuk perangkat atau kasus penggunaan tertentu

::: warning PENTING
Tanpa metamodul yang diinstal, modul **TIDAK** akan dipasang. Instalasi KernelSU yang baru memerlukan pemasangan metamodul (seperti `meta-overlayfs`) agar modul berfungsi.
:::

## Untuk Pengguna

### Menginstal Metamodul

Instal metamodul dengan cara yang sama seperti modul biasa:

1. Unduh file ZIP metamodul (misalnya, `meta-overlayfs.zip`)
2. Buka aplikasi KernelSU Manager
3. Ketuk tombol tindakan mengambang (➕)
4. Pilih file ZIP metamodul
5. Reboot perangkat Anda

Metamodul `meta-overlayfs` adalah implementasi referensi resmi yang menyediakan pemasangan modul berbasis overlayfs tradisional dengan dukungan image ext4.

### Memeriksa Metamodul Aktif

Anda dapat memeriksa metamodul mana yang saat ini aktif di halaman Modul aplikasi KernelSU Manager. Metamodul aktif akan ditampilkan di daftar modul Anda dengan penunjukan khususnya.

### Menghapus Instalasi Metamodul

::: danger PERINGATAN
Menghapus instalasi metamodul akan memengaruhi **SEMUA** modul. Setelah dihapus, modul tidak akan lagi dipasang hingga Anda menginstal metamodul lain.
:::

Untuk menghapus instalasi:

1. Buka KernelSU Manager
2. Temukan metamodul di daftar modul Anda
3. Ketuk hapus instalasi (Anda akan melihat peringatan khusus)
4. Konfirmasi tindakan
5. Reboot perangkat Anda

Setelah menghapus instalasi, Anda harus menginstal metamodul lain jika Anda ingin modul terus berfungsi.

### Batasan Metamodul Tunggal

Hanya satu metamodul yang dapat diinstal pada satu waktu. Jika Anda mencoba menginstal metamodul kedua, KernelSU akan mencegah instalasi untuk menghindari konflik.

Untuk beralih metamodul:

1. Hapus instalasi semua modul biasa
2. Hapus instalasi metamodul saat ini
3. Reboot
4. Instal metamodul baru
5. Instal ulang modul biasa Anda
6. Reboot lagi

## Untuk Pengembang Modul

Jika Anda mengembangkan modul KernelSU biasa, Anda tidak perlu terlalu khawatir tentang metamodul. Modul Anda akan berfungsi selama pengguna memiliki metamodul yang kompatibel (seperti `meta-overlayfs`) yang diinstal.

**Yang perlu Anda ketahui:**

- **Pemasangan memerlukan metamodul**: Direktori `system` di modul Anda hanya akan dipasang jika pengguna memiliki metamodul yang diinstal yang menyediakan fungsi pemasangan
- **Tidak perlu perubahan kode**: Modul yang ada terus berfungsi tanpa modifikasi

::: tip
Jika Anda terbiasa dengan pengembangan modul Magisk, modul Anda akan berfungsi dengan cara yang sama di KernelSU ketika metamodul diinstal, karena menyediakan pemasangan kompatibel Magisk.
:::

## Untuk Pengembang Metamodul

Membuat metamodul memungkinkan Anda untuk menyesuaikan bagaimana KernelSU menangani instalasi modul, pemasangan, dan penghapusan instalasi.

### Persyaratan Dasar

Metamodul diidentifikasi oleh properti khusus di `module.prop`:

```txt
id=my_metamodule
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

Properti `metamodule=1` (atau `metamodule=true`) menandai ini sebagai metamodul. Tanpa properti ini, modul akan diperlakukan sebagai modul biasa.

### Struktur File

Struktur metamodul:

```txt
my_metamodule/
├── module.prop              (harus menyertakan metamodule=1)
│
│      *** Hook khusus metamodul ***
├── metamount.sh             (opsional: handler mount kustom)
├── metainstall.sh           (opsional: hook instalasi untuk modul biasa)
├── metauninstall.sh         (opsional: hook pembersihan untuk modul biasa)
│
│      *** File modul standar (semua opsional) ***
├── customize.sh             (kustomisasi instalasi)
├── post-fs-data.sh          (skrip tahap post-fs-data)
├── service.sh               (skrip late_start service)
├── boot-completed.sh        (skrip boot selesai)
├── uninstall.sh             (skrip penghapusan instalasi metamodul sendiri)
├── system/                  (modifikasi systemless, jika diperlukan)
└── [file tambahan apa pun]
```

Metamodul dapat menggunakan semua fitur modul standar (skrip siklus hidup, dll.) selain hook metamodul khusus mereka.

### Skrip Hook

Metamodul dapat menyediakan hingga tiga skrip hook khusus:

#### 1. metamount.sh - Handler Mount

**Tujuan**: Mengontrol bagaimana modul dipasang selama boot.

**Kapan dieksekusi**: Selama tahap `post-fs-data`, sebelum skrip modul apa pun berjalan.

**Variabel lingkungan:**

- `MODDIR`: Path direktori metamodul (misalnya, `/data/adb/modules/my_metamodule`)
- Semua variabel lingkungan KernelSU standar

**Tanggung jawab:**

- Pasang semua modul yang diaktifkan secara systemless
- Periksa flag `skip_mount`
- Tangani persyaratan pemasangan khusus modul

::: danger PERSYARATAN KRITIS
Saat melakukan operasi mount, Anda **HARUS** mengatur nama sumber/perangkat ke `"KSU"`. Ini mengidentifikasi mount sebagai milik KernelSU.

**Contoh (benar):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**Untuk API mount modern**, atur string sumber:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

Ini penting agar KernelSU mengidentifikasi dan mengelola mount-nya dengan benar.
:::

**Contoh skrip:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# Contoh: Implementasi bind mount sederhana
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # Mount dengan source=KSU (DIPERLUKAN!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - Hook Instalasi

**Tujuan**: Sesuaikan bagaimana modul biasa diinstal.

**Kapan dieksekusi**: Selama instalasi modul, setelah file diekstrak tetapi sebelum instalasi selesai. Skrip ini **di-source** (tidak dieksekusi) oleh installer bawaan, mirip dengan cara kerja `customize.sh`.

**Variabel lingkungan dan fungsi:**

Skrip ini mewarisi semua variabel dan fungsi dari `install.sh` bawaan:

- **Variabel**: `MODPATH`, `TMPDIR`, `ZIPFILE`, `ARCH`, `API`, `IS64BIT`, `KSU`, `KSU_VER`, `KSU_VER_CODE`, `BOOTMODE`, dll.
- **Fungsi**:
  - `ui_print <msg>` - Cetak pesan ke konsol
  - `abort <msg>` - Cetak error dan hentikan instalasi
  - `set_perm <target> <owner> <group> <permission> [context]` - Atur izin file
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - Atur izin secara rekursif
  - `install_module` - Panggil proses instalasi modul bawaan

**Kasus penggunaan:**

- Proses file modul sebelum atau sesudah instalasi bawaan (panggil `install_module` ketika siap)
- Pindahkan file modul
- Validasi kompatibilitas modul
- Siapkan struktur direktori khusus
- Inisialisasi sumber daya khusus modul

**Catatan**: Skrip ini **TIDAK** dipanggil saat menginstal metamodul itu sendiri.

#### 3. metauninstall.sh - Hook Pembersihan

**Tujuan**: Bersihkan sumber daya ketika modul biasa dihapus instalasi.

**Kapan dieksekusi**: Selama penghapusan instalasi modul, sebelum direktori modul dihapus.

**Variabel lingkungan:**

- `MODULE_ID`: ID modul yang sedang dihapus instalasi

**Kasus penggunaan:**

- Proses file
- Bersihkan symlink
- Bebaskan sumber daya yang dialokasikan
- Perbarui pelacakan internal

**Contoh skrip:**

```sh
#!/system/bin/sh
# Dipanggil saat menghapus instalasi modul biasa
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# Hapus file modul dari image
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### Urutan Eksekusi

Memahami urutan eksekusi boot sangat penting untuk pengembangan metamodul:

```txt
tahap post-fs-data:
  1. Skrip post-fs-data.d umum dieksekusi
  2. Prune modul, restorecon, muat sepolicy.rule
  3. post-fs-data.sh metamodul dieksekusi (jika ada)
  4. post-fs-data.sh modul biasa dieksekusi
  5. Muat system.prop
  6. metamount.sh metamodul dieksekusi
     └─> Pasang semua modul secara systemless
  7. Tahap post-mount.d berjalan
     - Skrip post-mount.d umum
     - post-mount.sh metamodul (jika ada)
     - post-mount.sh modul biasa

tahap service:
  1. Skrip service.d umum dieksekusi
  2. service.sh metamodul dieksekusi (jika ada)
  3. service.sh modul biasa dieksekusi

tahap boot-completed:
  1. Skrip boot-completed.d umum dieksekusi
  2. boot-completed.sh metamodul dieksekusi (jika ada)
  3. boot-completed.sh modul biasa dieksekusi
```

**Poin penting:**

- `metamount.sh` berjalan **SETELAH** semua skrip post-fs-data (baik metamodul maupun modul biasa)
- Skrip siklus hidup metamodul (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`) selalu berjalan sebelum skrip modul biasa
- Skrip umum di direktori `.d` berjalan sebelum skrip metamodul
- Tahap `post-mount` berjalan setelah pemasangan selesai

### Mekanisme Symlink

Ketika metamodul diinstal, KernelSU membuat symlink:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

Ini menyediakan path yang stabil untuk mengakses metamodul aktif, terlepas dari ID-nya.

**Manfaat:**

- Path akses yang konsisten
- Deteksi mudah metamodul aktif
- Menyederhanakan konfigurasi

### Contoh Dunia Nyata: meta-overlayfs

Metamodul `meta-overlayfs` adalah implementasi referensi resmi. Ini menunjukkan praktik terbaik untuk pengembangan metamodul.

#### Arsitektur

`meta-overlayfs` menggunakan **arsitektur dual-directory**:

1. **Direktori metadata**: `/data/adb/modules/`
   - Berisi `module.prop`, `disable`, penanda `skip_mount`
   - Cepat untuk dipindai selama boot
   - Jejak penyimpanan kecil

2. **Direktori konten**: `/data/adb/metamodule/mnt/`
   - Berisi file modul aktual (system, vendor, product, dll.)
   - Disimpan dalam image ext4 (`modules.img`)
   - Dioptimalkan ruang dengan fitur ext4

#### Implementasi metamount.sh

Berikut adalah cara `meta-overlayfs` mengimplementasikan handler mount:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# Pasang image ext4 jika belum dipasang
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# Atur variabel lingkungan untuk dukungan dual-directory
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# Eksekusi binary mount
# (Logika pemasangan aktual ada di binary Rust)
"$MODDIR/meta-overlayfs"
```

#### Fitur Utama

**Pemasangan Overlayfs:**

- Menggunakan overlayfs kernel untuk modifikasi systemless yang sebenarnya
- Mendukung beberapa partisi (system, vendor, product, system_ext, odm, oem)
- Dukungan lapisan baca-tulis melalui `/data/adb/modules/.rw/`

**Identifikasi sumber:**

```rust
// Dari meta-overlayfs/src/mount.rs
fsconfig_set_string(fs, "source", "KSU")?;  // DIPERLUKAN!
```

Ini mengatur `dev=KSU` untuk semua mount overlay, memungkinkan identifikasi yang tepat.

### Praktik Terbaik

Saat mengembangkan metamodul:

1. **Selalu atur sumber ke "KSU"** untuk operasi mount - umount kernel dan umount zygisksu memerlukan ini untuk umount dengan benar
2. **Tangani error dengan baik** - proses boot sensitif terhadap waktu
3. **Hormati flag standar** - dukung `skip_mount` dan `disable`
4. **Log operasi** - gunakan `echo` atau logging untuk debugging
5. **Tes secara menyeluruh** - error pemasangan dapat menyebabkan boot loop
6. **Dokumentasikan perilaku** - jelaskan dengan jelas apa yang dilakukan metamodul Anda
7. **Sediakan jalur migrasi** - bantu pengguna beralih dari solusi lain

### Menguji Metamodul Anda

Sebelum merilis:

1. **Uji instalasi** pada pengaturan KernelSU yang bersih
2. **Verifikasi pemasangan** dengan berbagai jenis modul
3. **Periksa kompatibilitas** dengan modul umum
4. **Uji penghapusan instalasi** dan pembersihan
5. **Validasi kinerja boot** (metamount.sh memblokir!)
6. **Pastikan penanganan error yang tepat** untuk menghindari boot loop

## Pertanyaan yang Sering Diajukan

### Apakah saya memerlukan metamodul?

**Untuk pengguna**: Hanya jika Anda ingin menggunakan modul yang memerlukan pemasangan. Jika Anda hanya menggunakan modul yang menjalankan skrip tanpa memodifikasi file sistem, Anda tidak memerlukan metamodul.

**Untuk pengembang modul**: Tidak, Anda mengembangkan modul secara normal. Pengguna memerlukan metamodul hanya jika modul Anda memerlukan pemasangan.

**Untuk pengguna lanjutan**: Hanya jika Anda ingin menyesuaikan perilaku pemasangan atau membuat implementasi pemasangan alternatif.

### Bisakah saya memiliki beberapa metamodul?

Tidak. Hanya satu metamodul yang dapat diinstal pada satu waktu. Ini mencegah konflik dan memastikan perilaku yang dapat diprediksi.

### Apa yang terjadi jika saya menghapus instalasi satu-satunya metamodul saya?

Modul tidak akan lagi dipasang. Perangkat Anda akan boot secara normal, tetapi modifikasi modul tidak akan diterapkan hingga Anda menginstal metamodul lain.

### Apakah meta-overlayfs diperlukan?

Tidak. Ini menyediakan pemasangan overlayfs standar yang kompatibel dengan sebagian besar modul. Anda dapat membuat metamodul Anda sendiri jika Anda memerlukan perilaku yang berbeda.

## Lihat Juga

- [Panduan Modul](module.md) - Pengembangan modul umum
- [Perbedaan dengan Magisk](difference-with-magisk.md) - Membandingkan KernelSU dan Magisk
- [Cara Membangun](how-to-build.md) - Membangun KernelSU dari sumber

```

`website/docs/id_ID/guide/module-config.md`:

```md
# Konfigurasi Modul

KernelSU menyediakan sistem konfigurasi bawaan yang memungkinkan modul menyimpan pengaturan key-value persisten atau sementara. Konfigurasi disimpan dalam format biner di `/data/adb/ksu/module_configs/<module_id>/` dengan karakteristik berikut:

## Tipe Konfigurasi

- **Konfigurasi Persisten** (`persist.config`): Bertahan setelah reboot hingga dihapus secara eksplisit atau modul di-uninstall
- **Konfigurasi Sementara** (`tmp.config`): Otomatis dihapus selama tahap post-fs-data pada setiap boot

Saat membaca konfigurasi, nilai sementara lebih diprioritaskan daripada nilai persisten untuk key yang sama.

## Menggunakan Konfigurasi dalam Skrip Modul

Semua skrip modul (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`, dll.) berjalan dengan variabel lingkungan `KSU_MODULE` diatur ke ID modul. Anda dapat menggunakan perintah `ksud module config` untuk mengelola konfigurasi modul Anda:

```bash
# Mendapatkan nilai konfigurasi
value=$(ksud module config get my_setting)

# Mengatur nilai konfigurasi persisten
ksud module config set my_setting "some value"

# Mengatur nilai konfigurasi sementara (dihapus setelah reboot)
ksud module config set --temp runtime_state "active"

# Mengatur nilai dari stdin (berguna untuk teks multiline atau data kompleks)
ksud module config set my_key <<EOF
teks multiline
nilai
EOF

# Atau alirkan dari perintah
echo "value" | ksud module config set my_key

# Bendera stdin eksplisit
cat file.json | ksud module config set json_data --stdin

# Daftar semua entri konfigurasi (gabungan persisten dan sementara)
ksud module config list

# Menghapus entri konfigurasi
ksud module config delete my_setting

# Menghapus entri konfigurasi sementara
ksud module config delete --temp runtime_state

# Menghapus semua konfigurasi persisten
ksud module config clear

# Menghapus semua konfigurasi sementara
ksud module config clear --temp
```

## Batasan Validasi

Sistem konfigurasi memberlakukan batasan berikut:

- **Panjang key maksimum**: 256 byte
- **Panjang nilai maksimum**: 1MB (1048576 byte)
- **Jumlah entri konfigurasi maksimum**: 32 per modul
- **Format key**: Harus cocok dengan `^[a-zA-Z][a-zA-Z0-9._-]+$` (seperti ID modul)
  - Harus dimulai dengan huruf
  - Dapat berisi huruf, angka, titik, garis bawah, atau tanda hubung
  - Panjang minimum: 2 karakter
- **Format nilai**: Tanpa batasan - dapat berisi karakter UTF-8 apa pun, termasuk jeda baris dan karakter kontrol
  - Disimpan dalam format biner dengan awalan panjang untuk penanganan data yang aman

## Siklus Hidup

- **Saat boot**: Semua konfigurasi sementara dihapus selama tahap post-fs-data
- **Saat uninstall modul**: Semua konfigurasi (persisten dan sementara) otomatis dihapus
- Konfigurasi disimpan dalam format biner dengan magic number `0x4b53554d` ("KSUM") dan validasi versi

## Kasus Penggunaan

Sistem konfigurasi ideal untuk:

- **Preferensi pengguna**: Menyimpan pengaturan modul yang dikonfigurasi pengguna melalui WebUI atau skrip action
- **Flag fitur**: Mengaktifkan/menonaktifkan fitur modul tanpa menginstal ulang
- **Status runtime**: Melacak status sementara yang harus direset saat reboot (gunakan konfigurasi sementara)
- **Pengaturan instalasi**: Mengingat pilihan yang dibuat saat instalasi modul
- **Data kompleks**: Menyimpan JSON, teks multiline, data terenkode Base64, atau konten terstruktur apa pun (hingga 1MB)

::: tip PRAKTIK TERBAIK
- Gunakan konfigurasi persisten untuk preferensi pengguna yang harus bertahan setelah reboot
- Gunakan konfigurasi sementara untuk status runtime atau flag fitur yang harus direset saat boot
- Validasi nilai konfigurasi dalam skrip Anda sebelum menggunakannya
- Gunakan perintah `ksud module config list` untuk men-debug masalah konfigurasi
:::

## Fitur Lanjutan

Sistem konfigurasi modul menyediakan kunci konfigurasi khusus untuk kasus penggunaan lanjutan:

### Mengganti Deskripsi Modul {#overriding-module-description}

Anda dapat mengganti field `description` dari `module.prop` secara dinamis dengan mengatur kunci konfigurasi `override.description`:

```bash
# Mengganti deskripsi modul
ksud module config set override.description "Deskripsi kustom yang ditampilkan di pengelola"
```

Saat mengambil daftar modul, jika konfigurasi `override.description` ada, itu akan menggantikan deskripsi asli dari `module.prop`. Ini berguna untuk:
- Menampilkan informasi status dinamis dalam deskripsi modul
- Menunjukkan detail konfigurasi runtime kepada pengguna
- Memperbarui deskripsi berdasarkan status modul tanpa menginstal ulang

### Mendeklarasikan Fitur yang Dikelola

Modul dapat mendeklarasikan fitur KernelSU mana yang mereka kelola menggunakan pola konfigurasi `manage.<feature>`. Fitur yang didukung sesuai dengan enum internal `FeatureId` KernelSU:

**Fitur yang Didukung:**
- `su_compat` - Mode kompatibilitas SU
- `kernel_umount` - Unmount otomatis kernel

```bash
# Mendeklarasikan bahwa modul ini mengelola kompatibilitas SU dan mengaktifkannya
ksud module config set manage.su_compat true

# Mendeklarasikan bahwa modul ini mengelola unmount kernel dan menonaktifkannya
ksud module config set manage.kernel_umount false

# Menghapus pengelolaan fitur (modul tidak lagi mengontrol fitur ini)
ksud module config delete manage.su_compat
```

**Cara kerjanya:**
- Keberadaan kunci `manage.<feature>` menunjukkan bahwa modul mengelola fitur tersebut
- Nilai menunjukkan status yang diinginkan: `true`/`1` untuk diaktifkan, `false`/`0` (atau nilai lainnya) untuk dinonaktifkan
- Untuk berhenti mengelola fitur, hapus kunci konfigurasi sepenuhnya

Fitur yang dikelola diekspos melalui API daftar modul sebagai field `managedFeatures` (string yang dipisahkan koma). Ini memungkinkan:
- Pengelola KernelSU mendeteksi modul mana yang mengelola fitur KernelSU mana
- Pencegahan konflik ketika beberapa modul mencoba mengelola fitur yang sama
- Koordinasi yang lebih baik antara modul dan fungsionalitas inti KernelSU

::: warning HANYA FITUR YANG DIDUKUNG
Gunakan hanya nama fitur yang telah ditentukan sebelumnya yang tercantum di atas (`su_compat`, `kernel_umount`). Ini sesuai dengan fitur internal KernelSU yang sebenarnya. Menggunakan nama fitur lain tidak akan menyebabkan error, tetapi tidak memiliki tujuan fungsional.
:::

```

`website/docs/id_ID/guide/module-webui.md`:

```md
# Module WebUI

Selain menjalankan skrip boot dan memodifikasi berkas sistem, modul KernelSU dapat menampilkan antarmuka dan berinteraksi langsung dengan pengguna.

Modul dapat mendefinisikan halaman HTML + CSS + JavaScript dengan teknologi web apa pun. Manajer KernelSU menampilkan halaman tersebut lewat WebView dan menyediakan API untuk berinteraksi dengan sistem, misalnya menjalankan perintah shell.

## Direktori `webroot`

Berkas sumber daya web harus ditempatkan di subdirektori `webroot` di direktori root modul, dan **HARUS** ada berkas bernama `index.html` sebagai pintu masuk halaman modul. Struktur modul paling sederhana yang mempunyai antarmuka web adalah sebagai berikut:

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

::: warning
Saat modul dipasang, KernelSU otomatis mengatur izin serta konteks SELinux untuk direktori ini. Jika Anda tidak paham benar apa yang dilakukan, jangan mengubah izin direktori ini sendiri!
:::

Jika halaman Anda memiliki CSS atau JavaScript, letakkan juga di direktori ini.

## JavaScript API

Jika hanya berupa halaman tampilan, ia akan berfungsi layaknya halaman web biasa. Namun yang paling penting, KernelSU menyediakan serangkaian API sistem sehingga modul bisa mewujudkan fungsi khususnya.

KernelSU menyediakan pustaka JavaScript yang dirilis di [npm](https://www.npmjs.com/package/kernelsu) dan bisa dipakai pada kode JavaScript halaman Anda.

Sebagai contoh, Anda bisa menjalankan perintah shell untuk memperoleh konfigurasi tertentu atau mengubah suatu properti:

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

Anda juga dapat membuat halaman menjadi layar penuh atau menampilkan toast.

[Dokumentasi API](https://www.npmjs.com/package/kernelsu)

Jika API yang ada belum memenuhi kebutuhan atau kurang nyaman digunakan, silakan beri kami masukan [di sini](https://github.com/tiann/KernelSU/issues)!

## Beberapa tips

1. Anda dapat menggunakan `localStorage` seperti biasa untuk menyimpan data, namun ingat bahwa data akan hilang jika aplikasi manager dihapus. Jika butuh penyimpanan permanen, simpan data secara manual pada direktori tertentu.
2. Untuk halaman sederhana kami menyarankan menggunakan [parceljs](https://parceljs.org/) untuk proses bundling. Ia tidak butuh konfigurasi awal dan sangat mudah dipakai. Namun jika Anda ahli front-end atau punya preferensi sendiri, silakan gunakan alat pilihan Anda!

```

`website/docs/id_ID/guide/module.md`:

```md
# Panduan module

KernelSU menyediakan mekanisme modul yang mencapai efek memodifikasi direktori sistem dengan tetap menjaga integritas partisi sistem. Mekanisme ini umumnya dikenal sebagai "tanpa sistem".

Mekanisme modul KernelSU hampir sama dengan Magisk. Jika Anda terbiasa dengan pengembangan modul Magisk, mengembangkan modul KernelSU sangat mirip. Anda dapat melewati pengenalan modul di bawah ini dan hanya perlu membaca [difference-with-magisk](difference-with-magisk.md).

::: warning METAMODULE HANYA DIPERLUKAN UNTUK MODIFIKASI FILE SISTEM
KernelSU menggunakan arsitektur [metamodule](metamodule.md) untuk me-mount direktori `system`. **Hanya jika modul Anda perlu memodifikasi file `/system`** (melalui direktori `system`) Anda perlu menginstal metamodule (seperti [meta-overlayfs](https://github.com/tiann/KernelSU/releases)). Fitur modul lainnya seperti skrip, aturan sepolicy, dan system.prop bekerja tanpa metamodule.
:::

## WebUI

Modul KernelSU mendukung tampilan antarmuka dan interaksi dengan pengguna. Lihat [WebUI documentation](module-webui.md) untuk detailnya.

## Konfigurasi Modul

KernelSU menyediakan sistem konfigurasi bawaan yang memungkinkan modul menyimpan pengaturan key-value persisten atau sementara. Untuk detail lebih lanjut, lihat [dokumentasi Konfigurasi Modul](module-config.md).

## Busybox

KernelSU dikirimkan dengan fitur biner BusyBox yang lengkap (termasuk dukungan penuh SELinux). Eksekusi terletak di `/data/adb/ksu/bin/busybox`. BusyBox KernelSU mendukung "Mode Shell Standalone Shell" yang dapat dialihkan waktu proses. Apa yang dimaksud dengan mode mandiri ini adalah bahwa ketika dijalankan di shell `ash` dari BusyBox, setiap perintah akan langsung menggunakan applet di dalam BusyBox, terlepas dari apa yang ditetapkan sebagai `PATH`. Misalnya, perintah seperti `ls`, `rm`, `chmod` **TIDAK** akan menggunakan apa yang ada di `PATH` (dalam kasus Android secara default akan menjadi `/system/bin/ls`, ` /system/bin/rm`, dan `/system/bin/chmod` masing-masing), tetapi akan langsung memanggil applet BusyBox internal. Ini memastikan bahwa skrip selalu berjalan di lingkungan yang dapat diprediksi dan selalu memiliki rangkaian perintah lengkap, apa pun versi Android yang menjalankannya. Untuk memaksa perintah _not_ menggunakan BusyBox, Anda harus memanggil yang dapat dieksekusi dengan path lengkap.

Setiap skrip shell tunggal yang berjalan dalam konteks KernelSU akan dieksekusi di shell `ash` BusyBox dengan mode mandiri diaktifkan. Untuk apa yang relevan dengan pengembang pihak ke-3, ini termasuk semua skrip boot dan skrip instalasi modul.

Bagi yang ingin menggunakan fitur “Standalone Mode” ini di luar KernelSU, ada 2 cara untuk mengaktifkannya:

1. Tetapkan variabel lingkungan `ASH_STANDALONE` ke `1`<br>Contoh: `ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. Beralih dengan opsi baris perintah:<br>`/data/adb/ksu/bin/busybox sh -o mandiri <script>`

Untuk memastikan semua shell `sh` selanjutnya dijalankan juga dalam mode mandiri, opsi 1 adalah metode yang lebih disukai (dan inilah yang digunakan secara internal oleh KernelSU dan manajer KernelSU) karena variabel lingkungan diwariskan ke proses anak.

::: perbedaan tip dengan Magisk

BusyBox KernelSU sekarang menggunakan file biner yang dikompilasi langsung dari proyek Magisk. **Berkat Magisk!** Oleh karena itu, Anda tidak perlu khawatir tentang masalah kompatibilitas antara skrip BusyBox di Magisk dan KernelSU karena keduanya persis sama!
:::

## KernelSU module

Modul KernelSU adalah folder yang ditempatkan di `/data/adb/modules` dengan struktur di bawah ini:

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- The folder is named with the ID of the module
│   │
│   │      *** Module Identity ***
│   │
│   ├── module.prop         <--- This file stores the metadata of the module
│   │
│   │      *** Main Contents ***
│   │
│   ├── system              <--- This folder will be mounted if skip_mount does not exist
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** Status Flags ***
│   │
│   ├── skip_mount          <--- If exists, KernelSU will NOT mount your system folder
│   ├── disable             <--- If exists, the module will be disabled
│   ├── remove              <--- If exists, the module will be removed next reboot
│   │
│   │      *** Optional Files ***
│   │
│   ├── post-fs-data.sh     <--- This script will be executed in post-fs-data
│   ├── service.sh          <--- This script will be executed in late_start service
|   ├── uninstall.sh        <--- This script will be executed when KernelSU removes your module
│   ├── system.prop         <--- Properties in this file will be loaded as system properties by resetprop
│   ├── sepolicy.rule       <--- Additional custom sepolicy rules
│   │
│   │      *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY ***
│   │
│   ├── vendor              <--- A symlink to $MODID/system/vendor
│   ├── product             <--- A symlink to $MODID/system/product
│   ├── system_ext          <--- A symlink to $MODID/system/system_ext
│   │
│   │      *** Any additional files / folders are allowed ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: perbedaan tip dengan Magisk
KernelSU tidak memiliki dukungan bawaan untuk Zygisk, jadi tidak ada konten terkait Zygisk dalam modul. Namun, Anda dapat menggunakan [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) untuk mendukung modul Zygisk. Dalam hal ini, konten modul Zygisk identik dengan yang didukung oleh Magisk.
:::

### module.prop

module.prop adalah file konfigurasi untuk sebuah modul. Di KernelSU, jika modul tidak berisi file ini, maka tidak akan dikenali sebagai modul. Format file ini adalah sebagai berikut:

```txt
id=<string>
name=<string>
version=<string>
versioncode=<int>
author=<string>
description=<string>
updateJson=<url> (opsional)
actionIcon=<path> (opsional)
webuiIcon=<path> (opsional)
```

- `id` harus cocok dengan ekspresi reguler ini: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
   contoh: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
   Ini adalah **pengidentifikasi unik** modul Anda. Anda tidak boleh mengubahnya setelah dipublikasikan.
- `versionCode` harus berupa **integer**. Ini digunakan untuk membandingkan versi.
- Lainnya yang tidak disebutkan di atas dapat berupa string **satu baris**.
- Pastikan untuk menggunakan tipe jeda baris `UNIX (LF)` dan bukan `Windows (CR+LF)` atau `Macintosh (CR)`.
- `actionIcon` dan `webuiIcon` adalah path ikon opsional yang digunakan sebagai
  ikon default untuk pintasan aksi modul dan pintasan WebUI modul di aplikasi
  pengelola. Path ini harus relatif terhadap direktori root modul. Contohnya,
  `actionIcon=icon/icon.png` akan dipetakan ke `<MODDIR>/icon/icon.png`.

::: tip DESKRIPSI DINAMIS
Field `description` dapat diganti secara dinamis saat runtime menggunakan sistem konfigurasi modul. Lihat [Mengganti Deskripsi Modul](module-config.md#overriding-module-description) untuk detailnya.
:::

### Shell skrip

Harap baca bagian [Boot Scripts](#boot-scripts) untuk memahami perbedaan antara `post-fs-data.sh` dan `service.sh`. Untuk sebagian besar pengembang modul, `service.sh` sudah cukup baik jika Anda hanya perlu menjalankan skrip boot.

Di semua skrip modul Anda, harap gunakan `MODDIR=${0%/*}` untuk mendapatkan jalur direktori dasar modul Anda; lakukan **TIDAK** hardcode jalur modul Anda dalam skrip.

::: perbedaan tip dengan Magisk
Anda dapat menggunakan variabel lingkungan KSU untuk menentukan apakah skrip berjalan di KernelSU atau Magisk. Jika berjalan di KernelSU, nilai ini akan disetel ke true.
:::

### `system` directory

Isi direktori ini akan dihamparkan di atas partisi sistem /sistem setelah sistem di-boot. Ini berarti bahwa:

::: tip PERSYARATAN METAMODULE
Direktori `system` hanya di-mount jika Anda telah menginstal metamodule yang menyediakan fungsionalitas mounting (seperti `meta-overlayfs`). Metamodule menangani bagaimana modul di-mount. Lihat [Panduan Metamodule](metamodule.md) untuk informasi lebih lanjut.
:::

1. File dengan nama yang sama dengan yang ada di direktori terkait di sistem akan ditimpa oleh file di direktori ini.
2. Folder dengan nama yang sama dengan yang ada di direktori terkait di sistem akan digabungkan dengan folder di direktori ini.

Jika Anda ingin menghapus file atau folder di direktori sistem asli, Anda perlu membuat file dengan nama yang sama dengan file/folder di direktori modul menggunakan `mknod filename c 0 0`. Dengan cara ini, sistem overlayfs akan secara otomatis "memutihkan" file ini seolah-olah telah dihapus (partisi / sistem sebenarnya tidak diubah).

Anda juga dapat mendeklarasikan variabel bernama `REMOVE` yang berisi daftar direktori di `customize.sh` untuk menjalankan operasi penghapusan, dan KernelSU akan secara otomatis mengeksekusi `mknod <TARGET> c 0 0` di direktori modul yang sesuai. Misalnya:

``` sh
HAPUS = "
/sistem/aplikasi/YouTube
/system/app/Bloatware
"
```

Daftar di atas akan mengeksekusi `mknod $MODPATH/system/app/YouTuBe c 0 0` dan `mknod $MODPATH/system/app/Bloatware c 0 0`; dan `/system/app/YouTube` dan `/system/app/Bloatware` akan dihapus setelah modul berlaku.

Jika Anda ingin mengganti direktori di sistem, Anda perlu membuat direktori dengan jalur yang sama di direktori modul Anda, lalu atur atribut `setfattr -n trusted.overlay.opaque -v y <TARGET>` untuk direktori ini. Dengan cara ini, sistem overlayfs akan secara otomatis mengganti direktori terkait di sistem (tanpa mengubah partisi /sistem).

Anda dapat mendeklarasikan variabel bernama `REPLACE` di file `customize.sh` Anda, yang menyertakan daftar direktori yang akan diganti, dan KernelSU akan secara otomatis melakukan operasi yang sesuai di direktori modul Anda. Misalnya:

REPLACE="
/system/app/YouTube
/system/app/Bloatware
"

Daftar ini akan secara otomatis membuat direktori `$MODPATH/system/app/YouTube` dan `$MODPATH/system/app/Bloatware`, lalu jalankan `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/ YouTube` dan `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/Bloatware`. Setelah modul berlaku, `/system/app/YouTube` dan `/system/app/Bloatware` akan diganti dengan direktori kosong.

::: perbedaan tip dengan Magisk

KernelSU menggunakan arsitektur [metamodule](metamodule.md) di mana mounting didelegasikan ke metamodule yang dapat dipasang. Metamodule `meta-overlayfs` resmi menggunakan OverlayFS kernel untuk modifikasi systemless, sedangkan Magisk menggunakan magic mount (bind mount) yang dibangun langsung ke dalam intinya. Keduanya mencapai tujuan yang sama: memodifikasi file `/system` tanpa memodifikasi partisi `/system` secara fisik. Pendekatan KernelSU memberikan lebih banyak fleksibilitas dan mengurangi permukaan deteksi.
:::

Jika Anda tertarik dengan overlayfs, disarankan untuk membaca [dokumentasi overlayfs](https://docs.kernel.org/filesystems/overlayfs.html) Kernel Linux.

### system.prop

File ini mengikuti format yang sama dengan `build.prop`. Setiap baris terdiri dari `[kunci]=[nilai]`.

### sepolicy.rule

Jika modul Anda memerlukan beberapa tambalan sepolicy tambahan, harap tambahkan aturan tersebut ke dalam file ini. Setiap baris dalam file ini akan diperlakukan sebagai pernyataan kebijakan.

## Pemasangan module

Penginstal modul KernelSU adalah modul KernelSU yang dikemas dalam file zip yang dapat di-flash di aplikasi pengelola KernelSU. Pemasang modul KernelSU yang paling sederhana hanyalah modul KernelSU yang dikemas sebagai file zip.

```txt
module.zip
│
├── customize.sh                       <--- (Optional, more details later)
│                                           This script will be sourced by update-binary
├── ...
├── ...  /* The rest of module's files */
│
```

:::peringatan
Modul KernelSU TIDAK didukung untuk diinstal dalam pemulihan kustom!!
:::

### Kostumisasi

Jika Anda perlu menyesuaikan proses penginstalan modul, secara opsional Anda dapat membuat skrip di penginstal bernama `customize.sh`. Skrip ini akan _sourced_ (tidak dijalankan!) oleh skrip penginstal modul setelah semua file diekstrak dan izin default serta konteks sekon diterapkan. Ini sangat berguna jika modul Anda memerlukan penyiapan tambahan berdasarkan ABI perangkat, atau Anda perlu menyetel izin khusus/konteks kedua untuk beberapa file modul Anda.

Jika Anda ingin sepenuhnya mengontrol dan menyesuaikan proses penginstalan, nyatakan `SKIPUNZIP=1` di `customize.sh` untuk melewati semua langkah penginstalan default. Dengan melakukannya, `customize.sh` Anda akan bertanggung jawab untuk menginstal semuanya dengan sendirinya.

Skrip `customize.sh` berjalan di shell BusyBox `ash` KernelSU dengan "Mode Mandiri" diaktifkan. Variabel dan fungsi berikut tersedia:

#### Variable

- `KSU` (bool): variabel untuk menandai bahwa skrip berjalan di lingkungan KernelSU, dan nilai variabel ini akan selalu benar. Anda dapat menggunakannya untuk membedakan antara KernelSU dan Magisk.
- `KSU_VER` (string): string versi dari KernelSU yang diinstal saat ini (mis. `v0.4.0`)
- `KSU_VER_CODE` (int): kode versi KernelSU yang terpasang saat ini di ruang pengguna (mis. `10672`)
- `KSU_KERNEL_VER_CODE` (int): kode versi KernelSU yang terpasang saat ini di ruang kernel (mis. `10672`)
- `BOOTMODE` (bool): selalu `true` di KernelSU
- `MODPATH` (jalur): jalur tempat file modul Anda harus diinstal
- `TMPDIR` (jalur): tempat di mana Anda dapat menyimpan file untuk sementara
- `ZIPFILE` (jalur): zip instalasi modul Anda
- `ARCH` (string): arsitektur CPU perangkat. Nilainya adalah `arm`, `arm64`, `x86`, atau `x64`
- `IS64BIT` (bool): `true` jika `$ARCH` adalah `arm64` atau `x64`
- `API` (int): level API (versi Android) perangkat (mis. `23` untuk Android 6.0)

::: peringatan
Di KernelSU, MAGISK_VER_CODE selalu 25200 dan MAGISK_VER selalu v25.2. Tolong jangan gunakan kedua variabel ini untuk menentukan apakah itu berjalan di KernelSU atau tidak.
:::

#### Fungsi

```txt
ui_print <msg>
    print <msg> to console
    Avoid using 'echo' as it will not display in custom recovery's console

abort <msg>
    print error message <msg> to console and terminate the installation
    Avoid using 'exit' as it will skip the termination cleanup steps

set_perm <target> <owner> <group> <permission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    this function is a shorthand for the following commands:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    for all files in <directory>, it will call:
       set_perm file owner group filepermission context
    for all directories in <directory> (including itself), it will call:
       set_perm dir owner group dirpermission context
```

## Boot scripts

Di KernelSU, skrip dibagi menjadi dua jenis berdasarkan mode operasinya: mode post-fs-data dan mode layanan late_start:

- mode pasca-fs-data
   - Tahap ini adalah BLOKIR. Proses boot dijeda sebelum eksekusi selesai, atau 10 detik telah berlalu.
   - Skrip dijalankan sebelum modul apa pun dipasang. Ini memungkinkan pengembang modul untuk menyesuaikan modul mereka secara dinamis sebelum dipasang.
   - Tahap ini terjadi sebelum Zygote dimulai, yang berarti segalanya di Android
   - **PERINGATAN:** menggunakan `setprop` akan menghentikan proses booting! Silakan gunakan `resetprop -n <prop_name> <prop_value>` sebagai gantinya.
   - **Hanya jalankan skrip dalam mode ini jika perlu.**
- mode layanan late_start
   - Tahap ini NON-BLOCKING. Skrip Anda berjalan paralel dengan proses booting lainnya.
   - **Ini adalah tahap yang disarankan untuk menjalankan sebagian besar skrip.**

Di KernelSU, skrip startup dibagi menjadi dua jenis berdasarkan lokasi penyimpanannya: skrip umum dan skrip modul:

- Skrip Umum
   - Ditempatkan di `/data/adb/post-fs-data.d` atau `/data/adb/service.d`
   - Hanya dieksekusi jika skrip disetel sebagai dapat dieksekusi (`chmod +x script.sh`)
   - Skrip di `post-fs-data.d` berjalan dalam mode post-fs-data, dan skrip di `service.d` berjalan di mode layanan late_start.
   - Modul seharusnya **TIDAK** menambahkan skrip umum selama instalasi
- Skrip Modul
   - Ditempatkan di folder modul itu sendiri
   - Hanya dijalankan jika modul diaktifkan
   - `post-fs-data.sh` berjalan dalam mode post-fs-data, dan `service.sh` berjalan dalam mode layanan late_start.

Semua skrip boot akan berjalan di shell BusyBox `ash` KernelSU dengan "Mode Mandiri" diaktifkan.

```

`website/docs/id_ID/guide/rescue-from-bootloop.md`:

```md
# Recovery dari bootloop

Saat mem-flash perangkat, kami mungkin menghadapi situasi di mana perangkat menjadi "bata". Secara teori, jika Anda hanya menggunakan fastboot untuk mem-flash partisi boot atau menginstal modul yang tidak sesuai yang menyebabkan perangkat gagal melakukan booting, ini dapat dipulihkan dengan operasi yang sesuai. Dokumen ini bertujuan untuk memberikan beberapa metode darurat untuk membantu Anda pulih dari perangkat "bricked".

## Brick saat memflash partisi boot

Di KernelSU, situasi berikut dapat menyebabkan bata boot saat mem-flash partisi boot:

1. Anda mem-flash image boot dalam format yang salah. Misalnya, jika format booting ponsel Anda adalah `gz`, tetapi Anda mem-flash image berformat `lz4`, maka ponsel tidak akan dapat melakukan booting.
2. Ponsel Anda perlu menonaktifkan verifikasi AVB agar dapat boot dengan benar (biasanya perlu menghapus semua data di ponsel).
3. Kernel Anda memiliki beberapa bug atau tidak cocok untuk flash ponsel Anda.

Apa pun situasinya, Anda dapat memulihkannya dengan **mem-flash gambar boot stok**. Oleh karena itu, di awal tutorial instalasi, kami sangat menyarankan Anda untuk mem-backup stock boot Anda sebelum melakukan flashing. Jika Anda belum mencadangkan, Anda dapat memperoleh boot pabrik asli dari pengguna lain dengan perangkat yang sama dengan Anda atau dari firmware resmi.

## Brick disebabkan modul

Memasang modul dapat menjadi penyebab yang lebih umum dari bricking perangkat Anda, tetapi kami harus memperingatkan Anda dengan serius: **Jangan memasang modul dari sumber yang tidak dikenal**! Karena modul memiliki hak akses root, mereka berpotensi menyebabkan kerusakan permanen pada perangkat Anda!

### Module normal

Jika Anda telah mem-flash modul yang telah terbukti aman tetapi menyebabkan perangkat Anda gagal booting, maka situasi ini dapat dipulihkan dengan mudah di KernelSU tanpa rasa khawatir. KernelSU memiliki mekanisme bawaan untuk menyelamatkan perangkat Anda, termasuk yang berikut:

1. Pembaruan AB
2. Selamatkan dengan menekan Volume Turun

#### Pembaruan AB

Pembaruan modul KernelSU menarik inspirasi dari mekanisme pembaruan AB sistem Android yang digunakan dalam pembaruan OTA. Jika Anda menginstal modul baru atau memperbarui modul yang sudah ada, itu tidak akan langsung mengubah file modul yang sedang digunakan. Sebagai gantinya, semua modul akan dibangun ke gambar pembaruan lainnya. Setelah sistem dimulai ulang, sistem akan mencoba untuk mulai menggunakan gambar pembaruan ini. Jika sistem Android berhasil melakukan booting, modul akan benar-benar diperbarui.

Oleh karena itu, metode paling sederhana dan paling umum digunakan untuk menyelamatkan perangkat Anda adalah dengan **memaksa reboot**. Jika Anda tidak dapat memulai sistem Anda setelah mem-flash modul, Anda dapat menekan dan menahan tombol daya selama lebih dari 10 detik, dan sistem akan melakukan reboot secara otomatis; setelah mem-boot ulang, itu akan kembali ke keadaan sebelum memperbarui modul, dan modul yang diperbarui sebelumnya akan dinonaktifkan secara otomatis.

#### Recovery dengan menekan Volume Bawah

Jika pembaruan AB masih tidak dapat menyelesaikan masalah, Anda dapat mencoba menggunakan **Safe Mode**. Dalam Safe Mode, semua modul dinonaktifkan.

Ada dua cara untuk masuk ke Safe Mode:

1. Mode Aman bawaan dari beberapa sistem; beberapa sistem memiliki Safe Mode bawaan yang dapat diakses dengan menekan lama tombol volume turun, sementara yang lain (seperti MIUI) dapat mengaktifkan Safe Mode di Recovery. Saat memasuki Safe Mode sistem, KernelSU juga akan masuk ke Safe Mode dan secara otomatis menonaktifkan modul.
2. Safe Mode bawaan dari KernelSU; metode pengoperasiannya adalah **tekan tombol volume turun secara terus-menerus selama lebih dari tiga kali** setelah layar boot pertama. Perhatikan bahwa ini adalah rilis pers, rilis pers, rilis pers, bukan tekan dan tahan.

Setelah memasuki mode aman, semua modul pada halaman modul KernelSU Manager dinonaktifkan, tetapi Anda dapat melakukan operasi "uninstall" untuk menghapus semua modul yang mungkin menyebabkan masalah.

Mode aman bawaan diimplementasikan di kernel, jadi tidak ada kemungkinan peristiwa penting yang hilang karena intersepsi. Namun, untuk kernel non-GKI, integrasi kode secara manual mungkin diperlukan, dan Anda dapat merujuk ke dokumentasi resmi untuk mendapatkan panduan.

### Module berbahaya

Jika metode di atas tidak dapat menyelamatkan perangkat Anda, kemungkinan besar modul yang Anda instal memiliki operasi jahat atau telah merusak perangkat Anda melalui cara lain. Dalam hal ini, hanya ada dua saran:

1. Hapus data dan flash sistem resmi.
2. Konsultasikan layanan purna jual.

```

`website/docs/id_ID/guide/unofficially-support-devices.md`:

```md
# Perangkat Yang Didukung Tidak Resmi

::: warning
Dokumen ini hanya untuk referensi arsip dan tidak lagi diperbarui.
Sejak KernelSU v1.0, kami telah menghentikan dukungan resmi untuk perangkat non-GKI.
:::

:::peringatan

di halaman ini, terdapat kernel untuk perangkat non-GKI yang mendukung KernelSU yang dikelola oleh pengembang lain.

:::

:::peringatan

Halaman ini hanya untuk Anda yang ingin menemukan kode sumber yang sesuai dengan perangkat Anda, itu **BUKAN** berarti kode sumber telah ditinjau oleh _KernelSU Developers_. Anda harus menggunakannya dengan risiko Anda sendiri.

:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>Pengelola</th>
         <th>Repository</th>
         <th>Perangkat yang didukung</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>

```

`website/docs/id_ID/guide/what-is-kernelsu.md`:

```md
# Apa itu KernelSU?

KernelSU adalah solusi root untuk perangkat GKI Android, ia bekerja dalam mode kernel dan memberikan izin root ke aplikasi userspace secara langsung di ruang kernel.

## Fitur

Fitur utama dari KernelSU adalah **berbasis kernel**. KernelSU bekerja dalam mode kernel, sehingga dapat menyediakan antarmuka kernel yang belum pernah kita miliki sebelumnya. Sebagai contoh, kita dapat menambahkan breakpoint perangkat keras ke proses apa pun dalam mode kernel; Kita dapat mengakses memori fisik dari proses apa pun tanpa diketahui oleh siapa pun; Kita dapat mencegat syscall apa pun di ruang kernel; dll.

Selain itu, KernelSU menyediakan [sistem metamodule](metamodule.md), yang merupakan arsitektur yang dapat dipasang untuk manajemen modul. Tidak seperti solusi root tradisional yang mengintegrasikan logika mount ke dalam intinya, KernelSU mendelegasikan ini ke metamodules. Ini memungkinkan Anda untuk memasang metamodules (seperti [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs)) untuk menyediakan modifikasi systemless pada partisi `/system` dan partisi lainnya.

## Bagaimana cara menggunakannya

Silakan merujuk ke: [Installation](installation)

## Bagaimana cara men-buildnya

[How to build](how-to-build)

## Diskusi

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/id_ID/index.md`:

```md
---
layout: home
title: Sebuah solusi root kernel-based untuk Android

hero:
  name: KernelSU
  text: Sebuah solusi root kernel-based untuk Android
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: Permulaan
      link: /id_ID/guide/what-is-kernelsu
    - theme: alt
      text: Lihat di GitHub
      link: https://github.com/tiann/KernelSU

features:
  - title: Kernel-based
    details: KernelSU bekerja dalam mode Linux kernel, dan mempunyai kelebihan diatas aplikasi userspace.
  - title: Kontrol akses daftar putih
    details: Hanya aplikasi yang diberikan izin root yang bisa mengakses `su`, aplikasi lain tidak bisa mengakses su.
  - title: Sistem Metamodule
    details: Infrastruktur modul yang dapat dipasang memungkinkan modifikasi systemless pada /system. Pasang metamodule seperti meta-overlayfs untuk mengaktifkan pemasangan modul.
  - title: Sumber terbuka
    details: KernelSU adalah projek sumber terbuka dibawah lisensi GPL-3.

```

`website/docs/index.md`:

```md
---
layout: home
title: Home

hero:
  name: KernelSU
  text: A kernel-based root solution for Android
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: Get started
      link: /guide/what-is-kernelsu
    - theme: alt
      text: View on GitHub
      link: https://github.com/tiann/KernelSU

features:
  - title: Kernel-based
    details: As the name suggests, KernelSU runs inside the Linux kernel, giving it more control over userspace apps.
  - title: Root access control
    details: Only permitted apps can access or see su; all other apps remain unaware of it.
  - title: Customizable root privileges
    details: KernelSU allows customization of su's uid, gid, groups, capabilities, and SELinux rules, hardening root privileges.
  - title: Metamodule system
    details: Pluggable module infrastructure allows systemless /system modifications. Install a metamodule like meta-overlayfs to enable module mounting.

```

`website/docs/ja_JP/guide/app-profile.md`:

```md
# App Profile

App Profile は KernelSU が提供する仕組みで、さまざまなアプリの設定を柔軟にカスタマイズできます。

root 権限（`su` を利用できること）を付与したアプリの場合、App Profile は Root Profile とも呼べます。`su` コマンドの `uid`、`gid`、`groups`、`capabilities`、`SELinux` ルールを調整できるため、root ユーザーの特権を細かく制限できます。たとえばファイアウォールアプリにだけネットワーク権限を与えてファイルアクセスを禁止したり、凍結アプリには完全な root の代わりに shell 権限のみを与えたりできます。**すなわち最小権限の原則で力を箱の中に閉じ込める**ことができます。

root 権限を持たない通常のアプリに対しても、App Profile は kernel やモジュールシステムがそのアプリをどのように扱うかを制御できます。モジュールによる変更をアプリで見せるべきかなどを決められ、設定に基づいて kernel／モジュールシステムは「隠す」といった挙動を選択できます。

## Root Profile

### UID・GID・グループ

Linux にはユーザーとグループの 2 つの概念があります。各ユーザーにはユーザー ID (UID) があり、ユーザーは複数のグループに所属できます。それぞれのグループにはグループ ID (GID) があり、これらの ID がシステム内でのユーザー識別やアクセス可能なリソースの判断に使われます。

UID が 0 のユーザーは root ユーザー、GID が 0 のグループは root グループと呼ばれます。root グループは一般的にシステムでもっとも強い権限を持ちます。

Android では各アプリ（shared UID を除く）が独立したユーザーとして動作し、固有の UID を持ちます。たとえば `0` は root、`1000` は `system`、`2000` は ADB shell、`10000`〜`19999` は一般アプリに割り当てられます。

::: info
ここでいう UID は Android のマルチユーザーやワークプロファイルとは別の概念です。ワークプロファイルは UID の範囲を分割することで実装されています。たとえば 10000-19999 がメインユーザー、110000-119999 がワークプロファイルを表し、その中の各アプリは独自の UID を持っています。
:::

各アプリは複数のグループに所属でき、GID はそのうちのプライマリグループを表します（多くの場合 UID と同じです）。その他のグループは補助グループです。ネットワークアクセスや Bluetooth など、いくつかの権限はグループで管理されています。

例として、ADB shell で `id` コマンドを実行すると次のような結果になります。

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

ここでは UID が `2000`、GID（プライマリグループ ID）も `2000` です。さらに `inet`（`AF_INET` や `AF_INET6` を作成できる、つまりネットワークアクセスが可能）、`sdcard_rw`（SD カードの読み書きが可能）といった補助グループにも所属しています。

KernelSU の Root Profile を使うと、`su` 実行後の root プロセスの UID・GID・所属グループをカスタマイズできます。たとえばある root アプリの Root Profile で UID を `2000` に設定すれば、そのアプリが `su` を使っても実際の権限は ADB shell 相当になります。またグループから `inet` を外せば、`su` コマンドがネットワークにアクセスできなくなります。

::: tip 注意
App Profile が制御するのは `su` 使用後の root プロセスの権限だけであり、アプリ自身の権限ではありません。アプリがネットワーク権限を要求して許可されていれば、`su` を使わなくてもネットワークにアクセスできます。`su` から `inet` グループを外すのは、`su` にネットワークアクセスをさせないためだけの措置です。
:::

Root Profile は kernel によって強制され、`su` でユーザーやグループを切り替えるようなアプリ側の自発的な動作には依存しません。`su` 権限を与えるかどうかは開発者ではなくユーザー自身が完全にコントロールできます。

### Capabilities

Capability は Linux における特権分離の仕組みです。

従来の `UNIX` 実装では、権限チェックのためにプロセスを 2 種類に分けます。effective UID が `0` の特権プロセス（superuser/root）と、それ以外の非特権プロセスです。特権プロセスは kernel の権限チェックをすべてバイパスし、非特権プロセスはプロセスの資格情報（effective UID・effective GID・補助グループ一覧など）に基づいた完全なチェックを受けます。

Linux 2.2 以降は、従来 root が一括して持っていた権限を capability と呼ばれる単位に分割し、それぞれを独立して有効化・無効化できるようになりました。

各 capability は 1 つ以上の権限を表します。たとえば `CAP_DAC_READ_SEARCH` は、ファイル読み取りやディレクトリの読み取り・実行に必要なチェックをバイパスできる権限です。effective UID が `0` のユーザー（root）であっても、`CAP_DAC_READ_SEARCH` などを持っていなければ自由にファイルを読めません。

KernelSU の Root Profile では `su` 実行後の root プロセスの capability もカスタマイズでき、いわば「部分的な root 権限」を与えられます。上で触れた UID / GID と異なり、`su` 後も UID `0` が必要な root アプリもあります。その場合は UID `0` のまま capability を制限することで、許可される操作を限定できます。

::: tip 強く推奨
Linux の capability については[公式ドキュメント](https://man7.org/linux/man-pages/man7/capabilities.7.html)に詳細がまとまっています。capability をカスタマイズする予定があるなら、まずこのドキュメントを読んでください。
:::

### SELinux

SELinux は強力な Mandatory Access Control (MAC) 仕組みで、**default deny**（明示的に許可されていない操作はすべて拒否）という原則で動作します。

SELinux には 2 つのグローバルモードがあります。

1. Permissive モード: 拒否イベントを記録しますが強制しません。
2. Enforcing モード: 拒否イベントを記録し、かつ強制します。

::: warning
近年の Android は SELinux に大きく依存してシステム全体の安全性を保っています。何のメリットもないので、「Permissive モード」で動作するカスタムシステムの利用は強く非推奨です。
:::

SELinux の全容を説明するのは非常に複雑で、このドキュメントの範囲を超えています。まずは以下の資料で仕組みを理解することをおすすめします。

1. [Wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Red Hat: What Is SELinux?](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

KernelSU の Root Profile では、`su` 実行後の root プロセスの SELinux コンテキストもカスタマイズできます。特定のコンテキストに対してアクセス制御ルールを定義し、root 権限をきめ細かく制御できます。

一般的なシナリオでは、アプリが `su` を実行すると `u:r:su:s0` のような**制限のない** SELinux ドメインに切り替わります。Root Profile を介して `u:r:app1:s0` のようなカスタムドメインに切り替え、そのドメイン向けに次のようなルールを定義できます。

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

`allow app1 * * *` というルールは例示目的であり、実際にはあまり使うべきではありません。Permissive モードとほとんど変わらなくなってしまうからです。

### エスカレーション

Root Profile の設定が適切でないと、意図せず制限を回避される恐れがあります。

たとえば ADB shell ユーザーに root 権限を与えていて（よくある構成です）、さらに通常アプリにも root 権限を付与したあと、そのアプリの Root Profile で UID 2000（ADB shell の UID）を設定したとします。この場合、アプリは `su` を 2 回実行するだけで完全な root を得られます。

1. 1 回目の `su` は App Profile の制限を受け、UID を `0` ではなく `2000`（ADB shell）に変更します。
2. 2 回目の `su` は、既に UID が `2000` であり、その UID に root 権限を許可しているため、完全な root 権限を取得します。

::: warning 注意
この挙動は仕様でありバグではありません。したがって以下を推奨します。

本当に ADB に root 権限が必要な（開発者などの）場合でも、Root Profile で UID を `2000` に変更するのは避けてください。`1000`（system）を使う方が安全です。
:::

## 非 root プロファイル

### モジュールのアンマウント

KernelSU は OverlayFS をマウントすることで systemless な形でシステムパーティションを変更します。しかしこの挙動に敏感なアプリもあります。そのような場合は「Umount modules」オプションを設定して、対象アプリではモジュールをアンマウントさせることができます。

KernelSU マネージャーの設定画面には「Umount modules by default」という項目もあります。デフォルトではこのオプションは**有効**で、追加設定をしない限り KernelSU や一部モジュールはそのアプリでモジュールをアンマウントします。この挙動を望まない、あるいは一部アプリに影響する場合は、次のいずれかの方法を取ってください。

1. 「Umount modules by default」を有効のままにし、モジュールを読み込みたいアプリの App Profile では個別に「Umount modules」を無効にする（ホワイトリスト方式）。
2. 「Umount modules by default」を無効にし、アンマウントしたいアプリでのみ個別に「Umount modules」を有効にする（ブラックリスト方式）。

::: info
カーネル 5.10 以降を実行しているデバイスでは、カーネルが追加の処理なしにモジュールをアンマウントします。一方 5.10 未満のデバイスでは、このオプションは設定値を示すだけで KernelSU は何もしません。5.10 より前のカーネルで「Umount modules」を使いたい場合は、`fs/namespace.c` にある `path_umount` 関数をバックポートする必要があります。詳細は [Integrate for non-GKI devices](https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#how-to-backport-path_umount) ページの末尾を参照してください。Zygisksu など一部モジュールも、モジュールをアンマウントすべきかどうかを判断するためにこのオプションを参照します。
:::

```

`website/docs/ja_JP/guide/difference-with-magisk.md`:

```md
# Magisk との違い

KernelSU モジュールと Magisk モジュールには多くの共通点がありますが、実装の仕組みが全く異なるため、必然的にいくつかの相違点が存在します。Magisk と KernelSU の両方でモジュールを動作させたい場合、これらの違いを理解する必要があります。

## 似ているところ

- モジュールファイルの形式：どちらもzip形式でモジュールを整理しており、モジュールの形式はほぼ同じです。
- モジュールのインストールディレクトリ：どちらも `/data/adb/modules` に配置されます。
- システムレス：どちらもモジュールによるシステムレスな方法で /system を変更できます。
- post-fs-data.sh: 実行時間と意味は全く同じです。
- service.sh: 実行時間と意味は全く同じです。
- system.prop：全く同じです。
- sepolicy.rule：全く同じです。
- BusyBox：スクリプトは BusyBox で実行され、どちらの場合も「スタンドアロンモード」が有効です。

## 違うところ

違いを理解する前に、モジュールが KernelSU で動作しているか Magisk で動作しているかを区別する方法を知っておく必要があります。環境変数 `KSU` を使うとモジュールスクリプトを実行できるすべての場所 (`customize.sh`, `post-fs-data.sh`, `service.sh`) で区別できます。KernelSU では、この環境変数に `true` が設定されます。

以下は違いです：

- KernelSU モジュールは、リカバリーモードではインストールできません。
- KernelSU モジュールには Zygisk のサポートが組み込まれていません（ただし[ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext)を使うと Zygisk モジュールを使用できます）。
- **モジュールマウントアーキテクチャ**：KernelSU は [metamodule システム](metamodule.md) を使用し、マウントをプラグ可能な metamodule (`meta-overlayfs`など) に委任します。一方、Magisk はマウントをコアに組み込んでいます。KernelSU はモジュールマウントを有効にするために metamodule のインストールが必要です。
- KernelSU モジュールにおけるファイルの置換や削除の方法は、Magisk とは全く異なります。KernelSU は `.replace` メソッドをサポートしていません。その代わり、`mknod filename c 0 0` で同名のファイルを作成し、対応するファイルを削除する必要があります。
- BusyBox 用のディレクトリが違います。KernelSU の組み込み BusyBox は `/data/adb/ksu/bin/busybox` に、Magisk では `/data/adb/magisk/busybox` に配置されます。**これは KernelSU の内部動作であり、将来的に変更される可能性があることに注意してください!**
- KernelSU は `.replace` ファイルをサポートしていません。しかし、KernelSU はファイルやフォルダを削除したり置き換えたりするための `REMOVE` と `REPLACE` 変数をサポートしています。
- KernelSU は `boot-completed.sh` スクリプトを追加し、Android システムの起動完了後にタスクを実行できます。
- KernelSU は `post-mount.sh` スクリプトを追加し、モジュールマウント完了後にタスクを実行できます。

```

`website/docs/ja_JP/guide/faq.md`:

```md
# よくある質問

## 私のデバイスは KernelSU に対応していますか?

まず、お使いのデバイスがブートローダーのロックを解除できる必要があります。もしできないのであれば、サポート外です。

もし KernelSU アプリで「非対応」と表示されたら、そのデバイスは最初からサポートされていないことになりますが、カーネルソースをビルドして KernelSU を組み込むか、[非公式の対応デバイス](unofficially-support-devices)で動作させることが可能です。

## KernelSU を使うにはブートローダーのロックを解除する必要がありますか？

はい。

## KernelSU はモジュールに対応していますか?

はい。ほとんどの Magisk モジュールは KernelSU で動作します。ただし、モジュールが `/system` ファイルを変更する必要がある場合は、[metamodule](metamodule.md) (`meta-overlayfs`など) をインストールする必要があります。他のモジュール機能は metamodule なしで動作します。詳細は [モジュールガイド](module.md) をご覧ください。

## KernelSU は Xposed に対応していますか?

はい。[Dreamland](https://github.com/canyie/Dreamland) や [TaiChi](https://taichi.cool) が動作します。LSPosed については、[ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) を使うと動作するようにできます。

## KernelSU は Zygisk に対応していますか?

KernelSU は Zygisk サポートを内蔵していません。[ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) を使ってください。

## KernelSU は Magisk と互換性がありますか?

KernelSU のモジュールシステムは Magisk のマジックマウントと競合しており、KernelSU で有効になっているモジュールがある場合、Magisk 全体が動作しなくなります。

しかし、KernelSU の `su` だけを使うのであれば、Magisk とうまく連携することができます。KernelSU は `kernel` を、Magisk は `ramdisk` を修正するため、両者は共存できます。

## KernelSU は Magisk の代わりになりますか？

私たちはそうは思っていませんし、それが目標でもありません。Magisk はユーザ空間の root ソリューションとして十分であり、長く使われ続けるでしょう。KernelSU の目標は、ユーザーにカーネルインターフェースを提供することであり、Magisk の代用ではありません。

## KernelSU は GKI 以外のデバイスに対応できますか？

可能です。ただしカーネルソースをダウンロードし、KernelSU をソースツリーに統合して、自分でカーネルをビルドする必要があります。

## KernelSU は Android 12 以下のデバイスに対応できますか？

KernelSU の互換性に影響を与えるのはデバイスのカーネルであり、Android のバージョンとは無関係です。唯一の制限は、Android 12 で発売されたデバイスはカーネル5.10以上（GKI デバイス）でなければならないことです：

1. Android 12 をプリインストールして発売された端末は対応しているはずです。
2. カーネルが古い端末（一部の Android 12 端末はカーネルも古い）は対応可能ですが、カーネルは自分でビルドする必要があります。

## KernelSU は古いカーネルに対応できますか？

KernelSU は現在カーネル4.14にバックポートされていますが、それ以前のカーネルについては手動でバックポートする必要があります。プルリクエスト歓迎です！

## 古いカーネルに KernelSU を組み込むには？

[ガイド](../../guide/how-to-integrate-for-non-gki) を参考にしてください。

## Android のバージョンが13なのに、カーネルは「android12-5.10」と表示されるのはなぜ？

カーネルのバージョンは Android のバージョンと関係ありません。カーネルを書き込む必要がある場合は、常にカーネルのバージョンを使用してください。Android のバージョンはそれほど重要ではありません。

## KernelSU に-mount-master/global のマウント名前空間はありますか？

今はまだありませんが（将来的にはあるかもしれません）、グローバルマウントの名前空間に手動で切り替える方法は、以下のようにたくさんあります：

1. `nsenter -t 1 -m sh` でシェルをグローバル名前空間にします。
2. `nsenter --mount=/proc/1/ns/mnt` を実行したいコマンドに追加すればグローバル名前空間で実行されます。 KernelSU は [このような使い方](https://github.com/tiann/KernelSU/blob/77056a710073d7a5f7ee38f9e77c9fd0b3256576/manager/app/src/main/java/me/weishu/kernelsu/ui/util/KsuCli.kt#L115) もできます。

## GKI 1.0 なのですが、使えますか？

GKI1 は GKI2 と全く異なるため、カーネルは自分でビルドする必要があります。

## 新規インストール後にモジュールが動作しないのはなぜですか？

モジュールが `/system` ファイルを変更する必要がある場合は、`system` ディレクトリをマウントするために [metamodule](metamodule.md) をインストールする必要があります。他のモジュール機能（スクリプト、sepolicy、system.prop）は metamodule なしで動作します。

**解決策**：インストール手順については [Metamodule ガイド](metamodule.md) をご覧ください。

## metamodule とは何ですか？なぜ必要なのですか？

Metamodule は、通常のモジュールをマウントするためのインフラストラクチャを提供する特殊なモジュールです。完全な説明については [Metamodule ガイド](metamodule.md) をご覧ください。

```

`website/docs/ja_JP/guide/hidden-features.md`:

```md
# 隠し機能

## .ksurc

デフォルトでは `/system/bin/sh` は `/system/etc/mkshrc` を読み込みます。

`/data/adb/ksu/.ksurc` ファイルを作成することで、カスタマイズした rc ファイルを su に読み込ませられます。
```

`website/docs/ja_JP/guide/how-to-build.md`:

```md
# KernelSU のビルド方法は？

::: warning
このドキュメントはアーカイブ参照のみを目的としており、更新されなくなりました。
KernelSU v3.0以降、より高速な反復とビルド速度のため、GKIイメージモードの公式サポートを終了しました。`Ylarod/ddk` を使用してLKMをビルドすることをお勧めします。
:::

まず、Android の公式ドキュメントを読むべきです：

1. [カーネルをビルドする](https://source.android.com/docs/setup/build/building-kernels)
2. [GKI リリースビルド](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

::: 警告
このページは GKI デバイス用です。もし古いカーネルを使用している場合は、[古いカーネルへの KernelSU の統合方法](how-to-integrate-for-non-gki)を参照してください。
:::

## カーネルビルド

### カーネルソースコードの同期

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

`<kernel_manifest.xml>` は、ビルドを一意に決定するマニフェストファイルです。マニフェストを使用して再現可能なビルドを行えます。マニフェストファイルは [Google GKI リリースビルド](https://source.android.com/docs/core/architecture/kernel/gki-release-builds) からダウンロードしてください。

### ビルド

まずは [公式ドキュメント](https://source.android.com/docs/setup/build/building-kernels)を確認してください。

たとえば、aarch64 カーネルイメージをビルドする必要があります：

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```
`LTO=thin` フラグを追加するのを忘れないでください。それをしないと、コンピュータのメモリが 24Gb 未満の場合にビルドに失敗する可能性があります。

Android 13 からは、カーネルは `bazel` によってビルドされます：

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```
## KernelSU を使ったカーネルビルド

もしカーネルを正常にビルドできた場合、KernelSU をビルドするのは簡単です。カーネルソースのルートディレクトリで任意のものを選択して実行します：

::: code-group
```sh[最新タグ(安定版)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```
```sh[ main ブランチ (開発用)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```
```sh[タグを選択 (例：v0.5.2)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

:::

その後でカーネルを再ビルドすると、KernelSU が組み込まれたカーネルイメージが得られます！

```

`website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md`:

```md
# 非 GKI カーネルで KernelSU を統合する方法は？

::: warning
このドキュメントはアーカイブ参照のみを目的としており、更新されなくなりました。
KernelSU v1.0以降、非GKIデバイスの公式サポートを終了しました。
:::

KernelSU は非 GKI カーネルに統合することが可能であり、4.14 以下のバージョンにバックポートされました。

非 GKI カーネルの断片化のため、統一されたビルド方法がありませんので、非 GKI ブートイメージを提供することができません。しかし、KernelSU を統合して自分自身でカーネルをビルドすることができます。

まず、カーネルソースコードからブート可能なカーネルをビルドできる能力が必要です。もしカーネルがオープンソースでない場合、あなたのデバイスで KernelSU を実行することは困難です。

ブート可能なカーネルをビルドできるなら、カーネルソースコードに KernelSU を統合する方法は二つあります：

1. `kprobe` で自動的に
2. 手動で

## kprobe で統合する

KernelSU は kprobe を使ってカーネルフックを行います。もし *kprobe* があなたのカーネルでうまく動作する場合、この方法を使うことを推奨します。

まず、KernelSU をカーネルソースツリーに追加してください：

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

次に、*kprobe* がカーネル設定で有効になっているか確認してください。もし有効でなければ、これらの設定を追加してください：

```
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```
そしてカーネルを再度ビルドしてください。KernelSU はうまく動作するはずです。

KPROBES がまだ有効化されていない場合は、CONFIG_MODULES を有効化して試みることができます。（それでも効果がない場合は、make menuconfig を使って KPROBES の他の依存関係を検索してください）

しかし、KernelSU を統合した際にブートループに遭遇した場合、それは *kprobe* があなたのカーネルで破損している可能性があります。kprobe のバグを修正するか、二番目の方法を使用するべきです。

:::tip kprobe が破損しているかどうかを確認する方法は？

`KernelSU/kernel/ksu.c` にある `ksu_sucompat_init()` と `ksu_ksud_init()` をコメントアウトし、デバイスが正常にブートするか試してください。もし正常にブートするならば、kprobe が破損している可能性があります。

## カーネルソースを手動で変更する

もし kprobe があなたのカーネルで機能しない場合（上流のバグや 4.8 以下のカーネルバグが原因かもしれません）、以下の方法を試すことができます。

まず、KernelSU をカーネルソースツリーに追加してください：

::: code-group
## カーネルソースを手動で変更する

もし kprobe があなたのカーネルで機能しない場合（上流のバグや 4.8 以下のカーネルバグが原因かもしれません）、以下の方法を試すことができます。

まず、KernelSU をカーネルソースツリーに追加してください：

::: code-group

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

[ main branch(dev)]
```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

[Select tag(Such as v0.5.2)]
```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```


:::

いくつかのデバイスでは、あなたの defconfig が `arch/arm64/configs` にあったり、または他のケースでは `arch/arm64/configs/vendor/your_defconfig` にあることを念頭に置いてください。例えばあなたの defconfig で、`CONFIG_KSU` を y で有効に、または n で無効に設定します。あなたのパスは次のようになるでしょう：
`arch/arm64/configs/...`
```
# KernelSU
CONFIG_KSU=y
```
次に、KernelSU の呼び出しをカーネルソースに追加します。こちらは参照のためのパッチです：

::: code-group

```diff[exec.c]
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
+#endif
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
+   #endif
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff[open.c]
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
+#endif
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff[read_write.c]
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);

+#ifdef CONFIG_KSU
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
+#endif
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
+   #ifdef CONFIG_KSU 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+   #endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff[stat.c]
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;

+   #ifdef CONFIG_KSU
+	ksu_handle_stat(&dfd, &filename, &flags);
+   #endif
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```
カーネル ソースには 4 つの関数があるはずです。

1. do_faccessat、通常は `fs/open.c` にあります
2. do_execveat_common (通常は `fs/exec.c` にあります)
3. vfs_read (通常は `fs/read_write.c` にあります)
4. vfs_statx (通常は「fs/stat.c」にあります)

カーネルに `vfs_statx` がない場合は、代わりに `vfs_fstatat` を使用してください:

```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
+   #ifdef CONFIG_KSU 
+	ksu_handle_stat(&dfd, &filename, &flag);
+   #endif
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

4.17 より前のカーネルの場合、`do faccessat` が見つからない場合は、`faccessat` システムコールの定義に移動して、そこで呼び出しを実行します。

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+#endif
+
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

KernelSU の組み込み SafeMode を有効にするには、`drivers/input/input.c` の `input_handle_event` も変更する必要があります。

:::ヒント
この機能を有効にすることを強くお勧めします。ブートループを防ぐのに非常に役立ちます!
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+#endif
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
+   #endif
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

最後に、カーネルを再度ビルドすると、KernelSU が正常に動作するはずです。

### How to backport path_umount

You can make the "Umount modules" feature work on pre-GKI kernels by manually backporting `path_umount` from 5.9. You can use this patch as reference:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

Finally, build your kernel again, and KernelSU should work correctly.

:::info 誤ってセーフ モードに入ってしまった場合は、
手動統合を使用し、`CONFIG_KPROBES` を無効にしない場合、ユーザーは起動後に音量を下げるボタンを押してセーフ モードをトリガーする可能性があります。 したがって、手動統合を使用する場合は、`CONFIG_KPROBES` を無効にする必要があります。
:::

```

`website/docs/ja_JP/guide/installation.md`:

```md
# インストール

## デバイスが対応しているか確認する

[GitHub Releases](https://github.com/tiann/KernelSU/releases) から KernelSU Manager アプリをダウンロードし、お使いのデバイスにインストールしてください。

- アプリが「非対応」と表示した場合は、**自分でカーネルをコンパイルする必要がある**という意味です。KernelSU は書き込むためのブートイメージを提供しません。
- アプリが「未インストール」と表示した場合、お使いのデバイスは KernelSU に対応しています。

::: info ヒント
非対応と表示されているデバイスについては、[非公式の対応デバイス](unofficially-support-devices.md)であればご自身でカーネルをビルドできます。
:::

## 純正の boot.img をバックアップ

書き込む前に、まず純正の boot.img をバックアップする必要があります。ブートループが発生した場合は、fastboot を使用して純正のブートイメージを書き込むことでいつでもシステムを復旧できます。

::: warning 警告
書き込みによりデータ損失を引き起こす可能性があります。次のステップに進む前に、このステップを必ず行うようにしてください！また、可能であればすべてのデータをバックアップしてください。
:::

## 必要な知識

### ADB と fastboot

このチュートリアルでは、デフォルトで ADB と fastboot のツールを使用します。ご存じない方は、まず検索エンジンを使って勉強されることをおすすめします。

### KMI

同じ Kernel Module Interface (KMI) のカーネルバージョンは**互換性があります**。これが GKI の「汎用」という意味です。逆に言えば KMI が異なればカーネルには互換性がなく、お使いのデバイスと異なる KMI のカーネルイメージを書き込むと、ブートループが発生する場合があります。

具体的には GKI デバイスの場合、カーネルバージョンの形式は以下のようになります：

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

`w.x-zzz-k` は KMI のバージョンです。例えば、デバイスのカーネルバージョンが `5.10.101-android12-9-g30979850fc20` である場合、その KMIは `5.10-android12-9` であり、理論的には他の KMI カーネルでも正常に起動できます。

::: tip ヒント
カーネルバージョンの SubLevel は、KMI の一部ではないことに注意してください。`5.10.101-android12-9-g30979850fc20` は `5.10.137-android12-9-g30979850fc20` と同じ KMI を持っているということになります。
:::

### セキュリティパッチレベル {#security-patch-level}

新しめの Android 端末には、セキュリティパッチレベルが古い boot イメージのフラッシュを許可しないロールバック防止機構が導入されていることがあります。例えば、もしあなたの端末のカーネルが `5.10.101-android12-9-g30979850fc20` であれば、セキュリティパッチレベルは `2023-11` です。たとえ KMI に対応するカーネルをフラッシュしても、セキュリティパッチレベルが (`2023-06` のように) `2023-11` より低い場合、ブートループを起こす可能性があります。

### Kernel バージョンと Android バージョンの違い

注意： **カーネルバージョンと Android バージョンは必ずしも同じではありません**。

カーネルのバージョンは「android12-5.10.101」なのに、Android システムのバージョンは「Android 13」などとなっていても、驚かないでください。Android システムのバージョン番号は、必ずしも Linux カーネルのバージョン番号と同じではありません。Linux カーネルのバージョン番号は、通常、**デバイスの出荷時**にプリインストールされている Android システムのバージョンに一致しています。Android システムが後でアップグレードされた場合、一般的にはカーネルのバージョンは変更されません。フラッシュをする際は、**必ずカーネルバージョンを参照してください**!!!

## はじめに

バージョン [0.9.0](https://github.com/tiann/KernelSU/releases/tag/v0.9.0) 以降、KernelSU は GKI 端末において 2 つの動作モードに対応しています。

1. `GKI`: 端末本来のカーネルを KernelSU によって提供される **汎用カーネルイメージ** (GKI) で置き換えます。
2. `LKM`: 端末本来のカーネルを置き換えずに、カーネルに **ローダブルカーネルモジュール** (LKM) を読み込みます。

これらの 2 つのモードはそれぞれ異なる状況に適しており、必要に応じてどちらかを選ぶことができます。

### GKI モード {#gki-mode}

GKI モードでは、端末本来のカーネルは KernelSU によって提供される汎用カーネルイメージによって置き換えられます。GKI モードの利点は:

1. 強い汎用性があり、大部分の端末に適合。例えば、Samsung 端末は KNOX が有効であり、LKM モードは動作できません。また、GKI モードしか使えないニッチな改造を施された端末もあります。
2. 公式ファームウェアに依存せずに使うことができます。KMI が一致している限り、公式ファームウェアの更新を待つことなく使うことができます。

### LKM モード {#lkm-mode}

LKM モードでは、端末本来のカーネルを置き換えずに、カーネルにローダブルカーネルモジュールを読み込みます。LKM モードの利点は:

1. 端末本来のカーネルを置き換えません。端末本来のカーネルに特別な要件がある場合や、KernelSU をサードパーティのカーネルと両用したい場合、LKM モードを利用できます。
2. アップグレードと OTA がより便利です。KernelSU をアップデートする時は、手動でフラッシュすることなくマネージャーから直接インストールできます。システム OTA の後は、手動でフラッシュすることなく非アクティブなスロットに直接インストールすることができます。
3. いくつかの特殊な状況に適しています。例えば、LKM は一時的な Root 権限を用いて読み込むことができます。boot パーティションを置き換えないので、AVB を動作させず、端末を文鎮化しません。
4. LKM は一時的にアンインストールすることができます。一時的に root アクセスを無効化したい場合、LKM をアンインストールすることができます。この過程でパーティションをフラッシュすることも、また再起動することさえも必要ありません。root アクセスを再度有効化したい場合は、再起動するだけです。

:::tip 2 つのモードの共存
マネージャーを開くと、ホームで現在の端末の動作モードを確認できます。GKI モードの優先度は LKM モードより高いことに留意してください。例えば、本来のカーネルを GKI カーネルで置き換えたうえで LKM を使って GKI カーネルにパッチしている場合、LKM は無視され、端末は常時 GKI モードで動作します。
:::

### どちらを選ぶべきですか? {#which-one}

端末が携帯電話の場合、LKM モードを優先することを推奨します。端末がエミュレーター、WSA、または Waydroid の場合、GKI モードを優先することを推奨します。

## LKM モードのインストール

### 公式ファームウェアの入手

LKM モードを使うためには、公式ファームウェアを入手し、それを基にパッチを当てる必要があります。サードパーティのカーネルを使う場合、その `boot.img` を公式ファームウェアとして利用できます。

公式ファームウェアを入手する方法はたくさんあります。端末が `fastboot boot` に対応している場合、`fastboot boot` を使って一時的に KernelSU が提供する GKI カーネルを起動する、 **最も推奨される、最も簡単な** 方法を推奨します。

端末が `fastboot boot` に対応していない場合、公式ファームウェアのパッケージを手動でダウンロードし、そこから `boot.img` を展開する必要があります。

GKI モードとは異なり、LKM モードは `ramdisk` を展開します。そのため、Android 13 の端末では `boot` パーティションの代わりに `init_boot` パーティションにパッチを当てる必要があります。一方で、GKI モードは常に `boot` パーティションを操作します。

### マネージャーを使う

マネージャーを開き、右上のインストールアイコンをタップすると、いくつかのオプションが現れます:

1. ファイルを選択しパッチを当てる。端末が Root 権限を持っていない場合、このオプションを選択し、公式ファームウェアを選択すると、マネージャーが自動的にパッチを当てます。恒久的に Root 権限を獲得するには、パッチが当てられたファイルをフラッシュするだけです。
2. 直接インストール。端末が既に Root 化されている場合、このオプションを選択すると、マネージャーが自動的に端末の情報を取得し、自動的に公式ファームウェアにパッチを当て、それをフラッシュします。`fastboot boot` で KernelSU の GKI を起動し一時的に Root 権限を獲得したうえでこのオプションを利用することもできます。これは KernelSU をアップグレードする主な方法でもあります。
3. 非アクティブなスロットにインストール。端末が A/B パーティションに対応している場合、このオプションを選択すると、マネージャーが自動的に公式ファームウェアにパッチを当て、もう一方のパーティションにインストールします。この方法は OTA 後の端末に適しており、OTA 後にもう一方のパーティションに直接 KernelSU をインストールし、端末を再起動することができます。

### コマンドラインを使う

マネージャーを使いたくない場合、コマンドラインを使って LKM をインストールできます。KernelSU の提供する `ksud` ツールを使うと、迅速に公式ファームウェアにパッチを当てフラッシュすることができます。

このツールは macOS、Linux および Windows に対応しています。[GitHub Release](https://github.com/tiann/KernelSU/releases) から対応するバージョンをダウンロードしてください。

使用方法: `ksud bootpatch` コマンドの各オプションのヘルプをコマンドラインから確認できます。
```sh
oriole:/ # ksud boot-patch -h
Patch boot or init_boot images to apply KernelSU

Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              boot image path, if not specified, will try to find the boot image automatically
  -k, --kernel <KERNEL>          kernel image path to replace
  -m, --module <MODULE>          LKM module path to replace, if not specified, will use the builtin one
  -i, --init <INIT>              init to be replaced
  -u, --ota                      will use another slot when boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                output path, if not specified, will use current directory
      --magiskboot <MAGISKBOOT>  magiskboot path, if not specified, will use builtin one
      --kmi <KMI>                KMI version, if specified, will use the specified KMI
  -h, --help                     Print help
```

説明が必要ないくつかのオプション:

1. `--magiskboot` オプションは magiskboot のパスを指定します。指定されていない場合、ksud は環境変数を参照します。magiskboot の入手方法がわからない場合、[こちら](#patch-boot-image) を参照してください。
2. `--kmi` オプションは `KMI` バージョンを指定します。端末のカーネル名が KMI の仕様に準拠していない場合は、このオプションで指定することができます。

最も一般的な使い方: 

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## GKI モードのインストール

GKI モードのインストール方法はいくつかあり、それぞれ適したシーンが異なりますので、必要に応じて選択してください。

1. KernelSU が提供する boot.img を使用し、fastboot でインストールする
2. KernelFlasher などのカーネル管理アプリでインストールする
3. boot.img を手動でパッチしてインストールする
4. カスタムリカバリー（TWRPなど）でインストールする

## KernelSU が提供する boot.img を使用してインストール

この方法は TWRP や root 権限を必要としないので、KernelSU を初めてインストールする場合に適しています。

### 正しい boot.img を見つける

KernelSU では、GKI デバイス用の汎用 boot.img を提供しています。デバイスの boot パーティションに boot.img をフラッシュする必要があります。

boot.img は、[GitHub Release](https://github.com/tiann/KernelSU/releases) からダウンロードできます。例えば、あなたのデバイスがカーネル `android12-5.10.101` の場合、`android-5.10.101_yyyy-MM.boot-<format>.img`をダウンロードする必要があります。（KMI を同じにしてください！）。

`<format>`は純正 boot.img のカーネル圧縮形式を指します。純正の boot.img のカーネル圧縮形式を確認してください。間違った圧縮形式を使うと、ブートループするかもしれません。

::: info 情報
1. magiskboot を使えば、元のブートの圧縮形式を知ることができます。もちろん、あなたのデバイスと同じモデルを持つ、より経験豊富な他の人にも聞くこともできます。また、カーネルの圧縮形式は通常変更されないので、ある圧縮形式でうまく起動した場合、後でその形式を試すことも可能です。
2. Xiaomi デバイスでは通常 `gz` か**無圧縮**が使われます。
3. Pixel デバイスでは以下の手順に従ってください。
:::

### boot.img をデバイスに書き込む

`adb` でデバイスを接続し、`adb reboot bootloader` で fastboot モードにし、このコマンドで KernelSU を書き込んでください：

```sh
fastboot flash boot boot.img
```

::: info 情報
デバイスが `fastboot boot` をサポートしている場合、まず `fastboot boot.img` を使えば書き込みせずにシステムを起動できます。予期せぬことが起こった場合は、もう一度再起動して起動してください。
:::

### 再起動

書き込みが完了したら、デバイスを再起動します：

```sh
fastboot reboot
```

## カーネル管理アプリでインストール

前提条件：お使いのデバイスが root 化されている必要があります。例えば、Magisk をインストールして root を取得した場合、または古いバージョンの KernelSU をインストールしており、別のバージョンの KernelSU にアップグレードする必要がある場合などです。お使いのデバイスが root 化されていない場合、他の方法をお試しください。

手順:

1. AnyKernel3 ZIP をダウンロードします。ダウンロード方法は、「カスタムリカバリーでインストール」を参照してください。
2. カーネル管理アプリを開き、AnyKernel3 の ZIP をインストールします。

カーネル管理アプリは以下のようなものが人気です：

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

この方法は KernelSU をアップグレードするときに便利で、パソコンがなくてもできます。（まずはバックアップしてください！）

## boot.img を手動でパッチ {#patch-boot-image}

デバイスによっては、boot.img のフォーマットが `lz4` や、 `gz` 、無圧縮などの一般的な形式ではないことがあります。最も典型的なのは Pixel で、boot.img フォーマットは `lz4_legacy` 圧縮で、RAM ディスクは `gz` か `lz4_legacy` 圧縮です。この時、KernelSU が提供した boot.img を直接書き込むとデバイスが起動できなくなる場合があります。その場合は手動で boot.img に対してパッチしてください。

常に `magiskboot` を利用してイメージにパッチを当てることが推奨されます。2 つの方法があります:

1. [magiskboot](https://github.com/topjohnwu/Magisk/releases)
2. [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci)

公式の `magisikboot` ビルドは Android 端末でしか動作しないため、PC で作業したい場合、2 つめの方法を試してください。

:::tip
Android-Image-Kitchen は現在非推奨です。セキュリティパッチレベルなどの boot メタデータを正しく扱わないため、一部のデバイスでは動作しない可能性があります。
:::

### 準備

1. お使いのデバイスの純正 boot.img を入手します。デバイスメーカーから入手できます。[payload-dumper-go](https://github.com/ssut/payload-dumper-go)が必要かもしれません。
2. お使いのデバイスの KMI バージョンに合った、KernelSU が提供する AnyKernel3 の ZIP ファイルをダウンロードします（*カスタムリカバリーでインストール*を参照してください）。
3. AnyKernel3 パッケージを展開し、KernelSU のカーネルファイルである `Image` ファイルを取得します。

### Android 端末で magiskboot を使う {#using-magiskboot-on-Android-devices}

1. 最新の Magisk を[リリースページ](https://github.com/topjohnwu/Magisk/releases)からダウンロードしてください。
2. `Magisk-*(version).apk` を `Magisk-*.zip` に名前を変更して展開してください。
3. `Magisk-*/lib/arm64-v8a/libmagiskboot.so`を adb でデバイスに転送します：`adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`
4. 純正 boot.img と AnyKernel3 の中の Image をデバイスに転送します。
5. adb shell に入り、`cd /data/local/tmp/` し、`chmod +x magiskboot` を実行します。
6. adb shell に入り、`cd /data/local/tmp/` し、`./magiskboot unpack boot.img` を実行して `boot.img` を抽出します。`kernel` ファイルが純正カーネルです。
7. `kernel` を `Image` で置き換えます: `mv -f Image kernel`
8. `./magiskboot repack boot.img` を実行してブートイメージをリパックします。出来上がった `new-boot.img` を fastboot でデバイスに書き込んでください。

### Windows/macOS/Linux PC で magiskboot を使う {#using-magiskboot-on-PC}

1. OS に対応する `magiskboot` バイナリを [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci) からダウンロードします。
2. 純正の `boot.img` と `Image` を PC 上に準備します。
3. `chmod +x magiskboot` を実行します。
4. 対応するディレクトリに入り、`./magiskboot unpack boot.img` を実行して `boot.img` を展開します。展開された `kernel` ファイルが純正のカーネルです。
5. 下記のコマンドを実行し、`kernel` を `Image` で置き換えてください: `mv -f Image kernel`
6. `./magiskboot repack boot.img` を実行し、boot イメージを再パックします。作成された `new-boot.img` ファイルを、fastboot を利用して端末にフラッシュします。

::: info
公式の `magiskboot` は、`Linux` 環境においては正常に動作します。Linux を使っている場合、公式のビルドを利用できます。
:::

## カスタムリカバリーでインストール {#install-with-custom-recovery}

前提条件：デバイスに TWRP などのカスタムリカバリーがあること。ない場合、または公式リカバリーしかない場合は他の方法を使用してください。

手順:

1. KernelSUの[リリースページ](https://github.com/tiann/KernelSU/releases)から、お使いのデバイスのバージョンにあった AnyKernel3 で始まる ZIP パッケージをダウンロードします。例えば、デバイスのカーネルのバージョンが`android12-5.10. 66`の場合、AnyKernel3-android12-5.10.66_yyyy-MM.zip`（yyyy`は年、`MM`は月）のファイルをダウンロードします。
2. デバイスを TWRP へ再起動します。
3. adb を使用して AnyKernel3-*.zip をデバイスの /sdcard に入れ、TWRP GUI でインストールを選択します。または直接`adb sideload AnyKernel-*.zip` でインストールできます。

この方法は TWRP を使用できるならどのようなインストール（初期インストールやその後のアップグレード）にも適しています。

## その他の方法

実はこれらのインストール方法はすべて、**元のカーネルを KernelSU が提供するカーネルに置き換える**という主旨でしかなく、これが実現できれば他の方法でもインストール可能です：

## インストール後：モジュールサポート {#post-installation}

::: warning システムファイル変更用の METAMODULE
`/system` ファイルを変更するモジュールを使用したい場合は、KernelSU インストール後に **metamodule** をインストールする必要があります。スクリプト、sepolicy、または system.prop のみを使用するモジュールは metamodule なしで動作します。
:::

**`/system` 変更サポートが必要な場合**、[Metamodule ガイド](metamodule.md)を参照して：
- metamodule とは何か、なぜ必要なのかを理解する
- 公式の `meta-overlayfs` metamodule をインストールする
- 他の metamodule オプションについて学ぶ

1. まず Magisk をインストールし、Magisk を通じて root 権限を取得し、カーネル管理アプリで KernelSU の AnyKernel ZIPをインストールする
2. PC 上で何らかの書き込みツールを使用し、KernelSU が提供するカーネルを書き込む

しかし、これらの方法でうまく行かない場合、`magiskboot` を使う方法を試してみてください。

```

`website/docs/ja_JP/guide/metamodule.md`:

```md
# メタモジュール

メタモジュールは、KernelSU の革命的な機能であり、モジュールシステムの重要な機能をコアデーモンからプラグイン可能なモジュールに移行します。このアーキテクチャの転換により、KernelSU の安定性とセキュリティを維持しながら、モジュールエコシステムのより大きなイノベーションの可能性を解き放ちます。

## メタモジュールとは?

メタモジュールは、モジュールシステムのコアインフラストラクチャ機能を提供する特別なタイプの KernelSU モジュールです。システムファイルを変更する通常のモジュールとは異なり、メタモジュールは通常のモジュールの*インストールとマウントの方法*を制御します。

メタモジュールは、KernelSU のモジュール管理インフラストラクチャの完全なカスタマイズを可能にするプラグインベースの拡張メカニズムです。マウントとインストールのロジックをメタモジュールに委任することで、KernelSU は脆弱な検出ポイントになることを避けながら、多様な実装戦略を可能にします。

**主な特徴:**

- **インフラストラクチャの役割**: メタモジュールは通常のモジュールが依存するサービスを提供します
- **単一インスタンス**: 一度に1つのメタモジュールのみインストールできます
- **優先実行**: メタモジュールスクリプトは通常のモジュールスクリプトの前に実行されます
- **特別なフック**: インストール、マウント、クリーンアップのための3つのフックスクリプトを提供します

## なぜメタモジュールが必要なのか?

従来のルートソリューションは、マウントロジックをコアに組み込んでおり、検出されやすく、進化させることが困難です。KernelSU のメタモジュールアーキテクチャは、関心の分離によってこれらの問題を解決します。

**戦略的優位性:**

- **検出面の削減**: KernelSU 自体はマウントを実行しないため、検出ベクトルが減少します
- **安定性**: コアデーモンは安定したままで、マウント実装は進化し続けることができます
- **イノベーション**: コミュニティは KernelSU をフォークすることなく、代替マウント戦略を開発できます
- **選択**: ユーザーは自分のニーズに最適な実装を選択できます

**マウントの柔軟性:**

- **マウントなし**: マウントレスモジュールのみを使用するユーザーは、マウントのオーバーヘッドを完全に回避できます
- **OverlayFS マウント**: 読み書きレイヤーサポートを備えた従来のアプローチ(`meta-overlayfs` 経由)
- **マジックマウント**: より良いアプリ互換性のための Magisk 互換マウント
- **カスタム実装**: FUSE ベースのオーバーレイ、カスタム VFS マウント、または全く新しいアプローチ

**マウントを超えて:**

- **拡張性**: コア KernelSU を変更することなく、カーネルモジュールサポートなどの機能を追加できます
- **モジュール性**: KernelSU リリースとは独立して実装を更新できます
- **カスタマイズ**: 特定のデバイスやユースケースに特化したソリューションを作成できます

::: warning 重要
メタモジュールがインストールされていない場合、モジュールは**マウントされません**。新規の KernelSU インストールでは、モジュールを機能させるためにメタモジュール(`meta-overlayfs` など)をインストールする必要があります。
:::

## ユーザー向け

### メタモジュールのインストール

通常のモジュールと同じ方法でメタモジュールをインストールします:

1. メタモジュール ZIP ファイル(例: `meta-overlayfs.zip`)をダウンロードします
2. KernelSU Manager アプリを開きます
3. フローティングアクションボタン(➕)をタップします
4. メタモジュール ZIP ファイルを選択します
5. デバイスを再起動します

`meta-overlayfs` メタモジュールは、ext4 イメージサポートを備えた従来の overlayfs ベースのモジュールマウントを提供する公式リファレンス実装です。

### アクティブなメタモジュールの確認

KernelSU Manager アプリのモジュールページで、現在アクティブなメタモジュールを確認できます。アクティブなメタモジュールは、特別な指定とともにモジュールリストに表示されます。

### メタモジュールのアンインストール

::: danger 警告
メタモジュールをアンインストールすると、**すべて**のモジュールに影響します。削除後、別のメタモジュールをインストールするまで、モジュールはマウントされなくなります。
:::

アンインストール手順:

1. KernelSU Manager を開きます
2. モジュールリストでメタモジュールを見つけます
3. アンインストールをタップします(特別な警告が表示されます)
4. アクションを確認します
5. デバイスを再起動します

アンインストール後、モジュールが引き続き動作するようにするには、別のメタモジュールをインストールする必要があります。

### 単一メタモジュールの制約

一度に1つのメタモジュールのみインストールできます。2つ目のメタモジュールをインストールしようとすると、KernelSU は競合を避けるためにインストールを防止します。

メタモジュールを切り替える手順:

1. すべての通常のモジュールをアンインストールします
2. 現在のメタモジュールをアンインストールします
3. 再起動します
4. 新しいメタモジュールをインストールします
5. 通常のモジュールを再インストールします
6. 再度再起動します

## モジュール開発者向け

通常の KernelSU モジュールを開発している場合、メタモジュールについてあまり心配する必要はありません。ユーザーが互換性のあるメタモジュール(`meta-overlayfs` など)をインストールしていれば、モジュールは動作します。

**知っておくべきこと:**

- **マウントにはメタモジュールが必要**: モジュール内の `system` ディレクトリは、ユーザーがマウント機能を提供するメタモジュールをインストールしている場合にのみマウントされます
- **コード変更不要**: 既存のモジュールは変更なしで引き続き動作します

::: tip
Magisk モジュール開発に精通している場合、メタモジュールをインストールすると、Magisk 互換のマウントを提供するため、モジュールは KernelSU でも同じように動作します。
:::

## メタモジュール開発者向け

メタモジュールを作成すると、KernelSU がモジュールのインストール、マウント、アンインストールを処理する方法をカスタマイズできます。

### 基本要件

メタモジュールは、`module.prop` の特別なプロパティによって識別されます:

```txt
id=my_metamodule
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

`metamodule=1`(または `metamodule=true`)プロパティは、これをメタモジュールとしてマークします。このプロパティがない場合、モジュールは通常のモジュールとして扱われます。

### ファイル構造

メタモジュール構造:

```txt
my_metamodule/
├── module.prop              (metamodule=1 を含む必要があります)
│
│      *** メタモジュール固有のフック ***
├── metamount.sh             (オプション: カスタムマウントハンドラー)
├── metainstall.sh           (オプション: 通常モジュールのインストールフック)
├── metauninstall.sh         (オプション: 通常モジュールのクリーンアップフック)
│
│      *** 標準モジュールファイル(すべてオプション) ***
├── customize.sh             (インストールカスタマイズ)
├── post-fs-data.sh          (post-fs-data ステージスクリプト)
├── service.sh               (late_start service スクリプト)
├── boot-completed.sh        (起動完了スクリプト)
├── uninstall.sh             (メタモジュール自体のアンインストールスクリプト)
├── system/                  (必要に応じてシステムレス変更)
└── [その他のファイル]
```

メタモジュールは、特別なメタモジュールフックに加えて、すべての標準モジュール機能(ライフサイクルスクリプトなど)を使用できます。

### フックスクリプト

メタモジュールは最大3つの特別なフックスクリプトを提供できます:

#### 1. metamount.sh - マウントハンドラー

**目的**: 起動中にモジュールがマウントされる方法を制御します。

**実行タイミング**: `post-fs-data` ステージ中、モジュールスクリプトが実行される前。

**環境変数:**

- `MODDIR`: メタモジュールのディレクトリパス(例: `/data/adb/modules/my_metamodule`)
- すべての標準 KernelSU 環境変数

**責任:**

- すべての有効なモジュールをシステムレスにマウントする
- `skip_mount` フラグをチェックする
- モジュール固有のマウント要件を処理する

::: danger 重要な要件
マウント操作を実行する際、ソース/デバイス名を `"KSU"` に**設定する必要があります**。これにより、マウントが KernelSU に属していることが識別されます。

**例(正しい):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**最新のマウント API の場合**、ソース文字列を設定します:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

これは、KernelSU がマウントを適切に識別して管理するために不可欠です。
:::

**スクリプト例:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# 例: シンプルなバインドマウント実装
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # source=KSU でマウント(必須!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - インストールフック

**目的**: 通常のモジュールのインストール方法をカスタマイズします。

**実行タイミング**: モジュールのインストール中、ファイルが抽出された後、インストールが完了する前。このスクリプトは、`customize.sh` の動作と同様に、組み込みインストーラーによって**ソースされます**(実行されるのではありません)。

**環境変数と関数:**

このスクリプトは、組み込みの `install.sh` からすべての変数と関数を継承します:

- **変数**: `MODPATH`、`TMPDIR`、`ZIPFILE`、`ARCH`、`API`、`IS64BIT`、`KSU`、`KSU_VER`、`KSU_VER_CODE`、`BOOTMODE` など
- **関数**:
  - `ui_print <msg>` - コンソールにメッセージを出力
  - `abort <msg>` - エラーを出力してインストールを終了
  - `set_perm <target> <owner> <group> <permission> [context]` - ファイルパーミッションを設定
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - 再帰的にパーミッションを設定
  - `install_module` - 組み込みモジュールインストールプロセスを呼び出す

**ユースケース:**

- 組み込みインストールの前後にモジュールファイルを処理する(準備ができたら `install_module` を呼び出す)
- モジュールファイルを移動する
- モジュールの互換性を検証する
- 特別なディレクトリ構造を設定する
- モジュール固有のリソースを初期化する

**注意**: このスクリプトは、メタモジュール自体をインストールする際には**呼び出されません**。

#### 3. metauninstall.sh - クリーンアップフック

**目的**: 通常のモジュールがアンインストールされるときにリソースをクリーンアップします。

**実行タイミング**: モジュールのアンインストール中、モジュールディレクトリが削除される前。

**環境変数:**

- `MODULE_ID`: アンインストールされるモジュールの ID

**ユースケース:**

- ファイルを処理する
- シンボリックリンクをクリーンアップする
- 割り当てられたリソースを解放する
- 内部追跡を更新する

**スクリプト例:**

```sh
#!/system/bin/sh
# 通常のモジュールをアンインストールするときに呼び出される
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# イメージからモジュールファイルを削除
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### 実行順序

起動実行順序を理解することは、メタモジュール開発にとって重要です:

```txt
post-fs-data ステージ:
  1. 共通の post-fs-data.d スクリプトを実行
  2. モジュールをプルーン、restorecon、sepolicy.rule をロード
  3. メタモジュールの post-fs-data.sh を実行(存在する場合)
  4. 通常のモジュールの post-fs-data.sh を実行
  5. system.prop をロード
  6. メタモジュールの metamount.sh を実行
     └─> すべてのモジュールをシステムレスにマウント
  7. post-mount.d ステージが実行される
     - 共通の post-mount.d スクリプト
     - メタモジュールの post-mount.sh(存在する場合)
     - 通常のモジュールの post-mount.sh

service ステージ:
  1. 共通の service.d スクリプトを実行
  2. メタモジュールの service.sh を実行(存在する場合)
  3. 通常のモジュールの service.sh を実行

boot-completed ステージ:
  1. 共通の boot-completed.d スクリプトを実行
  2. メタモジュールの boot-completed.sh を実行(存在する場合)
  3. 通常のモジュールの boot-completed.sh を実行
```

**重要なポイント:**

- `metamount.sh` は、すべての post-fs-data スクリプト(メタモジュールと通常のモジュールの両方)**の後**に実行されます
- メタモジュールのライフサイクルスクリプト(`post-fs-data.sh`、`service.sh`、`boot-completed.sh`)は、常に通常のモジュールスクリプトの前に実行されます
- `.d` ディレクトリの共通スクリプトは、メタモジュールスクリプトの前に実行されます
- `post-mount` ステージは、マウントが完了した後に実行されます

### シンボリックリンクメカニズム

メタモジュールがインストールされると、KernelSU はシンボリックリンクを作成します:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

これにより、ID に関係なく、アクティブなメタモジュールにアクセスするための安定したパスが提供されます。

**利点:**

- 一貫したアクセスパス
- アクティブなメタモジュールの簡単な検出
- 設定の簡素化

### 実例: meta-overlayfs

`meta-overlayfs` メタモジュールは公式のリファレンス実装です。メタモジュール開発のベストプラクティスを示しています。

#### アーキテクチャ

`meta-overlayfs` は**デュアルディレクトリアーキテクチャ**を使用します:

1. **メタデータディレクトリ**: `/data/adb/modules/`
   - `module.prop`、`disable`、`skip_mount` マーカーを含む
   - 起動中に高速スキャン
   - 小さなストレージフットプリント

2. **コンテンツディレクトリ**: `/data/adb/metamodule/mnt/`
   - 実際のモジュールファイル(system、vendor、product など)を含む
   - ext4 イメージ(`modules.img`)に保存
   - ext4 機能でスペースを最適化

#### metamount.sh の実装

`meta-overlayfs` がマウントハンドラーを実装する方法は次のとおりです:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# まだマウントされていない場合は ext4 イメージをマウント
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# デュアルディレクトリサポートのための環境変数を設定
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# マウントバイナリを実行
# (実際のマウントロジックは Rust バイナリにあります)
"$MODDIR/meta-overlayfs"
```

#### 主な機能

**Overlayfs マウント:**

- 真のシステムレス変更のためのカーネル overlayfs を使用
- 複数のパーティション(system、vendor、product、system_ext、odm、oem)をサポート
- `/data/adb/modules/.rw/` を介した読み書きレイヤーサポート

**ソース識別:**

```rust
// meta-overlayfs/src/mount.rs から
fsconfig_set_string(fs, "source", "KSU")?;  // 必須!
```

これにより、すべてのオーバーレイマウントに対して `dev=KSU` が設定され、適切な識別が可能になります。

### ベストプラクティス

メタモジュールを開発する際:

1. **マウント操作には常にソースを "KSU" に設定する** - カーネルアンマウントと zygisksu アンマウントが正しくアンマウントするためにこれが必要です
2. **エラーを適切に処理する** - 起動プロセスは時間に敏感です
3. **標準フラグを尊重する** - `skip_mount` と `disable` をサポートします
4. **操作をログに記録する** - デバッグには `echo` またはロギングを使用します
5. **徹底的にテストする** - マウントエラーは起動ループを引き起こす可能性があります
6. **動作を文書化する** - メタモジュールが何をするかを明確に説明します
7. **移行パスを提供する** - ユーザーが他のソリューションから切り替えるのを支援します

### メタモジュールのテスト

リリース前に:

1. クリーンな KernelSU セットアップで**インストールをテスト**する
2. さまざまなモジュールタイプで**マウントを検証**する
3. 一般的なモジュールとの**互換性をチェック**する
4. **アンインストールとクリーンアップをテスト**する
5. **起動パフォーマンスを検証**する(metamount.sh はブロッキングです!)
6. 起動ループを避けるために**適切なエラー処理を確保**する

## よくある質問

### メタモジュールは必要ですか?

**ユーザー向け**: マウントが必要なモジュールを使用したい場合のみ。スクリプトを実行するだけでシステムファイルを変更しないモジュールのみを使用する場合は、メタモジュールは必要ありません。

**モジュール開発者向け**: いいえ、通常どおりモジュールを開発します。モジュールがマウントを必要とする場合にのみ、ユーザーはメタモジュールが必要です。

**上級ユーザー向け**: マウント動作をカスタマイズしたい場合、または代替マウント実装を作成したい場合のみ。

### 複数のメタモジュールを持つことはできますか?

いいえ。一度に1つのメタモジュールのみインストールできます。これにより、競合が防止され、予測可能な動作が保証されます。

### 唯一のメタモジュールをアンインストールするとどうなりますか?

モジュールはマウントされなくなります。デバイスは正常に起動しますが、別のメタモジュールをインストールするまで、モジュールの変更は適用されません。

### meta-overlayfs は必須ですか?

いいえ。ほとんどのモジュールと互換性のある標準の overlayfs マウントを提供します。異なる動作が必要な場合は、独自のメタモジュールを作成できます。

## 関連項目

- [モジュールガイド](module.md) - 一般的なモジュール開発
- [Magisk との違い](difference-with-magisk.md) - KernelSU と Magisk の比較
- [ビルド方法](how-to-build.md) - ソースから KernelSU をビルド

```

`website/docs/ja_JP/guide/module-config.md`:

```md
# モジュール設定

KernelSU は、モジュールが永続的または一時的なキー値設定を保存できる組み込みの設定システムを提供します。設定は `/data/adb/ksu/module_configs/<module_id>/` にバイナリ形式で保存され、以下の特性があります:

## 設定タイプ

- **永続設定** (`persist.config`):再起動後も保持され、明示的に削除またはモジュールをアンインストールするまで残ります
- **一時設定** (`tmp.config`):起動時の post-fs-data ステージで自動的にクリアされます

設定を読み取るとき、同じキーに対して一時値が永続値より優先されます。

## モジュールスクリプトでの設定の使用

すべてのモジュールスクリプト(`post-fs-data.sh`、`service.sh`、`boot-completed.sh` など)は、`KSU_MODULE` 環境変数がモジュール ID に設定された状態で実行されます。`ksud module config` コマンドを使用してモジュールの設定を管理できます:

```bash
# 設定値を取得
value=$(ksud module config get my_setting)

# 永続設定値を設定
ksud module config set my_setting "some value"

# 一時設定値を設定(再起動後にクリア)
ksud module config set --temp runtime_state "active"

# stdinから値を設定(複数行や複雑なデータに便利)
ksud module config set my_key <<EOF
複数行
テキスト値
EOF

# またはコマンドからパイプ
echo "value" | ksud module config set my_key

# 明示的なstdinフラグ
cat file.json | ksud module config set json_data --stdin

# すべての設定エントリを一覧表示(永続と一時をマージ)
ksud module config list

# 設定エントリを削除
ksud module config delete my_setting

# 一時設定エントリを削除
ksud module config delete --temp runtime_state

# すべての永続設定をクリア
ksud module config clear

# すべての一時設定をクリア
ksud module config clear --temp
```

## 検証制限

設定システムは以下の制限を強制します:

- **最大キー長**:256 バイト
- **最大値長**:1MB (1048576 バイト)
- **最大設定エントリ数**:モジュールあたり 32 個
- **キー形式**:`^[a-zA-Z][a-zA-Z0-9._-]+$` にマッチする必要があります(モジュールIDと同じ)
  - 文字(a-zA-Z)で開始する必要があります
  - 文字、数字、ドット(`.`)、アンダースコア(`_`)、ハイフン(`-`)を含めることができます
  - 最小長:2文字
- **値形式**:制限なし - 改行、制御文字などを含むあらゆるUTF-8文字を含めることができます
  - 長さプレフィックス付きのバイナリ形式で保存され、すべてのデータの安全な処理を保証

## ライフサイクル

- **起動時**:すべての一時設定が post-fs-data ステージでクリアされます
- **モジュールアンインストール時**:すべての設定(永続と一時)が自動的に削除されます
- 設定はバイナリ形式で保存され、マジックナンバー `0x4b53554d`("KSUM")とバージョン検証を使用します

## ユースケース

設定システムは以下に最適です:

- **ユーザー設定**:WebUI または action スクリプトを通じてユーザーが設定したモジュール設定を保存
- **機能フラグ**:再インストールせずにモジュール機能を有効/無効にする
- **ランタイム状態**:再起動時にリセットすべき一時的な状態を追跡(一時設定を使用)
- **インストール設定**:モジュールインストール時に行った選択を記憶
- **複雑なデータ**:JSON、複数行テキスト、Base64エンコードデータ、または任意の構造化コンテンツを保存(最大1MB)

::: tip ベストプラクティス
- 再起動後も保持すべきユーザー設定には永続設定を使用
- 起動時にリセットすべきランタイム状態や機能フラグには一時設定を使用
- スクリプトで設定値を使用する前に検証する
- 設定の問題をデバッグするには `ksud module config list` コマンドを使用
:::

## 高級機能

モジュール設定システムは、高度なユースケースのための特別な設定キーを提供します:

### モジュール説明のオーバーライド {#overriding-module-description}

`override.description` 設定キーを設定することで、`module.prop` の `description` フィールドを動的にオーバーライドできます:

```bash
# モジュール説明をオーバーライド
ksud module config set override.description "マネージャーに表示されるカスタム説明"
```

モジュールリストを取得する際、`override.description` 設定が存在する場合、`module.prop` の元の説明が置き換えられます。これは以下の場合に便利です:
- モジュール説明に動的なステータス情報を表示
- ユーザーにランタイム設定の詳細を表示
- 再インストールせずにモジュールの状態に基づいて説明を更新

### 管理対象機能の宣言

モジュールは `manage.<feature>` 設定パターンを使用して、管理する KernelSU 機能を宣言できます。サポートされている機能は、KernelSU 内部の `FeatureId` 列挙型に対応しています:

**サポートされている機能:**
- `su_compat` - SU 互換モード
- `kernel_umount` - カーネル自動アンマウント

```bash
# このモジュールが SU 互換性を管理し、有効にすることを宣言
ksud module config set manage.su_compat true

# このモジュールがカーネルアンマウントを管理し、無効にすることを宣言
ksud module config set manage.kernel_umount false

# 機能管理を削除(モジュールはこの機能を制御しなくなります)
ksud module config delete manage.su_compat
```

**動作原理:**
- `manage.<feature>` キーの存在は、モジュールがその機能を管理していることを示します
- 値は希望する状態を示します:`true`/`1` は有効、`false`/`0`(またはその他の値)は無効
- 機能の管理を停止するには、設定キーを完全に削除します

管理対象機能は、モジュールリスト API を通じて `managedFeatures` フィールド(カンマ区切りの文字列)として公開されます。これにより以下が可能になります:
- KernelSU マネージャーがどのモジュールがどの KernelSU 機能を管理しているかを検出
- 複数のモジュールが同じ機能を管理しようとした際の競合を防止
- モジュールとコア KernelSU 機能間のより良い調整

::: warning サポートされている機能のみ
上記にリストされた事前定義された機能名(`su_compat`、`kernel_umount`)のみを使用してください。これらは実際の KernelSU 内部機能に対応しています。他の機能名を使用してもエラーにはなりませんが、機能的な目的はありません。
:::

```

`website/docs/ja_JP/guide/module-webui.md`:

```md
# Module WebUI

KernelSU のモジュールは、ブートスクリプトの実行やシステムファイルの修正に加えて、UI インターフェースの表示やユーザーとの対話もサポートしています。

モジュールは、任意の Web 技術を通じて HTML + CSS + JavaScript のページを作成することができます。KernelSU のマネージャーは WebView を通じてこれらのページを表示します。また、シェルコマンドの実行など、システムと対話するためのいくつかのAPIを提供しています。

## `webroot` ディレクトリ

Web リソースファイルは、モジュールのルートディレクトリの `webroot` サブディレクトリに置かれるべきであり、`index.html` という名前のファイルが必ず存在しなければなりません。これがモジュールページのエントリです。Web インターフェイスを含む最もシンプルなモジュール構造は以下の通りです：

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

:::警告
モジュールをインストールするとき、KernelSU はこのディレクトリのパーミッションと SELinux コンテキストを自動的に設定します。何をしているかわからないのであれば、自分でこのディレクトリのパーミッションを設定しないでください！
:::

ページに css や JavaScript が含まれている場合は、このディレクトリに配置する必要があります。

## JavaScript API

単なる表示ページであれば、通常の Web ページとの違いはありません。より重要なのは、KernelSU がモジュールの固有機能を実装させるための一連のシステム API を提供することです。

KernelSU は JavaScript ライブラリを提供し、[npm で公開しています](https://www.npmjs.com/package/kernelsu)。これを Web ページの JavaScript コードで使用することができます。

たとえば、特定の設定を取得したり、プロパティを変更するために、シェルコマンドを実行することができます：

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

別の例として、Webページをフルスクリーンで表示したり、トーストを表示することができます。

[API ドキュメント](https://www.npmjs.com/package/kernelsu)

既存のAPIがご自身のニーズを満たしていない、または使い勝手が不便である場合、[こちら](https://github.com/tiann/KernelSU/issues)でご提案いただければ幸いです！

## いくつかのヒント

1. `localStorage` を通常通りに使用してデータを保存することができますが、Manager アプリをアンインストールした後には失われます。永続的に保存する必要がある場合は、自分でいくつかのディレクトリにデータを書き込むことができます。
2. シンプルなページには、[parceljs](https://parceljs.org/)を使用することをお勧めします。設定が不要で非常に便利です。しかし、フロントエンドの達人である場合や、自分の好みがある場合は、気に入ったものを選んでください！

```

`website/docs/ja_JP/guide/module.md`:

```md
# モジュールのガイド

KernelSU はシステムパーティションの整合性を維持しながら、システムディレクトリを変更する効果を実現するモジュール機構を提供します。この機構は一般に「システムレス」と呼ばれています。

KernelSU のモジュール機構は、Magisk とほぼ同じです。Magisk のモジュール開発に慣れている方であれば、KernelSU のモジュール開発も簡単でしょう。その場合は以下のモジュールの紹介は読み飛ばして、[Magisk との違い](difference-with-magisk.md)の内容だけ読めばOKです。

::: warning METAMODULE はシステムファイル変更時のみ必要
KernelSU は [metamodule](metamodule.md) アーキテクチャを使用して `system` ディレクトリをマウントします。**モジュールが `/system` ファイルを変更する必要がある場合のみ**（`system` ディレクトリ経由で）、metamodule ([meta-overlayfs](https://github.com/tiann/KernelSU/releases)など) をインストールする必要があります。スクリプト、sepolicy ルール、system.propなどの他のモジュール機能は metamodule なしで動作します。
:::

## WebUI

KernelSU modules support displaying interfaces and interacting with users. See the [WebUI documentation](module-webui.md) for more information.

## モジュール設定

KernelSU は、モジュールが永続的または一時的なキー値設定を保存できる組み込みの設定システムを提供します。詳細については、[モジュール設定ドキュメント](module-config.md)を参照してください。

## Busybox

KernelSU には、機能的に完全な Busybox バイナリ (SELinux の完全サポートを含む) が同梱されています。実行ファイルは `/data/adb/ksu/bin/busybox` に配置されています。KernelSU の Busybox はランタイムに切り替え可能な「ASH スタンドアローンシェルモード」をサポートしています。このスタンドアロンモードとは、Busybox の `ash` シェルで実行する場合 `PATH` として設定されているものに関係なく、すべてのコマンドが Busybox 内のアプレットを直接使用するというものです。たとえば、`ls`、`rm`、`chmod` などのコマンドは、`PATH` にあるもの（Android の場合、デフォルトではそれぞれ `/system/bin/ls`, `/system/bin/rm`, `/system/bin/chmod`）ではなく、直接 Busybox 内部のアプレットを呼び出すことになります。これにより、スクリプトは常に予測可能な環境で実行され、どの Android バージョンで実行されていても常にコマンドを利用できます。Busybox を使用しないコマンドを強制的に実行するには、フルパスで実行ファイルを呼び出す必要があります。

KernelSU のコンテキストで実行されるすべてのシェルスクリプトは、Busybox の `ash` シェルでスタンドアロンモードが有効な状態で実行されます。サードパーティの開発者に関係するものとしては、すべてのブートスクリプトとモジュールのインストールスクリプトが含まれます。

この「スタンドアロンモード」機能を KernelSU 以外で使用したい場合、2つの方法で有効にできます：

1. 環境変数 `ASH_STANDALONE` を `1` にする<br>例: `ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. コマンドラインのオプションで変更する:<br>`/data/adb/ksu/bin/busybox sh -o standalone <script>`

環境変数が子プロセスに継承されるため、その後に実行されるすべての `sh` シェルもスタンドアロンモードで実行されるようにするにはオプション 1 が望ましい方法です（KernelSU と KernelSU Managerが内部的に使用しているのもこちらです）。

::: tip Magisk との違い

KernelSU の Busybox は、Magisk プロジェクトから直接コンパイルされたバイナリファイルを使用するようになりました。Magisk と KernelSU の Busybox スクリプトはまったく同じものなので、互換性の問題を心配する必要はありません！
:::

## KernelSU モジュール

KernelSU モジュールは、`/data/adb/modules` に配置された以下の構造を持つフォルダーです：

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- フォルダの名前はモジュールの ID で付けます
│   │
│   │      *** モジュールの ID ***
│   │
│   ├── module.prop         <--- このファイルにモジュールのメタデータを保存します
│   │
│   │      *** メインコンテンツ ***
│   │
│   ├── system              <--- skip_mount が存在しない場合、このフォルダがマウントされます
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** ステータスフラグ ***
│   │
│   ├── skip_mount          <--- 存在する場合、KernelSU はシステムフォルダをマウントしません
│   ├── disable             <--- 存在する場合、モジュールは無効化されます
│   ├── remove              <--- 存在する場合、次の再起動時にモジュールが削除されます
│   │
│   │      *** 任意のファイル ***
│   │
│   ├── post-fs-data.sh     <--- このスクリプトは post-fs-data で実行されます
│   ├── service.sh          <--- このスクリプトは late_start サービスで実行されます
|   ├── uninstall.sh        <--- このスクリプトは KernelSU がモジュールを削除するときに実行されます
│   ├── system.prop         <--- このファイルのプロパティは resetprop によってシステムプロパティとして読み込まれます
│   ├── sepolicy.rule       <--- カスタム SEPolicy ルールを追加します
│   │
│   │      *** 自動生成されるため、手動で作成または変更しないでください ***
│   │
│   ├── vendor              <--- $MODID/system/vendor へのシンボリックリンク
│   ├── product             <--- $MODID/system/product へのシンボリックリンク
│   ├── system_ext          <--- $MODID/system/system_ext へのシンボリックリンク
│   │
│   │      *** その他のファイル/フォルダの追加も可能です ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip Magisk との違い
KernelSU は Zygisk をビルトインでサポートしていないため、モジュール内に Zygisk に関連するコンテンツは存在しません。 しかし、[ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) をインストールすれば Zygisk モジュールを使えます。その場合の Zygisk モジュールのコンテンツは Magisk と同じです。
:::

### module.prop

module.prop はモジュールの設定ファイルです。KernelSU ではこのファイルを含まないモジュールは、モジュールとして認識されません。このファイルの形式は以下の通りです：

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
actionIcon=<path> (optional)
webuiIcon=<path> (optional)
```

- `id` はこの正規表現に一致していなければいけません: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
  例: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
  これはモジュールの**ユニークな ID** です。公開後は変更しないでください。
- `versionCode` は **integer** です。バージョンの比較に使います。
- 他のものには**単一行** の文字であれば何でも使えます。
- 改行文字は `UNIX (LF)` を使ってください。`Windows (CR+LF)` や `Macintosh (CR)` は使ってはいけません。
- `actionIcon` と `webuiIcon` は、マネージャーアプリ内に表示される**モジュールアクションのショートカット**および**WebUI ショートカット**の既定アイコンとして使用される、任意指定の画像パスです。これらのパスは、モジュール ディレクトリを基準として指定する必要があります。例えば、`actionIcon=icon/icon.png` は `<MODDIR>/icon/icon.png` を指します。

::: tip 動的説明
`description` フィールドは、モジュール設定システムを使用して実行時に動的にオーバーライドできます。詳細は[モジュール説明のオーバーライド](module-config.md#overriding-module-description)を参照してください。
:::

### シェルスクリプト

`post-fs-data.sh` と `service.sh` の違いについては、[ブートスクリプト](#boot-scripts)のセクションを読んでください。ほとんどのモジュール開発者にとって、ブートスクリプトを実行するだけなら `service.sh` で十分なはずです。

モジュールのすべてのスクリプトでは、`MODDIR=${0%/*}`を使えばモジュールのベースディレクトリのパスを取得できます。スクリプト内でモジュールのパスをハードコードしないでください。

::: tip Magisk との違い
環境変数 `KSU` を使用すると、スクリプトが KernelSU と Magisk どちらで実行されているかを判断できます。KernelSU で実行されている場合、この値は `true` に設定されます。
:::

### `system` ディレクトリ

このディレクトリの内容は、システムの起動後に OverlayFS を使用してシステムの /system パーティションの上にオーバーレイされます：

1. システム内の対応するディレクトリにあるファイルと同名のファイルは、このディレクトリにあるファイルで上書きされます。
2. システム内の対応するディレクトリにあるフォルダと同じ名前のフォルダは、このディレクトリにあるフォルダと統合されます。

元のシステムディレクトリにあるファイルやフォルダを削除したい場合は、`mknod filename c 0 0` を使ってモジュールディレクトリにそのファイル/フォルダと同じ名前のファイルを作成する必要があります。こうすることで、OverlayFS システムはこのファイルを削除したかのように自動的に「ホワイトアウト」します（/system パーティションは実際には変更されません）。

また、`customize.sh` 内で `REMOVE` という変数に削除操作を実行するディレクトリのリストを宣言すると、KernelSU は自動的にそのモジュールの対応するディレクトリで `mknod <TARGET> c 0 0` を実行します。例えば

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

上記の場合は、`mknod $MODPATH/system/app/YouTuBe c 0 0`と`mknod $MODPATH/system/app/Bloatware c 0 0`を実行し、`/system/app/YouTube`と`/system/app/Bloatware`はモジュール有効化後に削除されます。

システム内のディレクトリを置き換えたい場合は、モジュールディレクトリに同じパスのディレクトリを作成し、このディレクトリに `setfattr -n trusted.overlay.opaque -v y <TARGET>` という属性を設定する必要があります。こうすることで、OverlayFS システムは（/system パーティションを変更することなく）システム内の対応するディレクトリを自動的に置き換えることができます。

`customize.sh` ファイル内に `REPLACE` という変数を宣言し、その中に置換するディレクトリのリストを入れておけば、KernelSU は自動的にモジュールディレクトリに対応した処理を行います。例えば：

REPLACE="
/system/app/YouTube
/system/app/Bloatware
"

このリストは、自動的に `$MODPATH/system/app/YouTube` と `$MODPATH/system/app/Bloatware` というディレクトリを作成し、 `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/YouTube` と `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/Bloatware` を実行します。モジュールが有効になると、`/system/app/YouTube` と `/system/app/Bloatware` は空のディレクトリに置き換えられます。

::: tip Magisk との違い

KernelSU のシステムレスメカニズムはカーネルの OverlayFS によって実装され、Magisk は現在マジックマウント（bind mount）を使用しています。この2つの実装方法には大きな違いがありますが最終的な目的は同じで、/system パーティションを物理的に変更することなく、/system のファイルを変更できます。
:::

OverlayFS に興味があれば、Linux カーネルの [OverlayFS のドキュメンテーション](https://docs.kernel.org/filesystems/overlayfs.html) を読んでみてください。

### system.prop

このファイルは `build.prop` と同じ形式をとっています。各行は `[key]=[value]` で構成されます。

### sepolicy.rule

もしあなたのモジュールが追加の SEPolicy パッチを必要とする場合は、それらのルールをこのファイルに追加してください。このファイルの各行は、ポリシーステートメントとして扱われます。

## モジュールのインストーラー

KernelSU モジュールインストーラーは、KernelSU Manager アプリでインストールできる、ZIP ファイルにパッケージされた KernelSU モジュールです。最もシンプルな KernelSU モジュールインストーラーは、KernelSU モジュールを ZIP ファイルとしてパックしただけのものです。

```txt
module.zip
│
├── customize.sh                       <--- (任意、詳細は後述)
│                                           このスクリプトは update-binary から読み込まれます
├── ...
├── ...  /* 残りのモジュールのファイル */
│
```

::: warning 警告
KernelSU モジュールは、カスタムリカバリーからのインストールには非対応です！
:::

### カスタマイズ

モジュールのインストールプロセスをカスタマイズする必要がある場合、`customize.sh` という名前のスクリプトを作成してください。このスクリプトは、すべてのファイルが抽出され、デフォルトのパーミッションと secontext が適用された後、モジュールインストーラースクリプトによって読み込み (実行ではなく) されます。これは、モジュールがデバイスの ABI に基づいて追加設定を必要とする場合や、モジュールファイルの一部に特別なパーミッション/コンテキストを設定する必要がある場合に、非常に便利です。

インストールプロセスを完全に制御しカスタマイズしたい場合は、`customize.sh` で `SKIPUNZIP=1` と宣言すればデフォルトのインストールステップをすべてスキップできます。そうすることで、`customize.sh` が責任をもってすべてをインストールするようになります。

`customize.sh`スクリプトは、KernelSU の Busybox `ash` シェルで、「スタンドアロンモード」を有効にして実行します。以下の変数と関数が利用可能です：

#### 変数

- `KSU` (bool): スクリプトが KernelSU 環境で実行されていることを示すための変数で、この変数の値は常に true になります。KernelSU と Magisk を区別するために使用できます。
- `KSU_VER` (string): 現在インストールされている KernelSU のバージョン文字列 (例: `v0.4.0`)
- `KSU_VER_CODE` (int): ユーザー空間に現在インストールされているKernelSUのバージョンコード (例: `10672`)
- `KSU_KERNEL_VER_CODE` (int): 現在インストールされている KernelSU のカーネル空間でのバージョンコード（例：`10672`）
- `BOOTMODE` (bool): KernelSU では常に `true` 
- `MODPATH` (path): モジュールファイルがインストールされるパス
- `TMPDIR` (path): ファイルを一時的に保存しておく場所
- `ZIPFILE` (path): あなたのモジュールのインストールZIP
- `ARCH` (string): デバイスの CPU アーキテクチャ。値は `arm`、`arm64`、`x86`、`x64` のいずれか
- `IS64BIT` (bool): `ARCH` が `arm64` または `x64` のときは `true` 
- `API` (int): 端末の API レベル・Android のバージョン（例：Android 6.0 なら`23`）

::: warning 警告
KernelSU では、MAGISK_VER_CODE は常に25200、MAGISK_VER は常にv25.2です。この2つの変数で KernelSU 上で動作しているかどうかを判断するのはやめてください。
:::

#### 機能

```txt
ui_print <msg>
    コンソールに <msg> を表示します
    カスタムリカバリーのコンソールでは表示されないため、「echo」の使用は避けてください

abort <msg>
    エラーメッセージ<msg>をコンソールに出力し、インストールを終了させます
    終了時のクリーンアップがスキップされてしまうため、「exit」の使用は避けてください

set_perm <target> <owner> <group> <permission> [context]
    [context] が設定されていない場合、デフォルトは "u:object_r:system_file:s0" です。
    この機能は、次のコマンドの略記です：
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    [context] が設定されていない場合、デフォルトは "u:object_r:system_file:s0" です。
    <directory> 内のすべてのファイルに対しては以下が実行されます:
       set_perm file owner group filepermission context
    <directory> 内のすべてのディレクトリ（自身を含む）に対しては以下が実行されます:
       set_perm dir owner group dirpermission context
```

## ブートスクリプト

KernelSU では、スクリプトは実行モードによって post-fs-data モードと late_start サービスモードの2種類に分けられます：

- post-fs-data モード
  - 同期処理です。実行が終わるか、10秒が経過するまでブートプロセスが一時停止されます。
  - スクリプトはモジュールがマウントされる前に実行されます。モジュール開発者はモジュールがマウントされる前に、動的にモジュールを調整できます。
  - このステージは Zygote が始まる前に起こるので、Android のほぼすべての処理の前に割り込めます
  - **警告:** `setprop` を使うとブートプロセスのデッドロックを引き起こします! `resetprop -n <prop_name> <prop_value>` を使ってください。
  - **本当に必要な場合だけこのモードでコマンド実行してください**
- late_start サービスモード
  - 非同期処理です。スクリプトは、起動プロセスの残りの部分と並行して実行されます。
  - **ほとんどのスクリプトにはこちらがおすすめです**

KernelSU では、起動スクリプトは保存場所によって一般スクリプトとモジュールスクリプトの2種類に分けられます：

- 一般スクリプト
  - `/data/adb/post-fs-data.d` か `/data/adb/service.d` に配置されます
  - スクリプトが実行可能な状態に設定されている場合にのみ実行されます (`chmod +x script.sh`)
  - `post-fs-data.d` のスクリプトは post-fs-data モードで実行され、`service.d` のスクリプトは late_start サービスモードで実行されます
  - モジュールはインストール時に一般スクリプトを追加するべきではありません
- モジュールスクリプト
  - モジュール独自のフォルダに配置されます
  - モジュールが有効な場合のみ実行されます
  - `post-fs-data.sh` は post-fs-data モードで実行され、`service.sh` は late_start サービスモードで実行されます

すべてのブートスクリプトは、KernelSU の Busybox `ash` シェルで「スタンドアロンモード」を有効にした状態で実行されます。

```

`website/docs/ja_JP/guide/rescue-from-bootloop.md`:

```md
# ブートループからの復旧

デバイスに書き込む際、デバイスが「文鎮化」状態になる場面に遭遇することがあります。理論的には、fastboot で boot パーティションを書き込んだだけだったり、不適切なモジュールをインストールしてデバイスが起動しなくなったりした場合なら、適切な操作で復旧できます。このページでは、「文鎮化」状態になったデバイスを復旧させるための緊急手段を紹介します。

## boot パーティションの書き込みによる文鎮化

KernelSU では、以下のような状況で boot パーティションを書き込んだときに文鎮化する場合があります：

1. 間違った形式の boot イメージを書き込んでしまった場合。例えばお使いのデバイスのパーティション形式が `gz` なのに `lz4` 形式のイメージを書き込んでしまうと、起動しなくなります。
2. お使いのデバイスが起動するために AVB 検証を無効にする必要がある場合（通常、無効にするにはすべてのデータを消去する必要があります）。
3. カーネルにバグがある、または書き込みに適していない場合。

どのような状況であっても、**純正の boot イメージを書き込む**ことで復旧できます。したがって、インストールする前にまずは純正の boot パーティションをバックアップすることを強くおすすめします。バックアップしていない場合は、あなたと同じデバイスを持つ他のユーザー、または公式ファームウェアから純正の boot イメージを入手できます。

## モジュールによる文鎮化

モジュールのインストールはデバイスを文鎮化させる一般的な原因です。**モジュールを未知のソースからインストールしないでください**！モジュールは root 権限を持つため、あなたのデバイスに不可逆的なダメージを与える可能性があります！

### 通常のモジュール

安全であることが確認されているモジュールをインストールしてデバイスが起動しなくなった場合、KernelSU では心配することなく簡単に復旧できます。KernelSU には、以下のようなデバイスを救出するための仕組みが組み込まれています：

1. AB アップデート
2. 音量下ボタンでの復旧

#### AB アップデート

KernelSU のモジュール更新は、OTA アップデートで使用される Android システムの AB アップデート機構からヒントを得ています。新しいモジュールをインストールしたり、既存のモジュールを更新したりする場合、現在使用されているモジュールファイルを直接変更することはありません。代わりに、すべてのモジュールが別のアップデートイメージに組み込まれます。システムが再起動された後、このアップデートイメージの使用を開始しようとします。Android システムが正常に起動した場合、モジュールは本当に更新されます。

そのため、デバイスを復旧する最もシンプルで一般的な方法は、**強制的に再起動すること**です。モジュールをインストールした後にシステムを起動できなくなった場合、電源ボタンを10秒以上長押しするとシステムが自動的に再起動します。再起動後はモジュールを更新する前の状態にロールバックされ、以前に更新したモジュールは自動的に無効化されます。

#### 音量下ボタンでの復旧

AB アップデートでも解決しない場合は、**セーフモード**を使用してみてください。セーフモードでは、すべてのモジュールが無効化されます。

セーフモードに入るには、2つの方法があります：

1. 一部のシステムの内蔵セーフモード：音量下ボタンの長押しでセーフモードに入れるシステムもあれば、リカバリーでセーフモードに入れるシステム（MIUI など）もあります。システムのセーフモードに入ると KernelSU もセーフモードに入り、自動的にモジュールを無効化します。
2. KernelSU の内蔵セーフモード：最初の起動画面の後、**音量下キーを3回以上連続して押す**と入れます。なお、押す→離すを三回繰り返すのであって、長押しではありません。

セーフモードに入ると、KernelSU Manager のモジュールページにあるすべてのモジュールが無効になります。「アンインストール」操作を行うことで、問題を起こしている可能性のあるモジュールをアンインストールできます。

内蔵のセーフモードはカーネルに実装されているため、キーイベントを見逃す可能性はありません。ただし、GKI 以外のカーネルでは手動によるコードの統合が必要な場合があるため、公式ドキュメントを参考にしてください。

### 悪意のあるモジュール

上記の方法でデバイスを救出できない場合、インストールしたモジュールが悪意のある操作をしているか、他の手段でデバイスを損傷している可能性が高いです。この場合、2つの方法しかありません：

1. データを消去して純正システムをインストールし直す
2. アフターセールスサービスに問い合わせする

```

`website/docs/ja_JP/guide/unofficially-support-devices.md`:

```md
# 非公式の対応デバイス

::: warning 警告
このドキュメントはアーカイブ参照のみを目的としており、更新されなくなりました。
KernelSU v1.0以降、非GKIデバイスの公式サポートを終了しました。
:::

::: warning 警告
このページでは他の開発者が管理している、KernelSU をサポートする GKI 以外のデバイス用のカーネルを紹介しています。
:::

::: warning 警告
このページはあなたのデバイスに対応するソースコードを見つけるためのものであり、そのソースコードが _KernelSU 開発者_ によってレビューされたことを意味するものではありません。ご自身の責任においてご利用ください。
:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>メンテナー</th>
         <th>リポジトリ</th>
         <th>対応デバイス</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>
```

`website/docs/ja_JP/guide/what-is-kernelsu.md`:

```md
# KernelSU とは?

KernelSU は Android GKI デバイスのための root ソリューションです。カーネルモードで動作し、カーネル空間で直接ユーザー空間アプリに root 権限を付与します。

## 機能

KernelSU の最大の特徴は、**カーネルベース**であることです。KernelSU はカーネルモードで動作するため、今までにないカーネルインターフェイスを提供できます。例えば、カーネルモードで任意のプロセスにハードウェアブレークポイントを追加できる、誰にも気づかれずに任意のプロセスの物理メモリにアクセスできる、カーネル空間で任意のシステムコールを傍受できる、などです。

さらに、KernelSU は [metamodule システム](metamodule.md) を提供しています。これはモジュール管理のためのプラグ可能なアーキテクチャです。従来の root ソリューションがマウントロジックをコアに組み込むのとは異なり、KernelSU はこの作業を metamodule に委任します。これにより、metamodule ([meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs)など) をインストールして、`/system`パーティションや他のパーティションへのsystemless変更を提供できます。

## 使用方法

こちらをご覧ください: [インストール方法](installation)

## ビルド方法

[ビルドするには](../../guide/how-to-build)

## ディスカッション

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/ja_JP/index.md`:

```md
---
layout: home
title: Android 向けのカーネルベース root ソリューション

hero:
  name: KernelSU
  text: Android 向けのカーネルベース root ソリューション
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: はじめる
      link: /ja_JP/guide/what-is-kernelsu
    - theme: alt
      text: GitHub で表示
      link: https://github.com/tiann/KernelSU

features:
  - title: カーネルベース
    details: KernelSU は Linux カーネルモードで動作し、ユーザー空間よりも高度な制御が可能です。
  - title: ホワイトリストの権限管理
    details: root 権限を許可したアプリのみが su にアクセスでき、他のアプリは su を見つけられません。
  - title: Metamodule システム
    details: プラグ可能なモジュールインフラストラクチャにより、systemless方式で/systemを変更可能。metamodule(meta-overlayfsなど)をインストールすることでモジュールのマウント機能を有効化。
  - title: オープンソース
    details: KernelSU は GPL-3 でライセンスされたオープンソースプロジェクトです。


```

`website/docs/pt_BR/guide/app-profile.md`:

```md
# Perfil do Aplicativo

O Perfil do Aplicativo é um mecanismo fornecido pelo KernelSU para personalizar a configuração de vários apps.

Para apps com privilégios root (ou seja, capazes de usar `su`), o Perfil do Aplicativo também pode ser chamado de Perfil root. Ele permite a customização das regras `uid`, `gid`, `grupos`, `capacidades` e `SELinux` do comando `su`, restringindo assim os privilégios do usuário root. Por exemplo, ele pode conceder permissões de rede apenas para apps de firewall enquanto nega permissões de acesso a arquivos, ou pode conceder permissões de shell em vez de acesso root completo para apps congelados: **mantendo o poder confinado com o princípio do menor privilégio.**

Para apps comuns sem privilégios root, o Perfil do Aplicativo pode controlar o comportamento do kernel e do sistema de módulos em relação a esses apps. Por exemplo, pode determinar se as modificações resultantes dos módulos devem ser abordadas. O kernel e o sistema de módulos podem tomar decisões com base nesta configuração, como realizar operações semelhantes a "ocultar".

## Perfil root

### UID, GID e Grupos

Os sistemas Linux possuem dois conceitos: usuários e grupos. Cada usuário possui um ID de usuário (UID) e pode pertencer a vários grupos, cada um com seu próprio ID de grupo (GID). Esses IDs são usados ​​para identificar usuários no sistema e determinar quais recursos do sistema eles podem acessar.

Os usuários com UID 0 são conhecidos como usuários root, e grupos com GID 0 são chamados de grupos root. O grupo de usuários root geralmente tem os privilégios mais altos no sistema.

No caso do sistema Android, cada app funciona como um usuário separado (exceto em casos de UID compartilhado) e recebe um UID exclusivo. Por exemplo, `0` representa o usuário root, `1000` representa `system`, `2000` ao ADB shell e os UIDs de `10000` a `19999` são atribuídos a apps comuns.

::: info INFORMAÇÕES
Aqui, o UID mencionado não é o mesmo que o conceito de múltiplos usuários ou perfis de trabalho no sistema Android. Os perfis de trabalho são, na verdade, implementados particionando o intervalo UID. Por exemplo, 10000-19999 representa o usuário principal, enquanto 110000-119999 representa um perfil de trabalho. Cada app comum entre eles possui seu próprio UID exclusivo.
:::

Cada app pode ter vários grupos, com o GID representando o grupo principal, que geralmente corresponde ao UID. Outros grupos são conhecidos como grupos suplementares. Certas permissões são controladas por meio de grupos, como permissões de acesso à rede ou acesso Bluetooth.

Por exemplo, se executarmos o comando `id` no ADB shell, a saída pode ser semelhante a esta:

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

Aqui, o UID é `2000` e o GID (ID do grupo primário) também é `2000`. Além disso, pertence a vários grupos suplementares, como `inet` (indicando a capacidade de criar soquetes `AF_INET` e `AF_INET6`) e `sdcard_rw` (indicando permissões de leitura/gravação para o cartão SD).

O Perfil root do KernelSU permite personalizar o UID, GID e grupos para o processo root após a execução de `su`. Por exemplo, o Perfil root de um app root pode definir seu UID como `2000`, o que significa que, ao usar `su`, as permissões reais do app estão no nível do ADB shell. Além disso, o grupo `inet` pode ser removido, evitando que o comando `su` tenha acesso à rede.

::: tip OBSERVAÇÃO
O Perfil do Aplicativo controla apenas as permissões do processo root após usar `su` e não afeta as permissões do próprio app. Se um app solicitou permissão para acessar a rede, ele ainda poderá acessar a rede mesmo sem usar `su`. Remover o grupo `inet` de `su` apenas impede que `su` acesse a rede.
:::

O Perfil root é aplicado no kernel e não depende do comportamento voluntário de apps root, ao contrário da troca de usuários ou grupos por meio de `su`. A concessão da permissão `su` depende inteiramente do usuário e não do desenvolvedor.

### Capacidades

As capacidades são um mecanismo para separação de privilégios no Linux.

Para realizar verificações de permissão, as implementações tradicionais do `UNIX` distinguem duas categorias de processos: processos privilegiados (cujo ID de usuário efetivo é `0`, referido como superusuário ou root) e processos sem privilégios (cujo UID efetivo é diferente de zero). Os processos privilegiados ignoram todas as verificações de permissão do kernel, enquanto os processos não privilegiados estão sujeitos à verificação completa de permissão com base nas credenciais do processo (geralmente: UID efetivo, GID efetivo e lista de grupos suplementares).

A partir do Linux 2.2, o Linux divide os privilégios tradicionalmente associados ao superusuário em unidades distintas, conhecidas como capacidades, que podem ser ativadas e desativadas de forma independente.

Cada capacidade representa um ou mais privilégios. Por exemplo, `CAP_DAC_READ_SEARCH` representa a capacidade de ignorar verificações de permissão para leitura de arquivos, bem como permissões de leitura e execução de diretório. Se um usuário com um UID efetivo `0` (usuário root) não tiver a capacidade `CAP_DAC_READ_SEARCH` ou superiores, isso significa que mesmo sendo root, ele não pode ler arquivos à vontade.

O Perfil root do KernelSU permite a personalização das capacidades do processo root após a execução de `su`, concedendo assim "privilégios root" de forma parcial. Ao contrário do UID e GID mencionados acima, certos apps root exigem um UID de `0` após usar `su`. Nesses casos, limitar as capacidades deste usuário root com UID `0` pode restringir as operações que ele pode realizar.

::: tip FORTE RECOMENDAÇÃO
A [documentação oficial](https://man7.org/linux/man-pages/man7/capabilities.7.html) da capacidade do Linux fornece explicações detalhadas das habilidades representadas por cada capacidade. Se você pretende customizar as capacidade, é altamente recomendável que você leia este documento primeiro.
:::

### SELinux

SELinux é um poderoso mecanismo do Controle de Acesso Obrigatório (MAC). Ele opera com base no princípio de **negação padrão**. Qualquer ação não explicitamente permitida é negada.

O SELinux pode ser executado em dois modos globais:

1. Modo permissivo (Permissive): Os eventos de negação são registrados, mas não aplicados.
2. Modo impondo (Enforcing): Os eventos de negação são registrados e aplicados.

::: warning AVISO
Os sistemas Android modernos dependem fortemente do SELinux para garantir a segurança geral do sistema. É altamente recomendável não usar nenhum sistema personalizado executado em "Modo permissivo", pois ele não oferece vantagens significativas em relação a um sistema completamente aberto.
:::

Explicar o conceito completo do SELinux é complexo e está além do objetivo deste documento. Recomenda-se primeiro entender seu funcionamento através dos seguintes recursos:

1. [Wikipédia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Red Hat: O que é SELinux?](https://www.redhat.com/pt-br/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

O Perfil root do KernelSU permite a personalização do contexto SELinux do processo root após a execução de `su`. Regras específicas de controle de acesso podem ser definidas para este contexto, possibilitando um controle refinado sobre os privilégios root.

Em cenários típicos, quando um app executa `su`, ele alterna o processo para um domínio SELinux com **acesso irrestrito**, como `u:r:su:s0`. Através do Perfil root, esse domínio pode ser mudado para um domínio personalizado, como `u:r:app1:s0`, e uma série de regras podem ser definidas para esse domínio:

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

Observe que a regra `allow app1 * * *` é usada apenas para fins de demonstração. Na prática, esta regra não deve ser usada extensivamente, pois não difere muito do Modo permissivo.

### Escalação

Se a configuração do Perfil root não estiver definida corretamente, poderá ocorrer um cenário de escalação. As restrições impostas pelo Perfil root poderão falhar involuntariamente.

Por exemplo, se você conceder permissão root a um usuário ADB shell (que é um caso comum) e, em seguida, conceder permissão root a um app normal, mas configurar seu Perfil root com o UID 2000 (o UID do usuário ADB shell), o app pode obter acesso root completo ao executar o comando `su` duas vezes:

1. A primeira execução de `su` será sujeita ao Perfil do Aplicativo, e mudará para o UID `2000` (ADB shell) em vez de `0` (root).
2. A segunda execução de `su`, como o UID é `2000` e você concedeu acesso root ao UID `2000` (ADB shell) na configuração, o app obterá privilégios root completo.

::: warning OBSERVAÇÃO
Este comportamento é totalmente esperado e não é um bug. Portanto, recomendamos o seguinte:

Se você realmente precisa conceder privilégios root ao ADB (por exemplo, como desenvolvedor), não é aconselhável alterar o UID para `2000` ao configurar o Perfil root. Usar `1000` (sistema) seria uma melhor escolha.
:::

## Perfil não root

### Desmontar módulos

O KernelSU fornece um mecanismo sem sistema para modificar partições do sistema, obtido através da montagem do OverlayFS. No entanto, alguns apps podem ser sensíveis a esse comportamento. Nesse caso, podemos descarregar módulos montados nesses apps configurando a opção "Desmontar módulos".

Além disso, a interface de configurações do gerenciador do KernelSU oferece a opção "Desmontar módulos por padrão". Por padrão, essa opção está **ativada**, o que significa que o KernelSU ou alguns módulos descarregarão módulos para este app, a menos que configurações adicionais sejam aplicadas. Se você não preferir esta configuração ou se ela afetar determinados apps, você terá as seguintes opções:

1. Manter a opção "Desmontar módulos por padrão" ativada e desative individualmente a opção "Desmontar módulos" no Perfil do Aplicativo para apps que exigem o carregamento do módulo (agindo como uma "lista de permissões").
2. Desativar a opção "Desmontar módulos por padrão" e ativar individualmente a opção "Desmontar módulos" no Perfil do Aplicativo para apps que exigem o descarregamento do módulo (agindo como uma "lista negra").

::: info INFORMAÇÕES
Em dispositivos que utilizam a versão do kernel 5.10 ou superior, o kernel realiza qualquer ação adicional do descarregamento de módulos. No entanto, para dispositivos que executam versões do kernel abaixo de 5.10, essa opção é apenas uma opção de configuração e o próprio KernelSU não executa nenhuma ação. Se você quiser usar a opção "Desmontar módulos" em versões do kernel anteriores a 5.10, é necessário portar a função `path_umount` em `fs/namespace.c`. Você pode obter mais informações no final da página [Integração para dispositivos não-GKI](https://kernelsu.org/pt_BR/guide/how-to-integrate-for-non-gki.html). Alguns módulos, como ZygiskNext, também podem usar essa opção para determinar se o descarregamento do módulo é necessário.
:::

```

`website/docs/pt_BR/guide/difference-with-magisk.md`:

```md
# Diferenças com Magisk

Embora os módulos do KernelSU e do Magisk tenham muitas semelhanças, existem inevitavelmente algumas diferenças devido aos seus mecanismos de implementação completamente diferentes. Se você deseja que seu módulo funcione tanto no Magisk quanto no KernelSU, é essencial compreender essas diferenças.

## Semelhanças

- Formato de arquivo do módulo: Ambos usam o formato ZIP para organizar os módulos, e o formato dos módulos é praticamente o mesmo.
- Diretório de instalação do módulo: Ambos estão localizados em `/data/adb/modules`.
- Sem sistema: Ambos suportam a modificação de `/system` de forma sem sistema por meio de módulos.
- post-fs-data.sh: O tempo de execução e a semântica são exatamente os mesmos.
- service.sh: O tempo de execução e a semântica são exatamente os mesmos.
- system.prop: Completamente o mesmo.
- sepolicy.rule: Completamente o mesmo.
- BusyBox: Os scripts são executados no BusyBox com o "Modo Autônomo" ativado em ambos os casos.

## Diferenças

Antes de entender as diferenças, é importante saber como identificar se o seu módulo está sendo executado no KernelSU ou no Magisk. Você pode usar a variável de ambiente `KSU` para diferenciá-lo em todos os locais onde você pode executar os scripts do módulo (`customize.sh`, `post-fs-data.sh`, `service.sh`). No KernelSU, essa variável de ambiente será definida como `true`.

Aqui estão algumas diferenças:

- Os módulos KernelSU não podem ser instalados no modo Recovery.
- Os módulos KernelSU não oferece suporte nativo ao Zygisk, mas você pode usar módulos Zygisk através do [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).
- **Arquitetura de montagem de módulos**: KernelSU usa um [sistema metamodule](metamodule.md), delegando a montagem a metamodules plugáveis (por exemplo, `meta-overlayfs`), enquanto o Magisk tem a montagem integrada em seu núcleo. KernelSU requer instalar um metamodule para habilitar a montagem de módulos.
- O método para substituir ou excluir arquivos nos módulos do KernelSU é completamente diferente do Magisk. O KernelSU não suporta o método `.replace`. Em vez disso, você deve criar um arquivo com o comando `mknod filename c 0 0` para excluir o arquivo correspondente.
- Os diretórios do BusyBox são diferentes. O BusyBox integrado no KernelSU está localizado em `/data/adb/ksu/bin/busybox`, enquanto no Magisk está em `/data/adb/magisk/busybox`. **Observe que este é um comportamento interno do KernelSU e pode mudar no futuro!**
- O KernelSU não suporta arquivos `.replace`, mas oferece suporte às variáveis ​​`REMOVE` e `REPLACE` para remover ou substituir arquivos e pastas.
- O KernelSU adiciona um script `boot-completed.sh` para executar tarefas após a conclusão da inicialização do sistema Android.
- O KernelSU adiciona um script `post-mount.sh` para executar tarefas após a conclusão da montagem do módulo.

```

`website/docs/pt_BR/guide/faq.md`:

```md
# Perguntas frequentes

## KernelSU oferece suporte ao meu dispositivo?

O KernelSU suporta dispositivos rodando Android com bootloader desbloqueado. No entanto, o suporte oficial é apenas para kernels Linux GKI 5.10+ (na prática isso significa que seu dispositivo precisa ter Android 12 de fábrica para ser compatível).

Você pode verificar facilmente o suporte para o seu dispositivo através do gerenciador do KernelSU, que está disponível [aqui](https://github.com/tiann/KernelSU/releases). 

Se o app mostrar `Não instalado`, significa que seu dispositivo é oficialmente suportado pelo KernelSU.

Se o app mostrar `Sem suporte`, significa que seu dispositivo não é oficialmente suportado no momento. No entanto, você pode compilar o código-fonte do kernel e integrar o KernelSU para fazê-lo funcionar, ou usar [Dispositivos com suporte não oficial](unofficially-support-devices).

## Para usar o KernelSU precisa desbloquear o bootloader?

Certamente, sim.

## KernelSU suporta módulos?

Sim, a maioria dos módulos Magisk funcionam no KernelSU. No entanto, se seu módulo precisar modificar arquivos `/system`, você precisa instalar um [metamodule](metamodule.md) (como `meta-overlayfs`). Outros recursos de módulos funcionam sem um metamodule. Confira o [Guia de módulos](module.md) para mais informações.

## KernelSU suporta Xposed?

Sim, você pode usar LSPosed (ou outro derivado moderno do Xposed) com [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).

## KernelSU suporta Zygisk?

KernelSU não tem suporte integrado ao Zygisk, mas você pode usar um módulo como [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) para suportá-lo.

## Por que meus módulos não funcionam após uma instalação nova?

Se seus módulos precisam modificar arquivos `/system`, você precisa instalar um [metamodule](metamodule.md) para montar o diretório `system`. Outros recursos de módulos (scripts, sepolicy, system.prop) funcionam sem um metamodule.

**Solução**: Consulte o [Guia de Metamodule](metamodule.md) para instruções de instalação.

## O que é um metamodule e por que preciso dele?

Um metamodule é um módulo especial que fornece infraestrutura para montar módulos regulares. Consulte o [Guia de Metamodule](metamodule.md) para uma explicação completa.

## KernelSU é compatível com o Magisk?

O sistema de módulos do KernelSU está em conflito com a montagem mágica do Magisk. Se houver algum módulo ativado no KernelSU, todo o Magisk deixará de funcionar.

No entanto, se você usar apenas o `su` do KernelSU, ele funcionará bem com o Magisk. O KernelSU modifica o `kernel`, enquanto o Magisk modifica o `ramdisk`, permitindo que ambos trabalhem juntos.

## KernelSU substituirá o Magisk?

Acreditamos que não, e esse não é o nosso objetivo. O Magisk é bom o suficiente para solução root do espaço do usuário e terá uma longa vida. O objetivo do KernelSU é fornecer uma interface de kernel aos usuários, não substituindo o Magisk.

## KernelSU oferece suporte a dispositivos não-GKI?

É possível. Mas você deve baixar o código-fonte do kernel e integrar o KernelSU à árvore do código-fonte e compilar o kernel você mesmo.

## KernelSU oferece suporte a dispositivos abaixo do Android 12?

É o kernel do dispositivo que afeta a compatibilidade do KernelSU e não tem nada a ver com a versão do Android. A única restrição é que os dispositivos lançados com Android 12 devem ser kernel 5.10+ (dispositivos GKI). Então:

1. Os dispositivos lançados com Android 12 devem ser compatíveis.
2. Dispositivos com kernel antigo (alguns dispositivos com Android 12 também têm o kernel antigo) são compatíveis (você mesmo deve compilar o kernel).

## KernelSU suporta kernel antigo?

É possível, o KernelSU é portado para o kernel 4.14 agora. Para kernels mais antigo, você precisa portar manualmente e PRs são sempre bem-vindas!

## Como integrar o KernelSU para um kernel antigo?

Por favor, verifique o guia [Integração para dispositivos não-GKI](how-to-integrate-for-non-gki).

## Por que a minha versão do Android é 13 e o kernel mostra "android12-5.10"?

A versão do Kernel não tem nada a ver com a versão do Android. Se você precisar fazer o flash do kernel, use sempre a versão do kernel, a versão do Android não é tão importante.

## Eu sou GKI 1.0, posso usar isso?

GKI 1.0 é completamente diferente do GKI 2.0, você deve compilar o kernel sozinho.

## Como posso fazer `/system` RW?

Não recomendamos que você modifique a partição do sistema diretamente. Por favor, verifique [Guias de módulo](module.md) para modificá-lo sem sistema. Se você insiste em fazer isso, verifique [magisk_overlayfs](https://github.com/HuskyDG/magic_overlayfs).

## KernelSU pode modificar hosts? Como posso usar AdAway?

Claro. Mas o KernelSU não tem suporte a hosts integrados, você pode instalar um módulo como [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module) para fazer isso.

```

`website/docs/pt_BR/guide/hidden-features.md`:

```md
# Recursos ocultos

## .ksurc

Por padrão, `/system/bin/sh` carrega `/system/etc/mkshrc`.

Você pode fazer su carregar um arquivo rc personalizado criando um arquivo `/data/adb/ksu/.ksurc`.

```

`website/docs/pt_BR/guide/how-to-build.md`:

```md
# Como compilar

::: warning
Este documento é apenas para referência de arquivo e não é mais mantido.
Desde o KernelSU v3.0, abandonamos o suporte oficial para o modo de imagem GKI para iteração e velocidade de compilação mais rápidas. É recomendado usar `Ylarod/ddk` para compilar o LKM.
:::

Primeiro, você deve ler a documentação oficial do Android para compilação do kernel:

1. [Como criar kernels](https://source.android.com/docs/setup/build/building-kernels)
2. [Builds de versão de imagem genérica do kernel (GKI)](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

::: warning AVISO
Esta página é para dispositivos GKI, se você usa um kernel antigo, consulte [Integração para dispositivos não-GKI](how-to-integrate-for-non-gki).
:::

## Compilar o kernel

### Sincronize o código-fonte do kernel

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

O arquivo `<kernel_manifest.xml>` é um manifesto que pode determinar exclusivamente uma compilação, permitindo que você a torne reprodutível. Para isso, você deve baixar o arquivo de manifesto em [Builds de versão de imagem genérica do kernel (GKI)](https://source.android.com/docs/core/architecture/kernel/gki-release-builds).

### Construir

Por favor, verifique [Como criar kernels](https://source.android.com/docs/setup/build/building-kernels) primeiro.

Por exemplo, para compilar uma imagem de kernel `aarch64`:

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

Não se esqueça de adicionar o sinalizador `LTO=thin`, caso contrário a compilação poderá falhar se a memória do seu computador for inferior a 24 GB.

A partir do Android 13, o kernel é compilado pelo `bazel`:

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

::: info INFORMAÇÕES
Para alguns kernel do Android 14, para fazer o Wi-Fi/Bluetooth funcionar, pode ser necessário remover todas as exportações protegidas pelo GKI:

```sh
rm common/android/abi_gki_protected_exports_*
```
:::

## Compilar o kernel com KernelSU

Se você conseguir compilar o kernel com sucesso, adicionar suporte ao KernelSU será relativamente simples. Na raiz do diretório de origem do kernel, execute qualquer uma das opções listadas abaixo:

::: code-group

```sh[Tag mais recente (estável)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

```sh[Branch main (dev)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

```sh[Selecionar tag (como v0.5.2)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

:::

Então, reconstrua o kernel e você obterá uma imagem do kernel com o KernelSU!

```

`website/docs/pt_BR/guide/how-to-integrate-for-non-gki.md`:

```md
# Integração para dispositivos não-GKI

::: warning
Este documento é apenas para referência de arquivo e não é mais mantido.
Desde o KernelSU v1.0, abandonamos o suporte oficial para dispositivos não-GKI.
:::

O KernelSU pode ser integrado a kernels não-GKI e foi portado para 4.14 e versões anteriores.

Devido à fragmentação dos kernels não-GKI, não temos um método universal para construí-lo, portanto, não podemos fornecer o boot.img não-GKI. No entanto, você pode compilar o kernel com o KernelSU integrado por conta própria.

Primeiro, você deve ser capaz de compilar um kernel inicializável a partir do código-fonte do kernel. Se o kernel não for de código aberto, será difícil executar o KernelSU para o seu dispositivo.

Se você puder compilar um kernel inicializável, existem duas maneiras de integrar o KernelSU ao código-fonte do kernel:

1. Automaticamente com `kprobe`
2. Manualmente

## Integrar com kprobe

O KernelSU usa kprobe para fazer ganchos do kernel, se o kprobe funcionar bem em seu kernel, é recomendado usar desta forma.

Primeiro, adicione o KernelSU à árvore de origem do kernel:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

::: info INFORMAÇÕES
[KernelSU 1.0 e versões posteriores não suportam mais kernels não-GKI](https://github.com/tiann/KernelSU/issues/1705). A última versão suportada é a `v0.9.5`, portanto, certifique-se de usar a versão correta.
:::

Então, você deve verificar se o kprobe está ativado na configuração do seu kernel. Caso não esteja, adicione estas configurações a ele:

```txt
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

Agora, ao recompilar seu kernel, o KernelSU deve funcionar corretamente.

Se você descobrir que o KPROBES ainda não está ativado, pode tentar ativar `CONFIG_MODULES`. Se isso não resolver, use `make menuconfig` para procurar outras dependências do KPROBES.

Porém, se você entrar em um bootloop após integrar o KernelSU, isso pode indicar que o **kprobe está quebrado no seu kernel**, o que significa que você precisará corrigir o bug do kprobe ou usar outra maneira.

::: tip COMO VERIFICAR SE O KPROBE ESTÁ QUEBRADO?
Comente `ksu_sucompat_init()` e `ksu_ksud_init()` em `KernelSU/kernel/ksu.c`, se o dispositivo inicializar normalmente, então o kprobe pode estar quebrado.
:::

::: info COMO FAZER COM QUE O RECURSO DE DESMONTAR MÓDULOS FUNCIONE NO PRÉ-GKI?
Se o seu kernel for inferior a 5.9, você deve portar `path_umount` para `fs/namespace.c`. Isso é necessário para que o recurso "Desmontar módulos" funcione corretamente. Caso você não porte `path_umount`, o recurso "Desmontar módulos" não funcionará. Você pode obter mais informações sobre como conseguir isso no final desta página.
:::

## Modifique manualmente a fonte do kernel

Se o kprobe não funcionar no seu kernel (isso pode ser causado por um bug no upstream ou do kernel abaixo de 4.8), então você pode tentar o seguinte:

Primeiro, adicione o KernelSU à árvore de origem do kernel:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

Tenha em mente que, em alguns dispositivos, seu defconfig pode estar localizado em `arch/arm64/configs` ou em outros casos pode estar em `arch/arm64/configs/vendor/your_defconfig`. Independentemente do defconfig que você estiver usando, certifique-se de ativar `CONFIG_KSU` com `y` para ativa-lo ou `n` para desativa-lo. Por exemplo, se optar por ativá-lo, seu defconfig deverá conter a seguinte linha:

```txt
# KernelSU
CONFIG_KSU=y
```

Em seguida, adicione chamadas do KernelSU à fonte do kernel. Abaixo estão alguns patches para referência:

::: code-group

```diff[exec.c]
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
+#endif
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
+   #endif
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff[open.c]
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
+#endif
 /*
  * access() precisa usar o uid/gid real, não o uid/gid efetivo.
  * Fazemos isso limpando temporariamente todos os recursos relacionados ao FS e
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff[read_write.c]
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);

+#ifdef CONFIG_KSU
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
+#endif
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
+   #ifdef CONFIG_KSU 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+   #endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff[stat.c]
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
+
 /**
  * vfs_statx - Obtenha atributos básicos e extras por filename
  * @dfd: Um descritor de arquivo que representa o diretório base para um filename relativo
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;

+   #ifdef CONFIG_KSU
+	ksu_handle_stat(&dfd, &filename, &flags);
+   #endif
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```

:::

Você deve encontrar as quatro funções no código-fonte do kernel:

1. `do_faccessat`, geralmente em `fs/open.c`
2. `do_execveat_common`, geralmente em `fs/exec.c`
3. `vfs_read`, geralmente em `fs/read_write.c`
4. `vfs_statx`, geralmente em `fs/stat.c`

Se o seu kernel não tiver a função `vfs_statx`, use `vfs_fstatat`:

```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
+   #ifdef CONFIG_KSU 
+	ksu_handle_stat(&dfd, &filename, &flag);
+   #endif
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

Para kernels anteriores ao 4.17, se você não conseguir encontrar `do_faccessat`, basta ir até a definição do syscall `faccessat` e fazer a chamada lá:

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+#endif
+
 /*
  * access() precisa usar o uid/gid real, não o uid/gid efetivo.
  * Fazemos isso limpando temporariamente todos os recursos relacionados ao FS e
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

### Modo de Segurança

Para ativar o Modo de Segurança integrado do KernelSU, você deve modificar a função `input_handle_event` em `drivers/input/input.c`:

::: tip DICA
É altamente recomendável ativar este recurso, é muito útil para evitar bootloops!
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+#endif
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
+   #endif
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

::: info ENTRANDO NO MODO DE SEGURANÇA ACIDENTALMENTE?
Se você estiver usando a integração manual e não desativar `CONFIG_KPROBES`, o usuário poderá acionar o Modo de Segurança pressionando o botão de diminuir volume após a inicialização! Portanto, se estiver usando a integração manual, é necessário desativar `CONFIG_KPROBES`!
:::

### Falha ao executar `pm` no terminal?

Você deve modificar `fs/devpts/inode.c`. Referência:

```diff
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index 32f6f1c68..d69d8eca2 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -602,6 +602,8 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
        return dentry;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_devpts(struct inode*);
+#endif
+
 /**
  * devpts_get_priv -- get private data for a slave
  * @pts_inode: inode of the slave
@@ -610,6 +612,7 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
  */
 void *devpts_get_priv(struct dentry *dentry)
 {
+       #ifdef CONFIG_KSU
+       ksu_handle_devpts(dentry->d_inode);
+       #ifdef CONFIG_KSU
        if (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)
                return NULL;
        return dentry->d_fsdata;
```

### Como portar path_umount

Você pode fazer com que o recurso "Desmontar módulos" funcione em kernels pré-GKI portando manualmente `path_umount` da versão 5.9. Você pode usar este patch como referência:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* não devemos chamar path_put() pois isso limparia mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Agora o umount pode lidar com pontos de montagem e também com dispositivos bloqueados.
  * Isto é importante para filesystems que usam dispositivos bloqueados sem nome.
```

Finalmente, compile seu kernel novamente e o KernelSU deverá funcionar corretamente.

```

`website/docs/pt_BR/guide/installation.md`:

```md
# Instalação

## Verifique se o seu dispositivo é compatível

Baixe o gerenciador do KernelSU em [GitHub Releases](https://github.com/tiann/KernelSU/releases) e instale-o no seu dispositivo:

- Se o app mostrar `Sem suporte`, significa que **você precisará compilar o kernel por conta própria**. O KernelSU não fornecerá e nunca fornecerá um arquivo boot.img para você instalar.
- Se o app mostrar `Não instalado`, então seu dispositivo é oficialmente suportado pelo KernelSU.

::: info INFORMAÇÕES
Para dispositivos que mostram `Sem suporte`, você pode conferir a lista de [Dispositivos com suporte não oficial](unofficially-support-devices.md). Você mesmo pode compilar o kernel.
:::

## Backup padrão do boot.img

Antes de fazer o flash, é essencial que você faça o backup do seu boot.img padrão. Se encontrar algum bootloop, você sempre pode restaurar o sistema voltando ao boot padrão de fábrica usando o fastboot.

::: warning AVISO
O flash pode causar perda de dados. Certifique-se de executar esta etapa bem antes de prosseguir para a próxima! Se necessário, também é recomendável fazer backup de todos os dados do seu dispositivo.
:::

## Conhecimento necessário

### ADB e fastboot

Por padrão, você usará as ferramentas ADB e fastboot neste tutorial, portanto, se você não as conhece, recomendamos pesquisar para aprender sobre elas primeiro.

### KMI

Kernel Module Interface (KMI), versões de kernel com o mesmo KMI são **compatíveis**, isso é o que "geral" significa no GKI. Por outro lado, se o KMI for diferente, então esses kernels não são compatíveis entre si, e atualizar uma imagem do kernel com um KMI diferente do seu dispositivo pode causar um bootloop.

Especificamente, para dispositivos GKI, o formato da versão do kernel deve ser a seguinte:

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -alguma coisa
```

`w.x-zzz-k` é a versão KMI. Por exemplo, se a versão do kernel de um dispositivo for `5.10.101-android12-9-g30979850fc20`, então seu KMI será `5.10-android12-9`. Teoricamente, ele pode inicializar normalmente com outros kernels KMI.

::: tip DICA
Observe que o SubLevel na versão do kernel não faz parte do KMI! Isso significa que `5.10.101-android12-9-g30979850fc20` tem o mesmo KMI que `5.10.137-android12-9-g30979850fc20`!
:::

### Nível do patch de segurança {#security-patch-level}

Dispositivos Android mais recentes podem ter mecanismos anti-rollback que impedem o flash de um boot.img com um nível de patch de segurança antigo. Por exemplo, se o kernel do seu dispositivo for `5.10.101-android12-9-g30979850fc20`, o patch de segurança será `2023-11`, mesmo se você atualizar o kernel correspondente ao KMI do kernel, se o nível do patch de segurança for anterior a `2023-11` (como `2023-06`), isso pode causar um bootloop.

Portanto, kernels com os níveis de patch de segurança mais recentes são preferidos para manter a compatibilidade com o KMI.

### Versão do kernel vs Versão do Android

Por favor, observe: **A versão do kernel e a versão do Android não são necessariamente iguais!**

Se você descobrir que a versão do seu kernel é `android12-5.10.101`, mas a versão do seu sistema Android é Android 13 ou outra, não se surpreenda, pois o número da versão do sistema Android não é necessariamente igual ao número da versão do kernel Linux. O número da versão do kernel Linux geralmente é correspondente à versão do sistema Android que acompanha o **dispositivo quando ele é enviado**. Se o sistema Android for atualizado posteriormente, a versão do kernel geralmente não será alterada. Então, antes de flashar qualquer coisa, **consulte sempre a versão do kernel!**

## Introdução

Desde a versão [0.9.0](https://github.com/tiann/KernelSU/releases/tag/v0.9.0), o KernelSU suporta dois modos de execução em dispositivos GKI:

1. `GKI`: Substitue o kernel original do dispositivo pelo **Generic Kernel Image** (GKI) fornecido pelo KernelSU.
2. `LKM`: Carregue o **Loadable Kernel Module** (LKM) no kernel do dispositivo sem substituir o kernel original.

Esses dois modos são adequados para diferentes cenários, e você pode escolher o mais adequado conforme suas necessidades.

### Modo GKI {#gki-mode}

No modo GKI, o kernel original do dispositivo será substituído pela imagem genérica do kernel fornecida pelo KernelSU. As vantagens do modo GKI são:

1. Forte universalidade, adequada para a maioria dos dispositivos. Por exemplo, a Samsung ativou dispositivos KNOX, e o modo LKM não pode funcionar. Existem também alguns dispositivos modificados de nicho que só podem usar o modo GKI.
2. Pode ser usado sem depender de firmware oficial, e não há necessidade de esperar por atualizações oficiais de firmware, desde que o KMI seja consistente, ele pode ser usado.

### Modo LKM {#lkm-mode}

No modo LKM, o kernel original do dispositivo não será substituído, mas o módulo do kernel carregável será carregado no kernel do dispositivo. As vantagens do modo LKM são:

1. Não substituirá o kernel original do dispositivo. Se você tiver os requisitos especiais para o kernel original do dispositivo ou quiser usar o KernelSU enquanto usa um kernel de terceiros, poderá usar o modo LKM.
2. É mais conveniente atualizar o OTA. Ao atualizar o KernelSU, você pode instalá-lo diretamente no gerenciador sem flashar manualmente. Após o sistema OTA, você pode instalá-lo diretamente no segundo slot sem flashar manualmente.
3. Adequado para alguns cenários especiais. Por exemplo, o LKM também pode ser carregado com privilégios root temporários. Como não é necessário substituir a partição boot, ele não acionará o AVB e não causará o bloqueio do dispositivo.
4. O LKM pode ser desinstalado temporariamente. Se você deseja desativar temporariamente o acesso root, você pode desinstalar o LKM. Este processo não requer o flash de partições, nem mesmo a reinicialização do dispositivo. Se quiser ativar o root novamente, basta reiniciar o dispositivo.

::: tip COEXISTÊNCIA DE DOIS MODOS
Após abrir o gerenciador, você pode ver o modo atual do dispositivo na página inicial. Observe que a prioridade do modo GKI é maior que a do LKM. Por exemplo, se você usar o kernel GKI para substituir o kernel original e usar LKM para corrigir o kernel GKI, o LKM será ignorado e o dispositivo sempre será executado no modo GKI.
:::

### Qual escolher? {#which-one}

Se o seu aparelho for um celular, recomendamos que você priorize o modo LKM. Se o seu dispositivo for um emulador, WSA ou Waydroid, recomendamos que você priorize o modo GKI.

## Instalação do LKM

### Obtenha o firmware oficial

Para usar o modo LKM, você precisa obter o firmware oficial e corrigi-lo com base no firmware oficial. Se você usar um kernel de terceiros, poderá usar o `boot.img` do kernel de terceiros como firmware oficial.

Existem muitas maneiras de obter o firmware oficial. Se o seu dispositivo suportar `fastboot boot`, então recomendamos **o método mais simples e indicado**, que consiste em usar `fastboot boot` para inicializar temporariamente o kernel GKI fornecido pelo KernelSU, depois instalar o gerenciador e, finalmente, instalá-lo diretamente pelo gerenciador. Este método não exige o download manual do firmware oficial nem a extração manual do boot.

Se o seu dispositivo não suportar `fastboot boot`, pode ser necessário baixar manualmente o pacote de firmware oficial e extrair o boot dele.

Ao contrário do modo GKI, o modo LKM modifica o `ramdisk`. Portanto, em dispositivos com Android 13, ele precisa corrigir a partição `init_boot` em vez da partição `boot`, enquanto o modo GKI sempre opera sobre a partição `boot`.

### Use o gerenciador

Abra o gerenciador, clique no ícone de instalação no canto superior direito e diversas opções aparecerão:

1. Selecione um arquivo. Se o seu dispositivo não tiver privilégios root, você pode escolher esta opção e, em seguida, selecionar o seu firmware oficial. O gerenciador corrigirá automaticamente o firmware. Após isso, basta fazer o flash deste arquivo corrigido para obter privilégios root permanentemente.
2. Instalação direta. Se o seu dispositivo já estiver rooteado, você pode escolher esta opção. O gerenciador obterá automaticamente as informações do seu dispositivo, corrigirá o firmware oficial e realizará o flash automaticamente. Você também pode usar o comando `fastboot boot` junto com o kernel GKI do KernelSU para obter root temporário e instalar o gerenciador, e então usar esta opção. Esta também é a principal forma de atualizar o KernelSU.
3. Instalar no slot inativo. Se o seu dispositivo suportar partição A/B, você pode escolher esta opção. O gerenciador corrigirá automaticamente o firmware oficial e o instalará em outra partição. Esse método é adequado para dispositivos após o OTA, você pode instalá-lo diretamente em outra partição após o OTA e, em seguida, reiniciar o dispositivo.

### Use a linha de comando

Se não quiser usar o gerenciador, você também pode usar a linha de comando para instalar o LKM. A ferramenta `ksud` fornecida pelo KernelSU pode ajudá-lo a corrigir rapidamente o firmware oficial e depois fazer o flash.

Esta ferramenta oferece suporte ao macOS, Linux e Windows. Você pode baixar a versão correspondente em [GitHub Release](https://github.com/tiann/KernelSU/releases).

Uso: `ksud boot-patch` você pode verificar a ajuda da linha de comando para opções específicas.

```sh
oriole:/ # ksud boot-patch -h
Patch boot ou imagens init_boot para aplicar o KernelSU

Uso: ksud boot-patch [OPTIONS]

Opções:
  -b, --boot <BOOT>              Caminho da imagem boot. Se não especificado, tentará encontrar a imagem boot automaticamente
  -k, --kernel <KERNEL>          Caminho da imagem do kernel a ser substituída
  -m, --module <MODULE>          Caminho do módulo LKM a ser substituído. Se não especificado, usará o módulo integrado
  -i, --init <INIT>              init a ser substituído
  -u, --ota                      Usará outro slot se a imagem boot não for especificada
  -f, --flash                    Flash para a partição boot após o patch
  -o, --out <OUT>                Caminho de saída. Se não especificado, usará o diretório atual
      --magiskboot <MAGISKBOOT>  Caminho do magiskboot. Se não especificado, usará a versão integrada
      --kmi <KMI>                Versão do KMI. Se especificada, usará o KMI indicado
  -h, --help                     Imprimir ajuda
```

Algumas opções que precisam ser explicadas:

1. A opção `--magiskboot` pode especificar o caminho do magiskboot. Se não for especificado, o ksud irá procurá-lo nas variáveis ​​de ambiente. Se você não souber como obter o magiskboot, você pode verificar [aqui](#patch-boot-image).
2. A opção `--kmi` pode especificar a versão do `KMI`. Se o nome do kernel do seu dispositivo não seguir a especificação KMI, você poderá especificá-lo através desta opção.

O uso mais comum é:

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## Instalação no modo GKI

Existem vários métodos de instalação para o modo GKI, cada um adequado para um cenário diferente, portanto escolha conforme necessário.

1. Instalar com fastboot usando o boot.img fornecido pelo KernelSU.
2. Instalar com um app kernel flash, como o [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases).
3. Corrigir manualmente o boot.img e instalá-lo.
4. Instalar com Recovery personalizado (por exemplo, TWRP).

## Instalar com o boot.img fornecido pelo KernelSU

Se o `boot.img` do seu dispositivo usa um formato de compactação comumente usado, você pode usar as imagens GKI fornecidas pelo KernelSU para atualizá-lo diretamente. Não requer TWRP ou autocorreção da imagem.

### Encontre o boot.img adequado

O KernelSU fornece um boot.img genérico para dispositivos GKI, e você deve fazer o flash do boot.img na partição boot do dispositivo.

Você pode baixar o boot.img em [GitHub Release](https://github.com/tiann/KernelSU/releases). Por favor, observe que você deve usar a versão correta do boot.img. Se você não sabe qual arquivo baixar, leia atentamente a descrição do [KMI](#kmi) e [Nível do patch de segurança](#security-patch-level) neste documento.

Normalmente, existem três arquivos de inicialização em formatos diferentes para o mesmo KMI e nível de patch de segurança. Eles são idênticos, exceto pelo formato de compactação do kernel. Por favor, verifique o formato de compactação do kernel de seu boot.img original. Você deve usar o formato correto, como `lz4` ou `gz`. Se você usar um formato de compactação incorreto, poderá encontrar bootloop após o flash do boot.img.

::: info FORMATO DE COMPACTAÇÃO DO BOOT.IMG
1. Você pode usar o magiskboot para obter o formato de compactação do seu boot.img original. Alternativamente, você também pode perguntar a membros ou desenvolvedores da comunidade que possuam o mesmo modelo de dispositivo. Além disso, o formato de compactação do kernel geralmente não muda, portanto, se você inicializar com êxito com um determinado formato de compactação, poderá tentar esse formato mais tarde.
2. Dispositivos Xiaomi geralmente usam `gz` ou `uncompressed`.
3. Para dispositivos Pixel, siga as instruções abaixo:
:::

### Flash o boot.img para o dispositivo

Use o `adb` para conectar seu dispositivo, execute `adb reboot bootloader` para entrar no modo fastboot e use este comando para flashar o KernelSU:

```sh
fastboot flash boot boot.img
```

::: info INFORMAÇÕES
Se o seu dispositivo suportar `fastboot boot`, você pode usar primeiro `fastboot boot boot.img` para tentar usar o boot.img para inicializar o sistema primeiro. Se algo inesperado acontecer, reinicie-o novamente para inicializar.
:::

### Reiniciar

Após a conclusão do flash, você deve reiniciar o dispositivo:

```sh
fastboot reboot
```

## Instalar com Kernel Flasher

Etapa:

1. Baixe o ZIP AnyKernel3. Se você não sabe qual arquivo baixar, leia atentamente a descrição do [KMI](#kmi) e [Nível do patch de segurança](#security-patch-level) neste documento.
2. Abra o app Kernel Flasher, conceda as permissões de root necessárias e use o ZIP AnyKernel3 fornecido para fazer o flash.

Dessa forma, é necessário que o app Kernel Flasher tenha privilégios root. Você pode usar os seguintes métodos para conseguir isso:

1. Seu dispositivo está rooteado. Por exemplo, você instalou o KernelSU e deseja atualizar para a versão mais recente ou fez o root por meio de outros métodos (como Magisk).
2. Se o seu dispositivo não estiver rooteado, mas suportar o método de inicialização temporária como `fastboot boot boot.img`, você pode usar a imagem GKI fornecida pelo KernelSU para inicializar temporariamente o seu dispositivo, obter privilégios root temporário e, em seguida, usar o Kernel Flasher para obter privilégios root permanente.

Aqui estão alguns apps que podem ser usados para realizar o flash do kernel:

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

Observação: Este método é mais conveniente ao atualizar o KernelSU e pode ser feito sem um computador (faça um backup primeiro).

## Corrigir boot.img manualmente {#patch-boot-image}

Para alguns dispositivos, o formato boot.img não é tão comum como `lz4`, `gz` e `uncompressed`. Um exemplo típico é o Pixel, cujo boot.img é compactado no formato `lz4_legacy`, enquanto o ramdisk pode estar em `gz` ou também comprimido em `lz4_legacy`. Atualmente, se você flashar diretamente o boot.img fornecido pelo KernelSU, o dispositivo pode não conseguir inicializar. Nesse caso, é necessário corrigir manualmente o boot.img para conseguir isso.

É sempre recomendado usar `magiskboot` para corrigir imagens, existem duas maneiras:

1. [magiskboot](https://github.com/topjohnwu/Magisk/releases)
2. [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci)

A versão oficial do `magiskboot` só pode ser executada em dispositivos Android, se você quiser rodar no PC, você pode tentar a segunda opção.

::: tip DICA
Android-Image-Kitchen não é recomendado por enquanto, porque ele não lida corretamente com os metadados de inicialização (como o nível do patch de segurança). Portanto, pode não funcionar em alguns dispositivos.
:::

### Preparação

1. Obtenha o boot.img padrão do dispositivo. Você pode obtê-lo com os fabricantes do seu dispositivo. Talvez você precise do [payload-dumper-go](https://github.com/ssut/payload-dumper-go).
2. Baixe o arquivo ZIP AnyKernel3 fornecido pelo KernelSU que corresponde à versão KMI do seu dispositivo. Você pode consultar [Instalar com Recovery personalizado](#install-with-custom-recovery).
3. Descompacte o pacote AnyKernel3 e obtenha o arquivo `Image`, que é o arquivo do kernel do KernelSU.

### Usando o magiskboot em dispositivos Android {#using-magiskboot-on-Android-devices}

1. Baixe o Magisk mais recente em [GitHub Releases](https://github.com/topjohnwu/Magisk/releases).
2. Renomeie o `Magisk-*(versão).apk` para `Magisk-*.zip` e descompacte-o.
3. Envie `Magisk-*/lib/arm64-v8a/libmagiskboot.so` para o seu dispositivo por ADB: `adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`.
4. Envie o boot.img padrão e Image em AnyKernel3 para o seu dispositivo.
5. Entre no ADB shell e execute o diretório `cd /data/local/tmp/`, em seguida, `chmod +x magiskboot`.
6. Entre no ADB shell e execute o diretório `cd /data/local/tmp/`, execute `./magiskboot unpack boot.img` para descompactar `boot.img`, você obterá um arquivo `kernel`, este é o seu kernel padrão.
7. Substitua `kernel` por `Image` executando o comando: `mv -f Image kernel`.
8. Execute `./magiskboot repack boot.img` para reembalar o boot.img, e você obterá um arquivo `new-boot.img`, faça o flash deste arquivo para o dispositivo por fastboot.

### Usando o magiskboot no PC Windows/macOS/Linux {#using-magiskboot-on-PC}

1. Baixe o `magiskboot` adequado para o seu sistema operacional em [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci).
2. Prepare o `boot.img` padrão e `Image` em seu PC.
3. Execute `chmod +x magiskboot`.
4. Entre no diretório apropriado, execute `./magiskboot unpack boot.img` para descompactar `boot.img`. Você obterá um arquivo `kernel`, este é o seu kernel padrão.
5. Substitua `kernel` por `Image` executando o comando: `mv -f Image kernel`.
6. Execute `./magiskboot repack boot.img` para reembalar o boot.img, e você obterá um arquivo `new-boot.img`, faça o flash deste arquivo para o dispositivo por fastboot.

::: info INFORMAÇÕES
O `magiskboot` oficial pode executar o dispositivo `Linux` normalmente. Se você for um usuário Linux, você pode usar a versão oficial.
:::

## Instalar com Recovery personalizado {#install-with-custom-recovery}

Pré-requisito: Seu dispositivo deve ter um Recovery personalizado, como TWRP. Se não houver Recovery personalizado disponível para o seu dispositivo, use outro método.

Etapas:

1. Em [GitHub Releases](https://github.com/tiann/KernelSU/releases), baixe o pacote ZIP começando com AnyKernel3 que corresponde à versão do seu dispositivo. Por exemplo, a versão do kernel do dispositivo é `android12-5.10.66`, então você deve baixar o arquivo `AnyKernel3-android12-5.10.66_yyyy-MM.zip` (onde `yyyy` é o ano e `MM` é o mês).
2. Reinicie o dispositivo no TWRP.
3. Use o ADB para colocar AnyKernel3-*.zip no dispositivo em `/sdcard` e escolha instalá-lo na interface do TWRP, ou você pode diretamente executar `adb sideload AnyKernel-*.zip` para instalar.

Observação: Este método é adequado para qualquer instalação (não limitado à instalação inicial ou atualizações subsequentes), desde que você use o TWRP.

## Outros métodos

Na verdade, todos esses métodos de instalação têm apenas uma ideia principal, que é **substituir o kernel original pelo fornecido pelo KernelSU**, desde que isso possa ser alcançado, ele pode ser instalado. A seguir estão outros métodos possíveis:

1. Primeiro instale o Magisk, obtenha privilégios root através do Magisk e então use o Kernel Flasher para fazer o flash no ZIP AnyKernel3 do KernelSU.
2. Use algum kit de ferramentas de flash em PC para flashar no kernel fornecido pelo KernelSU.

No entanto, se não funcionar, por favor, tente o método `magiskboot`.

## Pós-instalação: Suporte a Módulos {#post-installation}

::: warning METAMODULE PARA MODIFICAÇÃO DE ARQUIVOS DO SISTEMA
Se você deseja usar módulos que modificam arquivos `/system`, você precisa instalar um **metamodule** após instalar o KernelSU. Módulos que usam apenas scripts, sepolicy ou system.prop funcionam sem um metamodule.
:::

**Para suporte à modificação de `/system`**, consulte o [Guia de Metamodule](metamodule.md) para:
- Entender o que são metamodules e por que são necessários
- Instalar o metamodule oficial `meta-overlayfs`
- Conhecer outras opções de metamodule

```

`website/docs/pt_BR/guide/metamodule.md`:

```md
# Metamódulo

Metamódulos são um recurso revolucionário no KernelSU que transfere recursos críticos do sistema de módulos do daemon principal para módulos plugáveis. Essa mudança arquitetônica mantém a estabilidade e segurança do KernelSU enquanto libera um maior potencial de inovação para o ecossistema de módulos.

## O que é um Metamódulo?

Um metamódulo é um tipo especial de módulo KernelSU que fornece funcionalidade de infraestrutura central para o sistema de módulos. Ao contrário dos módulos regulares que modificam arquivos do sistema, os metamódulos controlam *como* os módulos regulares são instalados e montados.

Metamódulos são um mecanismo de extensão baseado em plugins que permite a personalização completa da infraestrutura de gerenciamento de módulos do KernelSU. Ao delegar a lógica de montagem e instalação aos metamódulos, o KernelSU evita se tornar um ponto de detecção frágil enquanto permite diversas estratégias de implementação.

**Características principais:**

- **Papel de infraestrutura**: Metamódulos fornecem serviços dos quais os módulos regulares dependem
- **Instância única**: Apenas um metamódulo pode ser instalado por vez
- **Execução prioritária**: Scripts de metamódulos são executados antes dos scripts de módulos regulares
- **Hooks especiais**: Fornece três scripts de hook para instalação, montagem e limpeza

## Por que Metamódulos?

Soluções root tradicionais incorporam a lógica de montagem em seu núcleo, tornando-as mais fáceis de detectar e mais difíceis de evoluir. A arquitetura de metamódulos do KernelSU resolve esses problemas através da separação de preocupações.

**Vantagens estratégicas:**

- **Superfície de detecção reduzida**: O próprio KernelSU não realiza montagens, reduzindo vetores de detecção
- **Estabilidade**: O daemon central permanece estável enquanto as implementações de montagem podem evoluir
- **Inovação**: A comunidade pode desenvolver estratégias alternativas de montagem sem bifurcar o KernelSU
- **Escolha**: Os usuários podem selecionar a implementação que melhor se adapta às suas necessidades

**Flexibilidade de montagem:**

- **Sem montagem**: Para usuários com módulos somente sem montagem, evite completamente a sobrecarga de montagem
- **Montagem OverlayFS**: Abordagem tradicional com suporte a camada de leitura-escrita (via `meta-overlayfs`)
- **Magic mount**: Montagem compatível com Magisk para melhor compatibilidade de aplicativos
- **Implementações personalizadas**: Sobreposições baseadas em FUSE, montagens VFS personalizadas ou abordagens totalmente novas

**Além da montagem:**

- **Extensibilidade**: Adicione recursos como suporte a módulos do kernel sem modificar o núcleo do KernelSU
- **Modularidade**: Atualize implementações independentemente das versões do KernelSU
- **Personalização**: Crie soluções especializadas para dispositivos ou casos de uso específicos

::: warning IMPORTANTE
Sem um metamódulo instalado, os módulos **NÃO** serão montados. Instalações novas do KernelSU requerem a instalação de um metamódulo (como `meta-overlayfs`) para que os módulos funcionem.
:::

## Para Usuários

### Instalando um Metamódulo

Instale um metamódulo da mesma forma que módulos regulares:

1. Baixe o arquivo ZIP do metamódulo (por exemplo, `meta-overlayfs.zip`)
2. Abra o aplicativo KernelSU Manager
3. Toque no botão de ação flutuante (➕)
4. Selecione o arquivo ZIP do metamódulo
5. Reinicie seu dispositivo

O metamódulo `meta-overlayfs` é a implementação de referência oficial que fornece montagem de módulos baseada em overlayfs tradicional com suporte a imagem ext4.

### Verificando o Metamódulo Ativo

Você pode verificar qual metamódulo está atualmente ativo na página de Módulos do aplicativo KernelSU Manager. O metamódulo ativo será exibido na sua lista de módulos com sua designação especial.

### Desinstalando um Metamódulo

::: danger AVISO
Desinstalar um metamódulo afetará **TODOS** os módulos. Após a remoção, os módulos não serão mais montados até que você instale outro metamódulo.
:::

Para desinstalar:

1. Abra o KernelSU Manager
2. Encontre o metamódulo na sua lista de módulos
3. Toque em desinstalar (você verá um aviso especial)
4. Confirme a ação
5. Reinicie seu dispositivo

Após desinstalar, você deve instalar outro metamódulo se quiser que os módulos continuem funcionando.

### Restrição de Metamódulo Único

Apenas um metamódulo pode ser instalado por vez. Se você tentar instalar um segundo metamódulo, o KernelSU impedirá a instalação para evitar conflitos.

Para trocar metamódulos:

1. Desinstale todos os módulos regulares
2. Desinstale o metamódulo atual
3. Reinicie
4. Instale o novo metamódulo
5. Reinstale seus módulos regulares
6. Reinicie novamente

## Para Desenvolvedores de Módulos

Se você está desenvolvendo módulos KernelSU regulares, não precisa se preocupar muito com metamódulos. Seus módulos funcionarão desde que os usuários tenham um metamódulo compatível (como `meta-overlayfs`) instalado.

**O que você precisa saber:**

- **Montagem requer um metamódulo**: O diretório `system` no seu módulo só será montado se o usuário tiver um metamódulo instalado que forneça funcionalidade de montagem
- **Nenhuma alteração de código necessária**: Módulos existentes continuam a funcionar sem modificação

::: tip
Se você está familiarizado com o desenvolvimento de módulos Magisk, seus módulos funcionarão da mesma forma no KernelSU quando o metamódulo estiver instalado, pois ele fornece montagem compatível com Magisk.
:::

## Para Desenvolvedores de Metamódulos

Criar um metamódulo permite que você personalize como o KernelSU lida com instalação de módulos, montagem e desinstalação.

### Requisitos Básicos

Um metamódulo é identificado por uma propriedade especial em seu `module.prop`:

```txt
id=my_metamodule
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

A propriedade `metamodule=1` (ou `metamodule=true`) marca isso como um metamódulo. Sem essa propriedade, o módulo será tratado como um módulo regular.

### Estrutura de Arquivos

Estrutura de um metamódulo:

```txt
my_metamodule/
├── module.prop              (deve incluir metamodule=1)
│
│      *** Hooks específicos de metamódulo ***
├── metamount.sh             (opcional: manipulador de montagem personalizado)
├── metainstall.sh           (opcional: hook de instalação para módulos regulares)
├── metauninstall.sh         (opcional: hook de limpeza para módulos regulares)
│
│      *** Arquivos de módulo padrão (todos opcionais) ***
├── customize.sh             (personalização de instalação)
├── post-fs-data.sh          (script de estágio post-fs-data)
├── service.sh               (script late_start service)
├── boot-completed.sh        (script de inicialização concluída)
├── uninstall.sh             (script de desinstalação do próprio metamódulo)
├── system/                  (modificações systemless, se necessário)
└── [quaisquer arquivos adicionais]
```

Metamódulos podem usar todos os recursos de módulos padrão (scripts de ciclo de vida, etc.) além de seus hooks especiais de metamódulo.

### Scripts de Hook

Metamódulos podem fornecer até três scripts de hook especiais:

#### 1. metamount.sh - Manipulador de Montagem

**Propósito**: Controla como os módulos são montados durante a inicialização.

**Quando executado**: Durante o estágio `post-fs-data`, antes de qualquer script de módulo ser executado.

**Variáveis de ambiente:**

- `MODDIR`: O caminho do diretório do metamódulo (por exemplo, `/data/adb/modules/my_metamodule`)
- Todas as variáveis de ambiente padrão do KernelSU

**Responsabilidades:**

- Montar todos os módulos habilitados de forma systemless
- Verificar flags `skip_mount`
- Lidar com requisitos específicos de montagem de módulos

::: danger REQUISITO CRÍTICO
Ao realizar operações de montagem, você **DEVE** definir o nome da origem/dispositivo como `"KSU"`. Isso identifica as montagens como pertencentes ao KernelSU.

**Exemplo (correto):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**Para APIs de montagem modernas**, defina a string de origem:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

Isso é essencial para o KernelSU identificar e gerenciar adequadamente suas montagens.
:::

**Script de exemplo:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# Exemplo: Implementação simples de bind mount
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # Monte com source=KSU (OBRIGATÓRIO!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - Hook de Instalação

**Propósito**: Personalizar como módulos regulares são instalados.

**Quando executado**: Durante a instalação do módulo, após a extração dos arquivos, mas antes da conclusão da instalação. Este script é **executado por source** (não executado) pelo instalador embutido, semelhante a como `customize.sh` funciona.

**Variáveis de ambiente e funções:**

Este script herda todas as variáveis e funções do `install.sh` embutido:

- **Variáveis**: `MODPATH`, `TMPDIR`, `ZIPFILE`, `ARCH`, `API`, `IS64BIT`, `KSU`, `KSU_VER`, `KSU_VER_CODE`, `BOOTMODE`, etc.
- **Funções**:
  - `ui_print <msg>` - Imprime mensagem no console
  - `abort <msg>` - Imprime erro e encerra a instalação
  - `set_perm <target> <owner> <group> <permission> [context]` - Define permissões de arquivo
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - Define permissões recursivamente
  - `install_module` - Chama o processo de instalação de módulo embutido

**Casos de uso:**

- Processar arquivos de módulo antes ou depois da instalação embutida (chame `install_module` quando estiver pronto)
- Mover arquivos de módulo
- Validar compatibilidade de módulo
- Configurar estruturas de diretório especiais
- Inicializar recursos específicos do módulo

**Nota**: Este script **NÃO** é chamado ao instalar o próprio metamódulo.

#### 3. metauninstall.sh - Hook de Limpeza

**Propósito**: Limpar recursos quando módulos regulares são desinstalados.

**Quando executado**: Durante a desinstalação do módulo, antes do diretório do módulo ser removido.

**Variáveis de ambiente:**

- `MODULE_ID`: O ID do módulo sendo desinstalado

**Casos de uso:**

- Processar arquivos
- Limpar symlinks
- Liberar recursos alocados
- Atualizar rastreamento interno

**Script de exemplo:**

```sh
#!/system/bin/sh
# Chamado ao desinstalar módulos regulares
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# Remover arquivos do módulo da imagem
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### Ordem de Execução

Entender a ordem de execução da inicialização é crucial para o desenvolvimento de metamódulos:

```txt
estágio post-fs-data:
  1. Scripts comuns post-fs-data.d são executados
  2. Limpar módulos, restorecon, carregar sepolicy.rule
  3. post-fs-data.sh do metamódulo é executado (se existir)
  4. post-fs-data.sh dos módulos regulares são executados
  5. Carregar system.prop
  6. metamount.sh do metamódulo é executado
     └─> Monta todos os módulos de forma systemless
  7. Estágio post-mount.d é executado
     - Scripts comuns post-mount.d
     - post-mount.sh do metamódulo (se existir)
     - post-mount.sh dos módulos regulares

estágio service:
  1. Scripts comuns service.d são executados
  2. service.sh do metamódulo é executado (se existir)
  3. service.sh dos módulos regulares são executados

estágio boot-completed:
  1. Scripts comuns boot-completed.d são executados
  2. boot-completed.sh do metamódulo é executado (se existir)
  3. boot-completed.sh dos módulos regulares são executados
```

**Pontos-chave:**

- `metamount.sh` é executado **APÓS** todos os scripts post-fs-data (tanto metamódulo quanto módulos regulares)
- Scripts de ciclo de vida do metamódulo (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`) sempre são executados antes dos scripts de módulos regulares
- Scripts comuns em diretórios `.d` são executados antes dos scripts de metamódulo
- O estágio `post-mount` é executado após a conclusão da montagem

### Mecanismo de Symlink

Quando um metamódulo é instalado, o KernelSU cria um symlink:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

Isso fornece um caminho estável para acessar o metamódulo ativo, independentemente de seu ID.

**Benefícios:**

- Caminho de acesso consistente
- Detecção fácil do metamódulo ativo
- Simplifica a configuração

### Exemplo do Mundo Real: meta-overlayfs

O metamódulo `meta-overlayfs` é a implementação de referência oficial. Ele demonstra as melhores práticas para desenvolvimento de metamódulos.

#### Arquitetura

`meta-overlayfs` usa uma **arquitetura de diretório duplo**:

1. **Diretório de metadados**: `/data/adb/modules/`
   - Contém `module.prop`, `disable`, marcadores `skip_mount`
   - Rápido para escanear durante a inicialização
   - Pegada de armazenamento pequena

2. **Diretório de conteúdo**: `/data/adb/metamodule/mnt/`
   - Contém arquivos reais do módulo (system, vendor, product, etc.)
   - Armazenado em uma imagem ext4 (`modules.img`)
   - Otimizado de espaço com recursos ext4

#### Implementação do metamount.sh

Veja como `meta-overlayfs` implementa o manipulador de montagem:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# Montar imagem ext4 se ainda não estiver montada
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# Definir variáveis de ambiente para suporte de diretório duplo
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# Executar binário de montagem
# (A lógica de montagem real está em um binário Rust)
"$MODDIR/meta-overlayfs"
```

#### Recursos Principais

**Montagem Overlayfs:**

- Usa overlayfs do kernel para modificações systemless verdadeiras
- Suporta múltiplas partições (system, vendor, product, system_ext, odm, oem)
- Suporte a camada de leitura-escrita via `/data/adb/modules/.rw/`

**Identificação de origem:**

```rust
// De meta-overlayfs/src/mount.rs
fsconfig_set_string(fs, "source", "KSU")?;  // OBRIGATÓRIO!
```

Isso define `dev=KSU` para todas as montagens overlay, permitindo identificação adequada.

### Melhores Práticas

Ao desenvolver metamódulos:

1. **Sempre defina a origem como "KSU"** para operações de montagem - umount do kernel e umount do zygisksu precisam disso para desmontar corretamente
2. **Trate erros graciosamente** - processos de inicialização são sensíveis ao tempo
3. **Respeite flags padrão** - suporte `skip_mount` e `disable`
4. **Registre operações** - use `echo` ou logging para depuração
5. **Teste minuciosamente** - erros de montagem podem causar boot loops
6. **Documente o comportamento** - explique claramente o que seu metamódulo faz
7. **Forneça caminhos de migração** - ajude os usuários a mudar de outras soluções

### Testando Seu Metamódulo

Antes de lançar:

1. **Teste a instalação** em uma configuração limpa do KernelSU
2. **Verifique a montagem** com vários tipos de módulos
3. **Verifique a compatibilidade** com módulos comuns
4. **Teste a desinstalação** e limpeza
5. **Valide o desempenho de inicialização** (metamount.sh está bloqueando!)
6. **Garanta o tratamento adequado de erros** para evitar boot loops

## Perguntas Frequentes

### Eu preciso de um metamódulo?

**Para usuários**: Apenas se você quiser usar módulos que requerem montagem. Se você usa apenas módulos que executam scripts sem modificar arquivos do sistema, não precisa de um metamódulo.

**Para desenvolvedores de módulos**: Não, você desenvolve módulos normalmente. Os usuários precisam de um metamódulo apenas se seu módulo requer montagem.

**Para usuários avançados**: Apenas se você quiser personalizar o comportamento de montagem ou criar implementações alternativas de montagem.

### Posso ter vários metamódulos?

Não. Apenas um metamódulo pode ser instalado por vez. Isso evita conflitos e garante comportamento previsível.

### O que acontece se eu desinstalar meu único metamódulo?

Os módulos não serão mais montados. Seu dispositivo inicializará normalmente, mas as modificações dos módulos não serão aplicadas até que você instale outro metamódulo.

### O meta-overlayfs é obrigatório?

Não. Ele fornece montagem overlayfs padrão compatível com a maioria dos módulos. Você pode criar seu próprio metamódulo se precisar de comportamento diferente.

## Veja Também

- [Guia de Módulos](module.md) - Desenvolvimento geral de módulos
- [Diferença com Magisk](difference-with-magisk.md) - Comparando KernelSU e Magisk
- [Como Compilar](how-to-build.md) - Compilando KernelSU a partir do código-fonte

```

`website/docs/pt_BR/guide/module-config.md`:

```md
# Configuração de Módulo

O KernelSU fornece um sistema de configuração integrado que permite que os módulos armazenem configurações de chave-valor persistentes ou temporárias. As configurações são armazenadas em formato binário em `/data/adb/ksu/module_configs/<module_id>/` com as seguintes características:

## Tipos de Configuração

- **Configuração Persistente** (`persist.config`): Sobrevive às reinicializações até ser explicitamente excluída ou o módulo ser desinstalado
- **Configuração Temporária** (`tmp.config`): Automaticamente limpa durante o estágio post-fs-data em cada inicialização

Ao ler configurações, os valores temporários têm prioridade sobre os valores persistentes para a mesma chave.

## Usando Configuração em Scripts de Módulo

Todos os scripts de módulo (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`, etc.) são executados com a variável de ambiente `KSU_MODULE` definida como o ID do módulo. Você pode usar os comandos `ksud module config` para gerenciar a configuração do seu módulo:

```bash
# Obter um valor de configuração
value=$(ksud module config get my_setting)

# Definir um valor de configuração persistente
ksud module config set my_setting "some value"

# Definir um valor de configuração temporário (limpo após a reinicialização)
ksud module config set --temp runtime_state "active"

# Definir valor a partir de stdin (útil para texto multilinhas ou dados complexos)
ksud module config set my_key <<EOF
texto multilinhas
valor
EOF

# Ou transmitir de um comando
echo "value" | ksud module config set my_key

# Sinalizador stdin explícito
cat file.json | ksud module config set json_data --stdin

# Listar todas as entradas de configuração (mesclando persistentes e temporárias)
ksud module config list

# Excluir uma entrada de configuração
ksud module config delete my_setting

# Excluir uma entrada de configuração temporária
ksud module config delete --temp runtime_state

# Limpar todas as configurações persistentes
ksud module config clear

# Limpar todas as configurações temporárias
ksud module config clear --temp
```

## Limites de Validação

O sistema de configuração impõe os seguintes limites:

- **Comprimento máximo da chave**: 256 bytes
- **Comprimento máximo do valor**: 1MB (1048576 bytes)
- **Número máximo de entradas de configuração**: 32 por módulo
- **Formato de chave**: Deve corresponder a `^[a-zA-Z][a-zA-Z0-9._-]+$` (como ID do módulo)
  - Deve começar com uma letra
  - Pode conter letras, números, pontos, sublinhados ou hífens
  - Comprimento mínimo: 2 caracteres
- **Formato de valor**: Sem restrições - pode conter qualquer caractere UTF-8, incluindo quebras de linha e caracteres de controle
  - Armazenado em formato binário com prefixo de comprimento para manuseio seguro de todos os dados

## Ciclo de Vida

- **Na inicialização**: Todas as configurações temporárias são limpas durante o estágio post-fs-data
- **Na desinstalação do módulo**: Todas as configurações (persistentes e temporárias) são automaticamente removidas
- As configurações são armazenadas em formato binário com número mágico `0x4b53554d` ("KSUM") e validação de versão

## Casos de Uso

O sistema de configuração é ideal para:

- **Preferências do usuário**: Armazenar configurações de módulo que os usuários configuram por meio de WebUI ou scripts de ação
- **Sinalizadores de recursos**: Ativar/desativar recursos do módulo sem reinstalar
- **Estado de execução**: Rastrear estado temporário que deve ser redefinido na reinicialização (use configuração temporária)
- **Configurações de instalação**: Lembrar escolhas feitas durante a instalação do módulo
- **Dados complexos**: Armazenar JSON, texto multilinha, dados codificados em Base64 ou qualquer conteúdo estruturado (até 1MB)

::: tip MELHORES PRÁTICAS
- Use configurações persistentes para preferências do usuário que devem sobreviver às reinicializações
- Use configurações temporárias para estado de execução ou sinalizadores de recursos que devem ser redefinidos na inicialização
- Valide os valores de configuração em seus scripts antes de usá-los
- Use o comando `ksud module config list` para depurar problemas de configuração
:::

## Recursos Avançados

O sistema de configuração de módulos fornece chaves de configuração especiais para casos de uso avançados:

### Substituindo a Descrição do Módulo {#overriding-module-description}

Você pode substituir dinamicamente o campo `description` do `module.prop` definindo a chave de configuração `override.description`:

```bash
# Substituir a descrição do módulo
ksud module config set override.description "Descrição personalizada exibida no gerenciador"
```

Ao recuperar a lista de módulos, se a configuração `override.description` existir, ela substituirá a descrição original do `module.prop`. Isso é útil para:
- Exibir informações dinâmicas de status na descrição do módulo
- Mostrar detalhes de configuração em tempo de execução aos usuários
- Atualizar a descrição com base no estado do módulo sem reinstalar

### Declarando Recursos Gerenciados

Os módulos podem declarar quais recursos do KernelSU eles gerenciam usando o padrão de configuração `manage.<feature>`. Os recursos suportados correspondem ao enum interno `FeatureId` do KernelSU:

**Recursos Suportados:**
- `su_compat` - Modo de compatibilidade SU
- `kernel_umount` - Desmontagem automática do kernel

```bash
# Declarar que este módulo gerencia a compatibilidade SU e a habilita
ksud module config set manage.su_compat true

# Declarar que este módulo gerencia a desmontagem do kernel e a desabilita
ksud module config set manage.kernel_umount false

# Remover gerenciamento de recurso (o módulo não controla mais este recurso)
ksud module config delete manage.su_compat
```

**Como funciona:**
- A presença de uma chave `manage.<feature>` indica que o módulo está gerenciando esse recurso
- O valor indica o estado desejado: `true`/`1` para habilitado, `false`/`0` (ou qualquer outro valor) para desabilitado
- Para parar de gerenciar um recurso, exclua completamente a chave de configuração

Os recursos gerenciados são expostos através da API de lista de módulos como um campo `managedFeatures` (string separada por vírgulas). Isso permite:
- O gerenciador do KernelSU detectar quais módulos gerenciam quais recursos do KernelSU
- Prevenção de conflitos quando vários módulos tentam gerenciar o mesmo recurso
- Melhor coordenação entre módulos e funcionalidade central do KernelSU

::: warning APENAS RECURSOS SUPORTADOS
Use apenas os nomes de recursos predefinidos listados acima (`su_compat`, `kernel_umount`). Eles correspondem aos recursos internos reais do KernelSU. Usar outros nomes de recursos não causará erros, mas não terá nenhum propósito funcional.
:::

```

`website/docs/pt_BR/guide/module-webui.md`:

```md
# Módulo WebUI

Além de executar scripts de inicialização e modificar arquivos do sistema, os módulos do KernelSU também suportam a exibição de interfaces da UI e à interação direta com os usuários.

O módulo pode escrever páginas HTML + CSS + JavaScript através de qualquer tecnologia web. O gerenciador do KernelSU exibirá essas páginas através do WebView. Ele também fornece algumas APIs para interagir com o sistema, como executar comandos shell.

## Diretório `webroot`

Os arquivos de recursos da web devem ser colocados no subdiretório `webroot` do diretório raiz do módulo, e **DEVE** haver um arquivo chamado `index.html`, que é a entrada da página do módulo. A estrutura do módulo mais simples contendo uma interface web é a seguinte:

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

::: warning AVISO
Ao instalar o módulo, KernelSU definirá automaticamente as permissões e o contexto do SELinux deste diretório. Se você não sabe o que está fazendo, não defina você mesmo as permissões deste diretório!
:::

Se sua página contém CSS e JavaScript, você também precisa colocá-la neste diretório.

## API JavaScript

Se for apenas uma página de exibição, ela funcionará como uma página web comum. No entanto, o mais importante é que o KernelSU oferece uma série de APIs de sistema, permitindo a implementação de funções exclusivas do módulo.

O KernelSU disponibiliza uma biblioteca JavaScript, que está publicada no [npm](https://www.npmjs.com/package/kernelsu) e pode ser usada no código JavaScript das suas páginas web.

Por exemplo, você pode executar um comando shell para obter uma configuração específica ou modificar uma propriedade:

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

Para outro exemplo, você pode fazer com que a página web seja exibida em tela inteira ou exibir um dica.

[Documentação da API](https://www.npmjs.com/package/kernelsu)

Se você achar que a API existente não atende às suas necessidades ou é inconveniente de usar, fique à vontade para nos dar sugestões [aqui](https://github.com/tiann/KernelSU/issues)!

## Algumas dicas

1. Você pode usar `localStorage` normalmente para armazenar alguns dados, mas tenha em mente que eles serão perdidos caso o app gerenciador seja desinstalado. Se precisar de armazenamento persistente, será necessário gravar os dados manualmente em algum diretório.
2. Para páginas simples, recomendamos o uso do [parceljs](https://parceljs.org/) para empacotamento. Ele não exige configuração inicial e é extremamente prático de usar. No entanto, se você é um especialista em front-end ou possui suas próprias preferências, sinta-se à vontade para usar a ferramenta de sua escolha!

```

`website/docs/pt_BR/guide/module.md`:

```md
# Guias de módulo

O KernelSU fornece um mecanismo de módulo que consegue modificar o diretório do sistema enquanto mantém a integridade da partição do sistema. Esse mecanismo é conhecido como "sem sistema".

O mecanismo de módulos do KernelSU é quase o mesmo do Magisk. Se você já está familiarizado com o desenvolvimento de módulos Magisk, o desenvolvimento de módulos KernelSU é muito semelhante. Você pode pular a introdução dos módulos abaixo e só precisa ler [Diferenças com Magisk](difference-with-magisk.md).

::: warning METAMODULE NECESSÁRIO APENAS PARA MODIFICAÇÃO DE ARQUIVOS DO SISTEMA
KernelSU usa uma arquitetura [metamodule](metamodule.md) para montar o diretório `system`. **Somente se seu módulo precisar modificar arquivos `/system`** (via diretório `system`), você precisa instalar um metamodule (como [meta-overlayfs](https://github.com/tiann/KernelSU/releases)). Outros recursos de módulos como scripts, regras sepolicy e system.prop funcionam sem um metamodule.
:::

## WebUI

Os módulos do KernelSU suportam a exibição de interfaces e a interação com os usuários. Para mais detalhes, consulte a [documentação do WebUI](module-webui.md).

## Configuração de Módulo

O KernelSU fornece um sistema de configuração integrado que permite que os módulos armazenem configurações de chave-valor persistentes ou temporárias. Para mais detalhes, consulte a [documentação de Configuração de Módulo](module-config.md).

## BusyBox

O KernelSU vem com um recurso binário BusyBox completo (incluindo suporte completo ao SELinux). O executável está localizado em `/data/adb/ksu/bin/busybox`. O BusyBox do KernelSU suporta "ASH Standalone Shell Mode" alternável em tempo de execução. O que este Modo Autônomo significa é que ao executar no shell `ash` do BusyBox, cada comando usará diretamente o miniaplicativo dentro do BusyBox, independentemente do que estiver definido em `PATH`. Por exemplo, comandos como `ls`, `rm`, `chmod` **NÃO** usarão o que está em `PATH` (no caso do Android, por padrão será `/system/bin/ls`, `/system/bin/rm` e `/system/bin/chmod` respectivamente), mas em vez disso chamará diretamente os miniaplicativos internos do BusyBox. Isso garante que os scripts sempre sejam executados em um ambiente previsível e sempre tenham o conjunto completo de comandos, independentemente da versão do Android em que estão sendo executados. Para forçar um comando a **NÃO** usar o BusyBox, você deve chamar o executável com caminhos completos.

Cada script shell executado no contexto do KernelSU será executado no shell `ash` do BusyBox com o Modo Autônomo ativado. Para o que é relevante para desenvolvedores terceirizados, isso inclui todos os scripts de inicialização e scripts de instalação de módulos.

Para aqueles que desejam usar o recurso Modo Autônomo fora do KernelSU, existem 2 maneiras de ativá-los:

1. Definir a variável de ambiente `ASH_STANDALONE` como `1`.<br>Exemplo: `ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. Alternar com opções de linha de comando:<br>`/data/adb/ksu/bin/busybox sh -o standalone <script>`

Para garantir que todos os shells `sh` subsequentes executados também sejam executados no Modo Autônomo, a opção 1 é o método preferido (e é isso que o KernelSU e o gerenciador do KernelSU usam internamente), pois as variáveis ​​de ambiente são herdadas para os subprocesso.

::: tip DIFERENÇAS COM MAGISK
O BusyBox do KernelSU agora está usando o arquivo binário compilado diretamente do projeto Magisk. **Obrigado ao Magisk!** Portanto, você não precisa se preocupar com problemas de compatibilidade entre scripts BusyBox no Magisk e KernelSU porque eles são exatamente iguais!
:::

## Módulos KernelSU

Um módulo KernelSU é uma pasta colocada em `/data/adb/modules` com a estrutura abaixo:

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- A pasta é nomeada com o ID do módulo
│   │
│   │      *** Identidade do módulo ***
│   │
│   ├── module.prop         <--- Este arquivo armazena os metadados do módulo
│   │
│   │      *** Conteúdo principal ***
│   │
│   ├── system              <--- Esta pasta será montada se skip_mount não existir
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** Sinalizadores de status ***
│   │
│   ├── skip_mount          <--- Se existir, o KernelSU não montará sua pasta de sistema
│   ├── disable             <--- Se existir, o módulo será desativado
│   ├── remove              <--- Se existir, o módulo será removido na próxima reinicialização
│   │
│   │      *** Arquivos opcionais ***
│   │
│   ├── post-fs-data.sh     <--- Este script será executado em post-fs-data
│   ├── post-mount.sh       <--- Este script será executado em post-mount
│   ├── service.sh          <--- Este script será executado no serviço late_start
│   ├── boot-completed.sh   <--- Este script será executado na inicialização concluída
|   ├── uninstall.sh        <--- Este script será executado quando o KernelSU remover seu módulo
|   ├── action.sh           <--- Este script será executado quando o usuário clicar no botão Ação no KernelSU
│   ├── system.prop         <--- As propriedades neste arquivo serão carregadas como propriedades do sistema por resetprop
│   ├── sepolicy.rule       <--- Regras adicionais do sepolicy personalizadas
│   │
│   │      *** Gerado automaticamente, NÃO CRIE OU MODIFIQUE MANUALMENTE ***
│   │
│   ├── vendor              <--- Um link simbólico para $MODID/system/vendor
│   ├── product             <--- Um link simbólico para $MODID/system/product
│   ├── system_ext          <--- Um link simbólico para $MODID/system/system_ext
│   │
│   │      *** Quaisquer arquivos/pastas adicionais são permitidos ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip DIFERENÇAS COM MAGISK
O KernelSU não possui suporte integrado para o Zygisk, portanto não há conteúdo relacionado ao Zygisk no módulo. No entanto, você pode usar [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) para suportar módulos Zygisk. Neste caso, o conteúdo do módulo Zygisk é idêntico ao suportado pelo Magisk.
:::

### module.prop

`module.prop` é um arquivo de configuração para um módulo. No KernelSU, se um módulo não contiver este arquivo, ele não será reconhecido como um módulo. O formato deste arquivo é o seguinte:

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (opcional)
actionIcon=<path> (opcional)
webuiIcon=<path> (opcional)
```

- `id` deve corresponder a esta expressão regular: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
  Exemplo: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
  Este é o **identificador exclusivo** do seu módulo. Você não deve alterá-lo depois de publicado.
- `versionCode` deve ser um **número inteiro**. Isso é usado para comparar versões.
- Outros que não foram mencionados acima podem ser qualquer string de **linha única**.
- Certifique-se de usar o tipo de quebra de linha `UNIX (LF)` e não o `Windows (CR+LF)` ou `Macintosh (CR)`.
- `actionIcon` e `webuiIcon` são caminhos de imagem opcionais usados como ícones
  padrão para o atalho de ação do módulo e o atalho WebUI do módulo no
  aplicativo gerenciador. Esses caminhos devem ser relativos ao diretório raiz do módulo.
  Por exemplo, `actionIcon=icon/icon.png` será resolvido como `<MODDIR>/icon/icon.png`.

::: tip DESCRIÇÃO DINÂMICA
O campo `description` pode ser substituído dinamicamente em tempo de execução usando o sistema de configuração de módulos. Veja [Substituindo a Descrição do Módulo](module-config.md#overriding-module-description) para detalhes.
:::

### Shell scripts

Por favor, leia a seção [Scripts de inicialização](#scripts-de-inicializacao) para entender a diferença entre `post-fs-data.sh` e `service.sh`. Para a maioria dos desenvolvedores de módulos, `service.sh` deve ser bom o suficiente se você precisar apenas executar um script de inicialização. Se precisar executar o script após a inicialização ser concluída, use `boot-completed.sh`. Se você quiser fazer algo após montar OverlayFS, use `post-mount.sh`.

Em todos os scripts do seu módulo, use `MODDIR=${0%/*}` para obter o caminho do diretório base do seu módulo, **NÃO** codifique o caminho do seu módulo nos scripts.

::: tip DIFERENÇAS COM MAGISK
Você pode usar a variável de ambiente `KSU` para determinar se um script está sendo executado no KernelSU ou Magisk. Se estiver executando no KernelSU, esse valor será definido como `true`.
:::

### Diretório `system`

O conteúdo deste diretório será sobreposto à partição `/system` do sistema usando OverlayFS após a inicialização do sistema. Isso significa que:

1. Arquivos com o mesmo nome daqueles no diretório correspondente no sistema serão substituídos pelos arquivos deste diretório.
2. Pastas com o mesmo nome daquelas no diretório correspondente no sistema serão mescladas com as pastas neste diretório.

Se você deseja excluir um arquivo ou pasta no diretório original do sistema, você precisa criar um arquivo com o mesmo nome do arquivo/pasta no diretório do módulo usando `mknod filename c 0 0`. Dessa forma, o sistema OverlayFS irá automaticamente "branquear" este arquivo como se ele tivesse sido excluído (a partição /system não foi realmente alterada).

Você também pode declarar uma variável chamada `REMOVE` contendo uma lista de diretórios em `customize.sh` para executar operações de remoção, e o KernelSU executará automaticamente `mknod <TARGET> c 0 0` nos diretórios correspondentes do módulo. Por exemplo:

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

A lista acima irá executar `mknod $MODPATH/system/app/YouTube c 0 0` e `mknod $MODPATH/system/app/Bloatware c 0 0`, `/system/app/YouTube` e `/system/app/Bloatware` serão removidos após o módulo entrar em vigor.

Se você deseja substituir um diretório no sistema, você precisa criar um diretório com o mesmo caminho no diretório do módulo e, em seguida, definir o atributo `setfattr -n trusted.overlay.opaque -v y <TARGET>` para este diretório. Desta forma, o sistema OverlayFS substituirá automaticamente o diretório correspondente no sistema (sem alterar a partição /system).

Você pode declarar uma variável chamada `REPLACE` em seu arquivo `customize.sh`, que inclui uma lista de diretórios a serem substituídos, e o KernelSU executará automaticamente as operações correspondentes em seu diretório de módulo. Por exemplo:

```sh
REPLACE="
/system/app/YouTube
/system/app/Bloatware
"
```

Esta lista criará automaticamente os diretórios `$MODPATH/system/app/YouTube` e `$MODPATH/system/app/Bloatware` e, em seguida, executará `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/YouTube` e `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/Bloatware`. Após o módulo entrar em vigor, `/system/app/YouTube` e `/system/app/Bloatware` serão substituídos por diretórios vazios.

::: tip DIFERENÇAS COM MAGISK
O mecanismo sem sistema do KernelSU é implementado através do OverlayFS do kernel, enquanto o Magisk atualmente usa montagem mágica (montagem de ligação). Os dois métodos de implementação têm diferenças significativas, mas o objetivo final é o mesmo: modificar os arquivos `/system` sem modificar fisicamente a partição `/system`.
:::

Se você estiver interessado em OverlayFS, é recomendável ler a [documentação sobre OverlayFS](https://docs.kernel.org/filesystems/overlayfs.html) do kernel Linux.

### system.prop

Este arquivo segue o mesmo formato de `build.prop`. Cada linha é composta por `[key]=[value]`.

### sepolicy.rule

Se o seu módulo exigir alguns patches adicionais do sepolicy, adicione essas regras a este arquivo. Cada linha neste arquivo será tratada como uma declaração de política.

## Instalador do módulo

Um instalador do módulo KernelSU é um módulo KernelSU empacotado em um arquivo ZIP que pode ser atualizado no gerenciador do KernelSU. O instalador do módulo KernelSU mais simples é apenas um módulo KernelSU compactado como um arquivo ZIP.

```txt
module.zip
│
├── customize.sh                       <--- (Opcional, mais detalhes posteriormente)
│                                           Este script será fornecido por update-binary
├── ...
├── ...  /* O resto dos arquivos do módulo */
│
```

::: warning AVISO
O módulo KernelSU **NÃO** é compatível para instalação no Recovery personalizado!
:::

### Personalização

Se você precisar personalizar o processo de instalação do módulo, opcionalmente você pode criar um script no instalador chamado `customize.sh`. Este script será **sourced** (não executado) pelo script do instalador do módulo depois que todos os arquivos forem extraídos e as permissões padrão e o contexto secundário forem aplicados. Isso é muito útil se o seu módulo exigir configuração adicional com base na ABI do dispositivo ou se você precisar definir permissões/secontext especiais para alguns dos arquivos do seu módulo.

Se você quiser controlar e personalizar totalmente o processo de instalação, declare `SKIPUNZIP=1` em `customize.sh` para pular todas as etapas de instalação padrão. Ao fazer isso, seu `customize.sh` será responsável por instalar tudo sozinho.

O script `customize.sh` é executado no shell BusyBox `ash` do KernelSU com o Modo Autônomo ativado. As seguintes variáveis ​​e funções estão disponíveis:

#### Variáveis

- `KSU` (bool): uma variável para marcar que o script está sendo executado no ambiente KernelSU, e o valor desta variável sempre será `true`. Você pode usá-lo para distinguir entre KernelSU e Magisk.
- `KSU_VER` (string): a string da versão do KernelSU atualmente instalado (ex.: `v0.4.0`).
- `KSU_VER_CODE` (int): o código da versão do KernelSU atualmente instalado no espaço do usuário (ex.: `10672`).
- `KSU_KERNEL_VER_CODE` (int): o código da versão do KernelSU atualmente instalado no espaço do kernel (ex.: `10672`).
- `BOOTMODE` (bool): sempre será `true` no KernelSU.
- `MODPATH` (path): o caminho onde os arquivos do seu módulo devem ser instalados.
- `TMPDIR` (path): um lugar onde você pode armazenar arquivos temporariamente.
- `ZIPFILE` (path): ZIP de instalação do seu módulo.
- `ARCH` (string): a arquitetura da CPU do dispositivo. O valor é `arm`, `arm64`, `x86` ou `x64`.
- `IS64BIT` (bool): `true` se `$ARCH` for `arm64` ou `x64`.
- `API` (int): o nível da API (versão do Android) do dispositivo (ex.: `23` para Android 6.0).

::: warning AVISO
No KernelSU, `MAGISK_VER_CODE` é sempre `25200` e `MAGISK_VER` é sempre `v25.2`. Por favor, não use essas duas variáveis ​​para determinar se ele está sendo executado no KernelSU ou não.
:::

#### Funções

```txt
ui_print <msg>
    imprima <msg> no console
    Evite usar 'echo', pois ele não será exibido no console de recovery personalizado

abort <msg>
    imprima mensagem de erro <msg> para consolar e encerrar a instalação
    Evite usar 'exit', pois isso irá pular as etapas de limpeza de encerramento

set_perm <target> <owner> <group> <permission> [context]
    se [context] não estiver definido, o padrão é "u:object_r:system_file:s0"
    esta função é uma abreviação para os seguintes comandos:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    se [context] não está definido, o padrão é "u:object_r:system_file:s0"
    para todos os arquivos em <directory>, ele chamará:
       set_perm arquivo proprietário do grupo filepermission
    para todos os diretórios em <directory> (incluindo ele mesmo), ele vai ligar:
       set_perm dir owner group dirpermission context
```

## Scripts de inicialização

No KernelSU, os scripts são divididos em dois tipos com base em seu modo de execução: modo post-fs-data e modo de serviço late_start.

- modo post-fs-data
  - Esta etapa está BLOQUEANDO. O processo de inicialização é pausado antes da conclusão da execução ou após 10 segundos.
  - Os scripts são executados antes de qualquer módulo ser montado. Isso permite que um desenvolvedor de módulo ajuste dinamicamente seus módulos antes de serem montados.
  - Este estágio acontece antes do início do Zygote, o que significa praticamente tudo no Android.
  - **AVISO:** Usar `setprop` irá bloquear o processo de inicialização! Por favor, use `resetprop -n <prop_name> <prop_value>` em vez disso.
  - **Execute scripts neste modo apenas se necessário**.
- modo de serviço late_start
  - Esta etapa é SEM BLOQUEIO. Seu script é executado em paralelo com o restante do processo de inicialização.
  - **Este é o estágio recomendado para executar a maioria dos scripts**.

No KernelSU, os scripts de inicialização são divididos em dois tipos com base no local de armazenamento: scripts gerais e scripts de módulo.

- Scripts gerais
  - Colocado em `/data/adb/post-fs-data.d`, `/data/adb/service.d`, `/data/adb/post-mount.d` ou `/data/adb/boot-completed.d`.
  - Somente executado se o script estiver definido como executável (`chmod +x script.sh`).
  - Os scripts em `post-fs-data.d` são executados no modo post-fs-data e os scripts em `service.d` são executados no modo de serviço late_start.
  - Os módulos **NÃO** devem adicionar scripts gerais durante a instalação.
- Scripts de módulo
  - Colocado na própria pasta do módulo.
  - Executado apenas se o módulo estiver ativado.
  - `post-fs-data.sh` é executado no modo post-fs-data, `service.sh` é executado no modo de serviço late_start, `boot-completed.sh` é executado na inicialização concluída e `post-mount.sh` é executado no OverlayFS montado.

Todos os scripts de inicialização serão executados no shell BusyBox `ash` do KernelSU com o Modo Autônomo ativado.

### Explicação do processo de scripts de inicialização

A seguir está o processo de inicialização relevante para o Android (algumas partes foram omitidas), que inclui a operação do KernelSU (com asteriscos iniciais) e pode ajudá-lo a entender melhor o propósito desses scripts de módulo:

```txt
0. Bootloader (nada nesta tela)
load patched boot.img
load kernel:
    - Modo GKI: kernel GKI com KernelSU integrado
    - Modo LKM: kernel stock
...

1. kernel exec init (logo OEM na tela):
    - Modo GKI: stock init
    - Modo LKM: exec ksuinit, insmod kernelsu.ko, exec stock init
mount /dev, /dev/pts, /proc, /sys, etc.
property-init -> read default props
read init.rc
...
early-init -> init -> late_init
early-fs
   start vold
fs
  mount /vendor, /system, /persist, etc.
post-fs-data
  *verificação do modo de segurança
  *executar scripts gerais em post-fs-data.d/
  *carregar sepolicy.rule
  *montar tmpfs
  *executar scripts de módulo post-fs-data.sh
    **(Zygisk)./bin/zygisk-ptrace64 monitor
  *(pré)carregamento de system.prop (igual a resetprop -n)
  *remontar módulos em /system
  *executar scripts gerais em post-mount.d/
  *executar scripts de módulo post-mount.sh
zygote-start
load_all_props_action
  *executar resetprop (defina adereços reais para resetprop com a opção -n)
... -> boot
  class_start core
    start-service logd, console, vold, etc.
  class_start main
    start-service adb, netd (iptables), zygote, etc.

2. kernel2user init (animação da ROM na tela, inicie pelo serviço bootanim)
*executar scripts gerais em service.d/
*executar scripts de módulo service.sh
*definir adereços para resetprop sem a opção -p
  **(Zygisk) hook zygote (iniciar o zygiskd)
  **(Zygisk) montar zygisksu/module.prop
iniciar apps do sistema (início automático)
...
inicialização completa (transmitir evento ACTION_BOOT_COMPLETED)
*executar scripts gerais em boot-completed.d/
*executar scripts de módulo boot-completed.sh

3. Operável pelo usuário (tela de bloqueio)
insira a senha para descriptografar /data/data
*conjunto real de adereços para resetprop com opção -p
iniciar apps de usuário (início automático)
```

Se você estiver interessado na linguagem de inicialização do Android, é recomendável ler sua [documentação](https://android.googlesource.com/platform/system/core/+/master/init/README.md).

```

`website/docs/pt_BR/guide/rescue-from-bootloop.md`:

```md
# Resgate do bootloop

Ao atualizar um dispositivo, podem ocorrer situações em que o dispositivo fica "bloqueado". Em teoria, se você usar o fastboot apenas para atualizar a partição boot ou instalar módulos inadequados que causam falha na inicialização do dispositivo, isso pode ser restaurado por meio de operações apropriadas. Este documento tem como objetivo fornecer alguns métodos de emergência para ajudá-lo a recuperar um dispositivo "bloqueado".

## Bloqueio por flashar partição boot

No KernelSU, as seguintes situações podem causar bloqueio de inicialização ao flashar a partição boot:

1. Você flashou uma imagem boot no formato errado. Por exemplo, se o formato de boot do seu dispositivo for `gz`, mas você flashou uma imagem no formato `lz4`, o dispositivo não inicializá.
2. Seu dispositivo precisa desativar a verificação AVB para inicializar corretamente, o que geralmente exige a limpeza de todos os dados do dispositivo.
3. Seu kernel tem alguns bugs ou não é adequado para o flash do seu dispositivo.

Não importa qual seja a situação, você pode recuperar **flashando a imagem de boot padrão**. Portanto, no início do guia de instalação, recomendamos fortemente que você faça backup de seu boot padrão antes de realizar o flash. Se você não fez backup, poderá obter o boot original de fábrica de outros usuários com o mesmo dispositivo ou do firmware oficial.

## Bloqueio por módulos

A instalação de módulos pode ser uma das causas mais comuns de bloqueio do seu dispositivo, mas devemos alertá-lo seriamente: **NÃO INSTALE MÓDULOS DE FONTES DESCONHECIDAS!** Como os módulos têm privilégios root, eles podem causar danos irreversíveis ao seu dispositivo!

### Módulos normais

Se você instalou um módulo que foi comprovadamente seguro, mas faz com que seu dispositivo não inicialize, então esta situação é facilmente recuperável no KernelSU sem qualquer preocupação. O KernelSU possui mecanismos integrados para recuperar seu dispositivo, incluindo o seguinte:

1. Atualização AB
2. Recupere pressionando o botão de diminuir volume

#### Atualização AB

As atualizações do módulo KernelSU são baseadas no mecanismo de atualização AB do sistema Android usado em atualizações OTA. Quando você instala um novo módulo ou atualiza um existente, isso não modifica diretamente o arquivo do módulo atualmente em uso. Em vez disso, todos os módulos são integrados em uma nova imagem de atualização. Após o sistema ser reiniciado, ele tentará iniciar usando essa nova imagem de atualização. Se o sistema Android inicializar com sucesso, os módulos serão efetivamente atualizados.

Portanto, o método mais simples e comumente usado para recuperar seu dispositivo é **forçar uma reinicialização**. Se você não conseguir iniciar o sistema após instalar um módulo, pode pressionar e segurar o botão liga/desliga por mais de 10 segundos, e o sistema será reiniciado automaticamente. Após a reinicialização, ele retornará ao estado anterior à atualização do módulo, e os módulos atualizados serão desativados automaticamente.

#### Recupere pressionando o botão de diminuir volume

Se a Atualização AB ainda não resolveu o problema, você pode tentar usar o **Modo de Segurança**. Nesse modo, todos os módulos são desativados.

Existem duas maneiras de entrar no Modo de Segurança:

1. O Modo de Segurança integrado de alguns sistemas: Alguns sistemas possuem um Modo de Segurança integrado que pode ser acessado pressionando longamente o botão de diminuir volume. Em outros sistemas (como o HyperOS), o Modo de Segurança pode ser ativado a partir do Recovery. Ao entrar no Modo de Segurança do sistema, o KernelSU também entrará nesse modo e desativará automaticamente os módulos.
2. O Modo de Segurança integrado do KernelSU: Nesse caso, o método é **pressionar a tecla de diminuir volume continuamente por mais de três vezes** após a primeira tela de inicialização.

Após entrar no Modo de Segurança, todos os módulos na página Módulos do gerenciador do KernelSU serão desativados. Porém, você ainda pode realizar a operação de "desinstalação" para desinstalar quaisquer módulos que possam estar causando problemas.

O Modo de Segurança integrado é implementado no kernel, portanto não há possibilidade de perder eventos importantes devido à interceptação. No entanto, para kernels não-GKI, pode ser necessária uma integração manual do código. Para isso, consulte a documentação oficial para orientações.

### Módulos maliciosos

Se os métodos acima não conseguirem recuperar seu dispositivo, é muito provável que o módulo que você instalou tenha operações maliciosas ou tenha danificado seu dispositivo de outra forma. Nesse caso, há apenas duas sugestões:

1. Limpar os dados e instalar o sistema oficial.
2. Consultar o serviço pós-venda.

```

`website/docs/pt_BR/guide/unofficially-support-devices.md`:

```md
# Dispositivos com suporte não oficial

::: warning AVISO
Este documento é apenas para referência de arquivo e não é mais mantido.
Desde o KernelSU v1.0, abandonamos o suporte oficial para dispositivos não-GKI.
:::

::: warning AVISO
Nesta página, existem kernels para dispositivos não-GKI que suportam o KernelSU mantidos por outros desenvolvedores.
:::

::: warning AVISO
Esta página é destinada apenas para ajudá-lo a encontrar o código-fonte correspondente ao seu dispositivo. **NÃO** significa que o código-fonte foi revisado pelos desenvolvedores do KernelSU. Você deve usá-lo por sua própria conta e risco.
:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>Mantenedor</th>
         <th>Repositório</th>
         <th>Dispositivos suportados</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>

```

`website/docs/pt_BR/guide/what-is-kernelsu.md`:

```md
# O que é KernelSU?

O KernelSU é uma solução root para dispositivos Android GKI, funciona no modo kernel e concede privilégios root para apps do espaço do usuário diretamente no espaço do kernel.

## Características

A principal característica do KernelSU é que ele é **baseado em kernel**. O KernelSU funciona no modo kernel, portanto pode fornecer uma interface de kernel que nunca tivemos antes. Por exemplo, é possível adicionar pontos de interrupção de hardware a qualquer processo no modo kernel, acessar a memória física de qualquer processo de forma invisível, interceptar qualquer chamada de sistema (syscall) no espaço do kernel, entre outras funcionalidades.

Além disso, o KernelSU fornece um [sistema metamodule](metamodule.md), que é uma arquitetura plugável para gerenciamento de módulos. Diferente das soluções root tradicionais que integram a lógica de montagem em seu núcleo, o KernelSU delega isso aos metamodules. Isso permite que você instale metamodules como [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs) para fornecer modificações systemless na partição `/system` e outras partições.

## Como usar o KernelSU?

Por favor, consulte: [Instalação](installation)

## Como compilar o KernelSU?

Por favor, consulte: [Como compilar](how-to-build)

## Discussão

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/pt_BR/index.md`:

```md
---
layout: home
title: Início

hero:
  name: KernelSU
  text: Uma solução root baseada em kernel para Android
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: Iniciar
      link: /pt_BR/guide/what-is-kernelsu
    - theme: alt
      text: Ver no GitHub
      link: https://github.com/tiann/KernelSU

features:
  - title: Baseado em kernel
    details: Como o nome sugere, KernelSU funciona no kernel Linux, dando-lhe mais controle sobre os apps do espaço do usuário.
  - title: Controle de acesso root
    details: Somente apps permitidos podem acessar ou ver su, todos os outros apps não estão cientes disso.
  - title: Privilégios root personalizáveis
    details: KernelSU permite a personalização de su, uid, gid, grupos, capacidades e regras do SELinux, bloqueando privilégios root.
  - title: Sistema Metamodule
    details: Infraestrutura de módulos plugável permite modificações systemless em /system. Instale um metamodule como meta-overlayfs para habilitar a montagem de módulos.

```

`website/docs/public/ads.txt`:

```txt
google.com, pub-8356785667482909, DIRECT, f08c47fec0942fa0
```

`website/docs/public/templates/adaway.root`:

```root
{
    "id":"adaway.root",
    "name":"Adaway Root",
    "author":"JohnRTitor",
    "description":"Only essential permissions to let Adaway modify hosts file and operate a web server.",
    "uid":0,
    "gid":0,
    "groups":[
        "ROOT"
    ],
    "capabilities":[
        "CAP_DAC_OVERRIDE",
        "CAP_NET_BIND_SERVICE",
        "CAP_SYS_PTRACE"
    ],
    "context":"u:r:su:s0",
    "namespace":"INHERITED",
    "locales": {
        "zh_TW": {
            "name": "Adaway Root",
            "description": "僅允許 Adaway 修改 hosts 和執行 Web 伺服器的必要權限"
        },
        "bn": {
            "name": "অ্যাডঅ্যাওয়ে রুট",
            "description": "অ্যাডঅ্যাওয়ে সিস্টেমের হোস্ট ফাইল পরিবর্তন এবং ওয়েবসার্ভার চালু করতে কমপক্ষে যা অনুমতি লাগে।"
        },
        "pt_BR": {
            "name": "Adaway Root",
            "description": "Apenas permissões essenciais para permitir que Adaway modifique o arquivo hosts e opere um servidor web."
        },
        "tr": {
            "name": "Adaway Root",
            "description": "Adaway'in hosts dosyasını değiştirmesine ve bir web sunucusunu çalıştırmasına izin vermek için gerekli izinler."
        },
        "it_IT": {
            "name": "Adaway Root",
            "description": "Concede le autorizzazioni essenziali affinché Adaway possa modificare il file host e gestire un server web. "
        }        
    }
}

```

`website/docs/public/templates/adb`:

```
{
    "id":"adb",
    "name":"Adb",
    "author":"kernelsu.org",
    "description":"Minimal rules required by most apps using ADB privilege.",
    "uid":2000,
    "gid":2000,
    "groups":[
        "ADB"
    ],
    "locales": {
        "bn": {
            "name": "এডিবি",
            "description": "নূন্যতম অনুমতি যার দ্বারা এডিবি স্বচ্ছন্দে কাজ করতে পারে।"
        },
        "zh_CN": {
            "name": "Adb 模版",
            "description": "大多数使用 ADB 权限应用所需要的最小权限"
        },
        "zh_TW": {
            "name": "Adb",
            "description": "大多數使用 ADB 權限應用程式所需要的最低權限"
        },
        "tr": {
            "name": "Adb",
            "description": "ADB ayrıcalığını kullanan çoğu uygulama için gereken minimum kurallar."
        },
        "pt_BR": {
            "name": "Adb",
            "description": "Regras mínimas exigidas pela maioria dos apps que usam privilégio ADB."
        },
        "ja": {
            "name": "Adb",
            "description": "ほとんどのアプリが使用するために必要な最小限のルール ADB."
        },
        "it_IT": {
            "name": "Adb",
            "description": "Autorizzazioni minime richieste dalla maggior parte delle app che usano i privilegi di ADB."
        } 
    }
}

```

`website/docs/public/templates/cemiuiler.readproc`:

```readproc
{
    "id":"cemiuiler.readproc",
    "name":"Cemiuiler",
    "author":"refined-fish",
    "description":"Grant Cemiuiler the minimum permissions to work properly-to restart the app.",
    "namespace":"INHERITED",
    "uid":10000,
    "gid":10000,
    "groups":[
        "READPROC"
    ],
    "capabilities":[
        "CAP_KILL"
    ],
    "context":"u:r:su:s0",
    "rules":"",
    "locales": {
        "bn": {
            "name": "সিমিউলার",
            "description": "নূন্যতম অনুমতি যার দ্বারা সিমিউলার আবার কাজে বহাল হতে পারে।"
        },
        "zh_CN": {
            "name": "西米露Cemiuiler",
            "description": "授予Cemiuiler能正常工作——重启作用域应用的最小限度权限。"
        },
        "zh_TW": {
            "name": "Cemiuiler",
            "description": "授予Cemiuiler能正常運作－重啟作用域應用程式的最低權限"
        },
        "tr": {
            "name": "Cemiuiler",
            "description": "Cemiuiler uygulamasına düzgün çalışması için minimum izinleri verin."
        },
        "pt_BR": {
            "name": "Cemiuiler",
            "description": "Conceda ao Cemiuiler as permissões mínimas para funcionar corretamente para reiniciar o app."
        },
        "ja": {
            "name": "Cemiuiler",
            "description": "Cemiuiler に適切に動作するための最小限の権限を付与し、アプリケーションを再起動します。"
        },
        "it_IT": {
            "name": "Cemiuiler",
            "description": "Concedi a Cemiuiler le autorizzazioni minime per riavviare correttamente l'applicazione."
        } 
    }
}

```

`website/docs/public/templates/hyperceiler.root`:

```root
{
    "id":"hyperceiler.root",
    "name":"HyperCeiler Official Root Template",
    "author":"github@lingqiqi5211",
    "description":"Minimum permissions to ensure HyperCeiler main functions work properly.",
    "namespace":"INHERITED",
    "uid":0,
    "gid":0,
    "groups":[
        "ROOT"
    ],
    "capabilities":[
        "CAP_DAC_OVERRIDE",
        "CAP_FOWNER",
        "CAP_KILL",
        "CAP_SYS_CHROOT",
        "CAP_SYS_PTRACE",
        "CAP_SYS_ADMIN",
        "CAP_SYS_BOOT",
        "CAP_SETFCAP",
        "CAP_BLOCK_SUSPEND"
    ],
    "context":"u:r:su:s0",
    "rules":"",
    "locales": {
        "zh_CN": {
            "name": "HyperCeiler 官方 Root 模板",
            "description": "能保证 HyperCeiler 主要功能运行的最小权能"
        },
        "zh_TW": {
            "name": "HyperCeiler 官方 Root 範本",
            "description": "能保證 HyperCeiler 主要功能運作的最小權能"
        },
        "bn": {
            "name": "হাইপারসিলার অফিসিয়াল রুট টেমপ্লেট",
            "description": "হাইপারসিলারের মূল কার্যকারিতা নিশ্চিত করতে ন্যূনতম অনুমতি।"
        },
        "tr": {
            "name": "HyperCeiler Resmi Root Şablonu",
            "description": "HyperCeiler'in ana işlevlerinin düzgün çalışmasını sağlamak için minimum izinler."
        },
        "pt_BR": {
            "name": "Modelo Root Oficial do HyperCeiler",
            "description": "Permissões mínimas para garantir que as funções principais do HyperCeiler funcionem corretamente."
        },
        "ja": {
            "name": "HyperCeiler 公式 Root テンプレート",
            "description": "HyperCeiler の主要機能が正常に動作するための最小限の権限。"
        },
        "it_IT": {
            "name": "Modello Root Ufficiale di HyperCeiler",
            "description": "Autorizzazioni minime per garantire il corretto funzionamento delle funzioni principali di HyperCeiler."
        }
    }
}

```

`website/docs/public/templates/incompetent.root`:

```root
{
    "id":"incompetent.root",
    "name":"Incompetent root",
    "author":"kernelsu.org",
    "description":"A incompetent root user without any capability.",
    "uid":0,
    "gid":0,
    "groups":[
        "ROOT"
    ],
    "locales": {
        "bn": {
            "name": "অযোগ্য রুট ইউজার",
            "description": "অযোগ্য রুট ইউজার যার কোনো স্পেশাল ক্ষমতা নেই।"
        },
        "zh_CN": {
            "name": "无能的 Root",
            "description": "无任何权能的 root 用户。"
        },
        "zh_TW": {
            "name": "無能的 Root",
            "description": "無任何權限的 root"
        },
        "tr": {
            "name": "Yetersiz root",
            "description": "Herhangi bir özelliği olmayan yetersiz bir root kullanıcısı."
        },
        "pt_BR": {
            "name": "Root incompetente",
            "description": "Um usuário root incompetente sem qualquer capacidade."
        },
        "ja": {
            "name": "無能な root",
            "description": "権限のない root ユーザー。"
        },
        "it_IT": {
            "name": "Root incompetente",
            "description": "Un utente root senza nessuna capacità."
        } 
    }
}

```

`website/docs/public/templates/kernelmanager.root`:

```root
{
    "id":"kernelmanager.root",
    "name":"Kernel Manager",
    "author":"Rem01Gaming",
    "description":"Commonly used in Kernel managers such as FKM and SmartPack.",
    "uid":0,
    "gid":0,
    "groups":[
        "ROOT",
        "READPROC"
    ],
    "capabilities":[
        "CAP_KILL",
        "CAP_SYSLOG",
        "CAP_SYS_BOOT",
        "CAP_DAC_OVERRIDE"
    ],
    "context":"u:r:su:s0",
    "namespace":"INHERITED",
    "locales": {
        "bn": {
            "name": "কার্নেল ম্যানেজার",
            "description": "এফ কে এম বা স্মার্টপ্যাক কার্নেল ম্যানেজারের যে অনুমতি লাগে।"
        },
        "zh_TW": {
            "name": "核心管理器",
            "description": "常用於 FKM 和 SmartPack 等核心管理器"
        },
        "in": {
            "name": "Kernel Manager",
            "description": "Umumnya digunakan pada Kernel manager seperti FKM dan SmartPack."
        },
        "tr": {
            "name": "Kernel Yöneticisi",
            "description": "FKM ve SmartPack gibi Kernel Yöneticilerinde yaygın olarak kullanılır."
        },
        "pt_BR": {
            "name": "Gerenciador de Kernel",
            "description": "Comumente usado em gerenciadores de Kernel como FKM e SmartPack."
        },
        "ja": {
            "name": "Kernel マネージャー",
            "description": "FKM や SmartPack などの XXX マネージャーでよく使用されます。"
        },
        "it_IT": {
            "name": "Gestore Kernel",
            "description": "Autorizzazioni comunemente richieste in applicazioni per gestire il Kernel come FKM e SmartPack."
        } 
    }
}

```

`website/docs/public/templates/nethunter.root`:

```root
{
    "id": "nethunter.root",
    "name": "Kali NetHunter",
    "author": "cachiusa",
    "description": "Required permissions for Kali NetHunter app to chroot.",
    "namespace": "INHERITED",
    "uid": 0,
    "gid": 0,
    "groups": [
        "ROOT"
    ],
    "capabilities": [
        "CAP_DAC_OVERRIDE",
        "CAP_DAC_READ_SEARCH",
        "CAP_SYS_CHROOT",
        "CAP_SYS_PTRACE",
        "CAP_SYS_ADMIN",
        "CAP_SETGID"
    ],
    "context": "u:r:su:s0",
    "locales": {
        "bn": {
            "name": "কালি নেটহানটার",
            "description": "কালি নেটহানটার অ্যাপের কার্যকলাপের জন্য যে অনুমতিগুলি লাগে।"
        },
        "zh_TW": {
            "name": "Kali NetHunter",
            "description": "提供Kali NetHunter使用chroot"
        },
        "pt_BR": {
            "name": "Kali NetHunter",
            "description": "Permissões necessárias para o app Kali NetHunter fazer chroot."
        },
        "it_IT": {
            "name": "Kali NetHunter",
            "description": "Autorizzazioni richieste per il chroot dell'applicazione Kali NetHunter."
        } 
    }
}

```

`website/docs/public/templates/rootexploler.root`:

```root
{
    "id":"rootexploler.root",
    "name":"Root Explorer",
    "author":"Rem01Gaming",
    "description":"File manager with Root capabilities.",
    "uid":0,
    "gid":0,
    "groups":[
        "ROOT"
    ],
    "capabilities":[
        "CAP_DAC_READ_SEARCH",
        "CAP_DAC_OVERRIDE",
        "CAP_SYS_ADMIN"
    ],
    "context":"u:r:su:s0",
    "namespace":"INHERITED",
    "locales": {
        "bn": {
            "name": "রুট এক্সপ্লোরার",
            "description": "রুট অনুমতি যুক্ত ফাইল ম্যানেজার।"
        },
        "zh_TW": {
            "name": "Root Explorer",
            "description": "具有根目錄讀寫權限的檔案管理器"
        },
        "in": {
            "name": "Root Explorer",
            "description": "File manager dengan kemampuan Root."
        },
        "tr": {
            "name": "Root Dosya Tarayıcı",
            "description": "Root özelliklerine sahip dosya yöneticisi."
        },
        "pt_BR": {
            "name": "Explorador root",
            "description": "Gerenciador de arquivos com recursos root."
        },
        "ja": {
            "name": "Root ブラウザ",
            "description": "Root 機能を備えたファイル マネージャー。"
        },
        "it_IT": {
            "name": "Gestore file root",
            "description": "Gestore file con permessi root."
        } 
    }
}

```

`website/docs/public/templates/shizuku.root`:

```root
{
    "id":"shizuku.root",
    "name":"Shizuku Service",
    "author":"Rem01Gaming & JohnRTitor",
    "description":"Only essential permissions to start Shizuku service. Shizuku modules aren't guaranteed to work.",
    "uid":0,
    "gid":0,
    "groups":[
        "SHELL"
    ],
    "capabilities":[
        "CAP_DAC_OVERRIDE",
        "CAP_CHOWN"
    ],
    "context":"u:r:su:s0",
    "namespace":"INHERITED",
    "locales": {
        "zh_TW": {
            "name": "Shizuku",
            "description": "只有啟動 Shizuku 服務所需的權限"
        },
        "bn": {
            "name": "শিজুকু সার্ভিস",
            "description": "শিজুকু চালানোর জন্য শুধু যে অনুমতি গুলি লাগে।"
        },
        "tr": {
            "name": "Shizuku",
            "description": "Shizuku servisini başlatmak için yalnızca gerekli izinler."
        },
        "pt_BR": {
            "name": "Shizuku",
            "description": "Apenas permissões essenciais para iniciar o serviço Shizuku. Não há garantia de que os módulos Shizuku funcionem."
        },
        "ja": {
            "name": "Shizuku",
            "description": "Shizuku サービスを開始するために必要な権限のみ。"
        },
        "it_IT": {
            "name": "Shizuku",
            "description": "Permessi essenziali per avviare il servizio Shizuku."
        } 
    }
}

```

`website/docs/public/templates/system`:

```
{
    "id":"system",
    "author":"kernelsu.org",
    "name":"System",
    "description":"The permission level at which the Android system runs without any capability.",
    "uid":1000,
    "gid":1000,
    "groups":[
        "SYSTEM"
    ],
    "locales": {
        "bn": {
            "name": "সিস্টেম",
            "description": "অ্যান্ড্রয়েড সিস্টেম যে অনুমতিগুলি নিয়ে কাজ করে।"
        },
        "zh_CN": {
            "name": "Android 系统",
            "description": "Android 系统运行的权限级别，但没有任何权能。"
        },
        "zh_TW": {
            "name": "Android 系統",
            "description": "Android 系統運作的權限級別，但沒有任何權能"
        },
        "tr": {
            "name": "Sistem",
            "description": "Android sisteminin herhangi bir yetenek olmadan çalıştığı izin düzeyi."
        },
        "pt_BR": {
            "name": "Sistema",
            "description": "O nível de permissão no qual o sistema Android é executado sem qualquer capacidade."
        },
        "ja": {
            "name": "System",
            "description": "Android システムが実行される許可レベルですが、機能はありません。"
        },
        "it_IT": {
            "name": "Sistema",
            "description": "Il livello di permessi con il quale viene eseguito il sistema operativo Android senza alcuna capacità."
        } 
    }
}

```

`website/docs/public/templates/wireguard.root`:

```root
{
    "id":"wireguard.root",
    "name":"Wireguard kernel module function",
    "author":"hotfur",
    "description":"Essential permissions for a working Wireguard kernel module backend. The optional Wireguard command line tools installation requires DAC_OVERRIDE for writing binaries to /system/bin. Because it is optional for operation, DAC_OVERRIDE is not granted here but you can grant the capability temporarily then revoke it after the app installed the command line binaries.",
    "uid":0,
    "gid":0,
    "groups":[
        "ROOT"
    ],
    "capabilities":[
        "CAP_DAC_READ_SEARCH",
        "CAP_NET_ADMIN",
        "CAP_NET_RAW"
    ],
    "context":"u:r:su:s0",
    "namespace":"INHERITED",
    "locales": {
        "pt_BR": {
            "name": "Função do módulo kernel Wireguard",
            "description": "Permissões essenciais para um backend funcional do módulo do kernel do Wireguard. A instalação opcional das ferramentas da linha de comando do Wireguard requer DAC_OVERRIDE para gravar binários em /system/bin. Como é opcional para a operação, DAC_OVERRIDE não é concedido aqui, mas você pode conceder o recurso temporariamente e revogá-lo após o app instalar os binários da linha de comando."
        }
    }
}

```

`website/docs/repos.json`:

```json
[
    {
        "maintainer": "diphons",
        "maintainer_link": "https://github.com/diphons",
        "kernel_name": "kernel_xiaomi_sm8250",
        "kernel_link": "https://github.com/diphons/kernel_xiaomi_sm8250/tree/main",
        "devices": "Poco F3: alioth | Poco F4: munch | MI10T/PRO: Apollo"
    },
    {
        "maintainer": "diphons",
        "maintainer_link": "https://github.com/diphons",
        "kernel_name": "D8G_Kernel_SM8150",
        "kernel_link": "https://github.com/diphons/D8G_Kernel_SM8150/tree/13",
        "devices": "Poco X3 Pro: Vayu | Bhima"
    },
    {
        "maintainer": "diphons",
        "maintainer_link": "https://github.com/diphons",
        "kernel_name": "kernel_xiaomi_sdm845",
        "kernel_link": "https://github.com/diphons/kernel_xiaomi_sdm845/tree/main",
        "devices": "Poco F1"
    },
    {
        "maintainer": "diphons",
        "maintainer_link": "https://github.com/diphons",
        "kernel_name": "kernel_xiaomi_sm8350",
        "kernel_link": "https://github.com/diphons/kernel_xiaomi_sm8350/tree/15",
        "devices": "MI11T Pro: vili"
    },
    {
        "maintainer": "diphons",
        "maintainer_link": "https://github.com/diphons",
        "kernel_name": "D8G_Kernel_Marble",
        "kernel_link": "https://github.com/diphons/D8G_Kernel_Marble/tree/op",
        "devices": "Poco F5 | Redmi Note 12 Turbo | Marble"
    },
    {
        "maintainer": "diphons",
        "maintainer_link": "https://github.com/diphons",
        "kernel_name": "kernel_xiaomi_sm8635",
        "kernel_link": "https://github.com/diphons/kernel_xiaomi_sm8635/tree/main",
        "devices": "Poco F6: peridot"
    },
    {
        "maintainer": "th1nhhdk",
        "maintainer_link": "https://github.com/th1nhhdk",
        "kernel_name": "android_kernel_sony_sm8250-kernelsu",
        "kernel_link": "https://github.com/th1nhhdk/android_kernel_sony_sm8250-kernelsu",
        "devices": "Sony Xperia 1 II | Sony Xperia 5 II"
    },
    {
        "maintainer": "akash07k",
        "maintainer_link": "https://github.com/akash07k",
        "kernel_name": "nexus_kernel_xiaomi_sm8250",
        "kernel_link": "https://github.com/akash07k/nexus_kernel_xiaomi_sm8250/tree/lychee",
        "devices": "Poco F4: munch"
    },
    {
        "maintainer": "Hadad",
        "maintainer_link": "https://xdaforums.com/m/hadad.8351572/",
        "kernel_name": "android_kernel_xiaomi_onc",
        "kernel_link": "https://github.com/hadadarjt/android_kernel_xiaomi_onc/tree/los21-KSU/local-non-gerrit-review",
        "devices": "Redmi 7: onclite | Redmi Y3: onc"
    },
    {
        "maintainer": "HMTheBoy154",
        "maintainer_link": "https://github.com/hmtheboy154",
        "kernel_name": "Darkmatter-kernel",
        "kernel_link": "https://github.com/hmtheboy154/Darkmatter-kernel",
        "devices": "Generic x86_64 devices running Android-x86"
    },
    {
        "maintainer": "Asuka-mio",
        "maintainer_link": "https://github.com/asuka-mio",
        "kernel_name": "android_kernel_xiaomi_cas",
        "kernel_link": "https://github.com/AcmeUI-Devices/android_kernel_xiaomi_cas",
        "devices": "Mi 10 Ultra: cas"
    },
    {
        "maintainer": "xiaoleGun",
        "maintainer_link": "https://github.com/xiaoleGun",
        "kernel_name": "Miku_kernel_xiaomi_wayne",
        "kernel_link": "https://github.com/Diva-Room/Miku_kernel_xiaomi_wayne",
        "devices": "wayne"
    },
    {
        "maintainer": "SakuraNotStupid",
        "maintainer_link": "https://github.com/SakuraKyuo",
        "kernel_name": "android_kernel_xiaomi_sdm710",
        "kernel_link": "https://github.com/SakuraKyuo/android_kernel_xiaomi_sdm710",
        "devices": "Xiaomi MI 8 SE(sirius/xmsirius)"
    },
    {
        "maintainer": "zlm324",
        "maintainer_link": "https://github.com/zlm324",
        "kernel_name": "android_kernel_xiaomi_msm8998",
        "kernel_link": "https://github.com/zlm324/android_kernel_xiaomi_msm8998_ksu",
        "devices": "MI 6 (sagit) and MIX 2 (chiron) for LineageOS"
    },
    {
        "maintainer": "SlackerState",
        "maintainer_link": "https://github.com/SlackerState",
        "kernel_name": "android_kernel_xiaomi_sm6150",
        "kernel_link": "https://github.com/SlackerState/android_kernel_xiaomi_sm6150",
        "devices": "Redmi K30 4G (phoenix)"
    },
    {
        "maintainer": "RooGhz720",
        "maintainer_link": "https://github.com/RooGhz720",
        "kernel_name": "kernel_xiaomi_sm6150",
        "kernel_link": "https://github.com/RooGhz720/kernel_xiaomi_sm6150",
        "devices": "REDMI NOTE 10 PRO (sweet)"
    },
    {
        "maintainer": "OnlyTomInSecond",
        "maintainer_link": "https://github.com/onlyTomInSecond/",
        "kernel_name": "android_kernel_xiaomi_sdm845",
        "kernel_link": "https://github.com/OnlyTomInSecond/android_kernel_xiaomi_sdm845",
        "devices": "Mi 8 (dipper) for LineageOS"
    },
    {
        "maintainer": "Rohail33",
        "maintainer_link": "https://github.com/Rohail33",
        "kernel_name": "RealKing Kernel",
        "kernel_link": "https://github.com/Rohail33/Realking_kernel_sm8250",
        "devices": "Apollo(Redmi K30S Ultra/Mi 10T/Mi 10T Pro)\uff0cAlioth(Redmi K40/POCO F3/Mi 11X)\uff0cMunch(Redmi K40S/POCO F4), both MIUI and AOSP."
    },
    {
        "maintainer": "Sreeshankar K",
        "maintainer_link": "https://github.com/sreeshankark",
        "kernel_name": "NeverSettle Kernel",
        "kernel_link": "https://github.com/sreeshankark/android_kernel_oneplus_avicii",
        "devices": "OnePlus Nord (avicii)"
    },
    {
        "maintainer": "PSavarMattas",
        "maintainer_link": "https://github.com/psavarmattas",
        "kernel_name": "PSM Kernel",
        "kernel_link": "https://github.com/psavarmattas/android_kernel_oneplus_sm7250-WKSU",
        "devices": "OnePlus Nord (avicii)"
    },
    {
        "maintainer": "Molyuu",
        "maintainer_link": "https://github.com/Molyuu",
        "kernel_name": "neko_kernel_xiaomi_gauguin",
        "kernel_link": "https://github.com/Molyuu/neko_kernel_xiaomi_gauguin",
        "devices": "Redmi Note 9 Pro/ Mi 10T Lite/ Mi 10i "
    },
    {
        "maintainer": "guh0613",
        "maintainer_link": "https://github.com/guh0613",
        "kernel_name": "android_kernel_oppo_sm8150",
        "kernel_link": "https://github.com/guh0613/android_kernel_oppo_sm8150",
        "devices": "OPPO Reno Ace (OP4A89)"
    },
    {
        "maintainer": "LeviMarvin",
        "maintainer_link": "https://github.com/LeviMarvin",
        "kernel_name": "android_kernel_xiaomi_alioth",
        "kernel_link": "https://github.com/LeviMarvin/android_kernel_xiaomi_alioth",
        "devices": "Redmi K40 / POCO F3"
    },
    {
        "maintainer": "cibimo",
        "maintainer_link": "https://github.com/cibimo",
        "kernel_name": "kernel_xiaomi_raphael_ksu",
        "kernel_link": "https://github.com/cibimo/kernel_xiaomi_raphael_ksu",
        "devices": "Xiaomi Redmi K20 Pro / Mi 9T Pro (raphael)"
    },
    {
        "maintainer": "EndCredits",
        "maintainer_link": "https://github.com/EndCredits",
        "kernel_name": "kernel_xiaomi_sm7250",
        "kernel_link": "https://github.com/EndCredits/kernel_xiaomi_sm7250",
        "devices": "Redmi K30 5G ( picasso ) , Redmi K30i 5G ( picasso_48m)"
    },
    {
        "maintainer": "msnx",
        "maintainer_link": "https://github.com/msnx",
        "kernel_name": "android-msm-coral-4.14-android13",
        "kernel_link": "https://github.com/msnx/KernelSU-Pixel4XL",
        "devices": "Pixel 4 XL"
    },
    {
        "maintainer": "SoDebug",
        "maintainer_link": "https://github.com/SoDebug",
        "kernel_name": "kernel_xiaomi_raphael",
        "kernel_link": "https://github.com/SoDebug/KernelSU_Kernel_Raphael",
        "devices": "Xiaomi Redmi K20 Pro / Mi 9T Pro (raphael)"
    },
    {
        "maintainer": "H1mJT",
        "maintainer_link": "https://github.com/H1mJT",
        "kernel_name": "kernel_realme_RMX1901",
        "kernel_link": "https://github.com/H1mJT/kernel_realme_RMX1901",
        "devices": "Realme X (RMX1901/RMX1901CN)"
    },
    {
        "maintainer": "SonalSingh18",
        "maintainer_link": "https://github.com/SonalSingh18",
        "kernel_name": "android_kernel_xiaomi_sm6250",
        "kernel_link": "https://github.com/SonalSingh18/android_kernel_xiaomi_sm6250",
        "devices": "Miatoll [curtana, excalibur, gram, joyeuse]"
    },
    {
        "maintainer": "RooGhz720",
        "maintainer_link": "https://github.com/RooGhz720",
        "kernel_name": "kernel_xiaomi_lavender",
        "kernel_link": "https://github.com/RooGhz720/kernel_xiaomi_lavender",
        "devices": "Redmi Note 7 (Lavender)"
    },
    {
        "maintainer": "JunASAKA",
        "maintainer_link": "https://github.com/JunASAKA",
        "kernel_name": "kernel_google_msm-4.9_KernelSU",
        "kernel_link": "https://github.com/JunASAKA/kernel_google_msm-4.9_KernelSU",
        "devices": "Google Pixel 3a & 3a XL (sargo & bonito)"
    },
    {
        "maintainer": "RooGhz720",
        "maintainer_link": "https://github.com/RooGhz720",
        "kernel_name": "kernel_asus_X01BD",
        "kernel_link": "https://github.com/RooGhz720/kernel_asus_X01BD",
        "devices": "Asus Zenfone Max Pro M1/M2"
    },
    {
        "maintainer": "Evans Mike",
        "maintainer_link": "https://github.com/etnperlong",
        "kernel_name": "kernel_xiaomi_raphael_bool-x",
        "kernel_link": "https://github.com/etnperlong/kernel_xiaomi_raphael_bool-x",
        "devices": "Xiaomi Redmi K20 Pro / Mi 9T Pro (raphael)"
    },
    {
        "maintainer": "easterNday",
        "maintainer_link": "https://github.com/DogDayAndroid",
        "kernel_name": "KSU_Thyme_BuildBot",
        "kernel_link": "https://github.com/DogDayAndroid/KSU_Thyme_BuildBot",
        "devices": "Xiaomi 10S"
    },
    {
        "maintainer": "tedomi2705",
        "maintainer_link": "https://github.com/tedomi2705",
        "kernel_name": "kernel_xiaomi_sdm660",
        "kernel_link": "https://github.com/tedomi2705/kernel_xiaomi_sdm660",
        "devices": "Xiaomi Redmi Note 6 Pro (tulip)"
    },
    {
        "maintainer": "RyuujiX",
        "maintainer_link": "https://github.com/RyuujiX",
        "kernel_name": "android_kernel_asus_sdm660-4.19",
        "kernel_link": "https://github.com/RyuujiX/android_kernel_asus_sdm660-4.19",
        "devices": "Asus Zenfone Max Pro M1 (X00TD)/ M2 (X01BD) (Linux 4.19)"
    },
    {
        "maintainer": "liqidecg",
        "maintainer_link": "https://github.com/liqidecg",
        "kernel_name": "android_kernel_xiaomi_sdm710",
        "kernel_link": "https://github.com/liqidecg/android_kernel_xiaomi_sdm710",
        "devices": "Mi 8 SE (sirius) (Linux 4.9)"
    },
    {
        "maintainer": "Abdelhay-Ali",
        "maintainer_link": "https://github.com/Abdelhay-Ali",
        "kernel_name": "android_kernel_huawei_hi6250",
        "kernel_link": "https://github.com/Abdelhay-Ali/android_kernel_huawei_hi6250_KernelSU",
        "devices": "Huawei P20 lite (hi6250) (Linux 4.9)"
    },
    {
        "maintainer": "reocat",
        "maintainer_link": "https://github.com/reocat",
        "kernel_name": "android_kernel_nokia_sdm660_ksu",
        "kernel_link": "https://github.com/reocat/android_kernel_nokia_sdm660_ksu",
        "devices": "Nokia 6.1 (2018)"
    },
    {
        "maintainer": "Tuan Anh",
        "maintainer_link": "https://github.com/log1cs",
        "kernel_name": "kernel_nokia_msm8998",
        "kernel_link": "https://github.com/log1cs/kernel_nokia_msm8998",
        "devices": "Nokia 8 (Repartitioned)/8 Sirocco (NLA/A1N)"
    },
    {
        "maintainer": "bggRGjQaUbCoE",
        "maintainer_link": "https://github.com/bggRGjQaUbCoE",
        "kernel_name": "android_kernel_samsung_sm8250",
        "kernel_link": "https://github.com/bggRGjQaUbCoE/android_kernel_samsung_sm8250-mohammad92",
        "devices": "Samsung Galaxy S20+ 5G (y2q)"
    },
    {
        "maintainer": "SOVIET-ANDROID",
        "maintainer_link": "https://github.com/SOVIET-ANDROID",
        "kernel_name": "kernel_xiaomi_raphael",
        "kernel_link": "https://github.com/SOVIET-ANDROID/kernel_xiaomi_raphael",
        "devices": "XK20 Pro Raphael  DSP & A only SAR support "
    },
    {
        "maintainer": "dabao1955",
        "maintainer_link": "https://github.com/dabao1955",
        "kernel_name": "android_kernel_OPPO_PEQM00",
        "kernel_link": "https://github.com/dabao1955/android_kernel_OPPO_PEQM00",
        "devices": "MediaTek devices in the OPPO Reno series on ColorOS13.x"
    },
    {
        "maintainer": "Aflaungos",
        "maintainer_link": "https://github.com/Aflaungos",
        "kernel_name": "android_kernel_motorola_msm8998",
        "kernel_link": "https://github.com/Aflaungos/android_kernel_motorola_msm8998",
        "devices": "Moto G6 Plus (evert)"
    },
    {
        "maintainer": "TheNoFace",
        "maintainer_link": "https://github.com/TheNoFace",
        "kernel_name": "kernel_oneplus_msm8998",
        "kernel_link": "https://github.com/TheNoFace/kernel_oneplus_msm8998/tree/pe-13-ksu",
        "devices": "OnePlus 5/5T (cheeseburger/dumpling)"
    },
    {
        "maintainer": "Nipin NA (Joker-V2)",
        "maintainer_link": "https://github.com/Joker-V2",
        "kernel_name": "Xcalibur kernel (violet)",
        "kernel_link": "https://github.com/Joker-V2/kernel_xiaomi_violet/tree/kernelsu",
        "devices": "Xiaomi Redmi Note 7 Pro (violet)"
    },
    {
        "maintainer": "Sr-Han",
        "maintainer_link": "https://github.com/Sr-Han",
        "kernel_name": "kernel_xiaomi_mojito",
        "kernel_link": "https://github.com/Sr-Han/kernel_xiaomi_mojito",
        "devices": "Redmi Note 10 (Sunny/Mojito)"
    },
    {
        "maintainer": "rushiranpise",
        "maintainer_link": "https://github.com/rushiranpise",
        "kernel_name": "android_kernel_samsung_exynos9610_mint",
        "kernel_link": "https://github.com/rushiranpise/android_kernel_samsung_exynos9610_mint",
        "devices": "Kernel 4.14.194 exynos9610 Non-GKI Device, Added KernelSu using manual method"
    },
    {
        "maintainer": "CN-Scars",
        "maintainer_link": "https://github.com/CN-Scars",
        "kernel_name": "pixel_experience_kernel_xiaomi_sm8250_kernelSU",
        "kernel_link": "https://github.com/CN-Scars/pixel_experience_kernel_xiaomi_sm8250_kernelSU",
        "devices": "Pixel Experience Kernel 4.19.282 for Xiaomi Redmi K40S / Xiaomi Poco F4 (munch)"
    },
    {
        "maintainer": "exer",
        "maintainer_link": "https://github.com/ekkusa",
        "kernel_name": "Miyo Toku",
        "kernel_link": "https://github.com/Miiyo/android_kernel_sony_sdm845/tree/KSU/Toku",
        "devices": "Sony Tama (akari, apollo, aurora, akatsuki) (Linux 4.9)"
    },
    {
        "maintainer": "likkai",
        "maintainer_link": "https://github.com/likkai",
        "kernel_name": "Quicksilver Kernel",
        "kernel_link": "https://github.com/likkai/ksu_kernel_xiaomi_lisa",
        "devices": "Xiaomi 11 Lite 5G NE (lisa)"
    },
    {
        "maintainer": "awakened1712",
        "maintainer_link": "https://github.com/awakened1712",
        "kernel_name": "android_kernel_samsung_exynos9820",
        "kernel_link": "https://github.com/awakened1712/android_kernel_samsung_exynos9820",
        "devices": "Samsung S10/N10"
    },
    {
        "maintainer": "awakened1712",
        "maintainer_link": "https://github.com/awakened1712",
        "kernel_name": "android_kernel_oneplus_sm8350",
        "kernel_link": "https://github.com/awakened1712/android_kernel_oneplus_sm8350",
        "devices": "Oneplus 9/9Pro"
    },
    {
        "maintainer": "siimsek",
        "maintainer_link": "https://github.com/siimsek",
        "kernel_name": "Lightning Kernel",
        "kernel_link": "https://github.com/siimsek/Lightning-Kernel",
        "devices": "Xiaomi Redmi Note 8/8T (ginkgo/willow)"
    },
    {
        "maintainer": "GiovanYCringe",
        "maintainer_link": "https://github.com/GiovanYCringe",
        "kernel_name": "kernel_a50",
        "kernel_link": "https://github.com/GiovanYCringe-Experiments/kernel_a50",
        "devices": "Galaxy A50 (A505f,fn,g,gn,gt)"
    },
    {
        "maintainer": "Asriadi Rahim",
        "maintainer_link": "https://github.com/asriadirahim",
        "kernel_name": "android_kernel_google_wahoo",
        "kernel_link": "https://github.com/Google-Pixel2-2XL/kernel_google_wahoo",
        "devices": "Google Pixel 2/2XL"
    },
    {
        "maintainer": "DawfukFR",
        "maintainer_link": "https://github.com/DawfukFR",
        "kernel_name": "kernel_oneplus_sm8250 (Stellaris-Kernel)",
        "kernel_link": "https://github.com/DawfukFR/kernel_oneplus_sm8250",
        "devices": "Oneplus 8 (Instantnoodle), Oneplus 8T (Kebab), Oneplus 8 Pro (Instantnoodlep), Oneplus 9R (lemonades) [msm-4.19]"
    },
    {
        "maintainer": "Tejas Singh",
        "maintainer_link": "https://github.com/tejas101k",
        "kernel_name": "kernel_xiaomi_ginkgo (Cuh Kernel)",
        "kernel_link": "https://github.com/tejas101k/Cuh-KerneL",
        "devices": "Xiaomi Redmi Note 8/8T (ginkgo/willow)"
    },
    {
        "maintainer": "Abdul Wahid Khan",
        "maintainer_link": "https://github.com/Wahid7852",
        "kernel_name": "kernel_xiaomi_begonia",
        "kernel_link": "https://github.com/Nova-Kernels/kernel_xiaomi_mt6785",
        "devices": "Redmi Note 8 Pro (Begonia/Begoniain)"
    },
    {
        "maintainer": "zfdx123",
        "maintainer_link": "https://github.com/zfdx123",
        "kernel_name": "kernel_xiaomi_alioth",
        "kernel_link": "https://github.com/zfdx123/kernel_xiaomi_alioth",
        "devices": "Redmi K40 (alioth)"
    },
    {
        "maintainer": "Bot-wxt1221",
        "maintainer_link": "https://github.com/Bot-wxt1221",
        "kernel_name": "android_kernel_oneplus_sdm845",
        "kernel_link": "https://github.com/Bot-wxt1221/android_kernel_oneplus_sdm845",
        "devices": "Oneplus 6 (enchilada) | Oneplus 6T (fajita) with Retrofit Dynamic Partitions Only with crdroid"
    },
    {
        "maintainer": "zlm324",
        "maintainer_link": "https://github.com/zlm324",
        "kernel_name": "android_kernel_xiaomi_msm8998_ksu",
        "kernel_link": "https://github.com/zlm324/android_kernel_xiaomi_msm8998_ksu",
        "devices": "a lineage kernel forked from LineageOS official repository, version 4.4.302, added ksu."
    },
    {
        "maintainer": "zlm324",
        "maintainer_link": "https://github.com/zlm324",
        "kernel_name": "android_kernel_xiaomi_msm8953_ksu",
        "kernel_link": "https://github.com/zlm324/android_kernel_xiaomi_msm8953_ksu",
        "devices": "Xiaomi 5X (tiffany)"
    },
    {
        "maintainer": "Vincent4440",
        "maintainer_link": "https://github.com/Vincent4440",
        "kernel_name": "android_kernel_xiaomi_sm8250",
        "kernel_link": "https://github.com/Vincent4440/android_kernel_xiaomi_sm8250",
        "devices": "Poco F4: munch"
    },
    {
        "maintainer": "tiandoufayale",
        "maintainer_link": "https://github.com/tiandoufayale",
        "kernel_name": "android_kernel_samsung_sm8250",
        "kernel_link": "https://github.com/tiandoufayale/android_kernel_samsung_sm8250",
        "devices": "Samsung Tab S7 WIFI(T870)"
    },
    {
        "maintainer": "starmoe",
        "maintainer_link": "https://github.com/bro-xun",
        "kernel_name": "android_kernel_oneplus_msm8998",
        "kernel_link": "https://github.com/Bro-Xun/kernel_op5t_ksu",
        "devices": "Oneplus 5/5T, kernel version 4.4.302"
    },
    {
        "maintainer": "supechicken",
        "maintainer_link": "https://github.com/supechicken",
        "kernel_name": "kernel_xiaomi_sm8350",
        "kernel_link": "https://github.com/supechicken/kernel_xiaomi_sm8350",
        "devices": " Xiaomi 11T Pro (vili)"
    },
    {
        "maintainer": "Vaz15k",
        "maintainer_link": "https://github.com/Vaz15k",
        "kernel_name": "kernelSU-A70q",
        "kernel_link": "https://github.com/Vaz15k/kernelSU-A70q",
        "devices": "Samsung Galaxy A70 ( A705MN / A705FN )"
    },
    {
        "maintainer": "whyakari",
        "maintainer_link": "https://github.com/whyakari",
        "kernel_name": "android_kernel_xiaomi_ginkgo",
        "kernel_link": "https://github.com/whyakari/android_kernel_xiaomi_ginkgo",
        "devices": "Xiaomi Redmi Note 8/8T (ginkgo/willow)"
    },
    {
        "maintainer": "wulan17",
        "maintainer_link": "https://github.com/wulan17",
        "kernel_name": "android_kernel_xiaomi_mt6765",
        "kernel_link": "https://github.com/Mayuri-Chan/android_kernel_xiaomi_mt6765/tree/10-ksu",
        "devices": "Redmi 6/6A (cereus/cactus)"
    },
    {
        "maintainer": "officialputuid",
        "maintainer_link": "https://github.com/officialputuid",
        "kernel_name": "android_kernel_realme_mt6785",
        "kernel_link": "https://github.com/psionicprjkt/android_kernel_realme_mt6785",
        "devices": "Realme 6/6i(Indian)/6s/7/Narzo/Narzo 20 Pro/Narzo 30 4G (RM6785)"
    },
    {
        "maintainer": "liquidprjkt",
        "maintainer_link": "https://github.com/liquidprjkt",
        "kernel_name": "liquid_kernel_realme_even",
        "kernel_link": "https://github.com/liquidprjkt/liquid_kernel_realme_even",
        "devices": "Realme C25/s and Narzo50A (even)"
    },
    {
        "maintainer": "Tonklaistonton",
        "maintainer_link": "https://github.com/Tonklaistonton",
        "kernel_name": "NEXGatokernel",
        "kernel_link": "https://github.com/Tonklaistonton/android_kernel_oneplus_sm6375",
        "devices": "Realme 9 pro 5g  | Oneplus nord ce 2 lite "
    },
    {
        "maintainer": "CoolestEnoch",
        "maintainer_link": "https://github.com/CoolestEnoch",
        "kernel_name": "kernel-su-huawei-nova2",
        "kernel_link": "https://github.com/CoolestEnoch/kernel-su-huawei-nova2",
        "devices": "Huawei nova 2 (pic)"
    },
    {
        "maintainer": "RisenID",
        "maintainer_link": "https://github.com/RisenID",
        "kernel_name": "kernel_samsung_ascendia_sm7325",
        "kernel_link": "https://github.com/RisenID/kernel_samsung_ascendia_sm7325",
        "devices": "Samsung Galaxy A52s 5G (a52sxq)"
    },
    {
        "maintainer": "RisenID",
        "maintainer_link": "https://github.com/RisenID",
        "kernel_name": "kernel_samsung_ascendia_sm7125",
        "kernel_link": "https://github.com/RisenID/kernel_samsung_ascendia_sm7125",
        "devices": "Samsung Galaxy A52 4G (a52q)"
    },
    {
        "maintainer": "RisenID",
        "maintainer_link": "https://github.com/RisenID",
        "kernel_name": "kernel_samsung_ascendia_sm7125",
        "kernel_link": "https://github.com/RisenID/kernel_samsung_ascendia_sm7125",
        "devices": "Samsung Galaxy A72 (a72q)"
    },
    {
        "maintainer": "RisenID",
        "maintainer_link": "https://github.com/RisenID",
        "kernel_name": "kernel_samsung_ascendia_sm7325",
        "kernel_link": "https://github.com/RisenID/kernel_samsung_ascendia_sm7325",
        "devices": "Samsung Galaxy M52 5G (m52xq)"
    },
    {
        "maintainer": "A-JiuA",
        "maintainer_link": "https://github.com/A-JiuA",
        "kernel_name": "sirius_Kernel",
        "kernel_link": "https://github.com/A-JiuA/sirius_Kernel",
        "devices": "Xiaomi MI 8 SE(MIUI12/12.5)"
    },
    {
        "maintainer": "picasso09",
        "maintainer_link": "https://github.com/picasso09",
        "kernel_name": "KernelSU-RM6765R",
        "kernel_link": "https://github.com/picasso09/RMX2189R/tree/c05-ksu",
        "devices": "Realme C11 12 15 (RM6765)"
    },
    {
        "maintainer": "josedelinux",
        "maintainer_link": "https://github.com/josedelinux",
        "kernel_name": "kernel_google_msm-4.9",
        "kernel_link": "https://github.com/josedelinux/kernel_google_msm-4.9",
        "devices": "Google Pixel 3a & 3a XL (sargo & bonito)"
    },
    {
        "maintainer": "Lonelystar9x",
        "maintainer_link": "https://github.com/lonelystar9x",
        "kernel_name": "Kernel_xiaomi_sdm845",
        "kernel_link": "https://github.com/lonelystar9x/android_kernel_xiaomi_sdm845",
        "devices": "Poco F1 | MI8 | MiMix2S | MiMix3"
    },
    {
        "maintainer": "iceBear67",
        "maintainer_link": "https://github.com/iceBear67",
        "kernel_name": "android_kernel_exynos9810_kernelsu",
        "kernel_link": "https://github.com/iceBear67/android_kernel_exynos9810_kernelsu",
        "devices": "Galaxy Note 9(N960N/F)"
    },
    {
        "maintainer": "BlackMesa123",
        "maintainer_link": "https://xdaforums.com/t/kernel-a546b-e-kernelsu-v0-7-5-for-galaxy-a54-5g.4607539/",
        "kernel_name": "android_kernel_samsung_s5e8835",
        "kernel_link": "https://github.com/BlackMesa123/android_kernel_samsung_s5e8835",
        "devices": "Samsung Galaxy A54 5G (a54x)"
    },
    {
        "maintainer": "Fede2782",
        "maintainer_link": "https://github.com/Fede2782",
        "kernel_name": "android_kernel_samsung_a34x",
        "kernel_link": "https://github.com/Fede2782/android_kernel_samsung_a34x/",
        "devices": "Samsung Galaxy A34 5G (a34x)"
    },
    {
        "maintainer": "SnowWolf725    ",
        "maintainer_link": "https://github.com/snowwolf725",
        "kernel_name": "android_kernel_oneplus_sm8150",
        "kernel_link": "https://github.com/snowwolf725/android_kernel_oneplus_sm8150",
        "devices": "Oneplus 7(guacamoleb)/7 Pro(guacamole)/7T(hotdog)/7TPro (hotdogb)"
    },
    {
        "maintainer": "Fede2782",
        "maintainer_link": "https://github.com/Fede2782",
        "kernel_name": "android_kernel_samsung_gta4xl",
        "kernel_link": "https://github.com/Fede2782/android_kernel_samsung_gta4xl",
        "devices": "Galaxy Tab S6 Lite LTE (gta4xl)"
    },
    {
        "maintainer": "ArchVisions",
        "maintainer_link": "https://github.com/ArchVisions",
        "kernel_name": "android_kernel_samsung_gts9fewifi",
        "kernel_link": "https://github.com/ArchVisions/android_kernel_samsung_gts9fewifi",
        "devices": "Samsung Tab S9 FE (gts9fewifi) | Exynos 1380"
    },
    {
        "maintainer": "ravindu644",
        "maintainer_link": "https://github.com/ravindu644",
        "kernel_name": "android_kernel_beyondx_lpos",
        "kernel_link": "https://github.com/ravindu644/android_kernel_beyondx_lpos",
        "devices": "Galaxy S10 5G (KOR)"
    },
    {
        "maintainer": "ravindu644",
        "maintainer_link": "https://github.com/ravindu644",
        "kernel_name": "android_kernel_beyond1_lpos",
        "kernel_link": "https://github.com/ravindu644/android_kernel_beyond1_lpos",
        "devices": "Galaxy S10"
    },
    {
        "maintainer": "ravindu644",
        "maintainer_link": "https://github.com/ravindu644",
        "kernel_name": "android_kernel_beyond2",
        "kernel_link": "https://github.com/ravindu644/android_kernel_beyond2",
        "devices": "Galaxy S10+"
    },
    {
        "maintainer": "ravindu644",
        "maintainer_link": "https://github.com/ravindu644",
        "kernel_name": "android_kernel_beyond0",
        "kernel_link": "https://github.com/ravindu644/android_kernel_beyond0",
        "devices": "Galaxy S10e"
    },
    {
        "maintainer": "Rofikkernel",
        "maintainer_link": "https://github.com/Rofikkernel",
        "kernel_name": "kernel_lgv600tm_4.19",
        "kernel_link": "https://github.com/Rofikkernel/kernel_lgv600tm_4.19",
        "devices": "LG V60 timelm"
    },
    {
        "maintainer": "Dawid2849",
        "maintainer_link": "https://github.com/Dawid2849",
        "kernel_name": "android_kernel_lge_sm8150",
        "kernel_link": "https://github.com/Dawid2849/android_kernel_lge_sm8150",
        "devices": "LG G8 (alphaplus) / LG G8s (betalm) / LG G8X (mh2mml)"
    },
    {
        "maintainer": "lyc8503",
        "maintainer_link": "https://github.com/lyc8503",
        "kernel_name": "kernel_xiaomi_chopin",
        "kernel_link": "https://github.com/ChopinKernels/kernel_xiaomi_chopin_android_S",
        "devices": "Redmi Note 10 Pro 5G (chopin) / Poco X3 GT (choping)"
    },
    {
        "maintainer": "Fede2782",
        "maintainer_link": "https://github.com/Fede2782",
        "kernel_name": "android_kernel_motorola_sdm632",
        "kernel_link": "https://github.com/Fede2782/android_kernel_motorola_sdm632",
        "devices": "Motorola Moto G7 (river)"
    },
    {
        "maintainer": "EmanuelCN",
        "maintainer_link": "https://github.com/EmanuelCN",
        "kernel_name": "N0Kernel",
        "kernel_link": "https://github.com/EmanuelCN/kernel_xiaomi_sm8250",
        "devices": "Poco F3 (alioth) | Mi 10T/Pro (apollo) | Poco F4 (munch)"
    },
    {
        "maintainer": "kvsnr113",
        "maintainer_link": "https://github.com/kvsnr113",
        "kernel_name": "NOVA Kernel",
        "kernel_link": "https://github.com/kvsnr113/xiaomi_sm8250_kernel",
        "devices": "Poco F3 (alioth) | Mi 10T/Pro (apollo) | Poco F4 (munch)"
    },
    {
        "maintainer": "anVzdGFtb25",
        "maintainer_link": "https://github.com/anVzdGFtb25",
        "kernel_name": "android_kernel_xiaomi_mt6768",
        "kernel_link": "https://github.com/anVzdGFtb25/android_kernel_xiaomi_mt6768",
        "devices": "Redmi 9 ( lancelot )"
    },
    {
        "maintainer": "rifsxd",
        "maintainer_link": "https://github.com/rifsxd",
        "kernel_name": "android_kernel_realme_RMX3511",
        "kernel_link": "https://github.com/rifsxd/android_kernel_realme_RMX3511",
        "devices": "Realme C35 (RMX3511)"
    },
    {
        "maintainer": "qlAD",
        "maintainer_link": "https://github.com/qlAD",
        "kernel_name": "kernel_oneplus_sdm845",
        "kernel_link": "https://github.com/qlAD/kernel_oneplus_sdm845",
        "devices": "OnePlus 6 (enchilada) with PixelExperience "
    },
    {
      "maintainer": "rsuntkOrgs",
        "maintainer_link": "https://github.com/rsuntkOrgs",
        "kernel_name": "kernel_samsung_wingtech",
        "kernel_link": "https://github.com/rsuntkOrgs/kernel_samsung_wingtech",
        "devices": "Samsung Galaxy A05 (a05m) and A04 (a04)"
     },
    {
        "maintainer": "itejo443",
        "maintainer_link": "https://github.com/itejo443",
        "kernel_name": "android_kernel_samsung_sm7225",
        "kernel_link": "https://github.com/itejo443/android_kernel_samsung_sm7225",
        "devices": "Samsung Galaxy F23 and M23 (m23xq)"
    },
    {
        "maintainer": "JuiIm",
        "maintainer_link": "https://github.com/JuiIm",
        "kernel_name": "M30s-custom-kernel",
        "kernel_link": "https://github.com/JuiIm/M30s-custom-kernel-M307f---KernelSU-support/",
        "devices": "Samsung Galaxy M30s (M307F)"
    },
    {
        "maintainer": "poqdavid",
        "maintainer_link": "https://github.com/poqdavid",
        "kernel_name": "android_kernel_samsung_sma155f",
        "kernel_link": "https://github.com/poqdavid/android_kernel_samsung_sma155f",
        "devices": "Samsung Galaxy A15 4G (sma155f) | MediaTek Helio G99"
    }
]

```

`website/docs/ru_RU/guide/app-profile.md`:

```md
# Профиль приложений

Профиль приложений - это механизм, предоставляемый KernelSU для настройки конфигурации различных приложений.

Для приложений, получивших права root (т.е. имеющих возможность использовать `su`), App Profile может также называться Root Profile. Он позволяет настраивать правила `uid`, `gid`, `groups`, `capabilities` и `SELinux` команды `su`, тем самым ограничивая привилегии пользователя root. Например, она может предоставлять сетевые права только приложениям межсетевого экрана, отказывая в праве доступа к файлам, или предоставлять права shell вместо полного root-доступа для приложений freeze: **сохранение власти в рамках принципа наименьших привилегий*.

Для обычных приложений, не имеющих прав root, App Profile может управлять поведением ядра и системы модулей по отношению к этим приложениям. Например, он может определять, следует ли обращать внимание на модификации, возникающие в результате работы модулей. На основе этой конфигурации ядро и система модулей могут принимать решения, например, выполнять операции, аналогичные "скрытию".

## Корневой профиль

### UID, GID и группы

В системах Linux существуют два понятия: пользователи и группы. Каждый пользователь имеет идентификатор пользователя (UID), а пользователь может принадлежать к нескольким группам, каждая из которых имеет свой идентификатор группы (GID). Эти идентификаторы используются для идентификации пользователей в системе и определяют, к каким системным ресурсам они могут получить доступ.

Пользователи с UID, равным 0, называются корневыми пользователями, а группы с GID, равным 0, - корневыми группами. Группа пользователей root, как правило, обладает самыми высокими системными привилегиями.

В случае системы Android каждое приложение является отдельным пользователем (исключая сценарии с общим UID) с уникальным UID. Например, `0` представляет пользователя root, `1000` - `system`, `2000` - ADB shell, а UID в диапазоне от 10000 до 19999 - обычные приложения.

:::info
Здесь упомянутый UID не совпадает с концепцией нескольких пользователей или рабочих профилей в системе Android. На самом деле рабочие профили реализуются путем разделения диапазона UID. Например, 10000-19999 представляет собой основного пользователя, а 110000-119999 - рабочий профиль. Каждое обычное приложение среди них имеет свой уникальный UID.
:::

Каждое приложение может иметь несколько групп, причем GID представляет собой основную группу, которая обычно совпадает с UID. Другие группы называются дополнительными. Определенные разрешения контролируются через группы, например, разрешения на доступ к сети или доступ к Bluetooth.

Например, если мы выполним команду `id` в оболочке ADB, то результат может выглядеть следующим образом:

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

Здесь UID равен `2000`, а GID (идентификатор основной группы) также равен `2000`. Кроме того, он входит в несколько дополнительных групп, таких как `inet` (указывает на возможность создания сокетов `AF_INET` и `AF_INET6`) и `sdcard_rw` (указывает на права чтения/записи на SD-карту).

Корневой профиль KernelSU позволяет настраивать UID, GID и группы для корневого процесса после выполнения команды `su`. Например, в корневом профиле корневого приложения можно установить его UID на `2000`, что означает, что при использовании `su` фактические разрешения приложения будут находиться на уровне оболочки ADB. Группа `inet` может быть удалена, что не позволит команде `su` получить доступ к сети.

:::tip Примечание
Профиль приложений контролирует только разрешения корневого процесса после использования `su`; он не контролирует разрешения самого приложения. Если приложение запросило разрешение на доступ к сети, оно может получить доступ к сети даже без использования `su`. Удаление группы `inet` из `su` только предотвращает доступ `su` к сети.
:::

Корневой профиль реализуется в ядре и не зависит от добровольного поведения root-приложений, в отличие от переключения пользователей или групп через `su`, предоставление прав `su` полностью зависит от пользователя, а не от разработчика.

### Привилегии

Привилегии - это механизм разделения привилегий в Linux.

В традиционных реализациях UNIX для проверки прав доступа выделяются две категории процессов: привилегированные процессы (эффективный идентификатор пользователя равен 0 и называется суперпользователем или root) и непривилегированные процессы (эффективный UID которых не равен нулю).  Привилегированные процессы обходят все проверки прав ядра, в то время как непривилегированные процессы подвергаются полной проверке прав на основе учетных данных процесса (обычно: эффективный UID, эффективный GID и список дополнительных групп).

Начиная с версии Linux 2.2, в Linux привилегии, традиционно ассоциируемые с суперпользователем, разделены на отдельные единицы, называемые возможностями, которые могут быть независимо включены и выключены.

Каждая способность представляет собой одну или несколько привилегий. Например, `CAP_DAC_READ_SEARCH` представляет собой возможность обхода проверок прав на чтение файлов, а также прав на чтение и выполнение каталогов. Если пользователь с эффективным UID `0` (пользователь root) не имеет возможности `CAP_DAC_READ_SEARCH` или более высоких возможностей, это означает, что, хотя он и является пользователем root, он не может читать файлы по своему усмотрению.

Корневой профиль KernelSU позволяет настраивать возможности корневого процесса после выполнения `su`, тем самым добиваясь частичного предоставления "прав root". В отличие от вышеупомянутых UID и GID, некоторые root-приложения после использования `su` требуют UID, равный `0`. В таких случаях ограничение возможностей данного root-пользователя с UID `0` может ограничить их разрешенные операции.

:::tip Настоятельная рекомендация
В документе привелегий Linux [официальной документации](https://man7.org/linux/man-pages/man7/capabilities.7.html) дается подробное объяснение возможностей, представленных каждой привелегией. Если вы собираетесь настраивать привелегии, настоятельно рекомендуется сначала прочитать этот документ.
:::

### SELinux

SELinux - это мощный механизм обязательного контроля доступа (MAC). Он работает по принципу **запрет по умолчанию**: любое действие, не разрешенное в явном виде, запрещается.

SELinux может работать в двух глобальных режимах:

1. Разрешительный режим: События запрета регистрируются, но не выполняются.
2. Принудительный режим: События запрета регистрируются и выполняются.

:::warning Предупреждение
Современные системы Android в значительной степени опираются на SELinux для обеспечения общей безопасности системы. Настоятельно не рекомендуется использовать пользовательские системы, работающие в "разрешительном режиме", поскольку это не дает существенных преимуществ перед полностью открытой системой.
:::

Объяснение полной концепции SELinux является сложным и выходит за рамки данного документа. Рекомендуется сначала разобраться в его работе с помощью следующих ресурсов:

1. [Wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Red Hat: Что такое SELinux?](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

Корневой профиль KernelSU позволяет настраивать SELinux-контекст корневого процесса после выполнения команды `su`. Для этого контекста могут быть заданы специальные правила управления доступом, позволяющие осуществлять тонкий контроль над правами root.

В типичных сценариях, когда приложение выполняет команду `su`, оно переключает процесс на домен SELinux с **неограниченным доступом**, например `u:r:su:s0`. С помощью профиля Root Profile этот домен может быть переключен на пользовательский домен, например `u:r:app1:s0`, и для него может быть определен ряд правил:

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

Обратите внимание, что правило `allow app1 * * *` используется только в демонстрационных целях. На практике это правило не должно широко использоваться, поскольку оно мало чем отличается от разрешительного режима.

### Эскалация

При неправильной настройке корневого профиля может возникнуть сценарий эскалации: ограничения, накладываемые корневым профилем, могут непреднамеренно не сработать.

Например, если предоставить права root пользователю ADB shell (что является обычным случаем), а затем предоставить права root обычному приложению, но настроить его профиль root с UID 2000 (это UID пользователя ADB shell), то приложение может получить полный доступ root, выполнив команду `su` дважды:

1. При первом выполнении команды `su` будет применен профиль App Profile и произойдет переход на UID `2000` (adb shell) вместо `0` (root).
2. При втором выполнении команды `su`, поскольку UID равен `2000`, а в конфигурации вы предоставили доступ root к UID `2000` (adb shell), приложение получит полные привилегии root.

:::warning Примечание
Такое поведение вполне ожидаемо и не является ошибкой. Поэтому мы рекомендуем следующее:

Если вам действительно необходимо предоставить права root в ADB (например, как разработчику), не рекомендуется изменять UID на `2000` при настройке корневого профиля. Лучше использовать `1000` (система).
:::

## Некорневой профиль

### Размонтирование модулей

KernelSU предоставляет бессистемный механизм модификации системных разделов, реализуемый через монтирование overlayfs. Однако некоторые приложения могут быть чувствительны к такому поведению. Поэтому мы можем выгрузить модули, смонтированные в этих приложениях, установив опцию "размонтирование модулей".

Кроме того, в интерфейсе настроек менеджера KernelSU имеется переключатель "размонтирование модулей по умолчанию". По умолчанию этот переключатель **включен**, что означает, что KernelSU или некоторые модули будут выгружать модули для данного приложения, если не будут применены дополнительные настройки. Если вам не нравится эта настройка или если она влияет на определенные приложения, у вас есть следующие возможности:

1. Оставить переключатель "размонтирование модулей по умолчанию" и индивидуально отключить опцию "размонтирование модулей" в профиле приложений для приложений, требующих загрузки модулей (действует как "белый список").
2. Отключить переключатель "размонтирование модулей по умолчанию" и индивидуально включить опцию "размонтирование модулей" в App Profile для приложений, требующих выгрузки модулей (действует как "черный список").

:::info
В устройствах, использующих ядро версии 5.10 и выше, выгрузку модулей выполняет само ядро. Однако для устройств с ядром версии ниже 5.10 этот переключатель является лишь опцией конфигурации, и KernelSU сам по себе не предпринимает никаких действий. Некоторые модули, например, Zygisksu, могут использовать этот переключатель для определения необходимости выгрузки модулей.
:::

```

`website/docs/ru_RU/guide/difference-with-magisk.md`:

```md
# Различия с Magisk {#title}

Несмотря на большое количество сходств между модулями KernelSU и модулями Magisk, неизбежно возникают и различия, обусловленные совершенно разными механизмами их реализации. Если вы хотите, чтобы ваш модуль работал как на Magisk, так и на KernelSU, вы должны понимать эти различия.

## Сходства {#similarities}

- Формат файлов модулей: оба используют формат zip для организации модулей, и формат модулей практически одинаков
- Каталог установки модулей: оба расположены в `/data/adb/modules`.
- Бессистемность: оба поддерживают модификацию /system бессистемным способом через модули
- post-fs-data.sh: время выполнения и семантика полностью совпадают
- service.sh: время выполнения и семантика полностью совпадают
- system.prop: полностью совпадает
- sepolicy.rule: полностью совпадает
- BusyBox: скрипты запускаются в BusyBox с включенным "автономным режимом" в обоих случаях

## Различия {#differences}

Прежде чем разбираться в различиях, необходимо знать, как отличить, в каком режиме работает ваш модуль - KernelSU или Magisk. Для этого можно использовать переменную окружения `KSU` во всех местах, где можно запустить скрипты модуля (`customize.sh`, `post-fs-data.sh`, `service.sh`). В KernelSU эта переменная окружения будет установлена в значение `true`.

Вот некоторые отличия:

- Модули KernelSU не могут быть установлены в режиме Recovery.
- Модули KernelSU не имеют встроенной поддержки Zygisk (но вы можете использовать модули Zygisk через [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).
- Метод замены или удаления файлов в модулях KernelSU полностью отличается от Magisk. KernelSU не поддерживает метод `.replace`. Вместо этого необходимо создать одноименный файл с помощью команды `mknod filename c 0 0` для удаления соответствующего файла.
- Каталоги для BusyBox отличаются. Встроенный BusyBox в KernelSU находится в каталоге `/data/adb/ksu/bin/busybox`, а в Magisk - в каталоге `/data/adb/magisk/busybox`. **Обратите внимание, что это внутреннее поведение KernelSU и в будущем оно может измениться!**
- KernelSU не поддерживает файлы `.replace`; однако KernelSU поддерживает переменные `REMOVE` и `REPLACE` для удаления или замены файлов и папок.

```

`website/docs/ru_RU/guide/faq.md`:

```md
# FAQ

## Поддерживает ли KernelSU мое устройство?

KernelSU поддерживает устройства под управлением Android с разблокированным загрузчиком. Однако официальная поддержка предоставляется только для GKI Linux Kernel 5.10+ (на практике это означает, что ваше устройство должно иметь Android 12 из коробки для поддержки).

Вы можете легко проверить поддержку вашего устройства через менеджер KernelSU, который доступен [здесь](https://github.com/tiann/KernelSU/releases).

Если приложение показывает `Not installed`, значит ваше устройство официально поддерживается KernelSU.

Если приложение показывает `Unsupported`, значит ваше устройство в настоящее время не поддерживается официально. Однако вы можете собрать исходный код ядра и интегрировать KernelSU, чтобы заставить его работать, или использовать [Неофициально поддерживаемые устройства](unofficially-support-devices).

## Нужно ли для KernelSU разблокировать загрузчик?

Безусловно, да.

## Поддерживает ли KernelSU модули?

Да, большинство модулей Magisk работают с KernelSU. Однако, если вашему модулю нужно модифицировать файлы `/system`, вам необходимо установить [метамодуль](metamodule.md) (например, `meta-overlayfs`). Другие функции модулей работают без метамодуля. Проверьте [Руководство по модулям](module.md) для получения дополнительной информации.

## Поддерживает ли KernelSU Xposed?

Да, вы можете использовать LSPosed (или другие современные производные Xposed) с [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).

## Поддерживает ли KernelSU Zygisk?

KernelSU не имеет встроенной поддержки Zygisk, но вы можете использовать модуль типа [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) для его поддержки.

## Совместим ли KernelSU с Magisk?

Система модулей KernelSU конфликтует с магическим монтированием Magisk. Если в KernelSU включен какой-либо модуль, Magisk полностью перестанет работать.

Однако, если вы используете только `su` из KernelSU, он будет хорошо работать с Magisk. KernelSU модифицирует `kernel`, а Magisk модифицирует `ramdisk`, позволяя обоим работать вместе.

## Заменит ли KernelSU Magisk?

Мы считаем, что нет, и это не наша цель. Magisk достаточно хорош для решения root в пользовательском пространстве и будет жить долго. Цель KernelSU - предоставить пользователям интерфейс ядра, а не заменить Magisk.

## Может ли KernelSU поддерживать устройства, не относящиеся к GKI?

Это возможно. Но вам нужно скачать исходный код ядра и интегрировать KernelSU в дерево исходных текстов и скомпилировать ядро самостоятельно.

## Может ли KernelSU поддерживать устройства ниже Android 12?

Это ядро устройства влияет на совместимость KernelSU, и это не имеет ничего общего с версией Android. Единственное ограничение заключается в том, что устройства, выпущенные с Android 12, должны иметь версию ядра 5.10+ (устройства GKI). Итак:

1. Устройства, выпущенные с Android 12, должны поддерживаться.
2. Устройства со старым ядром (некоторые устройства с Android 12 также имеют старое ядро) совместимы (вам нужно самостоятельно собрать ядро).

## Может ли KernelSU поддерживать старое ядро?

Это возможно. KernelSU теперь бэкпортирован на ядро 4.14. Для более старых ядер вам нужно выполнить бэкпорт вручную, и PR приветствуются!

## Как интегрировать KernelSU для старого ядра?

Пожалуйста, ознакомьтесь с руководством [Интеграция для устройств не-GKI](how-to-integrate-for-non-gki).

## Почему моя версия Android - 13, а ядро показывает "android12-5.10"?

Версия ядра не имеет ничего общего с версией Android. Если вам нужно прошить ядро, всегда используйте версию ядра; версия Android не так важна.

## Я GKI 1.0, могу ли я использовать это?

GKI 1.0 полностью отличается от GKI 2.0, вы должны скомпилировать ядро самостоятельно.

## Как можно сделать `/system` RW?

Мы не рекомендуем напрямую модифицировать системный раздел. Пожалуйста, ознакомьтесь с [Руководством по модулям](module.md) для его бессистемной модификации. Если вы настаиваете на этом, проверьте [magisk_overlayfs](https://github.com/HuskyDG/magic_overlayfs).

## Может ли KernelSU модифицировать hosts? Как использовать AdAway?

Конечно. Но KernelSU не имеет встроенной поддержки hosts, вы можете установить модуль типа [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module) для этого.

## Почему мои модули не работают после новой установки?

Если вашим модулям нужно модифицировать файлы `/system`, вам необходимо установить [метамодуль](metamodule.md) для монтирования директории `system`. Другие функции модулей (скрипты, sepolicy, system.prop) работают без метамодуля.

**Решение**: См. [Руководство по метамодулям](metamodule.md) для инструкций по установке.

## Что такое метамодуль и зачем он мне нужен?

Метамодуль - это специальный модуль, который предоставляет инфраструктуру для монтирования обычных модулей. См. [Руководство по метамодулям](metamodule.md) для полного объяснения.

```

`website/docs/ru_RU/guide/hidden-features.md`:

```md
# Скрытые возможности

## .ksurc

По умолчанию `/system/bin/sh` загружает `/system/etc/mkshrc`.

Вы можете заставить su загружать пользовательский rc-файл, создав файл `/data/adb/ksu/.ksurc`.
```

`website/docs/ru_RU/guide/how-to-build.md`:

```md
# Как собрать KernelSU?

::: warning
Этот документ предназначен только для архивных ссылок и больше не обновляется.
Начиная с KernelSU v3.0, мы отказались от официальной поддержки режима образов GKI для более быстрой итерации и скорости сборки. Рекомендуется использовать `Ylarod/ddk` для сборки LKM.
:::

Прежде всего, необходимо ознакомиться с официальной документацией Android по сборке ядра:

1. [Сборка ядер](https://source.android.com/docs/setup/build/building-kernels)
2. [Сборки релизов GKI](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

::: warning
Эта страница предназначена для устройств GKI, если вы используете старое ядро, пожалуйста, обратитесь к [Как интегрировать KernelSU для не GKI ядер?](how-to-integrate-for-non-gki).
:::

## Сборка ядра

### Синхронизация исходного кода ядра

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

Файл `<kernel_manifest.xml>` - это файл манифеста, который может однозначно определять сборку, с его помощью можно выполнить пересборку. Файл манифеста следует загрузить с сайта [Сборки релизов Google GKI](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

### Построение

Пожалуйста, сначала ознакомьтесь с [официальной документацией](https://source.android.com/docs/setup/build/building-kernels).

Например, нам необходимо собрать образ ядра aarch64:

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

Не забудьте добавить флаг `LTO=thin`, иначе сборка может завершиться неудачей, если память вашего компьютера меньше 24 Гб.

Начиная с Android 13, сборка ядра осуществляется с помощью `bazel`:

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

## Сборка ядра с помощью KernelSU

Если вы успешно собрали ядро, то собрать KernelSU очень просто, выберите любой запуск в корневом каталоге исходного кода ядра:

- Последний тэг(стабильный)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

- Основная ветвь(разработка)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

- Выбранный тэг(Например, версия v0.5.2)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

А затем пересоберите ядро и получите образ ядра с KernelSU!

```

`website/docs/ru_RU/guide/how-to-integrate-for-non-gki.md`:

```md
# Как интегрировать KernelSU для не GKI ядер? {#introduction}

::: warning
Этот документ предназначен только для архивных ссылок и больше не обновляется.
Начиная с KernelSU v1.0, мы отказались от официальной поддержки устройств не-GKI.
:::

KernelSU может быть интегрирован в ядра, отличные от GKI, и был перенесен на версии 4.14 и ниже.

В связи с фрагментацией ядер, отличных от GKI, у нас нет единого способа их сборки, поэтому мы не можем предоставить загрузочные образы, отличные от GKI. Однако вы можете собрать ядро самостоятельно с помощью интегрированной программы KernelSU.

Во-первых, вы должны уметь собирать загрузочное ядро из исходных текстов ядра. Если ядро не является открытым, то запустить KernelSU для вашего устройства будет затруднительно.

Если вы можете собрать загрузочное ядро, то существует два способа интеграции KernelSU в исходный код ядра:

1. Автоматически с помощью `kprobe`
2. Вручную

## Интеграция с kprobe {#using-kprobes}

KernelSU использует kprobe для выполнения хуков ядра, если *kprobe* хорошо работает в вашем ядре, то рекомендуется использовать именно этот способ.

Сначала добавьте KernelSU в дерево исходных текстов ядра:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

Затем необходимо проверить, включена ли функция *kprobe* в конфигурации ядра, если нет, то добавьте в нее эти настройки:

```
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

И снова соберите ядро, KernelSU должен работать нормально.

Если вы обнаружите, что KPROBES по-прежнему не активирован, попробуйте включить `CONFIG_MODULES`. (Если это все равно не даст результата, используйте `make menuconfig` для поиска других зависимостей KPROBES).

Если же при интеграции KernelSU возникает зацикливание загрузки, то, возможно, в вашем ядре *kprobe неисправен*, следует исправить ошибку kprobe или воспользоваться вторым способом.

:::tip Как проверить, не сломан ли kprobe？

закомментируйте `ksu_sucompat_init()` и `ksu_ksud_init()` в файле `KernelSU/kernel/ksu.c`, если устройство загружается нормально, то может быть нарушена работа kprobe.
:::

## Ручная модификация исходного кода ядра {#modify-kernel-source-code}

Если kprobe не работает в вашем ядре (возможно, это ошибка апстрима или ядра ниже 4.8), то можно попробовать следующий способ:

Сначала добавьте Kernel SU в дерево исходного кода вашего ядра:

- Последний тэг(стабильный)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

- Основная ветвь(разработка)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

- Выбранный тэг(Например, версия v0.5.2)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

Затем добавьте вызовы KernelSU в исходный код ядра, вот патч, на который можно сослаться:

```diff
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }
 
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);
 
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
 
+	ksu_handle_stat(&dfd, &filename, &flags);
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```

В исходных кодах ядра можно найти эти четыре функции:

1. do_faccessat, обычно в `fs/open.c`.
2. do_execveat_common, обычно в `fs/exec.c`.
3. vfs_read, обычно в `fs/read_write.c`.
4. vfs_statx, обычно в `fs/stat.c`.

Если в вашем ядре нет `vfs_statx`, используйте вместо него `vfs_fstatat`:

```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
 
+	ksu_handle_stat(&dfd, &filename, &flag);
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

Для ядер младше 4.17, если вы не можете найти `do_faccessat`, просто перейдите к определению системного вызова `faccessat` и поместите вызов туда:

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

Чтобы включить встроенный в KernelSU безопасный режим, необходимо также изменить `input_handle_event` в файле `drivers/input/input.c`:

:::tip
Настоятельно рекомендуется включить эту функцию, она очень помогает предотвратить циклическую загрузку!
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }
 
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

Наконец, снова соберите ядро, KernelSU должен работать хорошо.

### How to backport path_umount

You can make the "Umount modules" feature work on pre-GKI kernels by manually backporting `path_umount` from 5.9. You can use this patch as reference:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

Finally, build your kernel again, and KernelSU should work correctly.

```

`website/docs/ru_RU/guide/installation.md`:

```md
# Установка {#title}

## Проверьте, поддерживается ли ваше устройство {#check-if-supported}

Скачайте приложение менеджера KernelSU с сайта [GitHub Releases](https://github.com/tiann/KernelSU/releases) и установите его на устройство:

- Если приложение показывает `Unsupported`, это означает, что **Вы должны скомпилировать ядро самостоятельно**, KernelSU не будет и никогда не предоставит Вам загрузочный образ для прошивки.
- Если приложение показывает `Не установлено`, значит, ваши устройства официально поддерживаются KernelSU.

:::info
Для устройств, показывающих `Unsupported`, здесь находится [Unofficially-support-devices](unofficially-support-devices.md), вы можете скомпилировать ядро самостоятельно.
:::

## Резервное копирование стокового файла boot.img {#backup-boot-image}

Перед прошивкой необходимо создать резервную копию файла boot.img. Если возникнет ошибка загрузки, вы всегда сможете восстановить систему, перепрошив ее на заводскую загрузку с помощью fastboot.

::: warning
Прошивка может привести к потере данных, поэтому обязательно выполните этот шаг перед переходом к следующему шагу!!! При необходимости можно также создать резервную копию всех данных на телефоне.
:::

## Необходимые знания {#acknowage}

### ADB и fastboot {#adb-and-fastboot}

По умолчанию в этом руководстве вы будете использовать инструменты ADB и fastboot, поэтому, если вы их не знаете, рекомендуем сначала воспользоваться поисковой системой, чтобы узнать о них.

### KMI

Kernel Module Interface (KMI), версии ядра с одинаковым KMI **совместимы** Это то, что в GKI означает "общий"; наоборот, если KMI отличается, то эти ядра несовместимы друг с другом, и прошивка образа ядра с другим KMI, чем у вашего устройства, может привести к bootloop.

В частности, для устройств GKI формат версии ядра должен быть следующим:

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

`w.x-zz-k` - версия KMI. Например, если версия ядра устройства `5.10.101-android12-9-g30979850fc20`, то его KMI - `5.10-android12-9`; теоретически оно может нормально загружаться с другими ядрами KMI.

::: tip
Обратите внимание, что SubLevel в версии ядра не является частью KMI! Это означает, что `5.10.101-android12-9-g30979850fc20` имеет тот же KMI, что и `5.10.137-android12-9-g30979850fc20`!
:::

### Версия ядра и версия Android {#kernel-version-vs-android-version}

Обратите внимание: **Версия ядра и версия Android - это не обязательно одно и то же!**

Если вы обнаружили, что версия ядра `android12-5.10.101`, а версия системы Android - Android 13 или другая, не удивляйтесь, поскольку номер версии системы Android не обязательно совпадает с номером версии ядра Linux; Номер версии ядра Linux обычно соответствует версии системы Android, поставляемой с **устройством при его поставке**. При последующем обновлении системы Android версия ядра, как правило, не меняется. При необходимости прошивки **укажите версию ядра!!!**.

## Введение {#installation-introduction}

Существует несколько способов установки KernelSU, каждый из которых подходит для разных сценариев, поэтому выбирайте их по своему усмотрению.

1. Установка с помощью пользовательского Recovery (например, TWRP)
2. Установка с помощью приложения для прошивки ядра, например, Franco Kernel Manager
3. Установка с помощью fastboot с использованием boot.img, предоставленного KernelSU
4. Восстановить boot.img вручную и установить его

Since version [0.9.0](https://github.com/tiann/KernelSU/releases/tag/v0.9.0), KernelSU supports two running modes on GKI devices:

1. `GKI`: Replace the original kernel of the device with the **Generic Kernel Image** (GKI) provided by KernelSU.
2. `LKM`: Load the **Loadable Kernel Module** (LKM) into the device kernel without replacing the original kernel.

These two modes are suitable for different scenarios, and you can choose the one according to your needs.

### GKI mode {#gki-mode}

In GKI mode, the original kernel of the device will be replaced with the generic kernel image provided by KernelSU. The advantages of GKI mode are:

1. Strong universality, suitable for most devices. For example, Samsung has enabled KNOX devices, and LKM mode cannot work. There are also some niche modified devices that can only use GKI mode.
2. Can be used without relying on official firmware, and there is no need to wait for official firmware updates, as long as the KMI is consistent, it can be used.

### LKM mode {#lkm-mode}

In LKM mode, the original kernel of the device won't be replaced, but the loadable kernel module will be loaded into the device kernel. The advantages of LKM mode are:

1. Won't replace the original kernel of the device. If you have special requirements for the original kernel of the device, or you want to use KernelSU while using a third-party kernel, you can use LKM mode.
2. It's more convenient to upgrade and OTA. When upgrading KernelSU, you can directly install it in the manager without flashing manually. After the system OTA, you can directly install it to the second slot without manual flashing.
3. Suitable for some special scenarios. For example, LKM can also be loaded with temporary root permissions. Since it doesn't need to replace the boot partition, it won't trigger AVB and won't cause the device to be bricked.
4. LKM can be temporarily uninstalled. If you want to temporarily disable root access, you can uninstall LKM. This process doesn't require flashing partitions, or even rebooting the device. If you want to enable root again, just reboot the device.

::: tip COEXISTENCE OF TWO MODES
After opening the manager, you can see the current mode of the device on the homepage. Note that the priority of GKI mode is higher than that of LKM. For example, if you use GKI kernel to replace the original kernel, and use LKM to patch the GKI kernel, the LKM will be ignored, and the device will always run in GKI mode.
:::

### Which one to choose? {#which-one}

If your device is a mobile phone, we recommend that you prioritize LKM mode. If your device is an emulator, WSA, or Waydroid, we recommend that you prioritize GKI mode.

## LKM installation

### Get the official firmware

To use LKM mode, you need to get the official firmware and patch it based on the official firmware. If you use a third-party kernel, you can use the `boot.img` of the third-party kernel as the official firmware.

There are many ways to get the official firmware. If your device supports `fastboot boot`, we recommend **the most recommended and simplest** method is to use `fastboot boot` to temporarily boot the GKI kernel provided by KernelSU, then install the manager, and finally install it directly in the manager. This method doesn't require manually downloading the official firmware or manually extracting the boot.

If your device doesn't support `fastboot boot`, you may need to manually download the official firmware package and extract the boot from it.

Unlike GKI mode, LKM mode modifies the `ramdisk`. Therefore, on devices with Android 13, it needs to patch the `init_boot` partition instead of the `boot` partition, while GKI mode always operates on the `boot` partition.

### Use the manager

Open the manager, click the installation icon in the upper right corner, and several options will appear:

1. Select a file. If your device doesn't have root privileges, you can choose this option and then select your official firmware. The manager will automatically patch it. After that, just flash this patched file to obtain root privileges permanently.
2. Direct install. If your device is already rooted, you can choose this option. The manager will automatically get your device information, and then automatically patch the official firmware, and flash it automatically. You can consider using `fastboot boot` KernelSU's GKI kernel to get temporary root and install the manager, and then use this option. This is also the main way to upgrade KernelSU.
3. Install to inactive slot. If your device supports A/B partition, you can choose this option. The manager will automatically patch the official firmware and install it to another partition. This method is suitable for devices after OTA, you can directly install it to the inactive slot after OTA.

If you don't want to use the manager, you can also use the command line to install LKM. The `ksud` tool provided by KernelSU can help you patch the official firmware quickly and then flash it.

The usage of `ksud` is as follows:

```sh
ksud boot-patch 
```

```txt
Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              Boot image be patched
  -l, --lkm <LKM>                LKM module path. If not specified, the built-in module will be used
  -m, --module <MODULE>          LKM module path to be replaced. If not specified, the built-in module will be used
  -i, --init <INIT>              init to be replaced
  -u, --ota                      Will use another slot if the boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                Output path. If not specified, the current directory will be used
      --magiskboot <MAGISKBOOT>  magiskboot path. If not specified, the built-in version will be used
      --kmi <KMI>                KMI version. If specified, the indicated KMI will be used
  -h, --help                     Print help
```

A few options that need to be explained:

1. The `--magiskboot` option can specify the path of magiskboot. If not specified, ksud will look for it in the environment variables. If you don’t know how to get magiskboot, you can check [here](#patch-boot-image).
2. The `--kmi` option can specify the `KMI` version. If the kernel name of your device doesn't follow the KMI specification, you can specify it using this option.

The most common usage is:

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## LKM mode installation

There are several installation methods for LKM mode, each suitable for a different scenario, so please choose accordingly:

1. Install with fastboot using the boot.img provided by KernelSU.
2. Install with a kernel flash app, such as [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases).
3. Repair the boot.img manually and install it.
4. Install with custom Recovery (e.g., TWRP).

## Установка с помощью пользовательского Recovery {#install-by-recovery}

Необходимые условия: На устройстве должен быть установлен пользовательский Recovery, например TWRP; если его нет или доступен только официальный Recovery, воспользуйтесь другим способом.

Шаг:

1. С [Release page](https://github.com/tiann/KernelSU/releases) KernelSU загрузите zip-пакет, начинающийся с AnyKernel3, который соответствует версии вашего телефона; например, версия ядра телефона - `android12-5.10. 66`, то следует скачать файл `AnyKernel3-android12-5.10.66_yyy-MM.zip` (где `yyyy` - год, а `MM` - месяц).
2. Перезагрузите телефон в TWRP.
3. С помощью adb поместите AnyKernel3-*.zip в /sdcard телефона и выберите установку в графическом интерфейсе TWRP; или вы можете напрямую `adb sideload AnyKernel-*.zip` для установки.

PS. Данный способ подходит для любой установки (не ограничиваясь начальной установкой или последующими обновлениями), если вы используете TWRP.

## Установка с помощью Kernel Flasher {#install-by-kernel-flasher}

Необходимые условия: Ваше устройство должно быть рутованным. Например, вы установили Magisk, чтобы получить root, или установили старую версию KernelSU и должны обновить ее до другой версии; если ваше устройство не укоренено, попробуйте другие методы.

Шаг:

1. Загрузите zip-архив AnyKernel3; инструкции по загрузке см. в разделе *Установка с помощью пользовательского Recovery*.
2. Откройте приложение для прошивки ядра и используйте предоставленный AnyKernel3 zip для прошивки.

Если вы раньше не использовали приложение для прошивки ядра, то наиболее популярными являются следующие.

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

PS. Этот способ более удобен при обновлении KernelSU и может быть выполнен без компьютера (сначала сделайте резервную копию!). .

## Установка с помощью boot.img, предоставленного KernelSU {#install-by-kernelsu-boot-image}

Этот способ не требует наличия TWRP и root-прав на телефоне; он подходит для первой установки KernelSU.

### Найти подходящий boot.img {#found-propery-image}

KernelSU предоставляет общий boot.img для устройств GKI, и его необходимо прошить в загрузочный раздел устройства.

Вы можете загрузить boot.img с [GitHub Release](https://github.com/tiann/KernelSU/releases), обратите внимание, что вы должны использовать правильную версию boot.img. Например, если на устройстве установлено ядро `android12-5.10.101`, то необходимо загрузить `android-5.10.101_yyy-MM.boot-<format>.img`. , необходимо загрузить `android-5.10.101_yyy-MM.boot-<format>.img`.(Соблюдайте соответствие KMI!).

Где `<format>` означает формат сжатия ядра в официальном boot.img, проверьте формат сжатия ядра в оригинальном boot.img, вы должны использовать правильный формат, например, `lz4`, `gz`; если вы используете неправильный формат сжатия, вы можете столкнуться с bootloop.

::: info
1. Вы можете использовать magiskboot для получения формата сжатия исходной загрузки; конечно, вы также можете спросить других, более опытных ребят с той же моделью, что и ваше устройство. Кроме того, формат сжатия ядра обычно не меняется, поэтому, если вы успешно загрузились с определенным форматом сжатия, вы можете попробовать этот формат позже.
2. Устройства Xiaomi обычно используют `gz` или **без сжатия**.
3. Для устройств Pixel следуйте приведенным ниже инструкциям.
:::

### прошить boot.img на устройство {#flash-boot-image}

Используйте `adb` для подключения устройства, затем выполните `adb reboot bootloader` для входа в режим fastboot, после чего используйте эту команду для прошивки KernelSU:

```sh
fastboot flash boot boot.img
```

::: info
Если устройство поддерживает `fastboot boot`, можно сначала использовать `fastboot boot boot.img`, чтобы попытаться использовать boot.img для загрузки системы. Если произойдет что-то непредвиденное, перезагрузите его снова для загрузки.
:::

### перезагрузка {#reboot}

После завершения прошивки необходимо перезагрузить устройство:

```sh
fastboot reboot
```

## Исправить boot.img вручную {#patch-boot-image}

Для некоторых устройств формат boot.img не так распространен, например, не `lz4`, `gz` или несжатый; наиболее типичным является Pixel, его boot.img имеет формат `lz4_legacy` со сжатием, ramdisk может быть `gz`, также может быть `lz4_legacy` со сжатием; в это время, если напрямую прошить boot.img, предоставляемый KernelSU, телефон может не загрузиться; в это время можно вручную исправить boot.img для достижения цели.

Как правило, существует два способа исправления:

1. [Android-Image-Kitchen](https://forum.xda-developers.com/t/tool-android-image-kitchen-unpack-repack-kernel-ramdisk-win-android-linux-mac.2073775/)
2. [magiskboot](https://github.com/topjohnwu/Magisk/releases)

Среди них Android-Image-Kitchen подходит для работы на ПК, а magiskboot нуждается в сотрудничестве мобильного телефона.

### Подготовка {#patch-preparation}

1. Получите стоковый boot.img вашего телефона; его можно получить у производителя устройства, возможно, вам понадобится [payload-dumper-go](https://github.com/ssut/payload-dumper-go)
2. Загрузите zip-файл AnyKernel3, предоставленный KernelSU, который соответствует версии KMI вашего устройства (можно обратиться к разделу *Установка с помощью пользовательского Recovery*).
3. Распакуйте пакет AnyKernel3 и получите файл `Image`, который является файлом ядра KernelSU.

### Использование Android-Image-Kitchen {#using-android-image-kitchen}

1. Загрузите программу Android-Image-Kitchen на свой компьютер.
2. Поместите файл boot.img в корневую папку Android-Image-Kitchen.
3. Выполните команду `./unpackimg.sh boot.img` в корневом каталоге Android-Image-Kitchen, в результате чего boot.img распакуется и появятся некоторые файлы.
4. Замените `boot.img-kernel` в каталоге `split_img` тем `образом`, который вы извлекли из AnyKernel3 (обратите внимание на изменение названия на boot.img-kernel).
5. Выполните команду `./repackimg.sh` в корневом каталоге 在 Android-Image-Kitchen; Вы получите файл с именем `image-new.img`; Прошейте этот boot.img с помощью fastboot (см. предыдущий раздел).

### Использование magiskboot {#using magiskboot}

1. Загрузите последнюю версию Magisk с [Release Page](https://github.com/topjohnwu/Magisk/releases).
2. Переименуйте `Magisk-*(version).apk` в `Magisk-*.zip` и разархивируйте его.
3. Закачайте `Magisk-*/lib/arm64-v8a/libmagiskboot.so` на устройство с помощью adb: `adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`.
4. Установите на устройство стоковый boot.img и образ в AnyKernel3.
5. Войдите в оболочку adb и перейдите в каталог `/data/local/tmp/`, затем `chmod +x magiskboot`.
6. Войдите в adb shell и cd директории `/data/local/tmp/`, выполните команду `./magiskboot unpack boot.img` для распаковки `boot.img`, вы получите файл `kernel`, это и есть ваше стоковое ядро.
7. Замените `kernel` на `Image`: `mv -f Image kernel`.
8. Выполните команду `./magiskboot repack boot.img`, чтобы перепаковать boot img, и получите файл `new-boot.img`, прошейте его на устройство с помощью fastboot.

## Другие методы {#other-methods}

На самом деле все эти способы установки имеют только одну основную идею - **заменить исходное ядро на ядро, предоставляемое KernelSU**; если это возможно, то установка возможна; например, возможны следующие способы.

1. Сначала установить Magisk, получить права root через Magisk, а затем с помощью kernel flasher прошить AnyKernel zip из KernelSU.
2. Использовать какой-либо инструментарий для прошивки на ПК, чтобы прошить ядро, предоставленное KernelSU.

Однако, если это не работает, попробуйте подход `magiskboot`.

## После установки: Поддержка модулей

::: warning МЕТАМОДУЛЬ ДЛЯ МОДИФИКАЦИИ СИСТЕМНЫХ ФАЙЛОВ
Если вы хотите использовать модули, которые модифицируют файлы `/system`, вам необходимо установить **метамодуль** после установки KernelSU. Модули, которые используют только скрипты, sepolicy или system.prop, работают без метамодуля.
:::

**Для поддержки модификации `/system`**, пожалуйста, см. [Руководство по метамодулям](metamodule.md), чтобы:
- Понять, что такое метамодули и зачем они нужны
- Установить официальный метамодуль `meta-overlayfs`
- Узнать о других вариантах метамодулей

```

`website/docs/ru_RU/guide/metamodule.md`:

```md
# Метамодуль

Метамодули — это революционная функция в KernelSU, которая передает критически важные возможности модульной системы от основного демона к подключаемым модулям. Это архитектурное изменение сохраняет стабильность и безопасность KernelSU, одновременно раскрывая больший потенциал для инноваций в экосистеме модулей.

## Что такое Метамодуль?

Метамодуль — это специальный тип модуля KernelSU, который предоставляет основную инфраструктурную функциональность для модульной системы. В отличие от обычных модулей, которые модифицируют системные файлы, метамодули контролируют *способ* установки и монтирования обычных модулей.

Метамодули — это механизм расширения на основе плагинов, который позволяет полностью настраивать инфраструктуру управления модулями KernelSU. Делегируя логику монтирования и установки метамодулям, KernelSU избегает превращения в уязвимую точку обнаружения, одновременно поддерживая различные стратегии реализации.

**Ключевые характеристики:**

- **Роль инфраструктуры**: Метамодули предоставляют сервисы, от которых зависят обычные модули
- **Единственный экземпляр**: Одновременно может быть установлен только один метамодуль
- **Приоритетное выполнение**: Скрипты метамодулей выполняются перед скриптами обычных модулей
- **Специальные хуки**: Предоставляет три скрипта-хука для установки, монтирования и очистки

## Зачем нужны Метамодули?

Традиционные решения для получения root встраивают логику монтирования в свое ядро, что делает их более легко обнаруживаемыми и сложными для развития. Архитектура метамодулей KernelSU решает эти проблемы через разделение ответственности.

**Стратегические преимущества:**

- **Уменьшение поверхности обнаружения**: Сам KernelSU не выполняет монтирование, уменьшая векторы обнаружения
- **Стабильность**: Основной демон остается стабильным, в то время как реализации монтирования могут развиваться
- **Инновации**: Сообщество может разрабатывать альтернативные стратегии монтирования без форка KernelSU
- **Выбор**: Пользователи могут выбрать реализацию, которая лучше всего соответствует их потребностям

**Гибкость монтирования:**

- **Без монтирования**: Для пользователей с модулями только без монтирования полностью избегайте накладных расходов на монтирование
- **Монтирование OverlayFS**: Традиционный подход с поддержкой слоя чтения-записи (через `meta-overlayfs`)
- **Magic mount**: Монтирование, совместимое с Magisk, для лучшей совместимости с приложениями
- **Пользовательские реализации**: Наложения на основе FUSE, пользовательские монтирования VFS или совершенно новые подходы

**Помимо монтирования:**

- **Расширяемость**: Добавляйте функции, такие как поддержка модулей ядра, без изменения основного KernelSU
- **Модульность**: Обновляйте реализации независимо от выпусков KernelSU
- **Настройка**: Создавайте специализированные решения для конкретных устройств или случаев использования

::: warning ВАЖНО
Без установленного метамодуля модули **НЕ** будут смонтированы. Свежие установки KernelSU требуют установки метамодуля (например, `meta-overlayfs`) для работы модулей.
:::

## Для Пользователей

### Установка Метамодуля

Установите метамодуль так же, как обычные модули:

1. Загрузите ZIP-файл метамодуля (например, `meta-overlayfs.zip`)
2. Откройте приложение KernelSU Manager
3. Нажмите на плавающую кнопку действия (➕)
4. Выберите ZIP-файл метамодуля
5. Перезагрузите устройство

Метамодуль `meta-overlayfs` — это официальная эталонная реализация, которая обеспечивает традиционное монтирование модулей на основе overlayfs с поддержкой образов ext4.

### Проверка Активного Метамодуля

Вы можете проверить, какой метамодуль в настоящее время активен, на странице модулей приложения KernelSU Manager. Активный метамодуль будет отображаться в вашем списке модулей со своим специальным обозначением.

### Удаление Метамодуля

::: danger ПРЕДУПРЕЖДЕНИЕ
Удаление метамодуля повлияет на **ВСЕ** модули. После удаления модули больше не будут монтироваться, пока вы не установите другой метамодуль.
:::

Для удаления:

1. Откройте KernelSU Manager
2. Найдите метамодуль в списке модулей
3. Нажмите удалить (вы увидите специальное предупреждение)
4. Подтвердите действие
5. Перезагрузите устройство

После удаления вы должны установить другой метамодуль, если хотите, чтобы модули продолжали работать.

### Ограничение Единственного Метамодуля

Одновременно может быть установлен только один метамодуль. Если вы попытаетесь установить второй метамодуль, KernelSU предотвратит установку, чтобы избежать конфликтов.

Для переключения метамодулей:

1. Удалите все обычные модули
2. Удалите текущий метамодуль
3. Перезагрузите
4. Установите новый метамодуль
5. Переустановите обычные модули
6. Перезагрузите снова

## Для Разработчиков Модулей

Если вы разрабатываете обычные модули KernelSU, вам не нужно слишком беспокоиться о метамодулях. Ваши модули будут работать, пока у пользователей установлен совместимый метамодуль (например, `meta-overlayfs`).

**Что вам нужно знать:**

- **Монтирование требует метамодуль**: Директория `system` в вашем модуле будет смонтирована только если у пользователя установлен метамодуль, предоставляющий функциональность монтирования
- **Изменения кода не требуются**: Существующие модули продолжают работать без изменений

::: tip
Если вы знакомы с разработкой модулей Magisk, ваши модули будут работать точно так же в KernelSU при установленном метамодуле, так как он предоставляет монтирование, совместимое с Magisk.
:::

## Для Разработчиков Метамодулей

Создание метамодуля позволяет вам настроить, как KernelSU обрабатывает установку модулей, монтирование и удаление.

### Базовые Требования

Метамодуль идентифицируется специальным свойством в `module.prop`:

```txt
id=my_metamodule
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

Свойство `metamodule=1` (или `metamodule=true`) помечает это как метамодуль. Без этого свойства модуль будет рассматриваться как обычный модуль.

### Структура Файлов

Структура метамодуля:

```txt
my_metamodule/
├── module.prop              (должен включать metamodule=1)
│
│      *** Специфичные хуки метамодуля ***
├── metamount.sh             (опционально: пользовательский обработчик монтирования)
├── metainstall.sh           (опционально: хук установки для обычных модулей)
├── metauninstall.sh         (опционально: хук очистки для обычных модулей)
│
│      *** Стандартные файлы модуля (все опциональные) ***
├── customize.sh             (настройка установки)
├── post-fs-data.sh          (скрипт этапа post-fs-data)
├── service.sh               (скрипт late_start service)
├── boot-completed.sh        (скрипт завершения загрузки)
├── uninstall.sh             (скрипт удаления самого метамодуля)
├── system/                  (системные модификации, если необходимо)
└── [любые дополнительные файлы]
```

Метамодули могут использовать все стандартные функции модулей (скрипты жизненного цикла и т. д.) в дополнение к своим специальным хукам метамодуля.

### Скрипты-Хуки

Метамодули могут предоставлять до трех специальных скриптов-хуков:

#### 1. metamount.sh - Обработчик Монтирования

**Назначение**: Контролирует способ монтирования модулей во время загрузки.

**Когда выполняется**: Во время этапа `post-fs-data`, перед выполнением любых скриптов модулей.

**Переменные окружения:**

- `MODDIR`: Путь к директории метамодуля (например, `/data/adb/modules/my_metamodule`)
- Все стандартные переменные окружения KernelSU

**Обязанности:**

- Монтировать все включенные модули системно
- Проверять флаги `skip_mount`
- Обрабатывать специфичные требования монтирования модулей

::: danger КРИТИЧЕСКОЕ ТРЕБОВАНИЕ
При выполнении операций монтирования вы **ДОЛЖНЫ** установить имя источника/устройства в `"KSU"`. Это идентифицирует монтирования как принадлежащие KernelSU.

**Пример (правильный):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**Для современных API монтирования** установите строку источника:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

Это необходимо для правильной идентификации и управления монтированиями KernelSU.
:::

**Пример скрипта:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# Пример: Простая реализация bind mount
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # Монтирование с source=KSU (ОБЯЗАТЕЛЬНО!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - Хук Установки

**Назначение**: Настроить способ установки обычных модулей.

**Когда выполняется**: Во время установки модуля, после извлечения файлов, но до завершения установки. Этот скрипт **подключается** (не выполняется) встроенным установщиком, аналогично работе `customize.sh`.

**Переменные окружения и функции:**

Этот скрипт наследует все переменные и функции из встроенного `install.sh`:

- **Переменные**: `MODPATH`, `TMPDIR`, `ZIPFILE`, `ARCH`, `API`, `IS64BIT`, `KSU`, `KSU_VER`, `KSU_VER_CODE`, `BOOTMODE` и т. д.
- **Функции**:
  - `ui_print <msg>` - Вывести сообщение в консоль
  - `abort <msg>` - Вывести ошибку и завершить установку
  - `set_perm <target> <owner> <group> <permission> [context]` - Установить права доступа к файлу
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - Установить права рекурсивно
  - `install_module` - Вызвать встроенный процесс установки модуля

**Случаи использования:**

- Обработка файлов модуля до или после встроенной установки (вызовите `install_module`, когда готово)
- Перемещение файлов модуля
- Проверка совместимости модуля
- Настройка специальных структур каталогов
- Инициализация специфичных для модуля ресурсов

**Примечание**: Этот скрипт **НЕ** вызывается при установке самого метамодуля.

#### 3. metauninstall.sh - Хук Очистки

**Назначение**: Очистить ресурсы при удалении обычных модулей.

**Когда выполняется**: Во время удаления модуля, перед удалением каталога модуля.

**Переменные окружения:**

- `MODULE_ID`: ID удаляемого модуля

**Случаи использования:**

- Обработка файлов
- Очистка символических ссылок
- Освобождение выделенных ресурсов
- Обновление внутреннего отслеживания

**Пример скрипта:**

```sh
#!/system/bin/sh
# Вызывается при удалении обычных модулей
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# Удалить файлы модуля из образа
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### Порядок Выполнения

Понимание порядка выполнения загрузки критически важно для разработки метамодулей:

```txt
этап post-fs-data:
  1. Выполняются общие скрипты post-fs-data.d
  2. Очистка модулей, restorecon, загрузка sepolicy.rule
  3. Выполняется post-fs-data.sh метамодуля (если существует)
  4. Выполняются post-fs-data.sh обычных модулей
  5. Загружается system.prop
  6. Выполняется metamount.sh метамодуля
     └─> Монтирует все модули системно
  7. Выполняется этап post-mount.d
     - Общие скрипты post-mount.d
     - post-mount.sh метамодуля (если существует)
     - post-mount.sh обычных модулей

этап service:
  1. Выполняются общие скрипты service.d
  2. Выполняется service.sh метамодуля (если существует)
  3. Выполняются service.sh обычных модулей

этап boot-completed:
  1. Выполняются общие скрипты boot-completed.d
  2. Выполняется boot-completed.sh метамодуля (если существует)
  3. Выполняются boot-completed.sh обычных модулей
```

**Ключевые моменты:**

- `metamount.sh` выполняется **ПОСЛЕ** всех скриптов post-fs-data (как метамодуля, так и обычных модулей)
- Скрипты жизненного цикла метамодуля (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`) всегда выполняются перед скриптами обычных модулей
- Общие скрипты в каталогах `.d` выполняются перед скриптами метамодуля
- Этап `post-mount` выполняется после завершения монтирования

### Механизм Символических Ссылок

При установке метамодуля KernelSU создает символическую ссылку:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

Это обеспечивает стабильный путь для доступа к активному метамодулю независимо от его ID.

**Преимущества:**

- Постоянный путь доступа
- Простое обнаружение активного метамодуля
- Упрощение конфигурации

### Реальный Пример: meta-overlayfs

Метамодуль `meta-overlayfs` является официальной эталонной реализацией. Он демонстрирует лучшие практики разработки метамодулей.

#### Архитектура

`meta-overlayfs` использует **архитектуру с двумя каталогами**:

1. **Каталог метаданных**: `/data/adb/modules/`
   - Содержит `module.prop`, `disable`, маркеры `skip_mount`
   - Быстро сканируется во время загрузки
   - Малый объем хранения

2. **Каталог содержимого**: `/data/adb/metamodule/mnt/`
   - Содержит фактические файлы модулей (system, vendor, product и т. д.)
   - Хранится в образе ext4 (`modules.img`)
   - Оптимизировано по пространству с функциями ext4

#### Реализация metamount.sh

Вот как `meta-overlayfs` реализует обработчик монтирования:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# Монтировать образ ext4, если он еще не смонтирован
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# Установить переменные окружения для поддержки двух каталогов
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# Выполнить бинарный файл монтирования
# (Фактическая логика монтирования находится в бинарном файле Rust)
"$MODDIR/meta-overlayfs"
```

#### Ключевые Особенности

**Монтирование Overlayfs:**

- Использует kernel overlayfs для настоящих системных модификаций
- Поддерживает несколько разделов (system, vendor, product, system_ext, odm, oem)
- Поддержка слоя чтения-записи через `/data/adb/modules/.rw/`

**Идентификация источника:**

```rust
// Из meta-overlayfs/src/mount.rs
fsconfig_set_string(fs, "source", "KSU")?;  // ОБЯЗАТЕЛЬНО!
```

Это устанавливает `dev=KSU` для всех overlay монтирований, обеспечивая правильную идентификацию.

### Лучшие Практики

При разработке метамодулей:

1. **Всегда устанавливайте источник в "KSU"** для операций монтирования - размонтированию ядра и zygisksu нужно это для правильного размонтирования
2. **Обрабатывайте ошибки корректно** - процессы загрузки чувствительны ко времени
3. **Уважайте стандартные флаги** - поддерживайте `skip_mount` и `disable`
4. **Логируйте операции** - используйте `echo` или логирование для отладки
5. **Тщательно тестируйте** - ошибки монтирования могут вызвать циклы загрузки
6. **Документируйте поведение** - ясно объясняйте, что делает ваш метамодуль
7. **Предоставляйте пути миграции** - помогайте пользователям переключаться с других решений

### Тестирование Вашего Метамодуля

Перед выпуском:

1. **Тестируйте установку** на чистой настройке KernelSU
2. **Проверяйте монтирование** с различными типами модулей
3. **Проверяйте совместимость** с распространенными модулями
4. **Тестируйте удаление** и очистку
5. **Проверяйте производительность загрузки** (metamount.sh блокирует!)
6. **Обеспечьте правильную обработку ошибок** для избежания циклов загрузки

## Часто Задаваемые Вопросы

### Нужен ли мне метамодуль?

**Для пользователей**: Только если вы хотите использовать модули, требующие монтирования. Если вы используете только модули, которые запускают скрипты без изменения системных файлов, вам не нужен метамодуль.

**Для разработчиков модулей**: Нет, вы разрабатываете модули как обычно. Пользователям нужен метамодуль только если ваш модуль требует монтирования.

**Для продвинутых пользователей**: Только если вы хотите настроить поведение монтирования или создать альтернативные реализации монтирования.

### Могу ли я иметь несколько метамодулей?

Нет. Одновременно может быть установлен только один метамодуль. Это предотвращает конфликты и обеспечивает предсказуемое поведение.

### Что произойдет, если я удалю свой единственный метамодуль?

Модули больше не будут монтироваться. Ваше устройство будет загружаться нормально, но модификации модулей не будут применяться, пока вы не установите другой метамодуль.

### Обязателен ли meta-overlayfs?

Нет. Он обеспечивает стандартное монтирование overlayfs, совместимое с большинством модулей. Вы можете создать свой собственный метамодуль, если вам нужно другое поведение.

## См. Также

- [Руководство по Модулям](module.md) - Общая разработка модулей
- [Разница с Magisk](difference-with-magisk.md) - Сравнение KernelSU и Magisk
- [Как Собрать](how-to-build.md) - Сборка KernelSU из исходного кода

```

`website/docs/ru_RU/guide/module-config.md`:

```md
# Конфигурация модулей

KernelSU предоставляет встроенную систему конфигурации, которая позволяет модулям хранить постоянные или временные настройки в формате ключ-значение. Конфигурации хранятся в бинарном формате по пути `/data/adb/ksu/module_configs/<module_id>/` и имеют следующие характеристики:

## Типы конфигурации

- **Постоянная конфигурация** (`persist.config`): сохраняется после перезагрузки до явного удаления или деинсталляции модуля
- **Временная конфигурация** (`tmp.config`): автоматически очищается на этапе post-fs-data при каждой загрузке

При чтении конфигурации временные значения имеют приоритет над постоянными для одного и того же ключа.

## Использование конфигурации в скриптах модуля

Все скрипты модуля (`post-fs-data.sh`, `service.sh`, `boot-completed.sh` и др.) выполняются с установленной переменной окружения `KSU_MODULE`, содержащей ID модуля. Вы можете использовать команды `ksud module config` для управления конфигурацией модуля:

```bash
# Получить значение конфигурации
value=$(ksud module config get my_setting)

# Установить постоянное значение конфигурации
ksud module config set my_setting "some value"

# Установить временное значение конфигурации (очищается после перезагрузки)
ksud module config set --temp runtime_state "active"

# Установить значение из stdin (полезно для многострочного или сложного текста)
ksud module config set my_key <<EOF
многострочное
текстовое значение
EOF

# Или передать через pipe из команды
echo "значение" | ksud module config set my_key

# Явный флаг stdin
cat file.json | ksud module config set json_data --stdin

# Вывести все записи конфигурации (объединенные постоянные и временные)
ksud module config list

# Удалить запись конфигурации
ksud module config delete my_setting

# Удалить временную запись конфигурации
ksud module config delete --temp runtime_state

# Очистить все постоянные конфигурации
ksud module config clear

# Очистить все временные конфигурации
ksud module config clear --temp
```

## Ограничения валидации

Система конфигурации применяет следующие ограничения:

- **Максимальная длина ключа**: 256 байт
- **Максимальная длина значения**: 1МБ (1048576 байт)
- **Максимальное количество записей конфигурации**: 32 на модуль
- **Формат ключа**: Должен соответствовать `^[a-zA-Z][a-zA-Z0-9._-]+$` (как ID модуля)
  - Должен начинаться с буквы
  - Может содержать буквы, цифры, точки, подчеркивания или дефисы
  - Минимальная длина: 2 символа
- **Формат значения**: Без ограничений - может содержать любые UTF-8 символы, включая переносы строк и управляющие символы
  - Хранится в бинарном формате с префиксом длины для безопасной обработки всех данных

## Жизненный цикл

- **При загрузке**: все временные конфигурации очищаются на этапе post-fs-data
- **При деинсталляции модуля**: все конфигурации (постоянные и временные) автоматически удаляются
- Конфигурации хранятся в бинарном формате с магическим числом `0x4b53554d` ("KSUM") и проверкой версии

## Сценарии использования

Система конфигурации идеальна для:

- **Пользовательские настройки**: хранение настроек модуля, которые пользователи настраивают через WebUI или action-скрипты
- **Флаги функций**: включение/отключение функций модуля без переустановки
- **Состояние во время выполнения**: отслеживание временного состояния, которое должно сбрасываться при перезагрузке (используйте временную конфигурацию)
- **Настройки установки**: запоминание выбора, сделанного при установке модуля
- **Сложные данные**: Хранение JSON, многострочного текста, данных в кодировке Base64 или любого структурированного содержимого (до 1МБ)

::: tip ЛУЧШИЕ ПРАКТИКИ
- Используйте постоянную конфигурацию для пользовательских настроек, которые должны сохраняться после перезагрузки
- Используйте временную конфигурацию для состояния во время выполнения или флагов функций, которые должны сбрасываться при загрузке
- Проверяйте значения конфигурации в скриптах перед их использованием
- Используйте команду `ksud module config list` для отладки проблем с конфигурацией
:::

## Расширенные возможности

Система конфигурации модулей предоставляет специальные ключи конфигурации для расширенных сценариев использования:

### Переопределение описания модуля {#overriding-module-description}

Вы можете динамически переопределить поле `description` из `module.prop`, установив ключ конфигурации `override.description`:

```bash
# Переопределить описание модуля
ksud module config set override.description "Пользовательское описание, отображаемое в менеджере"
```

При получении списка модулей, если существует конфигурация `override.description`, она заменит исходное описание из `module.prop`. Это полезно для:
- Отображения динамической информации о состоянии в описании модуля
- Показа пользователям деталей конфигурации во время выполнения
- Обновления описания на основе состояния модуля без переустановки

### Объявление управляемых функций

Модули могут объявлять, какими функциями KernelSU они управляют, используя шаблон конфигурации `manage.<feature>`. Поддерживаемые функции соответствуют внутреннему перечислению `FeatureId` в KernelSU:

**Поддерживаемые функции:**
- `su_compat` - Режим совместимости SU
- `kernel_umount` - Автоматическое размонтирование ядра

```bash
# Объявить, что этот модуль управляет совместимостью SU и включает её
ksud module config set manage.su_compat true

# Объявить, что этот модуль управляет размонтированием ядра и отключает его
ksud module config set manage.kernel_umount false

# Удалить управление функцией (модуль больше не контролирует эту функцию)
ksud module config delete manage.su_compat
```

**Как это работает:**
- Наличие ключа `manage.<feature>` указывает, что модуль управляет этой функцией
- Значение указывает желаемое состояние: `true`/`1` для включения, `false`/`0` (или любое другое значение) для отключения
- Чтобы прекратить управление функцией, полностью удалите ключ конфигурации

Управляемые функции доступны через API списка модулей как поле `managedFeatures` (строка, разделённая запятыми). Это позволяет:
- Менеджеру KernelSU определять, какие модули управляют какими функциями KernelSU
- Предотвращать конфликты, когда несколько модулей пытаются управлять одной и той же функцией
- Улучшить координацию между модулями и основным функционалом KernelSU

::: warning ТОЛЬКО ПОДДЕРЖИВАЕМЫЕ ФУНКЦИИ
Используйте только предопределённые имена функций, перечисленные выше (`su_compat`, `kernel_umount`). Они соответствуют реальным внутренним функциям KernelSU. Использование других имён функций не вызовет ошибок, но не будет иметь никакого функционального назначения.
:::

```

`website/docs/ru_RU/guide/module-webui.md`:

```md
# Веб-интерфейс модуля

Помимо выполнения загрузочных скриптов и правки системных файлов, модули KernelSU могут показывать пользовательский интерфейс и напрямую взаимодействовать с пользователем.

Модуль может описать страницу на HTML + CSS + JavaScript, используя любые веб‑технологии. Менеджер KernelSU отображает такие страницы через WebView и предоставляет API для взаимодействия с системой, например для запуска shell-команд.

## Каталог `webroot`

Файлы веб-ресурсов должны располагаться в подкаталоге `webroot` в корне модуля, и там **ОБЯЗАТЕЛЬНО** должен находиться файл `index.html`, выступающий точкой входа. Самая простая структура модуля с веб-интерфейсом выглядит так:

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

::: warning
При установке модуля KernelSU автоматически задаёт права доступа и SELinux-контекст для этого каталога. Если вы не уверены, что делаете, не меняйте разрешения вручную!
:::

Если страница содержит CSS или JavaScript, их тоже нужно положить в этот каталог.

## JavaScript API

Если это только страница отображения, она работает как обычный веб-сайт. Но самое главное — KernelSU предоставляет набор системных API, позволяющих реализовать модуль‑специфичные функции.

KernelSU предлагает JavaScript-библиотеку, опубликованную в [npm](https://www.npmjs.com/package/kernelsu), которую можно использовать в коде страницы.

Например, можно выполнить shell-команду, чтобы получить конфигурацию или изменить свойство:

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

Также можно переключить страницу в полноэкранный режим или показать toast.

[Документация по API](https://www.npmjs.com/package/kernelsu)

Если существующего API недостаточно или им неудобно пользоваться, оставьте нам предложение [здесь](https://github.com/tiann/KernelSU/issues)!

## Несколько советов

1. `localStorage` можно использовать как обычно для хранения данных, но помните, что всё будет удалено при удалении приложения‑менеджера. Для постоянного хранения сохраните данные вручную в отдельном каталоге.
2. Для простых страниц мы рекомендуем использовать [parceljs](https://parceljs.org/) для сборки. Он не требует начальной настройки и очень прост. Но если вы опытный фронтенд‑разработчик или у вас есть собственные предпочтения, смело используйте любой другой инструмент!

```

`website/docs/ru_RU/guide/module.md`:

```md
# Руководство по разработке модулей {#introduction}

KernelSU предоставляет механизм модулей, позволяющий добиться эффекта модификации системного каталога при сохранении целостности системного раздела. Этот механизм принято называть "бессистемным".

Модульный механизм KernelSU практически аналогичен механизму Magisk. Если вы знакомы с разработкой модулей Magisk, то разработка модулей KernelSU очень похожа. Представление модулей ниже можно пропустить, достаточно прочитать [различия-с-magisk] (difference-with-magisk.md).

::: warning МЕТАМОДУЛЬ ТРЕБУЕТСЯ ТОЛЬКО ДЛЯ МОДИФИКАЦИИ СИСТЕМНЫХ ФАЙЛОВ
KernelSU использует архитектуру [метамодулей](metamodule.md) для монтирования директории `system`. **Только если вашему модулю нужно модифицировать файлы `/system`** (через директорию `system`), вам необходимо установить метамодуль (например, [meta-overlayfs](https://github.com/tiann/KernelSU/releases)). Другие функции модулей, такие как скрипты, правила sepolicy и system.prop, работают без метамодуля.
:::

## WebUI

KernelSU modules support displaying interfaces and interacting with users. See the [WebUI documentation](module-webui.md) for additional details.

## Конфигурация модулей

KernelSU предоставляет встроенную систему конфигурации, которая позволяет модулям хранить постоянные или временные настройки в формате ключ-значение. Подробности смотрите в [документации по конфигурации модулей](module-config.md).

## Busybox

В комплект поставки KernelSU входит полнофункциональный бинарный файл BusyBox (включая полную поддержку SELinux). Исполняемый файл находится по адресу `/data/adb/ksu/bin/busybox`. BusyBox от KernelSU поддерживает переключаемый во время работы "ASH Standalone Shell Mode". Этот автономный режим означает, что при запуске в оболочке `ash` BusyBox каждая команда будет напрямую использовать апплет внутри BusyBox, независимо от того, что задано в качестве `PATH`. Например, такие команды, как `ls`, `rm`, `chmod` будут **НЕ** использовать то, что находится в `PATH` (в случае Android по умолчанию это будут `/system/bin/ls`, `/system/bin/rm` и `/system/bin/chmod` соответственно), а вместо этого будут напрямую вызывать внутренние апплеты BusyBox. Это гарантирует, что скрипты всегда будут выполняться в предсказуемом окружении и всегда будут иметь полный набор команд, независимо от того, на какой версии Android они выполняются. Чтобы заставить команду _не_ использовать BusyBox, необходимо вызвать исполняемый файл с полными путями.

Каждый сценарий оболочки, запущенный в контексте KernelSU, будет выполняться в оболочке BusyBox `ash` с включенным автономным режимом. Для сторонних разработчиков это касается всех загрузочных скриптов и скриптов установки модулей.

Для тех, кто хочет использовать эту возможность "Автономного режима" вне KernelSU, есть два способа включить ее:

1. Установите переменной окружения `ASH_STANDALONE` значение `1`<br>Пример: `ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. Переключитесь с помощью параметров командной строки:<br>`/data/adb/ksu/bin/busybox sh -o standalone <script>`

Чтобы убедиться, что все последующие запуски оболочки `sh` также выполняются в автономном режиме, предпочтительным методом является вариант 1 (и это то, что KernelSU и менеджер KernelSU используют внутри), поскольку переменные окружения наследуются вплоть до дочерних процессов.

::: tip отличие от Magisk

BusyBox в KernelSU теперь использует бинарный файл, скомпилированный непосредственно из проекта Magisk. **Поэтому вам не нужно беспокоиться о проблемах совместимости между скриптами BusyBox в Magisk и KernelSU, поскольку они абсолютно одинаковы!
:::

## Модули KernelSU {#kernelsu-modules}

Модуль KernelSU - это папка, размещенная в каталоге `/data/adb/modules` и имеющая следующую структуру:

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- Папка имеет имя с идентификатором модуля
│   │
│   │      *** Идентификация модуля ***
│   │
│   ├── module.prop         <--- В этом файле хранятся метаданные модуля
│   │
│   │      *** Основное содержимое ***
│   │
│   ├── system              <--- Эта папка будет смонтирована, если skip_mount не существует
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** Флаги состояния ***
│   │
│   ├── skip_mount          <--- Если он существует, то KernelSU НЕ будет монтировать вашу системную папку
│   ├── disable             <--- Если модуль существует, то он будет отключен
│   ├── remove              <--- Если модуль существует, то при следующей перезагрузке он будет удален
│   │
│   │      *** Необязательные файлы ***
│   │
│   ├── post-fs-data.sh     <--- Этот скрипт будет выполняться в post-fs-data
│   ├── service.sh          <--- Этот скрипт будет выполняться в сервисе late_start
|   ├── uninstall.sh        <--- Этот скрипт будет выполнен, когда KernelSU удалит ваш модуль
│   ├── system.prop         <--- Свойства из этого файла будут загружены в качестве системных свойств программой resetprop
│   ├── sepolicy.rule       <--- Дополнительные пользовательские правила sepolicy
│   │
│   │      *** Автоматически генерируется, НЕЛЬЗЯ создавать или изменять вручную ***
│   │
│   ├── vendor              <--- Символьная ссылка на $MODID/system/vendor
│   ├── product             <--- Символьная ссылка на $MODID/system/product
│   ├── system_ext          <--- Симлинк на $MODID/system/system_ext
│   │
│   │      *** Допускается использование любых дополнительных файлов/папок ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip различия с Magisk
KernelSU не имеет встроенной поддержки Zygisk, поэтому в модуле нет содержимого, связанного с Zygisk. Однако для поддержки модулей Zygisk можно использовать [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext). В этом случае содержимое модуля Zygisk идентично содержимому, поддерживаемому Magisk.
:::

### module.prop

module.prop - это конфигурационный файл модуля. В KernelSU, если модуль не содержит этого файла, он не будет распознан как модуль. Формат этого файла следующий:

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
actionIcon=<path> (optional)
webuiIcon=<path> (optional)
```

- `id` должно соответствовать данному регулярному выражению: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
  экс: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
  Это **уникальный идентификатор** вашего модуля. Не следует изменять его после публикации.
- `versionCode` должен быть **целым**. Это используется для сравнения версий.
- Другими, не упомянутыми выше, могут быть любые **однострочные** строки.
- Обязательно используйте тип перевода строки `UNIX (LF)`, а не `Windows (CR+LF)` или `Macintosh (CR)`.
- `actionIcon` и `webuiIcon` — необязательные пути к изображениям, которые
  используются как значки по умолчанию для ярлыков действия и WebUI модуля в
  менеджере. Эти пути должны быть относительными к корневому каталогу модуля. Например,
  `actionIcon=icon/icon.png` будет интерпретирован как `<MODDIR>/icon/icon.png`.

::: tip ДИНАМИЧЕСКОЕ ОПИСАНИЕ
Поле `description` может быть динамически переопределено во время выполнения с помощью системы конфигурации модулей. Подробности см. в разделе [Переопределение описания модуля](module-config.md#overriding-module-description).
:::

### Сценарии командной оболочки {#shell-scripts}

Чтобы понять разницу между `post-fs-data.sh` и `Service.sh`, прочитайте раздел [Boot Scripts](#boot-scripts). Для большинства разработчиков модулей `service.sh` должно быть достаточно, если вам нужно просто запустить загрузочный скрипт.

Во всех скриптах вашего модуля используйте `MODDIR=${0%/*}` для получения пути к базовому каталогу вашего модуля; **НЕ** кодируйте жестко путь к вашему модулю в скриптах.

::: tip различия с Magisk
С помощью переменной окружения KSU можно определить, выполняется ли сценарий в KernelSU или в Magisk. Если скрипт выполняется в KernelSU, то это значение будет равно true.
:::

### каталог `system` {#system-directories}

После загрузки системы содержимое этого каталога будет наложено поверх раздела /system. Это означает, что:

::: tip ТРЕБОВАНИЕ МЕТАМОДУЛЯ
Директория `system` монтируется только если у вас установлен метамодуль, предоставляющий функциональность монтирования (например, `meta-overlayfs`). Метамодуль обрабатывает способ монтирования модулей. См. [Руководство по метамодулям](metamodule.md) для получения дополнительной информации.
:::

1. Файлы с теми же именами, что и в соответствующем каталоге в системе, будут перезаписаны файлами в этом каталоге.
2. Папки с теми же именами, что и в соответствующем каталоге в системе, будут объединены с папками в этом каталоге.

Если вы хотите удалить файл или папку в исходном каталоге системы, необходимо создать файл с тем же именем, что и файл/папка, в каталоге модуля с помощью команды `mknod filename c 0 0`. Таким образом, система overlayfs автоматически "забелит" этот файл, как если бы он был удален (раздел /system при этом фактически не изменится).

Вы также можете объявить в `customize.sh` переменную с именем `REMOVE`, содержащую список каталогов для выполнения операций удаления, и KernelSU автоматически выполнит команду `mknod <TARGET> c 0 0` в соответствующих каталогах модуля. Например:

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

В приведенном выше списке будут выполнены команды `mknod $MODPATH/system/app/YouTuBe c 0 0` и `mknod $MODPATH/system/app/Bloatware c 0 0`; при этом `/system/app/YouTube` и `/system/app/Bloatware` будут удалены после вступления модуля в силу.

Если вы хотите заменить каталог в системе, то необходимо создать каталог с тем же путем в каталоге модуля, а затем установить для этого каталога атрибут `setfattr -n trusted.overlay.opaque -v y <TARGET>`. Таким образом, система overlayfs автоматически заменит соответствующий каталог в системе (без изменения раздела /system).

Вы можете объявить в файле `customize.sh` переменную с именем `REPLACE`, содержащую список заменяемых каталогов, и KernelSU автоматически выполнит соответствующие операции в каталоге вашего модуля. Например:

REPLACE="
/system/app/YouTube
/system/app/Bloatware
"

В этом списке будут автоматически созданы каталоги `$MODPATH/system/app/YouTube` и `$MODPATH/system/app/Bloatware`, а затем выполнены команды `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/YouTube` и `setfattr -n trusted.overlay.opaque -v y $MODPATH/system/app/Bloatware`. После вступления модуля в силу каталоги `/system/app/YouTube` и `/system/app/Bloatware` будут заменены на пустые.

::: tip различия с Magisk

KernelSU использует архитектуру [метамодулей](metamodule.md), где монтирование делегируется подключаемым метамодулям. Официальный метамодуль `meta-overlayfs` использует OverlayFS ядра для бессистемных модификаций, в то время как Magisk использует magic mount (bind mount), встроенный непосредственно в его ядро. Оба достигают одной цели: модификация файлов `/system` без физического изменения раздела `/system`. Подход KernelSU обеспечивает большую гибкость и уменьшает поверхность обнаружения.
:::

Если вы заинтересованы в использовании overlayfs, рекомендуется прочитать [документацию по overlayfs](https://docs.kernel.org/filesystems/overlayfs.html) ядра Linux.

### system.prop

Этот файл имеет тот же формат, что и `build.prop`. Каждая строка состоит из `[key]=[value]`.

### sepolicy.rule

Если для вашего модуля требуются дополнительные патчи sepolicy, добавьте эти правила в данный файл. Каждая строка в этом файле будет рассматриваться как утверждение политики.

## Установщик модулей {#module-installer}

Инсталлятор модуля KernelSU - это модуль KernelSU, упакованный в zip-файл, который может быть прошит в APP-менеджере KernelSU. Простейший установщик модуля KernelSU - это просто модуль KernelSU, упакованный в zip-файл.

```txt
module.zip
│
├── customize.sh                       <--- (Необязательно, более подробно позже)
│                                           Этот скрипт будет использоваться в update-binary
├── ...
├── ...  /* Остальные файлы модуля */
│
```

:::warning
Модуль KernelSU НЕ поддерживается для установки в пользовательское Recovery!!!
:::

### Персонализация {#customizing-installation}

Если вам необходимо настроить процесс установки модуля, то в качестве опции вы можете создать в программе установки скрипт с именем `customize.sh`. Этот скрипт будет _источником_ (не исполняться!) сценария установщика модуля после извлечения всех файлов и применения стандартных разрешений и secontext. Это очень удобно, если ваш модуль требует дополнительной настройки в зависимости от ABI устройства, или вам необходимо установить специальные разрешения/секонтекст для некоторых файлов модуля.

Если вы хотите полностью контролировать и настраивать процесс установки, объявите `SKIPUNZIP=1` в файле `customize.sh`, чтобы пропустить все шаги установки по умолчанию. При этом ваш `customize.sh` будет сам отвечать за установку.

Сценарий `customize.sh` запускается в оболочке BusyBox `ash` KernelSU с включенным "Автономным режимом". Доступны следующие переменные и функции:

#### Переменные

- `KSU` (bool): переменная, отмечающая, что скрипт выполняется в окружении KernelSU, причем значение этой переменной всегда будет true. Ее можно использовать для различения KernelSU и Magisk.
- `KSU_VER` (string): строка версии текущего установленного KernelSU (например, `v0.4.0`)
- `KSU_VER_CODE` (int): код версии текущего установленного KernelSU в пользовательском пространстве (например, `10672`)
- `KSU_KERNEL_VER_CODE` (int): код версии текущей установленной KernelSU в пространстве ядра (например, `10672`)
- `BOOTMODE` (bool): в KernelSU всегда должно быть `true`.
- `MODPATH` (path): путь, по которому должны быть установлены файлы ваших модулей
- `TMPDIR` (path): место, где вы можете временно хранить файлы
- `ZIPFILE` (path): установочный zip-архив вашего модуля
- `ARCH` (string): архитектура процессора устройства. Значение: `arm`, `arm64`, `x86` или `x64`.
- `IS64BIT` (bool): `true`, если `$ARCH` имеет значение `arm64` или `x64`.
- `API` (int): уровень API (версия Android) устройства (например, `23` для Android 6.0)

::: warning
В KernelSU MAGISK_VER_CODE всегда равен 25200, а MAGISK_VER всегда равен v25.2. Пожалуйста, не используйте эти две переменные для определения того, запущен ли он на KernelSU или нет.
:::

#### Функции {#functions}

```txt
ui_print <msg>
    вывести <msg> на консоль
    Избегайте использования 'echo', так как он не будет отображаться в консоли пользовательского recovery

abort <msg>
    вывести сообщение об ошибке <msg> на консоль и завершить установку
    Избегайте использования команды 'exit', так как в этом случае будут пропущены шаги очистки завершения установки

set_perm <target> <owner> <group> <permission> [context]
    если [context] не задан, то по умолчанию используется "u:object_r:system_file:s0".
    Эта функция является сокращением для следующих команд:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    если [context] не задан, то по умолчанию используется "u:object_r:system_file:s0".
    для всех файлов в <directory> будет вызвана команда:
       set_perm file owner group filepermission context
    для всех каталогов в <directory> (включая себя самого), он вызовет:
       set_perm dir owner group dirpermission context
```

## Загрузочные сценарии {#boot-scripts}

В KernelSU скрипты делятся на два типа в зависимости от режима их работы: режим post-fs-data и режим late_start service:

- режим post-fs-data
  - Эта стадия является БЛОКИРУЮЩЕЙ. Процесс загрузки приостанавливается до завершения выполнения или по истечении 10 секунд.
  - Сценарии запускаются до того, как будут смонтированы какие-либо модули. Это позволяет разработчику модулей динамически настраивать свои модули до того, как они будут смонтированы.
  - Этот этап происходит до запуска Zygote, что практически означает, что все в Android
  - **ПРЕДУПРЕЖДЕНИЕ:** использование `setprop` приведет к блокировке процесса загрузки! Вместо этого используйте `resetprop -n <prop_name> <prop_value>`.
  - Запускайте скрипты в этом режиме только в случае необходимости.
- режим обслуживания late_start
  - Эта стадия является НЕБЛОКИРУЮЩЕЙ. Ваш скрипт выполняется параллельно с остальным процессом загрузки.
  - **Это рекомендуемый этап для запуска большинства скриптов.**

В KernelSU скрипты запуска делятся на два типа по месту их хранения: общие скрипты и скрипты модулей:

- Общие скрипты
  - Размещаются в файлах `/data/adb/post-fs-data.d` или `/data/adb/service.d`.
  - Выполняется только в том случае, если скрипт установлен как исполняемый (`chmod +x script.sh`)
  - Скрипты в `post-fs-data.d` выполняются в режиме post-fs-data, а скрипты в `service.d` - в режиме late_start service.
  - Модули не должны **НЕ** добавлять общие скрипты при установке
- Скрипты модуля
  - Размещаются в отдельной папке модуля
  - Выполняются только в том случае, если модуль включен
  - `post-fs-data.sh` запускается в режиме post-fs-data, а `service.sh` - в режиме late_start service.

Все загрузочные скрипты будут выполняться в оболочке BusyBox `ash` от KernelSU с включенным "Автономным режимом".

```

`website/docs/ru_RU/guide/rescue-from-bootloop.md`:

```md
# Выход из циклической загрузки {#intruduction}

При прошивке устройства могут возникать ситуации, когда устройство становится "окирпиченным". Теоретически, если использовать fastboot только для прошивки загрузочного раздела или установить неподходящие модули, из-за которых устройство не загружается, то это можно восстановить соответствующими операциями. В данном документе описаны некоторые экстренные методы восстановления работоспособности "окирпиченного" устройства.

## Кирпич путем перепрошивки загрузочного раздела

В KernelSU при прошивке загрузочного раздела могут возникнуть следующие ситуации:

1. Загрузочный образ прошивается в неправильном формате. Например, если формат загрузки телефона - `gz`, а вы прошили образ в формате `lz4`, то телефон не сможет загрузиться.
2. Для корректной загрузки телефона необходимо отключить проверку AVB (обычно для этого требуется стереть все данные на телефоне).
3. Ядро содержит ошибки или не подходит для прошивки телефона.

Независимо от ситуации, восстановить работоспособность можно путем **прошивки стокового загрузочного образа**. Поэтому в начале руководства по установке мы настоятельно рекомендуем создать резервную копию стокового загрузочного образа перед прошивкой. Если у вас нет резервной копии, вы можете получить оригинальную заводскую загрузку от других пользователей с таким же устройством, как у вас, или из официальной прошивки.

## Окирпичивание из-за модулей

Установка модулей может быть более распространенной причиной окирпичивания устройства, но мы должны серьезно предупредить вас: **Не устанавливайте модули из неизвестных источников**! Поскольку модули обладают правами root, они могут нанести непоправимый ущерб вашему устройству!

### Нормальные модули

Если вы прошили модуль, безопасность которого доказана, но он приводит к невозможности загрузки устройства, то такая ситуация легко восстанавливается в KernelSU без каких-либо проблем. KernelSU имеет встроенные механизмы для спасения устройства, в том числе следующие:

1. Обновление AB
2. Восстановление при нажатии клавиши уменьшения громкости

#### AB-обновление {#ab-update}

Механизм обновления модулей в KernelSU основан на механизме AB-обновления, используемом в OTA-обновлениях системы Android. При установке нового модуля или обновлении существующего он не будет напрямую изменять текущий файл модуля. Вместо этого все модули будут встроены в другой образ обновления. После перезагрузки системы она попытается начать использовать этот образ обновления. Если система Android успешно загрузится, то модули будут действительно обновлены.

Поэтому самым простым и наиболее часто используемым методом спасения устройства является **принудительная перезагрузка**. Если после прошивки модуля не удается запустить систему, можно нажать и удерживать кнопку питания более 10 секунд, после чего система автоматически перезагрузится; после перезагрузки произойдет откат к состоянию до обновления модуля, а ранее обновленные модули будут автоматически отключены.

#### Спасение, с зажатой клавишей уменьшения громкости {#volume-down}

Если обновление AB не помогло решить проблему, можно попробовать использовать **Безопасный режим**. В безопасном режиме все модули отключены.

Войти в безопасный режим можно двумя способами:

1. Встроенный безопасный режим некоторых систем; некоторые системы имеют встроенный безопасный режим, доступ к которому осуществляется долгим нажатием кнопки уменьшения громкости, в то время как другие (например, MIUI) могут включить безопасный режим в Recovery. При входе в безопасный режим системы KernelSU также переходит в безопасный режим и автоматически отключает модули.
2. Встроенный безопасный режим KernelSU; метод работы заключается в том, что после первого экрана загрузки необходимо **непрерывно нажать клавишу уменьшения громкости более трех раз**. Обратите внимание, что именно нажать-отпустить, нажать-отпустить, нажать-отпустить, а не нажать и удерживать.

После входа в безопасный режим все модули на странице модулей менеджера KernelSU Manager отключаются, но можно выполнить операцию "деинсталляция" для удаления модулей, которые могут вызывать проблемы.

Встроенный безопасный режим реализован в ядре, поэтому вероятность пропуска ключевых событий из-за перехвата исключена. Однако для ядер, отличных от ГКИ, может потребоваться ручная интеграция кода, и за рекомендациями можно обратиться к официальной документации.

### Вредоносные модули

Если описанные выше способы не помогли спасти устройство, то высока вероятность того, что установленный модуль имеет вредоносные операции или повредил устройство иным способом. В этом случае есть только два варианта:

1. Стереть данные и прошить официальную систему.
2. Обратиться в сервисную службу.

```

`website/docs/ru_RU/guide/unofficially-support-devices.md`:

```md
# Неофициально поддерживаемые устройства

::: warning
Этот документ предназначен только для архивных ссылок и больше не обновляется.
Начиная с KernelSU v1.0, мы отказались от официальной поддержки устройств не-GKI.
:::

::: warning
На этой странице представлены ядра для устройств, не поддерживающих ГКИ и поддерживающих KernelSU, которые поддерживаются другими разработчиками.
:::

::: warning
Эта страница предназначена только для поиска исходного кода, соответствующего вашему устройству, и **НЕ** означает, что исходный код был проверен _разработчиками KernelSU_. Вы должны использовать его на свой страх и риск.
:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>Сопровождающий</th>
         <th>Репозиторий</th>
         <th>Поддерживаемое устройство</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>

```

`website/docs/ru_RU/guide/what-is-kernelsu.md`:

```md
# Что такое KernelSU? {#introduction}

KernelSU - это root-решение для устройств Android GKI, работающее в режиме ядра и предоставляющее root-права пользовательским приложениям непосредственно в пространстве ядра.

## Особенности {#features}

Основной особенностью KernelSU является то, что он **основан на ядре**. KernelSU работает в режиме ядра, поэтому он может предоставить интерфейс ядра, которого раньше не было. Например, мы можем добавить аппаратную точку останова любому процессу в режиме ядра; мы можем получить доступ к физической памяти любого процесса без чьего-либо ведома; мы можем перехватить любой syscall в пространстве ядра; и т.д.

Кроме того, KernelSU предоставляет [систему metamodule](metamodule.md), которая является подключаемой архитектурой для управления модулями. В отличие от традиционных root-решений, которые встраивают логику монтирования в свое ядро, KernelSU делегирует это metamodules. Это позволяет устанавливать metamodules (например [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs)) для обеспечения бессистемных модификаций раздела `/system` и других разделов.

## Как использовать {#how-to-use}

Пожалуйста, обратитесь к: [Установка](installation)

## Как собрать {#how-to-build}

[Как собрать](how-to-build)

## Обсуждение {#discussion}

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/ru_RU/index.md`:

```md
---
layout: home
title: Основанное на ядре root-решение для Android

hero:
  name: KernelSU
  text: Основанное на ядре root-решение для Android
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: Начало работы
      link: /ru_RU/guide/what-is-kernelsu
    - theme: alt
      text: Посмотр на GitHub
      link: https://github.com/tiann/KernelSU

features:
  - title: Основанный на ядре
    details: KernelSU работает в режиме ядра Linux, он имеет больше контроля над пользовательскими приложениями.
  - title: Контроль доступа по белому списку
    details: Только приложение, которому предоставлено разрешение root, может получить доступ к `su`, другие приложения не могут воспринимать su.
  - title: Ограниченные root-права
    details: KernelSU позволяет вам настраивать uid, gid, группы, возможности и правила SELinux для su. Заприте root-власть в клетке.
  - title: Система Metamodule
    details: Подключаемая модульная инфраструктура позволяет модифицировать /system без изменения системы. Установите metamodule (например meta-overlayfs) для включения монтирования модулей.


```

`website/docs/vi_VN/guide/app-profile.md`:

```md
# App Profile

App Profile là một cơ chế do KernelSU cung cấp để tùy chỉnh cấu hình của các ứng dụng khác nhau.

Đối với các ứng dụng được cấp quyền root (tức là có thể sử dụng `su`), App Profile cũng có thể được gọi là Root Profile. Nó cho phép tùy chỉnh các quy tắc `uid`, `gid`, `groups`, `capabilities` và `SELinux` của lệnh `su`, do đó hạn chế các đặc quyền của người dùng root. Ví dụ: nó có thể chỉ cấp quyền mạng cho các ứng dụng tường lửa trong khi từ chối quyền truy cập tệp hoặc có thể cấp quyền shell thay vì quyền truy cập root đầy đủ cho các ứng dụng đóng băng: **giữ nguồn điện theo nguyên tắc đặc quyền tối thiểu.**

Đối với các ứng dụng thông thường không có quyền root, App Profile có thể kiểm soát hành vi của hệ thống kernel và mô-đun đối với các ứng dụng này. Ví dụ, nó có thể xác định liệu các sửa đổi do mô-đun tạo ra có nên được giải quyết hay không. Hệ thống kernel và mô-đun có thể đưa ra quyết định dựa trên cấu hình này, chẳng hạn như thực hiện các hoạt động tương tự như "hiding"

## Root Profile

### UID, GID, và Groups

Hệ thống Linux có hai khái niệm: người dùng (user) và nhóm (group). Mỗi người dùng có một user ID (UID) và một người dùng có thể thuộc nhiều nhóm, mỗi nhóm có group ID (GID) riêng. Những ID này được sử dụng để xác định người dùng trong hệ thống và xác định tài nguyên hệ thống nào họ có thể truy cập.

Người dùng có UID bằng 0 được gọi là người dùng root và các nhóm có GID bằng 0 được gọi là nhóm root. Nhóm người dùng root thường giữ các đặc quyền hệ thống cao nhất.

Trong trường hợp hệ thống Android, mỗi ứng dụng là một người dùng riêng biệt (không bao gồm các trường hợp UID dùng chung) với một UID duy nhất. Ví dụ: `0` đại diện cho người dùng root, `1000` đại diện cho `system`, `2000` đại diện cho ADB shell và các UID từ 10000 đến 19999 đại diện cho các ứng dụng thông thường.

:::info
Ở đây, UID được đề cập không giống với khái niệm nhiều người dùng hoặc hồ sơ công việc (Work profile) trong hệ thống Android. Hồ sơ công việc thực sự được triển khai bằng cách phân vùng phạm vi UID. Ví dụ: 10000-19999 đại diện cho người dùng chính, trong khi 110000-119999 đại diện cho hồ sơ công việc. Mỗi ứng dụng thông thường trong số đó đều có UID riêng.
:::

Mỗi ứng dụng có thể có nhiều nhóm, với GID đại diện cho nhóm chính, thường khớp với UID. Các nhóm khác được gọi là nhóm bổ sung. Một số quyền nhất định được kiểm soát thông qua các nhóm, chẳng hạn như quyền truy cập mạng hoặc truy cập Bluetooth.

Ví dụ: nếu chúng ta thực thi lệnh `id` trong shell ADB, kết quả đầu ra có thể trông như thế này:

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

Ở đây, UID là `2000` và GID (ID nhóm chính) cũng là `2000`. Ngoài ra, nó thuộc một số nhóm bổ sung, chẳng hạn như `inet` (biểu thị khả năng tạo ổ cắm `AF_INET` và `AF_INET6`) và `sdcard_rw` (biểu thị quyền đọc/ghi đối với thẻ SD).

Root Profile của KernelSU cho phép tùy chỉnh UID, GID và các nhóm cho quy trình gốc sau khi thực thi `su`. Ví dụ: Cấu hình gốc của ứng dụng gốc có thể đặt UID của nó thành `2000`, có nghĩa là khi sử dụng `su`, các quyền thực tế của ứng dụng sẽ ở cấp shell ADB. Nhóm `inet` có thể bị xóa, ngăn lệnh `su` truy cập mạng.

:::tip Ghi chú
Hồ sơ ứng dụng chỉ kiểm soát các quyền của tiến trình gốc sau khi sử dụng `su`; nó không kiểm soát các quyền của ứng dụng. Nếu một ứng dụng đã yêu cầu quyền truy cập mạng, ứng dụng đó vẫn có thể truy cập mạng ngay cả khi không sử dụng `su`. Việc xóa nhóm `inet` khỏi `su` chỉ ngăn `su` truy cập mạng.
:::

Root Profile được thực thi trong kernel và không dựa vào hành vi tự nguyện của các ứng dụng root, không giống như việc chuyển đổi người dùng hoặc nhóm thông qua `su`, việc cấp quyền `su` hoàn toàn phụ thuộc vào người dùng chứ không phải nhà phát triển.

### Capabilities

Capabilities (khả năng) là một cơ chế phân tách đặc quyền trong Linux.

Với mục đích thực hiện kiểm tra quyền, việc triển khai UNIX truyền thống phân biệt hai loại quy trình: quy trình đặc quyền (có ID người dùng hiệu quả là 0, được gọi là siêu người dùng hoặc root) và quy trình không có đặc quyền (có UID hiệu dụng khác 0). Các quy trình đặc quyền bỏ qua tất cả các bước kiểm tra quyền của kernel, trong khi các quy trình không có đặc quyền phải chịu sự kiểm tra quyền đầy đủ dựa trên thông tin xác thực của quy trình (thường là: UID hiệu quả, GID hiệu quả và danh sách nhóm bổ sung).

Bắt đầu với Linux 2.2, Linux chia các đặc quyền truyền thống được liên kết với siêu người dùng thành các đơn vị riêng biệt, được gọi là các khả năng, có thể được bật và tắt một cách độc lập.

Mỗi Khả năng đại diện cho một hoặc nhiều đặc quyền. Ví dụ: `CAP_DAC_READ_SEARCH` thể hiện khả năng bỏ qua việc kiểm tra quyền để đọc tệp cũng như quyền đọc và thực thi thư mục. Nếu người dùng có UID hiệu dụng là `0` (người dùng root) thiếu khả năng `CAP_DAC_READ_SEARCH` hoặc cao hơn, điều này có nghĩa là ngay cả khi họ là root, họ không thể tùy ý đọc tệp.

Cấu hình gốc của KernelSU cho phép tùy chỉnh các Khả năng của tiến trình gốc sau khi thực thi `su`, nhờ đó đạt được việc cấp một phần "quyền root". Không giống như UID và GID đã nói ở trên, một số ứng dụng gốc nhất định yêu cầu UID là `0` sau khi sử dụng `su`. Trong những trường hợp như vậy, việc giới hạn Khả năng của người dùng root này bằng UID `0` có thể hạn chế các hoạt động được phép của họ.

:::tip Rất Khuyến Nghị
Capabilities của Linux [tài liệu chính thức](https://man7.org/linux/man-pages/man7/capabilities.7.html) cung cấp giải thích chi tiết về các khả năng mà mỗi Capabilities thể hiện. Nếu bạn có ý định tùy chỉnh Capabilities, bạn nên đọc tài liệu này trước.
:::

### SELinux

SELinux là một cơ chế Kiểm Soát Truy Cập Bắt Buộc (Mandatory Access Control: MAC) mạnh mẽ. Nó hoạt động theo nguyên tắc **từ chối mặc định**: bất kỳ hành động nào không được cho phép rõ ràng đều bị từ chối.

SELinux có thể chạy ở hai chế độ chung:

1. Chế độ cho phép (Permissive mode): Các sự kiện từ chối được ghi lại nhưng không được thực thi.
2. Chế độ thực thi (Enforcing mode): Các sự kiện từ chối được ghi lại và thực thi.

:::warning Cảnh báo
Các hệ thống Android hiện đại phụ thuộc rất nhiều vào SELinux để đảm bảo an ninh hệ thống tổng thể. Chúng tôi khuyên bạn không nên sử dụng bất kỳ hệ thống tùy chỉnh nào chạy ở "chế độ cho phép" vì nó không mang lại lợi thế đáng kể nào so với hệ thống mở hoàn toàn.
:::

Việc giải thích khái niệm đầy đủ về SELinux rất phức tạp và nằm ngoài phạm vi của tài liệu này. Trước tiên nên hiểu hoạt động của nó thông qua các tài nguyên sau:

1. [Wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Red Hat: What Is SELinux?](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

Root Profile của KernelSU cho phép tùy chỉnh ngữ cảnh SELinux của tiến trình gốc sau khi thực thi `su`. Các quy tắc kiểm soát truy cập cụ thể có thể được đặt cho bối cảnh này để cho phép kiểm soát chi tiết hơn các quyền .

Trong các trường hợp điển hình, khi một ứng dụng thực thi `su`, nó sẽ chuyển quy trình sang miền SELinux với **quyền truy cập không hạn chế**, chẳng hạn như `u:r:su:s0`. Thông qua Root Profile, miền này có thể được chuyển sang miền tùy chỉnh, chẳng hạn như `u:r:app1:s0` và một loạt quy tắc có thể được xác định cho miền này:

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

Lưu ý rằng quy tắc `allow app1 * * *` chỉ được sử dụng cho mục đích minh họa. Trong thực tế, quy tắc này không nên được sử dụng rộng rãi vì nó không khác nhiều so với chế độ cho phép.

### Escalation

Nếu cấu hình của Root Profile không được đặt đúng cách, một tình huống escalation (leo thang) có thể xảy ra: các hạn chế do Root Profile áp đặt có thể vô tình bị lỗi.

Ví dụ: nếu bạn cấp quyền root cho người dùng shell ADB (đây là trường hợp phổ biến), sau đó bạn cấp quyền root cho một ứng dụng thông thường nhưng định cấu hình cấu hình gốc của nó bằng UID 2000 (là UID của người dùng shell ADB) , ứng dụng có thể có được quyền truy cập root đầy đủ bằng cách thực hiện lệnh `su` hai lần:

1. Lần thực thi `su` đầu tiên phải tuân theo sự thực thi của App Profile và sẽ chuyển sang UID `2000` (adb shell) thay vì `0` (root).
2. Lần thực thi `su` thứ hai, vì UID là `2000` và bạn đã cấp quyền truy cập root cho UID `2000` (adb shell) trong cấu hình, ứng dụng sẽ có toàn quyền root.

:::warning Ghi chú
Hành vi này hoàn toàn được mong đợi và không phải là lỗi. Vì vậy, chúng tôi khuyến nghị như sau:

Nếu bạn thực sự cần cấp quyền root cho ADB (ví dụ: với tư cách là nhà phát triển), bạn không nên thay đổi UID thành `2000` khi định cấu hình Root Profile. Sử dụng `1000` (hệ thống) sẽ là lựa chọn tốt hơn.
:::

## Non-Root Profile

### Umount Modules

KernelSU cung cấp một cơ chế systemless để sửa đổi các phân vùng hệ thống, đạt được thông qua việc gắn overlayfs. Tuy nhiên, một số ứng dụng có thể nhạy cảm với hành vi đó. Do đó, chúng ta có thể dỡ bỏ các mô-đun được gắn trên các ứng dụng này bằng cách đặt tùy chọn "umount modules".

Ngoài ra, giao diện cài đặt của trình quản lý KernelSU cung cấp một công tắc cho "umount modules by default". Theo mặc định, công tắc này được **bật**, có nghĩa là KernelSU hoặc một số mô-đun sẽ hủy tải các mô-đun cho ứng dụng này trừ khi áp dụng cài đặt bổ sung. Nếu bạn không thích cài đặt này hoặc nếu nó ảnh hưởng đến một số ứng dụng nhất định, bạn có các tùy chọn sau:

1. Giữ nút chuyển cho "umount modules by default" và tắt riêng tùy chọn "umount modules" trong App Profile đối với các ứng dụng yêu cầu tải mô-đun (hoạt động như "whitelist").
2. Tắt khóa chuyển cho "umount modules by default" và bật riêng tùy chọn "umount modules" trong App Profile cho các ứng dụng yêu cầu dỡ bỏ mô-đun (hoạt động như "blacklist").

:::info
Trong các thiết bị sử dụng kernel phiên bản 5.10 trở lên, kernel thực hiện việc dỡ tải các mô-đun. Tuy nhiên, đối với các thiết bị chạy phiên bản kernel dưới 5.10, công tắc này chỉ đơn thuần là một tùy chọn cấu hình và bản thân KernelSU không thực hiện bất kỳ hành động nào. Một số mô-đun, chẳng hạn như Zygisksu, có thể sử dụng công tắc này để xác định xem có cần thiết phải dỡ bỏ mô-đun hay không.
:::

```

`website/docs/vi_VN/guide/difference-with-magisk.md`:

```md
# Sự khác biệt với Magisk

Mặc dù có nhiều điểm tương đồng giữa mô-đun KernelSU và mô-đun Magisk nhưng chắc chắn vẫn có một số khác biệt do cơ chế triển khai hoàn toàn khác nhau của chúng. Nếu muốn mô-đun của mình chạy trên cả Magisk và KernelSU, bạn phải hiểu những khác biệt này.

## Điểm tương đồng

- Định dạng file mô-đun: đều sử dụng định dạng zip để sắp xếp các mô-đun và định dạng của các mô-đun gần như giống nhau
- Thư mục cài đặt mô-đun: cả hai đều nằm trong `/data/adb/modules`
- systemless: cả hai đều hỗ trợ sửa đổi /system theo cách không có hệ thống thông qua các mô-đun
- post-fs-data.sh: thời gian thực hiện và ngữ nghĩa hoàn toàn giống nhau
- service.sh: thời gian thực hiện và ngữ nghĩa hoàn toàn giống nhau
- system.prop: hoàn toàn giống nhau
- sepolicy.rule: hoàn toàn giống nhau
- BusyBox: các tập lệnh được chạy trong BusyBox với "standalone mode" được bật trong cả hai trường hợp

## Điểm khác biệt

Trước khi hiểu sự khác biệt, bạn cần biết cách phân biệt mô-đun của bạn đang chạy trong KernelSU hay Magisk. Bạn có thể sử dụng biến môi trường `KSU` để phân biệt nó ở tất cả những nơi bạn có thể chạy tập lệnh mô-đun (`customize.sh`, `post-fs-data.sh`, `service.sh`). Trong KernelSU, biến môi trường này sẽ được đặt thành `true`.

Dưới đây là một số khác biệt:

- Không thể cài đặt các mô-đun KernelSU ở chế độ Recovery.
- Các mô-đun KernelSU không có hỗ trợ tích hợp cho Zygisk (nhưng bạn có thể sử dụng các mô-đun Zygisk thông qua [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).
- Phương pháp thay thế hoặc xóa file trong module KernelSU hoàn toàn khác với Magisk. KernelSU không hỗ trợ phương thức `.replace`. Thay vào đó, bạn cần tạo một file cùng tên với `mknod filename c 0 0` để xóa file tương ứng.
- Các thư mục của BusyBox khác nhau. BusyBox tích hợp trong KernelSU nằm ở `/data/adb/ksu/bin/busybox`, trong khi ở Magisk nó nằm ở `/data/adb/magisk/busybox`. **Lưu ý rằng đây là hoạt động nội bộ của KernelSU và có thể thay đổi trong tương lai!**
- KernelSU không hỗ trợ file `.replace`; tuy nhiên, KernelSU hỗ trợ biến `REMOVE` và `REPLACE` để xóa hoặc thay thế các tệp và thư mục.
- KernelSU thêm giai đoạn `boot-completed` để chạy một số script khi khởi động xong.
- KernelSU thêm giai đoạn `post-mount` để chạy một số tập lệnh sau khi gắn overlayfs

```

`website/docs/vi_VN/guide/faq.md`:

```md
# FAQ

## KernelSU có hỗ trợ thiết bị của tôi không?

KernelSU hỗ trợ các thiết bị chạy Android với bootloader đã mở khóa. Tuy nhiên, hỗ trợ chính thức chỉ dành cho GKI Linux Kernel 5.10+ (trong thực tế, điều này có nghĩa là thiết bị của bạn cần có Android 12 out-of-the-box để được hỗ trợ).

Bạn có thể dễ dàng kiểm tra hỗ trợ cho thiết bị của mình thông qua ứng dụng quản lý KernelSU, có sẵn [tại đây](https://github.com/tiann/KernelSU/releases).

Nếu ứng dụng hiển thị `Not installed`, điều đó có nghĩa là thiết bị của bạn được KernelSU hỗ trợ chính thức.

Nếu ứng dụng hiển thị `Unsupported`, điều đó có nghĩa là thiết bị của bạn hiện không được hỗ trợ chính thức. Tuy nhiên, bạn có thể build mã nguồn kernel và tích hợp KernelSU để làm cho nó hoạt động, hoặc sử dụng [Thiết bị được hỗ trợ không chính thức](unofficially-support-devices).

## KernelSU có cần mở khóa bootloader không?

Chắc chắn rồi.

## KernelSU có hỗ trợ module không?

Có, hầu hết các module Magisk hoạt động trên KernelSU. Tuy nhiên, nếu module của bạn cần sửa đổi các tệp `/system`, bạn cần cài đặt [metamodule](metamodule.md) (chẳng hạn như `meta-overlayfs`). Các tính năng module khác hoạt động mà không cần metamodule. Kiểm tra [Hướng dẫn Module](module.md) để biết thêm thông tin.

## KernelSU có hỗ trợ Xposed không?

Có, bạn có thể sử dụng LSPosed (hoặc các phái sinh Xposed hiện đại khác) với [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext).

## KernelSU có hỗ trợ Zygisk không?

KernelSU không có hỗ trợ Zygisk tích hợp sẵn, nhưng bạn có thể sử dụng module như [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) để hỗ trợ nó.

## KernelSU có tương thích với Magisk không?

Hệ thống module của KernelSU xung đột với magic mount của Magisk. Nếu có bất kỳ module nào được kích hoạt trong KernelSU, toàn bộ Magisk sẽ ngừng hoạt động.

Tuy nhiên, nếu bạn chỉ sử dụng `su` của KernelSU, nó sẽ hoạt động tốt với Magisk. KernelSU sửa đổi `kernel`, trong khi Magisk sửa đổi `ramdisk`, cho phép cả hai hoạt động cùng nhau.

## KernelSU sẽ thay thế Magisk?

Chúng tôi tin rằng không, và đó không phải là mục tiêu của chúng tôi. Magisk đã đủ tốt cho giải pháp root userspace và sẽ tồn tại lâu dài. Mục tiêu của KernelSU là cung cấp giao diện kernel cho người dùng, không phải để thay thế Magisk.

## KernelSU có thể hỗ trợ các thiết bị không phải GKI không?

Có thể. Nhưng bạn cần tải xuống mã nguồn kernel và tích hợp KernelSU vào source tree, sau đó tự biên dịch kernel.

## KernelSU có thể hỗ trợ các thiết bị dưới Android 12 không?

Chính kernel thiết bị ảnh hưởng đến khả năng tương thích của KernelSU, và nó không liên quan gì đến phiên bản Android. Hạn chế duy nhất là các thiết bị được ra mắt với Android 12 phải có phiên bản kernel 5.10+ (thiết bị GKI). Vì vậy:

1. Các thiết bị được ra mắt với Android 12 phải được hỗ trợ.
2. Các thiết bị có kernel cũ (một số thiết bị với Android 12 cũng có kernel cũ) tương thích (bạn cần tự build kernel).

## KernelSU có thể hỗ trợ kernel cũ không?

Có thể. KernelSU hiện đã được backport cho kernel 4.14. Đối với các kernel cũ hơn, bạn cần tự backport, và PR luôn được chào đón!

## Làm cách nào để tích hợp KernelSU cho kernel cũ?

Vui lòng kiểm tra hướng dẫn [Tích hợp cho thiết bị không phải GKI](how-to-integrate-for-non-gki).

## Tại sao phiên bản Android của tôi là 13, nhưng kernel hiển thị "android12-5.10"?

Phiên bản kernel không liên quan gì đến phiên bản Android. Nếu bạn cần flash kernel, luôn sử dụng phiên bản kernel; phiên bản Android không quan trọng bằng.

## Tôi là GKI 1.0, tôi có thể sử dụng điều này không?

GKI 1.0 hoàn toàn khác với GKI 2.0, bạn phải tự biên dịch kernel.

## Làm cách nào để làm cho `/system` RW?

Chúng tôi không khuyến nghị bạn sửa đổi trực tiếp phân vùng hệ thống. Vui lòng kiểm tra [Hướng dẫn Module](module.md) để sửa đổi nó một cách systemless. Nếu bạn khăng khăng làm điều này, hãy kiểm tra [magisk_overlayfs](https://github.com/HuskyDG/magic_overlayfs).

## KernelSU có thể sửa đổi hosts không? Làm cách nào để sử dụng AdAway?

Tất nhiên. Nhưng KernelSU không có hỗ trợ hosts tích hợp sẵn, bạn có thể cài đặt module như [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module) để thực hiện.

## Tại sao các module của tôi không hoạt động sau khi cài đặt mới?

Nếu các module của bạn cần sửa đổi các tệp `/system`, bạn cần cài đặt [metamodule](metamodule.md) để mount thư mục `system`. Các tính năng module khác (scripts, sepolicy, system.prop) hoạt động mà không cần metamodule.

**Giải pháp**: Xem [Hướng dẫn Metamodule](metamodule.md) để biết hướng dẫn cài đặt.

## Metamodule là gì và tại sao tôi cần nó?

Metamodule là một module đặc biệt cung cấp cơ sở hạ tầng để mount các module thông thường. Xem [Hướng dẫn Metamodule](metamodule.md) để biết giải thích đầy đủ.

```

`website/docs/vi_VN/guide/hidden-features.md`:

```md
# Tính Năng Ẩn

## .ksurc

Theo mặc định, `/system/bin/sh` tải `/system/etc/mkshrc`.

Bạn có thể tạo su tải tệp rc tùy chỉnh bằng cách tạo tệp `/data/adb/ksu/.ksurc`.

```

`website/docs/vi_VN/guide/how-to-build.md`:

```md
# Làm thế nào để xây dựng KernelSU?

::: warning
Tài liệu này chỉ để tham khảo lưu trữ và không còn được duy trì.
Kể từ KernelSU v3.0, chúng tôi đã ngừng hỗ trợ chính thức cho chế độ ảnh GKI để có tốc độ lặp và build nhanh hơn. Khuyến nghị sử dụng `Ylarod/ddk` để build LKM.
:::

Trước tiên, bạn nên đọc tài liệu chính thức của Android để xây dựng kernel:

1. [Building Kernels](https://source.android.com/docs/setup/build/building-kernels?hl=vi)
2. [GKI Release Builds](https://source.android.com/docs/core/architecture/kernel/gki-release-builds?hl=vi)

::: warning
Trang này dành cho thiết bị GKI, nếu bạn sử dụng kernel cũ, vui lòng tham khảo [cách tích hợp KernelSU cho kernel cũ](how-to-integrate-for-non-gki)
:::

## Build Kernel

### Đồng bộ hóa mã nguồn kernel

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

`<kernel_manifest.xml>` là một tệp kê khai có thể xác định duy nhất một bản dựng, bạn có thể sử dụng tệp kê khai đó để thực hiện một bản dựng có thể dự đoán lại. Bạn nên tải xuống tệp kê khai từ [Google GKI release builds](https://source.android.com/docs/core/architecture/kernel/gki-release-builds?hl=vi)

### Build

Trước tiên, vui lòng kiểm tra [tài liệu chính thức](https://source.android.com/docs/setup/build/building-kernels?hl=vi).

Ví dụ: chúng ta cần xây dựng kernel image aarch64:

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

Đừng quên thêm cờ `LTO=thin`, nếu không quá trình xây dựng có thể thất bại nếu bộ nhớ máy tính của bạn nhỏ hơn 24Gb.

Bắt đầu từ Android 13, kernel được xây dựng bởi `bazel`:

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

## Build Kernel với KernelSU

Nếu bạn có thể build kernel thành công thì việc xây dựng KernelSU thật dễ dàng, Chọn bất kỳ một lần chạy trong thư mục gốc nguồn Kernel:

- Thẻ mới nhất (ổn định)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

- nhánh chính (dev)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

- Chọn thẻ (chẳng hạn như v0.5.2)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

Và sau đó build lại kernel và bạn sẽ có được image kernel với KernelSU!

```

`website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md`:

```md
# Làm thế nào để tích hợp KernelSU vào thiết bị không sử dụng GKI ?

::: warning
Tài liệu này chỉ để tham khảo lưu trữ và không còn được duy trì.
Kể từ KernelSU v1.0, chúng tôi đã ngừng hỗ trợ chính thức cho các thiết bị không phải GKI.
:::

KernelSU có thể được tích hợp vào kernel không phải GKI và hiện tại nó đã được backport xuống 4.14, thậm chí cũng có thể chạy trên kernel thấp hơn 4.14.

Do các kernel không phải GKI bị phân mảnh nên chúng tôi không có cách build thống nhất, vì vậy chúng tôi không thể cung cấp các boot image không phải GKI. Nhưng bạn có thể tự build kernel với KernelSU được tích hợp vào.

Đầu tiên, bạn phải build được kernel từ nguồn có khả năng boot được , nếu kernel không có mã nguồn mở thì rất khó để chạy KernelSU cho thiết bị của bạn.

Nếu bạn có thể build kernel khởi động được, có hai cách để tích hợp KernelSU vào mã nguồn kernel:

1. Tự động với `kprobe`
2. Thủ công


## Tích hợp vào kprobe

KernelSU sử dụng kprobe để thực hiện hook kernel, nếu *kprobe* chạy tốt trong kernel của bạn thì nên sử dụng cách này.

Đầu tiên, thêm KernelSU vào mã nguồn kernel của bạn:

- Thẻ mới nhất (ổn định)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

- Nhánh chính (dev)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

- Chọn thẻ (chẳng hạn như v0.5.2)

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

Sau đó, bạn nên kiểm tra xem *kprobe* có được bật trong config của bạn hay không, nếu không, vui lòng thêm các cấu hình sau vào:

```
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

Rồi build lại kernel của bạn, KernelSU sẽ hoạt động ok.

Trong trường hợp kprobe chưa được bật, bạn có thể thêm `CONFIG_MODULES=y` vào kernel config. (Nếu vẫn không có hiệu lực thì hãy sử dụng `make menuconfig` rồi tìm các thành phần khác mà kprobe phụ thuộc).

Nhưng nếu bạn gặp bootloop khi tích hợp KernelSU thì có khả năng ***kprobe bị hỏng trong kernel***, bạn nên fix lỗi kprobe trong mã nguồn hoặc dùng cách 2.

## Chỉnh sửa mã nguồn kernel thủ công

Nếu kprobe không thể hoạt động trong kernel của bạn (có thể là lỗi do upstream hoặc kernel dưới bản 4.8), thì bạn có thể thử cách này:

Đầu tiên, thêm KernelSU vào mã nguồn kernel của bạn:

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

Sau đó, thêm lệnh gọi KernelSU vào mã nguồn kernel, đây là một patch bạn có thể tham khảo:

```diff
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }
 
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);
 
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
 
+	ksu_handle_stat(&dfd, &filename, &flags);
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```

Bạn sẽ tìm thấy bốn chức năng trong mã nguồn kernel:

1. do_faccessat, thường là trong `fs/open.c`
2. do_execveat_common, thường nằm trong `fs/exec.c`
3. vfs_read, thường nằm trong `fs/read_write.c`
4. vfs_statx, thường có trong `fs/stat.c`

Cuối cùng, chỉnh sửa `KernelSU/kernel/ksu.c` và bỏ `enable_sucompat()` sau đó xây dựng lại kernel của bạn, KernelSU sẽ hoạt động tốt.

### How to backport path_umount

You can make the "Umount modules" feature work on pre-GKI kernels by manually backporting `path_umount` from 5.9. You can use this patch as reference:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

Finally, build your kernel again, and KernelSU should work correctly.

```

`website/docs/vi_VN/guide/installation.md`:

```md
# Cách cài đặt

## Kiểm tra xem thiết bị của bạn có được hỗ trợ không

Tải xuống APP KernelSU manager từ [GitHub Releases](https://github.com/tiann/KernelSU/releases) và cài đặt nó vào thiết bị của bạn:

- Nếu ứng dụng hiển thị `Unsupported`, nghĩa là **Bạn nên tự biên dịch kernel**, KernelSU sẽ không và không bao giờ cung cấp boot image để bạn flash.
- Nếu ứng dụng hiển thị `Not installed` thì thiết bị của bạn đã được KernelSU hỗ trợ chính thức.

:::info
Đối với các thiết bị hiển thị `Unsupported`, đây là [Thiết-bị-hỗ-trợ-không-chính-thức](unofficially-support-devices.md), bạn có thể tự biên dịch kernel.
:::

## Sao lưu stock boot.img

Trước khi flash, trước tiên bạn phải sao lưu stock boot.img. Nếu bạn gặp phải bootloop (vòng lặp khởi động), bạn luôn có thể khôi phục hệ thống bằng cách quay lại trạng thái khởi động ban đầu bằng fastboot.

::: warning
Việc flash có thể gây mất dữ liệu, hãy đảm bảo thực hiện tốt bước này trước khi chuyển sang bước tiếp theo!! Bạn cũng có thể sao lưu tất cả dữ liệu trên điện thoại nếu cần.
:::

## Kiến thức cần thiết

### ADB và fastboot

Theo mặc định, bạn sẽ sử dụng các công cụ ADB và fastboot trong hướng dẫn này, vì vậy nếu bạn không biết về chúng, chúng tôi khuyên bạn nên sử dụng công cụ tìm kiếm để tìm hiểu về chúng trước tiên.

### KMI

Kernel Module Interface (KMI), các phiên bản kernel có cùng KMI đều **tương thích** Đây là ý nghĩa của "general" trong GKI; ngược lại, nếu KMI khác thì các kernel này không tương thích với nhau và việc flash kernel image có KMI khác với thiết bị của bạn có thể gây ra bootloop.

Cụ thể, đối với thiết bị GKI, định dạng phiên bản kernel phải như sau:

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

`w.x-zzz-k` là phiên bản KMI. Ví dụ: nếu phiên bản kernel của thiết bị là `5.10.101-android12-9-g30979850fc20`, thì KMI của nó là `5.10-android12-9`; về mặt lý thuyết, nó có thể khởi động bình thường với các kernel KMI khác.

::: tip
Lưu ý rằng SubLevel trong phiên bản kernel không phải là một phần của KMI! Điều đó có nghĩa là `5.10.101-android12-9-g30979850fc20` có cùng KMI với `5.10.137-android12-9-g30979850fc20`!
:::

### Phiên bản kernel vs Phiên bản Android

Xin lưu ý: **Phiên bản kernel và phiên bản Android không nhất thiết phải giống nhau!**

Nếu bạn nhận thấy phiên bản kernel của mình là `android12-5.10.101` nhưng phiên bản hệ thống Android của bạn là Android 13 hoặc phiên bản khác; xin đừng ngạc nhiên, vì số phiên bản của hệ thống Android không nhất thiết phải giống với số phiên bản của kernel Linux; Số phiên bản của kernel Linux nhìn chung nhất quán với phiên bản của hệ thống Android đi kèm với **thiết bị khi nó được xuất xưởng**. Nếu hệ thống Android được nâng cấp sau này, phiên bản kernel thường sẽ không thay đổi. Nếu bạn cần flash, **vui lòng tham khảo phiên bản kernel!!**

## Giới thiệu

Có một số phương pháp cài đặt KernelSU, mỗi phương pháp phù hợp với một kịch bản khác nhau, vì vậy vui lòng chọn khi cần.

1. Cài đặt với Recovery tùy chỉnh (ví dụ TWRP)
2. Cài đặt bằng ứng dụng flash kernel, chẳng hạn như Franco Kernel Manager
3. Cài đặt thông qua fastboot bằng boot.img do KernelSU cung cấp
4. Sửa boot.img theo cách thủ công và cài đặt nó

Since version [0.9.0](https://github.com/tiann/KernelSU/releases/tag/v0.9.0), KernelSU supports two running modes on GKI devices:

1. `GKI`: Replace the original kernel of the device with the **Generic Kernel Image** (GKI) provided by KernelSU.
2. `LKM`: Load the **Loadable Kernel Module** (LKM) into the device kernel without replacing the original kernel.

These two modes are suitable for different scenarios, and you can choose the one according to your needs.

### GKI mode {#gki-mode}

In GKI mode, the original kernel of the device will be replaced with the generic kernel image provided by KernelSU. The advantages of GKI mode are:

1. Strong universality, suitable for most devices. For example, Samsung has enabled KNOX devices, and LKM mode cannot work. There are also some niche modified devices that can only use GKI mode.
2. Can be used without relying on official firmware, and there is no need to wait for official firmware updates, as long as the KMI is consistent, it can be used.

### LKM mode {#lkm-mode}

In LKM mode, the original kernel of the device won't be replaced, but the loadable kernel module will be loaded into the device kernel. The advantages of LKM mode are:

1. Won't replace the original kernel of the device. If you have special requirements for the original kernel of the device, or you want to use KernelSU while using a third-party kernel, you can use LKM mode.
2. It's more convenient to upgrade and OTA. When upgrading KernelSU, you can directly install it in the manager without flashing manually. After the system OTA, you can directly install it to the second slot without manual flashing.
3. Suitable for some special scenarios. For example, LKM can also be loaded with temporary root permissions. Since it doesn't need to replace the boot partition, it won't trigger AVB and won't cause the device to be bricked.
4. LKM can be temporarily uninstalled. If you want to temporarily disable root access, you can uninstall LKM. This process doesn't require flashing partitions, or even rebooting the device. If you want to enable root again, just reboot the device.

::: tip COEXISTENCE OF TWO MODES
After opening the manager, you can see the current mode of the device on the homepage. Note that the priority of GKI mode is higher than that of LKM. For example, if you use GKI kernel to replace the original kernel, and use LKM to patch the GKI kernel, the LKM will be ignored, and the device will always run in GKI mode.
:::

### Which one to choose? {#which-one}

If your device is a mobile phone, we recommend that you prioritize LKM mode. If your device is an emulator, WSA, or Waydroid, we recommend that you prioritize GKI mode.

## LKM installation

### Get the official firmware

To use LKM mode, you need to get the official firmware and patch it based on the official firmware. If you use a third-party kernel, you can use the `boot.img` of the third-party kernel as the official firmware.

There are many ways to get the official firmware. If your device supports `fastboot boot`, we recommend **the most recommended and simplest** method is to use `fastboot boot` to temporarily boot the GKI kernel provided by KernelSU, then install the manager, and finally install it directly in the manager. This method doesn't require manually downloading the official firmware or manually extracting the boot.

If your device doesn't support `fastboot boot`, you may need to manually download the official firmware package and extract the boot from it.

Unlike GKI mode, LKM mode modifies the `ramdisk`. Therefore, on devices with Android 13, it needs to patch the `init_boot` partition instead of the `boot` partition, while GKI mode always operates on the `boot` partition.

### Use the manager

Open the manager, click the installation icon in the upper right corner, and several options will appear:

1. Select a file. If your device doesn't have root privileges, you can choose this option and then select your official firmware. The manager will automatically patch it. After that, just flash this patched file to obtain root privileges permanently.
2. Direct install. If your device is already rooted, you can choose this option. The manager will automatically get your device information, and then automatically patch the official firmware, and flash it automatically. You can consider using `fastboot boot` KernelSU's GKI kernel to get temporary root and install the manager, and then use this option. This is also the main way to upgrade KernelSU.
3. Install to inactive slot. If your device supports A/B partition, you can choose this option. The manager will automatically patch the official firmware and install it to another partition. This method is suitable for devices after OTA, you can directly install it to the inactive slot after OTA.

If you don't want to use the manager, you can also use the command line to install LKM. The `ksud` tool provided by KernelSU can help you patch the official firmware quickly and then flash it.

The usage of `ksud` is as follows:

```sh
ksud boot-patch 
```

```txt
Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              Boot image be patched
  -l, --lkm <LKM>                LKM module path. If not specified, the built-in module will be used
  -m, --module <MODULE>          LKM module path to be replaced. If not specified, the built-in module will be used
  -i, --init <INIT>              init to be replaced
  -u, --ota                      Will use another slot if the boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                Output path. If not specified, the current directory will be used
      --magiskboot <MAGISKBOOT>  magiskboot path. If not specified, the built-in version will be used
      --kmi <KMI>                KMI version. If specified, the indicated KMI will be used
  -h, --help                     Print help
```

A few options that need to be explained:

1. The `--magiskboot` option can specify the path of magiskboot. If not specified, ksud will look for it in the environment variables. If you don’t know how to get magiskboot, you can check [here](#patch-boot-image).
2. The `--kmi` option can specify the `KMI` version. If the kernel name of your device doesn't follow the KMI specification, you can specify it using this option.

The most common usage is:

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## LKM mode installation

There are several installation methods for LKM mode, each suitable for a different scenario, so please choose accordingly:

1. Install with fastboot using the boot.img provided by KernelSU.
2. Install with a kernel flash app, such as [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases).
3. Repair the boot.img manually and install it.
4. Install with custom Recovery (e.g., TWRP).

## Cài đặt với Recovery tùy chỉnh

Điều kiện chắc chắn: Thiết bị của bạn phải có Recovery tùy chỉnh, chẳng hạn như TWRP; nếu không hoặc chỉ có Recovery chính thức, hãy sử dụng phương pháp khác.

Các bước:

1. Từ [Release page](https://github.com/tiann/KernelSU/releases) của KernelSU, tải xuống gói zip bắt đầu bằng AnyKernel3 phù hợp với phiên bản điện thoại của bạn; ví dụ: phiên bản kernel của điện thoại là `android12-5.10. 66`, thì bạn nên tải xuống tệp `AnyKernel3-android12-5.10.66_yyyy-MM.zip` (trong đó `yyyy` là năm và `MM` là tháng).
2. Khởi động lại điện thoại vào TWRP.
3. Sử dụng adb để đặt AnyKernel3-*.zip vào điện thoại /sdcard và chọn cài đặt nó trong GUI TWRP; hoặc bạn có thể trực tiếp `adb sideload AnyKernel-*.zip` để cài đặt.

PS. Phương pháp này phù hợp với mọi cài đặt (không giới hạn cài đặt ban đầu hoặc các nâng cấp tiếp theo), miễn là bạn sử dụng TWRP.

## Cài đặt bằng Kernel Flasher

Điều kiện chắc chắn: Thiết bị của bạn phải được root. Ví dụ: bạn đã cài đặt Magisk để root hoặc bạn đã cài đặt phiên bản KernelSU cũ và cần nâng cấp lên phiên bản KernelSU khác; nếu thiết bị của bạn chưa được root, vui lòng thử các phương pháp khác.

Các bước:

1. Tải xuống zip AnyKernel3; hãy tham khảo phần *Cài đặt bằng Custom Recovery* để biết hướng dẫn tải xuống.
2. Mở Ứng dụng Kernel Flash và sử dụng zip AnyKernel3 được cung cấp để flash.

Nếu trước đây bạn chưa từng sử dụng Ứng dụng Kernel flash thì sau đây là những ứng dụng phổ biến hơn.

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

PS. Phương pháp này thuận tiện hơn khi nâng cấp KernelSU và có thể thực hiện mà không cần máy tính (sao lưu trước!). .

Các bước:

## Cài đặt bằng boot.img do KernelSU cung cấp

Phương pháp này không yêu cầu bạn phải có TWRP, cũng như không yêu cầu điện thoại của bạn phải có quyền root; nó phù hợp cho lần cài đặt KernelSU đầu tiên của bạn.

### Tìm boot.img thích hợp

KernelSU cung cấp boot.img chung cho các thiết bị GKI và bạn nên chuyển boot.img vào phân vùng boot của thiết bị.

Bạn có thể tải xuống boot.img từ [GitHub Release](https://github.com/tiann/KernelSU/releases), xin lưu ý rằng bạn nên sử dụng đúng phiên bản boot.img. Ví dụ: nếu thiết bị của bạn hiển thị kernel `android12-5.10.101` , bạn cần tải xuống `android-5.10.101_yyyy-MM.boot-<format>.img`. (Giữ KMI nhất quán!)

Trong đó `<format>` đề cập đến định dạng nén kernel của boot.img chính thức của bạn, vui lòng kiểm tra định dạng nén kernel của boot.img ban đầu của bạn, bạn nên sử dụng đúng định dạng, ví dụ: `lz4`, `gz`; nếu bạn sử dụng định dạng nén không chính xác, bạn có thể gặp phải bootloop.

::: info
1. Bạn có thể sử dụng magiskboot để lấy định dạng nén của boot ban đầu; Tất nhiên, bạn cũng có thể hỏi những người khác, có kinh nghiệm hơn có cùng kiểu máy với thiết bị của bạn. Ngoài ra, định dạng nén của kernel thường không thay đổi nên nếu bạn khởi động thành công với một định dạng nén nào đó thì bạn có thể thử định dạng đó sau.
2. Các thiết bị Xiaomi thường sử dụng `gz` hoặc **uncompressed** (không nén).
3. Đối với thiết bị Pixel, hãy làm theo hướng dẫn bên dưới.
:::

### flash boot.img vào thiết bị

Sử dụng `adb` để kết nối thiết bị của bạn, sau đó thực thi `adb restart bootloader` để vào chế độ fastboot, sau đó sử dụng lệnh này để flash KernelSU:

```sh
fastboot flash boot boot.img
```

::: info
Nếu thiết bị của bạn hỗ trợ `fastboot boot`, trước tiên bạn có thể sử dụng `fastboot boot boot.img` để thử sử dụng boot.img để khởi động hệ thống trước. Nếu có điều gì bất ngờ xảy ra, hãy khởi động lại để boot.
:::

### khởi động lại

Sau khi flash xong bạn nên khởi động lại máy:

```sh
fastboot reboot
```

## Vá boot.img theo cách thủ công

Đối với một số thiết bị, định dạng boot.img không quá phổ biến, chẳng hạn như không `lz4`, `gz` và không nén; điển hình nhất là Pixel, định dạng boot.img của nó là nén `lz4_legacy`, ramdisk có thể là `gz` cũng có thể là nén `lz4_legacy`; tại thời điểm này, nếu bạn trực tiếp flash boot.img do KernelSU cung cấp, điện thoại có thể không khởi động được; Tại thời điểm này, bạn có thể vá boot.img theo cách thủ công để dùng được.

Nhìn chung có hai phương pháp vá:

1. [Android-Image-Kitchen](https://forum.xda-developers.com/t/tool-android-image-kitchen-unpack-repack-kernel-ramdisk-win-android-linux-mac.2073775/)
2. [magiskboot](https://github.com/topjohnwu/Magisk/releases)

Trong số đó, Android-Image-Kitchen phù hợp để hoạt động trên PC và magiskboot cần sự kết nối của điện thoại di động.

### Chuẩn bị

1. Lấy stock boot.img của điện thoại; bạn có thể lấy nó từ nhà sản xuất thiết bị của mình, bạn có thể cần [payload-dumper-go](https://github.com/ssut/payload-dumper-go)
2. Tải xuống tệp zip AnyKernel3 do KernelSU cung cấp phù hợp với phiên bản KMI của thiết bị của bạn (bạn có thể tham khảo *Cài đặt với Khôi phục tùy chỉnh*).
3. Giải nén gói AnyKernel3 và lấy tệp `Image`, đây là tệp kernel của KernelSU.

### Sử dụng Android-Image-Kitchen

1. Tải Android-Image-Kitchen về máy tính.
2. Đặt stock boot.img vào thư mục gốc của Android-Image-Kitchen.
3. Thực thi `./unpackimg.sh boot.img` tại thư mục gốc của Android-Image-Kitchen, lệnh này sẽ giải nén boot.img và bạn sẽ nhận được một số tệp.
4. Thay thế `boot.img-kernel` trong thư mục `split_img` bằng `Image` bạn đã trích xuất từ AnyKernel3 (lưu ý đổi tên thành boot.img-kernel).
5. Thực thi `./repackimg.sh` tại thư mục gốc của 在 Android-Image-Kitchen; Và bạn sẽ nhận được một file có tên `image-new.img`; Flash boot.img này bằng fastboot(Tham khảo phần trước).

### Sử dụng magiskboot

1. Tải xuống Magisk mới nhất từ [Trang phát hành](https://github.com/topjohnwu/Magisk/releases)
2. Đổi tên `Magisk-*(version).apk` thành `Magisk-*.zip` và giải nén nó.
3. Đẩy `Magisk-*/lib/arm64-v8a/libmagiskboot.so` vào thiết bị của bạn bằng adb: `adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp /magiskboot`
4. Đẩy stock boot.img và Image trong AnyKernel3 vào thiết bị của bạn.
5. Nhập thư mục adb shell và cd `/data/local/tmp/`, sau đó `chmod +x magiskboot`
6. Nhập adb shell và cd `/data/local/tmp/`, thực thi `./magiskboot unpack boot.img` để giải nén `boot.img`, bạn sẽ nhận được file `kernel`, đây là kernel gốc của bạn.
7. Thay thế `kernel` bằng `Image`: `mv -f Image kernel`
8. Thực thi `./magiskboot repack boot.img` để đóng gói lại boot img và bạn sẽ nhận được một tệp `new-boot.img`, flash tệp này vào thiết bị bằng fastboot.

## Các phương pháp khác

Trên thực tế, tất cả các phương pháp cài đặt này chỉ có một ý tưởng chính, đó là **thay thế kernel gốc bằng kernel do KernelSU cung cấp**; chỉ cần đạt được điều này là có thể cài đặt được; ví dụ, sau đây là các phương pháp có thể khác.

1. Trước tiên hãy cài đặt Magisk, nhận quyền root thông qua Magisk, sau đó sử dụng flasher kernel để flash trong zip AnyKernel từ KernelSU.
2. Sử dụng một số bộ công cụ flash trên PC để flash trong kernel do KernelSU cung cấp.

Tuy nhiên, nếu nó không hoạt động, vui lòng thử phương pháp `magiskboot`.

## Sau khi cài đặt: Hỗ trợ Module

::: warning METAMODULE CHO SỬA ĐỔI TỆP HỆ THỐNG
Nếu bạn muốn sử dụng các module sửa đổi tệp `/system`, bạn cần cài đặt **metamodule** sau khi cài đặt KernelSU. Các module chỉ sử dụng scripts, sepolicy hoặc system.prop hoạt động mà không cần metamodule.
:::

**Để hỗ trợ sửa đổi `/system`**, vui lòng xem [Hướng dẫn Metamodule](metamodule.md) để:
- Hiểu metamodule là gì và tại sao cần chúng
- Cài đặt metamodule `meta-overlayfs` chính thức
- Tìm hiểu về các tùy chọn metamodule khác

```

`website/docs/vi_VN/guide/metamodule.md`:

```md
# Metamodule

Metamodule là một tính năng đột phá trong KernelSU cho phép chuyển các khả năng quan trọng của hệ thống module từ lõi sang các module có thể cắm thêm. Sự thay đổi kiến trúc này duy trì tính ổn định và bảo mật của KernelSU đồng thời giải phóng tiềm năng đổi mới lớn hơn cho hệ sinh thái module.

## Metamodule là gì?

Metamodule là một loại module đặc biệt của KernelSU cung cấp chức năng cơ sở hạ tầng cốt lõi cho hệ thống module. Không giống như các module thông thường sửa đổi tệp hệ thống, metamodule kiểm soát *cách thức* các module thông thường được cài đặt và mount.

Metamodule là cơ chế mở rộng dựa trên plugin cho phép tùy chỉnh hoàn toàn cơ sở hạ tầng quản lý module của KernelSU. Bằng cách ủy thác logic mount và cài đặt cho metamodule, KernelSU tránh trở thành điểm phát hiện dễ vỡ trong khi cho phép các chiến lược triển khai đa dạng.

**Đặc điểm chính:**

- **Vai trò cơ sở hạ tầng**: Metamodule cung cấp các dịch vụ mà các module thông thường phụ thuộc vào
- **Chỉ một instance**: Chỉ có thể cài đặt một metamodule tại một thời điểm
- **Thực thi ưu tiên**: Các script của metamodule chạy trước các script của module thông thường
- **Hook đặc biệt**: Cung cấp ba script hook cho cài đặt, mount và dọn dẹp

## Tại sao cần Metamodule?

Các giải pháp root truyền thống tích hợp logic mount vào lõi của chúng, khiến chúng dễ bị phát hiện và khó phát triển hơn. Kiến trúc metamodule của KernelSU giải quyết những vấn đề này thông qua việc tách biệt các mối quan tâm.

**Lợi thế chiến lược:**

- **Giảm bề mặt phát hiện**: Bản thân KernelSU không thực hiện mount, giảm các vector phát hiện
- **Tính ổn định**: Lõi vẫn ổn định trong khi các triển khai mount có thể phát triển
- **Đổi mới**: Cộng đồng có thể phát triển các chiến lược mount thay thế mà không cần fork KernelSU
- **Lựa chọn**: Người dùng có thể chọn triển khai phù hợp nhất với nhu cầu của họ

**Tính linh hoạt của mount:**

- **Không mount**: Đối với người dùng chỉ sử dụng module không cần mount, tránh hoàn toàn chi phí mount
- **Mount OverlayFS**: Cách tiếp cận truyền thống với hỗ trợ lớp đọc-ghi (thông qua `meta-overlayfs`)
- **Magic mount**: Mount tương thích với Magisk để có khả năng tương thích ứng dụng tốt hơn
- **Triển khai tùy chỉnh**: Overlay dựa trên FUSE, mount VFS tùy chỉnh hoặc các phương pháp hoàn toàn mới

**Vượt xa mount:**

- **Khả năng mở rộng**: Thêm các tính năng như hỗ trợ kernel module mà không cần sửa đổi lõi KernelSU
- **Tính module hóa**: Cập nhật các triển khai độc lập với các bản phát hành KernelSU
- **Tùy chỉnh**: Tạo các giải pháp chuyên biệt cho các thiết bị hoặc trường hợp sử dụng cụ thể

::: warning QUAN TRỌNG
Nếu không cài đặt metamodule, các module sẽ **KHÔNG** được mount. Các cài đặt KernelSU mới yêu cầu cài đặt một metamodule (như `meta-overlayfs`) để các module hoạt động.
:::

## Dành cho Người dùng

### Cài đặt Metamodule

Cài đặt metamodule giống như cài đặt các module thông thường:

1. Tải xuống tệp ZIP metamodule (ví dụ: `meta-overlayfs.zip`)
2. Mở ứng dụng KernelSU Manager
3. Nhấn nút hành động nổi (➕)
4. Chọn tệp ZIP metamodule
5. Khởi động lại thiết bị của bạn

Metamodule `meta-overlayfs` là triển khai tham chiếu chính thức cung cấp mount module dựa trên overlayfs truyền thống với hỗ trợ ext4 image.

### Kiểm tra Metamodule đang hoạt động

Bạn có thể kiểm tra metamodule nào đang hoạt động trong trang Module của ứng dụng KernelSU Manager. Metamodule đang hoạt động sẽ được hiển thị trong danh sách module của bạn với chỉ định đặc biệt.

### Gỡ cài đặt Metamodule

::: danger CẢNH BÁO
Gỡ cài đặt metamodule sẽ ảnh hưởng đến **TẤT CẢ** các module. Sau khi gỡ bỏ, các module sẽ không còn được mount cho đến khi bạn cài đặt một metamodule khác.
:::

Để gỡ cài đặt:

1. Mở KernelSU Manager
2. Tìm metamodule trong danh sách module của bạn
3. Nhấn gỡ cài đặt (bạn sẽ thấy cảnh báo đặc biệt)
4. Xác nhận hành động
5. Khởi động lại thiết bị của bạn

Sau khi gỡ cài đặt, bạn nên cài đặt một metamodule khác nếu muốn các module tiếp tục hoạt động.

### Ràng buộc chỉ một Metamodule

Chỉ có thể cài đặt một metamodule tại một thời điểm. Nếu bạn cố gắng cài đặt metamodule thứ hai, KernelSU sẽ ngăn chặn việc cài đặt để tránh xung đột.

Để chuyển đổi metamodule:

1. Gỡ cài đặt tất cả các module thông thường
2. Gỡ cài đặt metamodule hiện tại
3. Khởi động lại
4. Cài đặt metamodule mới
5. Cài đặt lại các module thông thường của bạn
6. Khởi động lại một lần nữa

## Dành cho Nhà phát triển Module

Nếu bạn đang phát triển các module KernelSU thông thường, bạn không cần lo lắng nhiều về metamodule. Các module của bạn sẽ hoạt động miễn là người dùng có cài đặt một metamodule tương thích (như `meta-overlayfs`).

**Những điều bạn cần biết:**

- **Mount yêu cầu metamodule**: Thư mục `system` trong module của bạn sẽ chỉ được mount nếu người dùng có cài đặt metamodule cung cấp chức năng mount
- **Không cần thay đổi code**: Các module hiện có tiếp tục hoạt động mà không cần sửa đổi

::: tip
Nếu bạn quen thuộc với phát triển module Magisk, các module của bạn sẽ hoạt động tương tự trong KernelSU khi cài đặt metamodule, vì nó cung cấp mount tương thích với Magisk.
:::

## Dành cho Nhà phát triển Metamodule

Tạo một metamodule cho phép bạn tùy chỉnh cách KernelSU xử lý cài đặt, mount và gỡ cài đặt module.

### Yêu cầu Cơ bản

Một metamodule được xác định bởi một thuộc tính đặc biệt trong `module.prop`:

```txt
id=my_metamodule
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

Thuộc tính `metamodule=1` (hoặc `metamodule=true`) đánh dấu đây là một metamodule. Nếu không có thuộc tính này, module sẽ được coi là module thông thường.

### Cấu trúc Tệp

Cấu trúc một metamodule:

```txt
my_metamodule/
├── module.prop              (phải bao gồm metamodule=1)
│
│      *** Hook đặc biệt của metamodule ***
├── metamount.sh             (tùy chọn: xử lý mount tùy chỉnh)
├── metainstall.sh           (tùy chọn: hook cài đặt cho module thông thường)
├── metauninstall.sh         (tùy chọn: hook dọn dẹp cho module thông thường)
│
│      *** Tệp module tiêu chuẩn (tất cả đều tùy chọn) ***
├── customize.sh             (tùy chỉnh cài đặt)
├── post-fs-data.sh          (script giai đoạn post-fs-data)
├── service.sh               (script dịch vụ late_start)
├── boot-completed.sh        (script hoàn thành khởi động)
├── uninstall.sh             (script gỡ cài đặt của chính metamodule)
├── system/                  (sửa đổi systemless, nếu cần)
└── [bất kỳ tệp bổ sung nào]
```

Metamodule có thể sử dụng tất cả các tính năng module tiêu chuẩn (script vòng đời, v.v.) ngoài các hook metamodule đặc biệt của chúng.

### Script Hook

Metamodule có thể cung cấp tối đa ba script hook đặc biệt:

#### 1. metamount.sh - Xử lý Mount

**Mục đích**: Kiểm soát cách các module được mount trong quá trình khởi động.

**Khi thực thi**: Trong giai đoạn `post-fs-data`, trước khi bất kỳ script module nào chạy.

**Biến môi trường:**

- `MODDIR`: Đường dẫn thư mục của metamodule (ví dụ: `/data/adb/modules/my_metamodule`)
- Tất cả các biến môi trường KernelSU tiêu chuẩn

**Trách nhiệm:**

- Mount tất cả các module đã kích hoạt một cách systemless
- Kiểm tra cờ `skip_mount`
- Xử lý các yêu cầu mount cụ thể của module

::: danger YÊU CẦU QUAN TRỌNG
Khi thực hiện các thao tác mount, bạn **PHẢI** đặt tên nguồn/thiết bị thành `"KSU"`. Điều này xác định các mount thuộc về KernelSU.

**Ví dụ (đúng):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**Đối với API mount hiện đại**, đặt chuỗi nguồn:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

Điều này rất cần thiết để KernelSU xác định và quản lý các mount của nó đúng cách.
:::

**Script ví dụ:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# Ví dụ: Triển khai bind mount đơn giản
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # Mount với source=KSU (BẮT BUỘC!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - Hook Cài đặt

**Mục đích**: Tùy chỉnh cách các module thông thường được cài đặt.

**Khi thực thi**: Trong quá trình cài đặt module, sau khi các tệp được giải nén nhưng trước khi cài đặt hoàn tất. Script này được **sourced** (không thực thi) bởi trình cài đặt tích hợp, tương tự như cách `customize.sh` hoạt động.

**Biến môi trường và hàm:**

Script này kế thừa tất cả các biến và hàm từ `install.sh` tích hợp:

- **Biến**: `MODPATH`, `TMPDIR`, `ZIPFILE`, `ARCH`, `API`, `IS64BIT`, `KSU`, `KSU_VER`, `KSU_VER_CODE`, `BOOTMODE`, v.v.
- **Hàm**:
  - `ui_print <msg>` - In thông báo ra console
  - `abort <msg>` - In lỗi và kết thúc cài đặt
  - `set_perm <target> <owner> <group> <permission> [context]` - Đặt quyền tệp
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - Đặt quyền đệ quy
  - `install_module` - Gọi quy trình cài đặt module tích hợp

**Trường hợp sử dụng:**

- Xử lý tệp module trước hoặc sau khi cài đặt tích hợp (gọi `install_module` khi sẵn sàng)
- Di chuyển tệp module
- Xác thực khả năng tương thích của module
- Thiết lập cấu trúc thư mục đặc biệt
- Khởi tạo tài nguyên cụ thể của module

**Lưu ý**: Script này **KHÔNG** được gọi khi cài đặt chính metamodule.

#### 3. metauninstall.sh - Hook Dọn dẹp

**Mục đích**: Dọn dẹp tài nguyên khi các module thông thường được gỡ cài đặt.

**Khi thực thi**: Trong quá trình gỡ cài đặt module, trước khi thư mục module bị xóa.

**Biến môi trường:**

- `MODULE_ID`: ID của module đang được gỡ cài đặt

**Trường hợp sử dụng:**

- Xử lý tệp
- Dọn dẹp symlink
- Giải phóng tài nguyên đã phân bổ
- Cập nhật theo dõi nội bộ

**Script ví dụ:**

```sh
#!/system/bin/sh
# Được gọi khi gỡ cài đặt module thông thường
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# Xóa tệp module khỏi image
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### Thứ tự Thực thi

Hiểu thứ tự thực thi khởi động rất quan trọng cho phát triển metamodule:

```txt
Giai đoạn post-fs-data:
  1. Các script post-fs-data.d chung thực thi
  2. Prune module, restorecon, tải sepolicy.rule
  3. post-fs-data.sh của metamodule thực thi (nếu có)
  4. post-fs-data.sh của các module thông thường thực thi
  5. Tải system.prop
  6. metamount.sh của metamodule thực thi
     └─> Mount tất cả các module một cách systemless
  7. Giai đoạn post-mount.d chạy
     - Các script post-mount.d chung
     - post-mount.sh của metamodule (nếu có)
     - post-mount.sh của các module thông thường

Giai đoạn service:
  1. Các script service.d chung thực thi
  2. service.sh của metamodule thực thi (nếu có)
  3. service.sh của các module thông thường thực thi

Giai đoạn boot-completed:
  1. Các script boot-completed.d chung thực thi
  2. boot-completed.sh của metamodule thực thi (nếu có)
  3. boot-completed.sh của các module thông thường thực thi
```

**Điểm chính:**

- `metamount.sh` chạy **SAU** tất cả các script post-fs-data (cả metamodule và module thông thường)
- Các script vòng đời của metamodule (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`) luôn chạy trước các script module thông thường
- Các script chung trong thư mục `.d` chạy trước các script metamodule
- Giai đoạn `post-mount` chạy sau khi mount hoàn tất

### Cơ chế Symlink

Khi một metamodule được cài đặt, KernelSU tạo một symlink:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

Điều này cung cấp một đường dẫn ổn định để truy cập metamodule đang hoạt động, bất kể ID của nó.

**Lợi ích:**

- Đường dẫn truy cập nhất quán
- Dễ dàng phát hiện metamodule đang hoạt động
- Đơn giản hóa cấu hình

### Ví dụ Thực tế: meta-overlayfs

Metamodule `meta-overlayfs` là triển khai tham chiếu chính thức. Nó thể hiện các thực hành tốt nhất cho phát triển metamodule.

#### Kiến trúc

`meta-overlayfs` sử dụng **kiến trúc thư mục kép**:

1. **Thư mục metadata**: `/data/adb/modules/`
   - Chứa `module.prop`, các marker `disable`, `skip_mount`
   - Nhanh để quét trong quá trình khởi động
   - Dung lượng lưu trữ nhỏ

2. **Thư mục nội dung**: `/data/adb/metamodule/mnt/`
   - Chứa các tệp module thực tế (system, vendor, product, v.v.)
   - Được lưu trữ trong một ext4 image (`modules.img`)
   - Tối ưu hóa không gian với các tính năng ext4

#### Triển khai metamount.sh

Đây là cách `meta-overlayfs` triển khai xử lý mount:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# Mount ext4 image nếu chưa được mount
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# Đặt biến môi trường cho hỗ trợ thư mục kép
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# Thực thi binary mount
# (Logic mount thực tế nằm trong binary Rust)
"$MODDIR/meta-overlayfs"
```

#### Tính năng Chính

**Mount Overlayfs:**

- Sử dụng kernel overlayfs cho các sửa đổi systemless thực sự
- Hỗ trợ nhiều phân vùng (system, vendor, product, system_ext, odm, oem)
- Hỗ trợ lớp đọc-ghi thông qua `/data/adb/modules/.rw/`

**Xác định nguồn:**

```rust
// Từ meta-overlayfs/src/mount.rs
fsconfig_set_string(fs, "source", "KSU")?;  // BẮT BUỘC!
```

Điều này đặt `dev=KSU` cho tất cả các overlay mount, cho phép xác định đúng.

### Thực hành Tốt nhất

Khi phát triển metamodule:

1. **Luôn đặt source thành "KSU"** cho các thao tác mount - kernel umount và zygisksu umount cần điều này để umount đúng cách
2. **Xử lý lỗi một cách khéo léo** - các quy trình khởi động nhạy cảm về thời gian
3. **Tôn trọng các cờ tiêu chuẩn** - hỗ trợ `skip_mount` và `disable`
4. **Log các thao tác** - sử dụng `echo` hoặc logging để debug
5. **Kiểm tra kỹ lưỡng** - lỗi mount có thể gây ra vòng lặp khởi động
6. **Ghi chú hành vi** - giải thích rõ ràng metamodule của bạn làm gì
7. **Cung cấp đường dẫn di chuyển** - giúp người dùng chuyển đổi từ các giải pháp khác

### Kiểm tra Metamodule của bạn

Trước khi phát hành:

1. **Kiểm tra cài đặt** trên thiết lập KernelSU sạch
2. **Xác minh mount** với nhiều loại module khác nhau
3. **Kiểm tra khả năng tương thích** với các module phổ biến
4. **Kiểm tra gỡ cài đặt** và dọn dẹp
5. **Xác thực hiệu suất khởi động** (metamount.sh đang chặn!)
6. **Đảm bảo xử lý lỗi đúng cách** để tránh vòng lặp khởi động

## Câu hỏi Thường gặp

### Tôi có cần metamodule không?

**Đối với người dùng**: Chỉ cần nếu bạn muốn sử dụng các module yêu cầu mount. Nếu bạn chỉ sử dụng các module chạy script mà không sửa đổi tệp hệ thống, bạn không cần metamodule.

**Đối với nhà phát triển module**: Không, bạn phát triển module bình thường. Người dùng chỉ cần metamodule nếu module của bạn yêu cầu mount.

**Đối với người dùng nâng cao**: Chỉ cần nếu bạn muốn tùy chỉnh hành vi mount hoặc tạo các triển khai mount thay thế.

### Tôi có thể có nhiều metamodule không?

Không. Chỉ có thể cài đặt một metamodule tại một thời điểm. Điều này ngăn chặn xung đột và đảm bảo hành vi có thể dự đoán được.

### Điều gì xảy ra nếu tôi gỡ cài đặt metamodule duy nhất của mình?

Các module sẽ không còn được mount. Thiết bị của bạn sẽ khởi động bình thường, nhưng các sửa đổi của module sẽ không áp dụng cho đến khi bạn cài đặt một metamodule khác.

### meta-overlayfs có bắt buộc không?

Không. Nó cung cấp mount overlayfs tiêu chuẩn tương thích với hầu hết các module. Bạn có thể tạo metamodule của riêng mình nếu cần hành vi khác.

## Xem thêm

- [Module Guide](module.md) - Phát triển module chung
- [Difference with Magisk](difference-with-magisk.md) - So sánh KernelSU và Magisk
- [How to Build](how-to-build.md) - Xây dựng KernelSU từ nguồn

```

`website/docs/vi_VN/guide/module-config.md`:

```md
# Cấu hình module

KernelSU cung cấp hệ thống cấu hình tích hợp cho phép các module lưu trữ các cài đặt key-value liên tục hoặc tạm thời. Cấu hình được lưu trữ ở định dạng nhị phân tại `/data/adb/ksu/module_configs/<module_id>/` với các đặc điểm sau:

## Các loại cấu hình

- **Cấu hình liên tục** (`persist.config`): tồn tại sau khi khởi động lại cho đến khi bị xóa rõ ràng hoặc gỡ cài đặt module
- **Cấu hình tạm thời** (`tmp.config`): tự động bị xóa trong giai đoạn post-fs-data mỗi khi khởi động

Khi đọc cấu hình, giá trị tạm thời được ưu tiên hơn giá trị liên tục cho cùng một key.

## Sử dụng cấu hình trong script module

Tất cả các script module (`post-fs-data.sh`, `service.sh`, `boot-completed.sh`, v.v.) chạy với biến môi trường `KSU_MODULE` được đặt thành ID module. Bạn có thể sử dụng các lệnh `ksud module config` để quản lý cấu hình module của mình:

```bash
# Lấy giá trị cấu hình
value=$(ksud module config get my_setting)

# Đặt giá trị cấu hình liên tục
ksud module config set my_setting "some value"

# Đặt giá trị cấu hình tạm thời (xóa sau khi khởi động lại)
ksud module config set --temp runtime_state "active"

# Đặt giá trị từ stdin (hữu ích cho văn bản nhiều dòng hoặc dữ liệu phức tạp)
ksud module config set my_key <<EOF
văn bản nhiều dòng
giá trị
EOF

# Hoặc truyền từ lệnh
echo "value" | ksud module config set my_key

# Cờ stdin rõ ràng
cat file.json | ksud module config set json_data --stdin

# Liệt kê tất cả các mục cấu hình (hợp nhất liên tục và tạm thời)
ksud module config list

# Xóa một mục cấu hình
ksud module config delete my_setting

# Xóa một mục cấu hình tạm thời
ksud module config delete --temp runtime_state

# Xóa tất cả cấu hình liên tục
ksud module config clear

# Xóa tất cả cấu hình tạm thời
ksud module config clear --temp
```

## Giới hạn xác thực

Hệ thống cấu hình áp dụng các giới hạn sau:

- **Độ dài key tối đa**: 256 byte
- **Độ dài giá trị tối đa**: 1MB (1048576 byte)
- **Số lượng mục cấu hình tối đa**: 32 mỗi module
- **Định dạng key**: Phải khớp với `^[a-zA-Z][a-zA-Z0-9._-]+$` (như ID module)
  - Phải bắt đầu bằng một chữ cái
  - Có thể chứa chữ cái, số, dấu chấm, dấu gạch dưới hoặc dấu gạch ngang
  - Độ dài tối thiểu: 2 ký tự
- **Định dạng giá trị**: Không có hạn chế - có thể chứa bất kỳ ký tự UTF-8 nào, bao gồm ngắt dòng và ký tự điều khiển
  - Được lưu trữ ở định dạng nhị phân có tiền tố độ dài để xử lý dữ liệu an toàn

## Vòng đời

- **Khi khởi động**: Tất cả cấu hình tạm thời được xóa trong giai đoạn post-fs-data
- **Khi gỡ cài đặt module**: Tất cả cấu hình (liên tục và tạm thời) tự động bị xóa
- Cấu hình được lưu trữ ở định dạng nhị phân với số ma thuật `0x4b53554d` ("KSUM") và xác thực phiên bản

## Trường hợp sử dụng

Hệ thống cấu hình lý tưởng cho:

- **Tùy chọn người dùng**: Lưu trữ cài đặt module mà người dùng cấu hình thông qua WebUI hoặc action script
- **Cờ tính năng**: Bật/tắt tính năng module mà không cần cài đặt lại
- **Trạng thái runtime**: Theo dõi trạng thái tạm thời nên được đặt lại khi khởi động lại (sử dụng cấu hình tạm thời)
- **Cài đặt cài đặt**: Ghi nhớ các lựa chọn được thực hiện trong quá trình cài đặt module
- **Dữ liệu phức tạp**: Lưu trữ JSON, văn bản nhiều dòng, dữ liệu được mã hóa Base64 hoặc bất kỳ nội dung có cấu trúc nào (lên đến 1MB)

::: tip THỰC HÀNH TỐT NHẤT
- Sử dụng cấu hình liên tục cho tùy chọn người dùng nên tồn tại sau khi khởi động lại
- Sử dụng cấu hình tạm thời cho trạng thái runtime hoặc cờ tính năng nên được đặt lại khi khởi động
- Xác thực giá trị cấu hình trong script của bạn trước khi sử dụng chúng
- Sử dụng lệnh `ksud module config list` để gỡ lỗi các vấn đề cấu hình
:::

## Tính năng Nâng cao

Hệ thống cấu hình mô-đun cung cấp các khóa cấu hình đặc biệt cho các trường hợp sử dụng nâng cao:

### Ghi đè Mô tả Mô-đun {#overriding-module-description}

Bạn có thể ghi đè động trường `description` từ `module.prop` bằng cách đặt khóa cấu hình `override.description`:

```bash
# Ghi đè mô tả mô-đun
ksud module config set override.description "Mô tả tùy chỉnh được hiển thị trong trình quản lý"
```

Khi lấy danh sách mô-đun, nếu cấu hình `override.description` tồn tại, nó sẽ thay thế mô tả gốc từ `module.prop`. Điều này hữu ích cho:
- Hiển thị thông tin trạng thái động trong mô tả mô-đun
- Hiển thị chi tiết cấu hình runtime cho người dùng
- Cập nhật mô tả dựa trên trạng thái mô-đun mà không cần cài đặt lại

### Khai báo Tính năng được Quản lý

Các mô-đun có thể khai báo tính năng KernelSU nào mà chúng quản lý bằng cách sử dụng mẫu cấu hình `manage.<feature>`. Các tính năng được hỗ trợ tương ứng với enum nội bộ `FeatureId` của KernelSU:

**Tính năng được Hỗ trợ:**
- `su_compat` - Chế độ tương thích SU
- `kernel_umount` - Tự động unmount kernel

```bash
# Khai báo rằng mô-đun này quản lý khả năng tương thích SU và bật nó
ksud module config set manage.su_compat true

# Khai báo rằng mô-đun này quản lý unmount kernel và tắt nó
ksud module config set manage.kernel_umount false

# Xóa quản lý tính năng (mô-đun không còn kiểm soát tính năng này)
ksud module config delete manage.su_compat
```

**Cách hoạt động:**
- Sự hiện diện của khóa `manage.<feature>` cho biết mô-đun đang quản lý tính năng đó
- Giá trị cho biết trạng thái mong muốn: `true`/`1` để bật, `false`/`0` (hoặc bất kỳ giá trị nào khác) để tắt
- Để ngừng quản lý một tính năng, xóa hoàn toàn khóa cấu hình

Các tính năng được quản lý được hiển thị thông qua API danh sách mô-đun dưới dạng trường `managedFeatures` (chuỗi phân tách bằng dấu phẩy). Điều này cho phép:
- Trình quản lý KernelSU phát hiện mô-đun nào quản lý tính năng KernelSU nào
- Ngăn chặn xung đột khi nhiều mô-đun cố gắng quản lý cùng một tính năng
- Phối hợp tốt hơn giữa các mô-đun và chức năng cốt lõi của KernelSU

::: warning CHỈ CÁC TÍNH NĂNG ĐƯỢC HỖ TRỢ
Chỉ sử dụng các tên tính năng được xác định trước được liệt kê ở trên (`su_compat`, `kernel_umount`). Chúng tương ứng với các tính năng nội bộ thực tế của KernelSU. Sử dụng các tên tính năng khác sẽ không gây lỗi nhưng không có mục đích chức năng nào.
:::

```

`website/docs/vi_VN/guide/module-webui.md`:

```md
# Module WebUI

Ngoài việc chạy các script khởi động và chỉnh sửa tệp hệ thống, module KernelSU còn có thể hiển thị giao diện người dùng và tương tác trực tiếp với người dùng.

Module có thể định nghĩa các trang HTML + CSS + JavaScript bằng bất kỳ công nghệ web nào. Trình quản lý của KernelSU hiển thị những trang này thông qua WebView và cung cấp API để tương tác với hệ thống, chẳng hạn như thực thi lệnh shell.

## Thư mục `webroot`

Các tệp tài nguyên web cần được đặt trong thư mục con `webroot` ở thư mục gốc của module và **PHẢI** có tệp `index.html`, đây là điểm vào của trang module. Cấu trúc đơn giản nhất của một module có giao diện web trông như sau:

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

::: warning
Khi cài đặt module, KernelSU sẽ tự động đặt quyền và ngữ cảnh SELinux cho thư mục này. Nếu bạn không chắc mình đang làm gì, đừng tự ý thay đổi quyền của thư mục!
:::

Nếu trang của bạn có CSS hoặc JavaScript thì cũng cần đặt chúng trong thư mục này.

## JavaScript API

Nếu chỉ là trang hiển thị, nó sẽ hoạt động giống một trang web bình thường. Tuy nhiên điều quan trọng nhất là KernelSU cung cấp một loạt API hệ thống cho phép bạn triển khai các chức năng riêng của module.

KernelSU có một thư viện JavaScript được phát hành trên [npm](https://www.npmjs.com/package/kernelsu) để bạn dùng trong mã JavaScript của trang.

Ví dụ, bạn có thể thực thi một lệnh shell để lấy cấu hình hoặc thay đổi một thuộc tính:

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

Bạn cũng có thể chuyển trang sang chế độ toàn màn hình hoặc hiển thị thông báo toast.

[Tài liệu API](https://www.npmjs.com/package/kernelsu)

Nếu API hiện tại chưa đáp ứng nhu cầu hoặc khó sử dụng, hãy gửi đề xuất cho chúng tôi [tại đây](https://github.com/tiann/KernelSU/issues)!

## Một vài lưu ý

1. Bạn có thể sử dụng `localStorage` như bình thường để lưu dữ liệu, nhưng hãy nhớ rằng dữ liệu sẽ biến mất khi ứng dụng quản lý bị gỡ cài đặt. Nếu cần lưu trữ lâu dài, hãy tự lưu dữ liệu vào một thư mục cụ thể.
2. Với các trang đơn giản, chúng tôi gợi ý dùng [parceljs](https://parceljs.org/) để đóng gói. Công cụ này không cần cấu hình ban đầu và rất dễ dùng. Nếu bạn là chuyên gia front-end hoặc có sở thích khác, cứ thoải mái dùng công cụ bạn muốn!

```

`website/docs/vi_VN/guide/module.md`:

```md
# Hướng dẫn mô-đun

KernelSU cung cấp một cơ chế mô-đun giúp đạt được hiệu quả sửa đổi thư mục hệ thống trong khi vẫn duy trì tính toàn vẹn của phân vùng system. Cơ chế này thường được gọi là "systemless".

Cơ chế mô-đun của KernelSU gần giống với Magisk. Nếu bạn đã quen với việc phát triển mô-đun Magisk thì việc phát triển các mô-đun KernelSU cũng rất tương tự. Bạn có thể bỏ qua phần giới thiệu các mô-đun bên dưới và chỉ cần đọc [difference-with-magisk](difference-with-magisk.md).

::: warning METAMODULE CHỈ CẦN THIẾT ĐỂ SỬA ĐỔI TỆP HỆ THỐNG
KernelSU sử dụng kiến trúc [metamodule](metamodule.md) để mount thư mục `system`. **Chỉ khi module của bạn cần sửa đổi tệp `/system`** (thông qua thư mục `system`), bạn mới cần cài đặt metamodule (như [meta-overlayfs](https://github.com/tiann/KernelSU/releases)). Các tính năng module khác như scripts, quy tắc sepolicy và system.prop hoạt động mà không cần metamodule.
:::

## WebUI

KernelSU modules support displaying interfaces and interacting with users. Xem [tài liệu WebUI](module-webui.md) để biết thêm chi tiết.

## Cấu hình module

KernelSU cung cấp hệ thống cấu hình tích hợp cho phép các module lưu trữ các cài đặt key-value liên tục hoặc tạm thời. Để biết thêm chi tiết, xem [tài liệu Cấu hình module](module-config.md).

## Busybox

KernelSU cung cấp tính năng nhị phân BusyBox hoàn chỉnh (bao gồm hỗ trợ SELinux đầy đủ). Tệp thực thi được đặt tại `/data/adb/ksu/bin/busybox`. BusyBox của KernelSU hỗ trợ "ASH Standalone Shell Mode" có thể chuyển đổi thời gian chạy. Standalone mode này có nghĩa là khi chạy trong shell `ash` của BusyBox, mọi lệnh sẽ trực tiếp sử dụng applet trong BusyBox, bất kể cái gì được đặt là `PATH`. Ví dụ: các lệnh như `ls`, `rm`, `chmod` sẽ **KHÔNG** sử dụng những gì có trong `PATH` (trong trường hợp Android theo mặc định, nó sẽ là `/system/bin/ls`, ` /system/bin/rm` và `/system/bin/chmod` tương ứng), nhưng thay vào đó sẽ gọi trực tiếp các ứng dụng BusyBox nội bộ. Điều này đảm bảo rằng các tập lệnh luôn chạy trong môi trường có thể dự đoán được và luôn có bộ lệnh đầy đủ cho dù nó đang chạy trên phiên bản Android nào. Để buộc lệnh _not_ sử dụng BusyBox, bạn phải gọi tệp thực thi có đường dẫn đầy đủ.

Mỗi tập lệnh shell đơn lẻ chạy trong ngữ cảnh của KernelSU sẽ được thực thi trong shell `ash` của BusyBox với standalone mode được bật. Đối với những gì liên quan đến nhà phát triển bên thứ 3, điều này bao gồm tất cả các tập lệnh khởi động và tập lệnh cài đặt mô-đun.

Đối với những người muốn sử dụng tính năng "Standalone mode" này bên ngoài KernelSU, có 2 cách để kích hoạt tính năng này:

1. Đặt biến môi trường `ASH_STANDALONE` thành `1`<br>Ví dụ: `ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. Chuyển đổi bằng các tùy chọn dòng lệnh:<br>`/data/adb/ksu/bin/busybox sh -o độc lập <script>`

Để đảm bảo tất cả shell `sh` tiếp theo được thực thi cũng chạy ở standalone mode, tùy chọn 1 là phương thức ưu tiên (và đây là những gì KernelSU và KernelSU manager sử dụng nội bộ) vì các biến môi trường được kế thừa xuống các tiến trình con.

::: tip sự khác biệt với Magisk

BusyBox của KernelSU hiện đang sử dụng tệp nhị phân được biên dịch trực tiếp từ dự án Magisk. **Cảm ơn Magisk!** Vì vậy, bạn không phải lo lắng về vấn đề tương thích giữa các tập lệnh BusyBox trong Magisk và KernelSU vì chúng hoàn toàn giống nhau!
:::

## Mô-đun hạt nhânSU

Mô-đun KernelSU là một thư mục được đặt trong `/data/adb/modules` với cấu trúc bên dưới:

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- Thư mục được đặt tên bằng ID của mô-đun
│   │
│   │      *** Nhận Dạng Mô-đun ***
│   │
│   ├── module.prop         <--- Tệp này lưu trữ metadata của mô-đun
│   │
│   │      *** Nội Dung Chính ***
│   │
│   ├── system              <--- Thư mục này sẽ được gắn kết nếu skip_mount không tồn tại
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** Cờ Trạng Thái ***
│   │
│   ├── skip_mount          <--- Nếu tồn tại, KernelSU sẽ KHÔNG gắn kết thư mục hệ thống của bạn
│   ├── disable             <--- Nếu tồn tại, mô-đun sẽ bị vô hiệu hóa
│   ├── remove              <--- Nếu tồn tại, mô-đun sẽ bị xóa trong lần khởi động lại tiếp theo
│   │
│   │      *** Tệp Tùy Chọn ***
│   │
│   ├── post-fs-data.sh     <--- Tập lệnh này sẽ được thực thi trong post-fs-data
│   ├── post-mount.sh       <--- Tập lệnh này sẽ được thực thi trong post-mount
│   ├── service.sh          <--- Tập lệnh này sẽ được thực thi trong dịch vụ late_start
│   ├── boot-completed.sh   <--- Tập lệnh này sẽ được thực thi khi khởi động xong
|   ├── uninstall.sh        <--- Tập lệnh này sẽ được thực thi khi KernelSU xóa mô-đun của bạn
│   ├── system.prop         <--- Các thuộc tính trong tệp này sẽ được tải dưới dạng thuộc tính hệ thống bằng resetprop
│   ├── sepolicy.rule       <--- Quy tắc riêng biệt tùy chỉnh bổ sung
│   │
│   │      *** Được Tạo Tự Động, KHÔNG TẠO HOẶC SỬA ĐỔI THỦ CÔNG ***
│   │
│   ├── vendor              <--- Một liên kết tượng trưng đến $MODID/system/vendor
│   ├── product             <--- Một liên kết tượng trưng đến $MODID/system/product
│   ├── system_ext          <--- Một liên kết tượng trưng đến $MODID/system/system_ext
│   │
│   │      *** Mọi tập tin / thư mục bổ sung đều được phép ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip sự khác biệt với Magisk
KernelSU không có hỗ trợ tích hợp cho Zygisk nên không có nội dung liên quan đến Zygisk trong mô-đun. Tuy nhiên, bạn có thể sử dụng [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) để hỗ trợ các mô-đun Zygisk. Trong trường hợp này, nội dung của mô-đun Zygisk giống hệt với nội dung được Magisk hỗ trợ.
:::

### module.prop

module.prop là tệp cấu hình cho mô-đun. Trong KernelSU, nếu một mô-đun không chứa tệp này, nó sẽ không được nhận dạng là mô-đun. Định dạng của tập tin này như sau:

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
actionIcon=<path> (optional)
webuiIcon=<path> (optional)
```

- `id` phải khớp với biểu thức chính quy này: `^[a-zA-Z][a-zA-Z0-9._-]+$`<br>
   ví dụ: ✓ `a_module`, ✓ `a.module`, ✓ `module-101`, ✗ `a module`, ✗ `1_module`, ✗ `-a-module`<br>
   Đây là **mã định danh duy nhất** của mô-đun của bạn. Bạn không nên thay đổi nó sau khi được xuất bản.
- `versionCode` phải là **số nguyên**. Điều này được sử dụng để so sánh các phiên bản.
- Các chuỗi khác không được đề cập ở trên có thể là chuỗi **một dòng** bất kỳ.
- Đảm bảo sử dụng kiểu ngắt dòng `UNIX (LF)` chứ không phải `Windows (CR+LF)` hoặc `Macintosh (CR)`.
- `actionIcon` và `webuiIcon` là các đường dẫn hình ảnh tùy chọn, được dùng làm
  biểu tượng mặc định cho phím tắt hành động và phím tắt WebUI của mô-đun trong
  ứng dụng quản lý. Các đường dẫn này phải là đường dẫn tương đối so với thư mục gốc
  của mô-đun. Ví dụ, `actionIcon=icon/icon.png` sẽ được ánh xạ thành `<MODDIR>/icon/icon.png`.

::: tip MÔ TẢ ĐỘNG
Trường `description` có thể được ghi đè động khi chạy bằng hệ thống cấu hình mô-đun. Xem [Ghi đè Mô tả Mô-đun](module-config.md#overriding-module-description) để biết chi tiết.
:::

### Tập lệnh Shell

Vui lòng đọc phần [Boot Scripts](#boot-scripts) để hiểu sự khác biệt giữa `post-fs-data.sh` và `service.sh`. Đối với hầu hết các nhà phát triển mô-đun, `service.sh` sẽ đủ tốt nếu bạn chỉ cần chạy tập lệnh khởi động, nếu bạn cần chạy tập lệnh sau khi khởi động xong, vui lòng sử dụng `boot-completed.sh`. Nếu bạn muốn làm gì đó sau khi gắn các lớp phủ, vui lòng sử dụng `post-mount.sh`.

Trong tất cả các tập lệnh của mô-đun của bạn, vui lòng sử dụng `MODDIR=${0%/*}` để lấy đường dẫn thư mục cơ sở của mô-đun của bạn; **KHÔNG** mã hóa cứng đường dẫn mô-đun của bạn trong tập lệnh.

::: tip sự khác biệt với Magisk
Bạn có thể sử dụng biến môi trường KSU để xác định xem tập lệnh đang chạy trong KernelSU hay Magisk. Nếu chạy trong KernelSU, giá trị này sẽ được đặt thành true.
:::

### thư mục `system`

Nội dung của thư mục này sẽ được phủ lên trên phân vùng /system của hệ thống sau khi hệ thống được khởi động. Điều này có nghĩa rằng:

::: tip YÊU CẦU METAMODULE
Thư mục `system` chỉ được mount nếu bạn đã cài đặt metamodule cung cấp chức năng mounting (như `meta-overlayfs`). Metamodule xử lý cách các module được mount. Xem [Hướng dẫn Metamodule](metamodule.md) để biết thêm thông tin.
:::

1. Các file có cùng tên với các file trong thư mục tương ứng trong hệ thống sẽ bị ghi đè bởi các file trong thư mục này.
2. Các thư mục có cùng tên với thư mục tương ứng trong hệ thống sẽ được gộp với các thư mục trong thư mục này.

Nếu bạn muốn xóa một tập tin hoặc thư mục trong thư mục hệ thống gốc, bạn cần tạo một tập tin có cùng tên với tập tin/thư mục trong thư mục mô-đun bằng cách sử dụng `mknod filename c 0 0`. Bằng cách này, hệ thống lớp phủ sẽ tự động "whiteout" (Xóa trắng) tệp này như thể nó đã bị xóa (phân vùng /system không thực sự bị thay đổi).

Bạn cũng có thể khai báo một biến có tên `REMOVE` chứa danh sách các thư mục trong `customize.sh` để thực hiện các thao tác xóa và KernelSU sẽ tự động thực thi `mknod <TARGET> c 0 0` trong các thư mục tương ứng của mô-đun. Ví dụ:

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

Danh sách trên sẽ thực thi `mknod $MODPATH/system/app/YouTuBe c 0 0` và `mknod $MODPATH/system/app/Bloatware c 0 0`; và `/system/app/YouTube` và `/system/app/Bloatware` sẽ bị xóa sau khi mô-đun này có hiệu lực.

Nếu bạn muốn thay thế một thư mục trong hệ thống, bạn cần tạo một thư mục có cùng đường dẫn trong thư mục mô-đun của mình, sau đó đặt thuộc tính `setfattr -ntrust.overlay.opaque -v y <TARGET>` cho thư mục này. Bằng cách này, hệ thống Overlayfs sẽ tự động thay thế thư mục tương ứng trong hệ thống (mà không thay đổi phân vùng /system).

Bạn có thể khai báo một biến có tên `REPLACE` trong tệp `customize.sh` của mình, bao gồm danh sách các thư mục sẽ được thay thế và KernelSU sẽ tự động thực hiện các thao tác tương ứng trong thư mục mô-đun của bạn. Ví dụ:

REPLACE="
/system/app/YouTube
/system/app/Bloatware
"

Danh sách này sẽ tự động tạo các thư mục `$MODPATH/system/app/YouTube` và `$MODPATH/system/app/Bloatware`, sau đó thực thi `setfattr -ntrusted.overlay.opaque -v y $MODPATH/system/app/ YouTube` và `setfattr -n Trust.overlay.opaque -v y $MODPATH/system/app/Bloatware`. Sau khi mô-đun có hiệu lực, `/system/app/YouTube` và `/system/app/Bloatware` sẽ được thay thế bằng các thư mục trống.

::: tip sự khác biệt với Magisk

KernelSU sử dụng kiến trúc [metamodule](metamodule.md) trong đó việc mounting được ủy thác cho các metamodule có thể cắm được. Metamodule `meta-overlayfs` chính thức sử dụng OverlayFS của kernel cho các sửa đổi systemless, trong khi Magisk sử dụng magic mount (bind mount) được tích hợp trực tiếp vào lõi của nó. Cả hai đều đạt được cùng một mục tiêu: sửa đổi tệp `/system` mà không sửa đổi vật lý phân vùng `/system`. Cách tiếp cận của KernelSU mang lại tính linh hoạt cao hơn và giảm bề mặt phát hiện.
:::

Nếu bạn quan tâm đến overlayfs, bạn nên đọc [documentation on overlayfs](https://docs.kernel.org/filesystems/overlayfs.html) của Kernel Linux.

### system.prop

Tệp này có cùng định dạng với `build.prop`. Mỗi dòng bao gồm `[key]=[value]`.

### sepolicy.rule

Nếu mô-đun của bạn yêu cầu một số bản vá lỗi chính sách bổ sung, vui lòng thêm các quy tắc đó vào tệp này. Mỗi dòng trong tệp này sẽ được coi là một tuyên bố chính sách.

## Trình cài đặt mô-đun

Trình cài đặt mô-đun KernelSU là mô-đun KernelSU được đóng gói trong tệp zip có thể được flash trong APP KernelSU manager. Trình cài đặt mô-đun KernelSU đơn giản chỉ là mô-đun KernelSU được đóng gói dưới dạng tệp zip.

```txt
module.zip
│
├── customize.sh                       <--- (Tùy chọn, biết thêm chi tiết sau)
│                                           Tập lệnh này sẽ có nguồn gốc từ update-binary
├── ...
├── ...  /* Các tập tin còn lại của mô-đun */
│
```

:::warning
Mô-đun KernelSU KHÔNG được hỗ trợ để cài đặt trong khôi phục tùy chỉnh!!
:::

### Tùy chỉnh

Nếu bạn cần tùy chỉnh quá trình cài đặt mô-đun, bạn có thể tùy ý tạo một tập lệnh trong trình cài đặt có tên `customize.sh`. Tập lệnh này sẽ được _sourced_ (không được thực thi!) bởi tập lệnh cài đặt mô-đun sau khi tất cả các tệp được trích xuất và các quyền mặc định cũng như văn bản thứ hai được áp dụng. Điều này rất hữu ích nếu mô-đun của bạn yêu cầu thiết lập bổ sung dựa trên ABI của thiết bị hoặc bạn cần đặt các quyền/văn bản thứ hai đặc biệt cho một số tệp mô-đun của mình.

Nếu bạn muốn kiểm soát và tùy chỉnh hoàn toàn quá trình cài đặt, hãy khai báo `SKIPUNZIP=1` trong `customize.sh` để bỏ qua tất cả các bước cài đặt mặc định. Bằng cách đó, `customize.sh` của bạn sẽ chịu trách nhiệm cài đặt mọi thứ.

Tập lệnh `customize.sh` chạy trong shell `ash` BusyBox của KernelSU với "Chế độ độc lập" được bật. Có sẵn các biến và hàm sau:

#### Biến

- `KSU` (bool): biến để đánh dấu script đang chạy trong môi trường KernelSU, và giá trị của biến này sẽ luôn đúng. Bạn có thể sử dụng nó để phân biệt giữa KernelSU và Magisk.
- `KSU_VER` (chuỗi): chuỗi phiên bản của KernelSU được cài đặt hiện tại (ví dụ: `v0.4.0`)
- `KSU_VER_CODE` (int): mã phiên bản của KernelSU được cài đặt hiện tại trong không gian người dùng (ví dụ: `10672`)
- `KSU_KERNEL_VER_CODE` (int): mã phiên bản của KernelSU được cài đặt hiện tại trong không gian kernel (ví dụ: `10672`)
- `BOOTMODE` (bool): luôn là `true` trong KernelSU
- `MODPATH` (đường dẫn): đường dẫn nơi các tập tin mô-đun của bạn sẽ được cài đặt
- `TMPDIR` (đường dẫn): nơi bạn có thể lưu trữ tạm thời các tập tin
- `ZIPFILE` (đường dẫn): zip cài đặt mô-đun của bạn
- `ARCH` (chuỗi): kiến trúc CPU của thiết bị. Giá trị là `arm`, `arm64`, `x86` hoặc `x64`
- `IS64BIT` (bool): `true` nếu `$ARCH` là `arm64` hoặc `x64`
- `API` (int): cấp độ API (phiên bản Android) của thiết bị (ví dụ: `23` cho Android 6.0)

::: warning
Trong KernelSU, MAGISK_VER_CODE luôn là 25200 và MAGISK_VER luôn là v25.2. Vui lòng không sử dụng hai biến này để xác định xem nó có chạy trên KernelSU hay không.
:::

#### Hàm

```txt
ui_print <msg>
    in <msg> ra console
    Tránh sử dụng 'echo' vì nó sẽ không hiển thị trong console của recovery tùy chỉnh

abort <msg>
    in thông báo lỗi <msg> ra bàn điều khiển và chấm dứt cài đặt
    Tránh sử dụng 'exit' vì nó sẽ bỏ qua các bước dọn dẹp chấm dứt

set_perm <target> <owner> <group> <permission> [context]
    nếu [context] không được đặt, mặc định là "u:object_r:system_file:s0"
    chức năng này là một shorthand cho các lệnh sau:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    nếu [context] không được đặt, mặc định là "u:object_r:system_file:s0"
    đối với tất cả các tệp trong <directory>, nó sẽ gọi:
       bối cảnh cấp phép tệp của nhóm chủ sở hữu tệp set_perm
    đối với tất cả các thư mục trong <directory> (bao gồm cả chính nó), nó sẽ gọi:
       set_perm bối cảnh phân quyền của nhóm chủ sở hữu thư mục
```

## Tập lệnh khởi động

Trong KernelSU, tập lệnh được chia thành hai loại dựa trên chế độ chạy của chúng: chế độ post-fs-data và chế độ dịch vụ late_start:

- chế độ post-fs-data
   - Giai đoạn này là BLOCKING. Quá trình khởi động bị tạm dừng trước khi thực thi xong hoặc đã trôi qua 10 giây.
   - Các tập lệnh chạy trước khi bất kỳ mô-đun nào được gắn kết. Điều này cho phép nhà phát triển mô-đun tự động điều chỉnh các mô-đun của họ trước khi nó được gắn kết.
   - Giai đoạn này xảy ra trước khi Zygote được khởi động, điều này gần như có ý nghĩa đối với mọi thứ trong Android
   - **CẢNH BÁO:** sử dụng `setprop` sẽ làm quá trình khởi động bị nghẽn! Thay vào đó, vui lòng sử dụng `resetprop -n <prop_name> <prop_value>`.
   - **Chỉ chạy tập lệnh ở chế độ này nếu cần thiết.**
- chế độ dịch vụ late_start
   - Giai đoạn này là NON-BLOCKING. Tập lệnh của bạn chạy song song với phần còn lại của quá trình khởi động.
   - **Đây là giai đoạn được khuyến nghị để chạy hầu hết các tập lệnh.**

Trong KernelSU, tập lệnh khởi động được chia thành hai loại dựa trên vị trí lưu trữ của chúng: tập lệnh chung và tập lệnh mô-đun:

- Kịch Bản Chung
   - Được đặt trong `/data/adb/post-fs-data.d`, `/data/adb/service.d`, `/data/adb/post-mount.d` hoặc `/data/adb/boot- đã hoàn thành.d`
   - Chỉ được thực thi nếu tập lệnh được đặt là có thể thực thi được (`chmod +x script.sh`)
   - Các tập lệnh trong `post-fs-data.d` chạy ở chế độ post-fs-data và các tập lệnh trong `service.d` chạy ở chế độ dịch vụ late_start.
   - Các mô-đun **KHÔNG** thêm các tập lệnh chung trong quá trình cài đặt
- Tập Lệnh Mô-đun
   - Được đặt trong thư mục riêng của mô-đun
   - Chỉ thực hiện nếu mô-đun được kích hoạt
   - `post-fs-data.sh` chạy ở chế độ post-fs-data, `service.sh` chạy ở chế độ dịch vụ late_start, `boot-completed.sh` chạy khi khởi động xong, `post-mount.sh` chạy trên overlayfs được gắn kết.

Tất cả các tập lệnh khởi động sẽ chạy trong shell `ash` BusyBox của KernelSU với "Standalone Mode" được bật.

```

`website/docs/vi_VN/guide/rescue-from-bootloop.md`:

```md
# Cứu khỏi bootloop (Vòng lặp khởi động)

Khi flash một thiết bị, chúng ta có thể gặp phải tình trạng máy "bị brick". Về lý thuyết, nếu bạn chỉ sử dụng fastboot để flash phân vùng boot hoặc cài đặt các mô-đun không phù hợp khiến máy không khởi động được thì điều này có thể được khắc phục bằng các thao tác thích hợp. Tài liệu này nhằm mục đích cung cấp một số phương pháp khẩn cấp để giúp bạn khôi phục từ thiết bị "bị brick".

## Brick bởi flash vào phân vùng boot

Trong KernelSU, các tình huống sau có thể gây ra lỗi khởi động khi flash phân vùng khởi động:

1. Bạn flash image boot sai định dạng. Ví dụ: nếu định dạng khởi động điện thoại của bạn là `gz`, nhưng bạn flash image định dạng `lz4` thì điện thoại sẽ không thể khởi động.
2. Điện thoại của bạn cần tắt xác minh AVB để khởi động bình thường (thường yêu cầu xóa tất cả dữ liệu trên điện thoại).
3. Kernel của bạn có một số lỗi hoặc không phù hợp để flash điện thoại của bạn.

Bất kể tình huống thế nào, bạn có thể khôi phục bằng cách **flash boot image gốc**. Do đó, khi bắt đầu hướng dẫn cài đặt, chúng tôi thực sự khuyên bạn nên sao lưu boot image gốc trước khi flash. Nếu chưa sao lưu, bạn có thể lấy boot image gốc từ người dùng khác có cùng thiết bị với bạn hoặc từ chương trình cơ sở chính thức (official firmware).

## Brick bởi mô-đun

Việc cài đặt mô-đun có thể là nguyên nhân phổ biến hơn khiến thiết bị của bạn bị brick, nhưng chúng tôi phải nghiêm túc cảnh báo bạn: **Không cài đặt mô-đun từ các nguồn không xác định**! Vì các mô-đun có đặc quyền root nên chúng có thể gây ra thiệt hại không thể khắc phục cho thiết bị của bạn!

### Mô-đun bình thường

Nếu bạn đã flash một mô-đun đã được chứng minh là an toàn nhưng khiến thiết bị của bạn không khởi động được thì tình huống này có thể dễ dàng phục hồi trong KernelSU mà không phải lo lắng gì. KernelSU có các cơ chế tích hợp sẵn để giải cứu thiết bị của bạn, bao gồm:

1. Cập nhật AB
2. Cứu bằng cách nhấn Giảm âm lượng

#### Cập nhật AB

Các bản cập nhật mô-đun của KernelSU lấy cảm hứng từ cơ chế cập nhật AB của hệ thống Android được sử dụng trong các bản cập nhật OTA. Nếu bạn cài đặt một mô-đun mới hoặc cập nhật mô-đun hiện có, nó sẽ không trực tiếp sửa đổi tệp mô-đun hiện đang sử dụng. Thay vào đó, tất cả các mô-đun sẽ được tích hợp vào một hình ảnh cập nhật khác. Sau khi hệ thống được khởi động lại, nó sẽ cố gắng bắt đầu sử dụng hình ảnh cập nhật này. Nếu hệ thống Android khởi động thành công, các mô-đun sẽ được cập nhật thực sự.

Vì vậy, phương pháp đơn giản và được sử dụng phổ biến nhất để cứu thiết bị của bạn là **buộc khởi động lại**. Nếu bạn không thể khởi động hệ thống của mình sau khi flash một mô-đun, bạn có thể nhấn và giữ nút nguồn trong hơn 10 giây và hệ thống sẽ tự động khởi động lại; sau khi khởi động lại, nó sẽ quay trở lại trạng thái trước khi cập nhật mô-đun và các mô-đun được cập nhật trước đó sẽ tự động bị tắt.

#### Cứu bằng cách nhấn Giảm âm lượng

Nếu bản cập nhật AB vẫn không giải quyết được vấn đề, bạn có thể thử sử dụng **Chế độ an toàn**. Ở Chế độ an toàn, tất cả các mô-đun đều bị tắt.

Có hai cách để vào Chế độ an toàn:

1. Chế Độ An Toàn tích hợp (built-in Safe Mode) của một số hệ thống; một số hệ thống có Chế độ an toàn tích hợp có thể được truy cập bằng cách nhấn và giữ nút giảm âm lượng, trong khi những hệ thống khác (chẳng hạn như MIUI) có thể bật Chế Độ An Toàn trong Recovery. Khi vào Chế Độ An Toàn của hệ thống, KernelSU cũng sẽ vào Chế Độ An Toàn và tự động tắt các mô-đun.
2. Chế Độ An Toàn tích hợp (built-in Safe Mode) của KernelSU; phương pháp thao tác là **nhấn phím giảm âm lượng liên tục hơn ba lần** sau màn hình khởi động đầu tiên. Lưu ý là nhấn-thả, nhấn-thả, nhấn-thả chứ không phải nhấn giữ.

Sau khi vào chế độ an toàn, tất cả các mô-đun trên trang mô-đun của KernelSU Manager đều bị tắt nhưng bạn có thể thực hiện thao tác "gỡ cài đặt" để gỡ cài đặt bất kỳ mô-đun nào có thể gây ra sự cố.

Chế độ an toàn tích hợp được triển khai trong kernel, do đó không có khả năng thiếu các sự kiện chính do bị chặn. Tuy nhiên, đối với các hạt nhân không phải GKI, có thể cần phải tích hợp mã thủ công và bạn có thể tham khảo tài liệu chính thức để được hướng dẫn.

### Mô-đun độc hại

Nếu các phương pháp trên không thể cứu được thiết bị của bạn thì rất có thể mô-đun bạn cài đặt có hoạt động độc hại hoặc đã làm hỏng thiết bị của bạn thông qua các phương tiện khác. Trong trường hợp này, chỉ có hai gợi ý:

1. Xóa sạch dữ liệu và flash hệ thống chính thức.
2. Tham khảo dịch vụ hậu mãi.

```

`website/docs/vi_VN/guide/unofficially-support-devices.md`:

```md
# Thiết bị hỗ trợ không chính thức

::: warning
Tài liệu này chỉ để tham khảo lưu trữ và không còn được duy trì.
Kể từ KernelSU v1.0, chúng tôi đã ngừng hỗ trợ chính thức cho các thiết bị không phải GKI.
:::

::: warning
Đây là trang liệt kê kernel cho các thiết bị không dùng GKI được hỗ trợ bởi các lập trình viên khác.

:::

::: warning
Trang này chỉ để cho bạn tìm thấy source cho thiết bị của bạn, nó **HOÀN TOÀN KHÔNG** được review bởi _lập trình viên của KernelSU_. Vậy nên hãy chấp nhận rủi ro khi sử dụng chúng.

:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>Người bảo trì</th>
         <th>Kho lưu trữ</th>
         <th>Thiết bị hỗ trợ</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>

```

`website/docs/vi_VN/guide/what-is-kernelsu.md`:

```md
# KernelSU là gì?

KernelSU là một giải pháp root cho các thiết bị Android GKI, nó hoạt động ở chế độ kernel và cấp quyền root cho ứng dụng không gian người dùng trực tiếp trong không gian kernel.

## Tính năng

Tính năng chính của KernelSU là **Kernel-based** (dựa trên Kernel). KernelSU hoạt động ở chế độ kernel nên nó có thể cung cấp giao diện kernel mà chúng ta chưa từng có trước đây. Ví dụ: chúng ta có thể thêm điểm dừng phần cứng vào bất kỳ quy trình nào ở chế độ kernel; Chúng ta có thể truy cập bộ nhớ vật lý của bất kỳ quy trình nào mà không bị phát hiện; Chúng ta còn có thể chặn bất kỳ syscall nào trong không gian kernel; v.v.

Ngoài ra, KernelSU cung cấp [hệ thống metamodule](metamodule.md), đây là một kiến trúc có thể cắm để quản lý module. Không giống như các giải pháp root truyền thống tích hợp logic mount vào lõi, KernelSU ủy thác điều này cho metamodules. Điều này cho phép bạn cài đặt metamodules (như [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs)) để cung cấp các sửa đổi systemless cho phân vùng `/system` và các phân vùng khác.

## Hướng dẫn sử dụng

Xin hãy xem: [Cách cài đặt](installation)

## Cách để build

[Cách để build](how-to-build)

## Thảo luận

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/vi_VN/index.md`:

```md
---
layout: home
title: Giải pháp root dựa trên kernel dành cho Android

hero:
  name: KernelSU
  text: Giải pháp root dựa trên kernel dành cho Android
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: Bắt Đầu
      link: /guide/what-is-kernelsu
    - theme: alt
      text: Xem trên GitHub
      link: https://github.com/tiann/KernelSU

features:
  - title: Dựa trên Kernel
    details: KernelSU đang hoạt động ở chế độ kernel Linux, nó có nhiều quyền kiểm soát hơn đối với các ứng dụng userspace.
  - title: Kiểm soát truy cập bằng whitelist
    details: Chỉ ứng dụng được cấp quyền root mới có thể truy cập `su`, các ứng dụng khác không thể nhận được su.
  - title: Quyền root bị hạn chế
    details: KernelSU cho phép bạn tùy chỉnh uid, gid, group, capabilities và các quy tắc SELinux của su. Giới hạn sức mạnh của root.
  - title: Hệ thống Metamodule
    details: Cơ sở hạ tầng module có thể cắm cho phép sửa đổi /system theo cách systemless. Cài đặt metamodule như meta-overlayfs để bật tính năng mount module.


```

`website/docs/zh_CN/guide/app-profile.md`:

```md
# App Profile

App Profile 是 KernelSU 提供的一种针对各种应用自定义其使用配置的机制。

对授予了 root 权限（也即可以使用 `su`）的应用来说，App Profile 也可以称之为 Root Profile，它可以自定义 `su` 的 `uid`, `gid`, `groups`, `capabilities` 以及 `SELinux` 规则，从而限制 root 用户的权限；比如可以针对防火墙应用仅授予网络权限，而不授予文件访问权限，针对冻结类应用仅授予 shell 权限而不是直接给 root；通过最小化权限原则**把权力关进笼子里**。

对于没有被授予 root 权限的普通应用，App Profile 可以控制内核以及模块系统对此应用的行为；比如是否需要针对此应用卸载模块造成的修改等。内核和模块系统可以通过此配置决定是否要做一些类似“隐藏痕迹”类的操作。

## Root Profile

### UID、GID 和 groups

Linux 系统中有用户和组两个概念。每个用户都有一个用户 ID(UID)，一个用户可以属于多个组，每个组也有组 ID(GID)。该 ID 用于识别系统的用户并确定用户可以访问哪些系统资源。

UID 为 0 的用户被称之为 root 用户，GID 为 0 的组被称之为 root 组；root 用户组通常拥有系统的最高权限。

对于 Android 系统来说，每一个 App 都是一个单独的用户（不考虑 share uid 的情况），拥有一个唯一的 UID。比如 `0` 是 root 用户，`1000` 是 `system`，`2000` 是 ADB shell，10000-19999 的是普通用户。

:::info
此处的 UID 跟 Android 系统的多用户，或者说工作资料（Work Profile），不是一个概念。工作资料实际上是对 UID 进行分片实现的，比如 10000-19999 是主用户，110000-119999 是工作资料；他们中的任何一个普通应用都拥有自己独有的 UID。
:::

每一个 App 可以有若干个组，GID 是其主要的组，通常与 UID 一致；其他的组被称之为补充组 (groups)。某些权限是通过组控制的，比如网络访问，蓝牙等。

例如，如果我们在 ADB shell 中执行 `id` 命令，会得到如下输出：

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0
```

其中，UID 为 `2000`，GID 也即主要组 ID 也为 `2000`；除此之外它还在很多补充组里面，例如 `inet` 组代表可以创建 `AF_INET` 和 `AF_INET6` 的 socket（访问网络），`sdcard_rw` 代表可以读写 sdcard 等。

KernelSU 的 Root Profile 可以自定义执行 `su` 后 root 进程的 UID, GID 和 groups。例如，你可以设置某个 root 应用的 Root Profile 其 UID 为 `2000`，这意味着此应用在使用 `su` 的时候，它的实际权限是 ADB Shell 级别；你可以去掉 groups 中的 `inet`，这样这个 `su` 就无法访问网络。

:::tip 注意
App Profile 仅仅是控制 root 应用使用 `su` 后的权限，它并非控制 App 本身的权限！如果 App 本身申请了网络访问权限，那么它即使不使用 `su` 也可以访问网络；为 `su` 去掉 `inet` 组仅仅是让 `su` 无法访问网络。
:::

与应用通过 `su` 主动切换用户或者组不同，Root Profile 是在内核中强制实施的，不依赖 root 应用的自觉行为，`su` 权限的授予完全取决于用户而非开发者。

### Capabilities

Capabilities 是 Linux 的一种分权机制。

传统的 UNIX 系统为了执行权限检查，将进程分为两类：特权进程（其有效用户 ID 为 0，称为超级用户或 root）和非特权进程（其有效 UID 为非零）。特权进程会绕过所有内核权限检查，而非特权进程则根据其凭据（通常是有效 UID、有效 GID 和补充组列表）进行完整的权限检查。

从 Linux 2.2 开始，Linux 将传统上与超级用户关联的特权分解为独立的单元，称为 Capabilities（有的也翻译为“权能”），它们可以独立启用和禁用。

每一个 Capability 代表一个或者一类权限。比如 `CAP_DAC_READ_SEARCH` 就代表是否有能力绕过文件读取权限检查和目录读取和执行权限检查。如果一个有效 UID 为 `0` 的用户（root 用户）没有 `CAP_DAC_READ_SEARCH` 或者更高 Capalities，这意味着即使它是 root 也不能随意读取文件。

KernelSU 的 Root Profile 可以自定义执行 `su` 后 root 进程的 Capabilities，从而实现只授予“部分 root 权限”。与上面介绍的 UID, GID 不同，某些 root 应用就是需要 `su` 后 UID 是 `0`，此时我们可以通过限制这个 UID 为 `0` 的 root 用户的 Capabilities，就可以限制它能够执行的操作。

:::tip 强烈建议
Linux 系统关于 Capability 的 [官方文档](https://man7.org/linux/man-pages/man7/capabilities.7.html)，解释了每一项 Capability 所代表的能力，写的非常详细，如果你想要自定义 Capabilities，请务必先阅读此文档。
:::

### SELinux

SELinux 是一种强大的强制性权限访问控制（MAC）机制。它按照**默认拒绝**的原则运行：任何未经明确允许的行为都会被拒绝。

SELinux 可按两种全局模式运行：

1. 宽容模式：权限拒绝事件会被记录下来，但不会被强制执行。
2. 强制模式：权限拒绝事件会被记录下来**并**强制执行。

:::warning 警告
现代的 Android 系统极度依赖 SELinux 来保障整个系统的安全性，我们强烈建议您不要使用任何以“宽容模式”运行的自定义系统，因为那样与裸奔没什么区别。
:::

SELinux 的完整概念比较复杂，我们这里不打算讲解它的具体工作方式，建议你先通过以下资料来了解其工作原理：

1. [wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Redhat: what-is-selinux](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

KernelSU 的 Root Profile 可以自定义执行 `su` 后 root 进程的 SELinux context，并且可以针对这个 context 设置特定的访问控制规则，从而更加精细化地控制 root 权限。

通常情况下，应用执行 `su` 后，会将进程切换到一个 **不受任何限制** 的 SELinux 域，比如 `u:r:su:s0`，通过 Root Profile，我们可以将它切换到一个自定义的域，比如 `u:r:app1:s0`，然后为这个域制定一系列规则：

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

注意：此处的 `allow app1 * * *` 仅仅作为演示方便而使用，实际过程中不应使用这个规则，因为它跟 permissive 区别不大。

### 逃逸

如果 Root Profile 的配置不合理，那么可能会发生逃逸的情况：Root Profile 的限制会意外失效。

比如，如果你为 ADB shell 用户设置允许 root 权限（这是相当常见的情况）；然后你给某个普通应用允许 root 权限，但是配置它的 root profile 中的 UID 为 2000（ADB shell 用户的 UID）；那么此时，这个 App 可以通过执行两次 `su` 来获得完整的 root 权限：

1. 第一次执行 `su`，由于 App Profile 强制生效，会正常切换到 UID 为 `2000(adb shell)` 而非 `0(root)`。
2. 第二次执行 `su`，由于此时它 UID 是 `2000`，而你给 `2000(adb shell)` 配置了允许 root，它会获得完整的 root 权限！

:::warning 注意
这是完全符合预期的行为，并非 BUG！因此我们建议：

如果你的确需要给 adb 授予 root 权限（比如你是开发者），那么不建议你在配置 Root Profile 的时候将 UID 改成 `2000`，用 `1000(system)` 会更好。
:::

## Non Root Profile

### 卸载模块

KernelSU 提供了一种 systemless 的方式来修改系统分区，这是通过挂载 overlayfs 来实现的。但有些情况下，App 可能会对这种行为比较敏感；因此，我们可以通过设置“卸载模块”来卸载挂载在这些 App 上的模块。

另外，KernelSU 管理器的设置界面还提供了一个“默认卸载模块”的开关，这个开关默认情况下是**开启**的，这意味着**如果不对 App 做额外的设置**，默认情况下 KernelSU 或者某些模块会对此 App 执行卸载操作。当然，如果你不喜欢这个设置或者这个设置会影响某些 App，可以有如下选择：

1. 保持“默认卸载模块”的开关，然后针对不需要“卸载模块”的 App 进行单独的设置，在 App Profile 中关闭“卸载模块”；（相当于“白名单”）。
2. 关闭“默认卸载模块”的开关，然后针对需要“卸载模块”的 App 进行单独的设置，在 App Profile 中开启“卸载模块”；（相当于“黑名单”）。

:::info
KernelSU 在 5.10 及以上内核上，内核会执行“卸载模块”的操作；但在 5.10 以下的设备上，这个开关仅仅是一个“配置项”，KernelSU 本身不会做任何动作，一些模块（如 Zygisksu 会通过这个模块决定是否需要卸载）
:::

```

`website/docs/zh_CN/guide/difference-with-magisk.md`:

```md
# KernelSU 模块与 Magisk 的差异 {#title}

虽然 KernelSU 模块与 Magisk 模块有很多相似之处，但由于它们的实现机制完全不同，因此不可避免地会有一些差异；如果你希望你的模块能同时在 Magisk 与 KernelSU 中运行，那么你必须了解这些差异。

## 相同之处 {#similarities}

- 模块文件格式: 都以 zip 的方式组织模块，并且模块的格式几乎相同
- 模块安装目录: 都在 `/data/adb/modules`
- systemless: 都支持通过模块的形式以 systemless 修改 /system
- `post-fs-data.sh`: 执行时机完全一致，语义也完全一致
- `service.sh`: 执行时机完全一致，语义也完全一致
- `system.prop`: 完全相同
- `sepolicy.rule`: 完全相同
- BusyBox：脚本都在 BusyBox 中以“独立模式”运行

## 不同之处 {#differences}

在了解不同之处之前，你需要知道如何区分你的模块是运行在 KernelSU 还是运行在 Magisk 之中；在所有你可以运行模块脚本的地方（`customize.sh`, `post-fs-data.sh`, `service.sh`)，你都可以通过环境变量`KSU` 来区分，在 KernelSU 中，这个环境变量将被设置为 `true`。

以下是一些不同之处：

1. KernelSU 的模块不支持在 Recovery 中安装。
2. KernelSU 的模块没有内置的 Zygisk 支持（但你可以通过 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 来使用 Zygisk 模块）。
3. **模块挂载架构**：KernelSU 使用 [metamodule 系统](metamodule.md)，将挂载委托给可插拔的 metamodule（例如 `meta-overlayfs`），而 Magisk 将挂载内置在其核心中。KernelSU 需要安装 metamodule 才能启用模块挂载。
4. KernelSU 模块替换或者删除文件与 Magisk 完全不同。KernelSU 不支持 `.replace` 方式，相反，你需要通过 `mknod filename c 0 0` 创建同名文件夹来删除对应文件。
5. BusyBox 的目录不同；KernelSU 内置的 BusyBox 在 `/data/adb/ksu/bin/busybox` 而 Magisk 在 `/data/adb/magisk/busybox`；**注意此为 KernelSU 内部行为，未来可能会更改！**
6. KernelSU 不支持 `.replace` 文件；但 KernelSU 支持 `REPLACE` 和 `REMOVE` 变量。
7. KernelSU 新增了一种脚本 `boot-completed.sh`，以便在 Android 系统启动后运行某些任务。
8. KernelSU 新增了一种脚本 `post-mount.sh`，以便在模块挂载完成后运行某些任务。

```

`website/docs/zh_CN/guide/faq.md`:

```md
# 常见问题

## KernelSU 是否支持我的设备？

首先，您的设备应该能够解锁 bootloader。 如果不能，则不支持。

然后在你的设备上安装 KernelSU 管理器并打开它，如果它显示 `不支持` ，那么你的设备没有官方支持的开箱即用的 boot image；但你可以自己编译内核集成 KernelSU 进而使用它。

## KernelSU 是否需要解锁 Bootloader？

当然需要。

## KernelSU 是否支持模块？

支持。但是，如果您的模块需要修改 `/system` 文件，则需要安装 [metamodule](metamodule.md)（例如 `meta-overlayfs`）。其他模块功能无需 metamodule。请查阅 [模块](module.md)。

## KernelSU 是否支持 Xposed？

支持。LSPosed 可以在 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 的支持下正常运行。

## KernelSU 支持 Zygisk 吗？

KernelSU 本体不支持 Zygisk，但是你可以用 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 来使用 Zygisk 模块。

## KernelSU 与 Magisk 兼容吗？

KernelSU 的模块系统与 Magisk 的 magic mount 有冲突，如果 KernelSU 中启用了任何模块，那么整个 Magisk 将无法工作。

但是如果你只使用 KernelSU 的 `su`，那么它会和 Magisk 一起工作：KernelSU 修改 `kernel` 、 Magisk 修改 `ramdisk`，它们可以一起工作。

## KernelSU 会替代 Magisk 吗？

我们不这么认为，这也不是我们的目标。Magisk 对于用户空间 root 解决方案来说已经足够好了，它会存活很久。KernelSU 的目标是为用户提供内核接口，而不是替代 Magisk。

## KernelSU 可以支持非 GKI 设备吗？

可以。但是你应该下载内核源代码并将 KernelSU 集成到源代码树中并自己编译内核。

## KernelSU 支持 Android 12 以下的设备吗？

影响 KernelSU 兼容性的是设备内核的版本，它与设备的 Android 版本没有直接的关系。唯一有关联的是：**出厂** Android 12 的设备，一定是 5.10 或更高的内核（GKI 设备）；因此结论如下：

1. 出厂 Android 12 的设备必定是支持的（GKI 设备）
2. 旧版本内核的设备（即使是 Android 12，也可能是旧内核）是兼容的（你需要自己编译内核）

## KernelSU 可以支持旧内核吗？

可以，目前最低支持到 4.14；更低的版本你需要手动移植它，欢迎 PR ！

## 如何为旧内核集成 KernelSU？

参考[教程](how-to-integrate-for-non-gki)

## 为什么我手机系统是 Android 13，但内核版本却是 "android12-5.10"？

内核版本与 Android 版本无关，如果你需要刷入 KernelSU，请永远使用**内核版本**而非 Android 版本，如果你为 "android12-5.10" 的设备刷入 Android 13 的内核，等待你的将是 bootloop.

## 我是 GKI1.0, 能用 KernelSU 吗？

GKI1 跟 GKI2 完全是两个东西，所以你需要自行编译内核。

## 如何把 `/system` 变成挂载为可读写？

我们不建议你直接修改系统分区，你应该使用[模块功能](module.md) 来做修改；如果你执意要这么做，可以看看 [magisk_overlayfs](https://github.com/HuskyDG/magic_overlayfs)

## KernelSU 能修改 hosts 吗，我如何使用 AdAway？

当然可以。但这个功能 KernelSU 没有内置，你可以安装这个 [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module)

## 为什么全新安装后模块不工作？

如果您的模块需要修改 `/system` 文件，您需要安装 [metamodule](metamodule.md) 来挂载 `system` 目录。其他模块功能（脚本、sepolicy、system.prop）无需 metamodule 即可工作。

**解决方案**：参阅 [Metamodule 指南](metamodule.md) 获取安装说明。

## 什么是 metamodule，为什么需要它？

Metamodule 是一个特殊模块，为挂载常规模块提供基础设施。请参阅 [Metamodule 指南](metamodule.md) 获取完整说明。

```

`website/docs/zh_CN/guide/hidden-features.md`:

```md
# 隐藏功能

## ksurc

默认情况下，`/system/bin/sh` 会加载 `/system/etc/mkshrc`。

可以通过创建 `/data/adb/ksu/.ksurc` 文件来让 su 加载该文件而不是 `/system/etc/mkshrc`。
```

`website/docs/zh_CN/guide/how-to-build.md`:

```md
# 如何构建 KernelSU？

::: warning
该文档仅供存档参考，不再维护更新。
自 KernelSU v3.0 版本之后，为了更快的迭代和构建速度，我们放弃了对 GKI 镜像模式的官方支持。推荐使用 `Ylarod/ddk` 构建 LKM 使用。
:::

首先，您应该阅读内核构建的 Android 官方文档：

1. [构建内核](https://source.android.com/docs/setup/build/building-kernels)
2. [通用内核映像 (GKI) 发布构建](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

::: warning
本文档适用于 GKI 设备，如果你是旧内核，请参考[如何为非GKI设备集成 KernelSU](how-to-integrate-for-non-gki)
:::

## 构建内核

### 同步内核源码

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

`<kernel_manifest.xml>` 是一个可以唯一确定构建的清单文件，您可以使用该清单进行可重新预测的构建。 您应该从 [通用内核映像 (GKI) 发布构建](https://source.android.com/docs/core/architecture/kernel/gki-release-builds) 下载清单文件 

### 构建

请先查看 [官方文档](https://source.android.com/docs/setup/build/building-kernels)。

例如，我们需要构建 aarch64 内核镜像：

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

不要忘记添加 `LTO=thin`, 否则，如果您的计算机内存小于 24GB，构建可能会失败.

从 Android 13 开始，内核由 `bazel` 构建:

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

## 使用 KernelSU 构建内核

如果您可以成功构建内核，那么构建 KernelSU 就很容易，根据自己的需求在内核源代码根目录中运行以下任一命令：

::: code-group

```sh[最新 tag(稳定版本)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

```sh[main 分支(开发版本)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

```sh[指定 tag(比如 v0.5.2)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

:::

然后重建内核，您将获得带有 KernelSU 的内核映像！

```

`website/docs/zh_CN/guide/how-to-integrate-for-non-gki.md`:

```md
# 如何为非 GKI 内核集成 KernelSU {#introduction}

::: warning
该文档仅供存档参考，不再维护更新。
自 KernelSU v1.0 版本之后，我们放弃了对非 GKI 设备的官方支持。
:::

KernelSU 可以被集成到非 GKI 内核中，现在它最低支持到内核 4.14 版本；理论上也可以支持更低的版本。

由于非 GKI 内核的碎片化极其严重，因此通常没有统一的方法来编译它，所以我们也无法为非 GKI 设备提供 boot 镜像。但你完全可以自己集成 KernelSU 然后编译内核使用。

首先，你必须有能力从你设备的内核源码编译出一个可以开机并且能正常使用的内核，如果内核不开源，这通常难以做到。

如果你已经做好了上述准备，那有两个方法来集成 KernelSU 到你的内核之中。

1. 借助 `kprobe` 自动集成
2. 手动修改内核源码

## 使用 kprobe 集成 {#using-kprobes}

KernelSU 使用 kprobe 机制来做内核的相关 hook，如果 *kprobe* 可以在你编译的内核中正常运行，那么推荐用这个方法来集成。

首先，把 KernelSU 添加到你的内核源码树，在内核的根目录执行以下命令：

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

:::info
[KernelSU 1.0 及更高版本已经不再支持非 GKI 内核](https://github.com/tiann/KernelSU/issues/1705)，最后的支持版本为 `v0.9.5`，请注意使用正确的版本。
:::

然后，你需要检查你的内核是否开启了 *kprobe* 相关的配置，如果没有开启，需要添加以下配置：

```
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

最后，重新编译你的内核即可。

如果你发现 KPROBES 仍未生效，很有可能是因为它的依赖项`CONFIG_MODULES`没有被启用（如果还是未生效请键入`make menuconfig`搜索 KPROBES 的其它依赖并启用）

如果你在集成 KernelSU 之后手机无法启动，那么很可能你的内核中 **kprobe 工作不正常**，你需要修复这个 bug 或者用第二种方法。

:::tip 如何验证是否是 kprobe 的问题？

注释掉 `KernelSU/kernel/ksu.c` 中 `ksu_sucompat_init()` 和 `ksu_ksud_init()`，如果正常开机，那么就是 kprobe 的问题；或者你可以手动尝试使用 kprobe 功能，如果不正常，手机会直接重启。
:::

## 手动修改内核源码 {#modify-kernel-source-code}

如果 kprobe 工作不正常（通常是上游的 bug 或者内核版本过低），那你可以尝试这种方法：

首先，把 KernelSU 添加到你的内核源码树，在内核的根目录执行以下命令：

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

请注意，某些设备的 defconfig 文件可能在`arch/arm64/configs/设备代号_defconfig`或位于`arch/arm64/configs/vendor/设备代号_defconfig`。在您的 defconfig 文件中，将`CONFIG_KSU`设置为`y`以启用 KernelSU，或设置为`n`以禁用。比如在某个 defconfig 中：
`arch/arm64/configs/...` 
```sh
+# KernelSU
+CONFIG_KSU=y
```

然后，将 KernelSU 调用添加到内核源代码中，这里有几个补丁可以参考：

::: code-group

```diff[exec.c]
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
+#endif
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
+   #endif
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff[open.c]
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
+#endif
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff[read_write.c]
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);

+#ifdef CONFIG_KSU
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
+#endif
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
+   #ifdef CONFIG_KSU 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+   #endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff[stat.c]
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);

+#ifdef CONFIG_KSU
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;

+   #ifdef CONFIG_KSU
+	ksu_handle_stat(&dfd, &filename, &flags);
+   #endif
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```
:::

主要是要改四个地方：

1. do_faccessat，通常位于 `fs/open.c`
2. do_execveat_common，通常位于 `fs/exec.c`
3. vfs_read，通常位于 `fs/read_write.c`
4. vfs_statx，通常位于 `fs/stat.c`

如果你的内核没有 `vfs_statx`, 使用 `vfs_fstatat` 来代替它：
```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);
 
+#ifdef CONFIG_KSU 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif
+
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
+   #ifdef CONFIG_KSU 
+	ksu_handle_stat(&dfd, &filename, &flag);
+   #endif
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

对于早于 4.17 的内核，如果没有 `do_faccessat`，可以直接找到 `faccessat` 系统调用的定义然后修改：

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+#endif
+
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
+   #ifdef CONFIG_KSU
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+   #endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

### 安全模式 

要使用 KernelSU 内置的安全模式，你还需要修改 `drivers/input/input.c` 中的 `input_handle_event` 方法：

:::tip
强烈建议开启此功能，对用户救砖会非常有帮助！
:::

:::info 莫名其妙进入安全模式？
如果你采用手动集成的方式，并且没有禁用`CONFIG_KPROBES`，那么用户在开机之后按音量下，也可能触发安全模式！因此如果使用手动集成，你需要关闭 `CONFIG_KPROBES`！
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }

+#ifdef CONFIG_KSU
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+#endif
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+   #ifdef CONFIG_KSU
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
+   #endif
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

### pm 命令执行失败？

你需要同时修改 `fs/devpts/inode.c`，补丁如下：

```diff
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index 32f6f1c68..d69d8eca2 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -602,6 +602,8 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
        return dentry;
 }

+extern int ksu_handle_devpts(struct inode*);
+
 /**
  * devpts_get_priv -- get private data for a slave
  * @pts_inode: inode of the slave
@@ -610,6 +612,7 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
  */
 void *devpts_get_priv(struct dentry *dentry)
 {
+       ksu_handle_devpts(dentry->d_inode);
        if (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)
                return NULL;
        return dentry->d_fsdata;
```

### path_umount {#how-to-backport-path-umount}

你可以通过从 K5.9 向旧版本移植 `path_umount`，在 GKI 之前的内核上获得卸载模块的功能。你可以通过以下补丁作为参考:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

改完之后重新编译内核即可。

```

`website/docs/zh_CN/guide/installation.md`:

```md
# 安装 {#title}

## 检查您的设备是否被支持 {#check-if-supported}

从 [GitHub Releases](https://github.com/tiann/KernelSU/releases) 下载 KernelSU 管理器应用，然后将应用程序安装到设备并打开：

- 如果应用程序显示 “不支持”，则表示您的设备不支持 KernelSU，你需要自己编译设备的内核才能使用，KernelSU 官方不会也永远不会为你提供一个可以刷写的 boot 镜像。
- 如果应用程序显示 “未安装”，那么 KernelSU 支持您的设备；可以进行下一步操作。

:::info
对于显示“不支持”的设备，这里有一个[非官方支持设备列表](unofficially-support-devices.md)，你可以用这个列表里面的内核自行编译。
:::

## 备份你的 boot.img {#backup-boot-image}

在进行刷机操作之前，你必须先备份好自己的原厂 boot.img。如果你后续刷机出现了任何问题，你都可以通过使用 fastboot 刷回原厂 boot 来恢复系统。

::: warning
任何刷机操作都是有风险的，请务必做好这一步再进行下一步操作！！必要时你还可以备份你手机的所有数据。
:::

## 必备知识 {#acknowage}

### ADB 和 fastboot {#adb-and-fastboot}

此教程默认你会使用 ADB 和 fastboot 工具，如果你没有了解过，建议使用搜索引擎先学习相关知识。

### KMI

KMI 全称 Kernel Module Interface，相同 KMI 的内核版本是**兼容的** 这也是 GKI 中“通用”的含义所在；反之，如果 KMI 不同，那么这些内核之间无法互相兼容，刷入与你设备 KMI 不同的内核镜像可能会导致死机。

具体来说，对 GKI 的设备，其内核版本格式应该如下：

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

其中，`w.x-zzz-k` 为 KMI 版本。例如，一个设备内核版本为`5.10.101-android12-9-g30979850fc20`，那么它的 KMI 为 `5.10-android12-9`；理论上刷入其他这个 KMI 的内核也能正常开机。

::: tip
请注意，内核版本中的 SubLevel 不属于 KMI 的范畴！也就是说 `5.10.101-android12-9-g30979850fc20` 与 `5.10.137-android12-9-g30979850fc20` 的 KMI 相同！
:::

### 安全补丁级别 {#security-patch-level}

新的 Android 设备上可能采取了防回滚机制，它不允许刷入一个安全补丁更旧的内核。比如，如果你的设备内核是 `5.10.101-android12-9-g30979850fc20`，它的安全补丁为 `2023-11`；即使你刷入与内核 KMI 一致的内核，如果安全补丁级别比 `2023-11` 要老（例如`2023-06`），那么很可能会无法开机。

因此，在保持 KMI 一致的情况下，优先采用安全补丁级别更新的内核。

### 内核版本与 Android 版本 {#kernel-version-vs-android-version}

请注意：**内核版本与 Android 版本并不一定相同！**

如果您发现您的内核版本是 `android12-5.10.101`，然而你 Android 系统的版本为 Android 13 或者其他；请不要觉得奇怪，因为 Android 系统的版本与 Linux 内核的版本号不一定是一致的；Linux 内核的版本号一般与**设备出厂的时候自带的 Android 系统的版本一致**，如果后续 Android 系统升级，内核版本一般不会发生变化。如果你需要刷机，**请以内核版本为准！！**

## 安装介绍 {#installationintroduction}

自 `0.9.0` 版本以后，在 GKI 设备中，KernelSU 支持两种运行模式：

1. `GKI`：使用**通用内核镜像**（GKI）替换掉设备原有的内核。
2. `LKM`：使用**可加载内核模块**（LKM）的方式加载到设备内核中，不会替换掉设备原有的内核。

这两种方式适用于不同的场景，你可以根据自己的需求选择。

### GKI 模式 {#gki-mode}

GKI 模式会替换掉设备原有的内核，使用 KernelSU 提供的通用内核镜像。GKI 模式的优点是：

1. 通用型强，适用于大多数设备；比如三星开启了 KNOX 的设备，LKM 模式无法运作。还有一些冷门的魔改设备，也只能使用 GKI 模式；
2. 不依赖官方固件即可使用；不需要等待官方固件更新，只要 KMI 一致，就可以使用；

### LKM 模式 {#lkm-mode}

LKM 模式不会替换掉设备原有的内核，而是使用可加载内核模块的方式加载到设备内核中。LKM 模式的优点是：

1. 不会替换掉设备原有的内核；如果你对设备原有的内核有特殊需求，或者你希望在使用第三方内核的同时使用 KernelSU，可以使用 LKM 模式；
2. 升级和 OTA 较为方便；升级 KernelSU 时，可以直接在管理器里面安装，无需再手动刷写；系统 OTA 后，可以直接安装到第二个槽位，也无需再手动刷写；
3. 适用于一些特殊场景；比如使用临时 ROOT 权限也可以加载 LKM，由于不需要替换 boot 分区，因此不会触发 avb，不会使设备意外变砖；
4. LKM 可以被临时卸载；如果你临时想取消 root，可以卸载 LKM，这个过程不需要刷写分区，甚至也不用重启设备；如果你想再次 root，只需要重启设备即可；

:::tip 两种模式共存
打开管理器后，你可以在首页看到设备当前运行的模式；注意 GKI 模式的优先级高于 LKM，如你既使用 GKI 内核替换掉了原有的内核，又使用 LKM 的方式修补了 GKI 内核，那么 LKM 会被忽略，设备将永远以 GKI 的模式运行。
:::

### 选哪个？ {#which-one}

如果你的设备是手机，我们建议您优先考虑 LKM 模式；如果你的设备是模拟器、WSA 或者 Waydroid 等，我们建议您优先考虑 GKI 模式。

## LKM 安装

### 获取官方固件

使用 LKM 的模式，需要获取官方固件，然后在官方固件的基础上修补；如果你使用的是第三方内核，可以把第三方内核的 boot.img 作为官方固件。

获取官方固件的方法有很多，如果你的设备支持 `fastboot boot`，那么我们最推荐以及最简单的方法是使用 `fastboot boot` 临时启动 KernelSU 提供的 GKI 内核，然后安装管理器，最后在管理器中直接安装；这种方法不需要你手动下载官方固件，也不需要你手动提取 boot。

如果你的设备不支持 `fastboot boot`，那么你可能需要手动去下载官方固件包，然后从中提取 boot。

与 GKI 模式不同，LKM 模式会修改 `ramdisk`，因此在出厂 Android 13 的设备上，它需要修补的是 `init_boot` 分区而非 `boot` 分区；而 GKI 模式则永远是操作 `boot` 分区。

### 使用管理器

打开管理器，点击右上角的安装图标，会出现若干个选项：

1. 选择并修补一个文件；如果你手机目前没有 root 权限，你可以选择这个选项，然后选择你的官方固件，管理器会自动修补它；你只需要刷入这个修补后的文件，即可永久获取 root 权限；
2. 直接安装；如果你手机已经 root，你可以选择这个选项，管理器会自动获取你的设备信息，然后自动修补官方固件，然后刷入；你可以考虑使用 `fastboot boot` KernelSU 的 GKI 内核来获取临时 root 安装管理器，然后再使用这个选项；这种方式也是 KernelSU 升级最主要的方式；
3. 安装到另一个分区；如果你的设备支持 A/B 分区，你可以选择这个选项，管理器会自动修补官方固件，然后安装到另一个分区；这种方式适用于 OTA 后的设备，你可以在 OTA 后直接安装到另一个分区，然后重启设备即可；

### 使用命令行

如果你不想使用管理器，你也可以使用命令行来安装 LKM；KernelSU 提供的 `ksud` 工具可以帮助你快速修补官方固件，然后刷入。

这个工具支持 macOS、Linux 和 Windows，你可以在 [GitHub Release](https://github.com/tiann/KernelSU/releases) 下载对应的版本。

使用方法：`ksud boot-patch` 具体的使用方法你可以查看命令行帮助。

```sh
oriole:/ # ksud boot-patch -h
Patch boot or init_boot images to apply KernelSU

Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              boot image path, if not specified, will try to find the boot image automatically
  -k, --kernel <KERNEL>          kernel image path to replace
  -m, --module <MODULE>          LKM module path to replace, if not specified, will use the builtin one
  -i, --init <INIT>              init to be replaced
  -u, --ota                      will use another slot when boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                output path, if not specified, will use current directory
      --magiskboot <MAGISKBOOT>  magiskboot path, if not specified, will use builtin one
      --kmi <KMI>                KMI version, if specified, will use the specified KMI
  -h, --help                     Print help
```

需要说明的几个选项：

1. `--magiskboot` 选项可以指定 magiskboot 的路径，如果不指定，ksud 会在环境变量中查找；如果你不知道如何获取 magiskboot，可以查阅[这里](#patch-boot-image)；
2. `--kmi` 选项可以指定 `KMI` 版本，如果你的设备内核名字没有遵循 KMI 规范，你可以通过这个选项来指定；

最常见的使用方法为：

```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```

## GKI 安装

GKI 的安装方法有如下几种，各自适用于不同的场景，请按需选择：

1. 使用 KernelSU 提供的**通用内核镜像**使用 fastboot 安装
2. 使用内核刷写 App（如 KernelFlasher）安装
3. 手动修补 boot.img 然后安装
4. 使用自定义 Recovery（如 TWRP）安装

## 使用 KernelSU 提供的 boot.img 安装 {#install-by-kernelsu-boot-image}

如果你设备的 `boot.img` 采用常用的压缩格式，那么可以采用 KernelSU 提供的的通用内核镜像直接刷入，它不需要 TWRP 或者自行修补镜像。

### 找到合适的 boot.img {#found-propery-image}

KernelSU 为 GKI 设备提供了通用的 boot.img，您应该将 boot.img 刷写到设备的 boot 分区。

您可以从 [GitHub Release](https://github.com/tiann/KernelSU/releases) 下载 boot.img, 请注意您应该使用正确版本的 boot.img。如果您不知道应该下载哪一个文件，请仔细阅读本文档中关于 [KMI](#kmi) 和[安全补丁级别](#security-patch-level)的描述。

通常情况下，同一个 KMI 和 安全补丁级别下会有三个不同格式的 boot 文件，它们除了内核压缩格式不同之外都一样。请检查您原有 boot.img 的内核压缩格式，您应该使用正确的格式，例如 `lz4`、`gz`；如果是用不正确的压缩格式，刷入 boot 后可能无法开机。

::: info
1. 您可以通过 magiskboot 来获取你原来 boot 的压缩格式；当然您也可以询问与您机型相同的其他更有经验的童鞋。另外，内核的压缩格式通常不会发生变化，如果您使用某个压缩格式成功开机，后续可优先尝试这个格式。
2. 小米设备通常使用 `gz` 或者 **不压缩**。
3. Pixel 设备有些特殊，请查看下面的教程。
:::

### 将 boot.img 刷入设备 {#flash-boot-image}

使用 `adb` 连接您的设备，然后执行 `adb reboot bootloader` 进入 fastboot 模式，然后使用此命令刷入 KernelSU：

```sh
fastboot flash boot boot.img
```

::: info
如果你的设备支持 `fastboot boot`，可以先使用 `fastboot boot boot.img` 来先尝试使用 boot.img 引导系统，如果出现意外，再重启一次即可开机。
:::

### 重启 {#reboot}

刷入完成后，您应该重新启动您的设备：

```sh
fastboot reboot
```

## 使用内核刷写 App 安装 {#install-by-kernel-flasher}

步骤：

1. 下载 AnyKernel3 的刷机包，如果你不知道下载哪一个，请仔细查阅上述文档中关于 [KMI](#kmi) 和[安全补丁级别](#security-patch-level)的描述；下载错误的刷机包很可能导致无法开机，请注意备份。
2. 打开内核刷写 App（授予必要的 root 权限），使用提供的 AnyKernel3 刷机包刷入。

这种方法需要内核刷写 App 拥有 root 权限，你可以用如下几种方法实现：

1. 你的设备已经获取了 root 权限，比如你已经安装好了 KernelSU 想升级到最新的版本，又或者你通过其他方法（如 Magisk）获取了 root。
2. 如果你的手机没有 root，但手机支持 `fastboot boot boot.img` 这种临时启动的方法，你可以用 KernelSU 提供的 GKI 镜像临时启动你的设备，获取临时的 root 权限，然后使用内核刷写器刷入获取永久 root 权限。


如果您以前没有使用过内核刷写 App，建议使用以下应用：

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

## 手动修补 boot.img {#patch-boot-image}

对于某些设备来说，其 boot.img 格式不那么常见，比如不是 `lz4`, `gz` 和未压缩；最典型的就是 Pixel，它 boot.img 的格式是 `lz4_legacy` 压缩，ramdisk 可能是 `gz` 也可能是 `lz4_legacy` 压缩；此时如果你直接刷入 KernelSU 提供的 boot.img，手机可能无法开机；这时候，你可以通过手动修补 boot.img 来实现。

任何情况下都推荐使用 `magiskboot` 来修补 boot 镜像，有两个方法：

1. [magiskboot](https://github.com/topjohnwu/Magisk/releases)
2. [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci)

Magisk 官方提供的 `magiskboot` 只能运行在 Android/Linux 设备上，如果你想在 macOS/Windows 上使用 `magiskboot` 可以使用第二个方法。

::: tip
不再推荐使用 Android-Image-Kitchen，因为它可能没有合理地处理 boot 元数据（比如安全补丁级别），从而导致某些设备上会无法启动。
:::

### 准备 {#patch-preparation}

1. 获取你手机的原厂 boot.img；你可以通过你手机的线刷包解压后之间获取，如果你是卡刷包，那你也许需要 [payload-dumper-go](https://github.com/ssut/payload-dumper-go)
2. 下载 KernelSU 提供的与你设备 KMI 版本一致的 AnyKernel3 刷机包；如果您不知道应该下载哪一个文件，请仔细阅读本文档中关于 [KMI](#kmi) 和[安全补丁级别](#security-patch-level)的描述。
3. 解压缩 AnyKernel3 刷机包，获取其中的 `Image` 文件，此文件为 KernelSU 的内核文件。

### 在 Android 设备上使用 magiskboot {#using-magiskboot-on-Android-devices}

1. 在 Magisk 的 [Release 页面](https://github.com/topjohnwu/Magisk/releases) 下载最新的 Magisk 安装包。
2. 将 `Magisk-*(version).apk` 重命名为 `Magisk-*.zip` 然后解压缩。
3. 将解压后的 `Magisk-*/lib/arm64-v8a/libmagiskboot.so` 文件，使用 adb push 到手机：`adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`
4. 使用 adb 将原厂 boot.img 和 AnyKernel3 中的 Image 推送到手机
5. adb shell 进入 /data/local/tmp/ 目录，然后赋予刚 push 文件的可执行权限 `chmod +x magiskboot`
6. adb shell 进入 /data/local/tmp/ 目录，执行 `./magiskboot unpack boot.img` 此时会解包 `boot.img` 得到一个叫做 `kernel` 的文件，这个文件为你原厂的 kernel
7. 使用 `Image` 替换 `kernel`: `mv -f Image kernel`
8. 执行 `./magiskboot repack boot.img` 打包 img，此时你会得到一个 `new-boot.img` 的文件，使用这个文件 fastboot 刷入设备即可。

### 在 macOS/Windows/Linux 上使用 magiskboot {#using-magiskboot-on-PC}

1. 在 [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci) 下载适合你操作系统的 `magiskboot` 二进制文件。
2. 在你的 PC 上准备好设备原厂的 boot.img 和 KernelSU 的 Image。
3. `chmod +x magiskboot`
4. 在你 PC 上合适的目录执行 `./magiskboot unpack boot.img` 来解包 `boot.img`, 你会得到一个 `kernel` 文件，这个文件是你设备原厂的 kernel。
5. 使用 `Image` 替换 `kernel`: `mv -f Image kernel`
6. 执行 `./magiskboot repack boot.img` 打包 img，此时你会得到一个 `new-boot.img` 的文件，使用这个文件 fastboot 刷入设备即可。

:::info
Magisk 官方的 `magiskboot` 可以在 Linux 设备上执行，如果你是 Linux 用户，可以直接用官方版本。
:::

## 使用自定义 Recovery 安装 {#install-by-recovery}

前提：你的设备必须有自定义的 Recovery，如 TWRP；如果没有或者只有官方 Recovery，请使用其他方法。

步骤：

1. 在 KernelSU 的 [Release 页面](https://github.com/tiann/KernelSU/releases) 下载与你手机版本匹配的以 AnyKernel3 开头的 zip 刷机包；如果你不知道下载哪一个，请仔细查阅上述文档中关于 **KMI** 和**安全补丁级别**的描述；下载错误的刷机包很可能导致无法开机，请注意备份。
2. 重启手机进入 TWRP。
3. 使用 adb 将 AnyKernel3-*.zip 放到手机 /sdcard 然后在 TWRP 图形界面选择安装；或者你也可以直接 `adb sideload AnyKernel-*.zip` 安装。

PS. 这种方法适用于任何情况下的安装（不限于初次安装或者后续升级），只要你用 TWRP 就可以操作。

## 其他变通方法 {#other-methods}

其实所有这些安装方法的主旨只有一个，那就是**替换原厂的内核为 KernelSU 提供的内核**；只要能实现这个目的，就可以安装；比如以下是其他可行的方法：

1. 首先安装 Magisk，通过 Magisk 获取 root 权限后使用内核刷写器刷入 KernelSU 的 AnyKernel 包。
2. 使用某些 PC 上的刷机工具箱刷入 KernelSU 提供的内核。

如果这些方法导致无法开机，请优先尝试用 `magiskboot` 的方法。

## 安装后：模块支持 {#post-installation-module-support}

::: warning 修改系统文件需要 METAMODULE
如果您想使用修改 `/system` 文件的模块，需要在安装 KernelSU 后安装一个 **metamodule**。仅使用脚本、sepolicy 或 system.prop 的模块无需 metamodule。
:::

**要获得 `/system` 修改支持**，请参阅 [Metamodule 指南](metamodule.md) 了解：
- 什么是 metamodule 以及为什么需要它们
- 如何安装官方的 `meta-overlayfs` metamodule
- 其他 metamodule 选项

```

`website/docs/zh_CN/guide/metamodule.md`:

```md
# 元模块

元模块是 KernelSU 的一项革新性功能，它将关键的模块系统能力从核心转移到可插拔模块中。这种架构转变在保持 KernelSU 稳定性和安全性的同时，为模块生态系统释放了更大的创新潜力。

## 什么是元模块?

元模块是一种特殊类型的 KernelSU 模块，为模块系统提供核心基础设施功能。与常规模块不同，元模块控制常规模块的*安装和挂载方式*。

元模块是一种基于插件的扩展机制，允许完全自定义 KernelSU 的模块管理基础设施。通过将挂载和安装逻辑委托给元模块，KernelSU 避免成为脆弱的检测点，同时支持多样化的实现策略。

**主要特征:**

- **基础设施角色**: 元模块提供常规模块依赖的服务
- **单实例**: 只允许一个元模块处于运行状态
- **优先执行**: 元模块脚本在常规模块脚本之前运行
- **特殊钩子**: 提供三个用于安装、挂载和清理的钩子脚本

## 为什么需要元模块?

传统的 Root 解决方案将挂载逻辑内置在核心中，这使得它们更容易被检测且难以演进。KernelSU 的元模块架构通过关注点分离解决了这些问题。

**战略优势:**

- **减少检测面**: KernelSU 本身不执行挂载，减少了检测向量
- **稳定性**: 核心保持稳定，而挂载实现可以不断演进
- **创新性**: 社区可以开发替代挂载策略
- **选择性**: 用户可以选择最适合其需求的实现

**挂载灵活性:**

- **无挂载**: 对于仅使用无挂载模块的用户，完全避免挂载开销
- **OverlayFS 挂载**: 传统方法，支持读写层(通过 `meta-overlayfs`)
- **Magic Mount**: Magisk 兼容挂载，以获得更好的应用兼容性
- **自定义实现**: 基于 FUSE 的 overlayfs、自定义 VFS 挂载或全新方法

**超越挂载:**

- **可扩展性**: 添加内核模块支持等功能，无需修改核心 KernelSU
- **模块化**: 独立于 KernelSU 版本更新实现
- **定制化**: 为特定设备或用例创建专门的解决方案

::: warning 重要
如果没有安装元模块，依赖挂载的模块，其挂载功能将不会生效。新安装的 KernelSU 需要安装元模块(如 `meta-overlayfs`)才能使模块正常工作。
:::

## 对于用户

### 安装元模块

像安装常规模块一样安装元模块:

1. 下载元模块 ZIP 文件(例如 `meta-overlayfs.zip`)
2. 打开 KernelSU Manager 应用
3. 点击浮动操作按钮(➕)
4. 选择元模块 ZIP 文件
5. 重启设备

`meta-overlayfs` 元模块是官方参考实现，提供传统的基于 overlayfs 的模块挂载，支持读写系统分区。

### 检查活动的元模块

您可以在 KernelSU Manager 应用的模块页面中查看当前活动的元模块。活动的元模块将显示在模块列表中，并带有特殊标识。

### 卸载元模块

::: danger 警告
卸载元模块会影响**所有**模块。移除后，模块将不再被挂载，直到您安装另一个元模块。
:::

卸载步骤:

1. 打开 KernelSU Manager
2. 在模块列表中找到元模块
3. 点击卸载(您会看到特殊警告)
4. 确认操作
5. 重启设备

卸载后，如果您需要元模块的功能，应该安装另一个元模块。

### 单元模块约束

只允许一个元模块处于运行状态。如果您尝试安装第二个元模块，KernelSU 将阻止安装以避免冲突。

切换元模块的步骤:

1. 卸载所有常规模块
2. 卸载当前元模块
3. 重启
4. 安装新元模块
5. 重新安装常规模块
6. 再次重启

## 对于模块开发者

如果您正在开发常规 KernelSU 模块，您不需要太担心元模块。只要用户安装了兼容的元模块(如 `meta-overlayfs`)，您的模块就能正常工作。

**您需要知道的:**

- **挂载需要元模块**: 模块中的 `system` 目录只有在用户安装了提供挂载功能的元模块时才会被挂载
- **无需更改代码**: 现有模块无需修改即可继续工作

::: tip
如果您熟悉 Magisk 模块开发，您的模块在安装元模块后将在 KernelSU 中以相同方式工作，因为它提供了 Magisk 兼容的挂载。
:::

## 对于元模块开发者

创建元模块允许您自定义 KernelSU 处理模块安装、挂载和卸载的方式。

### 基本要求

元模块通过 `module.prop` 中的特殊属性来识别:

```txt
id=meta-example
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

`metamodule=1`(或 `metamodule=true`)属性将此模块标记为元模块。没有此属性，模块将被视为常规模块。

### 文件结构

元模块结构:

```txt
meta-example/
├── module.prop              (必须包含 metamodule=1)
│
│      *** 元模块特定钩子 ***
├── metamount.sh             (可选: 自定义挂载处理程序)
├── metainstall.sh           (可选: 常规模块的安装钩子)
├── metauninstall.sh         (可选: 常规模块的清理钩子)
│
│      *** 标准模块文件(全部可选) ***
├── customize.sh             (安装自定义)
├── post-fs-data.sh          (post-fs-data 阶段脚本)
├── service.sh               (late_start service 脚本)
├── boot-completed.sh        (启动完成脚本)
├── uninstall.sh             (元模块自己的卸载脚本)
└── [任何其他文件]
```

除了特殊的元模块钩子外，元模块可以使用所有标准模块功能(生命周期脚本等)。

### 钩子脚本

元模块可以提供最多三个特殊钩子脚本:

#### 1. metamount.sh - 挂载处理程序

**目的**: 控制启动期间模块的挂载方式。

**执行时机**: 参考 [执行顺序](#execution-order)

**环境变量:**

- `MODDIR`: 元模块的目录路径(例如 `/data/adb/modules/meta-example`)
- 所有标准 KernelSU 环境变量

**职责:**

- 以无系统方式挂载所有已启用的模块
- 检查 `skip_mount` 标志
- 处理特定模块的挂载要求

::: danger 关键要求
执行挂载操作时，**必须**将源/设备名称设置为 `"KSU"`。这将挂载标识为属于 KernelSU。

**示例(正确):**

```sh
mount -t overlay -o lowerdir=/lower，upperdir=/upper，workdir=/work KSU /target
```

**对于现代挂载 API**，设置源字符串:

```rust
fsconfig_set_string(fs， "source"， "KSU")?;
```

这对于 KernelSU 正确识别和管理其挂载至关重要。
:::

**示例脚本:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# 示例: 简单的绑定挂载实现
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # 使用 source=KSU 挂载(必需!)
        mount -o bind，dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - 安装钩子

**目的**: 自定义常规模块的安装方式。

**执行时机**: 在模块安装期间，文件提取后但安装完成前。此脚本被内置安装程序**source**(而非执行)，类似于 `customize.sh` 的工作方式。

**环境变量和函数:**

此脚本继承内置 `install.sh` 的所有变量和函数:

- **变量**: `MODPATH`、`TMPDIR`、`ZIPFILE`、`ARCH`、`API`、`IS64BIT`、`KSU`、`KSU_VER`、`KSU_VER_CODE`、`BOOTMODE` 等
- **函数**:
  - `ui_print <msg>` - 向控制台打印消息
  - `abort <msg>` - 打印错误并终止安装
  - `set_perm <target> <owner> <group> <permission> [context]` - 设置文件权限
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - 递归设置权限
  - `install_module` - 调用内置模块安装过程

**用例:**

- 在内置安装之前或之后处理模块文件(准备好后调用 `install_module`)
- 移动模块文件
- 验证模块兼容性
- 设置特殊目录结构
- 初始化模块特定资源

**注意**: 安装元模块本身时**不会**调用此脚本。

#### 3. metauninstall.sh - 清理钩子

**目的**: 卸载常规模块时清理资源。

**执行时机**: 在模块卸载期间，在删除模块目录之前。

**环境变量:**

- `MODULE_ID`: 正在卸载的模块的 ID

**用例:**

- 处理文件
- 清理符号链接
- 释放分配的资源
- 更新内部跟踪

**示例脚本:**

```sh
#!/system/bin/sh
# 卸载常规模块时调用
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# 从镜像中删除模块文件
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### 执行顺序 {#execution-order}

了解启动执行顺序对于元模块开发至关重要:

```txt
post-fs-data 阶段:
  1. 执行通用 post-fs-data.d 脚本
  2. restorecon，加载 sepolicy.rule
  3. 执行元模块的 post-fs-data.sh(如果存在)
  4. 执行常规模块的 post-fs-data.sh
  5. 加载 system.prop
  6. 执行元模块的 metamount.sh
     └─> 以无系统方式挂载所有模块
  7. post-mount.d 阶段运行
     - 通用 post-mount.d 脚本
     - 元模块的 post-mount.sh(如果存在)
     - 常规模块的 post-mount.sh

service 阶段:
  1. 执行通用 service.d 脚本
  2. 执行元模块的 service.sh(如果存在)
  3. 执行常规模块的 service.sh

boot-completed 阶段:
  1. 执行通用 boot-completed.d 脚本
  2. 执行元模块的 boot-completed.sh(如果存在)
  3. 执行常规模块的 boot-completed.sh
```

**要点:**

- `metamount.sh` 在所有 post-fs-data 脚本(元模块和常规模块)**之后**运行
- 元模块生命周期脚本(`post-fs-data.sh`、`service.sh`、`boot-completed.sh`)始终在常规模块脚本之前运行
- `.d` 目录中的通用脚本在元模块脚本之前运行
- `post-mount` 阶段在挂载完成后运行

### 符号链接机制

当安装元模块时，KernelSU 会创建一个符号链接:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

这为访问活动元模块提供了稳定的路径，无论其 ID 如何。

**好处:**

- 一致的访问路径
- 轻松检测活动元模块
- 简化配置

### 真实示例: meta-overlayfs

`meta-overlayfs` 元模块是官方参考实现。它展示了元模块开发的最佳实践。

#### 架构

`meta-overlayfs` 使用**双目录架构**:

1. **元数据目录**: `/data/adb/modules/`
   - 包含 `module.prop`、`disable`、`skip_mount` 标记
   - 启动期间快速扫描
   - 存储占用小

2. **内容目录**: `/data/adb/metamodule/mnt/`
   - 包含实际模块文件(system、vendor、product 等)
   - 存储在 ext4 镜像(`modules.img`)中
   - 使用 ext4 功能优化空间

#### metamount.sh 实现

以下是 `meta-overlayfs` 如何实现挂载处理程序:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# 如果尚未挂载，则挂载 ext4 镜像
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop，rw，noatime "$IMG_FILE" "$MNT_DIR"
fi

# 为双目录支持设置环境变量
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# 执行挂载二进制文件
# (实际挂载逻辑在 Rust 二进制文件中)
"$MODDIR/meta-overlayfs"
```

#### 主要特性

**Overlayfs 挂载:**

- 使用内核 overlayfs 进行真正的无系统修改
- 支持多个分区(system、vendor、product、system_ext、odm、oem)
- 通过 `/data/adb/modules/.rw/` 支持读写层

**源标识:**

```rust
// 来自 meta-overlayfs/src/mount.rs
fsconfig_set_string(fs， "source"， "KSU")?;  // 必需!
```

这为所有 overlay 挂载设置 `dev=KSU`，实现正确识别。

### 最佳实践

开发元模块时:

1. **始终将源设置为"KSU"**以进行挂载操作 - 内核卸载和 zygisksu 卸载需要此设置才能正确卸载
2. **优雅地处理错误** - 启动过程对时间敏感
3. **尊重标准标志** - 支持 `skip_mount` 和 `disable`
4. **记录操作** - 使用 `echo` 或日志记录进行调试
5. **彻底测试** - 挂载错误可能导致启动循环
6. **记录行为** - 清楚地解释您的元模块做什么
7. **提供迁移路径** - 帮助用户从其他解决方案切换

### 测试您的元模块

发布前:

1. 在干净的 KernelSU 设置上**测试安装**
2. **验证挂载**各种模块类型
3. **检查兼容性**与常见模块
4. **测试卸载**和清理
5. **验证启动性能**(metamount.sh 是阻塞的!)
6. **确保正确的错误处理**以避免启动循环

## 常见问题

### 我需要元模块吗?

**对于用户**: 仅当您想使用需要挂载的模块时。如果您只使用运行脚本而不修改系统文件的模块，则不需要元模块。

**对于模块开发者**: 不需要，您正常开发模块。仅当您的模块需要挂载时，用户才需要元模块。

**对于高级用户**: 仅当您想自定义挂载行为或创建替代挂载实现时。

### 我可以有多个元模块吗?

不可以。一次只能安装一个元模块。这可以防止冲突并确保可预测的行为。

### 如果我卸载了唯一的元模块会怎样?

模块将不再被挂载。您的设备将正常启动，但模块修改将不会应用，直到您安装另一个元模块。

### meta-overlayfs 是必需的吗?

不是。它提供与大多数模块兼容的标准 overlayfs 挂载。如果您需要不同的行为，可以创建自己的元模块。

## 另请参阅

- [模块指南](module.md) - 通用模块开发
- [与 Magisk 的区别](difference-with-magisk.md) - 比较 KernelSU 和 Magisk
- [如何构建](how-to-build.md) - 从源代码构建 KernelSU

```

`website/docs/zh_CN/guide/module-config.md`:

```md
# 模块配置

KernelSU 提供了一个内置的配置系统,允许模块存储持久化或临时的键值设置。配置以二进制格式存储在 `/data/adb/ksu/module_configs/<module_id>/`,具有以下特性:

## 配置类型

- **持久配置** (`persist.config`):重启后保留,直到明确删除或卸载模块
- **临时配置** (`tmp.config`):在每次启动时的 post-fs-data 阶段自动清除

读取配置时,对于同一个键,临时值优先于持久值。

## 在模块脚本中使用配置

所有模块脚本(`post-fs-data.sh`、`service.sh`、`boot-completed.sh` 等)运行时都会设置 `KSU_MODULE` 环境变量为模块 ID。您可以使用 `ksud module config` 命令来管理模块的配置:

```bash
# 获取配置值
value=$(ksud module config get my_setting)

# 设置持久配置值
ksud module config set my_setting "some value"

# 设置临时配置值(重启后清除)
ksud module config set --temp runtime_state "active"

# 从 stdin 设置值(适用于多行或复杂数据)
ksud module config set my_key <<EOF
多行
文本值
EOF

# 或从命令管道输入
echo "value" | ksud module config set my_key

# 显式使用 stdin 标志
cat file.json | ksud module config set json_data --stdin

# 列出所有配置项(合并持久和临时配置)
ksud module config list

# 删除配置项
ksud module config delete my_setting

# 删除临时配置项
ksud module config delete --temp runtime_state

# 清除所有持久配置
ksud module config clear

# 清除所有临时配置
ksud module config clear --temp
```

## 验证限制

配置系统强制执行以下限制:

- **最大键长度**:256 字节
- **最大值长度**:1MB (1048576 字节)
- **最大配置项数**:每个模块 32 个
- **键格式**:必须匹配 `^[a-zA-Z][a-zA-Z0-9._-]+$`(与模块 ID 相同)
  - 必须以字母(a-zA-Z)开头
  - 可包含字母、数字、点(`.`)、下划线(`_`)或连字符(`-`)
  - 最小长度:2 个字符
- **值格式**:无限制 - 可包含任何 UTF-8 字符,包括换行符、控制字符等
  - 以二进制格式存储,带长度前缀,确保安全处理所有数据

## 生命周期

- **启动时**:所有临时配置在 post-fs-data 阶段清除
- **模块卸载时**:所有配置(持久和临时)自动删除
- 配置以二进制格式存储,使用魔数 `0x4b53554d`("KSUM")和版本验证

## 使用场景

配置系统适用于:

- **用户偏好**:存储用户通过 WebUI 或 action 脚本配置的模块设置
- **功能开关**:在不重新安装的情况下启用/禁用模块功能
- **运行时状态**:跟踪应在重启时重置的临时状态(使用临时配置)
- **安装设置**:记住模块安装时做出的选择
- **复杂数据**:存储 JSON、多行文本、Base64 编码数据或任何结构化内容(最多 1MB)

::: tip 最佳实践
- 对于应在重启后保留的用户偏好,使用持久配置
- 对于应在启动时重置的运行时状态或功能开关,使用临时配置
- 在脚本中使用配置值之前验证它们
- 使用 `ksud module config list` 命令调试配置问题
:::

## 高级功能

模块配置系统提供了用于高级用例的特殊配置键:

### 覆盖模块描述 {#overriding-module-description}

您可以通过设置 `override.description` 配置键来动态覆盖 `module.prop` 中的 `description` 字段:

```bash
# 覆盖模块描述
ksud module config set override.description "在管理器中显示的自定义描述"
```

当获取模块列表时,如果存在 `override.description` 配置,它将替换 `module.prop` 中的原始描述。这对于以下场景很有用:
- 在模块描述中显示动态状态信息
- 向用户显示运行时配置详情
- 基于模块状态更新描述而无需重新安装

### 声明管理的功能

模块可以使用 `manage.<feature>` 配置模式声明它们管理的 KernelSU 功能。支持的功能对应于 KernelSU 内部的 `FeatureId` 枚举:

**支持的功能:**
- `su_compat` - SU 兼容模式
- `kernel_umount` - 内核自动卸载

```bash
# 声明此模块管理 SU 兼容性并将其启用
ksud module config set manage.su_compat true

# 声明此模块管理内核卸载并将其禁用
ksud module config set manage.kernel_umount false

# 移除功能管理(模块不再控制此功能)
ksud module config delete manage.su_compat
```

**工作原理:**
- `manage.<feature>` 键的存在表示模块正在管理该功能
- 值表示期望的状态:`true`/`1` 代表启用,`false`/`0`(或任何其他值)代表禁用
- 要停止管理某个功能,请完全删除该配置键

管理的功能通过模块列表 API 以 `managedFeatures` 字段(逗号分隔的字符串)公开。这允许:
- KernelSU 管理器检测哪些模块管理哪些 KernelSU 功能
- 防止多个模块尝试管理同一功能时发生冲突
- 更好地协调模块与核心 KernelSU 功能之间的关系

::: warning 仅支持预定义功能
仅使用上面列出的预定义功能名称(`su_compat`、`kernel_umount`)。这些对应于实际的 KernelSU 内部功能。使用其他功能名称不会导致错误,但没有任何功能作用。
:::

```

`website/docs/zh_CN/guide/module-webui.md`:

```md
# 模块 WebUI

KernelSU 的模块除了执行启动脚本和修改系统文件之外，还支持显示 UI 界面和与用户交互。

你可以通过任何 Web 技术编写 HTML + CSS + JavaScript 页面，KernelSU 的管理器将通过 WebView 显示这些页面。此外，KernelSU 还提供了一些用于与系统交互的 JavaScript API，例如执行 shell 命令。

## WebUI 根目录

Web 资源文件应放置在模块根目录的 `webroot` 子目录中，并且其中**必须**有一个名为`index.html`的文件，该文件是模块页面入口。包含 Web 界面的最简单的模块结构如下：

````txt
❯ tree .
.
|-- module.prop
`-- webroot
     `--index.html
````

:::warning
安装模块时，KernelSU 会自动设置 `webroot` 目录的权限和 SELinux context，如果您不知道自己在做什么，请不要自行设置该目录的权限！
:::

如果您的页面包含 CSS 和 JavaScript，您也需要将其放入此目录中。

## JavaScript API

如果只是一个显示页面，那它和普通网页没有什么区别。更重要的是，KernelSU 提供了一系列的系统 API，可以让您实现模块特有的功能。

KernelSU 提供了一个 JavaScript 库并[在 npm 上发布](https://www.npmjs.com/package/kernelsu)，您可以在网页的 JavaScript 代码中使用它。

例如，您可以执行 shell 命令来获取特定配置或修改属性：

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = await exec("getprop ro.product.model");
````

再比如，你可以让网页全屏显示，或者显示一个 Toast。

[API 文档](https://www.npmjs.com/package/kernelsu)

如果您发现现有的 API 不能满足您的需求或者使用不方便，欢迎[在这里](https://github.com/tiann/KernelSU/issues)给我们提出建议！

## 一些技巧

1. 您可以正常使用`localStorage`存储一些数据，但卸载管理器后，这些数据将会丢失。 如果需要持久保存，可以自己将数据写入某个目录。
2. 对于简单的页面，我建议您使用 [parceljs](https://parceljs.org/) 进行打包。它零配置，使用非常方便。不过，如果你是前端高手或者有自己的喜好，那就选择你喜欢的吧！

```

`website/docs/zh_CN/guide/module.md`:

```md
# 模块开发指南 {#introduction}

KernelSU 提供了一个模块机制，它可以在保持系统分区完整性的同时达到修改系统分区的效果；这种机制通常被称之为 systemless。

KernelSU 的模块运作机制与 Magisk 几乎是一样的，如果你熟悉 Magisk 模块的开发，那么开发 KernelSU 的模块大同小异，你可以跳过下面有关模块的介绍，只需要了解 [KernelSU 模块与 Magisk 模块的异同](difference-with-magisk.md)。

::: warning 仅修改系统文件需要 METAMODULE
KernelSU 使用 [metamodule](metamodule.md) 架构来挂载 `system` 目录。**只有当您的模块需要修改 `/system` 文件**（通过 `system` 目录）时，才需要安装 metamodule（例如 [meta-overlayfs](https://github.com/tiann/KernelSU/releases)）。其他模块功能如脚本、sepolicy 规则和 system.prop 无需 metamodule 即可工作。
:::

## 模块界面

KernelSU 的模块支持显示界面并与用户交互，请参阅 [WebUI 文档](module-webui.md)。

## 模块配置

KernelSU 提供了一个内置的配置系统，允许模块存储持久化或临时的键值设置。详情请参阅[模块配置文档](module-config.md)。

## Busybox

KernelSU 提供了一个功能完备的 BusyBox 二进制文件（包括完整的 SELinux 支持）。可执行文件位于 `/data/adb/ksu/bin/busybox`。
KernelSU 的 BusyBox 支持运行时可切换的 "ASH Standalone Shell Mode"。
这种独立模式意味着在运行 BusyBox 的 ash shell 时，每个命令都会直接使用 BusyBox 中内置的应用程序，而不管 PATH 设置为什么。
例如，`ls`、`rm`、`chmod` 等命令将不会使用 PATH 中设置的命令（在 Android 的情况下，默认情况下分别为 `/system/bin/ls`、`/system/bin/rm` 和 `/system/bin/chmod`），而是直接调用 BusyBox 内置的应用程序。
这确保了脚本始终在可预测的环境中运行，并始终具有完整的命令套件，无论它运行在哪个 Android 版本上。
要强制一个命令不使用 BusyBox，你必须使用完整路径调用可执行文件。

在 KernelSU 上下文中运行的每个 shell 脚本都将在 BusyBox 的 ash shell 中以独立模式运行。对于第三方开发者相关的内容，包括所有启动脚本和模块安装脚本。

对于想要在 KernelSU 之外使用这个“独立模式”功能的用户，有两种启用方法:

1. 设置环境变量 `ASH_STANDALONE` 为 `1`。例如：`ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. 使用命令行选项切换：`/data/adb/ksu/bin/busybox sh -o standalone <script>`

为了确保所有后续的 `sh` shell 都在独立模式下执行，第一种是首选方法（这也是 KernelSU 和 KernelSU 管理器内部使用的方法），因为环境变量会被继承到子进程中。

::: tip 与 Magisk 的差异

KernelSU 的 BusyBox 现在是直接使用 Magisk 项目编译的二进制文件，**感谢 Magisk！**
因此，你完全不用担心 BusyBox 脚本与在 Magisk 和 KernelSU 之间的兼容问题，因为他们是完全一样的！
:::

## KernelSU 模块 {#kernelsu-modules}

KernelSU 模块就是一个放置在 `/data/adb/modules` 内且满足如下结构的文件夹：

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- 模块的文件夹名称与模块 ID 相同
│   │
│   │      *** 模块配置文件 ***
│   │
│   ├── module.prop         <--- 此文件保存模块相关的一些配置，如模块 ID、版本等
│   │
│   │      *** 模块内容 ***
│   │
│   ├── system              <--- 这个文件夹通常会被挂载到系统
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** 标记文件 ***
│   │
│   ├── skip_mount          <--- 如果这个文件存在，那么模块的 `/system` 将不会被挂载
│   ├── disable             <--- 如果这个文件存在，那么模块会被禁用
│   ├── remove              <--- 如果这个文件存在，下次重启的时候模块会被移除
│   │
│   │      *** 可选文件 ***
│   │
│   ├── post-fs-data.sh     <--- 这个脚本将会在 post-fs-data 模式下运行
│   ├── post-mount.sh       <--- 这个脚本将会在 post-mount 模式下运行
│   ├── service.sh          <--- 这个脚本将会在 late_start 服务模式下运行
│   ├── boot-completed.sh   <--- 这个脚本将会在 Android 系统启动完毕后以服务模式运行
|   ├── uninstall.sh        <--- 这个脚本将会在模块被卸载时运行
│   ├── system.prop         <--- 这个文件中指定的属性将会在系统启动时通过 resetprop 更改
│   ├── sepolicy.rule       <--- 这个文件中的 SELinux 策略将会在系统启动时加载
│   │
│   │      *** 自动生成的目录，不要手动创建或者修改！ ***
│   │
│   ├── vendor              <--- 如果 /system/vendor 是符号链接且存在，从 $MODID/system/vendor 移动到模块根目录
│   ├── product             <--- 如果 /system/product 是符号链接且存在，从 $MODID/system/product 移动到模块根目录
│   ├── system_ext          <--- 如果 /system/system_ext 是符号链接且存在，从 $MODID/system/system_ext 移动到模块根目录
│   │
│   │      *** Any additional files / folders are allowed ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip 与 Magisk 的差异
KernelSU 没有内置的针对 Zygisk 的支持，因此模块中没有 Zygisk 相关的内容，但你可以通过 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 来支持 Zygisk 模块，此时 Zygisk 模块的内容与 Magisk 所支持的 Zygisk 是完全相同的。
:::

### module.prop

module.prop 是一个模块的配置文件，在 KernelSU 中如果模块中不包含此文件，那么它将不被认为是一个模块；此文件的格式如下：

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
actionIcon=<path> (optional)
webuiIcon=<path> (optional)
```

- id 必须与这个正则表达式匹配：`^[a-zA-Z][a-zA-Z0-9._-]+$` 例如：✓ `a_module`，✓ `a.module`，✓ `module-101`，✗ `a module`，✗ `1_module`，✗ `-a-module`。这是您的模块的唯一标识符，发布后不应更改。
- versionCode 必须是一个整数，用于比较版本。
- 其他未在上面提到的内容可以是任何单行字符串。
- 请确保使用 UNIX（LF）换行类型，而不是 Windows（CR + LF）或 Macintosh（CR）。
- actionIcon 和 webuiIcon 是可选的图标路径，用作管理器中模块
  Action 快捷方式和 WebUI 快捷方式的默认图标。这些路径必须是基于模
  块根目录的相对路径。例如 `actionIcon=icon/icon.png`
  将会解析为 `<MODDIR>/icon/icon.png`。

::: tip 动态描述
`description` 字段可以在运行时使用模块配置系统动态覆盖。详情请参阅[覆盖模块描述](module-config.md#overriding-module-description)。
:::

### Shell 脚本 {#shell-scripts}

请阅读 [启动脚本](#boot-scripts) 一节，以了解 `post-fs-data.sh`, `post-mount.sh`, `service.sh` 和 `boot-completed.sh` 之间的区别。对于大多数模块开发者来说，如果您只需要运行一个启动脚本，`service.sh` 应该已经足够了。

在您的模块的所有脚本中，请使用`MODDIR=${0%/*}`来获取您的模块的基本目录路径；请勿在脚本中硬编码您的模块路径。

:::tip 与 Magisk 的差异
你可以通过环境变量 `KSU` 来判断脚本是运行在 KernelSU 还是 Magisk 中，如果运行在 KernelSU，这个值会被设置为 `true`。
:::

### `system` 目录 {#system-directories}

这个目录的内容会在系统启动后，以 `overlayfs` 的方式叠加在系统的 `/system` 分区之上，这意味着：

1. 系统中对应目录的同名文件会被此目录的文件覆盖。
2. 系统中对应目录的同名文件夹会与此目录的文件夹合并。

如果你想删掉系统原来目录某个文件或者文件夹，你需要在模块目录通过 `mknod filename c 0 0` 来创建一个 `filename` 的同名文件；这样 overlayfs 系统会自动 whiteout 等效删除此文件（`/system` 分区并没有被更改）。

你也可以在 `customize.sh` 中声明一个名为 `REMOVE` 并且包含一系列目录的变量来执行删除操作，KernelSU 会自动为你在模块对应目录执行 `mknod <TARGET> c 0 0`。例如：

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

上面的这个列表将会执行： `mknod $MODPATH/system/app/YouTuBe c 0 0` 和 `mknod $MODPATH/system/app/Bloatware c 0 0`；并且 `/system/app/YouTube` 和 `/system/app/Bloatware` 将会在模块生效后被删除。

如果你想替换掉系统的某个目录，你需要在模块目录创建一个相同路径的目录，然后为此目录设置此属性：`setfattr -n trusted.overlay.opaque -v y <TARGET>`；这样 overlayfs 系统会自动将系统内相应目录替换（`/system` 分区并没有被更改）。

你可以在 `customize.sh` 中声明一个名为 `REPLACE` 并且包含一系列目录的变量来执行替换操作，KernelSU 会自动为你在模块对应目录执行相关操作。例如：

```sh
REPLACE="
/system/app/YouTube
/system/app/Bloatware
"
```

上面这个列表将会：自动创建目录 `$MODPATH/system/app/YouTube` 和 `$MODPATH//system/app/Bloatware`，然后执行 `setfattr -n trusted.overlay.opaque -v y $$MODPATH/system/app/YouTube` 和 `setfattr -n trusted.overlay.opaque -v y $$MODPATH/system/app/Bloatware`；并且 `/system/app/YouTube` 和 `/system/app/Bloatware` 将会在模块生效后替换为空目录。

::: tip 与 Magisk 的差异

KernelSU 的 systemless 机制是通过内核的 overlayfs 实现的，而 Magisk 当前则是通过 magic mount (bind mount)，二者实现方式有着巨大的差异，但最终的目标实际上是一致的：不修改物理的 `/system` 分区但实现修改 `/system` 文件。
:::

如果你对 overlayfs 感兴趣，建议阅读 Linux Kernel 关于 [overlayfs 的文档](https://docs.kernel.org/filesystems/overlayfs.html)

### system.prop

这个文件的格式与 `build.prop` 完全相同：每一行都是 `[key]=[value]` 的形式。

### sepolicy.rule

如果您的模块需要一些额外的 SELinux 策略补丁，请将这些规则添加到此文件中。这个文件中的每一行都将被视为一个策略语句。

## 模块安装包 {#module-installer}

KernelSU 的模块安装包就是一个可以通过 KernelSU 管理器 APP 刷入的 zip 文件，此 zip 文件的格式如下：

```txt
module.zip
│
├── customize.sh                       <--- (Optional, more details later)
│                                           This script will be sourced by update-binary
├── ...
├── ...  /* 其他模块文件 */
│
```

:::warning
KernelSU 模块不支持在 Recovery 中安装！！
:::

### 定制安装过程 {#customizing-installation}

如果你想控制模块的安装过程，可以在模块的目录下创建一个名为 `customize.sh` 的文件，这个脚本将会在模块被解压后**导入**到当前 shell 中，如果你的模块需要根据设备的 API 版本或者设备构架做一些额外的操作，那这个脚本将非常有用。

如果你想完全控制脚本的安装过程，你可以在 `customize.sh` 中声明 `SKIPUNZIP=1` 来跳过所有的默认安装步骤；此时，你需要自行处理所有安装过程（如解压模块，设置权限等）

`customize.sh` 脚本以“独立模式”运行在 KernelSU 的 BusyBox `ash` shell 中。你可以使用如下变量和函数：

#### 变量 {#variables}

- `KSU` (bool): 标记此脚本运行在 KernelSU 环境下，此变量的值将永远为 `true`，你可以通过它区分 Magisk。
- `KSU_VER` (string): KernelSU 当前的版本名字 (如： `v0.4.0`)
- `KSU_VER_CODE` (int): KernelSU 用户空间当前的版本号 (如. `10672`)
- `KSU_KERNEL_VER_CODE` (int): KernelSU 内核空间当前的版本号 (如. `10672`)
- `BOOTMODE` (bool): 此变量在 KernelSU 中永远为 `true`
- `MODPATH` (path): 当前模块的安装目录
- `TMPDIR` (path): 可以存放临时文件的目录
- `ZIPFILE` (path): 当前模块的安装包文件
- `ARCH` (string): 设备的 CPU 构架，有如下几种： `arm`, `arm64`, `x86`, or `x64`
- `IS64BIT` (bool): 是否是 64 位设备
- `API` (int): 当前设备的 Android API 版本 (如：Android 6.0 上为 `23`)

::: warning
`MAGISK_VER_CODE` 在 KernelSU 中永远为 `25200`，`MAGISK_VER` 则为 `v25.2`，请不要通过这两个变量来判断是否是 KernelSU！
:::

#### 函数 {#functions}

```txt
ui_print <msg>
    print <msg> to console
    Avoid using 'echo' as it will not display in custom recovery's console

abort <msg>
    print error message <msg> to console and terminate the installation
    Avoid using 'exit' as it will skip the termination cleanup steps

set_perm <target> <owner> <group> <permission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    this function is a shorthand for the following commands:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    for all files in <directory>, it will call:
       set_perm file owner group filepermission context
    for all directories in <directory> (including itself), it will call:
       set_perm dir owner group dirpermission context
```

## 启动脚本 {#boot-scripts}

在 KernelSU 中，根据脚本运行模式的不同分为两种：post-fs-data 模式和 late_start 服务模式。

- post-fs-data 模式
  - 这个阶段是阻塞的。在执行完成之前或者 10 秒钟之后，启动过程会暂停。
  - 脚本在任何模块被挂载之前运行。这使得模块开发者可以在模块被挂载之前动态地调整它们的模块。
  - 这个阶段发生在 Zygote 启动之前。
  - 使用 setprop 会导致启动过程死锁！请使用 `resetprop -n <prop_name> <prop_value>` 代替。
  - **只有在必要时才在此模式下运行脚本**。

- late_start 服务模式
  - 这个阶段是非阻塞的。你的脚本会与其余的启动过程**并行**运行。
  - **大多数脚本都建议在这种模式下运行**。

在 KernelSU 中，启动脚本根据存放位置的不同还分为两种：通用脚本和模块脚本。

- 通用脚本
  - 放置在 `/data/adb/post-fs-data.d`, `/data/adb/post-mount.d`, `/data/adb/service.d` 或 `/data/adb/boot-completed.d` 中。
  - 只有在脚本被设置为可执行（`chmod +x script.sh`）时才会被执行。
  - 在 `post-fs-data.d` 中的脚本以 post-fs-data 模式运行，在 `service.d` 中的脚本以 late_start 服务模式运行。
  - 模块**不应**在安装过程中添加通用脚本。

- 模块脚本
  - 放置在模块自己的文件夹中。
  - 只有当模块被启用时才会执行。
  - `post-fs-data.sh` 以 post-fs-data 模式运行，`post-mount.sh` 以 post-mount 模式运行，而 `service.sh` 则以 late_start 服务模式运行，`boot-completed` 在 Android 系统启动完毕后以服务模式运行。

所有启动脚本都将在 KernelSU 的 BusyBox ash shell 中运行，并启用“独立模式”。

### 启动脚本的流程解疑 {#Boot-scripts-process-explanation}

以下是 Android 的相关启动流程（部分省略），其中包括了 KernelSU 的操作（带前导星号），应该能帮助你更好地理解这些启动脚本的用途：

```txt
0. Bootloader (nothing on screen)
load patched boot.img
load kernel:
    - GKI mode: GKI kernel with KernelSU integrated
    - LKM mode: stock kernel
...

1. kernel exec init (oem logo on screen):
    - GKI mode: stock init
    - LKM mode: exec ksuinit, insmod kernelsu.ko, exec stock init
mount /dev, /dev/pts, /proc, /sys, etc.
property-init -> read default props
read init.rc
...
early-init -> init -> late_init
early-fs
   start vold
fs
  mount /vendor, /system, /persist, etc.
post-fs-data
  *safe mode check
  *execute general scripts in post-fs-data.d/
  *load sepolicy.rule
  *mount tmpfs
  *execute module scripts post-fs-data.sh
    **(Zygisk)./bin/zygisk-ptrace64 monitor
  *(pre)load system.prop (same as resetprop -n)
  *remount modules /system
  *execute general scripts in post-mount.d/
  *execute module scripts post-mount.sh
zygote-start
load_all_props_action
  *execute resetprop (actual set props for resetprop with -n option)
... -> boot
  class_start core
    start-service logd, console, vold, etc.
  class_start main
    start-service adb, netd (iptables), zygote, etc.

2. kernel2user init (rom animation on screen, start by service bootanim)
*execute general scripts in service.d/
*execute module scripts service.sh
*set props for resetprop without -p option
  **(Zygisk) hook zygote (start zygiskd)
  **(Zygisk) mount zygisksu/module.prop
start system apps (autostart)
...
boot complete (broadcast ACTION_BOOT_COMPLETED event)
*execute general scripts in boot-completed.d/
*execute module scripts boot-completed.sh

3. User operable (lock screen)
input password to decrypt /data/data
*actual set props for resetprop with -p option
start user apps (autostart)
```

如果你对 Android 的 init 语言感兴趣，推荐阅读[文档](https://android.googlesource.com/platform/system/core/+/master/init/README.md)。

```

`website/docs/zh_CN/guide/rescue-from-bootloop.md`:

```md
# 救砖 {#intruduction}

在刷机的时候我们可能会遇到设备“变砖”的情况，理论上讲，如果你只是使用 fastboot 刷入 boot 分区或者安装不合适的模块导致设备无法启动，那么这都可以通过合适的操作恢复手机；本文档旨在提供一些急救方法让你可以在“变砖”中恢复。

## 刷入 boot 变砖

在 KernelSU 中，刷入 boot 变砖有如下可能：

1. 你刷入了错误格式的 boot 镜像。比如你的手机 boot 格式是 `gz` 的，但你刷入了 `lz4` 格式的镜像，那么此时手机无法启动。
2. 你的手机需要关闭 avb 验证才能正常启动（注意这通常意味着需要清除手机所有数据）。
3. 你的 kernel 有某些 bug 或者你的 kernel 不适合你这个手机刷入。

无论哪种情况，你都可以通过**刷入原厂 boot**恢复；因此，在安装教程最开始，我们已经强烈建议大家，在刷机之前备份自己的原厂 boot！如果你没有备份，那么你可以通过其他跟你相同设备的童鞋或者官方固件包获取原厂 boot。

## 刷入模块变砖

刷入模块变砖可能是大家遇到更常见的情况，但是这里必须郑重告诉大家：**请勿刷入来路不明的模块！！**。因为模块其实是有 root 权限的，它完全可能导致你的设备发生不可逆的损坏！

### 普通模块变砖

如果大家刷入某些开源的或者被证明是安全的模块使得手机无法启动，那么这种情况在 KernelSU 中非常容易恢复，完全无需担心。KernelSU 内置了如下两种机制来救砖：

1. AB 更新
2. 音量键救砖

#### AB 更新 {#ab-update}

KernelSU 的模块更新借鉴了 Android 系统 OTA 更新时的 AB 更新机制，如果你安装了新模块或者对已有模块有更新操作，不会直接操作当前使用的模块文件，而是会把所有模块构建成另外一个 update 镜像；系统重启之后，会使用这个 update 镜像尝试启动一次，如果 Android 系统成功启动，才会真正更新模块。

因此，最简单最常用的救砖方法就是：**强制重启一次**。如果你在刷某个模块之后系统无法启动，你可以长按电源键超过 10 秒，系统会自动重启；重启之后会回滚到更新模块之前的状态，之前更新的模块会被自动禁用。

#### 音量键救砖 {#volume-down}

如果 AB 更新依然无法解决，你可以尝试使用**安全模式**。进入安全模式之后，所有的模块都会被禁用。

进入安全模式的方法有两种：

1. 某些系统自带的安全模式；有些系统是长按音量下，有些系统（比如MIUI）可以在 Recovery 中开启安全模式。进入系统的安全模式后，KernelSU 也会进入安全模式，自动禁用模块。
2. KernelSU 内置的安全模式；操作方法：开机第一屏后，**连续按音量下键超过三次**。注意是按下-松开、按下-松开、按下-松开，不是按着不动。

进入安全模式以后，KernelSU 管理器的模块页面所有模块都被禁用，但你可以执行“卸载”操作，卸载可能会有问题的模块。

内置的安全模式是在内核里面实现的，因此不会出现按键事件被拦截导致捕获不到的情况。不过对于非 GKI 内核，可能需要手动集成代码，可以参考官网教程。

### 格机或其他病毒模块变砖

如果以上方法无法拯救你的设备，那么很有可能你装的模块有恶意操作或者通过其他方式损坏了你的设备，这种情况下，只有两个建议：

1. 清除数据后刷入完整刷入官方系统。
2. 咨询售后服务。

```

`website/docs/zh_CN/guide/unofficially-support-devices.md`:

```md
# 非官方支持设备

::: warning
该文档仅供存档参考，不再维护更新。
自 KernelSU v1.0 版本之后，我们放弃了对非 GKI 设备的官方支持。
:::

::: warning
本文档列出由其他开发者维护的支持 KernelSU 的非 GKI 设备内核
:::

::: warning
本文档仅方便查找设备对应源码，这并不意味该源码**被** KernelSU 开发者**审查**，你应自行承担使用风险。
:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>维护者</th>
         <th>仓库地址</th>
         <th>支持设备</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>
```

`website/docs/zh_CN/guide/what-is-kernelsu.md`:

```md
# 什么是 KernelSU？ {#introduction}

KernelSU 是 Android GKI 设备的 root 解决方案，它工作在内核模式，并直接在内核空间中为用户空间应用程序授予 root 权限。

## 功能 {#features}

KernelSU 的主要特点是它是**基于内核的**。KernelSU 运行在内核空间，所以它可以提供我们以前从未有过的内核接口。例如，我们可以在内核模式下为任何进程添加硬件断点；我们可以在任何进程的物理内存中访问，而无人知晓；我们可以在内核空间拦截任何系统调用; 等等。

此外，KernelSU 提供了 [metamodule 系统](metamodule.md)，这是一个可插拔的模块管理架构。与将挂载逻辑内置到核心的传统 root 方案不同，KernelSU 将此功能委托给 metamodule。这允许您安装 [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs) 等 metamodule，以提供对 `/system` 分区和其他分区的无系统修改。

## 如何使用 {#how-to-use}

请参考: [安装](installation)

## 如何构建 {#how-to-build}

请参考: [如何构建](how-to-build)

## 讨论 {#discussion}

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/zh_CN/index.md`:

```md
---
layout: home
title: Android 上的内核级的 root 方案

hero:
  name: KernelSU
  text: Android 上的内核级的 root 方案
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: 开始了解
      link: /zh_CN/guide/what-is-kernelsu
    - theme: alt
      text: 在 GitHub 中查看
      link: https://github.com/tiann/KernelSU

features:
  - title: 基于内核
    details: KernelSU 运行在内核空间，对用户空间应用有更强的掌控。
  - title: 白名单访问控制
    details: 只有被授权的 App 才可以访问 `su`，而其他 App 无法感知其存在。
  - title: 受限制的 root 权限
    details: KernelSU 可以自定义 `su` 的 uid, gid, groups, capabilities 和 SELinux 规则：把 root 权限关进笼子里。
  - title: Metamodule 模块系统
    details: 可插拔的模块基础架构，支持无系统修改。安装 meta-overlayfs 等 metamodule 来启用模块挂载。


```

`website/docs/zh_TW/guide/app-profile.md`:

```md
# App Profile {#app-profile}

App Profile 是 KernelSU 提供的一種針對各種應用程式自訂其使用配置的機制。

對於授予了 root 權限（即可以使用 `su`）的應用程式來說，App Profile 也可以稱為 Root Profile，它可以自訂 `su` 的 `uid`、`gid`、`groups`、` capabilities` 以及 `SELinux context` 規則，從而限制 root 使用者的權限。
例如可以針對防火牆應用程式僅授予網路權限，而不授予檔案存取權限，針對凍結類別應用程式僅授予 shell 權限而不是直接給 root ；透過最小化權限原則**把權力關進籠子裡**。

對於沒有被授予 root 權限的普通應用，App Profile 可以控制核心以及模組系統對此應用的行為；例如是否需要針對此應用程式卸載模組造成的修改等。核心和模組系統可以透過此配置決定是否要做一些類似「隱藏痕跡」類別的操作。

## Root Profile {#root-profile}

### UID、GID 和 groups {#uid-gid-and-groups}

Linux 系統中有使用者和群組兩個概念。每個使用者都有一個使用者 ID(UID)，一個使用者可以屬於多個群組，每個群組也有群組 ID(GID)。此 ID 用於識別系統的使用者並確定使用者可以存取哪些系統資源。

UID 為 0 的使用者稱為 root 使用者，GID 為 0 的群組稱為 root 群組；root 使用者群組通常擁有系統的最高權限。

對於 Android 系統來說，每個應用程式都是一個單獨的使用者（不考慮 share uid 的情況），擁有一個唯一的 UID。例如 `0` 是 root 使用者，`1000` 是 `system`，`2000` 是 ADB shell，10000-19999 的是一般使用者。

:::info 補充
此處的 UID 跟 Android 系統的多使用者，或者說工作資料（Work Profile），是不同概念。工作資料實際上是對 UID 進行分片實現的，例如 10000-19999 是主使用者，110000-119999 是工作資料；他們中的任何一個普通應用都擁有自己獨有的 UID。
:::

每一個應用程式可以有若干個群組，GID 是其主要的群組，通常與 UID 一致；其他的群組稱為補充群組(groups)。某些權限是透過群組控制的，例如網路訪問，藍牙等。

例如，如果我們在 ADB shell 中執行 `id` 指令，會得到以下輸出：

```sh
oriole:/ $ id
uid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_ww) (ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readreadtracefs:s05:
```

其中，UID 為`2000`，GID 也即主要組 ID 也為 `2000`；除此之外它還在許多補充組裡面，例如 `inet` 組代表可以創建 `AF_INET` 和 `AF_INET6` 的 socket（存取網路），`sdcard_rw` 代表可以讀寫 sdcard 等。

KernelSU 的 Root Profile 可以自訂執行 `su` 後 root 程式的 UID, GID 和 groups。例如，你可以設定某個 root 應用程式的Root Profile 其UID 為`2000`，這表示此應用程式在使用`su` 的時候，它的實際權限是ADB Shell 等級；你可以去掉groups 中的`inet` ，這樣這個`su` 就無法存取網路。

:::tip 注意
App Profile 只是控制 root 應用程式使用 `su` 後的權限，它並非控制應用程式本身的權限！如果應用程式本身申請了網路存取權限，那麼它即使不使用 `su` 也可以存取網路；為 `su` 去掉 `inet` 群組只是讓 `su` 無法存取網路。
:::

與應用程式透過 `su` 主動切換使用者或群組不同，Root Profile 是在核心中強制實施的，不依賴 root 應用程式的自覺行為，`su` 權限的授予完全取決於使用者而非開發者。

### Capabilities {#capabilities}

Capabilities 是 Linux 的一種分權機制。

傳統的 UNIX 系統為了執行權限檢查，將流程分為兩類：特權程式（其等效使用者 ID 為 0，稱為超級使用者或 root）和非特權程式（其等效 UID 為非零）。特權程式會繞過所有核心權限檢查，而非特權程式則根據其憑證（通常是等校 UID、等效 GID 和補充群組清單）進行完整的權限檢查。

從 Linux 2.2開始，Linux 將傳統上與超級使用者關聯的特權分解為獨立的單元，稱為 Capabilities（有的也翻譯為「權能」），它們可以獨立啟用和停用。

每一個 Capability 代表一個或一類權限。例如 `CAP_DAC_READ_SEARCH` 就代表是否有能力繞過檔案讀取權限檢查和目錄讀取和執行權限檢查。如果一個有效 UID 為 `0` 的使用者（root 使用者）沒有 `CAP_DAC_READ_SEARCH` 或更高 Capalities，這表示即使它是 root 也不能​​隨意讀取檔案。

KernelSU 的 Root Profile 可以自訂執行 `su` 後 root 程式的 Capabilities，從而實現只授予「部分 root 權限」。與上面介紹的UID, GID 不同，某些 root 應用就是需要 `su` 後 UID 是 `0`，此時我們可以透過限制這個 UID 為 `0` 的 root 使用者的 Capabilities，就可以限制它能夠執行的操作。

:::tip 強烈建議
Linux 的 Capability [官方文件](https://man7.org/linux/man-pages/man7/capabilities.7.html)詳細解釋了每一項 Capability 所代表的能力，如果你想要自訂Capabilities，請務必先閱讀此文件。
:::

### SELinux {#selinux}

SELinux 是一種強大的強制權限存取控制（MAC）機制。它按照**預設拒絕**的原則運作：任何未經明確允許的行為都會被拒絕。

SELinux 可依兩種全域模式運作：

1. 寬容模式：權限拒絕事件會被記錄下來，但不會被強制執行。
2. 強制模式：權限拒絕事件會被記錄下來**並且**強制執行。

:::warning 警告
現代的 Android 系統極度依賴 SELinux 來保障整個系統的安全性，我們強烈建議您不要使用任何以「寬容模式」運作的自訂系統，因為那樣與裸奔沒什麼區別。
:::

SELinux 的完整概念比較複雜，我們這裡不打算講解它的具體運作方式，建議你先透過以下資料來了解其運作原理：

1. [wikipedia](https://en.wikipedia.org/wiki/Security-Enhanced_Linux)
2. [Redhat: what-is-selinux](https://www.redhat.com/en/topics/linux/what-is-selinux)
3. [ArchLinux: SELinux](https://wiki.archlinux.org/title/SELinux)

KernelSU 的 Root Profile 可以自訂執行 `su` 後 root 程式的 SELinux context，並且可以針對這個 context 設定特定的存取控制規則，從而更精細地控制 root 權限。

通常情況下，應用程式執行 `su` 後，會將進程切換到一個**不受任何限制** 的 SELinux 域，例如`u:r:su:s0`，透過 Root Profile，我們可以將它切換到一個自訂的作用域，例如 `u:r:app1:s0`，然後為這個作用域制定一系列規則：

```sh
type app1
enforce app1
typeattribute app1 mlstrustedsubject
allow app1 * * *
```

注意：此處的 `allow app1 * * *` 僅僅作為示範方便而使用，實際過程中不應使用這個規則，因為它跟寬容模式區別不大。

### 逃逸 {#escalation}

如果 Root Profile 的配置不合理，那麼可能會發生逃逸的情況：Root Profile 的限制會意外失效。

例如，如果你為ADB shell 使用者設定允許root 權限（這是相當常見的情況）；然後你給某個普通應用程式允許 root 權限，但是配置它的 root profile 中的 UID 為 2000（ADB shell 使用者的UID）；那麼此時，這個 App 可以透過執行兩次 `su` 來獲得完整的root 權限：

1. 第一次執行 `su`，由於 App Profile 強制生效，會正常切換到 UID 為 `2000` (adb shell) 而非 `0` (root)。
2. 第二次執行 `su`，由於此時它 UID 是 `2000`，而你給 `2000` (adb shell) 配置了允許 root，它會獲得完整的 root 權限！

:::warning 注意
這是完全符合預期的行為，並非 BUG！因此我們建議：

如果你的確需要給 adb 授予 root 權限（例如你是開發者），那麼不建議你在配置 Root Profile 的時候將 UID 改成 `2000`，用 `1000` (system) 會更好。
:::

## Non Root Profile {#non-root-profile}

### 卸載模組 {#umount-modules}

KernelSU 提供了一種無須直接修改系統分區的方式 (systemless) 來修改系統分區，這是透過掛載 overlayfs 來實現的。但有些情況下，App 可能會對這種行為比較敏感；因此，我們可以透過設定「卸載模組」來卸載掛載在這些應用程式上的模組。

另外，KernelSU 管理器的設定介面還提供了一個「預設卸載模組」的開關，這個開關預設是**開啟**的，這表示**如果不對應用程式做額外的設定**，預設情況下 KernelSU 或某些模組會對此應用程式執行卸載操作。當然，如果你不喜歡這個設定或這個設定會影響某些 App，你可以有以下選擇：

1. 保持「預設卸載模組」的開關，然後針對不需要「卸載模組」的應用程式進行單獨的設置，在 App Profile 中關閉「卸載模組」；（相當於「白名單」）。
2. 關閉「預設卸載模組」的開關，然後針對需要「卸載模組」的應用程式進行單獨的設置，在 App Profile 中開啟「卸載模組」；（相當於「黑名單」）。

:::info 提示
KernelSU 在 5.10 及以上內核上，內核無須任何修改就可以卸載模組；但在 5.10 以下的設備上，這個開關僅僅是一個"設定"，KernelSU 本身不會做任何動作，如果你希望在 5.10 以前的內核可以卸載模組，你需要將 `path_unmount` 函數向後移植到 `fs/namespace.c`，您可以在[如何為非 GKI 核心整合 KernelSU](how-to-integrate-for-non-gki.md#how-to-backport-path_unpount)獲取更多資訊。一些模組（如 ZygiskNext）也會透過這個設定決定是否需要卸載。
:::
```

`website/docs/zh_TW/guide/difference-with-magisk.md`:

```md
# KernelSU 與 Magisk 的差異 {#difference-with-magisk}

儘管 KernelSU 模組和 Magisk 模組之間有許多相似之處，但由於它們完全不同的實作機制，不可避免地存在一些差異；如果您想讓您的模組同時在 Magisk 和 KernelSU 上運作，那麼您必須瞭解這些差異。

## 相同之處 {#similarities}

- 模組檔案格式：都以 Zip 的格式組織模組，並且模組的格式幾乎相同
- 模組安裝目錄：都位於 `/data/adb/modules`
- 無系統修改：都支援透過模組以無系統修改的方式來更改 `/system`
- `post-fs-data.sh`：執行階段和語義完全相同
- `service.sh`：執行階段和語義完全相同
- `system.prop`：完全相同
- `sepolicy.rule`：完全相同
- BusyBox：指令碼在 BusyBox 中以「獨立模式」執行

## 不同之處 {#differences}

在瞭解不同之處之前，您需要知道如何區分您的模組是在 KernelSU 還是 Magisk 中執行；在所有可以執行模組指令碼的位置 (`customize.sh`, `post-fs-data.sh`, `service.sh`)，您都可以使用環境變數 `KSU` 來區分，在 KernelSU 中，這個環境變數將被設定為 `true`。

以下是一些不同之處：

1. KernelSU 的模組無法在 Recovery 中安裝。
2. KernelSU 的模組沒有內建的 Zygisk 支援 (但您可以透過 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 來使用 Zygisk 模組)。
3. **模組掛載架構**：KernelSU 使用 [metamodule 系統](metamodule.md)，將掛載委託給可插拔的 metamodule(例如 `meta-overlayfs`)，而 Magisk 將掛載內建於其核心中。KernelSU 需要安裝 metamodule 才能啟用模組掛載。
4. KernelSU 模組取代或刪除檔案與 Magisk 完全不同。KernelSU 不支援 `.replace` 方法，相反，您需要透過 `mknod filename c 0 0` 建立相同名稱的資料夾以刪除對應檔案。
5. BusyBox 的目錄不同。KernelSU 內建的 BusyBox 在 `/data/adb/ksu/bin/busybox`，而 Magisk 在 `/data/adb/magisk/busybox`。**注意此為 KernelSU 內部行為，未來可能會變更！**
6. KernelSU 不支援 `.replace` 檔案；但 KernelSU 支援 `REPLACE` 和 `REMOVE` 變數以移除或取代檔案與資料夾。
7. KernelSU 新增了 `boot-completed.sh` 腳本，以便在 Android 系統啟動完成後執行某些任務。
8. KernelSU 新增了 `post-mount.sh` 腳本，以便在模組掛載完成後執行某些任務。

```

`website/docs/zh_TW/guide/faq.md`:

```md
# 常見問題

## KernelSU 是否支援我的裝置？

首先，您的裝置應該能解鎖 Bootloader。如果不能，則不支援。

然後在您的裝置上安裝 KernelSU 管理員並開啟它，如果它顯示 `不支援`，那麼您的裝置沒有官方支援的開箱即用的 Boot 映像；但您可以自行建置核心來源並整合 KernelSU 以繼續使用。

## KernelSU 是否需要解鎖 Bootloader？

當然需要。

## KernelSU 是否支援模組？

支援，大多數 Magisk 模組都可以在 KernelSU 上運作。但是，如果您的模組需要修改 `/system` 檔案，您需要安裝 [metamodule](metamodule.md)(如 `meta-overlayfs`)。其他模組功能無需 metamodule 即可運作。請參閱 [模組指南](module.md) 以獲取更多資訊。

## KernelSU 是否支援 Xposed ？

支援。[Dreamland](https://github.com/canyie/Dreamland) 和 [TaiChi](https://taichi.cool) 可以正常運作。LSPosed 可以在 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 的支援下正常運作。

## KernelSU 支援 Zygisk 嗎？

KernelSU 沒有內建 Zygisk 支援，但是您可以用 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 來使用 Zygisk 模組。

## KernelSU 與 Magisk 相容嗎？

KernelSU 的模組系統與 Magisk 的 magic mount 存在衝突，如果在 KernelSU 中啟用了任何模組，那麼整個 Magisk 將無法正常運作。

但是如果您只使用 KernelSU 的 `su`，那么它會和 Magisk 一同運作：KernelSU 修改 `kernel`、Magisk 修改 `ramdisk`，它們可以搭配使用。

## KernelSU 会取代 Magisk 嗎？

我們不這樣認為，這也不是我們的目標。Magisk 對於使用者空間 Root 解決方案來說已經足夠優秀了，它會存在很長一段時間。KernelSU 的目標是為使用者提供核心介面，而非取代 Magisk。

## KernelSU 可以支援非 GKI 裝置嗎？

可以。但是您應該下載核心來源並整合 KernelSU 至來源樹狀結構並自行編譯核心。

## KernelSU 支援 Android 12 以下的裝置嗎？

影響 KernelSU 相容性的是裝置的核心版本，它與 Android 版本並無直接關係。唯一有關聯的是：**原廠** Android 12 的裝置，一定是 5.10 或更高的核心 (GKI 裝置)；因此結論如下：

1. 原廠 Android 12 的裝置必定支援 (GKI 裝置)
2. 舊版核心的裝置 (即使是 Android 12，也可能是舊版核心) 是相容的 (您需要自行建置核心)

## KernelSU 可以支援舊版核心嗎？

可以，目前最低支援到 4.14；更低的版本您需要手動移植它，歡迎 PR！

## 如何為舊版核心整合 KernelSU？

請參閱[指南](how-to-integrate-for-non-gki.md)

## 為何我的 Android 版本為 13，但核心版本卻是 "android12-5.10"？

核心版本與 Android 版本無關，如果您要使用 KernelSU，請一律使用**核心版本**而非 Android 版本，如果你為 "android12-5.10" 的裝置寫入 Android 13 的核心，等候您的將會是開機迴圈。

## 我是 GKI1.0，能用 KernelSU 嗎？

GKI1 與 GKI2 完全不同，所以您需要自行編譯核心。

## KernelSU 支援 --mount-master/全域掛接命名空間嗎？

目前沒有 (未來可能會支援)，但實際上有很多種方法手動進入全域命名空間，無需 `su` 內建支援，比如：

1. `nsenter -t 1 -m sh` 可以取得一個全域 mount namespace 的 shell.
2. 在您要執行的命令前新增 `nsenter --mount=/proc/1/ns/mnt` 即可使此命令在全域 mount namespace 下執行。KernelSU 本身也使用了 [這種方法](https://github.com/tiann/KernelSU/blob/77056a710073d7a5f7ee38f9e77c9fd0b3256576/manager/app/src/main/java/me/weishu/kernelsu/ui/util/KsuCli.kt#L115)

## KernelSU 可以修改 Hosts 嗎？ 我要怎麼使用 AdAway？
當然。但是 KernelSU 沒有內建的 Hosts 支持，您可以安裝 [systemless-hosts](https://github.com/symbuzzer/systemless-hosts-KernelSU-module) 來做到這一點。

## 為什麼全新安裝後模組不工作？

如果您的模組需要修改 `/system` 檔案，您需要安裝 [metamodule](metamodule.md) 來掛載 `system` 目錄。其他模組功能(腳本、sepolicy、system.prop)無需 metamodule 即可運作。

**解決方案**：參閱 [Metamodule 指南](metamodule.md) 獲取安裝說明。

## 什麼是 metamodule，為什麼需要它？

Metamodule 是一個特殊模組，為掛載常規模組提供基礎架構。請參閱 [Metamodule 指南](metamodule.md) 獲取完整說明。

```

`website/docs/zh_TW/guide/hidden-features.md`:

```md
# 隱藏功能 {#hidden-features}

## .ksurc

預設狀況下，`/system/bin/sh` 會載入 `/system/etc/mkshrc`。

可以透過建立 `/data/adb/ksu/.ksurc` 檔案來讓 `su` 載入此檔案而非 `/system/etc/mkshrc`。
```

`website/docs/zh_TW/guide/how-to-build.md`:

```md
# 如何建置 KernelSU? {#how-to-build-kernelsu}

::: warning
該文件僅供存檔參考，不再維護更新。
自 KernelSU v3.0 版本之後，為了更快的迭代和建置速度，我們放棄了對 GKI 映像模式的官方支援。推薦使用 `Ylarod/ddk` 建置 LKM 使用。
:::

首先,您需要閱讀核心建置的 Android 官方文件：

1. [建置核心](https://source.android.com/docs/setup/build/building-kernels)
2. [標準核心映像 (GKI) 發行組建](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)

::: warning 警告
此文件適用於 GKI 裝置，如果您是舊版核心，請參閱[如何為非 GKI 裝置整合 KernelSU](how-to-integrate-for-non-gki)
:::

## 建置核心 {#build-kernel}

### 同步核心原始碼 {#sync-the-kernel-source-code}

```sh
repo init -u https://android.googlesource.com/kernel/manifest
mv <kernel_manifest.xml> .repo/manifests
repo init -m manifest.xml
repo sync
```

`<kernel_manifest.xml>` 是一個可以唯一確定組建的資訊清單，您可以使用這個資訊清單進行可重新預測的組建。您需要從[標準核心映像 (GKI) 發行組建](https://source.android.com/docs/core/architecture/kernel/gki-release-builds)下載資訊清單。

### 建置 {#build}

請先查看[官方文件](https://source.android.com/docs/setup/build/building-kernels)。

例如，我們需要建置 aarch64 核心映像：

```sh
LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh
```

不要忘記新增 `LTO=thin`，否則，如果您的電腦記憶體小於 24GB，建置可能會失敗。

從 Android 13 開始，核心使用 `bazel` 建置：

```sh
tools/bazel build --config=fast //common:kernel_aarch64_dist
```

:::info 你可能需要知道...
對於某些 Android 14 核心，要使 Wi-Fi/藍牙正常工作，可能需要刪除所有受 GKI 保護的匯出：

```sh
rm common/android/abi_gki_protected_exports_*
```
:::

## 與 KernelSU 一起建置核心 {#build-kernel-with-kernelsu}

如果您可以成功建置核心，那麼建置 KernelSU 就會非常輕鬆，依自己的需求在核心原始碼根目錄中執行以下任一命令：

::: code-group

```sh[最新 tag (穩定版本)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -
```

```sh[main 分支 (開發版本)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
```

```sh[選取 tag (例如 v0.5.2)]
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.5.2
```

:::

然後重新建置核心，您將會得到一個帶有 KernelSU 的核心映像！

```

`website/docs/zh_TW/guide/how-to-integrate-for-non-gki.md`:

```md
# 如何為非 GKI 核心整合 KernelSU {#how-to-integrate-kernelsu-for-non-gki-kernels}

::: warning
該文件僅供存檔參考，不再維護更新。
自 KernelSU v1.0 版本之後，我們放棄了對非 GKI 裝置的官方支援。
:::

KernelSU 可以被整合到非 GKI 核心中，現在它最低支援到核心 4.14 版本；理論上也可以支援更低的版本。

由於非 GKI 核心的片段化極其嚴重，因此通常沒有統一的方法來建置它，所以我們也無法為非 GKI 裝置提供 Boot 映像。但您完全可以自行整合 KernelSU 並建置核心以繼續使用。

首先，您必須有能力從您裝置的核心原始碼建置出一個可以開機並且能夠正常使用的核心，如果核心並非開放原始碼，這通常難以做到。

如果您已經做好了上述準備，那有兩個方法來將 KernelSU 整合至您的核心之中。

1. 藉助 `kprobe` 自動整合
2. 手動修改核心原始碼

## 使用 kprobe 整合 {#integrate-with-kprobe}

KernelSU 使用 kprobe 機制來處理核心的相關 hook，如果 *kprobe* 可以在您建置的核心中正常運作，那麼建議使用這個方法進行整合。

首先，把 KernelSU 新增至您的核心來源樹狀結構，再核心的根目錄執行以下命令：

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```

:::info 公告
[KernelSU 1.0 及更新版本不再支援非 GKI 核心](https://github.com/tiann/KernelSU/issues/1705)。最後一個支援的版本為 `v0.9.5`，請確保使用的版本正確。
:::

然後，您需要檢查您的核心是否啟用 *kprobe*，如果未啟用，則需要新增以下設定：

```
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
```

最後，重新建置您的核心即可。

如果您發現 KPROBES 仍未生效，很有可能是因為它依賴的 `CONFIG_MODULES` 並未被啟用，如果還是未生效請輸入 `make menuconfig` 搜尋 KPROBES 的其他相依性並啟用。

如果您在整合 KernelSU 之後手機無法啟動，那麼很可能您的核心中 **kprobe 無法正常運作**，您需要修正這個錯誤，或者使用第二種方法。

:::tip 如何檢查 kprobe 是否損毀？

將 `KernelSU/kernel/ksu.c` 中的 `ksu_sucompat_init()` 和 `ksu_ksud_init()` 註解掉，如果正常開機，即 kprobe 已損毀；或者您可以手動嘗試使用 kprobe 功能，如果不正常，手機會直接重新啟動。
:::

:::info 如何為非 GKI 核心啟用卸載模組功能

如果你的內核版本小於 5.10，你應該將 `path_umount` 向後移植至 `fs/namespace.c`。卸載模組功能依賴於這個函數。如果你沒有向後移植 `path_umount`，卸載模組功能將無法工作。你可以在[這裡查看更多關於 `path_unmount` 的資料](#how-to-backport-path_unpount)。 
:::

## 手動修改核心原始碼 {#manually-modify-the-kernel-source}

如果 kprobe 無法正常運作 (在4.8之前可能是上游或核心的錯誤)，那您可以嘗試這種方法：

首先，將 KernelSU 新增至您的原始碼樹狀結構，在核心的根目錄執行以下命令：

```sh
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
```
請記住，在某些裝置上，您的 `defconfig` 可能位於 `arch/arm64/configs` 中，或在其他情況下位於 `arch/arm64/configs/vendor/你的defconfig` 中。無論您使用哪個 `defconfig`，請確保使用 `CONFIG_KSU=y` 啟用KernelSU，或使用 `n` 停用它。例如，如果您選擇啟用它，則 `defconfig` 應包含以下字串：
```conf
# KernelSU
CONFIG_KSU=y
```

然後，手動修改核心原始碼，您可以參閱下方的 patch：

::: code-group

```diff[exec.c]
diff --git a/fs/exec.c b/fs/exec.c
index ac59664eaecf..bdd585e1d2cc 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,
 	return retval;
 }
 
+extern bool ksu_execveat_hook __read_mostly;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *argv, void *envp, int *flags);
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp,
 			      int flags)
 {
+	if (unlikely(ksu_execveat_hook))
+		ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
+	else
+		ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
 	return __do_execve_file(fd, filename, argv, envp, flags, NULL);
 }
```
```diff[open.c]
diff --git a/fs/open.c b/fs/open.c
index 05036d819197..965b84d486b8 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return ksys_fallocate(fd, mode, offset, len);
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *flags);
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
  */
 long do_faccessat(int dfd, const char __user *filename, int mode)
 {
 	const struct cred *old_cred;
 	struct cred *override_cred;
 	struct path path;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```
```diff[read_write.c]
diff --git a/fs/read_write.c b/fs/read_write.c
index 650fc7e0f3a6..55be193913b6 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)
 }
 EXPORT_SYMBOL(kernel_read);
 
+extern bool ksu_vfs_read_hook __read_mostly;
+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
+			size_t *count_ptr, loff_t **pos);
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
 
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
```
```diff[stat.c]
diff --git a/fs/stat.c b/fs/stat.c
index 376543199b5a..82adcef03ecc 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,
 }
 EXPORT_SYMBOL(vfs_statx_fd);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 /**
  * vfs_statx - Get basic and extra attributes by filename
  * @dfd: A file descriptor representing the base dir for a relative filename
@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
 
+	ksu_handle_stat(&dfd, &filename, &flags);
 	if ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
 		return -EINVAL;
```

:::

主要修改四個項目：

1. do_faccessat，通常位於 `fs/open.c`
2. do_execveat_common，通常位於 `fs/exec.c`
3. vfs_read，通常位於 `fs/read_write.c`
4. vfs_statx，通常位於 `fs/stat.c`

如果您的核心沒有 `vfs_statx`，使用 `vfs_fstatat` 將其取代：

```diff
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26..5348b7bb9db2 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 }
 EXPORT_SYMBOL(vfs_fstat);
 
+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+
 int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 		int flag)
 {
@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	int error = -EINVAL;
 	unsigned int lookup_flags = 0;
 
+	ksu_handle_stat(&dfd, &filename, &flag);
+
 	if ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
 		      AT_EMPTY_PATH)) != 0)
 		goto out;
```

對於早於 4.17 的核心，如果沒有 `do_faccessat`，可以直接找到 `faccessat` 系統呼叫的定義並進行修改：

```diff
diff --git a/fs/open.c b/fs/open.c
index 2ff887661237..e758d7db7663 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)
 	return error;
 }
 
+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			        int *flags);
+
 /*
  * access() needs to use the real uid/gid, not the effective uid/gid.
  * We do this by temporarily clearing all FS-related capabilities and
@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	int res;
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 
+	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
```

### 安全模式 {#safe-mode}

若要啟用 KernelSU 內建的安全模式，您還需要修改 `drivers/input/input.c` 中的 `input_handle_event` 方法：

:::tip 小建議
強烈建議啟用此功能，如果遇到開機迴圈，這將會非常有用！
:::

```diff
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 45306f9ef247..815091ebfca4 100755
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,
 	return disposition;
 }
 
+extern bool ksu_input_hook __read_mostly;
+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
+
 static void input_handle_event(struct input_dev *dev,
 			       unsigned int type, unsigned int code, int value)
 {
	int disposition = input_get_disposition(dev, type, code, &value);
+
+	if (unlikely(ksu_input_hook))
+		ksu_handle_input_handle_event(&type, &code, &value);
 
 	if (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)
 		add_input_randomness(type, code, value);
```

:::info 不小心進入安全模式？
如果您使用手動整合且不停用 `CONFIG_KPROBES`，那麼您將可能會在啟動後透過按下音量來減少按鈕來觸發安全模式！因此，如果使用手動集成，您需要停用 `CONFIG_KPROBES` ！
:::

### 無法在終端中執行 `pm` ? {#failed-to-execute-pm-in-terminal}

你應該修改 `fs/devpts/inode.c`，參考:

```diff
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index 32f6f1c68..d69d8eca2 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -602,6 +602,8 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
        return dentry;
 }

+#ifdef CONFIG_KSU
+extern int ksu_handle_devpts(struct inode*);
+#endif
+
 /**
  * devpts_get_priv -- get private data for a slave
  * @pts_inode: inode of the slave
@@ -610,6 +612,7 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)
  */
 void *devpts_get_priv(struct dentry *dentry)
 {
+       #ifdef CONFIG_KSU
+       ksu_handle_devpts(dentry->d_inode);
+       #endif
        if (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)
                return NULL;
        return dentry->d_fsdata;
```

### 如何向後移植 path_umount {#how-to-backport-path_unpount}

你可以透過向後移植 `path_umount` 來讓卸載模組功能在低於 5.10 的非 GKI 核心上運作。你可以參考這個修改:

```diff
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)
 }
 #endif

+static int can_umount(const struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+	if (!may_mount())
+		return -EPERM;
+	if (path->dentry != path->mnt->mnt_root)
+		return -EINVAL;
+	if (!check_mnt(mnt))
+		return -EINVAL;
+	if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+		return -EINVAL;
+	if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
 /*
  * Now umount can handle mount points as well as block devices.
  * This is important for filesystems which use unnamed block devices.
```

最後，再次建置您的核心，KernelSU 將會如期運作。

```

`website/docs/zh_TW/guide/installation.md`:

```md
# 安裝 {#title}

## 檢查您的裝置是否受支援 {#check-if-your-device-is-supported}

從 [GitHub Releases](https://github.com/tiann/KernelSU/releases) 下載 KernelSU 管理器，然後安裝至裝置並開啟：

- 如果顯示「不支援」，則表示您的裝置不支援 KernelSU，您需要自行編譯核心才能繼續使用，KernelSU 官方也永遠不會提供一個您可以寫入的 Boot 映像。
- 如果顯示「未安裝」，那麼 KernelSU 支援您的裝置。

::: info 提示
對於顯示「不支援」的裝置，這裡有一個[非官方支援裝置清單](unofficially-support-devices.md)，您可以使用這個清單裡的核心自行編譯。
:::

## 備份您的原廠 boot.img {#backup-stock-boot-img}

在寫入核心映像前，您必須預先備份您的原廠 boot.img。如果您在後續寫入中出現了任何問題，您都可以透過使用 Fastboot 寫回原廠 Boot 以還原系統。

::: warning 警告
寫入核心映像可能會造成資料遺失，請確保做好這一步再繼續進行下一步作業！！必要時您還可以備份您手機的所有資料。
:::

## 必要知識 {#necessary-knowledge}

### ADB 和 Fastboot {#adb-and-fastboot}

預設狀況下，您將會使用 ADB 和 Fastboot 工具，如果您不知道它們，建議使用搜尋引擎先瞭解相關內容。

### KMI

KMI 全稱 Kernel Module Interface，相同 KMI 的核心版本是**相容的**，這也是 GKI 中「標準」的涵義所在。反之，如果 KMI 不同，那麼這些核心之間無法彼此相容，寫入與您裝置 KMI 不同的核心映像可能會導致無法開機。

具體來講，對於 GKI 的裝置，其核心版本格式應該如下：

```txt
KernelRelease :=
Version.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix
w      .x         .y       -zzz           -k            -something
```

其中，`w.x-zzz-k` 為 KMI 版本。例如，一部裝置核心版本為 `5.10.101-android12-9-g30979850fc20`，那麼它的 KMI 為 `5.10-android12-9`，理論上寫入其他這個 KMI 的核心也能正常開機。

::: tip 補充
請注意，核心版本中的 SubLevel 並非 KMI 的一部分！也就是說 `5.10.101-android12-9-g30979850fc20` 與 `5.10.137-android12-9-g30979850fc20` 的 KMI 相同！
:::

### 安全性修補程式等級 {#security-patch-level}

較新的 Android 裝置可能具有防回滾機制，不允許寫入具有較舊安全性修補程式等級的啟動映像。例如，如果您的裝置核心為 `5.10.101-android12-9-g30979850fc20`，則其安全修補程式等級為 `2023-11`；即使寫入了 KMI 對應的核心，如果安全修補程式等級早於 `2023-11`（例如 `2023-06`），也可能會導致無法開機。

因此，最好使用具有最新安全性修補程式等級的核心來維護與 KMI 的對應關係。

### 核心版本與 Android 版本 {#kernel-version-vs-android-version}

請注意：**核心版本與 Android 版本並不一定相同！**

如果您發現您的核心版本是 `android12-5.10.101`，然而您 Android 系統的版本為 Android 13 或更高，請不要覺得奇怪，因為 Android 系統的版本與 Linux 核心的版本號碼並非一致。Linux 核心的版本號碼一般與**裝置出廠時隨附的 Android 系統的版本一致**，如果後續 Android 系統更新，核心版本一般不會發生變化。如果您需要寫入，**請以核心版本為準！！**

## 安裝簡介 {#introduction}

自 `0.9.0` 版本以後，在 GKI 裝置上，KernelSU 支援兩種運作模式：

1. `GKI`：使用**通用核心鏡像**（GKI）取代掉裝置原有的核心。
2. `LKM`：使用**可載入核心模組**（LKM）的方式載入到裝置核心中，不會替換掉裝置原有的核心。

這兩種方式適用於不同的場景，你可以根據自己的需求選擇。

### GKI 模式 {#gki-mode}

GKI 模式會替換掉裝置原有的核心，使用 KernelSU 提供的通用核心鏡像。 GKI 模式的優點是：

1. 通用型高，適用於大多數裝置；例如開啟了 KNOX 的三星裝置、或是 LKM 模式無法運作的裝置。還有一些冷門的魔改裝置，也只能使用 GKI 模式。
2. 不依賴官方韌體即可使用；不需要等待官方韌體更新，只要 KMI 一致，就可以使用。

### LKM 模式 {#lkm-mode}

LKM 模式不會替換掉裝置原有的核心，而是使用可載入核心模組的方式載入到裝置核心中。 LKM 模式的優點是：

1. 不會取代裝置原有的核心：如果你對裝置原有的核心有特殊需求，或是你希望在使用第三方核心的同時使用 KernelSU，可以使用 LKM 模式。
2. 升級和 OTA 較為方便：升級 KernelSU 時，可以直接在管理器內部安裝，無需再手動寫入；系統 OTA 後，可以直接安裝到第二個槽位，也無需再手動寫入。
3. 適用於一些特殊場景：例如使用臨時 root 權限也可以載入 LKM，由於不需要替換 boot 分區，因此不會觸發 avb，不會使裝置意外變磚。
4. LKM 可以被暫時卸載：如果你暫時想取消 root，可以卸載 LKM，這個過程不需要寫入分區，甚至也不用重啟裝置。如果你想重新取得 root，只需要重啟裝置即可。

:::tip 兩種模式共存
打開管理器後，你可以在首頁看到裝置目前運行的模式。注意 GKI 模式的優先級高於 LKM ，如你既使用 GKI 核心替換掉了原有的核心，又使用 LKM 的方式修補了 GKI 核心，那麼 LKM 會被忽略，裝置將永遠以 GKI 的模式運作。
:::

### 選哪個？ {#which-one}

如果你的裝置是手機，我們建議您優先考慮 LKM 模式。
如果你的裝置是模擬器、WSA 或 Waydroid 等，我們建議您優先考慮 GKI 模式。

## LKM 安裝 {#lkm-installation}

### 取得官方韌體 {#get-the-official-firmware}

使用 LKM 的模式，需要取得官方韌體，然後在官方韌體的基礎上修補；如果你使用的是第三方核心，可以把第三方核心的 boot.img 作為官方韌體。

取得官方韌體的方法有很多，如果你的裝置支援 `fastboot boot`，那麼我們最推薦以及最簡單的方法是使用 `fastboot boot` 臨時啟動 KernelSU 提供的 GKI 核心，並參考[使用管理器](#use-the-manager)安裝。

如果你的裝置不支援 `fastboot boot`，那麼你可能需要手動去下載官方韌體包，然後從中提取 boot。

與 GKI 模式不同，LKM 模式會修改 `ramdisk`，因此在出廠 Android 13 的裝置上，通常它需要修補的是 `init_boot` 分區而非 `boot` 分區；而 GKI 模式則永遠是修改 `boot` 分區。

### 使用管理器 {#use-the-manager}

開啟管理器，點選右上角的安裝圖標，會出現若干個選項：

1. 選擇並修補一個文件：如果你手機目前沒有 root 權限，你可以選擇這個選項，然後選擇你的官方韌體，管理器會自動修補它。你只需要寫入這個修補後的文件，即可永久取得 root 權限。
2. 直接安裝：如果你手機已經 root，你可以選擇這個選項，管理器會自動獲取你的裝置資訊，然後自動修補官方韌體，然後寫入。你可以考慮使用 `fastboot boot` KernelSU 的 GKI 核心來取得臨時 root 安裝管理器，然後再使用這個選項。**這種方式也是 KernelSU 升級最主要的方式**。
3. 安裝到另一個分割區：如果你的裝置支援 A/B 分區，你可以選擇這個選項，管理器會自動修補官方韌體，然後安裝到另一個分區。這種方式適用於 OTA 後的裝置，你可以在 OTA 後直接安裝到另一個分割區，然後重新啟動裝置即可。

### 使用命令列{#use-the-command-line}

如果你不想使用管理器，你也可以使用命令列來安裝 LKM。KernelSU 提供的 `ksud` 可以幫助你快速修補官方韌體，然後寫入。

這個工具支援 macOS、Linux 和 Windows，你可以在 [GitHub Release](https://github.com/tiann/KernelSU/releases) 下載對應的版本。

使用方法：`ksud boot-patch`。 你可以查看命令列的提示了解具體的使用方法。

```sh
husky:/ # ksud boot-patch -h
Patch boot or init_boot images to apply KernelSU

Usage: ksud boot-patch [OPTIONS]

Options:
  -b, --boot <BOOT>              boot image path, if not specified, will try to find the boot image automatically
  -k, --kernel <KERNEL>          kernel image path to replace
  -m, --module <MODULE>          LKM module path to replace, if not specified, will use the builtin one
  -i, --init <INIT>              init to be replaced
  -u, --ota                      will use another slot when boot image is not specified
  -f, --flash                    Flash it to boot partition after patch
  -o, --out <OUT>                output path, if not specified, will use current directory
      --magiskboot <MAGISKBOOT>  magiskboot path, if not specified, will use builtin one
      --kmi <KMI>                KMI version, if specified, will use the specified KMI
  -h, --help                     Print help
```
需要說明的幾個選項：
1. `--magiskboot` 選項可以指定 magiskboot 的路徑，如果不指定，ksud 會在環境變數中尋找。如果你不知道如何取得 magiskboot，可以參考[這裡](#patch-boot-image)。
2. `--kmi` 選項可以指定 `KMI` 版本，如果你的裝置核心名字沒有遵循 KMI 規範，你可以透過這個選項來指定。

最常見的使用方法為：
```sh
ksud boot-patch -b <boot.img> --kmi android13-5.10
```
## GKI 安裝{#gki-mode-installation}
GKI 的安裝方式有以下幾種，各自適用於不同的場景，請依需求選擇：

1. 使用 KernelSU 提供的 boot.img 透過 Fastboot 安裝
2. 使用核心寫入程式 (例如 KernelFlasher) 安裝
3. 使用自訂 Recovery (例如 TWRP) 安裝
4. 手動修補 boot.img 並安裝

## 使用 KernelSU 提供的 boot.img 安裝 {#install-with-boot-img-provided-by-kernelsu}

如果你的裝置的 `boot.img` 使用常見的壓縮格式，你可以直接寫入 KernelSU 提供的 GKI 核心映像，這種方法無需 TWRP，也無需您的手機有 Root 權限；適用於您初次安裝 KernelSU。

### 找到合適的 boot.img {#find-proper-boot-img}

KernelSU 為 GKI 裝置提供了標準 boot.img，您需要將 boot.img 寫入至裝置的 Boot 分區。

您可以從 [GitHub Release](https://github.com/tiann/KernelSU/releases) 下載 boot.img，請注意，您應該使用正確版本的 boot.img。如果你不知道你該下載哪個檔案，請詳細閱讀文檔中的 [KMI](#kmi) 與[安全性修補程式等級](#security-patch-level)。

通常，在相同的 KMI 和安全性修補程式等級下，會存在三種不同格式的啟動檔案。除了核心壓縮格式之外，它們都是相同的。請檢查您原來的 boot.img 的核心壓縮格式。您應該使用正確的格式，例如 `lz4` 、 `gz`，如果你使用了不正確的壓縮格式，你可能會在寫入後無法開機。

::: info 關於 boot.img 的壓縮格式
1. 您可以透過 magiskboot 以取得您的原始 Boot 的壓縮格式。當然，您也可以詢問與您相同型號的其他更有經驗的使用者。另外，核心的壓縮格式通常不會出現變更，如果您使用的某個壓縮格式成功開機，後續可以優先嘗試這個格式。
2. 小米裝置通常 `gz` 或者 **不壓縮**。
3. Pixel 裝置有些特殊，請遵循下方的指示。
:::

### 將 boot.img 寫入至裝置 {#flash-boot-img-to-device}

使用 `adb` 連接您的裝置，然後執行 `adb reboot bootloader` 進入 fastboot 模式，然後使用此命令寫入 KernelSU：

```sh
fastboot flash boot boot.img
```

::: info 提示
如果您的裝置支援 `fastboot boot`，可以先使用 `fastboot boot boot.img` 來嘗試使用 boot.img 開機進入系統，如果出現意外，重新啟動即可開機。
:::

### 重新開機 {#reboot}

寫入完成後，您應該重新啟動您的裝置：

```sh
fastboot reboot
```

## 使用核心寫入程式安裝 {#install-with-kernel-flasher}

先決條件：您的裝置必須已經 Root。例如您已經安裝了 Magisk 並取得 Root 存取權，或者您已經安裝了舊版本的 KernelSU 需升級到其他版本的 KernelSU；如果您的裝置並未 Root，請嘗試其他方法。

步驟：

1. 下載 AnyKernel3 的 Zip 檔。如果你不知道你該下載哪個檔案，請詳細閱讀文檔中的 [KMI](#kmi) 與[安全性修補程式等級](#security-patch-level)。
2. 開啟核心寫入程式提供的 AnyKernel3 Zip 檔案並寫入核心。

如果您先前並未使用過核心寫入應用程式，可以嘗試下面幾個：

1. [Kernel Flasher](https://github.com/capntrips/KernelFlasher/releases)
2. [Franco Kernel Manager](https://play.google.com/store/apps/details?id=com.franco.kernel)
3. [Ex Kernel Manager](https://play.google.com/store/apps/details?id=flar2.exkernelmanager)

P.S. 這種方法在更新 KernelSU 時比較方便，無需電腦即可完成 (注意備份！)。

## 手動修補 boot.img {#patch-boot-image}

對於某些裝置來說，其 boot.img 格式並不是很常見，不屬於 `lz4`，`gz` 和未壓縮；最典型的就是 Pixel，它的 boot.img 格式是 `lz4_legacy` 壓縮，ramdisk 可能是 `gz` 也可能是 `lz4_legacy` 壓縮；此時如果您直接寫入 KernelSU 提供的 boot.img，手機可能無法開機。這時，您可以透過手動修補 boot.img 來完成。

永遠建議使用 `magiskboot` 來修補映像，一般有兩種修補方法：

1. [magiskboot](https://github.com/topjohnwu/Magisk/releases)
2. [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci)

其中，官方的 `magiskboot` 僅能在 Android 上使用，若您想在電腦上完成，可以嘗試第二個選項。

### 準備 {#preparation}

1. 取得您手機的原廠 boot.img，您可以從您的裝置製造商取得，您也可能需要 [payload-dumper-go](https://github.com/ssut/payload-dumper-go)。
2. 下載 KernelSU 提供的與您的裝置 KMI 一致的 AnyKernel3 Zip 檔 (可參閱[使用自訂 Recovery 安裝](#install-with-custom-recovery))。
3. 解壓縮 AnyKernel3 Zip 檔，取得其中的 `Image` 檔，此檔案為具有 KernelSU 的核心。

### 在 Android 上使用 magiskboot {#using-magiskboot-on-Android-devices}

1. 在 Magisk 的 [Release 頁面](https://github.com/topjohnwu/Magisk/releases) 下載最新的 Magisk。
2. 將 `Magisk-*(version).apk` 重新命名為 `Magisk-*.zip` 並解壓縮。
3. 使用 Adb 將 magiskboot 推入至手機：`adb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot`。
4. 使用 Adb 將原廠 boot.img 和 AnyKernel3 中的 Image 推入至手機。
5. adb shell 進入 /data/local/tmp/ 目錄，然後賦予先前推入的檔案可執行權限 `chmod +x magiskboot`。
6. adb shell 進入 /data/local/tmp/ 目錄，執行 `./magiskboot unpack boot.img` 此時會將 `boot.img` 解除封裝，得到一個名為 `kernel` 的檔案，這個檔案是您的原廠核心。
7. 使用 `Image` 取代 `kernel`: `mv -f Image kernel`
8. 執行 `./magiskboot repack boot.img` 重新封裝映像，此時您會得到一個 `new-boot.img` 檔案，透過 Fastboot 將這個檔案寫入至裝置即可。

### 在 Windows/macOS/Linux PC 上使用 magiskboot {#using-magiskboot-on-PC}

1. 在 [magiskboot_build](https://github.com/ookiineko/magiskboot_build/releases/tag/last-ci) 下載對應的 magiskboot。
2. (僅linux)賦予檔案可執行權限 `chmod +x magiskboot`。
3. 執行 `./magiskboot unpack boot.img` 此時會將 `boot.img` 解除封裝，得到一個名為 `kernel` 的檔案，這個檔案是您的原廠核心。
4. 使用 `Image` 取代 `kernel`: `mv -f Image kernel`
5. 執行 `./magiskboot repack boot.img` 重新封裝映像，此時您會得到一個 `new-boot.img` 檔案，透過 Fastboot 將這個檔案寫入至裝置即可。

## 使用自訂 Recovery 安裝 {#install-with-custom-recovery}

先決條件：您的裝置必須有自訂的 Recovery，例如 TWRP。如果沒有或者只有官方 Recovery，請使用其他方法。

步驟：

1. 在 KernelSU 的 [Release 頁面](https://github.com/tiann/KernelSU/releases) 下載與您手機版本相符的以 AnyKernel3 開頭的 Zip 檔；例如，手機核心版本為 `android12-5.10.66`，那麼您應該下載 `AnyKernel3-android12-5.10.66_yyyy-MM.zip` 這個檔案 (其中 `yyyy` 為年份，`MM` 為月份)。
2. 重新開機手機至 TWRP。
3. 使用 Adb 將 AnyKernel3-*.zip 放置到手機 `/sdcard` 然後在 TWRP 圖形使用者介面選擇並安裝；或者您也可以直接 `adb sideload AnyKernel-*.zip` 安裝。

PS. 這種方法適用於任何狀況下的安裝 (不限於初次安裝或後續更新)，只要您用 TWRP 就可以進行作業。

## GKI的其他替代方法 {#other-methods}

其實所有這些安裝方法的主旨只有一個，那就是**將原廠核心取代為 KernelSU 提供的核心**。只要能實現這個目的，就可以安裝，比如以下是其他可行的方法：

1. 首先安裝 Magisk，透過 Magisk 取得 Root 權限後使用核心寫入程式寫入 KernelSU 的 AnyKernel Zip。
2. 使用某些 PC 上的寫入工具組寫入 KernelSU 提供的核心。

但是，如果不起作用，請嘗試 Magiskboot 方法。

## 安裝後：模組支援 {#post-installation}

::: warning 用於系統檔案修改的 METAMODULE
如果您想使用修改 `/system` 檔案的模組，您需要在安裝 KernelSU 後安裝 **metamodule**。僅使用腳本、sepolicy 或 system.prop 的模組無需 metamodule 即可運作。
:::

**若需 `/system` 修改支援**，請參閱 [Metamodule 指南](metamodule.md)以：
- 了解什麼是 metamodule 以及為何需要它
- 安裝官方 `meta-overlayfs` metamodule
- 了解其他 metamodule 選項


```

`website/docs/zh_TW/guide/metamodule.md`:

```md
# 元模組

元模組是 KernelSU 的一項革命性功能,它將關鍵的模組系統能力從核心守護程序轉移到可插拔模組中。這種架構轉變在保持 KernelSU 穩定性和安全性的同時,為模組生態系統釋放了更大的創新潛力。

## 什麼是元模組?

元模組是一種特殊類型的 KernelSU 模組,為模組系統提供核心基礎設施功能。與修改系統檔案的常規模組不同,元模組控制常規模組的*安裝和掛載方式*。

元模組是一種基於外掛的擴充機制,允許完全自訂 KernelSU 的模組管理基礎設施。透過將掛載和安裝邏輯委託給元模組,KernelSU 避免成為脆弱的檢測點,同時支援多樣化的實作策略。

**主要特徵:**

- **基礎設施角色**: 元模組提供常規模組依賴的服務
- **單實例**: 一次只能安裝一個元模組
- **優先執行**: 元模組腳本在常規模組腳本之前執行
- **特殊鉤子**: 提供三個用於安裝、掛載和清理的鉤子腳本

## 為什麼需要元模組?

傳統的 Root 解決方案將掛載邏輯內建在核心中,這使得它們更容易被檢測且難以演進。KernelSU 的元模組架構透過關注點分離解決了這些問題。

**策略優勢:**

- **減少檢測面**: KernelSU 本身不執行掛載,減少了檢測向量
- **穩定性**: 核心守護程序保持穩定,而掛載實作可以不斷演進
- **創新性**: 社群可以開發替代掛載策略,而無需分叉 KernelSU
- **選擇性**: 使用者可以選擇最適合其需求的實作

**掛載靈活性:**

- **無掛載**: 對於僅使用無掛載模組的使用者,完全避免掛載開銷
- **OverlayFS 掛載**: 傳統方法,支援讀寫層(透過 `meta-overlayfs`)
- **魔術掛載**: Magisk 相容掛載,以獲得更好的應用程式相容性
- **自訂實作**: 基於 FUSE 的覆蓋層、自訂 VFS 掛載或全新方法

**超越掛載:**

- **可擴充性**: 新增核心模組支援等功能,無需修改核心 KernelSU
- **模組化**: 獨立於 KernelSU 版本更新實作
- **客製化**: 為特定裝置或用例建立專門的解決方案

::: warning 重要
如果沒有安裝元模組,模組將**不會**被掛載。新安裝的 KernelSU 需要安裝元模組(如 `meta-overlayfs`)才能使模組正常運作。
:::

## 對於使用者

### 安裝元模組

像安裝常規模組一樣安裝元模組:

1. 下載元模組 ZIP 檔案(例如 `meta-overlayfs.zip`)
2. 開啟 KernelSU Manager 應用程式
3. 點擊浮動操作按鈕(➕)
4. 選擇元模組 ZIP 檔案
5. 重新啟動裝置

`meta-overlayfs` 元模組是官方參考實作,提供傳統的基於 overlayfs 的模組掛載,支援 ext4 映像。

### 檢查活動的元模組

您可以在 KernelSU Manager 應用程式的模組頁面中檢視目前活動的元模組。活動的元模組將顯示在模組清單中,並帶有特殊標識。

### 解除安裝元模組

::: danger 警告
解除安裝元模組會影響**所有**模組。移除後,模組將不再被掛載,直到您安裝另一個元模組。
:::

解除安裝步驟:

1. 開啟 KernelSU Manager
2. 在模組清單中找到元模組
3. 點擊解除安裝(您會看到特殊警告)
4. 確認操作
5. 重新啟動裝置

解除安裝後,如果您希望模組繼續運作,應該安裝另一個元模組。

### 單元模組約束

一次只能安裝一個元模組。如果您嘗試安裝第二個元模組,KernelSU 將阻止安裝以避免衝突。

切換元模組的步驟:

1. 解除安裝所有常規模組
2. 解除安裝目前元模組
3. 重新啟動
4. 安裝新元模組
5. 重新安裝常規模組
6. 再次重新啟動

## 對於模組開發者

如果您正在開發常規 KernelSU 模組,您不需要太擔心元模組。只要使用者安裝了相容的元模組(如 `meta-overlayfs`),您的模組就能正常運作。

**您需要知道的:**

- **掛載需要元模組**: 模組中的 `system` 目錄只有在使用者安裝了提供掛載功能的元模組時才會被掛載
- **無需變更程式碼**: 現有模組無需修改即可繼續運作

::: tip
如果您熟悉 Magisk 模組開發,您的模組在安裝元模組後將在 KernelSU 中以相同方式運作,因為它提供了 Magisk 相容的掛載。
:::

## 對於元模組開發者

建立元模組允許您自訂 KernelSU 處理模組安裝、掛載和解除安裝的方式。

### 基本要求

元模組透過 `module.prop` 中的特殊屬性來識別:

```txt
id=my_metamodule
name=My Custom Metamodule
version=1.0
versionCode=1
author=Your Name
description=Custom module mounting implementation
metamodule=1
```

`metamodule=1`(或 `metamodule=true`)屬性將此模組標記為元模組。沒有此屬性,模組將被視為常規模組。

### 檔案結構

元模組結構:

```txt
my_metamodule/
├── module.prop              (必須包含 metamodule=1)
│
│      *** 元模組特定鉤子 ***
├── metamount.sh             (選用: 自訂掛載處理程式)
├── metainstall.sh           (選用: 常規模組的安裝鉤子)
├── metauninstall.sh         (選用: 常規模組的清理鉤子)
│
│      *** 標準模組檔案(全部選用) ***
├── customize.sh             (安裝自訂)
├── post-fs-data.sh          (post-fs-data 階段腳本)
├── service.sh               (late_start service 腳本)
├── boot-completed.sh        (啟動完成腳本)
├── uninstall.sh             (元模組自己的解除安裝腳本)
├── system/                  (無系統修改,如果需要)
└── [任何其他檔案]
```

除了特殊的元模組鉤子外,元模組可以使用所有標準模組功能(生命週期腳本等)。

### 鉤子腳本

元模組可以提供最多三個特殊鉤子腳本:

#### 1. metamount.sh - 掛載處理程式

**目的**: 控制啟動期間模組的掛載方式。

**執行時機**: 在 `post-fs-data` 階段,在任何模組腳本執行之前。

**環境變數:**

- `MODDIR`: 元模組的目錄路徑(例如 `/data/adb/modules/my_metamodule`)
- 所有標準 KernelSU 環境變數

**職責:**

- 以無系統方式掛載所有已啟用的模組
- 檢查 `skip_mount` 標誌
- 處理特定模組的掛載要求

::: danger 關鍵要求
執行掛載操作時,**必須**將來源/裝置名稱設定為 `"KSU"`。這將掛載標識為屬於 KernelSU。

**範例(正確):**

```sh
mount -t overlay -o lowerdir=/lower,upperdir=/upper,workdir=/work KSU /target
```

**對於現代掛載 API**,設定來源字串:

```rust
fsconfig_set_string(fs, "source", "KSU")?;
```

這對於 KernelSU 正確識別和管理其掛載至關重要。
:::

**範例腳本:**

```sh
#!/system/bin/sh
MODDIR="${0%/*}"

# 範例: 簡單的繫結掛載實作
for module in /data/adb/modules/*; do
    if [ -f "$module/disable" ] || [ -f "$module/skip_mount" ]; then
        continue
    fi

    if [ -d "$module/system" ]; then
        # 使用 source=KSU 掛載(必需!)
        mount -o bind,dev=KSU "$module/system" /system
    fi
done
```

#### 2. metainstall.sh - 安裝鉤子

**目的**: 自訂常規模組的安裝方式。

**執行時機**: 在模組安裝期間,檔案提取後但安裝完成前。此腳本被內建安裝程式**引用**(而非執行),類似於 `customize.sh` 的運作方式。

**環境變數和函式:**

此腳本繼承內建 `install.sh` 的所有變數和函式:

- **變數**: `MODPATH`、`TMPDIR`、`ZIPFILE`、`ARCH`、`API`、`IS64BIT`、`KSU`、`KSU_VER`、`KSU_VER_CODE`、`BOOTMODE` 等
- **函式**:
  - `ui_print <msg>` - 向主控台列印訊息
  - `abort <msg>` - 列印錯誤並終止安裝
  - `set_perm <target> <owner> <group> <permission> [context]` - 設定檔案權限
  - `set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]` - 遞迴設定權限
  - `install_module` - 呼叫內建模組安裝程序

**用例:**

- 在內建安裝之前或之後處理模組檔案(準備好後呼叫 `install_module`)
- 移動模組檔案
- 驗證模組相容性
- 設定特殊目錄結構
- 初始化模組特定資源

**注意**: 安裝元模組本身時**不會**呼叫此腳本。

#### 3. metauninstall.sh - 清理鉤子

**目的**: 解除安裝常規模組時清理資源。

**執行時機**: 在模組解除安裝期間,在刪除模組目錄之前。

**環境變數:**

- `MODULE_ID`: 正在解除安裝的模組的 ID

**用例:**

- 處理檔案
- 清理符號連結
- 釋放配置的資源
- 更新內部追蹤

**範例腳本:**

```sh
#!/system/bin/sh
# 解除安裝常規模組時呼叫
MODULE_ID="$1"
IMG_MNT="/data/adb/metamodule/mnt"

# 從映像中刪除模組檔案
if [ -d "$IMG_MNT/$MODULE_ID" ]; then
    rm -rf "$IMG_MNT/$MODULE_ID"
fi
```

### 執行順序

了解啟動執行順序對於元模組開發至關重要:

```txt
post-fs-data 階段:
  1. 執行通用 post-fs-data.d 腳本
  2. 修剪模組,restorecon,載入 sepolicy.rule
  3. 執行元模組的 post-fs-data.sh(如果存在)
  4. 執行常規模組的 post-fs-data.sh
  5. 載入 system.prop
  6. 執行元模組的 metamount.sh
     └─> 以無系統方式掛載所有模組
  7. post-mount.d 階段執行
     - 通用 post-mount.d 腳本
     - 元模組的 post-mount.sh(如果存在)
     - 常規模組的 post-mount.sh

service 階段:
  1. 執行通用 service.d 腳本
  2. 執行元模組的 service.sh(如果存在)
  3. 執行常規模組的 service.sh

boot-completed 階段:
  1. 執行通用 boot-completed.d 腳本
  2. 執行元模組的 boot-completed.sh(如果存在)
  3. 執行常規模組的 boot-completed.sh
```

**要點:**

- `metamount.sh` 在所有 post-fs-data 腳本(元模組和常規模組)**之後**執行
- 元模組生命週期腳本(`post-fs-data.sh`、`service.sh`、`boot-completed.sh`)始終在常規模組腳本之前執行
- `.d` 目錄中的通用腳本在元模組腳本之前執行
- `post-mount` 階段在掛載完成後執行

### 符號連結機制

當安裝元模組時,KernelSU 會建立一個符號連結:

```sh
/data/adb/metamodule -> /data/adb/modules/<metamodule_id>
```

這為存取活動元模組提供了穩定的路徑,無論其 ID 如何。

**好處:**

- 一致的存取路徑
- 輕鬆偵測活動元模組
- 簡化設定

### 真實範例: meta-overlayfs

`meta-overlayfs` 元模組是官方參考實作。它展示了元模組開發的最佳實踐。

#### 架構

`meta-overlayfs` 使用**雙目錄架構**:

1. **中繼資料目錄**: `/data/adb/modules/`
   - 包含 `module.prop`、`disable`、`skip_mount` 標記
   - 啟動期間快速掃描
   - 儲存佔用小

2. **內容目錄**: `/data/adb/metamodule/mnt/`
   - 包含實際模組檔案(system、vendor、product 等)
   - 儲存在 ext4 映像(`modules.img`)中
   - 使用 ext4 功能最佳化空間

#### metamount.sh 實作

以下是 `meta-overlayfs` 如何實作掛載處理程式:

```sh
#!/system/bin/sh
MODDIR="${0%/*}"
IMG_FILE="$MODDIR/modules.img"
MNT_DIR="$MODDIR/mnt"

# 如果尚未掛載,則掛載 ext4 映像
if ! mountpoint -q "$MNT_DIR"; then
    mkdir -p "$MNT_DIR"
    mount -t ext4 -o loop,rw,noatime "$IMG_FILE" "$MNT_DIR"
fi

# 為雙目錄支援設定環境變數
export MODULE_METADATA_DIR="/data/adb/modules"
export MODULE_CONTENT_DIR="$MNT_DIR"

# 執行掛載二進位檔案
# (實際掛載邏輯在 Rust 二進位檔案中)
"$MODDIR/meta-overlayfs"
```

#### 主要特性

**Overlayfs 掛載:**

- 使用核心 overlayfs 進行真正的無系統修改
- 支援多個分割區(system、vendor、product、system_ext、odm、oem)
- 透過 `/data/adb/modules/.rw/` 支援讀寫層

**來源識別:**

```rust
// 來自 meta-overlayfs/src/mount.rs
fsconfig_set_string(fs, "source", "KSU")?;  // 必需!
```

這為所有 overlay 掛載設定 `dev=KSU`,實現正確識別。

### 最佳實踐

開發元模組時:

1. **始終將來源設定為"KSU"**以進行掛載操作 - 核心卸載和 zygisksu 卸載需要此設定才能正確卸載
2. **優雅地處理錯誤** - 啟動程序對時間敏感
3. **尊重標準標誌** - 支援 `skip_mount` 和 `disable`
4. **記錄操作** - 使用 `echo` 或日誌記錄進行除錯
5. **徹底測試** - 掛載錯誤可能導致啟動迴圈
6. **記錄行為** - 清楚地解釋您的元模組做什麼
7. **提供遷移路徑** - 協助使用者從其他解決方案切換

### 測試您的元模組

發布前:

1. 在乾淨的 KernelSU 設定上**測試安裝**
2. **驗證掛載**各種模組類型
3. **檢查相容性**與常見模組
4. **測試解除安裝**和清理
5. **驗證啟動效能**(metamount.sh 是阻塞的!)
6. **確保正確的錯誤處理**以避免啟動迴圈

## 常見問題

### 我需要元模組嗎?

**對於使用者**: 僅當您想使用需要掛載的模組時。如果您只使用執行腳本而不修改系統檔案的模組,則不需要元模組。

**對於模組開發者**: 不需要,您正常開發模組。僅當您的模組需要掛載時,使用者才需要元模組。

**對於進階使用者**: 僅當您想自訂掛載行為或建立替代掛載實作時。

### 我可以有多個元模組嗎?

不可以。一次只能安裝一個元模組。這可以防止衝突並確保可預測的行為。

### 如果我解除安裝了唯一的元模組會怎樣?

模組將不再被掛載。您的裝置將正常啟動,但模組修改將不會套用,直到您安裝另一個元模組。

### meta-overlayfs 是必需的嗎?

不是。它提供與大多數模組相容的標準 overlayfs 掛載。如果您需要不同的行為,可以建立自己的元模組。

## 另請參閱

- [模組指南](module.md) - 通用模組開發
- [與 Magisk 的差異](difference-with-magisk.md) - 比較 KernelSU 和 Magisk
- [如何建置](how-to-build.md) - 從原始碼建置 KernelSU

```

`website/docs/zh_TW/guide/module-config.md`:

```md
# 模組配置

KernelSU 提供了一個內建的配置系統,允許模組儲存持久化或暫時的鍵值設定。配置以二進位格式儲存在 `/data/adb/ksu/module_configs/<module_id>/`,具有以下特性:

## 配置類型

- **持久配置** (`persist.config`):重新開機後保留,直到明確刪除或解除安裝模組
- **暫時配置** (`tmp.config`):在每次啟動時的 post-fs-data 階段自動清除

讀取配置時,對於同一個鍵,暫時值優先於持久值。

## 在模組腳本中使用配置

所有模組腳本(`post-fs-data.sh`、`service.sh`、`boot-completed.sh` 等)執行時都會設定 `KSU_MODULE` 環境變數為模組 ID。您可以使用 `ksud module config` 命令來管理模組的配置:

```bash
# 獲取配置值
value=$(ksud module config get my_setting)

# 設定持久配置值
ksud module config set my_setting "some value"

# 設定暫時配置值(重新開機後清除)
ksud module config set --temp runtime_state "active"

# 列出所有配置項(合併持久和暫時配置)
ksud module config list

# 刪除配置項
ksud module config delete my_setting

# 刪除暫時配置項
ksud module config delete --temp runtime_state

# 清除所有持久配置
ksud module config clear

# 清除所有暫時配置
ksud module config clear --temp

# 從 stdin 設定值(適用於多行或複雜資料)
ksud module config set my_key <<EOF
多行
文字值
EOF

# 或從命令管道輸入
echo "value" | ksud module config set my_key

# 明確使用 stdin 標誌
cat file.json | ksud module config set json_data --stdin
```

## 驗證限制

配置系統強制執行以下限制:

- **最大鍵長度**:256 位元組
- **最大值長度**:1MB (1048576 位元組)
- **最大配置項數**:每個模組 32 個
- **鍵格式**:必須符合 `^[a-zA-Z][a-zA-Z0-9._-]+$`(與模組 ID 相同)
  - 必須以字母(a-zA-Z)開頭
  - 可包含字母、數字、點(`.`)、底線(`_`)或連字號(`-`)
  - 最小長度:2 個字元
- **值格式**:無限制 - 可包含任何 UTF-8 字元,包括換行符、控制字元等
  - 以二進位格式儲存,帶長度前綴,確保安全處理所有資料

## 生命週期

- **啟動時**:所有暫時配置在 post-fs-data 階段清除
- **模組解除安裝時**:所有配置(持久和暫時)自動刪除
- 配置以二進位格式儲存,使用魔數 `0x4b53554d`("KSUM")和版本驗證

## 使用場景

配置系統適用於:

- **使用者偏好**:儲存使用者透過 WebUI 或 action 腳本配置的模組設定
- **功能開關**:在不重新安裝的情況下啟用/停用模組功能
- **執行時狀態**:追蹤應在重新開機時重置的暫時狀態(使用暫時配置)
- **安裝設定**:記住模組安裝時做出的選擇
- **複雜資料**:儲存 JSON、多行文字、Base64 編碼資料或任何結構化內容(最多 1MB)

::: tip 最佳實踐
- 對於應在重新開機後保留的使用者偏好,使用持久配置
- 對於應在啟動時重置的執行時狀態或功能開關,使用暫時配置
- 在腳本中使用配置值之前驗證它們
- 使用 `ksud module config list` 命令偵錯配置問題
:::

## 進階功能

模組配置系統提供了用於進階用例的特殊配置鍵:

### 覆蓋模組描述 {#overriding-module-description}

您可以透過設定 `override.description` 配置鍵來動態覆蓋 `module.prop` 中的 `description` 欄位:

```bash
# 覆蓋模組描述
ksud module config set override.description "在管理器中顯示的自訂描述"
```

當取得模組列表時,如果存在 `override.description` 配置,它將取代 `module.prop` 中的原始描述。這對於以下場景很有用:
- 在模組描述中顯示動態狀態資訊
- 向使用者顯示執行時配置詳情
- 基於模組狀態更新描述而無需重新安裝

### 宣告管理的功能

模組可以使用 `manage.<feature>` 配置模式宣告它們管理的 KernelSU 功能。支援的功能對應於 KernelSU 內部的 `FeatureId` 列舉:

**支援的功能:**
- `su_compat` - SU 相容模式
- `kernel_umount` - 核心自動卸載

```bash
# 宣告此模組管理 SU 相容性並將其啟用
ksud module config set manage.su_compat true

# 宣告此模組管理核心卸載並將其停用
ksud module config set manage.kernel_umount false

# 移除功能管理(模組不再控制此功能)
ksud module config delete manage.su_compat
```

**工作原理:**
- `manage.<feature>` 鍵的存在表示模組正在管理該功能
- 值表示期望的狀態:`true`/`1` 代表啟用,`false`/`0`(或任何其他值)代表停用
- 要停止管理某個功能,請完全刪除該配置鍵

管理的功能透過模組列表 API 以 `managedFeatures` 欄位(逗號分隔的字串)公開。這允許:
- KernelSU 管理器偵測哪些模組管理哪些 KernelSU 功能
- 防止多個模組嘗試管理同一功能時發生衝突
- 更好地協調模組與核心 KernelSU 功能之間的關係

::: warning 僅支援預定義功能
僅使用上面列出的預定義功能名稱(`su_compat`、`kernel_umount`)。這些對應於實際的 KernelSU 內部功能。使用其他功能名稱不會導致錯誤,但沒有任何功能作用。
:::

```

`website/docs/zh_TW/guide/module-webui.md`:

```md
# 模組 WebUI {#module-webui}

KernelSU 的模組除了執行啟動腳本和修改系統檔案之外，還支援顯示 UI 介面和與使用者互動。

該模組可以透過任何 Web 技術編寫 HTML + CSS + JavaScript 頁面。 KernelSU的管理器將透過 WebView 顯示這些頁面。它還提供了一些用於與系統互動的 JavaScript API，例如執行 shell 命令。

## WebUI 根目錄 {#webroot-directory}

Web資源應放置在模組根目錄的 `webroot` 子目錄中，並且其中**必須**有一個名為 `index.html` 的文件，該檔案是模組頁面入口。

包含Web介面的最簡單的模組結構如下：

```txt
❯ tree .
.
|-- module.prop
`-- webroot
    `-- index.html
```

:::warning 提醒
安裝模組時，KernelSU 將自動設定`webroot`的權限和 SELinux context。如果您不知道自己在做什麼，請不要自行設定該目錄的權限！
:::

如果您的頁面包含 CSS 和 JavaScript，您也需要將其放入此目錄中。

## JavaScript API

如果只是一個顯示頁面，那和一般網頁沒有什麼不同。更重要的是，KernelSU 提供了一系列的系統 API，讓您可以實現模組獨特的功能。

KernelSU [在 npm 上發布](https://www.npmjs.com/package/kernelsu)了一個 JavaScript 庫，您可以在網頁的 JavaScript 程式碼中使用它。

例如，您可以執行 shell 命令來取得特定配置或修改屬性：

```JavaScript
import { exec } from 'kernelsu';

const { errno, stdout } = exec("getprop ro.product.model");
```

再例如，你可以讓網頁全螢幕顯示，或是顯示一個 Toast。

[API 文檔](https://www.npmjs.com/package/kernelsu)

如果您發現現有的 API 無法滿足您的需求或使用不方便，歡迎您在[這裡](https://github.com/tiann/KernelSU/issues)給我們建議！

## 一些技巧 {#some-tips}

1. 您可以正常使用 `localStorage` 來儲存一些數據，但解除安裝管理器後，這些數據將會遺失。如果需要持久保存，可以自行將資料寫入某個目錄。
2. 對於簡單的頁面，我建議您使用 [parceljs](https://parceljs.org/) 進行打包。它無須設定，使用非常方便。不過，如果你是前端高手或有自己的喜好，那就選擇你喜歡的吧！

```

`website/docs/zh_TW/guide/module.md`:

```md
# 模組指南 {#module-guide}

KernelSU 提供了一個模組機制，它可以在保持系統分割區完整性的同時達到修改系統分割區的效果；這種機制一般被稱為 systemless (無系統修改)。

KernelSU 的模組運作機制與 Magisk 幾乎相同，如果您熟悉 Magisk 模組的開發，那麼開發 KernelSU 的模組大同小異，您可以跳過下列有關模組的介紹，只需要瞭解 [KernelSU 模組與 Magisk 模組的差異](difference-with-magisk.md)。

::: warning METAMODULE 僅在修改系統檔案時需要
KernelSU 使用 [metamodule](metamodule.md) 架構來掛載 `system` 目錄。**僅當您的模組需要修改 `/system` 檔案時**(透過 `system` 目錄)，您才需要安裝 metamodule(如 [meta-overlayfs](https://github.com/tiann/KernelSU/releases))。其他模組功能如腳本、sepolicy 規則和 system.prop 無需 metamodule 即可運作。
:::

## WebUI

KernelSU 的模組支援顯示互動介面，請參閱 [WebUI 文檔](module-webui.md).

## 模組配置

KernelSU 提供了一個內建的配置系統，允許模組儲存持久化或暫時的鍵值設定。詳情請參閱[模組配置文檔](module-config.md)。

## Busybox

KernelSU 提供了一個完備的 BusyBox 二進位檔案 (包括完整的 SELinux 支援)。可執行檔位於 `/data/adb/ksu/bin/busybox`。
KernelSU 的 BusyBox 支援執行時可切換的 "ASH 獨立模式"。
ASH 獨立模式在執行 BusyBox 時，每個命令都會直接使用 BusyBox 中內建的應用程式，而不論 `PATH` 的設定為何。
例如，`ls`、`rm`、`chmod` 等命令將不會使用 `PATH` 中設定的命令 (在 Android 的狀況下，預設狀況下分別為 `/system/bin/ls`、`/system/bin/rm` 和 `/system/bin/chmod`)，而是直接呼叫 BusyBox 內建的應用程式。
這確保了腳本始終在可預測的環境中執行，並始終具有完整的命令套件，不論它執行在哪個 Android 版本上。
要強制下一個命令不使用 BusyBox，您必須使用完整路徑呼叫可執行檔。

每個基於 KernelSU 上下文的腳本都將在 BusyBox 的獨立模式執行。對於第三方開發人員而言，這包括所有開機腳本和模組安裝腳本。

對於想要在 KernelSU 之外使用這個「獨立模式」功能的使用者，有兩種啟用方法：

1. 將環境變數 `ASH_STANDALONE` 設為 `1`。例如：`ASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>`
2. 使用命令列選項切換：`/data/adb/ksu/bin/busybox sh -o standalone <script>`

為了確保所有後續的 `sh` shell 都在獨立模式下執行，第一種是首選方法 (這也是 KernelSU 和 KernelSU 管理器內部使用的方法)，因為環境變數會被繼承到子執行緒中。

::: tip 與 Magisk 的差異
KernelSU 的 BusyBox 現在是直接使用 Magisk 專案編譯的二進位檔案，**感謝 Magisk！**
因此，您完全不必擔心 BusyBox 腳本與在 Magisk 和 KernelSU 之間的相容性問題，因為它們完全相同！
:::

## KernelSU 模組 {#kernelsu-modules}

KernelSU 模組是一個放置於 `/data/adb/modules` 且滿足下列結構的資料夾：

```txt
/data/adb/modules
├── .
├── .
|
├── $MODID                  <--- 模組的資料夾名稱與模組 ID 相同
│   │
│   │      *** 模組識別 ***
│   │
│   ├── module.prop         <--- 這個檔案儲存與模組相關的中繼資料，例如模組 ID、版本等
│   │
│   │      *** 主要內容 ***
│   │
│   ├── system              <--- 這個資料夾會在 skip_mount 不存在時被掛接至系統
│   │   ├── ...
│   │   ├── ...
│   │   └── ...
│   │
│   │      *** 狀態旗標 ***
│   │
│   ├── skip_mount          <--- 如果這個檔案存在，那麼 KernelSU 將不會掛接您的系統資料夾
│   ├── disable             <--- 如果這個檔案存在，那麼模組將會被停用
│   ├── remove              <--- 如果這個檔案存在，那麼模組將會在下次重新開機時被移除
│   │
│   │      *** 選用檔案 ***
│   │
│   ├── post-fs-data.sh     <--- 這個腳本將會在 post-fs-data 中執行
│   ├── service.sh          <--- 這個腳本將會在 late_start 服務中執行
|   ├── uninstall.sh        <--- 這個腳本將會在 KernelSU 移除模組時執行
│   ├── system.prop         <--- 這個檔案中指定的屬性將會在系統啟動時透過 resetprop 變更
│   ├── sepolicy.rule       <--- 這個檔案中的 SELinux 原則將會在系統開機時載入
│   │
│   │      *** 自動產生的目錄，不要手動建立或修改！ ***
│   │
│   ├── vendor              <--- A symlink to $MODID/system/vendor
│   ├── product             <--- A symlink to $MODID/system/product
│   ├── system_ext          <--- A symlink to $MODID/system/system_ext
│   │
│   │      *** 允許的其他額外檔案/資料夾 ***
│   │
│   ├── ...
│   └── ...
|
├── another_module
│   ├── .
│   └── .
├── .
├── .
```

::: tip 與 Magisk 的差異
KernelSU 沒有內建的針對 Zygisk 的支援，因此模組中沒有與 Zygisk 相關的內容，但您可以透過安裝 [ZygiskNext](https://github.com/Dr-TSNG/ZygiskNext) 以支援 Zygisk 模組，此時 Zygisk 模組的內容與 Magisk 所支援的 Zygisk 完全相同。
:::

### module.prop

module.prop 是一個模組的設定檔，在 KernelSU 中如果模組中不包含這個檔案，那麼它將不被認為是一個模組；這個檔案的格式如下：

```txt
id=<string>
name=<string>
version=<string>
versionCode=<int>
author=<string>
description=<string>
updateJson=<url> (optional)
actionIcon=<path> (optional)
webuiIcon=<path> (optional)
```

- id 必須與這個正則表達式相符：`^[a-zA-Z][a-zA-Z0-9._-]+$` 例如：✓ `a_module`，✓ `a.module`，✓ `module-101`，✗ `a module`，✗ `1_module`，✗ `-a-module`。這是您的模組的唯一識別碼，發表後將無法變更。
- versionCode 必須是一個整數，用於比較版本。
- 其他未在上方提到的內容可以是任何單行字串。
- 請確保使用 `UNIX (LF)` 分行符號類型，而非 `Windows (CR + LF)` 或 `Macintosh (CR)`。
- actionIcon 與 webuiIcon 是可選的圖示路徑，會作為管理器中模組
  Action 捷徑與 WebUI 捷徑的預設圖示。這些路徑必須是以模組根目錄為
  基準的相對路徑。例如：`actionIcon=icon/icon.png`
  會解析為 `<MODDIR>/icon/icon.png`。

::: tip 動態描述
`description` 欄位可以在執行階段使用模組配置系統動態覆蓋。詳情請參閱[覆蓋模組描述](module-config.md#overriding-module-description)。
:::

### Shell 腳本 {#shell-scripts}

請閱讀 [開機腳本](#boot-scripts) 章節，以瞭解 `post-fs-data.sh` 和 `service.sh` 之間的差別。對於大多數模組開發人員來說，如果您只需要執行一個開機腳本，`service.sh` 應該已經足夠了。
如果您需要在啟動完成後執行腳本，請使用 `boot-completed.sh`。
如果你想在掛載 overlayfs 後做一些事情，請使用 `post-mount.sh`。

在您的模組中的所有腳本中，請使用 `MODDIR=${0%/*}` 以取得您的模組基本目錄路徑；請不要在腳本中以硬式編碼的方式加入您的模組路徑。

:::tip 與 Magisk 的差異
您可以透過環境變數 `KSU` 來判斷腳本是執行在 KernelSU 還是 Magisk 中，如果執行在 KernelSU，這個值會被設為 `true`。
:::

### `system` 目錄 {#system-directories}

這個目錄的內容會在系統啟動後，以 `overlayfs` 的方式覆疊在系統的 `/system` 分區之上，這表示：

1. 系統中對應目錄的相同名稱的檔案會被此目錄中的檔案覆寫。
2. 系統中對應目錄的相同名稱的檔案會與此目錄的檔案合併。

如果您想要刪除系統先前的目錄中的某個檔案或資料夾，您需要在模組目錄中透過 `mknod filename c 0 0` 以建立一個 `filename` 的相同名稱的檔案；這樣 overlayfs 系統會自動「whiteout」等效刪除這個檔案 (`/system` 分割區並未被變更)。

您也可以在 `customize.sh` 中宣告一個名為 `REMOVE` 並且包含一系列目錄的變數以執行移除作業，KernelSU 會自動為您在模組對應目錄執行 `mknod <TARGET> c 0 0`。例如：

```sh
REMOVE="
/system/app/YouTube
/system/app/Bloatware
"
```

上方的清單將會執行：`mknod $MODPATH/system/app/YouTuBe c 0 0` 和 `mknod $MODPATH/system/app/Bloatware c 0 0`；並且 `/system/app/YouTube` 和 `/system/app/Bloatware` 將會在模組生效前移除。

如果您想要取代系統的某個目錄，您需要在模組目錄中建立一個相同路徑的目錄，然後為此目錄設定此屬性：`setfattr -n trusted.overlay.opaque -v y <TARGET>`；這樣 overlayfs 系統會自動將對應目錄取代 (`/system` 分割區並未被變更)。

您可以在 `customize.sh` 中宣告一個名為 `REMOVE` 並且包含一系列目錄的變數以執行移除作業，KernelSU 會自動為您在模組對應目錄執行相關作業。例如：

```sh
REPLACE="
/system/app/YouTube
/system/app/Bloatware
"
```

上方的清單將會執行：自動建立目錄 `$MODPATH/system/app/YouTube` 和 `$MODPATH//system/app/Bloatware`，然後執行 `setfattr -n trusted.overlay.opaque -v y $$MODPATH/system/app/YouTube` 和 `setfattr -n trusted.overlay.opaque -v y $$MODPATH/system/app/Bloatware`；並且 `/system/app/YouTube` 和 `/system/app/Bloatware` 將會在模組生效後被取代為空白目錄。

::: tip 與 Magisk 的差異

KernelSU 的 systemless 機制透過核心的 overlayfs 實作，而 Magisk 目前則是透過 magic mount (bind mount)，兩者的實作方式有很大的差別，但最終的目標是一致的：不修改實際的 `/system` 分區但修改 `/system` 檔案。
:::

如果您對 overlayfs 感興趣，建議閱讀 Linux Kernel 關於 [overlayfs 的文檔](https://docs.kernel.org/filesystems/overlayfs.html)

### system.prop

這個檔案的格式與 `build.prop` 完全相同：每一行都是由 `[key]=[value]` 組成。

### sepolicy.rule

如果您的模組需要一些額外 sepolicy 修補，請將這些原則新增至這個檔案中。這個檔案的每一行都將被視為一個原則陳述。

## 模組安裝程式 {#module-installer}

KernelSU 的模組安裝程式就是一個可以透過 KernelSU 管理員應用程式刷新的 Zip 檔案，這個 Zip 檔案的格式如下：

```txt
module.zip
│
├── customize.sh                       <--- (Optional, more details later)
│                                           This script will be sourced by update-binary
├── ...
├── ...  /* 其他模块文件 */
│
```

:::warning 警告
KernelSU 模組不支援在 Recovery 中安裝！！
:::

### 自訂安裝過程 {#customizing-installation}

如果您想要控制模組的安裝過程，可以在模組的目錄下建立一個名為 `customize.sh` 的檔案，這個檔案將會在模組被解壓縮後經由 **source** 調用，如果您的模組需要依據裝置的 API 版本或裝置架構執行一些額外的作業，這個腳本將非常有用。

如果您想完全控制腳本的安裝過程，您可以在 `customize.sh` 中宣告 `SKIPUNZIP=1` 以跳過所有的預設安裝步驟。此時，您需要自行處理所有的安裝過程(例如解壓縮模組、設定權限等)。

`customize.sh` 腳本以「獨立模式」執行在 KernelSU 的 BusyBox `ash` shell 中。您可以使用下列變數和函式：

#### 變數 {#variables}

- `KSU` (bool): 標示此腳本執行於 KernelSU 環境中，此變數的值將永遠為 `true`，您可以透過它與 Magisk 進行區分。
- `KSU_VER` (string): KernelSU 目前的版本名稱 (例如 `v0.4.0`)
- `KSU_VER_CODE` (int): KernelSU 使用者空間目前的版本代碼 (例如 `10672`)
- `KSU_KERNEL_VER_CODE` (int): KernelSU 核心空間目前的版本代碼 (例如 `10672`)
- `BOOTMODE` (bool): 此變數在 KernelSU 中永遠為 `true`
- `MODPATH` (path): 目前模組的安裝目錄
- `TMPDIR` (path): 可以存放暫存檔的位置
- `ZIPFILE` (path): 目前模組的安裝程式 Zip
- `ARCH` (string): 裝置的 CPU 架構，有這幾種：`arm`, `arm64`, `x86`, or `x64`
- `IS64BIT` (bool): 是否為 64 位元裝置
- `API` (int): 目前裝置的 Android API 版本 (例如 Android 6.0 上為 `23`)

::: warning 警告
`MAGISK_VER_CODE` 在 KernelSU 永遠為 `25200`，`MAGISK_VER` 則為 `v25.2`，請不要透過這兩個變數來判斷是否為 KernelSU！
:::

#### 函式 {#functions}

```txt
ui_print <msg>
    print <msg> to console
    Avoid using 'echo' as it will not display in custom recovery's console

abort <msg>
    print error message <msg> to console and terminate the installation
    Avoid using 'exit' as it will skip the termination cleanup steps

set_perm <target> <owner> <group> <permission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    this function is a shorthand for the following commands:
       chown owner.group target
       chmod permission target
       chcon context target

set_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]
    if [context] is not set, the default is "u:object_r:system_file:s0"
    for all files in <directory>, it will call:
       set_perm file owner group filepermission context
    for all directories in <directory> (including itself), it will call:
       set_perm dir owner group dirpermission context
```

## 開機腳本 {#boot-scripts}

在 KernelSU 中，依據腳本執行模式的不同分為兩種：post-fs-data 模式和 late_start 服務模式。

- post-fs-data 模式
  - 這個階段是 **阻塞** 的。在執行完成之前或 10 秒鐘之後，開機程序會被暫停。
  - 腳本在任何模組被掛接之前執行。這使模組開發人員可以在模組被掛接之前動態調整他們的模組。
  - 這個階段發生在 Zygote 啟動之前，這意味著 Android 中的一切。
  - **警告**: 使用 `setprop` 會導致開機程序死鎖！請使用 `resetprop -n <prop_name> <prop_value>` 替代。
  - **僅在必要時在此模式中執行腳本**。

- late_start 服務模式
  - 這個階段是 **非阻塞** 的。您的腳本會與其餘的啟動程序**平行**執行。
  - **大多數腳本建議在這種模式下執行**。

在 KernelSU 中，開機腳本依據存放位置的不同還分為兩種：一般腳本和模組腳本。

- 一般腳本
  - 放置於 `/data/adb/post-fs-data.d` 或 `/data/adb/service.d` 中。
  - 僅有腳本被設為可執行 (`chmod +x script.sh`) 時才會被執行。
  - 在 `post-fs-data.d` 中的腳本以 post-fs-data 模式執行，在 `service.d` 中的腳本以 late_start 服務模式執行。
  - 模組**不應**在安裝程序中新增一般腳本。

- 模組腳本
  - 放置於模組自己的資料夾中。
  - 僅有在模組啟用時才會執行。
  - `post-fs-data.sh` 以 post-fs-data 模式運行，`post-mount.sh` 在 overlayfs 掛載後運行，而 `service.sh` 則以 late_start 服務模式運行，`boot-completed` 在 Android 系統啟動完畢後以服務模式運作。

所有啟動腳本都將在 KernelSU 的 BusyBox ash shell 中執行，並啟用**獨立模式**。

### 開機腳本解釋 {#boot-scripts-process-explanation}

以下是Android的相關啟動流程（部分省略），其中包括KernelSU的運行（帶前導星號），可以幫助您更好地理解這些模組腳本的用途：
```txt
0. Bootloader (nothing on screen)
load patched boot.img
load kernel:
    - GKI mode: GKI kernel with KernelSU integrated
    - LKM mode: stock kernel
...

1. kernel exec init (oem logo on screen):
    - GKI mode: stock init
    - LKM mode: exec ksuinit, insmod kernelsu.ko, exec stock init
mount /dev, /dev/pts, /proc, /sys, etc.
property-init -> read default props
read init.rc
...
early-init -> init -> late_init
early-fs
   start vold
fs
  mount /vendor, /system, /persist, etc.
post-fs-data
  *safe mode check
  *execute general scripts in post-fs-data.d/
  *load sepolicy.rule
  *mount tmpfs
  *execute module scripts post-fs-data.sh
    **(Zygisk)./bin/zygisk-ptrace64 monitor
  *(pre)load system.prop (same as resetprop -n)
  *remount modules /system
  *execute general scripts in post-mount.d/
  *execute module scripts post-mount.sh
zygote-start
load_all_props_action
  *execute resetprop (actual set props for resetprop with -n option)
... -> boot
  class_start core
    start-service logd, console, vold, etc.
  class_start main
    start-service adb, netd (iptables), zygote, etc.

2. kernel2user init (rom animation on screen, start by service bootanim)
*execute general scripts in service.d/
*execute module scripts service.sh
*set props for resetprop without -p option
  **(Zygisk) hook zygote (start zygiskd)
  **(Zygisk) mount zygisksu/module.prop
start system apps (autostart)
...
boot complete (broadcast ACTION_BOOT_COMPLETED event)
*execute general scripts in boot-completed.d/
*execute module scripts boot-completed.sh

3. User operable (lock screen)
input password to decrypt /data/data
*actual set props for resetprop with -p option
start user apps (autostart)
```

如果您對 Android 的 Init 語言感興趣，建議閱讀它的 [文檔](https://android.googlesource.com/platform/system/core/+/master/init/README.md).

```

`website/docs/zh_TW/guide/rescue-from-bootloop.md`:

```md
# 搶救開機迴圈 {#intruduction}

在寫入裝置時，我們很可能會遇到裝置「變磚」的狀況，從理論上講，如果您只是使用 Fastboot 寫入 Boot 分區或者安裝不合適的模組導致裝置無法開機，那麼這都可以透過合適的作業還原您的手機；這個文件提供一些緊急方法可以讓您在「變磚」中還原。

## 寫入 Boot 時變磚 {#brick-by-flashing-boot-partition}

在 KernelSU 中，寫入 boot 時變磚有下列原因：

1. 你寫入了錯誤格式的 Boot 映像。比如您的手機 Boot 格式為  `gz`，但您寫入 `lz4` 格式的映像，那麼此時手機將無法開機。
2. 您的手機需要關閉 AVB 驗證才可正常開機 (這通常需要抹除手機上的所有資料)。
3. 您的核心存在某些錯誤或您的核心並不適合這部手機寫入。

無論哪種狀況，您都可以透過**寫入原廠 Boot** 還原；因此，在安裝教學最開始，我們已經強烈建議大家，在寫入之前備份自己的原廠 Boot！如果您沒有備份，那麼您可以透過其他與您相同裝置的使用者或官方韌體擷取 Boot。

## 安裝模組變磚 {#brick-by-modules}

安裝模組變磚可能是大家遇到的更常見的狀況，但是這裡要嚴正警示大家：**不要安裝未知來源的模組！！**。因為模組擁有 Root 權限，它能完全對您的裝置造成無法復原的損壞！

### 一般模組 {#normal-modules}

如果大家安裝了某些開放原始碼的或者被證明是安全的模組使手機無法開機，那麼這種狀況在 KernelSU 中非常容易還原，也無需擔心。KernelSU 內建了下列兩種機制以搶救您的裝置：

1. AB 更新
2. 透過按下「音量 -」搶救

#### AB 更新 {#ab-update}

KernelSU 的模組借鑒了 Android 系統 OTA 更新時的 AB 更新機制，如果您安裝了新模組或者對現存模組進行了更新作業，不會直接修改目前使用的模組檔案，而是會把所有模組建置為另外一個更新映像；系統重新啟動後，會使用這個更新映像嘗試重新啟動一次，如果 Android 系統成功開機，模組才會真正更新。

因此，最簡單最常用的搶救方法就是：**強制重新開機一次**。如果您在刷新某個模組之後系統無法開機，您可以長按電源按鈕超過 10 秒，系統會自動重新開機；模組會回復為更新前的狀態，先前更新的模組也將會被自動停用。

#### 透過按下「音量 -」搶救 {#rescue-by-pressing-volume-down}

如果 AB 更新仍然無法解決，您可以嘗試使用**安全模式**。進入安全模式之後，所有的模組將會被停用。

進入安全模式的方法有兩種：

1. 某些系統內建的安全模式：有些系統是長按「音量 -」，有些系統 (例如 MIUI) 可以在 Recovery 中啟用安全模式。進入系統的安全模式後，KernelSU 也會進入安全模式，並自動停用模組。
2. KernelSU 內建的安全模式：開機第一個畫面後，**連續按下「音量 -」按鈕超過三次**。注意是按下-抬起、按下-抬起、按下-抬起，並非一直按下。

進入安全模式後，KernelSU 管理員的模組頁面的所有模組將會被停用，但您可以執行「解除安裝」作業，將可能存在問題的模組解除安裝。

內建的安全模式在核心中實作，因此不會出現按鍵活動無法攔截的狀況。不過對於非 GKI 核心，可能需要手動整合程式碼，可以參閱官方文件指南。

### 惡意模組 {#malicious-modules}

如果以上方法無法搶救您的裝置，那麼很可能您安裝的模組存在惡意作業或透過其他方式損壞了您的裝置，在這種狀況下，只有兩個建議：

1. 抹除資料並恢復為官方系統。
2. 諮詢售後服務。

```

`website/docs/zh_TW/guide/unofficially-support-devices.md`:

```md
# 非官方支援裝置

::: warning 警告
該文件僅供存檔參考，不再維護更新。
自 KernelSU v1.0 版本之後，我們放棄了對非 GKI 裝置的官方支援。
:::

::: warning 警告
本文件列出由其他開發人員維護的支援 KernelSU 的非 GKI 裝置核心
:::

::: warning 警告
本文件僅便於尋找裝置對應原始碼，這並非意味著這些原始碼被 KernelSU 開發人員**審查**，您應自行承擔風險。
:::

<script setup>
import data from '../../repos.json'
</script>

<table>
   <thead>
      <tr>
         <th>維護者</th>
         <th>存放庫</th>
         <th>支援裝置</th>
      </tr>
   </thead>
   <tbody>
    <tr v-for="repo in data" :key="repo.devices">
        <td><a :href="repo.maintainer_link" target="_blank" rel="noreferrer">{{ repo.maintainer }}</a></td>
        <td><a :href="repo.kernel_link" target="_blank" rel="noreferrer">{{ repo.kernel_name }}</a></td>
        <td>{{ repo.devices }}</td>
    </tr>
   </tbody>
</table>
```

`website/docs/zh_TW/guide/what-is-kernelsu.md`:

```md
# 什麼是 KernelSU？ {#what-is-kernelsu}

KernelSU 是 Android GKI 裝置的 Root 解決方案，它以核心模式運作，並直接在核心空間中為使用者空間應用程式授予 Root 權限。

## 功能 {#features}

KernelSU 的主要功能是它是**基於核心的**。 KernelSU 在核心空間中執行，所以它可以向我們提供從未有過的核心介面。例如，我們可以在核心模式中為任何處理程序新增硬體中斷點；我們可以在任何處理程序的實體記憶體中存取，而無人知曉；我們可以在核心空間攔截任何系統呼叫；等等。

此外，KernelSU 提供了 [metamodule 系統](metamodule.md)，這是一個用於模組管理的可插拔架構。與傳統 root 解決方案將掛載邏輯內建於核心的做法不同，KernelSU 將此工作委託給 metamodule。這允許您安裝 metamodule(如 [meta-overlayfs](https://github.com/tiann/KernelSU/tree/main/userspace/meta-overlayfs))來提供對 `/system` 分區和其他分區的 systemless 修改。

## 如何使用 {#how-to-use}

請參閱：[安裝](installation)

## 如何建置 {#how-to-build}

请參閱：[如何建置](how-to-build)

## 討論 {#discussion}

- Telegram: [@KernelSU](https://t.me/KernelSU)

```

`website/docs/zh_TW/index.md`:

```md
---
layout: home
title: 基於核心的 Android Root 解決方案

hero:
  name: KernelSU
  text: 基於核心的 Android root 解決方案
  tagline: ""
  image:
    src: /logo.png
    alt: KernelSU
  actions:
    - theme: brand
      text: 開始瞭解
      link: /zh_TW/guide/what-is-kernelsu
    - theme: alt
      text: 在 GitHub 中檢視
      link: https://github.com/tiann/KernelSU

features:
  - title: 以核心為基礎
    details: KernelSU 以 Linux 核心模式運作，對使用者空間有更強的掌控。
  - title: 白名單存取控制
    details: 僅有被授予 Root 權限的應用程式才可存取 su，而其他應用程式完全無法知悉。
  - title: 可定制的 Root 權限
    details: KernelSU 能夠對 su 的使用者ID（uid）、群組ID（gid）、群組、權限，以及 SELinux 規則進行客製化管理，以此加強 root 權限的安全性。
  - title: Metamodule 系統
    details: 可插拔的模組基礎架構,允許 systemless 方式修改 /system。安裝 metamodule(如 meta-overlayfs)以啟用模組掛載功能。


```

`website/package.json`:

```json
{
  "name": "KernelSU_website",
  "version": "1.0.0",
  "description": "KernelSU official website: https://kernelsu.org",
  "main": "index.js",
  "repository": "https://kernelsu.org",
  "author": "weishu",
  "license": "MIT",
  "devDependencies": {
    "vitepress": "^1.6.4",
    "vue": "^3.5.22"
  },
  "scripts": {
    "docs:dev": "vitepress dev docs",
    "docs:build": "vitepress build docs",
    "docs:preview": "vitepress preview docs"
  },
  "type": "module"
}
```

`website/yarn.lock`:

```lock
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


"@algolia/abtesting@1.8.0":
  version "1.8.0"
  resolved "https://registry.yarnpkg.com/@algolia/abtesting/-/abtesting-1.8.0.tgz#7b0d358ba857e3bc1330ff16b575585c6dfa3158"
  integrity sha512-Hb4BkGNnvgCj3F9XzqjiFTpA5IGkjOXwGAOV13qtc27l2qNF8X9rzSp1H5hu8XewlC0DzYtQtZZIOYzRZDyuXg==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/autocomplete-core@1.17.7":
  version "1.17.7"
  resolved "https://registry.yarnpkg.com/@algolia/autocomplete-core/-/autocomplete-core-1.17.7.tgz#2c410baa94a47c5c5f56ed712bb4a00ebe24088b"
  integrity sha512-BjiPOW6ks90UKl7TwMv7oNQMnzU+t/wk9mgIDi6b1tXpUek7MW0lbNOUHpvam9pe3lVCf4xPFT+lK7s+e+fs7Q==
  dependencies:
    "@algolia/autocomplete-plugin-algolia-insights" "1.17.7"
    "@algolia/autocomplete-shared" "1.17.7"

"@algolia/autocomplete-plugin-algolia-insights@1.17.7":
  version "1.17.7"
  resolved "https://registry.yarnpkg.com/@algolia/autocomplete-plugin-algolia-insights/-/autocomplete-plugin-algolia-insights-1.17.7.tgz#7d2b105f84e7dd8f0370aa4c4ab3b704e6760d82"
  integrity sha512-Jca5Ude6yUOuyzjnz57og7Et3aXjbwCSDf/8onLHSQgw1qW3ALl9mrMWaXb5FmPVkV3EtkD2F/+NkT6VHyPu9A==
  dependencies:
    "@algolia/autocomplete-shared" "1.17.7"

"@algolia/autocomplete-preset-algolia@1.17.7":
  version "1.17.7"
  resolved "https://registry.yarnpkg.com/@algolia/autocomplete-preset-algolia/-/autocomplete-preset-algolia-1.17.7.tgz#c9badc0d73d62db5bf565d839d94ec0034680ae9"
  integrity sha512-ggOQ950+nwbWROq2MOCIL71RE0DdQZsceqrg32UqnhDz8FlO9rL8ONHNsI2R1MH0tkgVIDKI/D0sMiUchsFdWA==
  dependencies:
    "@algolia/autocomplete-shared" "1.17.7"

"@algolia/autocomplete-shared@1.17.7":
  version "1.17.7"
  resolved "https://registry.yarnpkg.com/@algolia/autocomplete-shared/-/autocomplete-shared-1.17.7.tgz#105e84ad9d1a31d3fb86ba20dc890eefe1a313a0"
  integrity sha512-o/1Vurr42U/qskRSuhBH+VKxMvkkUVTLU6WZQr+L5lGZZLYWyhdzWjW0iGXY7EkwRTjBqvN2EsR81yCTGV/kmg==

"@algolia/client-abtesting@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-abtesting/-/client-abtesting-5.42.0.tgz#c72516e9a266faaf537d367c74dfd66b7a2d774a"
  integrity sha512-JLyyG7bb7XOda+w/sp8ch7rEVy6LnWs3qtxr6VJJ2XIINqGsY6U+0L3aJ6QFliBRNUeEAr2QBDxSm8u9Sal5uA==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/client-analytics@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-analytics/-/client-analytics-5.42.0.tgz#9b7051e4256bb893c622a6d5cafc4d335a677b9d"
  integrity sha512-SkCrvtZpdSWjNq9NGu/TtOg4TbzRuUToXlQqV6lLePa2s/WQlEyFw7QYjrz4itprWG9ASuH+StDlq7n49F2sBA==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/client-common@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-common/-/client-common-5.42.0.tgz#9187dca4d845faca499f9581a11460ecebe474c5"
  integrity sha512-6iiFbm2tRn6B2OqFv9XDTcw5LdWPudiJWIbRk+fsTX+hkPrPm4e1/SbU+lEYBciPoaTShLkDbRge4UePEyCPMQ==

"@algolia/client-insights@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-insights/-/client-insights-5.42.0.tgz#fb234d81635ef1ed53cd2125f3d48d549ad8a18f"
  integrity sha512-iEokmw2k6FBa8g/TT7ClyEriaP/FUEmz3iczRoCklEHWSgoABMkaeYrxRXrA2yx76AN+gyZoC8FX0iCJ55dsOg==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/client-personalization@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-personalization/-/client-personalization-5.42.0.tgz#0c778db08e2d61f387c511587c6f0bc6d7148a98"
  integrity sha512-ivVniRqX2ARd+jGvRHTxpWeOtO9VT+rK+OmiuRgkSunoTyxk0vjeDO7QkU7+lzBOXiYgakNjkZrBtIpW9c+muw==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/client-query-suggestions@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-query-suggestions/-/client-query-suggestions-5.42.0.tgz#82566746a13a9d4ff15019e630711cfb833f92a2"
  integrity sha512-9+BIw6rerUfA+eLMIS2lF4mgoeBGTCIHiqb35PLn3699Rm3CaJXz03hChdwAWcA6SwGw0haYXYJa7LF0xI6EpA==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/client-search@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/client-search/-/client-search-5.42.0.tgz#b4c9823af8621a17f1a9878242ac7518519ef0d8"
  integrity sha512-NZR7yyHj2WzK6D5X8gn+/KOxPdzYEXOqVdSaK/biU8QfYUpUuEA0sCWg/XlO05tPVEcJelF/oLrrNY3UjRbOww==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/ingestion@1.42.0":
  version "1.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/ingestion/-/ingestion-1.42.0.tgz#4c542836fb5644a747d9d0f643685533e1431680"
  integrity sha512-MBkjRymf4BT6VOvMpJlg6kq8K+PkH9q+N+K4YMNdzTXlL40YwOa1wIWQ5LxP/Jhlz64kW5g9/oaMWY06Sy9dcw==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/monitoring@1.42.0":
  version "1.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/monitoring/-/monitoring-1.42.0.tgz#8b68d4fe416ae686b280b13400a318d0afda7da3"
  integrity sha512-kmLs7YfjT4cpr4FnhhRmnoSX4psh9KYZ9NAiWt/YcUV33m0B/Os5L4QId30zVXkOqAPAEpV5VbDPWep+/aoJdQ==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/recommend@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/recommend/-/recommend-5.42.0.tgz#0576b5428b66a300767d1befd91f79a2c825ec3e"
  integrity sha512-U5yZ8+Jj+A4ZC0IMfElpPcddQ9NCoawD1dKyWmjHP49nzN2Z4284IFVMAJWR6fq/0ddGf4OMjjYO9cnF8L+5tw==
  dependencies:
    "@algolia/client-common" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

"@algolia/requester-browser-xhr@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/requester-browser-xhr/-/requester-browser-xhr-5.42.0.tgz#2de48dbf2c85e20e70c8f9091a5e2ef2a1254707"
  integrity sha512-EbuxgteaYBlKgc2Fs3JzoPIKAIaevAIwmv1F+fakaEXeibG4pkmVNsyTUjpOZIgJ1kXeqNvDrcjRb6g3vYBJ9A==
  dependencies:
    "@algolia/client-common" "5.42.0"

"@algolia/requester-fetch@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/requester-fetch/-/requester-fetch-5.42.0.tgz#c3db64e0896e60b7ebd4a8e4a151c2199854ff0a"
  integrity sha512-4vnFvY5Q8QZL9eDNkywFLsk/eQCRBXCBpE8HWs8iUsFNHYoamiOxAeYMin0W/nszQj6abc+jNxMChHmejO+ftQ==
  dependencies:
    "@algolia/client-common" "5.42.0"

"@algolia/requester-node-http@5.42.0":
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/@algolia/requester-node-http/-/requester-node-http-5.42.0.tgz#18347c33d59c8c6f8c145f7cfa62e3c76f4569b8"
  integrity sha512-gkLNpU+b1pCIwk1hKTJz2NWQPT8gsfGhQasnZ5QVv4jd79fKRL/1ikd86P0AzuIQs9tbbhlMwxsSTyJmlq502w==
  dependencies:
    "@algolia/client-common" "5.42.0"

"@babel/helper-string-parser@^7.27.1":
  version "7.27.1"
  resolved "https://registry.yarnpkg.com/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz#54da796097ab19ce67ed9f88b47bb2ec49367687"
  integrity sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==

"@babel/helper-validator-identifier@^7.28.5":
  version "7.28.5"
  resolved "https://registry.yarnpkg.com/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz#010b6938fab7cb7df74aa2bbc06aa503b8fe5fb4"
  integrity sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==

"@babel/parser@^7.28.4":
  version "7.28.5"
  resolved "https://registry.yarnpkg.com/@babel/parser/-/parser-7.28.5.tgz#0b0225ee90362f030efd644e8034c99468893b08"
  integrity sha512-KKBU1VGYR7ORr3At5HAtUQ+TV3SzRCXmA/8OdDZiLDBIZxVyzXuztPjfLd3BV1PRAQGCMWWSHYhL0F8d5uHBDQ==
  dependencies:
    "@babel/types" "^7.28.5"

"@babel/types@^7.28.5":
  version "7.28.5"
  resolved "https://registry.yarnpkg.com/@babel/types/-/types-7.28.5.tgz#10fc405f60897c35f07e85493c932c7b5ca0592b"
  integrity sha512-qQ5m48eI/MFLQ5PxQj4PFaprjyCTLI37ElWMmNs0K8Lk3dVeOdNpB3ks8jc7yM5CDmVC73eMVk/trk3fgmrUpA==
  dependencies:
    "@babel/helper-string-parser" "^7.27.1"
    "@babel/helper-validator-identifier" "^7.28.5"

"@docsearch/css@3.8.2":
  version "3.8.2"
  resolved "https://registry.yarnpkg.com/@docsearch/css/-/css-3.8.2.tgz#7973ceb6892c30f154ba254cd05c562257a44977"
  integrity sha512-y05ayQFyUmCXze79+56v/4HpycYF3uFqB78pLPrSV5ZKAlDuIAAJNhaRi8tTdRNXh05yxX/TyNnzD6LwSM89vQ==

"@docsearch/js@3.8.2":
  version "3.8.2"
  resolved "https://registry.yarnpkg.com/@docsearch/js/-/js-3.8.2.tgz#bdcfc9837700eb38453b88e211ab5cc5a3813cc6"
  integrity sha512-Q5wY66qHn0SwA7Taa0aDbHiJvaFJLOJyHmooQ7y8hlwwQLQ/5WwCcoX0g7ii04Qi2DJlHsd0XXzJ8Ypw9+9YmQ==
  dependencies:
    "@docsearch/react" "3.8.2"
    preact "^10.0.0"

"@docsearch/react@3.8.2":
  version "3.8.2"
  resolved "https://registry.yarnpkg.com/@docsearch/react/-/react-3.8.2.tgz#7b11d39b61c976c0aa9fbde66e6b73b30f3acd42"
  integrity sha512-xCRrJQlTt8N9GU0DG4ptwHRkfnSnD/YpdeaXe02iKfqs97TkZJv60yE+1eq/tjPcVnTW8dP5qLP7itifFVV5eg==
  dependencies:
    "@algolia/autocomplete-core" "1.17.7"
    "@algolia/autocomplete-preset-algolia" "1.17.7"
    "@docsearch/css" "3.8.2"
    algoliasearch "^5.14.2"

"@esbuild/aix-ppc64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz#c7184a326533fcdf1b8ee0733e21c713b975575f"
  integrity sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==

"@esbuild/android-arm64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz#09d9b4357780da9ea3a7dfb833a1f1ff439b4052"
  integrity sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==

"@esbuild/android-arm@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/android-arm/-/android-arm-0.21.5.tgz#9b04384fb771926dfa6d7ad04324ecb2ab9b2e28"
  integrity sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==

"@esbuild/android-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/android-x64/-/android-x64-0.21.5.tgz#29918ec2db754cedcb6c1b04de8cd6547af6461e"
  integrity sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==

"@esbuild/darwin-arm64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz#e495b539660e51690f3928af50a76fb0a6ccff2a"
  integrity sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==

"@esbuild/darwin-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz#c13838fa57372839abdddc91d71542ceea2e1e22"
  integrity sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==

"@esbuild/freebsd-arm64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz#646b989aa20bf89fd071dd5dbfad69a3542e550e"
  integrity sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==

"@esbuild/freebsd-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz#aa615cfc80af954d3458906e38ca22c18cf5c261"
  integrity sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==

"@esbuild/linux-arm64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz#70ac6fa14f5cb7e1f7f887bcffb680ad09922b5b"
  integrity sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==

"@esbuild/linux-arm@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz#fc6fd11a8aca56c1f6f3894f2bea0479f8f626b9"
  integrity sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==

"@esbuild/linux-ia32@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz#3271f53b3f93e3d093d518d1649d6d68d346ede2"
  integrity sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==

"@esbuild/linux-loong64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz#ed62e04238c57026aea831c5a130b73c0f9f26df"
  integrity sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==

"@esbuild/linux-mips64el@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz#e79b8eb48bf3b106fadec1ac8240fb97b4e64cbe"
  integrity sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==

"@esbuild/linux-ppc64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz#5f2203860a143b9919d383ef7573521fb154c3e4"
  integrity sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==

"@esbuild/linux-riscv64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz#07bcafd99322d5af62f618cb9e6a9b7f4bb825dc"
  integrity sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==

"@esbuild/linux-s390x@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz#b7ccf686751d6a3e44b8627ababc8be3ef62d8de"
  integrity sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==

"@esbuild/linux-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz#6d8f0c768e070e64309af8004bb94e68ab2bb3b0"
  integrity sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==

"@esbuild/netbsd-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz#bbe430f60d378ecb88decb219c602667387a6047"
  integrity sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==

"@esbuild/openbsd-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz#99d1cf2937279560d2104821f5ccce220cb2af70"
  integrity sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==

"@esbuild/sunos-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz#08741512c10d529566baba837b4fe052c8f3487b"
  integrity sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==

"@esbuild/win32-arm64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz#675b7385398411240735016144ab2e99a60fc75d"
  integrity sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==

"@esbuild/win32-ia32@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz#1bfc3ce98aa6ca9a0969e4d2af72144c59c1193b"
  integrity sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==

"@esbuild/win32-x64@0.21.5":
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz#acad351d582d157bb145535db2a6ff53dd514b5c"
  integrity sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==

"@iconify-json/simple-icons@^1.2.21":
  version "1.2.56"
  resolved "https://registry.yarnpkg.com/@iconify-json/simple-icons/-/simple-icons-1.2.56.tgz#f225b1dc10a6f9bbd80b55342bf34f13633f3824"
  integrity sha512-oAvxOzgSjfvdj/Jsi3S7HDUCxO8/n2j8e1w1e/FktHUAXiWjNX00n3Tu3AP+n1ayKrypcUDXCzxn+0ENMl6ouw==
  dependencies:
    "@iconify/types" "*"

"@iconify/types@*":
  version "2.0.0"
  resolved "https://registry.yarnpkg.com/@iconify/types/-/types-2.0.0.tgz#ab0e9ea681d6c8a1214f30cd741fe3a20cc57f57"
  integrity sha512-+wluvCrRhXrhyOmRDJ3q8mux9JkKy5SJ/v8ol2tu4FVjyYvtEzkc/3pK15ET6RKg4b4w4BmTk1+gsCUhf21Ykg==

"@jridgewell/sourcemap-codec@^1.5.5":
  version "1.5.5"
  resolved "https://registry.yarnpkg.com/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz#6912b00d2c631c0d15ce1a7ab57cd657f2a8f8ba"
  integrity sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==

"@rollup/rollup-android-arm-eabi@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.52.5.tgz#0f44a2f8668ed87b040b6fe659358ac9239da4db"
  integrity sha512-8c1vW4ocv3UOMp9K+gToY5zL2XiiVw3k7f1ksf4yO1FlDFQ1C2u72iACFnSOceJFsWskc2WZNqeRhFRPzv+wtQ==

"@rollup/rollup-android-arm64@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.52.5.tgz#25b9a01deef6518a948431564c987bcb205274f5"
  integrity sha512-mQGfsIEFcu21mvqkEKKu2dYmtuSZOBMmAl5CFlPGLY94Vlcm+zWApK7F/eocsNzp8tKmbeBP8yXyAbx0XHsFNA==

"@rollup/rollup-darwin-arm64@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.52.5.tgz#8a102869c88f3780c7d5e6776afd3f19084ecd7f"
  integrity sha512-takF3CR71mCAGA+v794QUZ0b6ZSrgJkArC+gUiG6LB6TQty9T0Mqh3m2ImRBOxS2IeYBo4lKWIieSvnEk2OQWA==

"@rollup/rollup-darwin-x64@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.52.5.tgz#8e526417cd6f54daf1d0c04cf361160216581956"
  integrity sha512-W901Pla8Ya95WpxDn//VF9K9u2JbocwV/v75TE0YIHNTbhqUTv9w4VuQ9MaWlNOkkEfFwkdNhXgcLqPSmHy0fA==

"@rollup/rollup-freebsd-arm64@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.52.5.tgz#0e7027054493f3409b1f219a3eac5efd128ef899"
  integrity sha512-QofO7i7JycsYOWxe0GFqhLmF6l1TqBswJMvICnRUjqCx8b47MTo46W8AoeQwiokAx3zVryVnxtBMcGcnX12LvA==

"@rollup/rollup-freebsd-x64@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.52.5.tgz#72b204a920139e9ec3d331bd9cfd9a0c248ccb10"
  integrity sha512-jr21b/99ew8ujZubPo9skbrItHEIE50WdV86cdSoRkKtmWa+DDr6fu2c/xyRT0F/WazZpam6kk7IHBerSL7LDQ==

"@rollup/rollup-linux-arm-gnueabihf@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.52.5.tgz#ab1b522ebe5b7e06c99504cc38f6cd8b808ba41c"
  integrity sha512-PsNAbcyv9CcecAUagQefwX8fQn9LQ4nZkpDboBOttmyffnInRy8R8dSg6hxxl2Re5QhHBf6FYIDhIj5v982ATQ==

"@rollup/rollup-linux-arm-musleabihf@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.52.5.tgz#f8cc30b638f1ee7e3d18eac24af47ea29d9beb00"
  integrity sha512-Fw4tysRutyQc/wwkmcyoqFtJhh0u31K+Q6jYjeicsGJJ7bbEq8LwPWV/w0cnzOqR2m694/Af6hpFayLJZkG2VQ==

"@rollup/rollup-linux-arm64-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.52.5.tgz#7af37a9e85f25db59dc8214172907b7e146c12cc"
  integrity sha512-a+3wVnAYdQClOTlyapKmyI6BLPAFYs0JM8HRpgYZQO02rMR09ZcV9LbQB+NL6sljzG38869YqThrRnfPMCDtZg==

"@rollup/rollup-linux-arm64-musl@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.52.5.tgz#a623eb0d3617c03b7a73716eb85c6e37b776f7e0"
  integrity sha512-AvttBOMwO9Pcuuf7m9PkC1PUIKsfaAJ4AYhy944qeTJgQOqJYJ9oVl2nYgY7Rk0mkbsuOpCAYSs6wLYB2Xiw0Q==

"@rollup/rollup-linux-loong64-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.52.5.tgz#76ea038b549c5c6c5f0d062942627c4066642ee2"
  integrity sha512-DkDk8pmXQV2wVrF6oq5tONK6UHLz/XcEVow4JTTerdeV1uqPeHxwcg7aFsfnSm9L+OO8WJsWotKM2JJPMWrQtA==

"@rollup/rollup-linux-ppc64-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.52.5.tgz#d9a4c3f0a3492bc78f6fdfe8131ac61c7359ccd5"
  integrity sha512-W/b9ZN/U9+hPQVvlGwjzi+Wy4xdoH2I8EjaCkMvzpI7wJUs8sWJ03Rq96jRnHkSrcHTpQe8h5Tg3ZzUPGauvAw==

"@rollup/rollup-linux-riscv64-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.52.5.tgz#87ab033eebd1a9a1dd7b60509f6333ec1f82d994"
  integrity sha512-sjQLr9BW7R/ZiXnQiWPkErNfLMkkWIoCz7YMn27HldKsADEKa5WYdobaa1hmN6slu9oWQbB6/jFpJ+P2IkVrmw==

"@rollup/rollup-linux-riscv64-musl@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.52.5.tgz#bda3eb67e1c993c1ba12bc9c2f694e7703958d9f"
  integrity sha512-hq3jU/kGyjXWTvAh2awn8oHroCbrPm8JqM7RUpKjalIRWWXE01CQOf/tUNWNHjmbMHg/hmNCwc/Pz3k1T/j/Lg==

"@rollup/rollup-linux-s390x-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.52.5.tgz#f7bc10fbe096ab44694233dc42a2291ed5453d4b"
  integrity sha512-gn8kHOrku8D4NGHMK1Y7NA7INQTRdVOntt1OCYypZPRt6skGbddska44K8iocdpxHTMMNui5oH4elPH4QOLrFQ==

"@rollup/rollup-linux-x64-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.52.5.tgz#a151cb1234cc9b2cf5e8cfc02aa91436b8f9e278"
  integrity sha512-hXGLYpdhiNElzN770+H2nlx+jRog8TyynpTVzdlc6bndktjKWyZyiCsuDAlpd+j+W+WNqfcyAWz9HxxIGfZm1Q==

"@rollup/rollup-linux-x64-musl@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.52.5.tgz#7859e196501cc3b3062d45d2776cfb4d2f3a9350"
  integrity sha512-arCGIcuNKjBoKAXD+y7XomR9gY6Mw7HnFBv5Rw7wQRvwYLR7gBAgV7Mb2QTyjXfTveBNFAtPt46/36vV9STLNg==

"@rollup/rollup-openharmony-arm64@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.52.5.tgz#85d0df7233734df31e547c1e647d2a5300b3bf30"
  integrity sha512-QoFqB6+/9Rly/RiPjaomPLmR/13cgkIGfA40LHly9zcH1S0bN2HVFYk3a1eAyHQyjs3ZJYlXvIGtcCs5tko9Cw==

"@rollup/rollup-win32-arm64-msvc@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.52.5.tgz#e62357d00458db17277b88adbf690bb855cac937"
  integrity sha512-w0cDWVR6MlTstla1cIfOGyl8+qb93FlAVutcor14Gf5Md5ap5ySfQ7R9S/NjNaMLSFdUnKGEasmVnu3lCMqB7w==

"@rollup/rollup-win32-ia32-msvc@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.52.5.tgz#fc7cd40f44834a703c1f1c3fe8bcc27ce476cd50"
  integrity sha512-Aufdpzp7DpOTULJCuvzqcItSGDH73pF3ko/f+ckJhxQyHtp67rHw3HMNxoIdDMUITJESNE6a8uh4Lo4SLouOUg==

"@rollup/rollup-win32-x64-gnu@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.52.5.tgz#1a22acfc93c64a64a48c42672e857ee51774d0d3"
  integrity sha512-UGBUGPFp1vkj6p8wCRraqNhqwX/4kNQPS57BCFc8wYh0g94iVIW33wJtQAx3G7vrjjNtRaxiMUylM0ktp/TRSQ==

"@rollup/rollup-win32-x64-msvc@4.52.5":
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.52.5.tgz#1657f56326bbe0ac80eedc9f9c18fc1ddd24e107"
  integrity sha512-TAcgQh2sSkykPRWLrdyy2AiceMckNf5loITqXxFI5VuQjS5tSuw3WlwdN8qv8vzjLAUTvYaH/mVjSFpbkFbpTg==

"@shikijs/core@2.5.0", "@shikijs/core@^2.1.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/core/-/core-2.5.0.tgz#e14d33961dfa3141393d4a76fc8923d0d1c4b62f"
  integrity sha512-uu/8RExTKtavlpH7XqnVYBrfBkUc20ngXiX9NSrBhOVZYv/7XQRKUyhtkeflY5QsxC0GbJThCerruZfsUaSldg==
  dependencies:
    "@shikijs/engine-javascript" "2.5.0"
    "@shikijs/engine-oniguruma" "2.5.0"
    "@shikijs/types" "2.5.0"
    "@shikijs/vscode-textmate" "^10.0.2"
    "@types/hast" "^3.0.4"
    hast-util-to-html "^9.0.4"

"@shikijs/engine-javascript@2.5.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/engine-javascript/-/engine-javascript-2.5.0.tgz#e045c6ecfbda6c99137547b0a482e0b87f1053fc"
  integrity sha512-VjnOpnQf8WuCEZtNUdjjwGUbtAVKuZkVQ/5cHy/tojVVRIRtlWMYVjyWhxOmIq05AlSOv72z7hRNRGVBgQOl0w==
  dependencies:
    "@shikijs/types" "2.5.0"
    "@shikijs/vscode-textmate" "^10.0.2"
    oniguruma-to-es "^3.1.0"

"@shikijs/engine-oniguruma@2.5.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/engine-oniguruma/-/engine-oniguruma-2.5.0.tgz#230de5693cc1da6c9d59c7ad83593c2027274817"
  integrity sha512-pGd1wRATzbo/uatrCIILlAdFVKdxImWJGQ5rFiB5VZi2ve5xj3Ax9jny8QvkaV93btQEwR/rSz5ERFpC5mKNIw==
  dependencies:
    "@shikijs/types" "2.5.0"
    "@shikijs/vscode-textmate" "^10.0.2"

"@shikijs/langs@2.5.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/langs/-/langs-2.5.0.tgz#97ab50c495922cc1ca06e192985b28dc73de5d50"
  integrity sha512-Qfrrt5OsNH5R+5tJ/3uYBBZv3SuGmnRPejV9IlIbFH3HTGLDlkqgHymAlzklVmKBjAaVmkPkyikAV/sQ1wSL+w==
  dependencies:
    "@shikijs/types" "2.5.0"

"@shikijs/themes@2.5.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/themes/-/themes-2.5.0.tgz#8c6aecf73f5455681c8bec15797cf678162896cb"
  integrity sha512-wGrk+R8tJnO0VMzmUExHR+QdSaPUl/NKs+a4cQQRWyoc3YFbUzuLEi/KWK1hj+8BfHRKm2jNhhJck1dfstJpiw==
  dependencies:
    "@shikijs/types" "2.5.0"

"@shikijs/transformers@^2.1.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/transformers/-/transformers-2.5.0.tgz#190c84786ff06c417580ab79177338a947168c55"
  integrity sha512-SI494W5X60CaUwgi8u4q4m4s3YAFSxln3tzNjOSYqq54wlVgz0/NbbXEb3mdLbqMBztcmS7bVTaEd2w0qMmfeg==
  dependencies:
    "@shikijs/core" "2.5.0"
    "@shikijs/types" "2.5.0"

"@shikijs/types@2.5.0", "@shikijs/types@^2.1.0":
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/@shikijs/types/-/types-2.5.0.tgz#e949c7384802703a48b9d6425dd41673c164df69"
  integrity sha512-ygl5yhxki9ZLNuNpPitBWvcy9fsSKKaRuO4BAlMyagszQidxcpLAr0qiW/q43DtSIDxO6hEbtYLiFZNXO/hdGw==
  dependencies:
    "@shikijs/vscode-textmate" "^10.0.2"
    "@types/hast" "^3.0.4"

"@shikijs/vscode-textmate@^10.0.2":
  version "10.0.2"
  resolved "https://registry.yarnpkg.com/@shikijs/vscode-textmate/-/vscode-textmate-10.0.2.tgz#a90ab31d0cc1dfb54c66a69e515bf624fa7b2224"
  integrity sha512-83yeghZ2xxin3Nj8z1NMd/NCuca+gsYXswywDy5bHvwlWL8tpTQmzGeUuHd9FC3E/SBEMvzJRwWEOz5gGes9Qg==

"@types/estree@1.0.8":
  version "1.0.8"
  resolved "https://registry.yarnpkg.com/@types/estree/-/estree-1.0.8.tgz#958b91c991b1867ced318bedea0e215ee050726e"
  integrity sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==

"@types/hast@^3.0.0", "@types/hast@^3.0.4":
  version "3.0.4"
  resolved "https://registry.yarnpkg.com/@types/hast/-/hast-3.0.4.tgz#1d6b39993b82cea6ad783945b0508c25903e15aa"
  integrity sha512-WPs+bbQw5aCj+x6laNGWLH3wviHtoCv/P3+otBhbOhJgG8qtpdAMlTCxLtsTWA7LH1Oh/bFCHsBn0TPS5m30EQ==
  dependencies:
    "@types/unist" "*"

"@types/linkify-it@^5":
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/@types/linkify-it/-/linkify-it-5.0.0.tgz#21413001973106cda1c3a9b91eedd4ccd5469d76"
  integrity sha512-sVDA58zAw4eWAffKOaQH5/5j3XeayukzDk+ewSsnv3p4yJEZHCCzMDiZM8e0OUrRvmpGZ85jf4yDHkHsgBNr9Q==

"@types/markdown-it@^14.1.2":
  version "14.1.2"
  resolved "https://registry.yarnpkg.com/@types/markdown-it/-/markdown-it-14.1.2.tgz#57f2532a0800067d9b934f3521429a2e8bfb4c61"
  integrity sha512-promo4eFwuiW+TfGxhi+0x3czqTYJkG8qB17ZUJiVF10Xm7NLVRSLUsfRTU/6h1e24VvRnXCx+hG7li58lkzog==
  dependencies:
    "@types/linkify-it" "^5"
    "@types/mdurl" "^2"

"@types/mdast@^4.0.0":
  version "4.0.4"
  resolved "https://registry.yarnpkg.com/@types/mdast/-/mdast-4.0.4.tgz#7ccf72edd2f1aa7dd3437e180c64373585804dd6"
  integrity sha512-kGaNbPh1k7AFzgpud/gMdvIm5xuECykRR+JnWKQno9TAXVa6WIVCGTPvYGekIDL4uwCZQSYbUxNBSb1aUo79oA==
  dependencies:
    "@types/unist" "*"

"@types/mdurl@^2":
  version "2.0.0"
  resolved "https://registry.yarnpkg.com/@types/mdurl/-/mdurl-2.0.0.tgz#d43878b5b20222682163ae6f897b20447233bdfd"
  integrity sha512-RGdgjQUZba5p6QEFAVx2OGb8rQDL/cPRG7GiedRzMcJ1tYnUANBncjbSB1NRGwbvjcPeikRABz2nshyPk1bhWg==

"@types/unist@*", "@types/unist@^3.0.0":
  version "3.0.3"
  resolved "https://registry.yarnpkg.com/@types/unist/-/unist-3.0.3.tgz#acaab0f919ce69cce629c2d4ed2eb4adc1b6c20c"
  integrity sha512-ko/gIFJRv177XgZsZcBwnqJN5x/Gien8qNOn0D5bQU/zAzVf9Zt3BlcUiLqhV9y4ARk0GbT3tnUiPNgnTXzc/Q==

"@types/web-bluetooth@^0.0.21":
  version "0.0.21"
  resolved "https://registry.yarnpkg.com/@types/web-bluetooth/-/web-bluetooth-0.0.21.tgz#525433c784aed9b457aaa0ee3d92aeb71f346b63"
  integrity sha512-oIQLCGWtcFZy2JW77j9k8nHzAOpqMHLQejDA48XXMWH6tjCQHz5RCFz1bzsmROyL6PUm+LLnUiI4BCn221inxA==

"@ungap/structured-clone@^1.0.0":
  version "1.3.0"
  resolved "https://registry.yarnpkg.com/@ungap/structured-clone/-/structured-clone-1.3.0.tgz#d06bbb384ebcf6c505fde1c3d0ed4ddffe0aaff8"
  integrity sha512-WmoN8qaIAo7WTYWbAZuG8PYEhn5fkz7dZrqTBZ7dtt//lL2Gwms1IcnQ5yHqjDfX8Ft5j4YzDM23f87zBfDe9g==

"@vitejs/plugin-vue@^5.2.1":
  version "5.2.4"
  resolved "https://registry.yarnpkg.com/@vitejs/plugin-vue/-/plugin-vue-5.2.4.tgz#9e8a512eb174bfc2a333ba959bbf9de428d89ad8"
  integrity sha512-7Yx/SXSOcQq5HiiV3orevHUFn+pmMB4cgbEkDYgnkUWb0WfeQ/wa2yFv6D5ICiCQOVpjA7vYDXrC7AGO8yjDHA==

"@vue/compiler-core@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/compiler-core/-/compiler-core-3.5.22.tgz#bb8294a0dd31df540563cc6ffa0456f1f7687b97"
  integrity sha512-jQ0pFPmZwTEiRNSb+i9Ow/I/cHv2tXYqsnHKKyCQ08irI2kdF5qmYedmF8si8mA7zepUFmJ2hqzS8CQmNOWOkQ==
  dependencies:
    "@babel/parser" "^7.28.4"
    "@vue/shared" "3.5.22"
    entities "^4.5.0"
    estree-walker "^2.0.2"
    source-map-js "^1.2.1"

"@vue/compiler-dom@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/compiler-dom/-/compiler-dom-3.5.22.tgz#6c9c2c9843520f6d3dbc685e5d0e1e12a2c04c56"
  integrity sha512-W8RknzUM1BLkypvdz10OVsGxnMAuSIZs9Wdx1vzA3mL5fNMN15rhrSCLiTm6blWeACwUwizzPVqGJgOGBEN/hA==
  dependencies:
    "@vue/compiler-core" "3.5.22"
    "@vue/shared" "3.5.22"

"@vue/compiler-sfc@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/compiler-sfc/-/compiler-sfc-3.5.22.tgz#663a8483b1dda8de83b6fa1aab38a52bf73dd965"
  integrity sha512-tbTR1zKGce4Lj+JLzFXDq36K4vcSZbJ1RBu8FxcDv1IGRz//Dh2EBqksyGVypz3kXpshIfWKGOCcqpSbyGWRJQ==
  dependencies:
    "@babel/parser" "^7.28.4"
    "@vue/compiler-core" "3.5.22"
    "@vue/compiler-dom" "3.5.22"
    "@vue/compiler-ssr" "3.5.22"
    "@vue/shared" "3.5.22"
    estree-walker "^2.0.2"
    magic-string "^0.30.19"
    postcss "^8.5.6"
    source-map-js "^1.2.1"

"@vue/compiler-ssr@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/compiler-ssr/-/compiler-ssr-3.5.22.tgz#a0ef16e364731b25e79a13470569066af101320f"
  integrity sha512-GdgyLvg4R+7T8Nk2Mlighx7XGxq/fJf9jaVofc3IL0EPesTE86cP/8DD1lT3h1JeZr2ySBvyqKQJgbS54IX1Ww==
  dependencies:
    "@vue/compiler-dom" "3.5.22"
    "@vue/shared" "3.5.22"

"@vue/devtools-api@^7.7.0":
  version "7.7.7"
  resolved "https://registry.yarnpkg.com/@vue/devtools-api/-/devtools-api-7.7.7.tgz#5ef5f55f60396220725a273548c0d7ee983d5d34"
  integrity sha512-lwOnNBH2e7x1fIIbVT7yF5D+YWhqELm55/4ZKf45R9T8r9dE2AIOy8HKjfqzGsoTHFbWbr337O4E0A0QADnjBg==
  dependencies:
    "@vue/devtools-kit" "^7.7.7"

"@vue/devtools-kit@^7.7.7":
  version "7.7.7"
  resolved "https://registry.yarnpkg.com/@vue/devtools-kit/-/devtools-kit-7.7.7.tgz#41a64f9526e9363331c72405544df020ce2e3641"
  integrity sha512-wgoZtxcTta65cnZ1Q6MbAfePVFxfM+gq0saaeytoph7nEa7yMXoi6sCPy4ufO111B9msnw0VOWjPEFCXuAKRHA==
  dependencies:
    "@vue/devtools-shared" "^7.7.7"
    birpc "^2.3.0"
    hookable "^5.5.3"
    mitt "^3.0.1"
    perfect-debounce "^1.0.0"
    speakingurl "^14.0.1"
    superjson "^2.2.2"

"@vue/devtools-shared@^7.7.7":
  version "7.7.7"
  resolved "https://registry.yarnpkg.com/@vue/devtools-shared/-/devtools-shared-7.7.7.tgz#ff14aa8c1262ebac8c0397d3b09f767cd489750c"
  integrity sha512-+udSj47aRl5aKb0memBvcUG9koarqnxNM5yjuREvqwK6T3ap4mn3Zqqc17QrBFTqSMjr3HK1cvStEZpMDpfdyw==
  dependencies:
    rfdc "^1.4.1"

"@vue/reactivity@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/reactivity/-/reactivity-3.5.22.tgz#9b26f8557c96df46c9a859914a2229f3ca5b8f4f"
  integrity sha512-f2Wux4v/Z2pqc9+4SmgZC1p73Z53fyD90NFWXiX9AKVnVBEvLFOWCEgJD3GdGnlxPZt01PSlfmLqbLYzY/Fw4A==
  dependencies:
    "@vue/shared" "3.5.22"

"@vue/runtime-core@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/runtime-core/-/runtime-core-3.5.22.tgz#e004c1e35f423555a0e4c10646ef3e9d380643d1"
  integrity sha512-EHo4W/eiYeAzRTN5PCextDUZ0dMs9I8mQ2Fy+OkzvRPUYQEyK9yAjbasrMCXbLNhF7P0OUyivLjIy0yc6VrLJQ==
  dependencies:
    "@vue/reactivity" "3.5.22"
    "@vue/shared" "3.5.22"

"@vue/runtime-dom@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/runtime-dom/-/runtime-dom-3.5.22.tgz#01276cea7cb9ac2b9aba046adfb5903b494e2e7e"
  integrity sha512-Av60jsryAkI023PlN7LsqrfPvwfxOd2yAwtReCjeuugTJTkgrksYJJstg1e12qle0NarkfhfFu1ox2D+cQotww==
  dependencies:
    "@vue/reactivity" "3.5.22"
    "@vue/runtime-core" "3.5.22"
    "@vue/shared" "3.5.22"
    csstype "^3.1.3"

"@vue/server-renderer@3.5.22":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/server-renderer/-/server-renderer-3.5.22.tgz#d134e3409094044bd066d9803714677457756157"
  integrity sha512-gXjo+ao0oHYTSswF+a3KRHZ1WszxIqO7u6XwNHqcqb9JfyIL/pbWrrh/xLv7jeDqla9u+LK7yfZKHih1e1RKAQ==
  dependencies:
    "@vue/compiler-ssr" "3.5.22"
    "@vue/shared" "3.5.22"

"@vue/shared@3.5.22", "@vue/shared@^3.5.13":
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/@vue/shared/-/shared-3.5.22.tgz#9d56a1644a3becb8af1e34655928b0e288d827f8"
  integrity sha512-F4yc6palwq3TT0u+FYf0Ns4Tfl9GRFURDN2gWG7L1ecIaS/4fCIuFOjMTnCyjsu/OK6vaDKLCrGAa+KvvH+h4w==

"@vueuse/core@12.8.2", "@vueuse/core@^12.4.0":
  version "12.8.2"
  resolved "https://registry.yarnpkg.com/@vueuse/core/-/core-12.8.2.tgz#007c6dd29a7d1f6933e916e7a2f8ef3c3f968eaa"
  integrity sha512-HbvCmZdzAu3VGi/pWYm5Ut+Kd9mn1ZHnn4L5G8kOQTPs/IwIAmJoBrmYk2ckLArgMXZj0AW3n5CAejLUO+PhdQ==
  dependencies:
    "@types/web-bluetooth" "^0.0.21"
    "@vueuse/metadata" "12.8.2"
    "@vueuse/shared" "12.8.2"
    vue "^3.5.13"

"@vueuse/integrations@^12.4.0":
  version "12.8.2"
  resolved "https://registry.yarnpkg.com/@vueuse/integrations/-/integrations-12.8.2.tgz#d04f33d86fe985c9a27c98addcfde9f30f2db1df"
  integrity sha512-fbGYivgK5uBTRt7p5F3zy6VrETlV9RtZjBqd1/HxGdjdckBgBM4ugP8LHpjolqTj14TXTxSK1ZfgPbHYyGuH7g==
  dependencies:
    "@vueuse/core" "12.8.2"
    "@vueuse/shared" "12.8.2"
    vue "^3.5.13"

"@vueuse/metadata@12.8.2":
  version "12.8.2"
  resolved "https://registry.yarnpkg.com/@vueuse/metadata/-/metadata-12.8.2.tgz#6cb3a4e97cdcf528329eebc1bda73cd7f64318d3"
  integrity sha512-rAyLGEuoBJ/Il5AmFHiziCPdQzRt88VxR+Y/A/QhJ1EWtWqPBBAxTAFaSkviwEuOEZNtW8pvkPgoCZQ+HxqW1A==

"@vueuse/shared@12.8.2":
  version "12.8.2"
  resolved "https://registry.yarnpkg.com/@vueuse/shared/-/shared-12.8.2.tgz#b9e4611d0603629c8e151f982459da394e22f930"
  integrity sha512-dznP38YzxZoNloI0qpEfpkms8knDtaoQ6Y/sfS0L7Yki4zh40LFHEhur0odJC6xTHG5dxWVPiUWBXn+wCG2s5w==
  dependencies:
    vue "^3.5.13"

algoliasearch@^5.14.2:
  version "5.42.0"
  resolved "https://registry.yarnpkg.com/algoliasearch/-/algoliasearch-5.42.0.tgz#c30247e6480030471dfa2899f591878ff2fc5e15"
  integrity sha512-X5+PtWc9EJIPafT/cj8ZG+6IU3cjRRnlHGtqMHK/9gsiupQbAyYlH5y7qt/FtsAhfX5AICHffZy69ZAsVrxWkQ==
  dependencies:
    "@algolia/abtesting" "1.8.0"
    "@algolia/client-abtesting" "5.42.0"
    "@algolia/client-analytics" "5.42.0"
    "@algolia/client-common" "5.42.0"
    "@algolia/client-insights" "5.42.0"
    "@algolia/client-personalization" "5.42.0"
    "@algolia/client-query-suggestions" "5.42.0"
    "@algolia/client-search" "5.42.0"
    "@algolia/ingestion" "1.42.0"
    "@algolia/monitoring" "1.42.0"
    "@algolia/recommend" "5.42.0"
    "@algolia/requester-browser-xhr" "5.42.0"
    "@algolia/requester-fetch" "5.42.0"
    "@algolia/requester-node-http" "5.42.0"

birpc@^2.3.0:
  version "2.6.1"
  resolved "https://registry.yarnpkg.com/birpc/-/birpc-2.6.1.tgz#c73463590928897e80f3263d9fbb7da63515014b"
  integrity sha512-LPnFhlDpdSH6FJhJyn4M0kFO7vtQ5iPw24FnG0y21q09xC7e8+1LeR31S1MAIrDAHp4m7aas4bEkTDTvMAtebQ==

ccount@^2.0.0:
  version "2.0.1"
  resolved "https://registry.yarnpkg.com/ccount/-/ccount-2.0.1.tgz#17a3bf82302e0870d6da43a01311a8bc02a3ecf5"
  integrity sha512-eyrF0jiFpY+3drT6383f1qhkbGsLSifNAjA61IUjZjmLCWjItY6LB9ft9YhoDgwfmclB2zhu51Lc7+95b8NRAg==

character-entities-html4@^2.0.0:
  version "2.1.0"
  resolved "https://registry.yarnpkg.com/character-entities-html4/-/character-entities-html4-2.1.0.tgz#1f1adb940c971a4b22ba39ddca6b618dc6e56b2b"
  integrity sha512-1v7fgQRj6hnSwFpq1Eu0ynr/CDEw0rXo2B61qXrLNdHZmPKgb7fqS1a2JwF0rISo9q77jDI8VMEHoApn8qDoZA==

character-entities-legacy@^3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/character-entities-legacy/-/character-entities-legacy-3.0.0.tgz#76bc83a90738901d7bc223a9e93759fdd560125b"
  integrity sha512-RpPp0asT/6ufRm//AJVwpViZbGM/MkjQFxJccQRHmISF/22NBtsHqAWmL+/pmkPWoIUJdWyeVleTl1wydHATVQ==

comma-separated-tokens@^2.0.0:
  version "2.0.3"
  resolved "https://registry.yarnpkg.com/comma-separated-tokens/-/comma-separated-tokens-2.0.3.tgz#4e89c9458acb61bc8fef19f4529973b2392839ee"
  integrity sha512-Fu4hJdvzeylCfQPp9SGWidpzrMs7tTrlu6Vb8XGaRGck8QSNZJJp538Wrb60Lax4fPwR64ViY468OIUTbRlGZg==

copy-anything@^4:
  version "4.0.5"
  resolved "https://registry.yarnpkg.com/copy-anything/-/copy-anything-4.0.5.tgz#16cabafd1ea4bb327a540b750f2b4df522825aea"
  integrity sha512-7Vv6asjS4gMOuILabD3l739tsaxFQmC+a7pLZm02zyvs8p977bL3zEgq3yDk5rn9B0PbYgIv++jmHcuUab4RhA==
  dependencies:
    is-what "^5.2.0"

csstype@^3.1.3:
  version "3.1.3"
  resolved "https://registry.yarnpkg.com/csstype/-/csstype-3.1.3.tgz#d80ff294d114fb0e6ac500fbf85b60137d7eff81"
  integrity sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==

dequal@^2.0.0:
  version "2.0.3"
  resolved "https://registry.yarnpkg.com/dequal/-/dequal-2.0.3.tgz#2644214f1997d39ed0ee0ece72335490a7ac67be"
  integrity sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==

devlop@^1.0.0:
  version "1.1.0"
  resolved "https://registry.yarnpkg.com/devlop/-/devlop-1.1.0.tgz#4db7c2ca4dc6e0e834c30be70c94bbc976dc7018"
  integrity sha512-RWmIqhcFf1lRYBvNmr7qTNuyCt/7/ns2jbpp1+PalgE/rDQcBT0fioSMUpJ93irlUhC5hrg4cYqe6U+0ImW0rA==
  dependencies:
    dequal "^2.0.0"

emoji-regex-xs@^1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/emoji-regex-xs/-/emoji-regex-xs-1.0.0.tgz#e8af22e5d9dbd7f7f22d280af3d19d2aab5b0724"
  integrity sha512-LRlerrMYoIDrT6jgpeZ2YYl/L8EulRTt5hQcYjy5AInh7HWXKimpqx68aknBFpGL2+/IcogTcaydJEgaTmOpDg==

entities@^4.5.0:
  version "4.5.0"
  resolved "https://registry.yarnpkg.com/entities/-/entities-4.5.0.tgz#5d268ea5e7113ec74c4d033b79ea5a35a488fb48"
  integrity sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==

esbuild@^0.21.3:
  version "0.21.5"
  resolved "https://registry.yarnpkg.com/esbuild/-/esbuild-0.21.5.tgz#9ca301b120922959b766360d8ac830da0d02997d"
  integrity sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==
  optionalDependencies:
    "@esbuild/aix-ppc64" "0.21.5"
    "@esbuild/android-arm" "0.21.5"
    "@esbuild/android-arm64" "0.21.5"
    "@esbuild/android-x64" "0.21.5"
    "@esbuild/darwin-arm64" "0.21.5"
    "@esbuild/darwin-x64" "0.21.5"
    "@esbuild/freebsd-arm64" "0.21.5"
    "@esbuild/freebsd-x64" "0.21.5"
    "@esbuild/linux-arm" "0.21.5"
    "@esbuild/linux-arm64" "0.21.5"
    "@esbuild/linux-ia32" "0.21.5"
    "@esbuild/linux-loong64" "0.21.5"
    "@esbuild/linux-mips64el" "0.21.5"
    "@esbuild/linux-ppc64" "0.21.5"
    "@esbuild/linux-riscv64" "0.21.5"
    "@esbuild/linux-s390x" "0.21.5"
    "@esbuild/linux-x64" "0.21.5"
    "@esbuild/netbsd-x64" "0.21.5"
    "@esbuild/openbsd-x64" "0.21.5"
    "@esbuild/sunos-x64" "0.21.5"
    "@esbuild/win32-arm64" "0.21.5"
    "@esbuild/win32-ia32" "0.21.5"
    "@esbuild/win32-x64" "0.21.5"

estree-walker@^2.0.2:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/estree-walker/-/estree-walker-2.0.2.tgz#52f010178c2a4c117a7757cfe942adb7d2da4cac"
  integrity sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==

focus-trap@^7.6.4:
  version "7.6.6"
  resolved "https://registry.yarnpkg.com/focus-trap/-/focus-trap-7.6.6.tgz#a255c1088ddc8cd4363b3023bf28b224fd38aff2"
  integrity sha512-v/Z8bvMCajtx4mEXmOo7QEsIzlIOqRXTIwgUfsFOF9gEsespdbD0AkPIka1bSXZ8Y8oZ+2IVDQZePkTfEHZl7Q==
  dependencies:
    tabbable "^6.3.0"

fsevents@~2.3.2, fsevents@~2.3.3:
  version "2.3.3"
  resolved "https://registry.yarnpkg.com/fsevents/-/fsevents-2.3.3.tgz#cac6407785d03675a2a5e1a5305c697b347d90d6"
  integrity sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==

hast-util-to-html@^9.0.4:
  version "9.0.5"
  resolved "https://registry.yarnpkg.com/hast-util-to-html/-/hast-util-to-html-9.0.5.tgz#ccc673a55bb8e85775b08ac28380f72d47167005"
  integrity sha512-OguPdidb+fbHQSU4Q4ZiLKnzWo8Wwsf5bZfbvu7//a9oTYoqD/fWpe96NuHkoS9h0ccGOTe0C4NGXdtS0iObOw==
  dependencies:
    "@types/hast" "^3.0.0"
    "@types/unist" "^3.0.0"
    ccount "^2.0.0"
    comma-separated-tokens "^2.0.0"
    hast-util-whitespace "^3.0.0"
    html-void-elements "^3.0.0"
    mdast-util-to-hast "^13.0.0"
    property-information "^7.0.0"
    space-separated-tokens "^2.0.0"
    stringify-entities "^4.0.0"
    zwitch "^2.0.4"

hast-util-whitespace@^3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/hast-util-whitespace/-/hast-util-whitespace-3.0.0.tgz#7778ed9d3c92dd9e8c5c8f648a49c21fc51cb621"
  integrity sha512-88JUN06ipLwsnv+dVn+OIYOvAuvBMy/Qoi6O7mQHxdPXpjy+Cd6xRkWwux7DKO+4sYILtLBRIKgsdpS2gQc7qw==
  dependencies:
    "@types/hast" "^3.0.0"

hookable@^5.5.3:
  version "5.5.3"
  resolved "https://registry.yarnpkg.com/hookable/-/hookable-5.5.3.tgz#6cfc358984a1ef991e2518cb9ed4a778bbd3215d"
  integrity sha512-Yc+BQe8SvoXH1643Qez1zqLRmbA5rCL+sSmk6TVos0LWVfNIB7PGncdlId77WzLGSIB5KaWgTaNTs2lNVEI6VQ==

html-void-elements@^3.0.0:
  version "3.0.0"
  resolved "https://registry.yarnpkg.com/html-void-elements/-/html-void-elements-3.0.0.tgz#fc9dbd84af9e747249034d4d62602def6517f1d7"
  integrity sha512-bEqo66MRXsUGxWHV5IP0PUiAWwoEjba4VCzg0LjFJBpchPaTfyfCKTG6bc5F8ucKec3q5y6qOdGyYTSBEvhCrg==

is-what@^5.2.0:
  version "5.5.0"
  resolved "https://registry.yarnpkg.com/is-what/-/is-what-5.5.0.tgz#a3031815757cfe1f03fed990bf6355a2d3f628c4"
  integrity sha512-oG7cgbmg5kLYae2N5IVd3jm2s+vldjxJzK1pcu9LfpGuQ93MQSzo0okvRna+7y5ifrD+20FE8FvjusyGaz14fw==

magic-string@^0.30.19:
  version "0.30.21"
  resolved "https://registry.yarnpkg.com/magic-string/-/magic-string-0.30.21.tgz#56763ec09a0fa8091df27879fd94d19078c00d91"
  integrity sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==
  dependencies:
    "@jridgewell/sourcemap-codec" "^1.5.5"

mark.js@8.11.1:
  version "8.11.1"
  resolved "https://registry.yarnpkg.com/mark.js/-/mark.js-8.11.1.tgz#180f1f9ebef8b0e638e4166ad52db879beb2ffc5"
  integrity sha512-1I+1qpDt4idfgLQG+BNWmrqku+7/2bi5nLf4YwF8y8zXvmfiTBY3PV3ZibfrjBueCByROpuBjLLFCajqkgYoLQ==

mdast-util-to-hast@^13.0.0:
  version "13.2.0"
  resolved "https://registry.yarnpkg.com/mdast-util-to-hast/-/mdast-util-to-hast-13.2.0.tgz#5ca58e5b921cc0a3ded1bc02eed79a4fe4fe41f4"
  integrity sha512-QGYKEuUsYT9ykKBCMOEDLsU5JRObWQusAolFMeko/tYPufNkRffBAQjIE+99jbA87xv6FgmjLtwjh9wBWajwAA==
  dependencies:
    "@types/hast" "^3.0.0"
    "@types/mdast" "^4.0.0"
    "@ungap/structured-clone" "^1.0.0"
    devlop "^1.0.0"
    micromark-util-sanitize-uri "^2.0.0"
    trim-lines "^3.0.0"
    unist-util-position "^5.0.0"
    unist-util-visit "^5.0.0"
    vfile "^6.0.0"

micromark-util-character@^2.0.0:
  version "2.1.1"
  resolved "https://registry.yarnpkg.com/micromark-util-character/-/micromark-util-character-2.1.1.tgz#2f987831a40d4c510ac261e89852c4e9703ccda6"
  integrity sha512-wv8tdUTJ3thSFFFJKtpYKOYiGP2+v96Hvk4Tu8KpCAsTMs6yi+nVmGh1syvSCsaxz45J6Jbw+9DD6g97+NV67Q==
  dependencies:
    micromark-util-symbol "^2.0.0"
    micromark-util-types "^2.0.0"

micromark-util-encode@^2.0.0:
  version "2.0.1"
  resolved "https://registry.yarnpkg.com/micromark-util-encode/-/micromark-util-encode-2.0.1.tgz#0d51d1c095551cfaac368326963cf55f15f540b8"
  integrity sha512-c3cVx2y4KqUnwopcO9b/SCdo2O67LwJJ/UyqGfbigahfegL9myoEFoDYZgkT7f36T0bLrM9hZTAaAyH+PCAXjw==

micromark-util-sanitize-uri@^2.0.0:
  version "2.0.1"
  resolved "https://registry.yarnpkg.com/micromark-util-sanitize-uri/-/micromark-util-sanitize-uri-2.0.1.tgz#ab89789b818a58752b73d6b55238621b7faa8fd7"
  integrity sha512-9N9IomZ/YuGGZZmQec1MbgxtlgougxTodVwDzzEouPKo3qFWvymFHWcnDi2vzV1ff6kas9ucW+o3yzJK9YB1AQ==
  dependencies:
    micromark-util-character "^2.0.0"
    micromark-util-encode "^2.0.0"
    micromark-util-symbol "^2.0.0"

micromark-util-symbol@^2.0.0:
  version "2.0.1"
  resolved "https://registry.yarnpkg.com/micromark-util-symbol/-/micromark-util-symbol-2.0.1.tgz#e5da494e8eb2b071a0d08fb34f6cefec6c0a19b8"
  integrity sha512-vs5t8Apaud9N28kgCrRUdEed4UJ+wWNvicHLPxCa9ENlYuAY31M0ETy5y1vA33YoNPDFTghEbnh6efaE8h4x0Q==

micromark-util-types@^2.0.0:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/micromark-util-types/-/micromark-util-types-2.0.2.tgz#f00225f5f5a0ebc3254f96c36b6605c4b393908e"
  integrity sha512-Yw0ECSpJoViF1qTU4DC6NwtC4aWGt1EkzaQB8KPPyCRR8z9TWeV0HbEFGTO+ZY1wB22zmxnJqhPyTpOVCpeHTA==

minisearch@^7.1.1:
  version "7.2.0"
  resolved "https://registry.yarnpkg.com/minisearch/-/minisearch-7.2.0.tgz#3dc30e41e9464b3836553b6d969b656614f8f359"
  integrity sha512-dqT2XBYUOZOiC5t2HRnwADjhNS2cecp9u+TJRiJ1Qp/f5qjkeT5APcGPjHw+bz89Ms8Jp+cG4AlE+QZ/QnDglg==

mitt@^3.0.1:
  version "3.0.1"
  resolved "https://registry.yarnpkg.com/mitt/-/mitt-3.0.1.tgz#ea36cf0cc30403601ae074c8f77b7092cdab36d1"
  integrity sha512-vKivATfr97l2/QBCYAkXYDbrIWPM2IIKEl7YPhjCvKlG3kE2gm+uBo6nEXK3M5/Ffh/FLpKExzOQ3JJoJGFKBw==

nanoid@^3.3.11:
  version "3.3.11"
  resolved "https://registry.yarnpkg.com/nanoid/-/nanoid-3.3.11.tgz#4f4f112cefbe303202f2199838128936266d185b"
  integrity sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==

oniguruma-to-es@^3.1.0:
  version "3.1.1"
  resolved "https://registry.yarnpkg.com/oniguruma-to-es/-/oniguruma-to-es-3.1.1.tgz#480e4bac4d3bc9439ac0d2124f0725e7a0d76d17"
  integrity sha512-bUH8SDvPkH3ho3dvwJwfonjlQ4R80vjyvrU8YpxuROddv55vAEJrTuCuCVUhhsHbtlD9tGGbaNApGQckXhS8iQ==
  dependencies:
    emoji-regex-xs "^1.0.0"
    regex "^6.0.1"
    regex-recursion "^6.0.2"

perfect-debounce@^1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/perfect-debounce/-/perfect-debounce-1.0.0.tgz#9c2e8bc30b169cc984a58b7d5b28049839591d2a"
  integrity sha512-xCy9V055GLEqoFaHoC1SoLIaLmWctgCUaBaWxDZ7/Zx4CTyX7cJQLJOok/orfjZAh9kEYpjJa4d0KcJmCbctZA==

picocolors@^1.1.1:
  version "1.1.1"
  resolved "https://registry.yarnpkg.com/picocolors/-/picocolors-1.1.1.tgz#3d321af3eab939b083c8f929a1d12cda81c26b6b"
  integrity sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==

postcss@^8.4.43, postcss@^8.5.6:
  version "8.5.6"
  resolved "https://registry.yarnpkg.com/postcss/-/postcss-8.5.6.tgz#2825006615a619b4f62a9e7426cc120b349a8f3c"
  integrity sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==
  dependencies:
    nanoid "^3.3.11"
    picocolors "^1.1.1"
    source-map-js "^1.2.1"

preact@^10.0.0:
  version "10.27.2"
  resolved "https://registry.yarnpkg.com/preact/-/preact-10.27.2.tgz#19b9009c1be801a76a0aaf0fe5ba665985a09312"
  integrity sha512-5SYSgFKSyhCbk6SrXyMpqjb5+MQBgfvEKE/OC+PujcY34sOpqtr+0AZQtPYx5IA6VxynQ7rUPCtKzyovpj9Bpg==

property-information@^7.0.0:
  version "7.1.0"
  resolved "https://registry.yarnpkg.com/property-information/-/property-information-7.1.0.tgz#b622e8646e02b580205415586b40804d3e8bfd5d"
  integrity sha512-TwEZ+X+yCJmYfL7TPUOcvBZ4QfoT5YenQiJuX//0th53DE6w0xxLEtfK3iyryQFddXuvkIk51EEgrJQ0WJkOmQ==

regex-recursion@^6.0.2:
  version "6.0.2"
  resolved "https://registry.yarnpkg.com/regex-recursion/-/regex-recursion-6.0.2.tgz#a0b1977a74c87f073377b938dbedfab2ea582b33"
  integrity sha512-0YCaSCq2VRIebiaUviZNs0cBz1kg5kVS2UKUfNIx8YVs1cN3AV7NTctO5FOKBA+UT2BPJIWZauYHPqJODG50cg==
  dependencies:
    regex-utilities "^2.3.0"

regex-utilities@^2.3.0:
  version "2.3.0"
  resolved "https://registry.yarnpkg.com/regex-utilities/-/regex-utilities-2.3.0.tgz#87163512a15dce2908cf079c8960d5158ff43280"
  integrity sha512-8VhliFJAWRaUiVvREIiW2NXXTmHs4vMNnSzuJVhscgmGav3g9VDxLrQndI3dZZVVdp0ZO/5v0xmX516/7M9cng==

regex@^6.0.1:
  version "6.0.1"
  resolved "https://registry.yarnpkg.com/regex/-/regex-6.0.1.tgz#282fa4435d0c700b09c0eb0982b602e05ab6a34f"
  integrity sha512-uorlqlzAKjKQZ5P+kTJr3eeJGSVroLKoHmquUj4zHWuR+hEyNqlXsSKlYYF5F4NI6nl7tWCs0apKJ0lmfsXAPA==
  dependencies:
    regex-utilities "^2.3.0"

rfdc@^1.4.1:
  version "1.4.1"
  resolved "https://registry.yarnpkg.com/rfdc/-/rfdc-1.4.1.tgz#778f76c4fb731d93414e8f925fbecf64cce7f6ca"
  integrity sha512-q1b3N5QkRUWUl7iyylaaj3kOpIT0N2i9MqIEQXP73GVsN9cw3fdx8X63cEmWhJGi2PPCF23Ijp7ktmd39rawIA==

rollup@^4.20.0:
  version "4.52.5"
  resolved "https://registry.yarnpkg.com/rollup/-/rollup-4.52.5.tgz#96982cdcaedcdd51b12359981f240f94304ec235"
  integrity sha512-3GuObel8h7Kqdjt0gxkEzaifHTqLVW56Y/bjN7PSQtkKr0w3V/QYSdt6QWYtd7A1xUtYQigtdUfgj1RvWVtorw==
  dependencies:
    "@types/estree" "1.0.8"
  optionalDependencies:
    "@rollup/rollup-android-arm-eabi" "4.52.5"
    "@rollup/rollup-android-arm64" "4.52.5"
    "@rollup/rollup-darwin-arm64" "4.52.5"
    "@rollup/rollup-darwin-x64" "4.52.5"
    "@rollup/rollup-freebsd-arm64" "4.52.5"
    "@rollup/rollup-freebsd-x64" "4.52.5"
    "@rollup/rollup-linux-arm-gnueabihf" "4.52.5"
    "@rollup/rollup-linux-arm-musleabihf" "4.52.5"
    "@rollup/rollup-linux-arm64-gnu" "4.52.5"
    "@rollup/rollup-linux-arm64-musl" "4.52.5"
    "@rollup/rollup-linux-loong64-gnu" "4.52.5"
    "@rollup/rollup-linux-ppc64-gnu" "4.52.5"
    "@rollup/rollup-linux-riscv64-gnu" "4.52.5"
    "@rollup/rollup-linux-riscv64-musl" "4.52.5"
    "@rollup/rollup-linux-s390x-gnu" "4.52.5"
    "@rollup/rollup-linux-x64-gnu" "4.52.5"
    "@rollup/rollup-linux-x64-musl" "4.52.5"
    "@rollup/rollup-openharmony-arm64" "4.52.5"
    "@rollup/rollup-win32-arm64-msvc" "4.52.5"
    "@rollup/rollup-win32-ia32-msvc" "4.52.5"
    "@rollup/rollup-win32-x64-gnu" "4.52.5"
    "@rollup/rollup-win32-x64-msvc" "4.52.5"
    fsevents "~2.3.2"

shiki@^2.1.0:
  version "2.5.0"
  resolved "https://registry.yarnpkg.com/shiki/-/shiki-2.5.0.tgz#09d01ebf3b0b06580431ce3ddc023320442cf223"
  integrity sha512-mI//trrsaiCIPsja5CNfsyNOqgAZUb6VpJA+340toL42UpzQlXpwRV9nch69X6gaUxrr9kaOOa6e3y3uAkGFxQ==
  dependencies:
    "@shikijs/core" "2.5.0"
    "@shikijs/engine-javascript" "2.5.0"
    "@shikijs/engine-oniguruma" "2.5.0"
    "@shikijs/langs" "2.5.0"
    "@shikijs/themes" "2.5.0"
    "@shikijs/types" "2.5.0"
    "@shikijs/vscode-textmate" "^10.0.2"
    "@types/hast" "^3.0.4"

source-map-js@^1.2.1:
  version "1.2.1"
  resolved "https://registry.yarnpkg.com/source-map-js/-/source-map-js-1.2.1.tgz#1ce5650fddd87abc099eda37dcff024c2667ae46"
  integrity sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==

space-separated-tokens@^2.0.0:
  version "2.0.2"
  resolved "https://registry.yarnpkg.com/space-separated-tokens/-/space-separated-tokens-2.0.2.tgz#1ecd9d2350a3844572c3f4a312bceb018348859f"
  integrity sha512-PEGlAwrG8yXGXRjW32fGbg66JAlOAwbObuqVoJpv/mRgoWDQfgH1wDPvtzWyUSNAXBGSk8h755YDbbcEy3SH2Q==

speakingurl@^14.0.1:
  version "14.0.1"
  resolved "https://registry.yarnpkg.com/speakingurl/-/speakingurl-14.0.1.tgz#f37ec8ddc4ab98e9600c1c9ec324a8c48d772a53"
  integrity sha512-1POYv7uv2gXoyGFpBCmpDVSNV74IfsWlDW216UPjbWufNf+bSU6GdbDsxdcxtfwb4xlI3yxzOTKClUosxARYrQ==

stringify-entities@^4.0.0:
  version "4.0.4"
  resolved "https://registry.yarnpkg.com/stringify-entities/-/stringify-entities-4.0.4.tgz#b3b79ef5f277cc4ac73caeb0236c5ba939b3a4f3"
  integrity sha512-IwfBptatlO+QCJUo19AqvrPNqlVMpW9YEL2LIVY+Rpv2qsjCGxaDLNRgeGsQWJhfItebuJhsGSLjaBbNSQ+ieg==
  dependencies:
    character-entities-html4 "^2.0.0"
    character-entities-legacy "^3.0.0"

superjson@^2.2.2:
  version "2.2.5"
  resolved "https://registry.yarnpkg.com/superjson/-/superjson-2.2.5.tgz#a01be31a54048f5c330aec8259f403f64913d83c"
  integrity sha512-zWPTX96LVsA/eVYnqOM2+ofcdPqdS1dAF1LN4TS2/MWuUpfitd9ctTa87wt4xrYnZnkLtS69xpBdSxVBP5Rm6w==
  dependencies:
    copy-anything "^4"

tabbable@^6.3.0:
  version "6.3.0"
  resolved "https://registry.yarnpkg.com/tabbable/-/tabbable-6.3.0.tgz#2e0e6163935387cdeacd44e9334616ca0115a8d3"
  integrity sha512-EIHvdY5bPLuWForiR/AN2Bxngzpuwn1is4asboytXtpTgsArc+WmSJKVLlhdh71u7jFcryDqB2A8lQvj78MkyQ==

trim-lines@^3.0.0:
  version "3.0.1"
  resolved "https://registry.yarnpkg.com/trim-lines/-/trim-lines-3.0.1.tgz#d802e332a07df861c48802c04321017b1bd87338"
  integrity sha512-kRj8B+YHZCc9kQYdWfJB2/oUl9rA99qbowYYBtr4ui4mZyAQ2JpvVBd/6U2YloATfqBhBTSMhTpgBHtU0Mf3Rg==

unist-util-is@^6.0.0:
  version "6.0.1"
  resolved "https://registry.yarnpkg.com/unist-util-is/-/unist-util-is-6.0.1.tgz#d0a3f86f2dd0db7acd7d8c2478080b5c67f9c6a9"
  integrity sha512-LsiILbtBETkDz8I9p1dQ0uyRUWuaQzd/cuEeS1hoRSyW5E5XGmTzlwY1OrNzzakGowI9Dr/I8HVaw4hTtnxy8g==
  dependencies:
    "@types/unist" "^3.0.0"

unist-util-position@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/unist-util-position/-/unist-util-position-5.0.0.tgz#678f20ab5ca1207a97d7ea8a388373c9cf896be4"
  integrity sha512-fucsC7HjXvkB5R3kTCO7kUjRdrS0BJt3M/FPxmHMBOm8JQi2BsHAHFsy27E0EolP8rp0NzXsJ+jNPyDWvOJZPA==
  dependencies:
    "@types/unist" "^3.0.0"

unist-util-stringify-position@^4.0.0:
  version "4.0.0"
  resolved "https://registry.yarnpkg.com/unist-util-stringify-position/-/unist-util-stringify-position-4.0.0.tgz#449c6e21a880e0855bf5aabadeb3a740314abac2"
  integrity sha512-0ASV06AAoKCDkS2+xw5RXJywruurpbC4JZSm7nr7MOt1ojAzvyyaO+UxZf18j8FCF6kmzCZKcAgN/yu2gm2XgQ==
  dependencies:
    "@types/unist" "^3.0.0"

unist-util-visit-parents@^6.0.0:
  version "6.0.2"
  resolved "https://registry.yarnpkg.com/unist-util-visit-parents/-/unist-util-visit-parents-6.0.2.tgz#777df7fb98652ce16b4b7cd999d0a1a40efa3a02"
  integrity sha512-goh1s1TBrqSqukSc8wrjwWhL0hiJxgA8m4kFxGlQ+8FYQ3C/m11FcTs4YYem7V664AhHVvgoQLk890Ssdsr2IQ==
  dependencies:
    "@types/unist" "^3.0.0"
    unist-util-is "^6.0.0"

unist-util-visit@^5.0.0:
  version "5.0.0"
  resolved "https://registry.yarnpkg.com/unist-util-visit/-/unist-util-visit-5.0.0.tgz#a7de1f31f72ffd3519ea71814cccf5fd6a9217d6"
  integrity sha512-MR04uvD+07cwl/yhVuVWAtw+3GOR/knlL55Nd/wAdblk27GCVt3lqpTivy/tkJcZoNPzTwS1Y+KMojlLDhoTzg==
  dependencies:
    "@types/unist" "^3.0.0"
    unist-util-is "^6.0.0"
    unist-util-visit-parents "^6.0.0"

vfile-message@^4.0.0:
  version "4.0.3"
  resolved "https://registry.yarnpkg.com/vfile-message/-/vfile-message-4.0.3.tgz#87b44dddd7b70f0641c2e3ed0864ba73e2ea8df4"
  integrity sha512-QTHzsGd1EhbZs4AsQ20JX1rC3cOlt/IWJruk893DfLRr57lcnOeMaWG4K0JrRta4mIJZKth2Au3mM3u03/JWKw==
  dependencies:
    "@types/unist" "^3.0.0"
    unist-util-stringify-position "^4.0.0"

vfile@^6.0.0:
  version "6.0.3"
  resolved "https://registry.yarnpkg.com/vfile/-/vfile-6.0.3.tgz#3652ab1c496531852bf55a6bac57af981ebc38ab"
  integrity sha512-KzIbH/9tXat2u30jf+smMwFCsno4wHVdNmzFyL+T/L3UGqqk6JKfVqOFOZEpZSHADH1k40ab6NUIXZq422ov3Q==
  dependencies:
    "@types/unist" "^3.0.0"
    vfile-message "^4.0.0"

vite@^5.4.14:
  version "5.4.21"
  resolved "https://registry.yarnpkg.com/vite/-/vite-5.4.21.tgz#84a4f7c5d860b071676d39ba513c0d598fdc7027"
  integrity sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==
  dependencies:
    esbuild "^0.21.3"
    postcss "^8.4.43"
    rollup "^4.20.0"
  optionalDependencies:
    fsevents "~2.3.3"

vitepress@^1.6.4:
  version "1.6.4"
  resolved "https://registry.yarnpkg.com/vitepress/-/vitepress-1.6.4.tgz#1b6c68fede541a3f401a66263dce0c985e2d8d92"
  integrity sha512-+2ym1/+0VVrbhNyRoFFesVvBvHAVMZMK0rw60E3X/5349M1GuVdKeazuksqopEdvkKwKGs21Q729jX81/bkBJg==
  dependencies:
    "@docsearch/css" "3.8.2"
    "@docsearch/js" "3.8.2"
    "@iconify-json/simple-icons" "^1.2.21"
    "@shikijs/core" "^2.1.0"
    "@shikijs/transformers" "^2.1.0"
    "@shikijs/types" "^2.1.0"
    "@types/markdown-it" "^14.1.2"
    "@vitejs/plugin-vue" "^5.2.1"
    "@vue/devtools-api" "^7.7.0"
    "@vue/shared" "^3.5.13"
    "@vueuse/core" "^12.4.0"
    "@vueuse/integrations" "^12.4.0"
    focus-trap "^7.6.4"
    mark.js "8.11.1"
    minisearch "^7.1.1"
    shiki "^2.1.0"
    vite "^5.4.14"
    vue "^3.5.13"

vue@^3.5.13, vue@^3.5.22:
  version "3.5.22"
  resolved "https://registry.yarnpkg.com/vue/-/vue-3.5.22.tgz#2b8ddb94ee4b640ef12fe7f6efe1cf16f3b582e7"
  integrity sha512-toaZjQ3a/G/mYaLSbV+QsQhIdMo9x5rrqIpYRObsJ6T/J+RyCSFwN2LHNVH9v8uIcljDNa3QzPVdv3Y6b9hAJQ==
  dependencies:
    "@vue/compiler-dom" "3.5.22"
    "@vue/compiler-sfc" "3.5.22"
    "@vue/runtime-dom" "3.5.22"
    "@vue/server-renderer" "3.5.22"
    "@vue/shared" "3.5.22"

zwitch@^2.0.4:
  version "2.0.4"
  resolved "https://registry.yarnpkg.com/zwitch/-/zwitch-2.0.4.tgz#c827d4b0acb76fc3e685a4c6ec2902d51070e9d7"
  integrity sha512-bXE4cR/kVZhKZX/RjPEflHaKVhUVl85noU3v6b8apfQEc1x4A+zBxjZ4lN8LqGd6WZ3dl98pY4o717VFmoPp+A==

```