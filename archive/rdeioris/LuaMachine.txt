Project Path: arc_rdeioris_LuaMachine_k8e_f0e8

Source Tree:

```txt
arc_rdeioris_LuaMachine_k8e_f0e8
├── BuildingNotes.md
├── Config
│   └── FilterPlugin.ini
├── Content
│   ├── Code
│   │   ├── ReflectionMetaTable.uasset
│   │   ├── TestActorCode.uasset
│   │   ├── TestBrokenCode.uasset
│   │   ├── TestCoroutines.uasset
│   │   ├── TestDummyCode.uasset
│   │   ├── TestMainCode.uasset
│   │   └── TestProxyCall.uasset
│   ├── LuaMachine_Tests.umap
│   ├── LuaReflectionTestState.uasset
│   ├── LuaTestActor.uasset
│   ├── LuaTestState.uasset
│   ├── Scripts
│   │   ├── submodules
│   │   │   └── test004.lua
│   │   ├── test001.lua
│   │   ├── test002.lua
│   │   ├── test003.lua
│   │   ├── test011.lua
│   │   └── trackedmodules
│   │       └── test005.lua
│   ├── TestAnotherTableInterface.uasset
│   ├── TestTableInterface.uasset
│   └── Tests
│       ├── TestActorField.uasset
│       ├── TestActorInception.uasset
│       ├── TestActorMethod.uasset
│       ├── TestActorMethodMulti.uasset
│       ├── TestActorMethodMultiNoArgs.uasset
│       ├── TestActorMethodValueMultiNoArgs.uasset
│       ├── TestActorReflectionBoolean.uasset
│       ├── TestActorReflectionBooleanFalse.uasset
│       ├── TestActorReflectionFunction.uasset
│       ├── TestActorReflectionFunctionK2.uasset
│       ├── TestActorReflectionFunctionStruct.uasset
│       ├── TestActorReflectionMulticastDelegate.uasset
│       ├── TestActorReflectionString.uasset
│       ├── TestActorReflectionStringSet.uasset
│       ├── TestActorSetField.uasset
│       ├── TestActorSetFieldOfTable.uasset
│       ├── TestActorToLuaComponent.uasset
│       ├── TestActorToLuaComponentByName.uasset
│       ├── TestActorToLuaComponentByName2.uasset
│       ├── TestActorToLuaComponentByStateAndName.uasset
│       ├── TestActorToLuaComponentFromState.uasset
│       ├── TestActorUFunction.uasset
│       ├── TestActorUFunctionAsValue.uasset
│       ├── TestActorUFunctionAsValueRaw.uasset
│       ├── TestArrayCreation.uasset
│       ├── TestCallTable.uasset
│       ├── TestCallTableWithSelf.uasset
│       ├── TestCallValueMulti.uasset
│       ├── TestCleanLazyTable.uasset
│       ├── TestCleanTable.uasset
│       ├── TestCoroutine.uasset
│       ├── TestCoroutineResume.uasset
│       ├── TestCoroutineResumeMulti.uasset
│       ├── TestCoroutineResumeMulti_BP.uasset
│       ├── TestCoroutineResume__newindex.uasset
│       ├── TestCoroutineResume__preload.uasset
│       ├── TestGC.uasset
│       ├── TestGetGlobalTable.uasset
│       ├── TestGetGlobalTableFallback.uasset
│       ├── TestGetGlobalTableNil.uasset
│       ├── TestGlobalCallValueMulti.uasset
│       ├── TestIterateArrayKeys.uasset
│       ├── TestIterateArrayValues.uasset
│       ├── TestIterateTableValues.uasset
│       ├── TestLuaValueCallError.uasset
│       ├── TestLuaValueCallErrorReferenced.uasset
│       ├── TestMultiArgs.uasset
│       ├── TestOwnage.uasset
│       ├── TestOwnageComplex.uasset
│       ├── TestRunAsset.uasset
│       ├── TestRunBrokenAsset.uasset
│       ├── TestRunFileError.uasset
│       ├── TestRunFiles.uasset
│       ├── TestRunNonExistingFile.uasset
│       ├── TestRunString.uasset
│       ├── TestRunStringWithVariable.uasset
│       ├── TestSetGlobalTable.uasset
│       ├── TestSetGlobalTableCreation.uasset
│       ├── TestSetGlobalTableNativeComplex.uasset
│       ├── TestSetGlobalTableSharedWithUnreal.uasset
│       ├── TestSetGlobalTableTable.uasset
│       ├── TestStack.uasset
│       ├── TestStateReload.uasset
│       ├── TestTableAsset.uasset
│       ├── TestTableFields.uasset
│       ├── TestTableImplements.uasset
│       ├── TestTableImplementsAll.uasset
│       ├── TestTableImplementsAllRedLight.uasset
│       ├── TestTableImplementsAny.uasset
│       ├── TestTablePointers.uasset
│       ├── TestTypes.uasset
│       ├── TestUserDataMetaTable.uasset
│       ├── TestUserDataMetaTableCreateObjectInState.uasset
│       └── TestUserDataMetaTableGet.uasset
├── Docs
│   ├── LuaBlueprintFunctionLibrary.md
│   ├── LuaComponent.md
│   ├── LuaCoroutines.md
│   ├── LuaMachine_Logo.png
│   ├── ReflectionAPI.md
│   ├── Screenshots
│   │   ├── Android24.PNG
│   │   ├── Coroutine.PNG
│   │   ├── Debugger.PNG
│   │   ├── LuaCodeBox.PNG
│   │   ├── LuaComponent.PNG
│   │   ├── LuaComponent2.PNG
│   │   ├── LuaComponent3.PNG
│   │   ├── LuaComponent4.PNG
│   │   ├── LuaComponent5.PNG
│   │   ├── LuaConsole.PNG
│   │   ├── Packaging.PNG
│   │   ├── Packaging2.PNG
│   │   ├── PlayerToLuaComponent.PNG
│   │   ├── Quickstart.PNG
│   │   ├── Quickstart2.PNG
│   │   ├── Quickstart3.PNG
│   │   ├── Quickstart4.PNG
│   │   ├── Quickstart5.PNG
│   │   ├── Quickstart6.PNG
│   │   ├── Quickstart7.PNG
│   │   ├── Quickstart8.PNG
│   │   └── SyntaxColor.PNG
│   └── TipsAndTricks.md
├── LICENSE
├── LuaMachine.uplugin
├── README.md
├── Resources
│   ├── Icon128.png
│   └── LuaTableAsset256.png
├── Source
│   ├── LuaMachine
│   │   ├── LuaMachine.Build.cs
│   │   ├── Private
│   │   │   ├── LuaBlueprintFunctionLibrary.cpp
│   │   │   ├── LuaBlueprintPackage.cpp
│   │   │   ├── LuaCode.cpp
│   │   │   ├── LuaCommandExecutor.cpp
│   │   │   ├── LuaComponent.cpp
│   │   │   ├── LuaDelegate.cpp
│   │   │   ├── LuaGlobalNameComponent.cpp
│   │   │   ├── LuaMachine.cpp
│   │   │   ├── LuaMultiLineEditableTextBox.cpp
│   │   │   ├── LuaState.cpp
│   │   │   ├── LuaSyntaxHighlighter.cpp
│   │   │   ├── LuaTableAsset.cpp
│   │   │   ├── LuaUserDataObject.cpp
│   │   │   └── LuaValue.cpp
│   │   └── Public
│   │       ├── LuaBlueprintFunctionLibrary.h
│   │       ├── LuaBlueprintPackage.h
│   │       ├── LuaCode.h
│   │       ├── LuaCommandExecutor.h
│   │       ├── LuaComponent.h
│   │       ├── LuaDelegate.h
│   │       ├── LuaGlobalNameComponent.h
│   │       ├── LuaMachine.h
│   │       ├── LuaMultiLineEditableTextBox.h
│   │       ├── LuaState.h
│   │       ├── LuaSyntaxHighlighter.h
│   │       ├── LuaTableAsset.h
│   │       ├── LuaUserDataObject.h
│   │       └── LuaValue.h
│   ├── LuaMachineEditor
│   │   ├── LuaMachineEditor.Build.cs
│   │   ├── Private
│   │   │   ├── LuaCodeCustomization.cpp
│   │   │   ├── LuaCodeFactory.cpp
│   │   │   ├── LuaMachineEditor.cpp
│   │   │   └── LuaValueCustomization.cpp
│   │   └── Public
│   │       ├── LuaCodeCustomization.h
│   │       ├── LuaCodeFactory.h
│   │       ├── LuaMachineEditor.h
│   │       └── LuaValueCustomization.h
│   └── ThirdParty
│       ├── ARM64
│       ├── ARMv7
│       ├── lua
│       │   ├── lauxlib.h
│       │   ├── lua.h
│       │   ├── lua.hpp
│       │   ├── luaconf.h
│       │   └── lualib.h
│       └── x64
└── Tutorials
    ├── JsonLuaBlueprintPackage.md
    ├── ReflectionShell.md
    ├── RickAndMortyAPI.md
    ├── RickAndMortyAPI_Data
    │   ├── RickAndMorty.PNG
    │   ├── RickAndMorty001.PNG
    │   ├── RickAndMorty002.PNG
    │   ├── RickAndMorty003.PNG
    │   ├── RickAndMorty004.PNG
    │   ├── RickAndMorty005.PNG
    │   ├── RickAndMorty006.PNG
    │   ├── RickAndMorty007.PNG
    │   ├── RickAndMorty008.PNG
    │   ├── RickAndMorty009.PNG
    │   ├── RickAndMorty010.PNG
    │   ├── RickAndMorty011.PNG
    │   ├── RickAndMorty012.PNG
    │   ├── RickAndMorty013.PNG
    │   ├── RickAndMorty014.PNG
    │   ├── RickAndMorty015.PNG
    │   ├── RickAndMorty016.PNG
    │   ├── RickAndMorty017.PNG
    │   ├── RickAndMorty018.PNG
    │   ├── RickAndMorty019.PNG
    │   ├── RickAndMorty020.PNG
    │   ├── RickAndMorty021.PNG
    │   ├── RickAndMorty022.PNG
    │   ├── RickAndMorty023.PNG
    │   ├── RickAndMorty024.PNG
    │   └── RickAndMorty025.PNG
    ├── SimpleDialogueSystem.md
    ├── SimpleDialogueSystem_Data
    │   ├── BeginPlay.PNG
    │   ├── CloseDialogue.PNG
    │   ├── CodeAsset.PNG
    │   ├── ContentBrowser.PNG
    │   ├── CurrentTarget.PNG
    │   ├── DialogueLuaState.PNG
    │   ├── DialogueQuestionDesigner.PNG
    │   ├── DialogueQuestionGraph.PNG
    │   ├── DialogueScreenDesigner.PNG
    │   ├── DialogueScreenGraph.PNG
    │   ├── EventLuaError.PNG
    │   ├── FromFile.PNG
    │   ├── GetPlayer.PNG
    │   ├── Intro.PNG
    │   ├── LevelBlueprint.PNG
    │   ├── LuaStateTable1.PNG
    │   ├── LuaStateTable2.PNG
    │   ├── LuaStateTable3.PNG
    │   ├── Modding.PNG
    │   ├── MultipleCharacters.PNG
    │   ├── OpenDialogue.PNG
    │   ├── Overlap.PNG
    │   ├── Owner.PNG
    │   ├── Page2.PNG
    │   ├── Page3.PNG
    │   ├── PrintAndLuaError.PNG
    │   ├── SetCamera.PNG
    │   ├── SetFace.PNG
    │   ├── SetFlash.PNG
    │   ├── SetFlashExposed.PNG
    │   ├── Shop.PNG
    │   ├── Speak.PNG
    │   ├── SpeakWithTwinblast.PNG
    │   ├── TalkingCharacter.PNG
    │   ├── TalkingScript.PNG
    │   ├── ThreeScripts.PNG
    │   └── Twinblast.PNG
    └── WebSocketsWithLuaUserDataObjects.md

```

`BuildingNotes.md`:

```md
# Building Lua static library for Mac

```sh
# edit src/Makefile and set MYCFLAGS to -mmacosx-version-min=10.12 -arch arm64 -arch x86_64
make macosx
```

# Building Lua static library for Linux x86_64

```sh
# after having added -fPIC to MYCFLAGS in src/Makefile
make linux
```

# Building Lua static library for Win64

```sh
# open visual studio shell for x64 and move to the src/ directory (change cl.exe and lib.exe with their arm64 version for hololens)
cl /MD /O2 /c /DLUA_BUILD_AS_DLL /DLUA_COMPAT_5_2 *.c
del lua.obj
del luac.obj
lib /OUT:liblua53_win64.lib *.obj
```

# Building Lua static library for Android

```sh
# assume ndk is installed in home with api 24
~/ndk/bin/clang -O2 -Wall -Werror -Wextra -DLUA_USE_POSIX -DLUA_USEDLOPEN -DLUA_COMPAT_5_2 -std=gnu99 -c *.c
rm lua.o
rm luac.o
 ~/ndk/bin/arm-linux-androideabi-ar.exe rcu liblua53_android.a *.o
```

# Building Lua static library for iOS

Comment the os_execute function in loslib.c and its mapping in the syslib array

```sh
clang -arch arm64 -mios-version-min=7.0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/ -O2 -Wall -Werror -Wextra -DLUA_USE_POSIX -DLUA_USEDLOPEN -DLUA_COMPAT_5_2 -std=gnu99 -c *.c
rm lua.o luac.o
 ar rcu liblua53_ios.a *.o
```


# Building Lua static library for Linux AArch64

```sh
# assume cross compiler for aarch64 is available
aarch64-linux-gnu-gcc -O2 -Wall -Werror -Wextra -DLUA_USE_POSIX -DLUA_USEDLOPEN -DLUA_COMPAT_5_2 -std=gnu99 -c *.c
rm lua.o
rm luac.o
aarch64-linux-gnu-ar rcD liblua53_linux_aarch64.a *.o
```

```

`Config/FilterPlugin.ini`:

```ini
[FilterPlugin]
/Docs/...
/Tutorials/...

```

`Content/Scripts/submodules/test004.lua`:

```lua
return 17.2230
```

`Content/Scripts/test001.lua`:

```lua
return 22
```

`Content/Scripts/test002.lua`:

```lua
return 30
```

`Content/Scripts/test003.lua`:

```lua
return broken()
```

`Content/Scripts/test011.lua`:

```lua
return require('test005')
```

`Content/Scripts/trackedmodules/test005.lua`:

```lua
return 'i am tracked'
```

`Docs/LuaBlueprintFunctionLibrary.md`:

```md
# LuaBlueprintFunctionLibrary

This is the BlueprintFunctionLibrary for accessing the LuaMachine api from both C++ and Blueprints.

```cpp
#include "LuaMachine/Public/LuaBlueprintFunctionLibrary.h"
```

## FLuaValue LuaCreateString(FString String)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaCreateString(FString String);
```

Create a new lua string from an Unreal FString

## FLuaValue LuaCreateNumber(float Value)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaCreateNumber(float Value);
```

Create a new Lua Number from an Unreal float

## FLuaValue LuaCreateInteger(int32 Value)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaCreateInteger(int32 Value);
```

Create a new Lua Integer from an Unreal int32

## FLuaValue LuaCreateBool(bool bInBool)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaCreateBool(bool bInBool);
```

Create a new Lua Integer from an Unreal boolean

## FLuaValue LuaCreateTable(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State)
  
```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static FLuaValue LuaCreateTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State);
```

Create a new Lua Table in the specific LuaState. The passed WorldContext will became the CurrentWorld for the LuaState (so you can call GetWorld() on the LuaState itself)

## FLuaValue LuaCreateObject(UObject* InObject)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaCreateObject(UObject* InObject);
```

Create a new Lua userdata pointing to an Unreal UObject

## FLuaValue LuaGetGlobal(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FString Name)
 
```cpp
UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject"))
static FLuaValue LuaGetGlobal(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FString Name);
```

Get 'Name' from the Global Table. Name can be in the dotted form to specify subpaths (example: package.path)

## LuaSetGlobal(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FString Name, FLuaValue Value)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static void LuaSetGlobal(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FString Name, FLuaValue Value);
```

Assign 'Value' to 'Name' in the Global Table. Name can be in the dotted form to specify subpaths (example: package.path)

## FLuaValue LuaTableGetField(FLuaValue Table, FString Key)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaTableGetField(FLuaValue Table, FString Key);
```

Get a value from a lua table

## FLuaValue LuaTableGetByIndex(FLuaValue Table, int32 Index)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static FLuaValue LuaTableGetByIndex(FLuaValue Table, int32 Index);
```

Get a value from a lua table/array using an index

## TArray\<FLuaValue\> LuaTableGetKeys(FLuaValue Table)
  
 ```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static TArray<FLuaValue> LuaTableGetKeys(FLuaValue Table);
 ```
 
 Get the list of keys in a table
 
## TArray\<FLuaValue\> LuaTableGetValues(FLuaValue Table)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static TArray<FLuaValue> LuaTableGetValues(FLuaValue Table);
```

Get the list of values in a table

## FLuaValue LuaTableSetField(FLuaValue Table, FString Key, FLuaValue Value)

```cpp
UFUNCTION(BlueprintCallable)
static FLuaValue LuaTableSetField(FLuaValue Table, FString Key, FLuaValue Value);
```

Set the field of a table

##  FLuaValue LuaGlobalCall(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FString Name, TArray\<FLuaValue\> Args)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"))
static FLuaValue LuaGlobalCall(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FString Name, TArray<FLuaValue> Args);
```

Call a function by its name from the global table

## FLuaValue LuaGlobalCallValue(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FLuaValue Value, TArray\<FLuaValue\> Args)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"))
static FLuaValue LuaGlobalCallValue(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value, TArray<FLuaValue> Args);
```

Call a value in the specified State

##  FLuaValue LuaValueCall(FLuaValue Value, TArray\<FLuaValue\> Args)

```cpp
UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"))
static FLuaValue LuaValueCall(FLuaValue Value, TArray<FLuaValue> Args);
```

Call a value

##  TArray\<FLuaValue\> LuaGlobalCallMulti(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FString Name, TArray\<FLuaValue\> Args)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"))
static TArray<FLuaValue> LuaGlobalCallMulti(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FString Name, TArray<FLuaValue> Args);
```

Call a function by its name from the global table and returns multiple values

## TArray\<FLuaValue\> LuaGlobalCallValueMulti(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FLuaValue Value, TArray\<FLuaValue\> Args)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"))
static TArray<FLuaValue> LuaGlobalCallValueMulti(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value, TArray<FLuaValue> Args);
```

Call a value in the specified State and returns multiple values

##  TArray\<FLuaValue\> LuaValueCallMulti(FLuaValue Value, TArray\<FLuaValue\> Args)

```cpp
UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"))
static TArray<FLuaValue> LuaValueCallMulti(FLuaValue Value, TArray<FLuaValue> Args);
```

Call a value and returns multiple values

## int32 LuaValueLength(FLuaValue Value)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static int32 LuaValueLength(FLuaValue Value);
```

Get the length of a value (equivalent to the lua '#')

## int32 LuaGetTop(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure, meta = (WorldContext = "WorldContextObject"))
static int32 LuaGetTop(UObject* WorldContextObject, TSubclassOf<ULuaState> State);
```

Get the stack top of the specified State. Useful for debugging/testing

## FLuaValue LuaRunFile(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, FString Filename, bool bIgnoreNonExistent)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static FLuaValue LuaRunFile(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FString Filename, bool bIgnoreNonExistent);
```

Run the specified file (relative to the Content/ directory) in the specified State.

## FLuaValue LuaRunCodeAsset(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State, ULuaCode* CodeAsset)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static FLuaValue LuaRunCodeAsset(UObject* WorldContextObject, TSubclassOf<ULuaState> State, ULuaCode* CodeAsset);
```

Run the specified Code Asset in the specified State.

## int32 LuaGetUsedMemory(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure, meta = (WorldContext = "WorldContextObject"))
static int32 LuaGetUsedMemory(UObject* WorldContextObject, TSubclassOf<ULuaState> State);
```

Get the used memory (in Kbytes) of the specified Lua State.

## void LuaGCCollect(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static void LuaGCCollect(UObject* WorldContextObject, TSubclassOf<ULuaState> State);
```

Triggers Lua GC

## void LuaGCStop(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static void LuaGCStop(UObject* WorldContextObject, TSubclassOf<ULuaState> State);
```

Disable automatic execution of the lua GC

## void LuaGCRestart(UObject* WorldContextObject, TSubclassOf\<ULuaState\> State)

```cpp
UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
static void LuaGCRestart(UObject* WorldContextObject, TSubclassOf<ULuaState> State);
```

Re-enable automatic execution of the lua GC

## bool LuaValueIsNil(FLuaValue Value)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static bool LuaValueIsNil(FLuaValue Value);
```

check if a LuaValue is nil

## bool LuaValueIsTable(FLuaValue Value)

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
static bool LuaValueIsTable(FLuaValue Value);
```

check if a LuaValue is a table

## Autocasting

```cpp
UFUNCTION(BlueprintPure, meta=(BlueprintAutocast))
static FString Conv_LuaValueToString(FLuaValue Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static FText Conv_LuaValueToText(FLuaValue Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static UObject* Conv_LuaValueToObject(FLuaValue Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static UClass* Conv_LuaValueToClass(FLuaValue Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static FLuaValue Conv_ObjectToLuaValue(UObject* Object);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static FLuaValue Conv_FloatToLuaValue(float Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static int32 Conv_LuaValueToInt(FLuaValue Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static float Conv_LuaValueToFloat(FLuaValue Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static FLuaValue Conv_IntToLuaValue(int32 Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static FLuaValue Conv_StringToLuaValue(FString Value);

UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
static bool Conv_LuaValueToBool(FLuaValue Value);
```

```

`Docs/LuaComponent.md`:

```md
# LuaComponent

This is an ActorComponent allowing you to expose Actor's related data to the Lua Virtual Machine.

The Component itself will be mapped to a lua userdata on a specific LuaState with its virtual table (and metatable)

![LuaComponent](Screenshots/LuaComponent.PNG?raw=true "LuaComponent")

Create a new lua script with the following content:

```lua
actor = {}

function actor:get_hp()
    self.name = 'test'
    print(self)
    self.hp = self.hp + 1
    return self.hp
end
```

Note the colon-syntax for implementing OOP style programming. Basically the LuaComponent will automatically pass the userdata as the first argument of actor.get_hp:

![LuaComponent2](Screenshots/LuaComponent2.PNG?raw=true "LuaComponent2")

While the game runs, you can see the "Table" property being updated from lua:

![LuaComponent3](Screenshots/LuaComponent3.PNG?raw=true "LuaComponent3")

## Metatable

You can specify a metatable for the LuaComponent. As an example you may want to implement a "__tostring" function so when doing

```lua
print(self)
```

you can get a meaningful value:

![LuaComponent4](Screenshots/LuaComponent4.PNG?raw=true "LuaComponent4")

![LuaComponent5](Screenshots/LuaComponent5.PNG?raw=true "LuaComponent5")

## LuaComponent Interactions

When passing UObject's as LuaValue, they are incapsulated as userdata, so technically (by default) you cannot do anything relevant via Lua (except for passing them as arguments to functions). LuaComponents instead, get a proper metatable exposing the values set in the Table property. A Common pattern is to return the LuaComponent of an Actor to Lua, instead of the actor itself:

![PlayerToLuaComponent](Screenshots/PlayerToLuaComponent.PNG?raw=true "PlayerToLuaComponent")

Note that you can eventually assign an automatic metatable to UObjects too, using the LuaState UserData MetaTable features:
https://github.com/rdeioris/LuaMachine/blob/master/Tutorials/ReflectionShell.md

## Exposed Functions

### LuaCallFunction

```cpp
UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"))
FLuaValue LuaCallFunction(FString FunctionName, TArray<FLuaValue> Args, bool bGlobal);
```

Call a Lua function by its name. If bGlobal is false, the name will be searched in the component-associated virtual table.
The userdata is passed as the first argument.

### LuaCallValue

```cpp
UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"))
FLuaValue LuaCallValue(FLuaValue Value, TArray<FLuaValue> Args);
```

Takes a callable LuaValue and execute it passing userdata as the first argument.

### LuaGetField

```cpp
UFUNCTION(BlueprintCallable, BlueprintPure)
FLuaValue LuaGetField(FString Name);
```

Get a field value from the userdata virtual table

### LuaSetField

```cpp
UFUNCTION(BlueprintCallable)
void LuaSetField(FString Name, FLuaValue Value);
```

Set a field in the userdata virtual table

## Exposed Events

### OnLuaError

Triggered when the lua virtual machine generates an error when triggered from the LuaComponent. The error string is passed as the event argument

```

`Docs/LuaCoroutines.md`:

```md
# Using Lua Coroutines

Coroutines in lua are "interruptable" functions: they can 'suspend' themselves and can be 'resumed' by another coroutine or from the main code:

```lua
coro = coroutine.create(function()
  -- suspend function (without returning values)
  coroutine.yield()
  -- suspend returning 5 values
  coroutine.yield('one', 'two', 'three', 'four', 'five')
  -- suspend returning 1 value
  coroutine.yield(17)
  -- suspend returning 1 value
  coroutine.yield('ended')
end)

-- run the coroutine until the first yield
alive = coroutine.resume(coro)

-- ... until second yield (it returns five values)
alive, one, two, three, four, five = coroutine.resume(coro)

-- ... until third yield
alive, seventeen = coroutine.resume(coro)

-- ... the last yield
alive, ended = coroutine.resume(coro)

-- complete the coroutine
alive = coroutine.resume(coro)

-- this time 'alive' will be 'false' as the coroutine is 'dead' (it has finished its work)
alive = coroutine.resume(coro)
```

Note that albeit coroutine.yield() can be called without arguments, the coroutine.resume() function will always get the first return value as a boolean specifying if the coroutine is still alive or not.

More infos can be found here:

https://www.lua.org/manual/5.3/manual.html#2.6

Coroutines maps to native lua objects named 'threads'. Lua Threads are fully supported by the FLuaValue USTRUCT, so you can create a coroutine from lua and pass it to Unreal Engine functions:


![Coroutine](Screenshots/Coroutine.PNG?raw=true "Coroutine")

The BeginPlay event will create a new coroutine (a thread LuaValue) and stores it in a blueprint variable.

At each tick the coroutine.resume() lua function is called passing it the coroutine as the first argument. Note the usage of the LuaGlobalCallMulti node as it allows to receive multiple return values. Remember that the first return value of coroutine.resume() is always the 'status' of the coroutine (true is alive, false is dead)

```

`Docs/ReflectionAPI.md`:

```md
# The LuaMachine Reflection API

While 'safety' of scripting api exposure is one of the main objective of LuaMachine, sometimes accessing the reflection api of Unreal Engine is pretty useful (and often a quick way for exposing scripting when you are not worried about giving too much power to users)

Albeit the api is usable from blueprints, it is strongly suggested to go to C++ when defining more advanced states.

## Converting between structs and Lua tables

The reflection API is pretty big, so before going into a more-or-less-useful implementation of Lua Reflection, we will cover some low-level details.

The first one is the automatic conversion between USTRUCTs and lua tables. The following 3 template functions allows easy conversion from any USTRUCT to an FLuaValue and the opposite.

```cpp
template<class T>
FLuaValue StructToLuaValue(T& InStruct);

template<class T>
T LuaValueToStruct(FLuaValue& LuaValue);

template<class T>
T LuaValueToBaseStruct(FLuaValue& LuaValue)
```

Let's implement a SetActorLocation() wrapper for a LuaState:

```cpp
#include "StructManagerLuaState.h"
#include "GameFramework/Actor.h"

UStructManagerLuaState::UStructManagerLuaState()
{
	Table.Add("set_actor_location", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UStructManagerLuaState, SetActorLocation)));
}

FLuaValue UStructManagerLuaState::SetActorLocation(FLuaValue Actor, FLuaValue Location)
{
	AActor* ActorObject = Cast<AActor>(Actor.Object);
	if (ActorObject)
	{
		FHitResult Hit;
		// FVector is a base type (like FRotator, FQuat, ...) , so we need to use LuaValueToBaseStruct instead of LuaValueToStruct
		ActorObject->SetActorLocation(LuaValueToBaseStruct<FVector>(Location), true, &Hit);
		// convert the FHitResult struct to a lua table
		return StructToLuaValue(Hit);
	}
	// nil
	return FLuaValue();
}
```

## Getting/Setting properties by name

The following c++/blueprint functions allow to access the Unreal properties using the reflection system:

```cpp
UFUNCTION(BlueprintCallable, Category = "Lua")
FLuaValue GetLuaValueFromProperty(UObject* InObject, const FString& PropertyName);

UFUNCTION(BlueprintCallable, Category = "Lua")
bool SetPropertyFromLuaValue(UObject* InObject, const FString& PropertyName, FLuaValue Value);
```

Properties Values are always converted to FLuaValue.

This is a simple (and pretty useless) example:

```cpp
void UStructManagerLuaState::SetActorProperty(FLuaValue Actor, FLuaValue Property, FLuaValue Value)
{
	AActor* ActorObject = Cast<AActor>(Actor.Object);
	if (ActorObject)
	{
		SetPropertyFromLuaValue(ActorObject, Property.ToString(), Value);
	}
}
```

Delegates are automatically managed as lua functions:

lua example for setting a delegate (assuming the previous defined UStructManagerLuaState::SetActorProperty has been exposed as 'set_actor_property') :

```lua
function setup(actor)
  set_actor_property(actor, 'OnActorHit', function(me, other, normal, hitresult)
    print('hit with', other)
  end
  )
end
```

## Implementing a LuaState that automatically exposes everything to the Lua VM

This is probably the reason you are reading this page ;)

In the following lines i will show you a 'simple' LuaState that automatically uses the Unreal reflection to expose UObject, UFunction, Properties, Structs, Delegates directly to lua without additional steps (in addition to assigning a lua name/variable to them when required).

Let's start by defining the header (LuaReflectionState.h):

```cpp
#pragma once

#include "CoreMinimal.h"
#include "LuaState.h"
#include "LuaReflectionState.generated.h"

UCLASS()
class ULuaReflectionState : public ULuaState
{
	GENERATED_BODY()

public:
	ULuaReflectionState();

protected:
	void LuaStateInit() override;

	// __index(object, key) -> returning 1 value
	LUACFUNCTION(ULuaReflectionState, MetaMethodIndex, 1, 2);

	// __newindex(object, key, value)
	LUACFUNCTION(ULuaReflectionState, MetaMethodNewIndex, 0, 3);

	// __eq(object1, object2) -> returning bool
	LUACFUNCTION(ULuaReflectionState, MetaMethodEq, 1, 2);

	// __string(object) -> returning string
	LUACFUNCTION(ULuaReflectionState, MetaMethodToString, 1, 1);
};
```

The new (and most important) stuff here is the usage of the LUACFUNCTION definition.

Here we are defining 4 metamethods to be called whenever an Unreal object is passed around in the lua state. UObjects are mapped to userdata, so this method defines what to do when using them. As an example, if the 'mannequin' lua variable is mapped to a Character, we want to make it jump by calling mannequin.Jump(). So our system needs to resolve Jump as a function and call it.

We cannot use plain UFunctions for those metamethods (as they are userdata under the hood), so we need to code them using lower level LUA c api. The LUACFUNCTION wraps those low-level functions in Unreal C++ api-friendly ones.

Now let's define the cpp part (LuaReflectionState.cpp):

```cpp
#include "LuaReflectionState.h"
#include "LuaBlueprintFunctionLibrary.h"

ULuaReflectionState::ULuaReflectionState()
{
	// allow to call native UFunctions with implicit FLuaValue conversions
	bRawLuaFunctionCall = true;
}

void ULuaReflectionState::LuaStateInit()
{
	UserDataMetaTable = CreateLuaTable();
	UserDataMetaTable.SetField("__index", ULuaReflectionState::MetaMethodIndex_C);
	UserDataMetaTable.SetField("__newindex", ULuaReflectionState::MetaMethodNewIndex_C);
	UserDataMetaTable.SetField("__eq", ULuaReflectionState::MetaMethodEq_C);
	UserDataMetaTable.SetField("__tostring", ULuaReflectionState::MetaMethodToString_C);
}

TArray<FLuaValue> ULuaReflectionState::MetaMethodIndex(TArray<FLuaValue> LuaArgs)
{
	TArray<FLuaValue> ReturnValues;

	UObject* Object = LuaArgs[0].Object;
	FString Key = LuaArgs[1].ToString();

	// skip nullptr and classes
	if (!Object || Object->IsA<UClass>())
	{
		return ReturnValues;
	}

	ELuaReflectionType ReflectionType = ELuaReflectionType::Unknown;
	ULuaBlueprintFunctionLibrary::GetLuaReflectionType(Object, Key, ReflectionType);

	if (ReflectionType == ELuaReflectionType::Property)
	{
		ReturnValues.Add(GetLuaValueFromProperty(Object, Key));
	}
	else if (ReflectionType == ELuaReflectionType::Function)
	{
		ReturnValues.Add(FLuaValue::FunctionOfObject(Object, FName(Key)));
	}

	return ReturnValues;
}

TArray<FLuaValue> ULuaReflectionState::MetaMethodNewIndex(TArray<FLuaValue> LuaArgs)
{
	TArray<FLuaValue> ReturnValues;

	UObject* Object = LuaArgs[0].Object;
	FString Key = LuaArgs[1].ToString();
	FLuaValue Value = LuaArgs[2];

	// skip nullptr and classes
	if (!Object || Object->IsA<UClass>())
	{
		return ReturnValues;
	}

	ELuaReflectionType ReflectionType = ELuaReflectionType::Unknown;
	ULuaBlueprintFunctionLibrary::GetLuaReflectionType(Object, Key, ReflectionType);

	if (ReflectionType == ELuaReflectionType::Property)
	{
		SetPropertyFromLuaValue(Object, Key, Value);
	}

	return ReturnValues;
}

TArray<FLuaValue> ULuaReflectionState::MetaMethodEq(TArray<FLuaValue> LuaArgs)
{
	TArray<FLuaValue> ReturnValues;

	UObject* Object = LuaArgs[0].Object;
	UObject* OtherObject = LuaArgs[1].Object;

	if (!Object || !OtherObject)
	{
		ReturnValues.Add(FLuaValue(false));
	}
	else
	{
		ReturnValues.Add(FLuaValue(Object == OtherObject));
	}

	return ReturnValues;
}

TArray<FLuaValue> ULuaReflectionState::MetaMethodToString(TArray<FLuaValue> LuaArgs)
{
	TArray<FLuaValue> ReturnValues;

	UObject* Object = LuaArgs[0].Object;

	// skip nullptr and classes
	if (!Object || Object->IsA<UClass>())
	{
		return ReturnValues;
	}

	ReturnValues.Add(Object->GetFullName());

	return ReturnValues;
}
```

We are now ready for building a simple logic in lua (put this in a script or a LuaCodeAsset):

```lua
mannequin.OnActorBeginOverlap = function(me, other)
  print(tostring(me) .. ' colliding with ' .. tostring(other))
  other.K2_AddActorLocalRotation({Yaw=10, Pitch=0, Roll=0})
end

mannequin.Jump()
```

Here we have a script that assumes a character can overlap with a (movable) object that will be rotated of 10 degrees on overlapping.

You can run this script in the LuaReflectionState using a blueprint. The only missing part is assigning your character to the lua 'mannequin' variable. For doing this automatically just add to the character a LuaGlobalNameComponent on which you can specify the state and the name.

Notes:

* You do not need to attach LuaComponents to actors (everything is automatic)
* You can attach multiple LuaGlobalNameComponents on the same actor (allowing it to be available on multiple states or with multiple names)
* The LuaGlobalNameComponent is super easy, just give it a look to adapt it to more complex scenario
* The LuaReflectionState class is not part of the official sources to encourage users/developers to implement their own solutions (like hiding dangerous methods or exposing subsets of them)

```

`Docs/TipsAndTricks.md`:

```md
# Tips & Tricks

In this page users can publish their c++ snippets (please make pull requests with your credits)

## Running lua files recursively from a directory and get their return value

Author: Roberto De Ioris

C++/UFUNCTION code:

```cpp
#include "HAL/FileManager.h"

ULuaStateOrLuaPackage::ULuaStateOrLuaPackage()
{
	Table.Add("scan_and_run", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaStateOrLuaPackage, ScanAndRunLuaScripts)));
}

TArray<FLuaValue> ULuaStateOrLuaPackage::ScanAndRunLuaScripts(FLuaValue Directory)
{
	TArray<FLuaValue> Results;
	TArray<FString> Filenames;
	IFileManager::Get().FindFilesRecursive(Filenames, *Directory.ToString(), TEXT("*.lua"), true, false);

	for (FString Filename : Filenames)
	{
		Results.Add(ULuaBlueprintFunctionLibrary::LuaRunNonContentFile(GetWorld(), GetLuaState(), Filename, false));
	}

	return Results;
}
```

Lua script:

```lua
items = {foobar.scan_and_run('D:/luascripts')}

for _, ret in ipairs(items) do
  print(ret)
end
```

## Wrapping Vectors in Lua tables with math support via metatables

The Goal:

```lua
a = vector:new(1,2,3)
b = vector:new(4,5,6)

print(a)
print(b)

print(a + b)
```

The Implementation:

(ULuaVector is a subclass of ULuaBlueprintPackage and must be added to the LuaState Blueprint Package Table as 'vector')

```cpp
#include "LuaVector.h"
#include "LuaBlueprintFunctionLibrary.h"

ULuaVector::ULuaVector()
{
	Table.Add("new", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaVector, VectorNew)));
	Table.Add("__add", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaVector, VectorAdd)));
	Table.Add("__tostring", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaVector, VectorStr)));
}

FLuaValue ULuaVector::VectorNew(FLuaValue SelfPackage, FLuaValue X, FLuaValue Y, FLuaValue Z)
{
	return BuildVector(FVector(X.ToFloat(), Y.ToFloat(), Z.ToFloat()));
}

FLuaValue ULuaVector::VectorAdd(FLuaValue A, FLuaValue B)
{
	return BuildVector(ULuaBlueprintFunctionLibrary::LuaTableToVector(A) + ULuaBlueprintFunctionLibrary::LuaTableToVector(B));
}

FLuaValue ULuaVector::VectorStr(FLuaValue LuaVector)
{
	return ULuaBlueprintFunctionLibrary::LuaTableToVector(LuaVector).ToString();
}

FLuaValue ULuaVector::BuildVector(FVector Vector)
{
	FLuaValue NewTable = ULuaBlueprintFunctionLibrary::LuaCreateTable(GetWorld(), GetLuaState());
	NewTable.SetField("x", Vector.X);
	NewTable.SetField("y", Vector.Y);
	NewTable.SetField("z", Vector.Z);

	NewTable.SetMetaTable(GetSelfLuaTable());

	return NewTable;
}
```

## Mapping BlueprintFunctionLibrary to UserData

The Goal:

```lua
kismet_math = bpfl.require('KismetMathLibrary')

print(kismet_math.Abs(-17.3))

print(kismet_math.Add_DoubleDouble(17, 0.3))

print(kismet_math.Add_VectorFloat({1,2,3}, 0.3).X)
```

'bpfl' (shortcut for 'Blueprint Function Library') will be the package to get a userdata from a BlueprintFunctionLibrary ('KismetMathLibrary' on the example, but can be anything)

```cpp
UCLASS()
class UBPFLLuaBlueprintPackage : public ULuaBlueprintPackage
{
	GENERATED_BODY()
public:
	UBPFLLuaBlueprintPackage();

	UFUNCTION()
	FLuaValue RequireBlueprintFunctionLibrary(FLuaValue LibraryName);
};
```

```cpp
UBPFLLuaBlueprintPackage::UBPFLLuaBlueprintPackage()
{
	Table.Add("require", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UBPFLLuaBlueprintPackage, RequireBlueprintFunctionLibrary)));
}

FLuaValue UBPFLLuaBlueprintPackage::RequireBlueprintFunctionLibrary(FLuaValue LibraryName)
{
	UClass* FoundClass = Cast<UClass>(StaticFindObject(UClass::StaticClass(), ANY_PACKAGE, *LibraryName.ToString()));
	if (FoundClass)
	{
		ULuaUserDataBPFL* UserDataBPFL = NewObject<ULuaUserDataBPFL>(GetLuaStateInstance());
		UserDataBPFL->InitializeWithClass(FoundClass);
		return FLuaValue(UserDataBPFL);
	}
	return FLuaValue();
}
```

The RequireBlueprintFunctionLibrary lua exposed UFunction will search for the specified library name using the reflection system, and will create a ULuaUserDataBPFL (check below) that will keep a reference to the blueprint library

```cpp
UCLASS()
class ULuaUserDataBPFL : public ULuaUserDataObject
{
	GENERATED_BODY()
	
public:
	void InitializeWithClass(UClass* InClass);

	virtual FLuaValue ReceiveLuaMetaIndex_Implementation(FLuaValue Key) override;

protected:
	UPROPERTY()
	UClass* BPFLClass;
};
```

```cpp
void ULuaUserDataBPFL::InitializeWithClass(UClass* InClass)
{
	BPFLClass = InClass;
}

FLuaValue ULuaUserDataBPFL::ReceiveLuaMetaIndex_Implementation(FLuaValue Key)
{
	UFunction* Function = BPFLClass->FindFunctionByName(*Key.ToString());
	if (Function)
	{
		return FLuaValue::FunctionOfObject(BPFLClass->GetDefaultObject(), Function->GetFName());
	}

	return FLuaValue();
}
```

The key here is the ReceiveLuaMetaIndex_Implementation override, that will return the UFunction ptr of the supplied function name (if it exists).

You can now map the UBPFLLuaBlueprintPackage to the bpfl package in your LuaState configuration and (this is required) you need to enable the bRawLuaFunctionCall too: this will allow the state to automatically convert UFunction arguments to lua values.

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 Roberto De Ioris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LuaMachine.uplugin`:

```uplugin
{
  "FileVersion": 3,
  "Version": 1,
  "VersionName": "20250604",
  "FriendlyName": "LuaMachine",
  "Description": "Expose a Lua api for your project",
  "Category": "Scripting",
  "CreatedBy": "Roberto De Ioris",
  "CreatedByURL": "https://github.com/rdeioris",
  "DocsURL": "https://github.com/rdeioris/LuaMachine",
  "MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/48a58a495c3f4d788fc9195bceff2ec8",
  "SupportURL": "https://github.com/rdeioris/LuaMachine",
  "CanContainContent": true,
  "IsBetaVersion": false,
  "Installed": false,
  "Modules": [
    {
      "Name": "LuaMachine",
      "Type": "Runtime",
      "LoadingPhase": "PreDefault",
      "WhitelistPlatforms": [
        "Mac",
        "Win64",
        "Linux",
        "LinuxArm64",
        "Android",
        "IOS",
      ]
    },
    {
      "Name": "LuaMachineEditor",
      "Type": "Editor",
      "LoadingPhase": "Default",
      "WhitelistPlatforms": [
        "Linux",
        "Mac",
        "Win64"
      ]
    }
  ]
}

```

`README.md`:

```md
# LuaMachine
![LuaMachine Logo](Docs/LuaMachine_Logo.png?raw=true "LuaMachine Logo")

Unreal Engine Plugin for adding Lua scripting to your projects.

If you want modders to customize your game/project, or you need to allow game designers to script parts of the logic, or more generally you want a framework for adding lua scripting capabilities to your projects, this plugin is for you.

![LuaMachine](Docs/Screenshots/SyntaxColor.PNG?raw=true "LuaMachine")

Note: The master branch is focused on Unreal Engine 5, if you need Unreal Engine 4 support use the ue4 branch.

Experimental LuaU (https://luau.org/) support is available (for Windows) in the "luau" branch.

## How it works

Contrary to the other Unreal Engine Lua plugins, this one does not try to automatically expose the Unreal Engine api, but completely hides it giving to the user/scripter only the features the developer decided to include (via Blueprints or C++).
An advanced api for using/abusing Unreal Engine Reflection is included too.

Currently Windows 64bit, Mac, Linux x86_64 (both Runtime and Editor), Linux AArch64, Android (32 and 64 bit) and iOS are supported. Minimal supported Engine version is 4.20.

## Discord Channel

Join the LuaMachine Discord channel: https://discord.gg/eTXDfEU

## Marketplace

Albeit fully open source and free, you can find the plugin in the Unreal Engine Marketplace for about 30$. If you want to sponsor the project consider buying it:

https://www.unrealengine.com/marketplace/en-US/product/luamachine

## Becoming a patron

Consider sponsoring the project using patreon: https://www.patreon.com/rdeioris

## Quickstart

In this fast (and useless) example we will print a string generated by a Lua script.

Install the LuaMachine plugin by downloading it from the official github releases page (free, but you need to compile it) or from the Marketplace (ready to use, about 30$): 

https://github.com/rdeioris/LuaMachine/releases/

https://www.unrealengine.com/marketplace/luamachine

To compile from sources, decompress the zip file in the Plugins/ directory of your project (create it if it does not exist) and restart the Unreal Editor. (if you want to manually compile it, ensure C++ is enabled in your project and regenerate the solution/xcode file)

Open your favourite editor for lua scripting and create a file into the project Content/ directory (call it hello.lua) with the following code:

```lua
current_time = os.date()
return "Hello, i am a lua script, current time is: " .. current_time
```

Now you need to create a new LuaState, it is a special Blueprint representing a Lua Virtual Machine (you can have multiple Lua virtual machines in the same project). Just add a new blueprint inheriting from LuaState and name as you want (QuickLuaState is a good candidate).

Finally open your Level Blueprint and add the following nodes:

![Quickstart](Docs/Screenshots/Quickstart.PNG?raw=true "Quickstart")

If you play the game, you will see the Lua string printed on top.

The LuaRunFile node will execute a lua file (relative to the Content/ directory) in the specified LuaState (QuickLuaState in our case) and will return the value returned by the script itself as a LuaValue UStruct. The plugin offers a bunch of operations you can apply to LuaValue's, in this example we simply converted the value to an Unreal String.

Time to something more complex, edit your hello.lua script:

```lua

function call_me_from_unreal(number)
  return number * 2
end

current_time = os.date()
return "Hello, i am a lua script, current time is: " .. current_time
```

Now the script will add the call_me_from_unreal function to the global table:

![Quickstart2](Docs/Screenshots/Quickstart2.PNG?raw=true "Quickstart2")

The LuaGlobalCall node calls a function from the global table passing arguments as an array of LuaValue's.

So, now we know how to call lua functions from Unreal, time to do the opposite.

Open the QuickLuaState Blueprint you created before. This Blueprint exposes lot of different fields to configure your Lua Virtual Machine:

![Quickstart3](Docs/Screenshots/Quickstart3.PNG?raw=true "Quickstart3")

The Table 'TMap' allows you to add items to the Lua global table. We will first try by adding a string and a number (float):

![Quickstart4](Docs/Screenshots/Quickstart4.PNG?raw=true "Quickstart4")

Note that we set the "Lua Filename" field to hello.lua, in this way we can avoid to call the LuaRunFile node as hello.lua will be executed during the spawn of the QuickLuaState.

Let's modify our Level Blueprint:

![Quickstart5](Docs/Screenshots/Quickstart5.PNG?raw=true "Quickstart5")

The hello.lua script is loaded automatically, while the LuaGetGlobal nodes, retrieve the specific fields from the Lua global table, and return them as LuaValue's

Time to expose an Unreal UFunction to Lua: just add a Function to QuickLuaState:

![Quickstart6](Docs/Screenshots/Quickstart6.PNG?raw=true "Quickstart6")

and expose it in the Table TMap:

![Quickstart7](Docs/Screenshots/Quickstart7.PNG?raw=true "Quickstart7")

calling get_player_location() from lua, will trigger the QuickLuaState's GetPlayerPawnLocation(). Note that not all of the UFunction's can be exposed: if they take or return values they must be LuaValue's

Let's update hello.lua

```lua
function call_me_from_unreal(number)
    location = get_player_location()
    print(location.x, location.y, location.z)
    return number * 2 + location.x + location.y + location.z
end

current_time = os.date()
return "Hello, i am a lua script, current time is: " .. current_time
```

and the Level Blueprint:

![Quickstart8](Docs/Screenshots/Quickstart8.PNG?raw=true "Quickstart8")

Please check the print() function: it is automatically mapped to the Unreal Output Log by the plugin.

Now you should have an idea of the plugin potential, continue reading for more infos.

## LuaState

A LuaState (ULuaState C++ class) represents a single Lua virtual machine (there can be multiple, each one isolated from the others). This is a "singleton" as each LuaState class can have a single instance for the whole process life. (Note that while in the Editor, LuaState's are constantly recreated whenever you enter PIE mode to simplify development)

Having multiple LuaState's allows clean separation of domains: as an example you may want a state for game configuration, another one for game logic and one for the modders. More complex examples include having states dedicated to specific Actors, GameModes or Levels.

LuaState's are loaded on-demand, so you can create dozens of them but they will not start Lua VMs until you need them.

LuaState's can load and execute scripts automatically if you specify the fields "LuaCodeAsset" and/or "LuaFilename". You can load scripts (both in text and bytecode format) from your filesystem (via "LuaFilename"), or from a specific asset exposed by the plugin, named LuaCode (you can specify it with the "LuaCodeAsset" field). The advantage of using filesystem scripts is that you can change them even after the project has been packaged (unless you package them too), while LuaCode assets are directly built in your pak files (as bytecode by default).

### LuaState Properties

* LuaCodeAsset: specify a LuaCode asset to automatically load an execute on spawn
* LuaFileName: specify a script path (relative to Content/) to load and execute on spawn
* Table: TMap<FString, FLuaValue> allows adding FLuaValue's to the Lua VM global table
* RequireTable: TMap<FString, ULuaCode> allows to map LuaCode assets to specific name, so you can call require('name') from your code
* LuaOpenLibs: if true, automatically load the lua standard library on spawn
* AddProjectContentDirToPackage: if true, when doing require('name') will search for 'name.lua' in the Content/ directory
* AppendProjectContentDirToPackage: TArray<FString> allows specifying a list of Content/ subdirectories to search for packages (while doing require('name'))
* OverridePackagePath: (advanced users) allows to modify package.path
* OverridePackageCPath: (advanced users) allows to modify package.cpath
* LogError: enable/disable logging of Lua errors
  
### LuaState Events

The "LuaError" event is exposed by ULuaState.

If defined, it will be triggered whenever the Lua VM generates an error. The Error message is passed as an argument. This is really useful for adding in-game consoles, or to catch specific errors.

### LuaMachine Debugger

A Simple Lua Debugger is included in the plugin (you can find it under the Window/Developer Tools menu)

![Debugger](Docs/Screenshots/Debugger.PNG?raw=true "Quickstart8")

You can control/monitor active LuaStates as well as triggering both Unreal and Lua GC's

### LuaMachine Console

As a great companion for the debugger, each LuaState automatically activates a lua console in your output log window:

![LuaConsole](Docs/Screenshots/LuaConsole.PNG?raw=true "LuaConsole")

LuaConsoles allow multiline input (shift-return for newlines, return for submitting the commands) and are automatically destroyed when the state is destroyed.

Obviously they are only available in the editor.

### LuaState in C++

You can define your LuaState's as C++ classes, this is handy for exposing functions that would be hard to define with blueprints:

```cpp
#pragma once

#include "CoreMinimal.h"
#include "LuaState.h"
#include "AdvancedLuaState.generated.h"

/**
 * 
 */
UCLASS()
class LUATEST420_API UAdvancedLuaState : public ULuaState
{
	GENERATED_BODY()
public:
	UAdvancedLuaState();

	UFUNCTION()
	FLuaValue GetPlayerPawnLocation();

	UFUNCTION()
	FLuaValue GetSimpleString();
	
};
```

```cpp
#include "AdvancedLuaState.h"
#include "Kismet/GameplayStatics.h"
#include "Engine/World.h"
#include "GameFramework/Pawn.h"

UAdvancedLuaState::UAdvancedLuaState()
{
	Table.Add("simple_string", FLuaValue("Test string"));
	Table.Add("get_player_location", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UAdvancedLuaState, GetPlayerPawnLocation)));
	Table.Add("get_simple_string", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UAdvancedLuaState, GetSimpleString)));
}

FLuaValue UAdvancedLuaState::GetPlayerPawnLocation()
{
	FVector Location = UGameplayStatics::GetPlayerPawn(GetWorld(), 0)->GetActorLocation();
	FLuaValue Table = CreateLuaTable();
	Table.SetField("x", FLuaValue(Location.X));
	Table.SetField("y", FLuaValue(Location.Y));
	Table.SetField("z", FLuaValue(Location.Z));

	return Table;
}

FLuaValue UAdvancedLuaState::GetSimpleString()
{
	return FLuaValue("Hello World");
}

```

GET_FUNCTION_NAME_CHECKED is an Unreal Macro for sanitizing UFunction names. Albeit not necessary (the argument is the FName of the function) it is highly suggested to use it to avoid silent errors.

You can call LuaState's offered api using the ULuaBlueprintFunctionLibrary class.

Check its docs here: [LuaBlueprintFunctionLibrary](Docs/LuaBlueprintFunctionLibrary.md)

## LuaValue

LuaValue's are the way Unreal communicates with a specific Lua virtual machine. They contains values that both Lua and your project can use.

This a list of the currently supported values:

* Nil (nil/NULL value)
* Bool (boolean value)
* Integer (integer/int32 value)
* Number (float value)
* String (string/FString value)
* Function (reference to a lua function)
* Table (reference to a lua table)
* UObject (pointer to an Unreal UObject)
* UFunction (pointer to an Unreal UFunction)
* Thread (reference to a lua thread/coroutines)

Note that tables are passed by reference, so technically you can update the same table from both lua and Unreal.

Check [LuaBlueprintFunctionLibrary](Docs/LuaBlueprintFunctionLibrary.md) for infos on how to use the FLuaValue api.

## Shortcut for specifying field names

As a shortcut for reaching long paths in tables, you can use the dot as the separator for field names.

As an example the LuaGetGlobal node, can access the package.path item by simply passing it "package.path" as the field name.

## LuaComponent

ULuaComponent allows to map a table to an ActorComponent

Check its docs here: [LuaComponent](Docs/LuaComponent.md)

## LuaBlueprintPackage

If you have C++/Blueprint functions that you want to expose to multiple LuaStates, consider grouping them in a LuaBlueprintPackage.

Check: https://github.com/rdeioris/LuaMachine/blob/master/Tutorials/JsonLuaBlueprintPackage.md

## LuaUserDataObject

You can create new Lua object types by subclassing ULuaUserDataObject.

check this funny tutorial about exposing the Unreal WebSockets api to Lua: https://github.com/rdeioris/LuaMachine/blob/master/Tutorials/WebSocketsWithLuaUserDataObjects.md

## LuaCodeBox/ULuaMultiLineEditableTextBox

This is a UMG widget for showing/editing lua code with syntax colouring:

![LuaCodeBox](Docs/Screenshots/LuaCodeBox.PNG?raw=true "LuaCodeBox")

The syntax highlighter is available in the FLuaMachineSyntaxHighlighterTextLayoutMarshaller class (so you can reuse it
for building more advanced Slate/UMG widgets)

## Lua Threads/Coroutines

Lua Threads/Coroutines are fully supported

Check dedicated docs here: [LuaCoroutines](Docs/LuaCoroutines.md)

## Packaging

You have various way to use Lua scripting facilities in your packaged project:

### LuaCode for everything

Transform your scripts (just drag them in the content browser) to LuaCode assets and eventually fix the RequireTable. By default they will be byte-compiled. It is highly suggested to "sign" the pak file to avoid pak file modifications. This method does not permit customization of scripts after the build.

### Scripts file packaging

You can include your scripts in the pak file automatically by specifying the directory containing them in the package settings:

![Packaging](Docs/Screenshots/Packaging.PNG?raw=true "Packaging")

Signing the pak file could be a good thing again, in addition to this byte-compiling the scripts could be accomplished with the 'luac' command (included in lua distributions)

### Scripts file inclusion

This is for allowing easy customization of your scripts after the packaging. Basically you include the scripts directories in your Content directory:

![Packaging2](Docs/Screenshots/Packaging2.PNG?raw=true "Packaging2")

## Android deployment

The plugin supports Android systems starting from api 24. Before deploying ensure you have force the right minimal api version:

![Android24](Docs/Screenshots/Android24.PNG?raw=true "Android24")

Cooked LuaCode assets are converted to 32bit size_t at runtime.

## iOS deployment

Nothing special, just ensure to package script files (instead of simply including them)

## Functional Tests

The projects includes various functional tests (all written as blueprints, so they could be useful as examples too).

Just enable the plugin content visualization from the content browser and from the Automator tool execute the Project related tests.

## Tutorials

https://github.com/rdeioris/LuaMachine/blob/master/Tutorials/SimpleDialogueSystem.md

https://github.com/rdeioris/LuaMachine/blob/master/Tutorials/RickAndMortyAPI.md

## C++ Tips & Tricks

https://github.com/rdeioris/LuaMachine/blob/master/Docs/TipsAndTricks.md
	
## Reflection API
	
https://github.com/rdeioris/LuaMachine/blob/master/Docs/ReflectionAPI.md

## Commercial Support

Commercial support is offered by Blitter (based in Rome, Italy), just contact info at blitter.studio or send a private message to rdeioris on the LuaMachine Discord server.

## Sponsors

The LuaMachine logo has been designed by Nicolas Martel (aka. Nogitsu)

```

`Source/LuaMachine/LuaMachine.Build.cs`:

```cs
// Copyright 2018-2023 - Roberto De Ioris

using UnrealBuildTool;

public class LuaMachine : ModuleRules
{
    public LuaMachine(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
        bUseUnity = false;

        PublicIncludePaths.AddRange(
            new string[] {
				// ... add public include paths required here ...
			}
            );


        PrivateIncludePaths.AddRange(
            new string[] {
				// ... add other private include paths required here ...
			}
            );


        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
                "HTTP",
                "Json",
                "PakFile"
				// ... add other public dependencies that you statically link with here ...
			}
            );


        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "CoreUObject",
                "Engine",
                "Slate",
                "SlateCore",
                "UMG",
                "InputCore",
				// ... add private dependencies that you statically link with here ...	
			}
            );


        DynamicallyLoadedModuleNames.AddRange(
            new string[]
            {
				// ... add any modules that your module loads dynamically here ...
			}
            );

        if (Target.bBuildEditor)
        {
            PrivateDependencyModuleNames.AddRange(new string[]{
                "UnrealEd",
                "Projects"
            });
        }

        string ThirdPartyDirectory = System.IO.Path.Combine(ModuleDirectory, "..", "ThirdParty");

        if (Target.Platform == UnrealTargetPlatform.Win64)
        {
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "x64", "liblua53_win64.lib"));
        }

        else if (Target.Platform == UnrealTargetPlatform.Mac)
        {
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "x64", "liblua53_mac.a"));
        }

        else if (Target.Platform == UnrealTargetPlatform.Linux)
        {
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "x64", "liblua53_linux64.a"));
        }

        else if (Target.Platform == UnrealTargetPlatform.LinuxArm64)
        {
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "ARM64", "liblua53_linux_aarch64.a"));
        }

        else if (Target.Platform == UnrealTargetPlatform.Android)
        {
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "ARMv7", "liblua53_android.a"));
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "ARM64", "liblua53_android64.a"));
        }

        else if (Target.Platform == UnrealTargetPlatform.IOS)
        {
            PublicAdditionalLibraries.Add(System.IO.Path.Combine(ThirdPartyDirectory, "ARM64", "liblua53_ios.a"));
        }

    }
}

```

`Source/LuaMachine/Private/LuaBlueprintFunctionLibrary.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaBlueprintFunctionLibrary.h"
#include "LuaComponent.h"
#include "LuaMachine.h"
#include "Runtime/Online/HTTP/Public/Interfaces/IHttpResponse.h"
#include "Runtime/Core/Public/Math/BigInt.h"
#include "Runtime/Core/Public/Misc/Base64.h"
#include "Runtime/Core/Public/Misc/SecureHash.h"
#include "Serialization/JsonSerializer.h"
#include "Engine/Texture2D.h"
#include "IImageWrapper.h"
#include "IImageWrapperModule.h"
#include "IPlatformFilePak.h"
#if ENGINE_MAJOR_VERSION >= 5
#include "HAL/PlatformFileManager.h" 
#else
#include "HAL/PlatformFilemanager.h"
#endif
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION > 0
#include "AssetRegistry/IAssetRegistry.h"
#include "AssetRegistry/AssetRegistryModule.h"
#else
#include "IAssetRegistry.h"
#include "AssetRegistryModule.h"
#endif
#include "Misc/FileHelper.h"
#include "Serialization/ArrayReader.h"
#include "TextureResource.h"

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 5
#include "Engine/BlueprintGeneratedClass.h"
#endif

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateNil()
{
	return FLuaValue();
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateString(const FString& String)
{
	return FLuaValue(String);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateNumber(const float Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateInteger(const int32 Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateInteger64(const int64 Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateBool(const bool bInBool)
{
	return FLuaValue(bInBool);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateObject(UObject* InObject)
{
	return FLuaValue(InObject);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateUFunction(UObject* InObject, const FString& FunctionName)
{
	if (InObject && InObject->FindFunction(FName(*FunctionName)))
	{
		FLuaValue Value = FLuaValue::Function(FName(*FunctionName));
		Value.Object = InObject;
		return Value;
	}

	return FLuaValue();
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	FLuaValue LuaValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return LuaValue;

	return L->CreateLuaTable();
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateLazyTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	FLuaValue LuaValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return LuaValue;

	return L->CreateLuaLazyTable();
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateThread(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value)
{
	FLuaValue LuaValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return LuaValue;

	return L->CreateLuaThread(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaCreateObjectInState(UObject* WorldContextObject, TSubclassOf<ULuaState> State, UObject* InObject)
{
	FLuaValue LuaValue;
	if (!InObject)
		return LuaValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return LuaValue;

	LuaValue = FLuaValue(InObject);
	LuaValue.LuaState = L;
	return LuaValue;
}

void ULuaBlueprintFunctionLibrary::LuaStateDestroy(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;
	FLuaMachineModule::Get().UnregisterLuaState(L);
}

void ULuaBlueprintFunctionLibrary::LuaStateReload(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;
	FLuaMachineModule::Get().UnregisterLuaState(L);
	FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
}

FString ULuaBlueprintFunctionLibrary::Conv_LuaValueToString(const FLuaValue& Value)
{
	return Value.ToString();
}

FVector ULuaBlueprintFunctionLibrary::Conv_LuaValueToFVector(const FLuaValue& Value)
{
	return LuaTableToVector(Value);
}

FRotator ULuaBlueprintFunctionLibrary::Conv_LuaValueToFRotator(const FLuaValue& Value)
{
	return LuaTableToRotator(Value);
}

FName ULuaBlueprintFunctionLibrary::Conv_LuaValueToName(const FLuaValue& Value)
{
	return FName(*Value.ToString());
}

FText ULuaBlueprintFunctionLibrary::Conv_LuaValueToText(const FLuaValue& Value)
{
	return FText::FromString(Value.ToString());
}

UObject* ULuaBlueprintFunctionLibrary::Conv_LuaValueToObject(const FLuaValue& Value)
{
	if (Value.Type == ELuaValueType::UObject)
	{
		return Value.Object;
	}
	return nullptr;
}

UClass* ULuaBlueprintFunctionLibrary::Conv_LuaValueToClass(const FLuaValue& Value)
{
	if (Value.Type == ELuaValueType::UObject)
	{
		UClass* Class = Cast<UClass>(Value.Object);
		if (Class)
			return Class;
		UBlueprint* Blueprint = Cast<UBlueprint>(Value.Object);
		if (Blueprint)
			return Blueprint->GeneratedClass;
	}
	return nullptr;
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_ObjectToLuaValue(UObject* Object)
{
	return FLuaValue(Object);
}


FLuaValue ULuaBlueprintFunctionLibrary::Conv_FloatToLuaValue(const float Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_BoolToLuaValue(const bool Value)
{
	return FLuaValue(Value);
}

int32 ULuaBlueprintFunctionLibrary::Conv_LuaValueToInt(const FLuaValue& Value)
{
	return Value.ToInteger();
}

int64 ULuaBlueprintFunctionLibrary::Conv_LuaValueToInt64(const FLuaValue& Value)
{
	return Value.ToInteger();
}

float ULuaBlueprintFunctionLibrary::Conv_LuaValueToFloat(const FLuaValue& Value)
{
	return Value.ToFloat();
}

bool ULuaBlueprintFunctionLibrary::Conv_LuaValueToBool(const FLuaValue& Value)
{
	return Value.ToBool();
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_IntToLuaValue(const int32 Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_Int64ToLuaValue(const int64 Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_StringToLuaValue(const FString& Value)
{
	return FLuaValue(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_TextToLuaValue(const FText& Value)
{
	return FLuaValue(Value.ToString());
}

FLuaValue ULuaBlueprintFunctionLibrary::Conv_NameToLuaValue(const FName Value)
{
	return FLuaValue(Value.ToString());
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaGetGlobal(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return FLuaValue();

	uint32 ItemsToPop = L->GetFieldFromTree(Name);
	FLuaValue ReturnValue = L->ToLuaValue(-1);
	L->Pop(ItemsToPop);
	return ReturnValue;
}

int64 ULuaBlueprintFunctionLibrary::LuaValueToPointer(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return 0;

	L->FromLuaValue(Value);
	const void* Ptr = L->ToPointer(-1);
	L->Pop();

	return (int64)Ptr;
}

FString ULuaBlueprintFunctionLibrary::LuaValueToHexPointer(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value)
{
	int64 Ptr = LuaValueToPointer(WorldContextObject, State, Value);
	if (FGenericPlatformProperties::IsLittleEndian())
	{
		uint8 BEPtr[8] =
		{
			(uint8)((Ptr >> 56) & 0xff),
			(uint8)((Ptr >> 48) & 0xff),
			(uint8)((Ptr >> 40) & 0xff),
			(uint8)((Ptr >> 32) & 0xff),
			(uint8)((Ptr >> 24) & 0xff),
			(uint8)((Ptr >> 16) & 0xff),
			(uint8)((Ptr >> 8) & 0xff),
			(uint8)((Ptr) & 0xff),
		};
		return BytesToHex((const uint8*)BEPtr, sizeof(int64));
	}
	return BytesToHex((const uint8*)&Ptr, sizeof(int64));
}

FString ULuaBlueprintFunctionLibrary::LuaValueToBase64(const FLuaValue& Value)
{
	return Value.ToBase64();
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaValueFromBase64(const FString& Base64)
{
	return FLuaValue::FromBase64(Base64);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaValueFromUTF16(const FString& String)
{
	TArray<uint8> Bytes;
	if (FGenericPlatformProperties::IsLittleEndian())
	{
		for (int32 Index = 0; Index < String.Len(); Index++)
		{
			uint16 UTF16Char = (uint16)String[Index];
			Bytes.Add((uint8)(UTF16Char & 0xFF));
			Bytes.Add((uint8)((UTF16Char >> 8) & 0xFF));
		}
	}
	else
	{
		for (int32 Index = 0; Index < String.Len(); Index++)
		{
			uint16 UTF16Char = (uint16)String[Index];
			Bytes.Add((uint8)((UTF16Char >> 8) & 0xFF));
			Bytes.Add((uint8)(UTF16Char & 0xFF));
		}
	}
	return FLuaValue(Bytes);
}

FString ULuaBlueprintFunctionLibrary::LuaValueToUTF16(const FLuaValue& Value)
{
	FString ReturnValue;
	TArray<uint8> Bytes = Value.ToBytes();
	if (Bytes.Num() % 2 != 0)
	{
		return ReturnValue;
	}

	if (FGenericPlatformProperties::IsLittleEndian())
	{
		for (int32 Index = 0; Index < Bytes.Num(); Index += 2)
		{
			uint16 UTF16Low = Bytes[Index];
			uint16 UTF16High = Bytes[Index + 1];
			ReturnValue.AppendChar((TCHAR)((UTF16High << 8) | UTF16Low));
		}
	}
	else
	{
		for (int32 Index = 0; Index < Bytes.Num(); Index += 2)
		{
			uint16 UTF16High = Bytes[Index];
			uint16 UTF16Low = Bytes[Index + 1];
			ReturnValue.AppendChar((TCHAR)((UTF16High << 8) | UTF16Low));
		}
	}
	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaValueFromUTF8(const FString& String)
{
	FTCHARToUTF8 UTF8String(*String);
	return FLuaValue((const char*)UTF8String.Get(), UTF8String.Length());
}

FString ULuaBlueprintFunctionLibrary::LuaValueToUTF8(const FLuaValue& Value)
{
	FString ReturnValue;
	TArray<uint8> Bytes = Value.ToBytes();
	Bytes.Add(0);
	return FString(UTF8_TO_TCHAR(Bytes.GetData()));
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaValueFromUTF32(const FString& String)
{
#if ENGINE_MINOR_VERSION >= 25
	FTCHARToUTF32 UTF32String(*String);
	return FLuaValue((const char*)UTF32String.Get(), UTF32String.Length());
#else
	UE_LOG(LogLuaMachine, Error, TEXT("UTF32 not supported in this engine version"));
	return FLuaValue();
#endif
}

FString ULuaBlueprintFunctionLibrary::LuaValueToUTF32(const FLuaValue& Value)
{
#if ENGINE_MINOR_VERSION >= 25
	FString ReturnValue;
	TArray<uint8> Bytes = Value.ToBytes();
	Bytes.Add(0);
	Bytes.Add(0);
	Bytes.Add(0);
	Bytes.Add(0);
	return FString(FUTF32ToTCHAR((const UTF32CHAR*)Bytes.GetData(), Bytes.Num() / 4).Get());
#else
	UE_LOG(LogLuaMachine, Error, TEXT("UTF32 not supported in this engine version"));
	return FString("");
#endif
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaRunFile(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Filename, const bool bIgnoreNonExistent)
{
	FLuaValue ReturnValue;

	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	if (!L->RunFile(Filename, bIgnoreNonExistent, 1))
	{
		if (L->bLogError)
			L->LogError(L->LastError);
		L->ReceiveLuaError(L->LastError);
	}
	else
	{
		ReturnValue = L->ToLuaValue(-1);
	}

	L->Pop();
	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaRunNonContentFile(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Filename, const bool bIgnoreNonExistent)
{
	FLuaValue ReturnValue;

	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	if (!L->RunFile(Filename, bIgnoreNonExistent, 1, true))
	{
		if (L->bLogError)
			L->LogError(L->LastError);
		L->ReceiveLuaError(L->LastError);
	}
	else
	{
		ReturnValue = L->ToLuaValue(-1);
	}

	L->Pop();
	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaRunString(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& CodeString, FString CodePath)
{
	FLuaValue ReturnValue;

	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
	{
		return ReturnValue;
	}

	return L->RunString(CodeString, CodePath);
}

ELuaThreadStatus ULuaBlueprintFunctionLibrary::LuaThreadGetStatus(FLuaValue Value)
{
	if (Value.Type != ELuaValueType::Thread || !Value.LuaState.IsValid())
		return ELuaThreadStatus::Invalid;

	return Value.LuaState->GetLuaThreadStatus(Value);
}

int32 ULuaBlueprintFunctionLibrary::LuaThreadGetStackTop(FLuaValue Value)
{
	if (Value.Type != ELuaValueType::Thread || !Value.LuaState.IsValid())
	{
		return MIN_int32;
	}

	return Value.LuaState->GetLuaThreadStackTop(Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaRunCodeAsset(UObject* WorldContextObject, TSubclassOf<ULuaState> State, ULuaCode* CodeAsset)
{
	FLuaValue ReturnValue;

	if (!CodeAsset)
		return ReturnValue;

	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	if (!L->RunCodeAsset(CodeAsset, 1))
	{
		if (L->bLogError)
			L->LogError(L->LastError);
		L->ReceiveLuaError(L->LastError);
	}
	else {
		ReturnValue = L->ToLuaValue(-1);
	}
	L->Pop();
	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaRunByteCode(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const TArray<uint8>& ByteCode, const FString& CodePath)
{
	FLuaValue ReturnValue;

	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	if (!L->RunCode(ByteCode, CodePath, 1))
	{
		if (L->bLogError)
			L->LogError(L->LastError);
		L->ReceiveLuaError(L->LastError);
	}
	else
	{
		ReturnValue = L->ToLuaValue(-1);
	}
	L->Pop();
	return ReturnValue;
}

UTexture2D* ULuaBlueprintFunctionLibrary::LuaValueToTransientTexture(int32 Width, int32 Height, const FLuaValue& Value, EPixelFormat PixelFormat, bool bDetectFormat)
{
	if (Value.Type != ELuaValueType::String)
	{
		return nullptr;
	}

	IImageWrapperModule& ImageWrapperModule = FModuleManager::LoadModuleChecked<IImageWrapperModule>(TEXT("ImageWrapper"));

	TArray<uint8> Bytes = Value.ToBytes();

	if (bDetectFormat)
	{
		EImageFormat ImageFormat = ImageWrapperModule.DetectImageFormat(Bytes.GetData(), Bytes.Num());
		if (ImageFormat == EImageFormat::Invalid)
		{
			UE_LOG(LogLuaMachine, Error, TEXT("Unable to detect image format"));
			return nullptr;
		}

		TSharedPtr<IImageWrapper> ImageWrapper = ImageWrapperModule.CreateImageWrapper(ImageFormat);
		if (!ImageWrapper.IsValid())
		{
			UE_LOG(LogLuaMachine, Error, TEXT("Unable to create ImageWrapper"));
			return nullptr;
		}

		if (!ImageWrapper->SetCompressed(Bytes.GetData(), Bytes.Num()))
		{
			UE_LOG(LogLuaMachine, Error, TEXT("Unable to parse image data"));
			return nullptr;
		}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
		TArray<uint8> UncompressedBytes;
#else
		const TArray<uint8>* UncompressedBytes = nullptr;
#endif
		if (!ImageWrapper->GetRaw(ERGBFormat::BGRA, 8, UncompressedBytes))
		{
			UE_LOG(LogLuaMachine, Error, TEXT("Unable to get raw image data"));
			return nullptr;
		}
		PixelFormat = EPixelFormat::PF_B8G8R8A8;
		Width = ImageWrapper->GetWidth();
		Height = ImageWrapper->GetHeight();
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
		Bytes = UncompressedBytes;
#else
		Bytes = *UncompressedBytes;
#endif
	}

	UTexture2D* Texture = UTexture2D::CreateTransient(Width, Height, PixelFormat);
	if (!Texture)
	{
		return nullptr;
	}

#if ENGINE_MAJOR_VERSION > 4
	FTexture2DMipMap& Mip = Texture->GetPlatformData()->Mips[0];
#else
	FTexture2DMipMap& Mip = Texture->PlatformData->Mips[0];
#endif
	void* Data = Mip.BulkData.Lock(LOCK_READ_WRITE);
	FMemory::Memcpy(Data, Bytes.GetData(), Bytes.Num());
	Mip.BulkData.Unlock();
	Texture->UpdateResource();

	return Texture;
}

void ULuaBlueprintFunctionLibrary::LuaHttpRequest(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Method, const FString& URL, TMap<FString, FString> Headers, FLuaValue Body, FLuaValue Context, const FLuaHttpResponseReceived& ResponseReceived, const FLuaHttpError& Error)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 26
	TSharedRef<IHttpRequest, ESPMode::ThreadSafe> HttpRequest = FHttpModule::Get().CreateRequest();
#else
	TSharedRef<IHttpRequest> HttpRequest = FHttpModule::Get().CreateRequest();
#endif
	HttpRequest->SetVerb(Method);
	HttpRequest->SetURL(URL);
	for (TPair<FString, FString> Header : Headers)
	{
		HttpRequest->AppendToHeader(Header.Key, Header.Value);
	}
	HttpRequest->SetContent(Body.ToBytes());

	TSharedRef<FLuaSmartReference> ContextSmartRef = L->AddLuaSmartReference(Context);

	HttpRequest->OnProcessRequestComplete().BindStatic(&ULuaBlueprintFunctionLibrary::HttpGenericRequestDone, TWeakPtr<FLuaSmartReference>(ContextSmartRef), ResponseReceived, Error);
	HttpRequest->ProcessRequest();
}

void ULuaBlueprintFunctionLibrary::HttpGenericRequestDone(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful, TWeakPtr<FLuaSmartReference> Context, FLuaHttpResponseReceived ResponseReceived, FLuaHttpError Error)
{
	// if the context is invalid, the LuaState is already dead
	if (!Context.IsValid())
		return;

	TSharedRef<FLuaSmartReference> SmartContext = Context.Pin().ToSharedRef();

	SmartContext->LuaState->RemoveLuaSmartReference(SmartContext);

	if (!bWasSuccessful)
	{
		Error.ExecuteIfBound(SmartContext->Value);
		return;
	}

	FLuaValue StatusCode = FLuaValue(Response->GetResponseCode());
	FLuaValue Headers = SmartContext->LuaState->CreateLuaTable();
	for (auto HeaderLine : Response->GetAllHeaders())
	{
		int32 Index;
		if (HeaderLine.Len() > 2 && HeaderLine.FindChar(':', Index))
		{
			FString Key;
			if (Index > 0)
				Key = HeaderLine.Left(Index);
			FString Value = HeaderLine.Right(HeaderLine.Len() - (Index + 2));
			Headers.SetField(Key, FLuaValue(Value));
		}
	}
	FLuaValue Content = FLuaValue(Response->GetContent());
	FLuaValue LuaHttpResponse = SmartContext->LuaState->CreateLuaTable();
	LuaHttpResponse.SetFieldByIndex(1, StatusCode);
	LuaHttpResponse.SetFieldByIndex(2, Headers);
	LuaHttpResponse.SetFieldByIndex(3, Content);
	ResponseReceived.ExecuteIfBound(SmartContext->Value, LuaHttpResponse);
}

void ULuaBlueprintFunctionLibrary::LuaRunURL(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& URL, TMap<FString, FString> Headers, const FString& SecurityHeader, const FString& SignaturePublicExponent, const FString& SignatureModulus, FLuaHttpSuccess Completed)
{

	// Security CHECK
	if (!SecurityHeader.IsEmpty() || !SignaturePublicExponent.IsEmpty() || !SignatureModulus.IsEmpty())
	{
		if (SecurityHeader.IsEmpty() || SignaturePublicExponent.IsEmpty() || SignatureModulus.IsEmpty())
		{
			UE_LOG(LogLuaMachine, Error, TEXT("For secure LuaRunURL() you need to specify the Security HTTP Header, the Signature Public Exponent and the Signature Modulus"));
			return;
		}
	}
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 26
	TSharedRef<IHttpRequest, ESPMode::ThreadSafe> HttpRequest = FHttpModule::Get().CreateRequest();
#else
	TSharedRef<IHttpRequest> HttpRequest = FHttpModule::Get().CreateRequest();
#endif
	HttpRequest->SetURL(URL);
	for (TPair<FString, FString> Header : Headers)
	{
		HttpRequest->AppendToHeader(Header.Key, Header.Value);
	}
	HttpRequest->OnProcessRequestComplete().BindStatic(&ULuaBlueprintFunctionLibrary::HttpRequestDone, State, TWeakObjectPtr<UWorld>(WorldContextObject->GetWorld()), SecurityHeader, SignaturePublicExponent, SignatureModulus, Completed);
	HttpRequest->ProcessRequest();
}

void ULuaBlueprintFunctionLibrary::HttpRequestDone(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful, TSubclassOf<ULuaState> LuaState, TWeakObjectPtr<UWorld> World, const FString SecurityHeader, const FString SignaturePublicExponent, const FString SignatureModulus, FLuaHttpSuccess Completed)
{
	FLuaValue ReturnValue;
	int32 StatusCode = -1;

	if (!bWasSuccessful)
	{
		UE_LOG(LogLuaMachine, Error, TEXT("HTTP session failed for \"%s %s\""), *Request->GetVerb(), *Request->GetURL());
	}

	else if (!World.IsValid())
	{
		UE_LOG(LogLuaMachine, Error, TEXT("Unable to access LuaState as the World object is no more available (\"%s %s\")"), *Request->GetVerb(), *Request->GetURL());
	}
	else
	{
		// Check signature
		if (!SecurityHeader.IsEmpty())
		{
			// check code size
			if (Response->GetContentLength() <= 0)
			{
				UE_LOG(LogLuaMachine, Error, TEXT("[Security] Invalid Content Size"));
				Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
				return;
			}
			FString EncryptesSignatureBase64 = Response->GetHeader(SecurityHeader);
			if (EncryptesSignatureBase64.IsEmpty())
			{
				UE_LOG(LogLuaMachine, Error, TEXT("[Security] Invalid Security HTTP Header"));
				Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
				return;
			}

			const uint32 KeySize = 64;

			TArray<uint8> Signature;
			FBase64::Decode(EncryptesSignatureBase64, Signature);

			if (Signature.Num() != KeySize)
			{
				UE_LOG(LogLuaMachine, Error, TEXT("[Security] Invalid Signature"));
				Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
				return;
			}
			TEncryptionInt SignatureValue = TEncryptionInt((uint32*)&Signature[0]);

			TArray<uint8> PublicExponent;
			FBase64::Decode(SignaturePublicExponent, PublicExponent);
			if (PublicExponent.Num() != KeySize)
			{
				UE_LOG(LogLuaMachine, Error, TEXT("[Security] Invalid Signature Public Exponent"));
				Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
				return;
			}

			TArray<uint8> Modulus;
			FBase64::Decode(SignatureModulus, Modulus);
			if (Modulus.Num() != KeySize)
			{
				UE_LOG(LogLuaMachine, Error, TEXT("[Security] Invalid Signature Modulus"));
				Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
				return;
			}

			TEncryptionInt PublicKey = TEncryptionInt((uint32*)&PublicExponent[0]);
			TEncryptionInt ModulusValue = TEncryptionInt((uint32*)&Modulus[0]);

			TEncryptionInt ShaHash;
			FSHA1::HashBuffer(Response->GetContent().GetData(), Response->GetContentLength(), (uint8*)&ShaHash);

			TEncryptionInt DecryptedSignature = FEncryption::ModularPow(SignatureValue, PublicKey, ModulusValue);
			if (DecryptedSignature != ShaHash)
			{
				UE_LOG(LogLuaMachine, Error, TEXT("[Security] Signature check failed"));
				Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
				return;
			}
		}

		ReturnValue = LuaRunString(World.Get(), LuaState, Response->GetContentAsString());
		StatusCode = Response->GetResponseCode();
	}

	Completed.ExecuteIfBound(ReturnValue, bWasSuccessful, StatusCode);
}

void ULuaBlueprintFunctionLibrary::LuaTableFillObject(FLuaValue InTable, UObject* InObject)
{
	if (InTable.Type != ELuaValueType::Table || !InObject)
		return;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return;

	UStruct* Class = Cast<UStruct>(InObject);
	if (!Class)
		Class = InObject->GetClass();

	L->FromLuaValue(InTable);
	L->PushNil(); // first key
	while (L->Next(-2))
	{
		FLuaValue Key = L->ToLuaValue(-2);
		FLuaValue Value = L->ToLuaValue(-1);
		L->SetPropertyFromLuaValue(InObject, Key.ToString(), Value);
		L->Pop(); // pop the value
	}

	L->Pop(); // pop the table
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableGetField(FLuaValue Table, const FString& Key)
{
	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return FLuaValue();

	return Table.GetField(Key);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaComponentGetField(FLuaValue LuaComponent, const FString& Key)
{
	FLuaValue ReturnValue;
	if (LuaComponent.Type != ELuaValueType::UObject)
		return ReturnValue;

	ULuaState* L = LuaComponent.LuaState.Get();
	if (!L)
		return ReturnValue;

	ULuaComponent* Component = Cast<ULuaComponent>(LuaComponent.Object);

	FLuaValue* LuaValue = Component->Table.Find(Key);
	if (LuaValue)
	{
		return *LuaValue;
	}

	return ReturnValue;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsNil(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Nil;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsOwned(const FLuaValue& Value)
{
	return Value.LuaState != nullptr;
}

TSubclassOf<ULuaState> ULuaBlueprintFunctionLibrary::LuaValueGetOwner(const FLuaValue& Value)
{
	if (!Value.LuaState.IsValid())
	{
		return nullptr;
	}
	return Value.LuaState->GetClass();
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsNotNil(const FLuaValue& Value)
{
	return Value.Type != ELuaValueType::Nil;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsTable(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Table;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsBoolean(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Bool;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsThread(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Thread;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsFunction(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Function;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsNumber(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Number;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsInteger(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::Integer;
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsString(const FLuaValue& Value)
{
	return Value.Type == ELuaValueType::String;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableGetByIndex(FLuaValue Table, int32 Index)
{
	if (Table.Type != ELuaValueType::Table)
		return FLuaValue();

	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return FLuaValue();

	return Table.GetFieldByIndex(Index);
}

FLuaValue ULuaBlueprintFunctionLibrary::AssignLuaValueToLuaState(UObject* WorldContextObject, FLuaValue Value, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return Value;
	Value.LuaState = L;
	return Value;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableSetByIndex(FLuaValue Table, int32 Index, FLuaValue Value)
{
	if (Table.Type != ELuaValueType::Table)
		return FLuaValue();

	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return FLuaValue();

	return Table.SetFieldByIndex(Index, Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableSetField(FLuaValue Table, const FString& Key, FLuaValue Value)
{
	FLuaValue ReturnValue;
	if (Table.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return ReturnValue;

	return Table.SetField(Key, Value);
}

FLuaValue ULuaBlueprintFunctionLibrary::GetLuaComponentAsLuaValue(AActor* Actor)
{
	if (!Actor)
		return FLuaValue();

	return FLuaValue(Actor->GetComponentByClass(ULuaComponent::StaticClass()));
}

FLuaValue ULuaBlueprintFunctionLibrary::GetLuaComponentByStateAsLuaValue(AActor* Actor, TSubclassOf<ULuaState> State)
{
	if (!Actor)
		return FLuaValue();
#if ENGINE_MAJOR_VERSION < 5 && ENGINE_MINOR_VERSION < 24
	TArray<UActorComponent*> Components = Actor->GetComponentsByClass(ULuaComponent::StaticClass());
#else
	TArray<UActorComponent*> Components;
	Actor->GetComponents(Components);
#endif
	for (UActorComponent* Component : Components)
	{
		ULuaComponent* LuaComponent = Cast<ULuaComponent>(Component);
		if (LuaComponent)
		{
			if (LuaComponent->LuaState == State)
			{
				return FLuaValue(LuaComponent);
			}
		}
	}

	return FLuaValue();
}

FLuaValue ULuaBlueprintFunctionLibrary::GetLuaComponentByNameAsLuaValue(AActor* Actor, const FString& Name)
{
	if (!Actor)
		return FLuaValue();

#if ENGINE_MAJOR_VERSION < 5 && ENGINE_MINOR_VERSION < 24
	TArray<UActorComponent*> Components = Actor->GetComponentsByClass(ULuaComponent::StaticClass());
#else
	TArray<UActorComponent*> Components;
	Actor->GetComponents(Components);
#endif
	for (UActorComponent* Component : Components)
	{
		ULuaComponent* LuaComponent = Cast<ULuaComponent>(Component);
		if (LuaComponent)
		{
			if (LuaComponent->GetName() == Name)
			{
				return FLuaValue(LuaComponent);
			}
		}
	}

	return FLuaValue();
}

FLuaValue ULuaBlueprintFunctionLibrary::GetLuaComponentByStateAndNameAsLuaValue(AActor* Actor, TSubclassOf<ULuaState> State, const FString& Name)
{
	if (!Actor)
		return FLuaValue();

#if ENGINE_MAJOR_VERSION < 5 && ENGINE_MINOR_VERSION < 24
	TArray<UActorComponent*> Components = Actor->GetComponentsByClass(ULuaComponent::StaticClass());
#else
	TArray<UActorComponent*> Components;
	Actor->GetComponents(Components);
#endif
	for (UActorComponent* Component : Components)
	{
		ULuaComponent* LuaComponent = Cast<ULuaComponent>(Component);
		if (LuaComponent)
		{
			if (LuaComponent->LuaState == State && LuaComponent->GetName() == Name)
			{
				return FLuaValue(LuaComponent);
			}
		}
	}

	return FLuaValue();
}

int32 ULuaBlueprintFunctionLibrary::LuaGetTop(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return MIN_int32;
	return L->GetTop();
}

void ULuaBlueprintFunctionLibrary::LuaSetGlobal(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name, FLuaValue Value)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;
	L->SetFieldFromTree(Name, Value, true);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaGlobalCall(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	int32 ItemsToPop = L->GetFieldFromTree(Name);

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	L->PCall(NArgs, ReturnValue);

	// we have the return value and the function has been removed, so we do not need to change ItemsToPop
	L->Pop(ItemsToPop);

	return ReturnValue;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaGlobalCallMulti(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	int32 ItemsToPop = L->GetFieldFromTree(Name);

	int32 StackTop = L->GetTop();

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	FLuaValue LastReturnValue;
	if (L->PCall(NArgs, LastReturnValue, LUA_MULTRET))
	{

		int32 NumOfReturnValues = (L->GetTop() - StackTop) + 1;
		if (NumOfReturnValues > 0)
		{
			for (int32 i = -1; i >= -(NumOfReturnValues); i--)
			{
				ReturnValue.Insert(L->ToLuaValue(i), 0);
			}
			L->Pop(NumOfReturnValues - 1);
		}

	}

	// we have the return value and the function has been removed, so we do not need to change ItemsToPop
	L->Pop(ItemsToPop);

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaGlobalCallValue(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	L->FromLuaValue(Value);

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	L->PCall(NArgs, ReturnValue);

	L->Pop();

	return ReturnValue;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaGlobalCallValueMulti(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	L->FromLuaValue(Value);

	int32 StackTop = L->GetTop();

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	FLuaValue LastReturnValue;
	if (L->PCall(NArgs, LastReturnValue, LUA_MULTRET))
	{

		int32 NumOfReturnValues = (L->GetTop() - StackTop) + 1;
		if (NumOfReturnValues > 0)
		{
			for (int32 i = -1; i >= -(NumOfReturnValues); i--)
			{
				ReturnValue.Insert(L->ToLuaValue(i), 0);
			}
			L->Pop(NumOfReturnValues - 1);
		}

	}

	L->Pop();

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaValueCall(FLuaValue Value, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return ReturnValue;

	L->FromLuaValue(Value);

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	L->PCall(NArgs, ReturnValue);

	L->Pop();

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(FLuaValue Value, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	if (Value.Type != ELuaValueType::Nil)
		ReturnValue = LuaValueCall(Value, Args);

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableKeyCall(FLuaValue InTable, const FString& Key, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetField(Key);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	return LuaValueCall(Value, Args);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableKeyCallWithSelf(FLuaValue InTable, const FString& Key, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetField(Key);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	Args.Insert(InTable, 0);

	return LuaValueCall(Value, Args);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableIndexCall(FLuaValue InTable, int32 Index, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetFieldByIndex(Index);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	return LuaValueCall(Value, Args);
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaTableUnpack(FLuaValue InTable)
{
	TArray<FLuaValue> ReturnValue;
	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	int32 Index = 1;
	for (;;)
	{
		FLuaValue Item = InTable.GetFieldByIndex(Index++);
		if (Item.Type == ELuaValueType::Nil)
			break;
		ReturnValue.Add(Item);
	}

	return ReturnValue;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaTableMergeUnpack(FLuaValue InTable1, FLuaValue InTable2)
{
	TArray<FLuaValue> ReturnValue;
	if (InTable1.Type != ELuaValueType::Table)
		return ReturnValue;

	if (InTable2.Type != ELuaValueType::Table)
		return ReturnValue;

	int32 Index = 1;
	for (;;)
	{
		FLuaValue Item = InTable1.GetFieldByIndex(Index++);
		if (Item.Type == ELuaValueType::Nil)
			break;
		ReturnValue.Add(Item);
	}

	for (;;)
	{
		FLuaValue Item = InTable2.GetFieldByIndex(Index++);
		if (Item.Type == ELuaValueType::Nil)
			break;
		ReturnValue.Add(Item);
	}

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTablePack(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TArray<FLuaValue> Values)
{
	FLuaValue ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	ReturnValue = L->CreateLuaTable();

	int32 Index = 1;

	for (FLuaValue& Value : Values)
	{
		ReturnValue.SetFieldByIndex(Index++, Value);
	}

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableMergePack(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TArray<FLuaValue> Values1, TArray<FLuaValue> Values2)
{
	FLuaValue ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	ReturnValue = L->CreateLuaTable();

	int32 Index = 1;

	for (FLuaValue& Value : Values1)
	{
		ReturnValue.SetFieldByIndex(Index++, Value);
	}

	for (FLuaValue& Value : Values2)
	{
		ReturnValue.SetFieldByIndex(Index++, Value);
	}

	return ReturnValue;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableFromMap(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TMap<FString, FLuaValue> Map)
{
	FLuaValue ReturnValue;
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return ReturnValue;

	ReturnValue = L->CreateLuaTable();

	for (TPair<FString, FLuaValue>& Pair : Map)
	{
		ReturnValue.SetField(Pair.Key, Pair.Value);
	}

	return ReturnValue;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaTableRange(FLuaValue InTable, int32 First, int32 Last)
{
	TArray<FLuaValue> ReturnValue;
	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	for (int32 i = First; i <= Last; i++)
	{
		ReturnValue.Add(InTable.GetFieldByIndex(i));
	}

	return ReturnValue;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaValueArrayMerge(TArray<FLuaValue> Array1, TArray<FLuaValue> Array2)
{
	TArray<FLuaValue> NewArray = Array1;
	NewArray.Append(Array2);
	return NewArray;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaValueArrayAppend(TArray<FLuaValue> Array, FLuaValue Value)
{
	TArray<FLuaValue> NewArray = Array;
	NewArray.Add(Value);
	return NewArray;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaValueCallMulti(FLuaValue Value, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return ReturnValue;

	L->FromLuaValue(Value);

	int32 StackTop = L->GetTop();

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	FLuaValue LastReturnValue;
	if (L->PCall(NArgs, LastReturnValue, LUA_MULTRET))
	{

		int32 NumOfReturnValues = (L->GetTop() - StackTop) + 1;
		if (NumOfReturnValues > 0)
		{
			for (int32 i = -1; i >= -(NumOfReturnValues); i--)
			{
				ReturnValue.Insert(L->ToLuaValue(i), 0);
			}
			L->Pop(NumOfReturnValues - 1);
		}

	}

	L->Pop();

	return ReturnValue;
}

void ULuaBlueprintFunctionLibrary::LuaValueYield(FLuaValue Value, TArray<FLuaValue> Args)
{
	if (Value.Type != ELuaValueType::Thread)
		return;

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return;

	L->FromLuaValue(Value);

	int32 StackTop = L->GetTop();

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	L->Yield(-1 - NArgs, NArgs);

	L->Pop();
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaValueResumeMulti(FLuaValue Value, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;

	if (Value.Type != ELuaValueType::Thread)
		return ReturnValue;

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return ReturnValue;

	L->FromLuaValue(Value);

	int32 StackTop = L->GetTop();

	int NArgs = 0;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	L->Resume(-1 - NArgs, NArgs);

	int32 NumOfReturnValues = (L->GetTop() - StackTop);
	if (NumOfReturnValues > 0)
	{
		for (int32 i = -1; i >= -(NumOfReturnValues); i--)
		{
			ReturnValue.Insert(L->ToLuaValue(i), 0);
		}
		L->Pop(NumOfReturnValues);
	}

	L->Pop();

	return ReturnValue;
}

FVector ULuaBlueprintFunctionLibrary::LuaTableToVector(FLuaValue Value)
{
	if (Value.Type != ELuaValueType::Table)
	{
		return FVector(NAN);
	}

	auto GetVectorField = [](FLuaValue& Table, const char* Field_n, const char* Field_N, int32 Index) -> FLuaValue
	{
		FLuaValue N = Table.GetField(Field_n);
		if (N.IsNil())
		{
			N = Table.GetField(Field_N);
			if (N.IsNil())
			{
				N = Table.GetFieldByIndex(Index);
				if (N.IsNil())
				{
					N = FLuaValue(NAN);
				}
			}
		}
		return N;
	};

	FLuaValue X = GetVectorField(Value, "x", "X", 1);
	FLuaValue Y = GetVectorField(Value, "y", "Y", 2);
	FLuaValue Z = GetVectorField(Value, "z", "Z", 3);

	return FVector(X.ToFloat(), Y.ToFloat(), Z.ToFloat());
}

FRotator ULuaBlueprintFunctionLibrary::LuaTableToRotator(FLuaValue Value)
{
	if (Value.Type != ELuaValueType::Table)
	{
		return FRotator(NAN);
	}

	auto GetRotatorField = [](FLuaValue& Table, const char* Field_n, const char* Field_N, int32 Index) -> FLuaValue
		{
			FLuaValue N = Table.GetField(Field_n);
			if (N.IsNil())
			{
				N = Table.GetField(Field_N);
				if (N.IsNil())
				{
					N = Table.GetFieldByIndex(Index);
					if (N.IsNil())
					{
						N = FLuaValue(NAN);
					}
				}
			}
			return N;
		};

	FLuaValue Roll = GetRotatorField(Value, "roll", "Roll", 1);
	FLuaValue Pitch = GetRotatorField(Value, "pitch", "Pitch", 2);
	FLuaValue Yaw = GetRotatorField(Value, "yaw", "Yaw", 3);

	return FRotator(Pitch.ToFloat(), Yaw.ToFloat(), Roll.ToFloat());
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableSetMetaTable(FLuaValue InTable, FLuaValue InMetaTable)
{
	FLuaValue ReturnValue;
	if (InTable.Type != ELuaValueType::Table || InMetaTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	return InTable.SetMetaTable(InMetaTable);
}

int32 ULuaBlueprintFunctionLibrary::LuaValueLength(FLuaValue Value)
{

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return 0;

	L->FromLuaValue(Value);
	L->Len(-1);
	int32 Length = L->ToInteger(-1);
	L->Pop(2);

	return Length;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaTableGetKeys(FLuaValue Table)
{
	TArray<FLuaValue> Keys;

	if (Table.Type != ELuaValueType::Table)
		return Keys;

	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return Keys;

	L->FromLuaValue(Table);
	L->PushNil(); // first key
	while (L->Next(-2))
	{
		Keys.Add(L->ToLuaValue(-2)); // add key
		L->Pop(); // pop the value
	}

	L->Pop(); // pop the table

	return Keys;
}

TArray<FLuaValue> ULuaBlueprintFunctionLibrary::LuaTableGetValues(FLuaValue Table)
{
	TArray<FLuaValue> Keys;

	if (Table.Type != ELuaValueType::Table)
		return Keys;

	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return Keys;

	L->FromLuaValue(Table);
	L->PushNil(); // first key
	while (L->Next(-2))
	{
		Keys.Add(L->ToLuaValue(-1)); // add value
		L->Pop(); // pop the value
	}

	L->Pop(); // pop the table

	return Keys;
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaTableAssetToLuaTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State, ULuaTableAsset* TableAsset)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return FLuaValue();

	return TableAsset->ToLuaTable(L);
}

FLuaValue ULuaBlueprintFunctionLibrary::LuaNewLuaUserDataObject(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TSubclassOf<ULuaUserDataObject> UserDataObjectClass, bool bTrackObject)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return FLuaValue();

	return L->NewLuaUserDataObject(UserDataObjectClass, bTrackObject);
}

ULuaState* ULuaBlueprintFunctionLibrary::LuaGetState(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	return FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
}

bool ULuaBlueprintFunctionLibrary::LuaTableImplements(FLuaValue Table, ULuaTableAsset* TableAsset)
{
	if (Table.Type != ELuaValueType::Table)
		return false;

	ULuaState* L = Table.LuaState.Get();
	if (!L)
		return false;

	for (TPair<FString, FLuaValue>& Pair : TableAsset->Table)
	{
		FLuaValue Item = Table.GetField(Pair.Key);
		if (Item.Type == ELuaValueType::Nil)
			return false;
		if (Item.Type != Pair.Value.Type)
			return false;
	}

	return true;
}

bool ULuaBlueprintFunctionLibrary::LuaTableImplementsAll(FLuaValue Table, TArray<ULuaTableAsset*> TableAssets)
{
	for (ULuaTableAsset* TableAsset : TableAssets)
	{
		if (!LuaTableImplements(Table, TableAsset))
			return false;
	}
	return true;
}

bool ULuaBlueprintFunctionLibrary::LuaTableImplementsAny(FLuaValue Table, TArray<ULuaTableAsset*> TableAssets)
{
	for (ULuaTableAsset* TableAsset : TableAssets)
	{
		if (LuaTableImplements(Table, TableAsset))
			return true;
	}
	return false;
}

int32 ULuaBlueprintFunctionLibrary::LuaGetUsedMemory(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return -1;

	return L->GC(LUA_GCCOUNT);
}

void ULuaBlueprintFunctionLibrary::LuaGCCollect(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;

	L->GC(LUA_GCCOLLECT);
}

void ULuaBlueprintFunctionLibrary::LuaGCStop(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;

	L->GC(LUA_GCSTOP);
}

void ULuaBlueprintFunctionLibrary::LuaGCRestart(UObject* WorldContextObject, TSubclassOf<ULuaState> State)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;

	L->GC(LUA_GCRESTART);
}

void ULuaBlueprintFunctionLibrary::LuaSetUserDataMetaTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue MetaTable)
{
	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return;
	L->SetUserDataMetaTable(MetaTable);
}

bool ULuaBlueprintFunctionLibrary::LuaValueIsReferencedInLuaRegistry(FLuaValue Value)
{
	return Value.IsReferencedInLuaRegistry();
}

UClass* ULuaBlueprintFunctionLibrary::LuaValueToBlueprintGeneratedClass(const FLuaValue& Value)
{
	UObject* LoadedObject = nullptr;
	if (Value.Type == ELuaValueType::String)
	{
		LoadedObject = StaticLoadObject(UBlueprint::StaticClass(), nullptr, *Value.ToString());
	}
	else if (Value.Type == ELuaValueType::UObject)
	{
		LoadedObject = Value.Object;
	}

	if (!LoadedObject)
		return nullptr;

	UBlueprint* Blueprint = Cast<UBlueprint>(LoadedObject);
	if (!Blueprint)
		return nullptr;
	return Cast<UClass>(Blueprint->GeneratedClass);
}

UClass* ULuaBlueprintFunctionLibrary::LuaValueLoadClass(const FLuaValue& Value, bool bDetectBlueprintGeneratedClass)
{
	UObject* LoadedObject = nullptr;
	if (Value.Type == ELuaValueType::String)
	{
		LoadedObject = StaticLoadObject(UObject::StaticClass(), nullptr, *Value.ToString());
	}
	else if (Value.Type == ELuaValueType::UObject)
	{
		LoadedObject = Value.Object;
	}

	if (!LoadedObject)
		return nullptr;

	if (bDetectBlueprintGeneratedClass)
	{
		UBlueprint* Blueprint = Cast<UBlueprint>(LoadedObject);
		if (Blueprint)
		{
			return Cast<UClass>(Blueprint->GeneratedClass);
		}
		UBlueprintGeneratedClass* BlueprintGeneratedClass = Cast<UBlueprintGeneratedClass>(LoadedObject);
		if (BlueprintGeneratedClass)
		{
			return BlueprintGeneratedClass;
		}
	}

	return Cast<UClass>(LoadedObject);
}

UObject* ULuaBlueprintFunctionLibrary::LuaValueLoadObject(const FLuaValue& Value)
{
	UObject* LoadedObject = nullptr;
	if (Value.Type == ELuaValueType::String)
	{
		LoadedObject = StaticLoadObject(UObject::StaticClass(), nullptr, *Value.ToString());
	}
	else if (Value.Type == ELuaValueType::UObject)
	{
		LoadedObject = Value.Object;
	}

	return LoadedObject;
}

bool ULuaBlueprintFunctionLibrary::LuaValueFromJson(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Json, FLuaValue& LuaValue)
{
	// default to nil
	LuaValue = FLuaValue();

	ULuaState* L = FLuaMachineModule::Get().GetLuaState(State, WorldContextObject->GetWorld());
	if (!L)
		return false;

	TSharedPtr<FJsonValue> JsonValue;
	TSharedRef< TJsonReader<TCHAR> > JsonReader = TJsonReaderFactory<TCHAR>::Create(Json);
	if (!FJsonSerializer::Deserialize(JsonReader, JsonValue))
	{
		return false;
	}

	LuaValue = FLuaValue::FromJsonValue(L, *JsonValue);
	return true;
}

FString ULuaBlueprintFunctionLibrary::LuaValueToJson(FLuaValue Value)
{
	FString Json;
	TSharedRef<TJsonWriter<>> JsonWriter = TJsonWriterFactory<>::Create(&Json);
	FJsonSerializer::Serialize(Value.ToJsonValue(), "", JsonWriter);
	return Json;
}

bool ULuaBlueprintFunctionLibrary::LuaLoadPakFile(const FString& Filename, FString Mountpoint, TArray<FLuaValue>& Assets, FString ContentPath, FString AssetRegistryPath)
{
	if (!Mountpoint.StartsWith("/") || !Mountpoint.EndsWith("/"))
	{
		UE_LOG(LogLuaMachine, Error, TEXT("Invalid Mountpoint, must be in the format /Name/"));
		return false;
	}

	IPlatformFile& TopPlatformFile = FPlatformFileManager::Get().GetPlatformFile();
	bool bCustomPakPlatformFile = false;

	FPakPlatformFile* PakPlatformFile = (FPakPlatformFile*)FPlatformFileManager::Get().FindPlatformFile(TEXT("PakFile"));
	if (!PakPlatformFile)
	{
		PakPlatformFile = new FPakPlatformFile();
		if (!PakPlatformFile->Initialize(&TopPlatformFile, TEXT("")))
		{
			UE_LOG(LogLuaMachine, Error, TEXT("Unable to setup PakPlatformFile"));
			delete(PakPlatformFile);
			return false;
		}
		FPlatformFileManager::Get().SetPlatformFile(*PakPlatformFile);
		bCustomPakPlatformFile = true;
	}

#if	ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION > 26
	TRefCountPtr<FPakFile> PakFile = new FPakFile(PakPlatformFile, *Filename, false);
#else
	FPakFile PakFile(PakPlatformFile, *Filename, false);
#endif
	if (!PakFile.IsValid())
	{
		UE_LOG(LogLuaMachine, Error, TEXT("Unable to open PakFile"));
		if (bCustomPakPlatformFile)
		{
			FPlatformFileManager::Get().SetPlatformFile(TopPlatformFile);
			delete(PakPlatformFile);
		}
		return false;
	}

#if	ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION > 26
	FString PakFileMountPoint = PakFile->GetMountPoint();
#else
	FString PakFileMountPoint = PakFile.GetMountPoint();
#endif

	FPaths::MakeStandardFilename(Mountpoint);

	FPaths::MakeStandardFilename(PakFileMountPoint);

#if	ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION > 26
	PakFile->SetMountPoint(*PakFileMountPoint);
#else
	PakFile.SetMountPoint(*PakFileMountPoint);
#endif

	if (!PakPlatformFile->Mount(*Filename, 0, *PakFileMountPoint))
	{
		UE_LOG(LogLuaMachine, Error, TEXT("Unable to mount PakFile"));
		if (bCustomPakPlatformFile)
		{
			FPlatformFileManager::Get().SetPlatformFile(TopPlatformFile);
			delete(PakPlatformFile);
		}
		return false;
	}

	if (ContentPath.IsEmpty())
	{
		ContentPath = "/Plugins" + Mountpoint + "Content/";
	}

	FString MountDestination = PakFileMountPoint + ContentPath;
	FPaths::MakeStandardFilename(MountDestination);

	FPackageName::RegisterMountPoint(Mountpoint, MountDestination);

	IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();

#if WITH_EDITOR
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION > 23
	int32 bPreviousGAllowUnversionedContentInEditor = GAllowUnversionedContentInEditor;
#else
	bool bPreviousGAllowUnversionedContentInEditor = GAllowUnversionedContentInEditor;
#endif
	GAllowUnversionedContentInEditor = true;
#endif

	if (AssetRegistryPath.IsEmpty())
	{
		AssetRegistryPath = "/Plugins" + Mountpoint + "AssetRegistry.bin";
	}

	FArrayReader SerializedAssetData;
	if (!FFileHelper::LoadFileToArray(SerializedAssetData, *(PakFileMountPoint + AssetRegistryPath)))
	{
		UE_LOG(LogLuaMachine, Error, TEXT("Unable to parse AssetRegistry file"));
		if (bCustomPakPlatformFile)
		{
			FPlatformFileManager::Get().SetPlatformFile(TopPlatformFile);
			delete(PakPlatformFile);
		}
#if WITH_EDITOR
		GAllowUnversionedContentInEditor = bPreviousGAllowUnversionedContentInEditor;
#endif
		return false;
	}

	AssetRegistry.Serialize(SerializedAssetData);

	AssetRegistry.ScanPathsSynchronous({ Mountpoint }, true);

	TArray<FAssetData> AssetData;
	AssetRegistry.GetAllAssets(AssetData, false);

	for (auto Asset : AssetData)
	{
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION > 0
		if (Asset.GetObjectPathString().StartsWith(Mountpoint))
#else
		if (Asset.ObjectPath.ToString().StartsWith(Mountpoint))
#endif
		{
			Assets.Add(FLuaValue(Asset.GetAsset()));
		}
	}

	if (bCustomPakPlatformFile)
	{
		FPlatformFileManager::Get().SetPlatformFile(TopPlatformFile);
		delete(PakPlatformFile);
	}

#if WITH_EDITOR
	GAllowUnversionedContentInEditor = bPreviousGAllowUnversionedContentInEditor;
#endif

	return true;
}

void ULuaBlueprintFunctionLibrary::SwitchOnLuaValueType(const FLuaValue& LuaValue, ELuaValueType& LuaValueTypes)
{
	LuaValueTypes = LuaValue.Type;
}

void ULuaBlueprintFunctionLibrary::GetLuaReflectionType(UObject* InObject, const FString& Name, ELuaReflectionType& LuaReflectionTypes)
{
	LuaReflectionTypes = ELuaReflectionType::Unknown;
	UClass* Class = InObject->GetClass();
	if (!Class)
	{
		return;
	}

	if (Class->FindPropertyByName(FName(*Name)) != nullptr)
	{
		LuaReflectionTypes = ELuaReflectionType::Property;
		return;
	}

	if (Class->FindFunctionByName(FName(*Name)))
	{
		LuaReflectionTypes = ELuaReflectionType::Function;
		return;
	}
}

void ULuaBlueprintFunctionLibrary::RegisterLuaConsoleCommand(const FString& CommandName, const FLuaValue& LuaConsoleCommand)
{
	FLuaMachineModule::Get().RegisterLuaConsoleCommand(CommandName, LuaConsoleCommand);
}

void ULuaBlueprintFunctionLibrary::UnregisterLuaConsoleCommand(const FString& CommandName)
{
	FLuaMachineModule::Get().UnregisterLuaConsoleCommand(CommandName);
}

ULuaState* ULuaBlueprintFunctionLibrary::CreateDynamicLuaState(UObject* WorldContextObject, TSubclassOf<ULuaState> LuaStateClass)
{
	if (!LuaStateClass)
	{
		return nullptr;
	}

	if (LuaStateClass == ULuaState::StaticClass())
	{
		UE_LOG(LogLuaMachine, Error, TEXT("attempt to use LuaState Abstract class, please create a child of LuaState"));
		return nullptr;
	}


	ULuaState* NewLuaState = NewObject<ULuaState>((UObject*)GetTransientPackage(), LuaStateClass);
	if (!NewLuaState)
	{
		return nullptr;
	}

	return NewLuaState->GetLuaState(WorldContextObject->GetWorld());
}

```

`Source/LuaMachine/Private/LuaBlueprintPackage.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris


#include "LuaBlueprintPackage.h"
#include "LuaState.h"

TSubclassOf<ULuaState> ULuaBlueprintPackage::GetLuaState() const
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (LuaState)
	{
		return LuaState->GetClass();
	}
	return nullptr;
}

ULuaState* ULuaBlueprintPackage::GetLuaStateInstance() const
{
	return Cast<ULuaState>(GetOuter());
}

UWorld* ULuaBlueprintPackage::GetWorld() const
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (LuaState)
	{
		return LuaState->GetWorld();
	}
	return nullptr;
}

void ULuaBlueprintPackage::Init()
{

}
```

`Source/LuaMachine/Private/LuaCode.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris
// Reimport system by yama2akira (Akira Yamamoto)

#include "LuaCode.h"
#include "LuaMachine.h"
#include "Serialization/CustomVersion.h"
#include "EditorFramework/AssetImportData.h"

const FGuid FLuaCodeObjectVersion::GUID(0x01C2E96A1, 0xE24436EA, 0x6C69B025, 0x14E7FC3);
FCustomVersionRegistration GRegisterLuaCodeCustomVersion(FLuaCodeObjectVersion::GUID, FLuaCodeObjectVersion::LatestVersion, TEXT("LuaCodeVer"));

ULuaCode::ULuaCode()
{
	bCookAsBytecode = true;
	bCooked = false;
}

void ULuaCode::Serialize(FArchive& Ar)
{
	bool bSkipOriginalCode = false;
	if (Ar.IsCooking() && !Ar.IsLoading())
	{
		if (bCookAsBytecode && !Code.IsEmpty())
		{
			bCooked = true;
			FString ErrorString;
			ByteCode = ULuaState::ToByteCode(Code.ToString(), GetPathName(), ErrorString);
			if (!ErrorString.IsEmpty())
			{
				UE_LOG(LogLuaMachine, Error, TEXT("Unable to generate bytecode: %s"), *ErrorString);
			}
			bSkipOriginalCode = true;
		}
	}
	else if (Ar.IsSaving())
	{
		bCooked = false;
		TArray<uint8> EmptyData;
		ByteCode = EmptyData;
	}

	FText OriginalCode;

	if (bSkipOriginalCode)
	{
		OriginalCode = Code;
		Code = FText::GetEmpty();
	}


	Super::Serialize(Ar);
	Ar.UsingCustomVersion(FLuaCodeObjectVersion::GUID);

	if (Ar.CustomVer(FLuaCodeObjectVersion::GUID) < FLuaCodeObjectVersion::FixDuplicationOfProperties)
	{
		Ar << bCooked;
		Ar << Code;
		Ar << bCookAsBytecode;
		Ar << ByteCode;
	}

	if (bSkipOriginalCode)
	{
		Code = OriginalCode;
	}
}

#if ENGINE_MAJOR_VERSION > 4
void ULuaCode::PreSave(FObjectPreSaveContext ObjectSaveContext)
{
	Super::PreSave(ObjectSaveContext);
#else
void ULuaCode::PreSave(const ITargetPlatform * TargetPlatform)
{
	Super::PreSave(TargetPlatform);
#endif

	for (ULuaState* LuaState : FLuaMachineModule::Get().GetRegisteredLuaStates())
	{
		if (LuaState->LuaCodeAsset == this)
		{
			FLuaMachineModule::Get().UnregisterLuaState(LuaState);
		}
	}
}

#if WITH_EDITORONLY_DATA
void ULuaCode::PostInitProperties()
{
	if (!HasAnyFlags(RF_ClassDefaultObject))
	{
		AssetImportData = NewObject<UAssetImportData>(this, TEXT("AssetImportData"));
	}
	Super::PostInitProperties();
}

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
void ULuaCode::GetAssetRegistryTags(FAssetRegistryTagsContext Context) const
{
	if (AssetImportData)
	{
		Context.AddTag(FAssetRegistryTag(SourceFileTagName(), AssetImportData->GetSourceData().ToJson(), FAssetRegistryTag::TT_Hidden));
	}
	Super::GetAssetRegistryTags(Context);
}
#else
void ULuaCode::GetAssetRegistryTags(TArray<FAssetRegistryTag>& OutTags) const
{
	if (AssetImportData)
	{
		OutTags.Add(FAssetRegistryTag(SourceFileTagName(), AssetImportData->GetSourceData().ToJson(), FAssetRegistryTag::TT_Hidden));
	}
	Super::GetAssetRegistryTags(OutTags);
}
#endif

#endif

```

`Source/LuaMachine/Private/LuaCommandExecutor.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris


#include "LuaCommandExecutor.h"
#include "LuaBlueprintFunctionLibrary.h"

FLuaCommandExecutor::FLuaCommandExecutor()
{
	LuaState = nullptr;
}

FLuaCommandExecutor::~FLuaCommandExecutor()
{
}

FName FLuaCommandExecutor::GetName() const
{
	return FName(*FString::Printf(TEXT("LuaMachine:%s"), *LuaState->GetName()));
}

FText FLuaCommandExecutor::GetDisplayName() const
{
	return FText::FromName(GetName());
}

FText FLuaCommandExecutor::GetDescription() const
{
	return GetDisplayName();
}

FText FLuaCommandExecutor::GetHintText() const
{
	return FText::GetEmpty();
}

void FLuaCommandExecutor::GetAutoCompleteSuggestions(const TCHAR* Input, TArray<FString>& Out)
{
}

void FLuaCommandExecutor::GetExecHistory(TArray<FString>& Out)
{
	IConsoleManager::Get().GetConsoleHistory(*(GetName().ToString()), Out);
}

bool FLuaCommandExecutor::Exec(const TCHAR* Input)
{
	IConsoleManager::Get().AddConsoleHistoryEntry(*(GetName().ToString()), Input);

	LuaState->RunString(Input, "");

	return true;
}

bool FLuaCommandExecutor::AllowHotKeyClose() const
{
	return false;
}

bool FLuaCommandExecutor::AllowMultiLine() const
{
	return true;
}

FInputChord FLuaCommandExecutor::GetHotKey() const
{
	return FInputChord();
}



```

`Source/LuaMachine/Private/LuaComponent.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaComponent.h"
#include "LuaMachine.h"
#include "LuaBlueprintFunctionLibrary.h"
#include "GameFramework/Actor.h"


// Sets default values for this component's properties
ULuaComponent::ULuaComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = false;

	// ...

	bLazy = false;
	bLogError = false;
	bImplicitSelf = false;
}

void ULuaComponent::OnRegister()
{
	Super::OnRegister();

	if (GetWorld()->IsGameWorld())
	{
		for (const FString& GlobalName : GlobalNames)
		{
			ULuaBlueprintFunctionLibrary::LuaSetGlobal(GetWorld(), LuaState, GlobalName, FLuaValue(this));
		}
	}
}

// Called when the game starts
void ULuaComponent::BeginPlay()
{
	Super::BeginPlay();

	if (!bLazy)
		FLuaMachineModule::Get().GetLuaState(LuaState, GetWorld());

	// ...

}

// Called every frame
void ULuaComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	// ...
}

ULuaState* ULuaComponent::LuaComponentGetState()
{
	return FLuaMachineModule::Get().GetLuaState(LuaState, GetWorld());
}

FLuaValue ULuaComponent::LuaGetField(const FString& Name)
{
	FLuaValue ReturnValue;
	ULuaState* L = LuaComponentGetState();
	if (!L)
		return ReturnValue;

	// push component pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int32 ItemsToPop = L->GetFieldFromTree(Name, false);
	ReturnValue = L->ToLuaValue(-1);

	// we need to remove the return value and the object
	L->Pop(ItemsToPop + 1);

	return ReturnValue;
}

void ULuaComponent::LuaSetField(const FString& Name, FLuaValue Value)
{
	ULuaState* L = LuaComponentGetState();
	if (!L)
		return;

	// push component pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	L->SetFieldFromTree(Name, Value, false);

	// remove UObject
	L->Pop();

}

FLuaValue ULuaComponent::LuaCallFunction(const FString& Name, TArray<FLuaValue> Args, bool bGlobal)
{
	FLuaValue ReturnValue;

	ULuaState* L = LuaComponentGetState();
	if (!L)
		return ReturnValue;

	// push component pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int32 ItemsToPop = L->GetFieldFromTree(Name, bGlobal);

	// first argument (self/actor)
	L->PushValue(-(ItemsToPop + 1));
	int NArgs = 1;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	if (!L->PCall(NArgs, ReturnValue))
	{
		if (L->InceptionLevel == 0)
		{
			if (bLogError)
				L->LogError(L->LastError);
			OnLuaError.Broadcast(L->LastError);
		}
	}

	// the return value and the function has been removed, so we do not need to change ItemsToPop
	L->Pop(ItemsToPop + 1);

	return ReturnValue;
}

TArray<FLuaValue> ULuaComponent::LuaCallFunctionMulti(FString Name, TArray<FLuaValue> Args, bool bGlobal)
{
	TArray<FLuaValue> ReturnValue;

	ULuaState* L = LuaComponentGetState();
	if (!L)
		return ReturnValue;

	// push component pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int32 ItemsToPop = L->GetFieldFromTree(Name, bGlobal);
	int32 StackTop = L->GetTop();

	// first argument (self/actor)
	L->PushValue(-(ItemsToPop + 1));
	int NArgs = 1;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	FLuaValue LastReturnValue;
	if (!L->PCall(NArgs, LastReturnValue, LUA_MULTRET))
	{
		if (L->InceptionLevel == 0)
		{
			if (bLogError)
				L->LogError(L->LastError);
			OnLuaError.Broadcast(L->LastError);
		}
	}
	else
	{
		int32 NumOfReturnValues = (L->GetTop() - StackTop) + 1;
		if (NumOfReturnValues > 0)
		{
			for (int32 i = -1; i >= -(NumOfReturnValues); i--)
			{
				ReturnValue.Insert(L->ToLuaValue(i), 0);
			}
			L->Pop(NumOfReturnValues - 1);
		}
	}

	// the return value and the function has been removed, so we do not need to change ItemsToPop
	L->Pop(ItemsToPop + 1);

	return ReturnValue;
}

FLuaValue ULuaComponent::LuaCallValue(FLuaValue Value, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return ReturnValue;

	// push function
	L->FromLuaValue(Value);
	// push component pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int NArgs = 1;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	if (!L->PCall(NArgs, ReturnValue))
	{
		if (L->InceptionLevel == 0)
		{
			if (bLogError)
				L->LogError(L->LastError);
			OnLuaError.Broadcast(L->LastError);
		}
	}

	L->Pop();

	return ReturnValue;
}

FLuaValue ULuaComponent::LuaCallValueIfNotNil(FLuaValue Value, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;
	if (Value.Type != ELuaValueType::Nil)
		ReturnValue = LuaCallValue(Value, Args);

	return ReturnValue;
}

FLuaValue ULuaComponent::LuaCallTableKey(FLuaValue InTable, FString Key, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;

	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetField(Key);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	return LuaCallValue(Value, Args);
}

FLuaValue ULuaComponent::LuaCallTableIndex(FLuaValue InTable, int32 Index, TArray<FLuaValue> Args)
{
	FLuaValue ReturnValue;

	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetFieldByIndex(Index);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	return LuaCallValue(Value, Args);
}

TArray<FLuaValue> ULuaComponent::LuaCallValueMulti(FLuaValue Value, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;

	ULuaState* L = Value.LuaState.Get();
	if (!L)
		return ReturnValue;

	// push function
	L->FromLuaValue(Value);
	int32 StackTop = L->GetTop();

	// push component pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int NArgs = 1;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	FLuaValue LastReturnValue;
	if (!L->PCall(NArgs, LastReturnValue, LUA_MULTRET))
	{
		if (L->InceptionLevel == 0)
		{
			if (bLogError)
				L->LogError(L->LastError);
			OnLuaError.Broadcast(L->LastError);
		}
	}
	else
	{
		int32 NumOfReturnValues = (L->GetTop() - StackTop) + 1;
		if (NumOfReturnValues > 0)
		{
			for (int32 i = -1; i >= -(NumOfReturnValues); i--)
			{
				ReturnValue.Insert(L->ToLuaValue(i), 0);
			}
			L->Pop(NumOfReturnValues - 1);
		}
	}

	L->Pop();

	return ReturnValue;
}

TArray<FLuaValue> ULuaComponent::LuaCallValueMultiIfNotNil(FLuaValue Value, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;
	if (Value.Type != ELuaValueType::Nil)
		ReturnValue = LuaCallValueMulti(Value, Args);

	return ReturnValue;
}

TArray<FLuaValue> ULuaComponent::LuaCallTableKeyMulti(FLuaValue InTable, FString Key, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;

	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetField(Key);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	return LuaCallValueMulti(Value, Args);
}

TArray<FLuaValue> ULuaComponent::LuaCallTableIndexMulti(FLuaValue InTable, int32 Index, TArray<FLuaValue> Args)
{
	TArray<FLuaValue> ReturnValue;

	if (InTable.Type != ELuaValueType::Table)
		return ReturnValue;

	ULuaState* L = InTable.LuaState.Get();
	if (!L)
		return ReturnValue;

	FLuaValue Value = InTable.GetFieldByIndex(Index);
	if (Value.Type == ELuaValueType::Nil)
		return ReturnValue;

	return LuaCallValueMulti(Value, Args);
}

FLuaValue ULuaComponent::ReceiveLuaMetaIndex_Implementation(FLuaValue Key)
{
	return FLuaValue();
}

bool ULuaComponent::ReceiveLuaMetaNewIndex_Implementation(FLuaValue Key, FLuaValue Value)
{
	return false;
}
```

`Source/LuaMachine/Private/LuaDelegate.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris


#include "LuaDelegate.h"
#include "LuaBlueprintFunctionLibrary.h"

void ULuaDelegate::LuaDelegateFunction()
{
}

void ULuaDelegate::SetupLuaDelegate(UFunction* InSignature, ULuaState* InLuaState, FLuaValue InLuaValue)
{
	LuaDelegateSignature = InSignature;
	LuaState = InLuaState;
	LuaValue = InLuaValue;
}

void ULuaDelegate::ProcessEvent(UFunction* Function, void* Parms)
{
	if (!LuaState.IsValid())
	{
		return;
	}

	TArray<FLuaValue> LuaArgs;
#if  ENGINE_MAJOR_VERSION > 4 ||ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(LuaDelegateSignature); (It && (It->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++It)
	{
		FProperty* Prop = *It;
#else
	for (TFieldIterator<UProperty> It(LuaDelegateSignature); (It && (It->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++It)
	{
		UProperty* Prop = *It;
#endif
		bool bPropSuccess = false;
		LuaArgs.Add(LuaState->FromProperty(Parms, Prop, bPropSuccess, 0));
	}

	ULuaBlueprintFunctionLibrary::LuaGlobalCallValue(LuaState->GetWorld(), LuaState->GetClass(), LuaValue, LuaArgs);
}

```

`Source/LuaMachine/Private/LuaGlobalNameComponent.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaGlobalNameComponent.h"
#include "LuaBlueprintFunctionLibrary.h"

// Sets default values for this component's properties
ULuaGlobalNameComponent::ULuaGlobalNameComponent()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = false;

	// ...
}

void ULuaGlobalNameComponent::OnRegister()
{
	Super::OnRegister();

	if (GetWorld()->IsGameWorld() && !LuaGlobalName.IsEmpty())
	{
		ULuaBlueprintFunctionLibrary::LuaSetGlobal(GetWorld(), LuaState, LuaGlobalName, FLuaValue(GetOwner()));
	}
}

// Called when the game starts
void ULuaGlobalNameComponent::BeginPlay()
{
	Super::BeginPlay();

	// ...
}


// Called every frame
void ULuaGlobalNameComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	// ...
}


```

`Source/LuaMachine/Private/LuaMachine.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaMachine.h"
#include "LuaBlueprintFunctionLibrary.h"
#if WITH_EDITOR
#include "Editor/UnrealEd/Public/Editor.h"
#include "Editor/PropertyEditor/Public/PropertyEditorModule.h"
#include "Runtime/Projects/Public/Interfaces/IPluginManager.h"
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
#include "Styling/SlateStyleRegistry.h"
#else
#include "SlateCore/Public/Styling/SlateStyleRegistry.h"
#endif
#endif

#define LOCTEXT_NAMESPACE "FLuaMachineModule"

void FLuaMachineModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
#if WITH_EDITOR
	FEditorDelegates::BeginPIE.AddRaw(this, &FLuaMachineModule::CleanupLuaStates);
	FEditorDelegates::EndPIE.AddRaw(this, &FLuaMachineModule::CleanupLuaStates);
#endif

	// streaming level hooks
	FWorldDelegates::LevelAddedToWorld.AddRaw(this, &FLuaMachineModule::LuaLevelAddedToWorld);
	FWorldDelegates::LevelRemovedFromWorld.AddRaw(this, &FLuaMachineModule::LuaLevelRemovedFromWorld);

}

void FLuaMachineModule::LuaLevelAddedToWorld(ULevel* Level, UWorld* World)
{
	for (ULuaState* LuaState : GetRegisteredLuaStates())
	{
#if ENGINE_MAJOR_VERSION > 4
		if (LuaState->IsValidLowLevel() && !IsValid(LuaState))
#else
		if (LuaState->IsValidLowLevel() && !LuaState->IsPendingKill())
#endif
		{
			LuaState->ReceiveLuaLevelAddedToWorld(Level, World);
		}
	}
}

void FLuaMachineModule::LuaLevelRemovedFromWorld(ULevel* Level, UWorld* World)
{
	for (ULuaState* LuaState : GetRegisteredLuaStates())
	{
#if ENGINE_MAJOR_VERSION > 4
		if (LuaState->IsValidLowLevel() && !IsValid(LuaState))
#else
		if (LuaState->IsValidLowLevel() && !LuaState->IsPendingKill())
#endif
		{
			LuaState->ReceiveLuaLevelRemovedFromWorld(Level, World);
		}
	}
}

void FLuaMachineModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

void FLuaMachineModule::AddReferencedObjects(FReferenceCollector& Collector)
{
	Collector.AddReferencedObjects(LuaStates);
}

void FLuaMachineModule::CleanupLuaStates(bool bIsSimulating)
{
	TArray<TSubclassOf<ULuaState>> LuaStatesKeys;
	LuaStates.GetKeys(LuaStatesKeys);

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
	TMap<TSubclassOf<ULuaState>, TObjectPtr<ULuaState>> PersistentLuaStates;
#else
	TMap<TSubclassOf<ULuaState>, ULuaState*> PersistentLuaStates;
#endif

	for (TSubclassOf<ULuaState> LuaStateClass : LuaStatesKeys)
	{
		if (LuaStates[LuaStateClass]->bPersistent)
		{
			PersistentLuaStates.Add(LuaStateClass, LuaStates[LuaStateClass]);
		}
		else
		{
			if (FLuaCommandExecutor* LuaConsole = LuaStates[LuaStateClass]->GetLuaConsole())
			{
				IModularFeatures::Get().UnregisterModularFeature(IConsoleCommandExecutor::ModularFeatureName(), LuaConsole);
			}
		}
	}

	LuaStates = PersistentLuaStates;
	OnRegisteredLuaStatesChanged.Broadcast();
}

ULuaState* FLuaMachineModule::GetLuaState(TSubclassOf<ULuaState> LuaStateClass, UWorld* InWorld, bool bCheckOnly)
{
	if (!LuaStateClass)
	{
		return nullptr;
	}

	if (LuaStateClass == ULuaState::StaticClass())
	{
		UE_LOG(LogLuaMachine, Error, TEXT("attempt to use LuaState Abstract class, please create a child of LuaState"));
		return nullptr;
	}

	if (!LuaStates.Contains(LuaStateClass))
	{
		if (bCheckOnly)
		{
			return nullptr;
		}
		ULuaState* NewLuaState = NewObject<ULuaState>((UObject*)GetTransientPackage(), LuaStateClass);
		LuaStates.Add(LuaStateClass, NewLuaState);
		OnNewLuaState.Broadcast(NewLuaState);
		OnRegisteredLuaStatesChanged.Broadcast();
	}

	return LuaStates[LuaStateClass]->GetLuaState(InWorld);
}

TArray<ULuaState*> FLuaMachineModule::GetRegisteredLuaStates()
{
	TArray<ULuaState*> RegisteredStates;
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
	for (TPair< TSubclassOf<ULuaState>, TObjectPtr<ULuaState>>& Pair : LuaStates)
#else
	for (TPair< TSubclassOf<ULuaState>, ULuaState*>& Pair : LuaStates)
#endif
	{
		RegisteredStates.Add(Pair.Value);
	}

	return RegisteredStates;
}

void FLuaMachineModule::UnregisterLuaState(ULuaState* LuaState)
{
	TSubclassOf<ULuaState> FoundLuaStateClass = nullptr;
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
	for (TPair< TSubclassOf<ULuaState>, TObjectPtr<ULuaState>>& Pair : LuaStates)
#else
	for (TPair< TSubclassOf<ULuaState>, ULuaState*>& Pair : LuaStates)
#endif
	{
		if (Pair.Value == LuaState)
		{
			FoundLuaStateClass = Pair.Key;
			break;
		}
	}

	if (FoundLuaStateClass)
	{
		LuaStates.Remove(FoundLuaStateClass);
	}

	// trick for waking up on low-level destructor
	OnRegisteredLuaStatesChanged.Broadcast();
}

void FLuaMachineModule::RegisterLuaConsoleCommand(const FString& CommandName, const FLuaValue& LuaConsoleCommand)
{
	// first check in lua console commands
	UnregisterLuaConsoleCommand(CommandName);
	if (IConsoleManager::Get().FindConsoleObject(*CommandName))
	{
		UE_LOG(LogLuaMachine, Error, TEXT("Lua Console Command Name \"%s\" is already in use."), *CommandName);
		return;
	}

	if (IConsoleManager::Get().RegisterConsoleCommand(*CommandName, *CommandName, FConsoleCommandWithArgsDelegate::CreateRaw(this, &FLuaMachineModule::RunLuaConsoleCommand, LuaConsoleCommand)))
	{
		LuaConsoleCommands.Add(CommandName);
	}
}

void FLuaMachineModule::UnregisterLuaConsoleCommand(const FString& CommandName)
{
	if (LuaConsoleCommands.Contains(CommandName))
	{
		IConsoleManager::Get().UnregisterConsoleObject(*CommandName);
		LuaConsoleCommands.Remove(CommandName);
	}
}

void FLuaMachineModule::RunLuaConsoleCommand(const TArray<FString>& Args, FLuaValue LuaConsoleCommand)
{
	TArray<FLuaValue> LuaArgs;
	for (FString Arg : Args)
	{
		LuaArgs.Add(FLuaValue(Arg));
	}
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(LuaConsoleCommand, LuaArgs);
}

FLuaMachineModule& FLuaMachineModule::Get()
{
	static FLuaMachineModule* Singleton = nullptr;
	if (Singleton == nullptr)
	{
		Singleton = &FModuleManager::LoadModuleChecked<FLuaMachineModule>("LuaMachine");
	}
	return *Singleton;
}

bool FLuaMachineModule::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
{
	if (FParse::Command(&Cmd, TEXT("luaspawn")))
	{
		if (!*Cmd)
		{
			UE_LOG(LogLuaMachine, Error, TEXT("please specify a valid LuaState path."));
			return false;
		}

		UObject* RequestedObject = LoadObject<UObject>(nullptr, Cmd);
		if (RequestedObject)
		{
			bool bLoaded = false;
			UClass* ObjectAsClass = Cast<UClass>(RequestedObject);
			if (ObjectAsClass && ObjectAsClass->IsChildOf<ULuaState>())
			{
				bLoaded = true;
			}

			if (!bLoaded)
			{
				UBlueprint* ObjectAsBlueprint = Cast<UBlueprint>(RequestedObject);
				if (ObjectAsBlueprint)
				{
					ObjectAsClass = ObjectAsBlueprint->GeneratedClass;
					if (ObjectAsClass && ObjectAsClass->IsChildOf<ULuaState>())
					{
						bLoaded = true;
					}
				}
			}

			if (bLoaded)
			{
				ULuaState* SpawnedState = FLuaMachineModule::Get().GetLuaState(ObjectAsClass, InWorld, false);
				if (SpawnedState)
				{
					UE_LOG(LogLuaMachine, Log, TEXT("%s spawned."), *SpawnedState->GetName());
				}
				return true;
			}

			UE_LOG(LogLuaMachine, Error, TEXT("specified argument is not a valid LuaState path."));
		}
	}

	return false;
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FLuaMachineModule, LuaMachine)
```

`Source/LuaMachine/Private/LuaMultiLineEditableTextBox.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaMultiLineEditableTextBox.h"
#include "Runtime/Slate/Public/Widgets/Input/SMultiLineEditableTextBox.h"
#include "Runtime/Slate/Public/Widgets/Input/SEditableTextBox.h"
#include "LuaSyntaxHighlighter.h"

#define LOCTEXT_NAMESPACE "UMG"

FLuaCustomHighlighter::FLuaCustomHighlighter()
{
	Color = FLinearColor::White;
}

ULuaMultiLineEditableTextBox::ULuaMultiLineEditableTextBox()
{
#if ENGINE_MAJOR_VERSION >=5 && ENGINE_MINOR_VERSION >= 2
	EditableTextBoxStyle.SetTextStyle(CodeStyle);
#endif

	SEditableTextBox::FArguments Defaults;
	WidgetStyle = *Defaults._Style;
	WidgetStyle.BackgroundColor = FSlateColor(FLinearColor::Black);
	WidgetStyle.ForegroundColor = FSlateColor(FLinearColor::White);

	TabSize = 2;

	bIsReadonly = false;
	bHandleTab = true;
	bHandleArrows = true;

	CodeStyle = FTextBlockStyle()
#if ENGINE_MAJOR_VERSION > 4 && ENGINE_MINOR_VERSION > 0
		.SetFont(WidgetStyle.TextStyle.Font)
#else
		.SetFont(WidgetStyle.Font)
#endif
		.SetColorAndOpacity(FLinearColor::White)
		.SetShadowOffset(FVector2D::ZeroVector)
		.SetSelectedBackgroundColor(FSlateColor(FLinearColor::Blue))
		.SetShadowColorAndOpacity(FLinearColor::Black);

	CommentColor = FLinearColor::Green;
	StringColor = FLinearColor(FColor::Orange);
	KeywordColor = FLinearColor(FColor::Cyan);
	NilColor = FLinearColor::Red;
	StdLibColor = FLinearColor::Yellow;
	BasicColor = FLinearColor(FColor::Magenta);

}

FText ULuaMultiLineEditableTextBox::GetText() const
{
	if (EditableTextBoxPtr.IsValid())
	{
		return EditableTextBoxPtr->GetText();
	}
	return FText::GetEmpty();
}

FText ULuaMultiLineEditableTextBox::GetSelectedText() const
{
	if (EditableTextBoxPtr.IsValid())
	{
		return EditableTextBoxPtr->GetSelectedText();
	}
	return FText::GetEmpty();
}

void  ULuaMultiLineEditableTextBox::SetText(FText InText)
{
	if (EditableTextBoxPtr.IsValid())
	{
		EditableTextBoxPtr->SetText(InText);
	}
}

FReply ULuaMultiLineEditableTextBox::OnKeyChar(const FGeometry& InGeometry, const FCharacterEvent& InCharacterEvent)
{
	const TCHAR Character = InCharacterEvent.GetCharacter();
	if (Character == TEXT('\t'))
	{
		FString Spaces;
		// using Max here for avoiding negative values
		for (int32 i = 0; i < FMath::Max(TabSize, 0); i++)
			Spaces = Spaces.AppendChar(TEXT(" ")[0]);
		EditableTextBoxPtr->ClearSelection();
		EditableTextBoxPtr->InsertTextAtCursor(Spaces);
		return FReply::Handled();
	}
	return EditableTextBoxPtr->SMultiLineEditableTextBox::OnKeyChar(InGeometry, InCharacterEvent);
}

FReply ULuaMultiLineEditableTextBox::OnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)
{
	FKey Key = InKeyEvent.GetKey();
	if (bHandleTab && Key == EKeys::Tab)
	{
		return FReply::Handled();
	}

	if (bHandleArrows)
	{
		if (Key == EKeys::Up)
		{
			MoveCursorUp();
			return FReply::Handled();
		}

		if (Key == EKeys::Down)
		{
			MoveCursorDown();
			return FReply::Handled();
		}

		if (Key == EKeys::Right)
		{
			MoveCursorRight();
			return FReply::Handled();
		}

		if (Key == EKeys::Left)
		{
			MoveCursorLeft();
			return FReply::Handled();
		}
	}

	return EditableTextBoxPtr->SMultiLineEditableTextBox::OnKeyDown(InGeometry, InKeyEvent);
}

void ULuaMultiLineEditableTextBox::OnCursorMoved(const FTextLocation& Location)
{
	CursorLocation = Location;
}

int32 ULuaMultiLineEditableTextBox::GetCursorLine() const
{
	return CursorLocation.GetLineIndex();
}

int32 ULuaMultiLineEditableTextBox::GetCursorColumn() const
{
	return CursorLocation.GetOffset();
}

void ULuaMultiLineEditableTextBox::CursorGoTo(int32 Line, int32 Column)
{
	if (Line < 0)
		Line = 0;
	if (Column < 0)
		Column = 0;
	return EditableTextBoxPtr->GoTo(FTextLocation(Line, Column));
}

void ULuaMultiLineEditableTextBox::MoveCursorUp()
{
	return CursorGoTo(CursorLocation.GetLineIndex() - 1, 0);
}

void ULuaMultiLineEditableTextBox::MoveCursorDown()
{
	return CursorGoTo(CursorLocation.GetLineIndex() + 1, 0);
}

void ULuaMultiLineEditableTextBox::MoveCursorRight()
{
	return CursorGoTo(CursorLocation.GetLineIndex(), CursorLocation.GetOffset() + 1);
}

void ULuaMultiLineEditableTextBox::MoveCursorLeft()
{
	return CursorGoTo(CursorLocation.GetLineIndex(), CursorLocation.GetOffset() - 1);
}

void ULuaMultiLineEditableTextBox::SynchronizeProperties()
{
	Super::SynchronizeProperties();

	EditableTextBoxPtr->SetStyle(&WidgetStyle);

	Super::SynchronizeTextLayoutProperties(*EditableTextBoxPtr);
}

#if WITH_EDITOR
const FText ULuaMultiLineEditableTextBox::GetPaletteCategory()
{
	return LOCTEXT("Lua", "Lua");
}
#endif

void ULuaMultiLineEditableTextBox::ReleaseSlateResources(bool bReleaseChildren)
{
	Super::ReleaseSlateResources(bReleaseChildren);

	EditableTextBoxPtr.Reset();
}

TSharedRef<SWidget> ULuaMultiLineEditableTextBox::RebuildWidget()
{
	FLuaSyntaxTextStyle Style;
	Style.NormalTextStyle = CodeStyle;
	Style.CommentTextStyle = FTextBlockStyle(CodeStyle).SetColorAndOpacity(CommentColor);
	Style.KeywordTextStyle = FTextBlockStyle(CodeStyle).SetColorAndOpacity(KeywordColor);
	Style.NilTextStyle = FTextBlockStyle(CodeStyle).SetColorAndOpacity(NilColor);
	Style.BasicTextStyle = FTextBlockStyle(CodeStyle).SetColorAndOpacity(BasicColor);
	Style.StdLibTextStyle = FTextBlockStyle(CodeStyle).SetColorAndOpacity(StdLibColor);
	Style.StringTextStyle = FTextBlockStyle(CodeStyle).SetColorAndOpacity(StringColor);
	for (FLuaCustomHighlighter& Highlighter : CustomTokensMapping)
	{
		for (FString& Token : Highlighter.Tokens)
		{
			Style.CustomTextColorMapping.Add(Token, Highlighter.Color);
		}
	}

	EditableTextBoxPtr = SNew(SMultiLineEditableTextBox)
		.Marshaller(FLuaMachineSyntaxHighlighterTextLayoutMarshaller::Create(Style))
#if ENGINE_MAJOR_VERSION >=5 && ENGINE_MINOR_VERSION >= 1
		.Style(&EditableTextBoxStyle)
#else
		.TextStyle(&CodeStyle)
#endif
		.OnKeyCharHandler_UObject(this, &ULuaMultiLineEditableTextBox::OnKeyChar)
		.OnKeyDownHandler_UObject(this, &ULuaMultiLineEditableTextBox::OnKeyDown)
		.IsReadOnly(bIsReadonly)
		.AllowContextMenu(false)
		.OnCursorMoved_UObject(this, &ULuaMultiLineEditableTextBox::OnCursorMoved)
		.Style(&WidgetStyle);

	return EditableTextBoxPtr.ToSharedRef();
}

#undef LOCTEXT_NAMESPACE
```

`Source/LuaMachine/Private/LuaState.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaState.h"
#include "LuaComponent.h"
#include "LuaUserDataObject.h"
#include "LuaMachine.h"
#include "LuaBlueprintPackage.h"
#include "LuaBlueprintFunctionLibrary.h"
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION > 0
#include "AssetRegistry/AssetRegistryModule.h"
#else
#include "AssetRegistryModule.h"
#endif
#include "GameFramework/Actor.h"
#include "Runtime/Core/Public/Misc/FileHelper.h"
#include "Runtime/Core/Public/Misc/Paths.h"
#include "Runtime/Core/Public/Serialization/BufferArchive.h"
#include "Runtime/CoreUObject/Public/UObject/TextProperty.h"

LUAMACHINE_API DEFINE_LOG_CATEGORY(LogLuaMachine);

ULuaState::ULuaState()
{
	L = nullptr;
	bLuaOpenLibs = true;
	bDisabled = false;
	bLogError = true;
	bAddProjectContentDirToPackagePath = true;
	bPersistent = false;
	bEnableLineHook = false;
	bEnableCallHook = false;
	bEnableReturnHook = false;
	bEnableCountHook = false;
	bRawLuaFunctionCall = false;

	FCoreUObjectDelegates::GetPostGarbageCollect().AddUObject(this, &ULuaState::GCLuaDelegatesCheck);
}

ULuaState* ULuaState::GetLuaState(UWorld* InWorld)
{
	CurrentWorld = InWorld;

	if (L != nullptr)
	{
		return this;
	}

	if (bDisabled)
	{
		return nullptr;
	}

	L = luaL_newstate();

	if (bLuaOpenLibs)
	{
		luaL_openlibs(L);
	}

	// load "package" for allowing minimal setup
	luaL_requiref(L, "package", luaopen_package, 1);
	lua_pop(L, 1);

	if (!bLuaOpenLibs)
	{
		if (LuaLibsLoader.bLoadBase)
		{
			luaL_requiref(L, "_G", luaopen_base, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadCoroutine)
		{
			luaL_requiref(L, "coroutine", luaopen_coroutine, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadTable)
		{
			luaL_requiref(L, "table", luaopen_table, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadIO)
		{
			luaL_requiref(L, "io", luaopen_io, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadOS)
		{
			luaL_requiref(L, "os", luaopen_os, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadString)
		{
			luaL_requiref(L, "string", luaopen_string, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadMath)
		{
			luaL_requiref(L, "math", luaopen_math, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadUTF8)
		{
			luaL_requiref(L, "utf8", luaopen_utf8, 1);
			lua_pop(L, 1);
		}

		if (LuaLibsLoader.bLoadDebug)
		{
			luaL_requiref(L, "debug", luaopen_debug, 1);
			lua_pop(L, 1);
		}
	}

	ULuaState** LuaExtraSpacePtr = (ULuaState**)lua_getextraspace(L);
	*LuaExtraSpacePtr = this;
	// get the global table
	lua_pushglobaltable(L);
	// override print
	PushCFunction(ULuaState::TableFunction_print);
	SetField(-2, "print");

	GetField(-1, "package");
	if (!OverridePackagePath.IsEmpty())
	{
		OverridePackagePath.ReplaceInline(*FString("$(CONTENT_DIR)"), *FPaths::ProjectContentDir());
		lua_pushstring(L, TCHAR_TO_ANSI(*OverridePackagePath));
		SetField(-2, "path");
	}

	if (bAddProjectContentDirToPackagePath)
	{
		GetField(-1, "path");
		const char* CurrentLuaPath = lua_tostring(L, -1);
		FString NewPackagePath = FString(CurrentLuaPath) + ";" + FPaths::ProjectContentDir() + "/?.lua";
		Pop();
		lua_pushstring(L, TCHAR_TO_ANSI(*NewPackagePath));
		SetField(-2, "path");
	}

	for (FString SubDir : AppendProjectContentDirSubDir)
	{
		GetField(-1, "path");
		const char* CurrentLuaPath = lua_tostring(L, -1);
		FString NewPackagePath = FString(CurrentLuaPath) + ";" + FPaths::ProjectContentDir() / SubDir + "/?.lua";
		Pop();
		lua_pushstring(L, TCHAR_TO_ANSI(*NewPackagePath));
		SetField(-2, "path");
	}

	if (!OverridePackageCPath.IsEmpty())
	{
		OverridePackageCPath.ReplaceInline(*FString("$(CONTENT_DIR)"), *FPaths::ProjectContentDir());

		static const FString libExtension =
#if PLATFORM_MAC || PLATFORM_IOS
			FString("dylib");
#elif PLATFORM_LINUX || PLATFORM_ANDROID
			FString("so");
#elif PLATFORM_WINDOWS
			FString("dll");
#else
			FString("");
#endif

		OverridePackageCPath.ReplaceInline(*FString("$(LIB_EXT)"), *libExtension);

		lua_pushstring(L, TCHAR_TO_ANSI(*OverridePackageCPath));
		SetField(-2, "cpath");
	}
	// manage RequireTable
	GetField(-1, "preload");
	for (TPair<FString, ULuaCode*>& Pair : RequireTable)
	{
		PushCFunction(ULuaState::TableFunction_package_preload);
		SetField(-2, TCHAR_TO_ANSI(*Pair.Key));
	}

	// pop package.prelod
	Pop(1);

	// manage searchers
	GetField(-1, "searchers");
	PushCFunction(ULuaState::TableFunction_package_loader);
	constexpr int PackageLoadersFirstAvailableIndex = 5;
	lua_seti(L, -2, PackageLoadersFirstAvailableIndex);

	// pop package.searchers (and package)
	Pop(2);


	for (TPair<FString, FLuaValue>& Pair : Table)
	{
		FromLuaValue(Pair.Value, this, L);
		SetField(-2, TCHAR_TO_ANSI(*Pair.Key));
	}

	for (TPair<FString, TSubclassOf<ULuaBlueprintPackage>>& Pair : LuaBlueprintPackagesTable)
	{
		if (Pair.Value)
		{
			NewTable();
			ULuaBlueprintPackage* LuaBlueprintPackage = NewObject<ULuaBlueprintPackage>(this, Pair.Value);
			if (LuaBlueprintPackage)
			{
				for (auto LuaPair : LuaBlueprintPackage->Table)
				{
					FromLuaValue(LuaPair.Value, LuaBlueprintPackage);
					SetField(-2, TCHAR_TO_ANSI(*LuaPair.Key));
				}
				// this avoid the package to be GC'd
				LuaBlueprintPackages.Add(Pair.Key, LuaBlueprintPackage);
				LuaBlueprintPackage->SelfTable = ToLuaValue(-1);
				LuaBlueprintPackage->Init();
				LuaBlueprintPackage->ReceiveInit();
			}
		}
		else
		{
			PushNil();
		}
		SetField(-2, TCHAR_TO_ANSI(*Pair.Key));
	}

	// pop global table
	Pop();

	// This allows subclasses to do any last minute initialization on lua state before
	// we load code
	ReceiveLuaStatePreInitialized();

	int DebugMask = 0;
	// install hooks
	if (bEnableLineHook)
	{
		DebugMask |= LUA_MASKLINE;
	}
	if (bEnableCallHook)
	{
		DebugMask |= LUA_MASKCALL;
	}
	if (bEnableReturnHook)
	{
		DebugMask |= LUA_MASKRET;
	}
	if (bEnableCountHook)
	{
		DebugMask |= LUA_MASKCOUNT;
	}

	if (DebugMask != 0)
	{
		lua_sethook(L, Debug_Hook, DebugMask, HookInstructionCount);
	}

	if (LuaCodeAsset)
	{
		if (!RunCodeAsset(LuaCodeAsset))
		{
			if (bLogError)
				LogError(LastError);
			ReceiveLuaError(LastError);
			bDisabled = true;
			return nullptr;
		}
	}

	if (!LuaFilename.IsEmpty())
	{
		if (!RunFile(LuaFilename, true))
		{
			if (bLogError)
				LogError(LastError);
			ReceiveLuaError(LastError);
			bDisabled = true;
			return nullptr;
		}
	}

	if (UserDataMetaTableFromCodeAsset)
	{
		if (!RunCodeAsset(UserDataMetaTableFromCodeAsset, 1))
		{
			if (bLogError)
				LogError(LastError);
			ReceiveLuaError(LastError);
			bDisabled = true;
			return nullptr;
		}
		UserDataMetaTable = ToLuaValue(-1);
		Pop();
	}

	LuaStateInit();
	ReceiveLuaStateInitialized();

#if WITH_EDITOR
	if (!(GetFlags() & RF_ClassDefaultObject))
	{
		LuaConsole.LuaState = this;
		IModularFeatures::Get().RegisterModularFeature(IConsoleCommandExecutor::ModularFeatureName(), &LuaConsole);
	}
#endif


	return this;
}

FLuaValue ULuaState::GetLuaBlueprintPackageTable(const FString& PackageName)
{
	if (!LuaBlueprintPackages.Contains(PackageName))
	{
		return FLuaValue();
	}

	return LuaBlueprintPackages[PackageName]->SelfTable;
}

bool ULuaState::RunCodeAsset(ULuaCode* CodeAsset, int NRet)
{

	if (CodeAsset->bCooked && CodeAsset->bCookAsBytecode)
	{
#if PLATFORM_ANDROID
		// fix size_t of the bytecode
		if (CodeAsset->ByteCode.Num() >= 14)
			CodeAsset->ByteCode[13] = sizeof(size_t);
#endif
		return RunCode(CodeAsset->ByteCode, CodeAsset->GetPathName(), NRet);
	}

	return RunCode(CodeAsset->Code.ToString(), CodeAsset->GetPathName(), NRet);

}

bool ULuaState::RunFile(const FString& Filename, bool bIgnoreNonExistent, int NRet, bool bNonContentDirectory)
{
	TArray<uint8> Code;
	FString AbsoluteFilename = FPaths::Combine(FPaths::ProjectContentDir(), Filename);

	if (bNonContentDirectory)
	{
		AbsoluteFilename = Filename;
	}

	if (!FPaths::FileExists(AbsoluteFilename))
	{
		if (bIgnoreNonExistent)
			return true;
		LastError = FString::Printf(TEXT("Unable to open file %s"), *Filename);
		FLuaValue LuaLastError = FLuaValue(LastError);
		FromLuaValue(LuaLastError);
		return false;
	}

	if (FFileHelper::LoadFileToArray(Code, *AbsoluteFilename))
	{
		if (RunCode(Code, AbsoluteFilename, NRet))
		{
			return true;
		}
		return false;
	}

	LastError = FString::Printf(TEXT("Unable to open file %s"), *Filename);
	FLuaValue LuaLastError = FLuaValue(LastError);
	FromLuaValue(LuaLastError);
	return false;
}

bool ULuaState::RunCode(const FString& Code, const FString& CodePath, int NRet)
{
	TArray<uint8> Bytes;
	Bytes.Append((uint8*)TCHAR_TO_UTF8(*Code), FCStringAnsi::Strlen(TCHAR_TO_UTF8(*Code)));
	return RunCode(Bytes, CodePath, NRet);
}

bool ULuaState::RunCode(const TArray<uint8>& Code, const FString& CodePath, int NRet)
{
	FString FullCodePath = FString("@") + CodePath;

	if (luaL_loadbuffer(L, (const char*)Code.GetData(), Code.Num(), TCHAR_TO_ANSI(*FullCodePath)))
	{
		LastError = FString::Printf(TEXT("Lua loading error: %s"), ANSI_TO_TCHAR(lua_tostring(L, -1)));
		return false;
	}
	else
	{

		if (lua_pcall(L, 0, NRet, 0))
		{
			LastError = FString::Printf(TEXT("Lua execution error: %s"), ANSI_TO_TCHAR(lua_tostring(L, -1)));
			return false;
		}
	}

	return true;
}

int ULuaState::ToByteCode_Writer(lua_State* L, const void* Ptr, size_t Size, void* UserData)
{
	TArray<uint8>* Output = (TArray<uint8>*)UserData;
	Output->Append((uint8*)Ptr, Size);
	return 0;
}

TArray<uint8> ULuaState::ToByteCode(const FString& Code, const FString& CodePath, FString& ErrorString)
{
	const TCHAR* CodeRaw = *Code;
	FString FullCodePath = FString("@") + CodePath;
	TArray<uint8> Output;

	lua_State* L = luaL_newstate();
	if (luaL_loadbuffer(L, TCHAR_TO_UTF8(CodeRaw), FCStringAnsi::Strlen(TCHAR_TO_UTF8(CodeRaw)), TCHAR_TO_ANSI(*FullCodePath)))
	{
		ErrorString = ANSI_TO_TCHAR(lua_tostring(L, -1));
		Output.Empty();
		lua_close(L);
		return Output;
	}

	if (lua_dump(L, ULuaState::ToByteCode_Writer, &Output, 1))
	{
		ErrorString = ANSI_TO_TCHAR(lua_tostring(L, -1));
		Output.Empty();
		lua_close(L);
		return Output;
	}

	lua_close(L);
	return Output;
}

void ULuaState::FromLuaValue(FLuaValue& LuaValue, UObject* CallContext, lua_State* State)
{
	if (!State)
	{
		State = this->L;
	}

	switch (LuaValue.Type)
	{
	case ELuaValueType::Bool:
		lua_pushboolean(State, LuaValue.Bool ? 1 : 0);
		break;
	case ELuaValueType::Integer:
		lua_pushinteger(State, LuaValue.Integer);
		break;
	case ELuaValueType::Number:
		lua_pushnumber(State, LuaValue.Number);
		break;
	case ELuaValueType::String:
	{
		TArray<uint8> Bytes = LuaValue.ToBytes();
		lua_pushlstring(State, (const char*)Bytes.GetData(), Bytes.Num());
	}
	break;
	case ELuaValueType::Table:
		if (LuaValue.LuaRef == LUA_NOREF)
		{
			lua_newtable(State);
			lua_pushvalue(State, -1);
			// hold references in the main state
			LuaValue.LuaRef = luaL_ref(this->L, LUA_REGISTRYINDEX);
			LuaValue.LuaState = this;
			break;
		}
		if (this != LuaValue.LuaState)
		{
			lua_pushnil(State);
			break;
		}
		lua_rawgeti(this->L, LUA_REGISTRYINDEX, LuaValue.LuaRef);
		if (this->L != State)
			lua_xmove(this->L, State, 1);
		break;
	case ELuaValueType::Thread:
		if (LuaValue.LuaRef == LUA_NOREF)
		{
			lua_newthread(State);
			lua_pushvalue(State, -1);
			LuaValue.LuaRef = luaL_ref(this->L, LUA_REGISTRYINDEX);
			LuaValue.LuaState = this;
			break;
		}
		if (this != LuaValue.LuaState)
		{
			lua_pushnil(State);
			break;
		}
		lua_rawgeti(this->L, LUA_REGISTRYINDEX, LuaValue.LuaRef);
		if (this->L != State)
			lua_xmove(this->L, State, 1);
		break;
	case ELuaValueType::Function:
		if (this != LuaValue.LuaState || LuaValue.LuaRef == LUA_NOREF)
		{
			lua_pushnil(State);
			break;
		}
		lua_rawgeti(this->L, LUA_REGISTRYINDEX, LuaValue.LuaRef);
		if (this->L != State)
			lua_xmove(this->L, State, 1);
		break;
	case ELuaValueType::UObject:
	{
		if (!LuaValue.Object)
		{
			lua_pushnil(State);
			break;
		}

		NewUObject(LuaValue.Object, State);
		if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(LuaValue.Object))
		{
			if (!LuaComponent->LuaState)
			{
				UE_LOG(LogLuaMachine, Warning, TEXT("%s has no associated LuaState"), *LuaComponent->GetFullName());
			}
			// ensure we are in the same LuaState
			else if (LuaComponent->LuaState == GetClass())
			{
				SetupAndAssignUserDataMetatable(LuaComponent, LuaComponent->Metatable, State);
			}
		}
		else if (ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(LuaValue.Object))
		{
			if (!LuaUserDataObject->GetLuaState())
			{
				UE_LOG(LogLuaMachine, Warning, TEXT("%s has no associated LuaState"), *LuaUserDataObject->GetFullName());
			}
			// ensure we are in the same LuaState
			else if (LuaUserDataObject->GetLuaState() == GetClass())
			{
				SetupAndAssignUserDataMetatable(LuaUserDataObject, LuaUserDataObject->Metatable, State);
			}
		}
		else
		{
			if (UserDataMetaTable.Type == ELuaValueType::Table)
			{
				FromLuaValue(UserDataMetaTable, nullptr, State);
			}
			else
			{
				lua_newtable(State);
				// allow comparison between userdata/UObject/UFunction
				lua_pushcfunction(State, ULuaState::MetaTableFunctionUserData__eq);
				lua_setfield(State, -2, "__eq");
			}
			lua_setmetatable(State, -2);
		}
	}
	break;
	case ELuaValueType::UFunction:
		// if no context is assigned to the function, own it !
		if (!LuaValue.LuaState.IsValid())
		{
			LuaValue.LuaState = this;
		}
		if (this != LuaValue.LuaState)
		{
			lua_pushnil(State);
			break;
		}
		// first time we should have a CallContext, then we cache it in the Object field
		if (!CallContext)
		{
			CallContext = LuaValue.Object;
		}
		if (CallContext)
		{
			UObject* FunctionOwner = CallContext;
			if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(CallContext))
			{
				FunctionOwner = LuaComponent->GetOwner();
			}

			if (FunctionOwner)
			{
				UFunction* Function = FunctionOwner->FindFunction(LuaValue.FunctionName);
				if (Function)
				{
					// cache it for context-less calls
					LuaValue.Object = CallContext;
					FLuaUserData* LuaCallContext = (FLuaUserData*)lua_newuserdata(State, sizeof(FLuaUserData));
					LuaCallContext->Type = ELuaValueType::UFunction;
					LuaCallContext->Context = CallContext;
					LuaCallContext->Function = Function;
					lua_newtable(State);
					lua_pushcfunction(State, bRawLuaFunctionCall ? ULuaState::MetaTableFunction__rawcall : ULuaState::MetaTableFunction__call);
					lua_setfield(State, -2, "__call");
					lua_setmetatable(State, -2);
					return;
				}
			}
		}
		// no function found
		lua_pushnil(State);
		break;
	case ELuaValueType::MulticastDelegate:
		// if no context is assigned to the function, own it !
		if (!LuaValue.LuaState.IsValid())
		{
			LuaValue.LuaState = this;
		}

		if (this != LuaValue.LuaState)
		{
			lua_pushnil(State);
			break;
		}
		{
			FLuaUserData* LuaCallContext = (FLuaUserData*)lua_newuserdata(State, sizeof(FLuaUserData));
			LuaCallContext->Type = ELuaValueType::MulticastDelegate;
			LuaCallContext->Function = reinterpret_cast<UFunction*>(LuaValue.Object);
			LuaCallContext->MulticastScriptDelegate = LuaValue.MulticastScriptDelegate;
			lua_newtable(State);
			lua_pushcfunction(State, bRawLuaFunctionCall ? ULuaState::MetaTableFunction__rawbroadcast : ULuaState::MetaTableFunction__rawbroadcast);
			lua_setfield(State, -2, "__call");
			lua_setmetatable(State, -2);
			return;
		}
		break;
	default:
		lua_pushnil(State);
	}
}

FLuaValue ULuaState::ToLuaValue(int Index, lua_State* State)
{
	if (!State)
	{
		State = this->L;
	}

	FLuaValue LuaValue;

	if (lua_isboolean(State, Index))
	{
		LuaValue = FLuaValue(lua_toboolean(State, Index) != 0);
	}
	else if (lua_type(State, Index) == LUA_TSTRING)
	{
		size_t StringLength = 0;
		const char* String = lua_tolstring(State, Index, &StringLength);
		LuaValue = FLuaValue(String, StringLength);
	}
	else if (lua_isinteger(State, Index))
	{
		LuaValue = FLuaValue(lua_tointeger(State, Index));
	}
	else if (lua_type(State, Index) == LUA_TNUMBER)
	{
		LuaValue = FLuaValue(lua_tonumber(State, Index));
	}
	else if (lua_istable(State, Index))
	{
		lua_pushvalue(State, Index);
		if (State != this->L)
			lua_xmove(State, this->L, 1);
		LuaValue.Type = ELuaValueType::Table;
		LuaValue.LuaState = this;
		LuaValue.LuaRef = luaL_ref(this->L, LUA_REGISTRYINDEX);
	}
	else if (lua_isthread(State, Index))
	{
		lua_pushvalue(State, Index);
		if (State != this->L)
			lua_xmove(State, this->L, 1);
		LuaValue.Type = ELuaValueType::Thread;
		LuaValue.LuaState = this;
		LuaValue.LuaRef = luaL_ref(this->L, LUA_REGISTRYINDEX);
	}
	else if (lua_isfunction(State, Index))
	{
		lua_pushvalue(State, Index);
		if (State != this->L)
			lua_xmove(State, this->L, 1);
		LuaValue.Type = ELuaValueType::Function;
		LuaValue.LuaState = this;
		LuaValue.LuaRef = luaL_ref(this->L, LUA_REGISTRYINDEX);
	}
	else if (lua_isuserdata(State, Index))
	{
		FLuaUserData* UserData = (FLuaUserData*)lua_touserdata(State, Index);
		switch (UserData->Type)
		{
		case(ELuaValueType::UObject):
			if (UserData->Context.IsValid())
			{
				LuaValue.Type = UserData->Type;
				LuaValue.Object = UserData->Context.Get();
				LuaValue.LuaState = this;
			}
			break;
		case(ELuaValueType::UFunction):
			if (UserData->Context.IsValid() && UserData->Function.IsValid())
			{
				LuaValue.Type = UserData->Type;
				LuaValue.FunctionName = UserData->Function->GetFName();
				LuaValue.Object = UserData->Context.Get();
				LuaValue.LuaState = this;
			}
			break;
		}
	}

	return LuaValue;
}

int32 ULuaState::GetTop()
{
	return lua_gettop(L);
}

int ULuaState::MetaTableFunctionUserData__index(lua_State* L)
{

	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	FLuaUserData* UserData = (FLuaUserData*)lua_touserdata(L, 1);

	if (!UserData->Context.IsValid())
	{
		return luaL_error(L, "invalid UObject for UserData %p", UserData);
	}

	TMap<FString, FLuaValue>* TablePtr = nullptr;
	UObject* Context = UserData->Context.Get();

	ULuaUserDataObject* LuaUserDataObject = nullptr;
	ULuaComponent* LuaComponent = nullptr;

	FString Key = ANSI_TO_TCHAR(lua_tostring(L, 2));

	LuaComponent = Cast<ULuaComponent>(Context);

	if (LuaComponent)
	{
		TablePtr = &LuaComponent->Table;
	}
	else
	{
		LuaUserDataObject = Cast<ULuaUserDataObject>(Context);
		if (LuaUserDataObject)
		{
			TablePtr = &LuaUserDataObject->Table;
		}
	}

	if (TablePtr)
	{
		FLuaValue* LuaValue = TablePtr->Find(Key);
		if (LuaValue)
		{
			LuaState->FromLuaValue(*LuaValue, Context, L);
			return 1;

		}
	}

	if (LuaComponent)
	{
		FLuaValue MetaIndexReturnValue = LuaComponent->ReceiveLuaMetaIndex(Key);
		LuaState->FromLuaValue(MetaIndexReturnValue, Context, L);
		return 1;
	}

	if (LuaUserDataObject)
	{
		FLuaValue MetaIndexReturnValue = LuaUserDataObject->ReceiveLuaMetaIndex(Key);
		LuaState->FromLuaValue(MetaIndexReturnValue, MetaIndexReturnValue.Object ? MetaIndexReturnValue.Object : Context, L);
		return 1;
	}

	lua_pushnil(L);
	return 1;
}

int ULuaState::MetaTableFunctionUserData__newindex(lua_State* L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	FLuaUserData* UserData = (FLuaUserData*)lua_touserdata(L, 1);
	if (!UserData->Context.IsValid())
	{
		return luaL_error(L, "invalid UObject for UserData %p", UserData);
	}

	TMap<FString, FLuaValue>* TablePtr = nullptr;
	UObject* Context = UserData->Context.Get();

	ULuaComponent* LuaComponent = Cast<ULuaComponent>(Context);

	if (LuaComponent)
	{
		TablePtr = &LuaComponent->Table;
	}
	else if (ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(Context))
	{
		TablePtr = &LuaUserDataObject->Table;
	}

	if (TablePtr)
	{
		FString Key = ANSI_TO_TCHAR(lua_tostring(L, 2));

		FLuaValue* LuaValue = TablePtr->Find(Key);
		if (LuaValue)
		{
			*LuaValue = LuaState->ToLuaValue(3, L);
		}
		else
		{
			if (LuaComponent)
			{
				if (LuaComponent->ReceiveLuaMetaNewIndex(LuaState->ToLuaValue(2, L), LuaState->ToLuaValue(3, L)))
				{
					return 0;
				}
			}
			TablePtr->Add(Key, LuaState->ToLuaValue(3, L));
		}
	}

	return 0;
}

FLuaDebug ULuaState::LuaGetInfo(int32 Level)
{
	lua_Debug ar;
	if (lua_getstack(L, Level, &ar) != 1)
		return FLuaDebug();
	lua_getinfo(L, "lSn", &ar);
	FLuaDebug LuaDebug;
	LuaDebug.CurrentLine = ar.currentline;
	LuaDebug.Source = ANSI_TO_TCHAR(ar.source);
	LuaDebug.Name = ANSI_TO_TCHAR(ar.name);
	LuaDebug.NameWhat = ANSI_TO_TCHAR(ar.namewhat);
	LuaDebug.What = ANSI_TO_TCHAR(ar.what);

	return LuaDebug;
}

TMap<FString, FLuaValue> ULuaState::LuaGetLocals(int32 Level)
{
	TMap<FString, FLuaValue> ReturnValue;

	lua_Debug ar;
	if (lua_getstack(L, Level, &ar) != 1)
		return ReturnValue;

	int Index = 1;
	const char* name = lua_getlocal(L, &ar, Index);
	while (name)
	{
		FLuaValue LuaValue = ToLuaValue(-1);
		ReturnValue.Add(ANSI_TO_TCHAR(name), LuaValue);
		Pop();
		name = lua_getlocal(L, &ar, ++Index);
	}
	return ReturnValue;
}

void ULuaState::Debug_Hook(lua_State* L, lua_Debug* ar)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	FLuaDebug LuaDebug;
	lua_getinfo(L, "lSn", ar);
	LuaDebug.CurrentLine = ar->currentline;
	LuaDebug.Source = ANSI_TO_TCHAR(ar->source);
	LuaDebug.Name = ANSI_TO_TCHAR(ar->name);
	LuaDebug.NameWhat = ANSI_TO_TCHAR(ar->namewhat);
	LuaDebug.What = ANSI_TO_TCHAR(ar->what);

	switch (ar->event)
	{
	case LUA_HOOKLINE:
		LuaState->ReceiveLuaLineHook(LuaDebug);
		break;
	case LUA_HOOKCALL:
		LuaState->ReceiveLuaCallHook(LuaDebug);
		break;
	case LUA_HOOKRET:
		LuaState->ReceiveLuaReturnHook(LuaDebug);
		break;
	case LUA_HOOKCOUNT:
		LuaState->ReceiveLuaCountHook(LuaDebug);
		break;
	default:
		break;
	}
}

int ULuaState::MetaTableFunctionUserData__eq(lua_State* L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);

	FLuaUserData* UserData = (FLuaUserData*)lua_touserdata(L, 1);
	if (!UserData->Context.IsValid())
	{
		return luaL_error(L, "invalid UObject for UserData %p", UserData);
	}

	FLuaUserData* UserData2 = (FLuaUserData*)lua_touserdata(L, 2);
	if (!UserData2->Context.IsValid())
	{
		return luaL_error(L, "invalid UObject for UserData %p", UserData2);
	}

	if (UserData->Type == UserData2->Type && UserData->Context.Get() == UserData2->Context.Get())
	{
		if (UserData->Type == ELuaValueType::UFunction)
		{
			if (!UserData->Function.IsValid())
			{
				return luaL_error(L, "invalid UFunction for UserData %p", UserData);
			}
			if (!UserData2->Function.IsValid())
			{
				return luaL_error(L, "invalid UFunction for UserData %p", UserData2);
			}
			if (UserData->Function.Get() == UserData2->Function.Get())
			{
				lua_pushboolean(L, 1);
				return 1;
			}
		}
		else if (UserData->Type == ELuaValueType::UObject)
		{
			lua_pushboolean(L, 1);
			return 1;
		}
	}

	lua_pushboolean(L, 0);
	return 1;
}

int ULuaState::MetaTableFunctionUserData__gc(lua_State* L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);

	FLuaUserData* UserData = (FLuaUserData*)lua_touserdata(L, 1);
	if (!UserData->Context.IsValid())
	{
		return luaL_error(L, "invalid UObject for UserData %p", UserData);
	}

	ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(UserData->Context.Get());
	if (LuaUserDataObject)
	{
		LuaState->TrackedLuaUserDataObjects.Remove(LuaUserDataObject);
		LuaUserDataObject->ReceiveLuaGC();
	}

	lua_pushnil(L);
	return 1;
}

int ULuaState::MetaTableFunction__call(lua_State* L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	FLuaUserData* LuaCallContext = (FLuaUserData*)lua_touserdata(L, 1);

	if (!LuaCallContext->Context.IsValid() || !LuaCallContext->Function.IsValid())
	{
		return luaL_error(L, "invalid lua UFunction for UserData %p", LuaCallContext);
	}

	int NArgs = lua_gettop(L);

	UObject* CallScope = LuaCallContext->Context.Get();
	bool bImplicitSelf = false;
	int StackPointer = 2;

	if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(CallScope))
	{
		CallScope = LuaComponent->GetOwner();
		if (NArgs > 0)
		{
			FLuaValue LuaFirstArgument = LuaState->ToLuaValue(StackPointer, L);
			if (LuaFirstArgument.Type == ELuaValueType::UObject && LuaFirstArgument.Object == LuaComponent)
			{
				bImplicitSelf = LuaComponent->bImplicitSelf;
			}
		}
	}
	else if (ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(CallScope))
	{
		if (NArgs > 0)
		{
			FLuaValue LuaFirstArgument = LuaState->ToLuaValue(StackPointer, L);
			if (LuaFirstArgument.Type == ELuaValueType::UObject && LuaFirstArgument.Object == LuaUserDataObject)
			{
				bImplicitSelf = LuaUserDataObject->bImplicitSelf;
			}
		}
	}

	FScopeCycleCounterUObject ObjectScope(CallScope);
	FScopeCycleCounterUObject FunctionScope(LuaCallContext->Function.Get());

	void* Parameters = FMemory_Alloca(LuaCallContext->Function->ParmsSize);
	FMemory::Memzero(Parameters, LuaCallContext->Function->ParmsSize);

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
	{
		FProperty* Prop = *It;
#else
	for (TFieldIterator<UProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
	{
		UProperty* Prop = *It;
#endif
		if (!Prop->HasAnyPropertyFlags(CPF_ZeroConstructor))
		{
			Prop->InitializeValue_InContainer(Parameters);
		}
	}

	if (bImplicitSelf)
	{
		NArgs--;
		StackPointer++;
	}

	// arguments
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> FArgs(LuaCallContext->Function.Get()); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
	{
		FProperty* Prop = *FArgs;
		FStructProperty* LuaProp = CastField<FStructProperty>(Prop);
#else
	for (TFieldIterator<UProperty> FArgs(LuaCallContext->Function.Get()); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
	{
		UProperty* Prop = *FArgs;
		UStructProperty* LuaProp = Cast<UStructProperty>(Prop);
#endif
		if (!LuaProp)
		{
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
			FArrayProperty* ArrayProp = CastField<FArrayProperty>(Prop);
			if (ArrayProp)
			{
				LuaProp = CastField<FStructProperty>(ArrayProp->Inner);
#else
			UArrayProperty* ArrayProp = Cast<UArrayProperty>(Prop);
			if (ArrayProp)
			{
				LuaProp = Cast<UStructProperty>(ArrayProp->Inner);
#endif
				if (!LuaProp)
				{
					break;
				}
				if (LuaProp->Struct != FLuaValue::StaticStruct())
				{
					break;
				}
				// start filling the array with the rest of arguments
				int ArgsToProcess = NArgs - StackPointer + 1;
				if (ArgsToProcess < 1)
				{
					break;
				}
				FScriptArrayHelper_InContainer ArrayHelper(ArrayProp, LuaProp->ContainerPtrToValuePtr<uint8>(Parameters));
				ArrayHelper.AddValues(ArgsToProcess);
				for (int i = StackPointer; i < StackPointer + ArgsToProcess; i++)
				{
					FLuaValue LuaValue = LuaState->ToLuaValue(i, L);
					*LuaProp->ContainerPtrToValuePtr<FLuaValue>(ArrayHelper.GetRawPtr(i - StackPointer)) = LuaValue;
				}
			}
			break;
		}
		if (LuaProp->Struct != FLuaValue::StaticStruct())
		{
			break;
		}

		FLuaValue LuaValue = LuaState->ToLuaValue(StackPointer++, L);
		*LuaProp->ContainerPtrToValuePtr<FLuaValue>(Parameters) = LuaValue;
	}

	LuaState->InceptionLevel++;
	CallScope->ProcessEvent(LuaCallContext->Function.Get(), Parameters);
	check(LuaState->InceptionLevel > 0);
	LuaState->InceptionLevel--;

	if (LuaState->InceptionLevel == 0)
	{
		FString Error;
		while (LuaState->InceptionErrors.Dequeue(Error))
		{
			ULuaComponent* LuaComponent = Cast<ULuaComponent>(LuaCallContext->Context);
			if (LuaComponent)
			{
				if (LuaComponent->bLogError)
				{
					LuaState->LogError(Error);
				}
				LuaComponent->OnLuaError.Broadcast(Error);
			}
			else
			{
				if (LuaState->bLogError)
				{
					LuaState->LogError(Error);
				}
				LuaState->ReceiveLuaError(Error);
			}
		}
	}

	int ReturnedValues = 0;

	// get return value
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> FArgs(LuaCallContext->Function.Get()); FArgs; ++FArgs)
	{
		FProperty* Prop = *FArgs;
#else
	for (TFieldIterator<UProperty> FArgs(LuaCallContext->Function.Get()); FArgs; ++FArgs)
	{
		UProperty* Prop = *FArgs;
#endif
		if (!Prop->HasAnyPropertyFlags(CPF_ReturnParm | CPF_OutParm))
		{
			continue;
		}

		// avoid input args (at all costs !)
		if (Prop->HasAnyPropertyFlags(CPF_ConstParm | CPF_ReferenceParm))
		{
			continue;
		}
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
		FStructProperty* LuaProp = CastField<FStructProperty>(Prop);
		if (!LuaProp)
		{
			FArrayProperty* ArrayProp = CastField<FArrayProperty>(Prop);
			if (ArrayProp)
			{
				LuaProp = CastField<FStructProperty>(ArrayProp->Inner);
#else
		UStructProperty* LuaProp = Cast<UStructProperty>(Prop);
		if (!LuaProp)
		{
			UArrayProperty* ArrayProp = Cast<UArrayProperty>(Prop);
			if (ArrayProp)
			{
				LuaProp = Cast<UStructProperty>(ArrayProp->Inner);
#endif
				if (!LuaProp)
					break;
				if (LuaProp->Struct != FLuaValue::StaticStruct())
					break;

				FScriptArrayHelper_InContainer ArrayHelper(ArrayProp, LuaProp->ContainerPtrToValuePtr<uint8>(Parameters));
				for (int i = 0; i < ArrayHelper.Num(); i++)
				{
					FLuaValue* LuaValue = LuaProp->ContainerPtrToValuePtr<FLuaValue>(ArrayHelper.GetRawPtr(i));
					ReturnedValues++;
					LuaState->FromLuaValue(*LuaValue, nullptr, L);
				}


			}
			break;
		}

		if (LuaProp->Struct != FLuaValue::StaticStruct())
			break;

		FLuaValue* LuaValue = LuaProp->ContainerPtrToValuePtr<FLuaValue>(Parameters);
		if (LuaValue)
		{
			ReturnedValues++;
			LuaState->FromLuaValue(*LuaValue, nullptr, L);
		}
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
#else
	for (TFieldIterator<UProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
#endif
	{
		It->DestroyValue_InContainer(Parameters);
	}


	if (ReturnedValues > 0)
		return ReturnedValues;

	lua_pushnil(L);
	return 1;
}

int ULuaState::MetaTableFunction__rawcall(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	FLuaUserData* LuaCallContext = (FLuaUserData*)lua_touserdata(L, 1);

	if (!LuaCallContext->Context.IsValid() || !LuaCallContext->Function.IsValid())
	{
		return luaL_error(L, "invalid lua UFunction for UserData %p", LuaCallContext);
	}

	int NArgs = lua_gettop(L);

	UObject* CallScope = LuaCallContext->Context.Get();
	bool bImplicitSelf = false;
	int StackPointer = 2;

	if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(CallScope))
	{
		CallScope = LuaComponent->GetOwner();
		if (NArgs > 0)
		{
			FLuaValue LuaFirstArgument = LuaState->ToLuaValue(StackPointer, L);
			if (LuaFirstArgument.Type == ELuaValueType::UObject && LuaFirstArgument.Object == LuaComponent)
			{
				bImplicitSelf = LuaComponent->bImplicitSelf;
			}
		}
	}
	else if (ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(CallScope))
	{
		if (NArgs > 0)
		{
			FLuaValue LuaFirstArgument = LuaState->ToLuaValue(StackPointer, L);
			if (LuaFirstArgument.Type == ELuaValueType::UObject && LuaFirstArgument.Object == LuaUserDataObject)
			{
				bImplicitSelf = LuaUserDataObject->bImplicitSelf;
			}
		}
	}

	FScopeCycleCounterUObject ObjectScope(CallScope);
	FScopeCycleCounterUObject FunctionScope(LuaCallContext->Function.Get());

	void* Parameters = FMemory_Alloca(LuaCallContext->Function->ParmsSize);
	FMemory::Memzero(Parameters, LuaCallContext->Function->ParmsSize);

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
	{
		FProperty* Prop = *It;
#else
	for (TFieldIterator<UProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
	{
		UProperty* Prop = *It;
#endif
		if (!Prop->HasAnyPropertyFlags(CPF_ZeroConstructor))
		{
			Prop->InitializeValue_InContainer(Parameters);
		}
	}

	if (bImplicitSelf)
	{
		NArgs--;
		StackPointer++;
	}

	// arguments
#if ENGINE_MAJOR_VERSION > 4 ||  ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> FArgs(LuaCallContext->Function.Get()); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
	{
		FProperty* Prop = *FArgs;
#else
	for (TFieldIterator<UProperty> FArgs(LuaCallContext->Function.Get()); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
	{
		UProperty* Prop = *FArgs;
#endif
		bool bPropertySet = false;
		LuaState->ToProperty(Parameters, Prop, LuaState->ToLuaValue(StackPointer++, L), bPropertySet, 0);
	}

	LuaState->InceptionLevel++;
	CallScope->ProcessEvent(LuaCallContext->Function.Get(), Parameters);
	check(LuaState->InceptionLevel > 0);
	LuaState->InceptionLevel--;

	if (LuaState->InceptionLevel == 0)
	{
		FString Error;
		while (LuaState->InceptionErrors.Dequeue(Error))
		{
			ULuaComponent* LuaComponent = Cast<ULuaComponent>(LuaCallContext->Context);
			if (LuaComponent)
			{
				if (LuaComponent->bLogError)
				{
					LuaState->LogError(Error);
				}
				LuaComponent->OnLuaError.Broadcast(Error);
			}
			else
			{
				if (LuaState->bLogError)
				{
					LuaState->LogError(Error);
				}
				LuaState->ReceiveLuaError(Error);
			}
		}
	}

	int ReturnedValues = 0;

	// get return value
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> FArgs(LuaCallContext->Function.Get()); FArgs; ++FArgs)
	{
		FProperty* Prop = *FArgs;
#else
	for (TFieldIterator<UProperty> FArgs(LuaCallContext->Function.Get()); FArgs; ++FArgs)
	{
		UProperty* Prop = *FArgs;
#endif
		if (!Prop->HasAnyPropertyFlags(CPF_ReturnParm | CPF_OutParm))
		{
			continue;
		}

		// avoid input args (at all costs !)
		if (Prop->HasAnyPropertyFlags(CPF_ConstParm | CPF_ReferenceParm))
		{
			continue;
		}

		bool bPropertyGet = false;
		FLuaValue LuaValue = LuaState->FromProperty(Parameters, Prop, bPropertyGet, 0);
		ReturnedValues++;
		LuaState->FromLuaValue(LuaValue, nullptr, L);
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
#else
	for (TFieldIterator<UProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
#endif
	{
		It->DestroyValue_InContainer(Parameters);
	}

	if (ReturnedValues > 0)
	{
		return ReturnedValues;
	}

	lua_pushnil(L);
	return 1;
}

int ULuaState::MetaTableFunction__rawbroadcast(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	FLuaUserData* LuaCallContext = (FLuaUserData*)lua_touserdata(L, 1);

	if (!LuaCallContext->MulticastScriptDelegate || !LuaCallContext->Function.IsValid())
	{
		return luaL_error(L, "invalid lua Multicast Delegate for UserData %p", LuaCallContext);
	}

	int NArgs = lua_gettop(L);
	int StackPointer = 2;

	FScopeCycleCounterUObject FunctionScope(LuaCallContext->Function.Get());

	void* Parameters = FMemory_Alloca(LuaCallContext->Function->ParmsSize);
	FMemory::Memzero(Parameters, LuaCallContext->Function->ParmsSize);

	for (TFieldIterator<FProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
	{
		FProperty* Prop = *It;
		if (!Prop->HasAnyPropertyFlags(CPF_ZeroConstructor))
		{
			Prop->InitializeValue_InContainer(Parameters);
		}
	}

	// arguments
	for (TFieldIterator<FProperty> FArgs(LuaCallContext->Function.Get()); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
	{
		FProperty* Prop = *FArgs;
		bool bPropertySet = false;
		LuaState->ToProperty(Parameters, Prop, LuaState->ToLuaValue(StackPointer++, L), bPropertySet, 0);
	}

	LuaState->InceptionLevel++;
	LuaCallContext->MulticastScriptDelegate->ProcessMulticastDelegate<UObject>(Parameters);
	check(LuaState->InceptionLevel > 0);
	LuaState->InceptionLevel--;

	if (LuaState->InceptionLevel == 0)
	{
		FString Error;
		while (LuaState->InceptionErrors.Dequeue(Error))
		{
			if (LuaState->bLogError)
			{
				LuaState->LogError(Error);
			}
			LuaState->ReceiveLuaError(Error);
		}
	}

	// no return values in multicast delegates
	for (TFieldIterator<FProperty> It(LuaCallContext->Function.Get()); (It && It->HasAnyPropertyFlags(CPF_Parm)); ++It)
	{
		It->DestroyValue_InContainer(Parameters);
	}

	lua_pushnil(L);
	return 1;
}

int ULuaState::TableFunction_print(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);
	TArray<FString> Messages;

	int n = lua_gettop(L);
	lua_getglobal(L, "tostring");
	for (int i = 1; i <= n; i++)
	{
		lua_pushvalue(L, -1);
		lua_pushvalue(L, i);
		lua_call(L, 1, 1);
		const char* s = lua_tostring(L, -1);
		if (!s)
			return luaL_error(L, "'tostring must return a string to 'print'");
		FString Value = ANSI_TO_TCHAR(s);
		lua_pop(L, 1);
		Messages.Add(Value);
	}
	LuaState->Log(FString::Join(Messages, TEXT("\t")));
	return 0;
}

int ULuaState::TableFunction_package_loader_codeasset(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);

	// use the second (sanitized by the loader) argument
	FString Key = ANSI_TO_TCHAR(lua_tostring(L, 2));

	FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry"));
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION > 0
	FAssetData AssetData = AssetRegistryModule.Get().GetAssetByObjectPath(Key);
	if (AssetData.IsValid() && AssetData.AssetClassPath.ToString() == "LuaCode")
#else
	FAssetData AssetData = AssetRegistryModule.Get().GetAssetByObjectPath(*Key);
	if (AssetData.IsValid() && AssetData.AssetClass == "LuaCode")
#endif
	{
		ULuaCode* LuaCode = Cast<ULuaCode>(AssetData.GetAsset());
		if (LuaCode)
		{
			if (!LuaState->RunCodeAsset(LuaCode, 1))
			{
				return luaL_error(L, "%s", lua_tostring(L, -1));
			}
			return 1;
		}
	}

	return luaL_error(L, "unable to load asset '%s'", TCHAR_TO_UTF8(*Key));
}

int ULuaState::TableFunction_package_loader_asset(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);

	// use the second (sanitized by the loader) argument
	const FString Key = ANSI_TO_TCHAR(lua_tostring(L, 2));

	if (LuaState->RunFile(Key, true, 1))
	{
		return 1;
	}
	return luaL_error(L, "%s", lua_tostring(L, -1));
}

int ULuaState::TableFunction_package_loader(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);

	FString Key = ANSI_TO_TCHAR(lua_tostring(L, 1));

	// check for code assets
	if (FPackageName::IsValidObjectPath(Key))
	{
		// fix asset name (if required)
		int32 LastSlashIndex = -1;
		Key.FindLastChar('/', LastSlashIndex);
		const FString LastPart = Key.RightChop(LastSlashIndex + 1);
		if (!LastPart.Contains("."))
		{
			Key = FString::Printf(TEXT("%s.%s"), *Key, *LastPart);
		}

		lua_pushcfunction(L, ULuaState::TableFunction_package_loader_codeasset);
		lua_pushstring(L, TCHAR_TO_UTF8(*Key));
		return 2;
	}
	else
	{
		// TODO: make it smarter by checking for file extension...
		if (!Key.EndsWith(".lua"))
		{
			Key += ".lua";
		}
		// search in root content...
		FString AbsoluteFilename = FPaths::Combine(FPaths::ProjectContentDir(), Key);
		if (FPaths::FileExists(AbsoluteFilename))
		{
			lua_pushcfunction(L, ULuaState::TableFunction_package_loader_asset);
			lua_pushstring(L, TCHAR_TO_UTF8(*Key));
			return 2;
		}
		else
		{
			// or search in additional paths
			for (FString AdditionalPath : LuaState->AppendProjectContentDirSubDir)
			{
				AbsoluteFilename = FPaths::Combine(FPaths::ProjectContentDir(), AdditionalPath, Key);
				if (FPaths::FileExists(AbsoluteFilename))
				{
					lua_pushcfunction(L, ULuaState::TableFunction_package_loader_asset);
					lua_pushstring(L, TCHAR_TO_UTF8(*(AdditionalPath / Key)));
					return 2;
				}
			}
		}
	}

	// use UTF8 as the package name can contains non-ASCII chars
	lua_pushstring(L, TCHAR_TO_UTF8(*FString::Printf(TEXT("\n\tno asset '%s'"), *Key)));
	return 1;
}

int ULuaState::TableFunction_package_preload(lua_State * L)
{
	ULuaState* LuaState = ULuaState::GetFromExtraSpace(L);

	if (LuaState->L != L)
	{
		return luaL_error(L, "you cannot call package.preload from a thread/coroutine (error while loading %s)", lua_tostring(L, 1));
	}

	FString Key = ANSI_TO_TCHAR(lua_tostring(L, 1));

	// check for code assets
	ULuaCode** LuaCodePtr = LuaState->RequireTable.Find(Key);
	if (!LuaCodePtr)
	{
		if (LuaState->bAddProjectContentDirToPackagePath && LuaState->RunFile(Key + ".lua", true, 1))
		{
			return 1;
		}

		// now search in additional paths
		for (FString AdditionalPath : LuaState->AppendProjectContentDirSubDir)
		{
			if (LuaState->RunFile(AdditionalPath / Key + ".lua", true, 1))
			{
				return 1;
			}
			return luaL_error(L, "%s", lua_tostring(L, -1));

		}
		return luaL_error(L, "unable to find package %s", TCHAR_TO_ANSI(*Key));
	}

	ULuaCode* LuaCode = *LuaCodePtr;
	if (!LuaCode)
	{
		return luaL_error(L, "LuaCodeAsset not set for package %s", TCHAR_TO_ANSI(*Key));
	}

	if (!LuaState->RunCodeAsset(LuaCode, 1))
	{
		return luaL_error(L, "%s", lua_tostring(L, -1));
	}

	return 1;
}

void ULuaState::ReceiveLuaError_Implementation(const FString & Message)
{

}

void ULuaState::ReceiveLuaCallHook_Implementation(const FLuaDebug & LuaDebug)
{

}

void ULuaState::ReceiveLuaReturnHook_Implementation(const FLuaDebug & LuaDebug)
{

}

void ULuaState::ReceiveLuaLineHook_Implementation(const FLuaDebug & LuaDebug)
{

}

void ULuaState::ReceiveLuaCountHook(const FLuaDebug & LuaDebug)
{

}

void ULuaState::ReceiveLuaLevelRemovedFromWorld_Implementation(ULevel * Level, UWorld * World)
{

}

void ULuaState::ReceiveLuaLevelAddedToWorld_Implementation(ULevel * Level, UWorld * World)
{

}

void ULuaState::ReceiveLuaStatePreInitialized_Implementation()
{

}

void ULuaState::ReceiveLuaStateInitialized_Implementation()
{

}

void ULuaState::NewTable()
{
	lua_newtable(L);
}

void ULuaState::SetMetaTable(int Index)
{
	lua_setmetatable(L, Index);
}

void ULuaState::GetMetaTable(int Index)
{
	lua_getmetatable(L, Index);
}

void ULuaState::SetField(int Index, const char* FieldName)
{
	lua_setfield(L, Index, FieldName);
}

void ULuaState::GetField(int Index, const char* FieldName)
{
	lua_getfield(L, Index, FieldName);
}

void ULuaState::RawGetI(int Index, int N)
{
	lua_rawgeti(L, Index, N);
}

void ULuaState::RawSetI(int Index, int N)
{
	lua_rawseti(L, Index, N);
}

void ULuaState::PushGlobalTable()
{
	lua_pushglobaltable(L);
}

void ULuaState::PushRegistryTable()
{
	lua_pushvalue(L, LUA_REGISTRYINDEX);
}

int32 ULuaState::GetFieldFromTree(const FString & Tree, bool bGlobal)
{
	TArray<FString> Parts;
	Tree.ParseIntoArray(Parts, TEXT("."));
	if (Parts.Num() == 0)
	{
		LastError = FString::Printf(TEXT("invalid Lua key: \"%s\""), *Tree);
		if (bLogError)
			LogError(LastError);
		ReceiveLuaError(LastError);
		PushNil();
		return 1;
	}

	int32 AdditionalPop = bGlobal ? 1 : 0;

	if (bGlobal)
	{
		PushGlobalTable();
	}
	int32 i;

	for (i = 0; i < Parts.Num(); i++)
	{
		GetField(-1, TCHAR_TO_ANSI(*Parts[i]));

		if (lua_isnil(L, -1))
		{
			if (i == Parts.Num() - 1)
			{
				return i + 1 + AdditionalPop;
			}
			LastError = FString::Printf(TEXT("Lua key \"%s\" is nil"), *Parts[i]);
			if (bLogError)
				LogError(LastError);
			ReceiveLuaError(LastError);
			return i + 1 + AdditionalPop;
		}
	}
	return i + AdditionalPop;
}

void ULuaState::SetFieldFromTree(const FString & Tree, FLuaValue & Value, bool bGlobal, UObject * CallContext)
{
	TArray<FString> Parts;
	Tree.ParseIntoArray(Parts, TEXT("."));

	int32 ItemsToPop = GetFieldFromTree(Tree, bGlobal);
	// invalid key
	if (ItemsToPop != (Parts.Num() + (bGlobal ? 1 : 0)))
	{
		Pop(ItemsToPop);
		return;
	}

	Pop();
	FromLuaValue(Value, CallContext);
	SetField(-2, TCHAR_TO_ANSI(*Parts.Last()));
	Pop(ItemsToPop - 1);
}


void ULuaState::NewUObject(UObject * Object, lua_State * State)
{
	if (!State)
	{
		State = this->L;
	}
	FLuaUserData* UserData = (FLuaUserData*)lua_newuserdata(State, sizeof(FLuaUserData));
	UserData->Type = ELuaValueType::UObject;
	UserData->Context = Object;
	UserData->Function = nullptr;
}

void ULuaState::GetGlobal(const char* Name)
{
	lua_getglobal(L, Name);
}

void ULuaState::SetGlobal(const char* Name)
{
	lua_setglobal(L, Name);
}

void ULuaState::PushValue(int Index)
{
	lua_pushvalue(L, Index);
}

bool ULuaState::PCall(int NArgs, FLuaValue & Value, int NRet)
{
	bool bSuccess = Call(NArgs, Value, NRet);
	if (!bSuccess)
	{
		if (InceptionLevel > 0)
		{
			InceptionErrors.Enqueue(LastError);
		}
		else
		{
			if (bLogError)
				LogError(LastError);
			ReceiveLuaError(LastError);
		}
	}
	return bSuccess;
}

bool ULuaState::Call(int NArgs, FLuaValue & Value, int NRet)
{
	if (lua_pcall(L, NArgs, NRet, 0))
	{
		LastError = FString::Printf(TEXT("Lua error: %s"), ANSI_TO_TCHAR(lua_tostring(L, -1)));
		return false;
	}

	if (NRet > 0)
	{
		Value = ToLuaValue(-1);
	}
	return true;
}

void ULuaState::Pop(int32 Amount)
{
	lua_pop(L, Amount);
}

void ULuaState::PushNil()
{
	lua_pushnil(L);
}

void ULuaState::PushCFunction(lua_CFunction Function)
{
	lua_pushcfunction(L, Function);
}

void* ULuaState::NewUserData(size_t DataSize)
{
	return lua_newuserdata(L, DataSize);
}

void ULuaState::Unref(int Ref)
{
	luaL_unref(L, LUA_REGISTRYINDEX, Ref);
}

void ULuaState::UnrefChecked(int Ref)
{
	// in case of moved value (like when compiling a blueprint), L should be nullptr
	if (!L)
		return;

	Unref(Ref);
}

int ULuaState::NewRef()
{
	return luaL_ref(L, LUA_REGISTRYINDEX);
}

void ULuaState::GetRef(int Ref)
{
	lua_rawgeti(L, LUA_REGISTRYINDEX, Ref);
}

int ULuaState::Next(int Index)
{
	return lua_next(L, Index);
}

bool ULuaState::Yield(int Index, int NArgs)
{
	lua_State* Coroutine = lua_tothread(L, Index);
	if (!Coroutine)
		return false;

	if (lua_status(Coroutine) == LUA_OK && lua_gettop(Coroutine) == 0)
	{
		lua_pushboolean(L, 0);
		lua_pushstring(L, "Lua error: cannot yield a dead coroutine");
		return false;
	}

	lua_xmove(L, Coroutine, NArgs);

	int	Ret = lua_yield(Coroutine, NArgs);

	if (Ret != LUA_OK)
	{
		lua_pushboolean(L, 0);
		lua_xmove(Coroutine, L, 1);
		return false;
	}

	int NRet = lua_gettop(Coroutine);
	lua_pushboolean(L, 1);
	lua_xmove(Coroutine, L, NRet);
	return true;
}

bool ULuaState::Resume(int Index, int NArgs)
{
	lua_State* Coroutine = lua_tothread(L, Index);
	if (!Coroutine)
		return false;

	if (lua_status(Coroutine) == LUA_OK && lua_gettop(Coroutine) == 0)
	{
		lua_pushboolean(L, 0);
		lua_pushstring(L, "Lua error: cannot resume dead coroutine");
		return false;
	}

	lua_xmove(L, Coroutine, NArgs);
	int Ret = lua_resume(Coroutine, L, NArgs);
	if (Ret != LUA_OK && Ret != LUA_YIELD)
	{
		lua_pushboolean(L, 0);
		lua_xmove(Coroutine, L, 1);
		return false;
	}

	int NRet = lua_gettop(Coroutine);
	lua_pushboolean(L, 1);
	lua_xmove(Coroutine, L, NRet);
	return true;
}

int ULuaState::GC(int What, int Data)
{
	return lua_gc(L, What, Data);
}

void ULuaState::Len(int Index)
{
	lua_len(L, Index);
}

int32 ULuaState::ILen(int Index)
{
	return luaL_len(L, Index);
}

int32 ULuaState::ToInteger(int Index)
{
	return lua_tointeger(L, Index);
}

FLuaValue ULuaState::CreateLuaTable()
{
	FLuaValue NewTable;
	NewTable.Type = ELuaValueType::Table;
	NewTable.LuaState = this;
	FromLuaValue(NewTable);
	Pop();
	return NewTable;
}

FLuaValue ULuaState::CreateLuaLazyTable()
{
	FLuaValue NewTable;
	NewTable.Type = ELuaValueType::Table;
	NewTable.LuaState = this;
	return NewTable;
}

FLuaValue ULuaState::CreateLuaThread(FLuaValue Value)
{
	FLuaValue NewThread;
	NewThread.Type = ELuaValueType::Thread;
	NewThread.LuaState = this;
	FromLuaValue(NewThread);
	lua_State* NewLuaThread = lua_tothread(L, -1);
	FromLuaValue(Value, nullptr, NewLuaThread);
	Pop();
	return NewThread;
}

ELuaThreadStatus ULuaState::GetLuaThreadStatus(FLuaValue Value)
{
	if (Value.Type != ELuaValueType::Thread || Value.LuaState != this)
		return ELuaThreadStatus::Invalid;

	FromLuaValue(Value);
	lua_State* LuaThread = lua_tothread(L, -1);
	int ReturnValue = lua_status(LuaThread);
	Pop();

	if (ReturnValue == 0)
		return ELuaThreadStatus::Ok;

	if (ReturnValue == LUA_YIELD)
		return ELuaThreadStatus::Suspended;

	return ELuaThreadStatus::Error;
}

int32 ULuaState::GetLuaThreadStackTop(FLuaValue Value)
{
	if (Value.Type != ELuaValueType::Thread || Value.LuaState != this)
		return MIN_int32;

	FromLuaValue(Value);
	lua_State* LuaThread = lua_tothread(L, -1);
	int ReturnValue = lua_gettop(LuaThread);
	Pop();

	return ReturnValue;
}

TSharedRef<FLuaSmartReference> ULuaState::AddLuaSmartReference(FLuaValue Value)
{
	TSharedRef<FLuaSmartReference> Ref = MakeShared<FLuaSmartReference>();
	Ref->LuaState = this;
	Ref->Value = Value;

	LuaSmartReferences.Add(Ref);

	return Ref;
}

void ULuaState::RemoveLuaSmartReference(TSharedRef<FLuaSmartReference> Ref)
{
	LuaSmartReferences.Remove(Ref);
}

ULuaState::~ULuaState()
{
	FCoreUObjectDelegates::GetPostGarbageCollect().Remove(GCLuaDelegatesHandle);

#if WITH_EDITOR
	if (LuaConsole.LuaState)
	{
		IModularFeatures::Get().UnregisterModularFeature(IConsoleCommandExecutor::ModularFeatureName(), &LuaConsole);
	}
#endif

	FLuaMachineModule::Get().UnregisterLuaState(this);

	if (L)
	{
		lua_close(L);
		L = nullptr;
	}
}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
#define LUAVALUE_PROP_CAST(Type, Type2) F##Type* __##Type##__ = CastField<F##Type>(Property);\
	if (__##Type##__)\
	{\
		return FLuaValue((Type2)__##Type##__->GetPropertyValue_InContainer(Buffer, Index));\
	}

#define LUAVALUE_PROP_CAST_TOSTRING(Type) F##Type* __##Type##__ = CastField<F##Type>(Property);\
	if (__##Type##__)\
	{\
		return FLuaValue(__##Type##__->GetPropertyValue_InContainer(Buffer, Index).ToString());\
	}

#define LUAVALUE_PROP_SET(Type, Value) F##Type* __##Type##__ = CastField<F##Type>(Property);\
	if (__##Type##__)\
	{\
		__##Type##__->SetPropertyValue_InContainer(Buffer, Value, Index);\
		return;\
	}
#else
#define LUAVALUE_PROP_CAST(Type, Type2) U##Type* __##Type##__ = Cast<U##Type>(Property);\
	if (__##Type##__)\
	{\
		return FLuaValue((Type2)__##Type##__->GetPropertyValue_InContainer(Buffer, Index));\
	}

#define LUAVALUE_PROP_CAST_TOSTRING(Type) U##Type* __##Type##__ = Cast<U##Type>(Property);\
	if (__##Type##__)\
	{\
		return FLuaValue(__##Type##__->GetPropertyValue_InContainer(Buffer, Index).ToString());\
	}

#define LUAVALUE_PROP_SET(Type, Value) U##Type* __##Type##__ = Cast<U##Type>(Property);\
	if (__##Type##__)\
	{\
		__##Type##__->SetPropertyValue_InContainer(Buffer, Value, Index);\
		return;\
	}
#endif

#if	ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
FLuaValue ULuaState::FromUProperty(void* Buffer, FProperty * Property, bool& bSuccess, int32 Index)
{
	return FromFProperty(Buffer, Property, bSuccess, Index);
}
void ULuaState::ToUProperty(void* Buffer, FProperty * Property, FLuaValue Value, bool& bSuccess, int32 Index)
{
	ToFProperty(Buffer, Property, Value, bSuccess, Index);
}
#endif

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
FLuaValue ULuaState::FromFProperty(void* Buffer, FProperty * Property, bool& bSuccess, int32 Index)
#else
FLuaValue ULuaState::FromUProperty(void* Buffer, UProperty * Property, bool& bSuccess, int32 Index)
#endif
{
	bSuccess = true;

	LUAVALUE_PROP_CAST(BoolProperty, bool);
	LUAVALUE_PROP_CAST(DoubleProperty, double);
	LUAVALUE_PROP_CAST(FloatProperty, float);
	LUAVALUE_PROP_CAST(Int64Property, int64);
	LUAVALUE_PROP_CAST(UInt64Property, int64);
	LUAVALUE_PROP_CAST(IntProperty, int32);
	LUAVALUE_PROP_CAST(UInt32Property, int32);
	LUAVALUE_PROP_CAST(Int16Property, int32);
	LUAVALUE_PROP_CAST(Int8Property, int32);
	LUAVALUE_PROP_CAST(ByteProperty, int32);
	LUAVALUE_PROP_CAST(UInt16Property, int32);

	LUAVALUE_PROP_CAST(StrProperty, FString);
	LUAVALUE_PROP_CAST_TOSTRING(NameProperty);
	LUAVALUE_PROP_CAST_TOSTRING(TextProperty);

	LUAVALUE_PROP_CAST(ClassProperty, UObject*);
	LUAVALUE_PROP_CAST(ObjectProperty, UObject*);

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FEnumProperty* EnumProperty = CastField<FEnumProperty>(Property);

	if (EnumProperty)
	{
		const uint8* EnumValue = EnumProperty->ContainerPtrToValuePtr<const uint8>(Buffer, Index);
		return FLuaValue((int32)*EnumValue);
	}
#endif

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FObjectPropertyBase* ObjectPropertyBase = CastField<FObjectPropertyBase>(Property);
#else
	UObjectPropertyBase* ObjectPropertyBase = Cast<UObjectPropertyBase>(Property);
#endif
	if (ObjectPropertyBase)
	{
		return FLuaValue(ObjectPropertyBase->GetObjectPropertyValue_InContainer(Buffer, Index));
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FWeakObjectProperty* WeakObjectProperty = CastField<FWeakObjectProperty>(Property);
#else
	UWeakObjectProperty* WeakObjectProperty = Cast<UWeakObjectProperty>(Property);
#endif
	if (WeakObjectProperty)
	{
		const FWeakObjectPtr& WeakPtr = WeakObjectProperty->GetPropertyValue_InContainer(Buffer, Index);
		return FLuaValue(WeakPtr.Get());
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FMulticastDelegateProperty* MulticastProperty = CastField<FMulticastDelegateProperty>(Property))
#else
	if (UMulticastDelegateProperty* MulticastProperty = Cast<UMulticastDelegateProperty>(Property))
#endif
	{
		FLuaValue MulticastValue;
		MulticastValue.Type = ELuaValueType::MulticastDelegate;
		MulticastValue.Object = MulticastProperty->SignatureFunction;
		MulticastValue.MulticastScriptDelegate = reinterpret_cast<FMulticastScriptDelegate*>(MulticastProperty->ContainerPtrToValuePtr<uint8>(Buffer));
		return MulticastValue;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FDelegateProperty* DelegateProperty = CastField<FDelegateProperty>(Property))
#else
	if (UDelegateProperty* DelegateProperty = Cast<UDelegateProperty>(Property))
#endif
	{
		const FScriptDelegate& ScriptDelegate = DelegateProperty->GetPropertyValue_InContainer(Buffer, Index);
		return FLuaValue::FunctionOfObject((UObject*)ScriptDelegate.GetUObject(), ScriptDelegate.GetFunctionName());
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FArrayProperty* ArrayProperty = CastField<FArrayProperty>(Property))
#else
	if (UArrayProperty* ArrayProperty = Cast<UArrayProperty>(Property))
#endif
	{
		FLuaValue NewLuaArray = CreateLuaTable();
		FScriptArrayHelper_InContainer Helper(ArrayProperty, Buffer, Index);
		for (int32 ArrayIndex = 0; ArrayIndex < Helper.Num(); ArrayIndex++)
		{
			uint8* ArrayItemPtr = Helper.GetRawPtr(ArrayIndex);
			bool bArrayItemSuccess = false;
			NewLuaArray.SetFieldByIndex(ArrayIndex + 1, FromProperty(ArrayItemPtr, ArrayProperty->Inner, bArrayItemSuccess, 0));
		}
		return NewLuaArray;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FMapProperty* MapProperty = CastField<FMapProperty>(Property))
#else
	if (UMapProperty* MapProperty = Cast<UMapProperty>(Property))
#endif
	{
		FLuaValue NewLuaTable = CreateLuaTable();
		FScriptMapHelper_InContainer Helper(MapProperty, Buffer, Index);
		for (int32 MapIndex = 0; MapIndex < Helper.Num(); MapIndex++)
		{
			uint8* ArrayKeyPtr = Helper.GetKeyPtr(MapIndex);
			uint8* ArrayValuePtr = Helper.GetValuePtr(MapIndex);
			bool bArrayItemSuccess = false;
			NewLuaTable.SetField(
				FromProperty(ArrayKeyPtr, MapProperty->KeyProp, bArrayItemSuccess, 0).ToString(),
				FromProperty(ArrayValuePtr, MapProperty->ValueProp, bArrayItemSuccess, 0));
		}
		return NewLuaTable;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FSetProperty* SetProperty = CastField<FSetProperty>(Property))
#else
	if (USetProperty* SetProperty = Cast<USetProperty>(Property))
#endif
	{
		FLuaValue NewLuaArray = CreateLuaTable();
		FScriptSetHelper_InContainer Helper(SetProperty, Buffer, Index);
		for (int32 SetIndex = 0; SetIndex < Helper.Num(); SetIndex++)
		{
			uint8* ArrayItemPtr = Helper.GetElementPtr(SetIndex);
			bool bArrayItemSuccess = false;
			NewLuaArray.SetFieldByIndex(SetIndex + 1, FromProperty(ArrayItemPtr, SetProperty->ElementProp, bArrayItemSuccess, 0));
		}
		return NewLuaArray;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FStructProperty* StructProperty = CastField<FStructProperty>(Property))
#else
	if (UStructProperty* StructProperty = Cast<UStructProperty>(Property))
#endif
	{
		// fast path
		if (StructProperty->Struct == FLuaValue::StaticStruct())
		{
			FLuaValue* LuaValuePtr = StructProperty->ContainerPtrToValuePtr<FLuaValue>(Buffer);
			// trick for allowing lazy tables creation
			FromLuaValue(*LuaValuePtr);
			Pop();
			return *LuaValuePtr;
		}

		const uint8* StructContainer = StructProperty->ContainerPtrToValuePtr<const uint8>(Buffer, Index);

		return StructToLuaTable(StructProperty->Struct, StructContainer);
	}

	bSuccess = false;
	return FLuaValue();
}

FLuaValue ULuaState::StructToLuaTable(UScriptStruct * InScriptStruct, const uint8 * StructData)
{
	FLuaValue NewLuaTable = CreateLuaTable();
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(InScriptStruct); It; ++It)
#else
	for (TFieldIterator<UProperty> It(InScriptStruct); It; ++It)
#endif
	{
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
		FProperty* FieldProp = *It;
#else
		UProperty* FieldProp = *It;
#endif
		FString PropName = FieldProp->GetName();
		bool bTableItemSuccess = false;
		NewLuaTable.SetField(PropName, FromProperty((void*)StructData, FieldProp, bTableItemSuccess, 0));
	}
	return NewLuaTable;
}

FLuaValue ULuaState::StructToLuaTable(UScriptStruct * InScriptStruct, const TArray<uint8>&StructData)
{
	return StructToLuaTable(InScriptStruct, StructData.GetData());
}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
void ULuaState::ToFProperty(void* Buffer, FProperty * Property, FLuaValue Value, bool& bSuccess, int32 Index)
#else
void ULuaState::ToUProperty(void* Buffer, UProperty * Property, FLuaValue Value, bool& bSuccess, int32 Index)
#endif
{
	bSuccess = true;

	LUAVALUE_PROP_SET(BoolProperty, Value.ToBool());
	LUAVALUE_PROP_SET(DoubleProperty, Value.ToFloat());
	LUAVALUE_PROP_SET(FloatProperty, Value.ToFloat());
	LUAVALUE_PROP_SET(IntProperty, Value.ToInteger());
	LUAVALUE_PROP_SET(UInt32Property, Value.ToInteger());
	LUAVALUE_PROP_SET(Int64Property, Value.ToInteger());
	LUAVALUE_PROP_SET(UInt64Property, Value.ToInteger());
	LUAVALUE_PROP_SET(Int16Property, Value.ToInteger());
	LUAVALUE_PROP_SET(Int8Property, Value.ToInteger());
	LUAVALUE_PROP_SET(ByteProperty, Value.ToInteger());
	LUAVALUE_PROP_SET(UInt16Property, Value.ToInteger());

	LUAVALUE_PROP_SET(StrProperty, Value.ToString());
	LUAVALUE_PROP_SET(NameProperty, Value.ToName());
	LUAVALUE_PROP_SET(TextProperty, FText::FromString(Value.ToString()));

	LUAVALUE_PROP_SET(ClassProperty, Value.Object);
	LUAVALUE_PROP_SET(ObjectProperty, Value.Object);

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FEnumProperty* EnumProperty = CastField<FEnumProperty>(Property);

	if (EnumProperty)
	{
		uint8* EnumValue = EnumProperty->ContainerPtrToValuePtr<uint8>(Buffer, Index);
		*EnumValue = Value.ToInteger();
		return;
	}
#endif

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FObjectPropertyBase* ObjectPropertyBase = CastField<FObjectPropertyBase>(Property);
#else
	UObjectPropertyBase* ObjectPropertyBase = Cast<UObjectPropertyBase>(Property);
#endif
	if (ObjectPropertyBase)
	{
		ObjectPropertyBase->SetObjectPropertyValue_InContainer(Buffer, Value.Object, Index);
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FWeakObjectProperty* WeakObjectProperty = CastField<FWeakObjectProperty>(Property);
#else
	UWeakObjectProperty* WeakObjectProperty = Cast<UWeakObjectProperty>(Property);
#endif
	if (WeakObjectProperty)
	{
		FWeakObjectPtr WeakPtr(Value.Object);
		WeakObjectProperty->SetPropertyValue_InContainer(Buffer, WeakPtr, Index);
		return;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FMulticastDelegateProperty* MulticastProperty = CastField<FMulticastDelegateProperty>(Property))
#else
	if (UMulticastDelegateProperty* MulticastProperty = Cast<UMulticastDelegateProperty>(Property))
#endif
	{
		if (Value.IsNil())
		{
			UObject* Object = static_cast<UObject*>(Buffer);
			UnregisterLuaDelegatesOfObject(Object);
			MulticastProperty->ClearDelegate(Object);
			return;
		}

		ULuaDelegate* LuaDelegate = NewObject<ULuaDelegate>();
		LuaDelegate->SetupLuaDelegate(MulticastProperty->SignatureFunction, this, Value);
		RegisterLuaDelegate((UObject*)Buffer, LuaDelegate);

		FScriptDelegate Delegate;
		Delegate.BindUFunction(LuaDelegate, FName("LuaDelegateFunction"));

		MulticastProperty->AddDelegate(Delegate, (UObject*)Buffer);
		return;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FDelegateProperty* DelegateProperty = CastField<FDelegateProperty>(Property))
#else
	if (UDelegateProperty* DelegateProperty = Cast<UDelegateProperty>(Property))
#endif
	{
		if (Value.IsNil())
		{
			UObject* Object = static_cast<UObject*>(Buffer);
			UnregisterLuaDelegatesOfObject(Object);
			DelegateProperty->SetPropertyValue_InContainer(Buffer, FScriptDelegate(), Index);
			return;
		}

		ULuaDelegate* LuaDelegate = NewObject<ULuaDelegate>();
		LuaDelegate->SetupLuaDelegate(DelegateProperty->SignatureFunction, this, Value);
		RegisterLuaDelegate((UObject*)Buffer, LuaDelegate);

		FScriptDelegate Delegate;
		Delegate.BindUFunction(LuaDelegate, FName("LuaDelegateFunction"));

		DelegateProperty->SetPropertyValue_InContainer(Buffer, Delegate, Index);
		return;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FStructProperty* StructProperty = CastField<FStructProperty>(Property))
#else
	if (UStructProperty* StructProperty = Cast<UStructProperty>(Property))
#endif
	{
		// fast path
		if (StructProperty->Struct == FLuaValue::StaticStruct())
		{
			FLuaValue* LuaValuePtr = StructProperty->ContainerPtrToValuePtr<FLuaValue>(Buffer);
			*LuaValuePtr = Value;
			return;
		}

		const uint8* StructContainer = StructProperty->ContainerPtrToValuePtr<const uint8>(Buffer, Index);
		LuaTableToStruct(Value, StructProperty->Struct, (uint8*)StructContainer);
		return;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FArrayProperty* ArrayProperty = CastField<FArrayProperty>(Property))
#else
	if (UArrayProperty* ArrayProperty = Cast<UArrayProperty>(Property))
#endif
	{
		FScriptArrayHelper_InContainer Helper(ArrayProperty, Buffer, Index);
		TArray<FLuaValue> ArrayValues = ULuaBlueprintFunctionLibrary::LuaTableGetValues(Value);
		Helper.Resize(ArrayValues.Num());
		for (int32 ArrayIndex = 0; ArrayIndex < Helper.Num(); ArrayIndex++)
		{
			uint8* ArrayItemPtr = Helper.GetRawPtr(ArrayIndex);
			bool bArrayItemSuccess = false;
			ToProperty(ArrayItemPtr, ArrayProperty->Inner, ArrayValues[ArrayIndex], bArrayItemSuccess, 0);
		}
		return;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FMapProperty* MapProperty = CastField<FMapProperty>(Property))
#else
	if (UMapProperty* MapProperty = Cast<UMapProperty>(Property))
#endif
	{
		FScriptMapHelper_InContainer Helper(MapProperty, Buffer, Index);
		Helper.EmptyValues();
		TArray<FLuaValue> TableKeys = ULuaBlueprintFunctionLibrary::LuaTableGetKeys(Value);
		for (FLuaValue TableKey : TableKeys)
		{
			int32 NewIndex = Helper.AddUninitializedValue();
			uint8* KeyBuffer = Helper.GetKeyPtr(NewIndex);
			uint8* ValueBuffer = Helper.GetValuePtr(NewIndex);
			bool bTableItemSuccess = false;
			ToProperty(KeyBuffer, Helper.GetKeyProperty(), TableKey, bTableItemSuccess, 0);
			ToProperty(ValueBuffer, Helper.GetValueProperty(), TableKey, bTableItemSuccess, 0);
		}
		return;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	if (FSetProperty* SetProperty = CastField<FSetProperty>(Property))
#else
	if (USetProperty* SetProperty = Cast<USetProperty>(Property))
#endif
	{
		FScriptSetHelper_InContainer Helper(SetProperty, Buffer, Index);
		TArray<FLuaValue> ArrayValues = ULuaBlueprintFunctionLibrary::LuaTableGetValues(Value);
		Helper.EmptyElements(ArrayValues.Num());
		for (int32 ArrayIndex = 0; ArrayIndex < Helper.Num(); ArrayIndex++)
		{
			uint8* SetItemPtr = Helper.GetElementPtr(ArrayIndex);
			bool bArrayItemSuccess = false;
			ToProperty(SetItemPtr, SetProperty->ElementProp, ArrayValues[ArrayIndex], bArrayItemSuccess, 0);
		}
		return;
	}

	bSuccess = false;
}

void ULuaState::LuaTableToStruct(FLuaValue & LuaValue, UScriptStruct * InScriptStruct, uint8 * StructData)
{
	TArray<FLuaValue> TableKeys = ULuaBlueprintFunctionLibrary::LuaTableGetKeys(LuaValue);
	for (FLuaValue TableKey : TableKeys)
	{
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
		FProperty* StructProp = InScriptStruct->FindPropertyByName(TableKey.ToName());
#else
		UProperty* StructProp = InScriptStruct->FindPropertyByName(TableKey.ToName());
#endif
		if (StructProp)
		{
			bool bStructValueSuccess = false;
			ToProperty((void*)StructData, StructProp, LuaValue.GetField(TableKey.ToString()), bStructValueSuccess, 0);
		}
	}
}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
void ULuaState::ToProperty(void* Buffer, FProperty * Property, FLuaValue Value, bool& bSuccess, int32 Index)
{
	ToFProperty(Buffer, Property, Value, bSuccess, Index);
}

FLuaValue ULuaState::FromProperty(void* Buffer, FProperty * Property, bool& bSuccess, int32 Index)
{
	return FromFProperty(Buffer, Property, bSuccess, Index);
}
#else
void ULuaState::ToProperty(void* Buffer, UProperty * Property, FLuaValue Value, bool& bSuccess, int32 Index)
{
	ToUProperty(Buffer, Property, Value, bSuccess, Index);
}
FLuaValue ULuaState::FromProperty(void* Buffer, UProperty * Property, bool& bSuccess, int32 Index)
{
	return FromUProperty(Buffer, Property, bSuccess, Index);
}
#endif


FLuaValue ULuaState::GetLuaValueFromProperty(UObject * InObject, const FString & PropertyName)
{
	if (!InObject)
	{
		return FLuaValue();
	}

	UClass* Class = InObject->GetClass();
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FProperty* Property = nullptr;
#else
	UProperty* Property = nullptr;
#endif
	Property = Class->FindPropertyByName(*PropertyName);
	if (Property)
	{
		bool bSuccess = false;
		return FromProperty(InObject, Property, bSuccess);
	}

	return FLuaValue();
}

bool ULuaState::SetPropertyFromLuaValue(UObject * InObject, const FString & PropertyName, FLuaValue Value)
{
	if (!InObject)
	{
		return false;
	}

	UClass* Class = InObject->GetClass();
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FProperty* Property = nullptr;
#else
	UProperty* Property = nullptr;
#endif
	Property = Class->FindPropertyByName(*PropertyName);
	if (Property)
	{
		bool bSuccess = false;
		ToProperty(InObject, Property, Value, bSuccess);
		return bSuccess;
	}

	return false;
}

void ULuaState::SetUserDataMetaTable(FLuaValue MetaTable)
{
	UserDataMetaTable = MetaTable;
}

void ULuaState::SetupAndAssignUserDataMetatable(UObject * Context, TMap<FString, FLuaValue>&Metatable, lua_State * State)
{
	if (!State)
	{
		State = this->L;
	}

	lua_newtable(State);
	lua_pushcfunction(State, ULuaState::MetaTableFunctionUserData__index);
	lua_setfield(State, -2, "__index");
	lua_pushcfunction(State, ULuaState::MetaTableFunctionUserData__newindex);
	lua_setfield(State, -2, "__newindex");
	lua_pushcfunction(State, ULuaState::MetaTableFunctionUserData__eq);
	lua_setfield(State, -2, "__eq");
	if (Context->IsA<ULuaUserDataObject>())
	{
		lua_pushcfunction(State, ULuaState::MetaTableFunctionUserData__gc);
		lua_setfield(State, -2, "__gc");
	}

	for (TPair<FString, FLuaValue>& Pair : Metatable)
	{
		// first check for UFunction
		if (Pair.Value.Type == ELuaValueType::UFunction)
		{
			UObject* FunctionOwner = Context;
			if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(Context))
			{
				FunctionOwner = LuaComponent->GetOwner();
			}

			if (FunctionOwner)
			{
				UFunction* Function = FunctionOwner->FindFunction(Pair.Value.FunctionName);
				if (Function)
				{
					FLuaUserData* LuaCallContext = (FLuaUserData*)lua_newuserdata(State, sizeof(FLuaUserData));
					LuaCallContext->Type = ELuaValueType::UFunction;
					LuaCallContext->Context = Context;
					LuaCallContext->Function = Function;

					lua_newtable(State);
					lua_pushcfunction(State, bRawLuaFunctionCall ? ULuaState::MetaTableFunction__rawcall : ULuaState::MetaTableFunction__call);
					lua_setfield(State, -2, "__call");
					lua_setmetatable(State, -2);
				}
				else
				{
					lua_pushnil(State);
				}
			}
		}
		else {
			FromLuaValue(Pair.Value, nullptr, State);
		}
		lua_setfield(State, -2, TCHAR_TO_ANSI(*Pair.Key));
	}

	lua_setmetatable(State, -2);
}

FLuaValue ULuaState::NewLuaUserDataObject(TSubclassOf<ULuaUserDataObject> LuaUserDataObjectClass, bool bTrackObject)
{
	ULuaUserDataObject* LuaUserDataObject = NewObject<ULuaUserDataObject>(this, LuaUserDataObjectClass);
	if (LuaUserDataObject)
	{
		if (bTrackObject)
		{
			TrackedLuaUserDataObjects.Add(LuaUserDataObject);
		}
		LuaUserDataObject->ReceiveLuaUserDataTableInit();
		return FLuaValue(LuaUserDataObject);
	}

	return FLuaValue();
}

void ULuaState::SetLuaUserDataField(FLuaValue UserData, const FString & Key, FLuaValue Value)
{
	if (UserData.Type != ELuaValueType::UObject || !UserData.Object)
		return;

	if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(UserData.Object))
	{
		LuaComponent->LuaSetField(Key, Value);
		return;
	}

	if (ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(UserData.Object))
	{
		LuaUserDataObject->LuaSetField(Key, Value);
		return;
	}
}

FLuaValue ULuaState::GetLuaUserDataField(FLuaValue UserData, const FString & Key)
{
	if (UserData.Type != ELuaValueType::UObject || !UserData.Object)
		return FLuaValue();

	if (ULuaComponent* LuaComponent = Cast<ULuaComponent>(UserData.Object))
	{
		return LuaComponent->LuaGetField(Key);
	}

	if (ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(UserData.Object))
	{
		return LuaUserDataObject->LuaGetField(Key);
	}

	return FLuaValue();
}

const void* ULuaState::ToPointer(int Index)
{
	return lua_topointer(L, Index);
}

void ULuaState::LuaStateInit()
{
}

void ULuaState::GCLuaDelegatesCheck()
{
	TSet<TWeakObjectPtr<UObject>> DeadObjects;
	for (TPair<TWeakObjectPtr<UObject>, FLuaDelegateGroup>& Pair : LuaDelegatesMap)
	{
		if (!Pair.Key.IsValid())
		{
			DeadObjects.Add(Pair.Key);
		}
	}

	for (TWeakObjectPtr<UObject>& WeakObjectPtr : DeadObjects)
	{
		LuaDelegatesMap.Remove(WeakObjectPtr);
	}
}

void ULuaState::RegisterLuaDelegate(UObject * InObject, ULuaDelegate * InLuaDelegate)
{
	FLuaDelegateGroup* LuaDelegateGroup = LuaDelegatesMap.Find(InObject);
	if (LuaDelegateGroup)
	{
		LuaDelegateGroup->LuaDelegates.Add(InLuaDelegate);
	}
	else
	{
		FLuaDelegateGroup NewLuaDelegateGroup;
		NewLuaDelegateGroup.LuaDelegates.Add(InLuaDelegate);
		LuaDelegatesMap.Add(InObject, NewLuaDelegateGroup);
	}
}

void ULuaState::UnregisterLuaDelegatesOfObject(UObject* InObject)
{
	LuaDelegatesMap.Remove(InObject);
}

TArray<FString> ULuaState::GetPropertiesNames(UObject * InObject)
{
	TArray<FString> Names;

	if (!InObject)
	{
		return Names;
	}

	UClass* Class = InObject->GetClass();
	if (!Class)
	{
		return Names;
	}

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	for (TFieldIterator<FProperty> It(Class); It; ++It)
#else
	for (TFieldIterator<UProperty> It(Class); It; ++It)
#endif
	{
		Names.Add((*It)->GetName());
	}

	return Names;
}

TArray<FString> ULuaState::GetFunctionsNames(UObject * InObject)
{
	TArray<FString> Names;

	if (!InObject)
	{
		return Names;
	}

	UClass* Class = InObject->GetClass();
	if (!Class)
	{
		return Names;
	}

	for (TFieldIterator<UFunction> It(Class); It; ++It)
	{
		Names.Add((*It)->GetName());
	}

	return Names;
}

void ULuaState::AddLuaValueToLuaState(const FString & Name, FLuaValue LuaValue)
{
	SetFieldFromTree(Name, LuaValue, true);
}

FLuaValue ULuaState::RunString(const FString & CodeString, FString CodePath)
{
	FLuaValue ReturnValue;
	if (CodePath.IsEmpty())
	{
		CodePath = CodeString;
	}

	if (!RunCode(CodeString, CodePath, 1))
	{
		if (bLogError)
			LogError(LastError);
		ReceiveLuaError(LastError);
	}
	else
	{
		ReturnValue = ToLuaValue(-1);
	}

	Pop();
	return ReturnValue;
}

void ULuaState::Error(const FString& ErrorString)
{
	luaL_error(L, TCHAR_TO_UTF8(*ErrorString));
}
```

`Source/LuaMachine/Private/LuaSyntaxHighlighter.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaSyntaxHighlighter.h"
#include "Runtime/Slate/Public/Framework/Text/IRun.h"
#include "Runtime/Slate/Public/Framework/Text/TextLayout.h"
#include "Runtime/Slate/Public/Framework/Text/SlateTextRun.h"

#define ADD_RULE(rule) TokenizerRules.Add(FSyntaxTokenizer::FRule(TEXT(rule)))

#define ADD_RULE_BASIC(rule) ADD_RULE(rule); BasicTokens.Add(TEXT(rule))

#define ADD_RULE_STDLIB(rule) ADD_RULE(rule); StdLibTokens.Add(TEXT(rule))

FLuaMachineSyntaxHighlighterTextLayoutMarshaller::FLuaMachineSyntaxHighlighterTextLayoutMarshaller(TSharedPtr<FSyntaxTokenizer> InTokenizer, TArray<const TCHAR *> InBasicTokens, TArray<const TCHAR *> InStdLibTokens, FLuaSyntaxTextStyle InLuaSyntaxTextStyle) :
	FSyntaxHighlighterTextLayoutMarshaller(InTokenizer),
	BasicTokens(InBasicTokens),
	StdLibTokens(InStdLibTokens),
	SyntaxTextStyle(InLuaSyntaxTextStyle)
{

}

TSharedRef<FLuaMachineSyntaxHighlighterTextLayoutMarshaller> FLuaMachineSyntaxHighlighterTextLayoutMarshaller::Create(FLuaSyntaxTextStyle LuaSyntaxTextStyle)
{
	TArray<FSyntaxTokenizer::FRule> TokenizerRules;

	TArray<const TCHAR *> BasicTokens;
	TArray<const TCHAR *> StdLibTokens;

	ADD_RULE("--[[");
	ADD_RULE("--]]");
	ADD_RULE("--");
	ADD_RULE("[[");
	ADD_RULE("]]");
	ADD_RULE("\\'");
	ADD_RULE("\\\"");
	ADD_RULE("'");
	ADD_RULE("\"");

	ADD_RULE("nil");
	ADD_RULE("self");
	ADD_RULE("...");
	ADD_RULE("_G");
	ADD_RULE("_VERSION");

	ADD_RULE("and");
	ADD_RULE("end");
	ADD_RULE("in");
	ADD_RULE("repeat");
	ADD_RULE("break");
	ADD_RULE("false");
	ADD_RULE("local");
	ADD_RULE("return");
	ADD_RULE("do");
	ADD_RULE("for");
	ADD_RULE("then");
	ADD_RULE("else");
	ADD_RULE("elseif");
	ADD_RULE("function");
	ADD_RULE("not");
	ADD_RULE("true");
	ADD_RULE("if");
	ADD_RULE("or");
	ADD_RULE("until");
	ADD_RULE("while");

	ADD_RULE_BASIC("assert");
	ADD_RULE_BASIC("collectgarbage");
	ADD_RULE_BASIC("require");
	ADD_RULE_BASIC("dofile");
	ADD_RULE_BASIC("error");
	ADD_RULE_BASIC("getmetatable");
	ADD_RULE_BASIC("ipairs");
	ADD_RULE_BASIC("load");
	ADD_RULE_BASIC("loadfile");
	ADD_RULE_BASIC("next");
	ADD_RULE_BASIC("pairs");
	ADD_RULE_BASIC("pcall");
	ADD_RULE_BASIC("print");
	ADD_RULE_BASIC("rawequal");
	ADD_RULE_BASIC("rawget");
	ADD_RULE_BASIC("rawlen");
	ADD_RULE_BASIC("rawset");
	ADD_RULE_BASIC("select");
	ADD_RULE_BASIC("setmetatable");
	ADD_RULE_BASIC("tonumber");
	ADD_RULE_BASIC("tostring");
	ADD_RULE_BASIC("type");
	ADD_RULE_BASIC("xpcall");

	ADD_RULE_STDLIB("coroutine");
	ADD_RULE_STDLIB("package");
	ADD_RULE_STDLIB("string");
	ADD_RULE_STDLIB("utf8");
	ADD_RULE_STDLIB("table");
	ADD_RULE_STDLIB("math");
	ADD_RULE_STDLIB("io");
	ADD_RULE_STDLIB("file");
	ADD_RULE_STDLIB("os");
	ADD_RULE_STDLIB("debug");

	for (TPair<FString, FLinearColor>& Pair : LuaSyntaxTextStyle.CustomTextColorMapping)
	{
		LuaSyntaxTextStyle.CustomTextStyleMapping.Add(Pair.Key, FTextBlockStyle(LuaSyntaxTextStyle.NormalTextStyle).SetColorAndOpacity(Pair.Value));
	}

	for (TPair<FString, FTextBlockStyle>& Pair : LuaSyntaxTextStyle.CustomTextStyleMapping)
	{
		TokenizerRules.Add(FSyntaxTokenizer::FRule(*Pair.Key));
	}

	TokenizerRules.Sort([](const FSyntaxTokenizer::FRule& A, const FSyntaxTokenizer::FRule& B) {
		return A.MatchText.Len() > B.MatchText.Len();
	});


	return MakeShareable(new FLuaMachineSyntaxHighlighterTextLayoutMarshaller(FSyntaxTokenizer::Create(TokenizerRules), BasicTokens, StdLibTokens, LuaSyntaxTextStyle));
}

void FLuaMachineSyntaxHighlighterTextLayoutMarshaller::ParseTokens(const FString& SourceString, FTextLayout& TargetTextLayout, TArray<FSyntaxTokenizer::FTokenizedLine> TokenizedLines)
{

	enum class EParseState : uint8
	{
		None,
		LookingForSingleLineComment,
		LookingForMultiLineComment,
		LookingForSingleQuoteString,
		LookingForDoubleQuoteString,
		LookingForMultiLineString,
	};

	TArray<FTextLayout::FNewLineData> LinesToAdd;
	LinesToAdd.Reserve(TokenizedLines.Num());


	EParseState ParseState = EParseState::None;

	for (const FSyntaxTokenizer::FTokenizedLine& TokenizedLine : TokenizedLines)
	{
		TSharedRef<FString> ModelString = MakeShareable(new FString());
		TArray<TSharedRef<IRun>> Runs;

		if (ParseState == EParseState::LookingForSingleLineComment)
		{
			ParseState = EParseState::None;
		}



		for (const FSyntaxTokenizer::FToken& Token : TokenizedLine.Tokens)
		{
			const FString TokenString = SourceString.Mid(Token.Range.BeginIndex, Token.Range.Len());
			const FTextRange ModelRange(ModelString->Len(), ModelString->Len() + TokenString.Len());

			ModelString->Append(TokenString);

			FRunInfo RunInfo(TEXT("SyntaxHighlight.LuaMachine.Normal"));

			FTextBlockStyle CurrentBlockStyle = SyntaxTextStyle.NormalTextStyle;

			bool bIsWhitespace = FString(TokenString).TrimEnd().IsEmpty();
			if (!bIsWhitespace)
			{
				bool bHasMatchedSyntax = false;
				if (Token.Type == FSyntaxTokenizer::ETokenType::Syntax)
				{
					if (ParseState == EParseState::None)
					{
						TCHAR NextChar = TEXT(" ")[0];
						TCHAR PrevChar = TEXT(" ")[0];
						if (Token.Range.EndIndex < SourceString.Len())
						{
							NextChar = SourceString[Token.Range.EndIndex];
						}
						if (Token.Range.BeginIndex > 0)
						{
							PrevChar = SourceString[Token.Range.BeginIndex - 1];
						}
						if (TokenString == TEXT("--"))
						{
							RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Comment");
							CurrentBlockStyle = SyntaxTextStyle.CommentTextStyle;
							ParseState = EParseState::LookingForSingleLineComment;
						}
						else if (TokenString == TEXT("--[["))
						{
							RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Comment");
							CurrentBlockStyle = SyntaxTextStyle.CommentTextStyle;
							ParseState = EParseState::LookingForMultiLineComment;
						}
						else if (TokenString == TEXT("[["))
						{
							RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
							CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
							ParseState = EParseState::LookingForMultiLineString;
							bHasMatchedSyntax = true;
						}
						else if (TokenString == TEXT("'"))
						{
							RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
							CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
							ParseState = EParseState::LookingForSingleQuoteString;
							bHasMatchedSyntax = true;
						}
						else if (TokenString == TEXT("\""))
						{
							RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
							CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
							ParseState = EParseState::LookingForDoubleQuoteString;
							bHasMatchedSyntax = true;
						}
						else if (!TChar<WIDECHAR>::IsAlpha(NextChar) && !TChar<WIDECHAR>::IsDigit(NextChar) && !TChar<WIDECHAR>::IsAlpha(PrevChar) && !TChar<WIDECHAR>::IsDigit(PrevChar) && NextChar != TCHAR('_') && PrevChar != TCHAR('_'))
						{
							if (TokenString == TEXT("nil") || TokenString == TEXT("self") || TokenString == TEXT("_G") || TokenString == TEXT("_VERSION") || TokenString == TEXT("..."))
							{
								RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Nil");
								CurrentBlockStyle = SyntaxTextStyle.NilTextStyle;
							}
							else if (BasicTokens.Contains(TokenString))
							{
								RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Basic");
								CurrentBlockStyle = SyntaxTextStyle.BasicTextStyle;
							}
							else if (StdLibTokens.Contains(TokenString))
							{
								RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.StdLib");
								CurrentBlockStyle = SyntaxTextStyle.StdLibTextStyle;
							}
							else {
								if (SyntaxTextStyle.CustomTextStyleMapping.Contains(TokenString))
								{
									RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Custom");
									CurrentBlockStyle = SyntaxTextStyle.CustomTextStyleMapping[TokenString];
								}
								else
								{
									RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Keyword");
									CurrentBlockStyle = SyntaxTextStyle.KeywordTextStyle;
								}
							}
							ParseState = EParseState::None;
						}
					}
					else if (ParseState == EParseState::LookingForMultiLineComment && TokenString == TEXT("--]]"))
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Comment");
						CurrentBlockStyle = SyntaxTextStyle.CommentTextStyle;
						ParseState = EParseState::None;
					}
					else if (ParseState == EParseState::LookingForMultiLineString && TokenString == TEXT("]]"))
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
						CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
						ParseState = EParseState::None;
					}
					else if (ParseState == EParseState::LookingForSingleQuoteString && TokenString == TEXT("'"))
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
						CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
						ParseState = EParseState::None;
					}
					else if (ParseState == EParseState::LookingForDoubleQuoteString && TokenString == TEXT("\""))
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
						CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
						ParseState = EParseState::None;
					}

				}

				if (Token.Type == FSyntaxTokenizer::ETokenType::Literal || !bHasMatchedSyntax)
				{
					if (ParseState == EParseState::LookingForSingleLineComment)
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Comment");
						CurrentBlockStyle = SyntaxTextStyle.CommentTextStyle;
					}
					else if (ParseState == EParseState::LookingForMultiLineComment)
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.Comment");
						CurrentBlockStyle = SyntaxTextStyle.CommentTextStyle;
					}
					else if (ParseState == EParseState::LookingForMultiLineString || ParseState == EParseState::LookingForSingleQuoteString || ParseState == EParseState::LookingForDoubleQuoteString)
					{
						RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.String");
						CurrentBlockStyle = SyntaxTextStyle.StringTextStyle;
					}
				}
				TSharedRef<ISlateRun> Run = FSlateTextRun::Create(RunInfo, ModelString, CurrentBlockStyle, ModelRange);
				Runs.Add(Run);
			}
			else
			{
				RunInfo.Name = TEXT("SyntaxHighlight.LuaMachine.WhiteSpace");
				TSharedRef<ISlateRun> Run = FSlateTextRun::Create(RunInfo, ModelString, SyntaxTextStyle.NormalTextStyle, ModelRange);
				Runs.Add(Run);
			}
		}

		LinesToAdd.Emplace(MoveTemp(ModelString), MoveTemp(Runs));
	}

	TargetTextLayout.AddLines(LinesToAdd);
}
```

`Source/LuaMachine/Private/LuaTableAsset.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaTableAsset.h"

FLuaValue ULuaTableAsset::ToLuaTable(ULuaState* LuaState)
{
	FLuaValue NewTable = LuaState->CreateLuaTable();
	for (TPair<FString, FLuaValue>& Pair : Table)
	{
		NewTable.SetField(Pair.Key, Pair.Value);
	}

	return NewTable;
}
```

`Source/LuaMachine/Private/LuaUserDataObject.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaUserDataObject.h"

TSubclassOf<ULuaState> ULuaUserDataObject::GetLuaState() const
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (LuaState)
	{
		return LuaState->GetClass();
	}
	return nullptr;
}

ULuaState* ULuaUserDataObject::GetLuaStateInstance() const
{
	return Cast<ULuaState>(GetOuter());
}

UWorld* ULuaUserDataObject::GetWorld() const
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (LuaState)
	{
		return LuaState->GetWorld();
	}
	return nullptr;
}

TSharedPtr<FLuaSmartReference> ULuaUserDataObject::AddLuaSmartReference(FLuaValue Value)
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (LuaState)
	{
		return LuaState->AddLuaSmartReference(Value);
	}
	return nullptr;
}

void ULuaUserDataObject::RemoveLuaSmartReference(TSharedPtr<FLuaSmartReference> Ref)
{
	if (!Ref.IsValid())
		return;

	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (LuaState)
	{
		return LuaState->RemoveLuaSmartReference(Ref.ToSharedRef());
	}
}

FLuaValue ULuaUserDataObject::LuaGetField(const FString& Name)
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (!LuaState)
		return FLuaValue();

	// push component pointer as userdata
	LuaState->NewUObject(this, nullptr);
	LuaState->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int32 ItemsToPop = LuaState->GetFieldFromTree(Name, false);
	FLuaValue ReturnValue = LuaState->ToLuaValue(-1);

	// we need to remove the return value and the object
	LuaState->Pop(ItemsToPop + 1);

	return ReturnValue;
}

void ULuaUserDataObject::LuaSetField(const FString& Name, FLuaValue Value)
{
	ULuaState* LuaState = Cast<ULuaState>(GetOuter());
	if (!LuaState)
		return;

	// push component pointer as userdata
	LuaState->NewUObject(this, nullptr);
	LuaState->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	LuaState->SetFieldFromTree(Name, Value, false, this);

	// remove UObject
	LuaState->Pop();
}

TArray<FString> ULuaUserDataObject::GetObjectUFunctions(bool bOnlyPublic)
{
	TArray<FString> FunctionNames;

	UClass* RelevantClass = GetClass();
	UClass* ParentClass = RelevantClass->GetSuperClass();
	while (ParentClass != ULuaUserDataObject::StaticClass())
	{
		RelevantClass = ParentClass;
		ParentClass = ParentClass->GetSuperClass();
	}

	for (TFieldIterator<UFunction> It(GetClass()); It; ++It)
	{
		UFunction* Function = *It;
		bool bSuccess = true;
		if (bOnlyPublic && !Function->HasAnyFunctionFlags(EFunctionFlags::FUNC_Public))
		{
			bSuccess = false;
		}
		
		if (bSuccess)
		{
			if (Function->GetOuterUClass()->IsChildOf(RelevantClass))
			{
				UFunction* SuperFunction = Function->GetSuperFunction();
				if (SuperFunction && !SuperFunction->GetOuterUClass()->IsChildOf(RelevantClass))
				{
					continue;
				}
				FunctionNames.Add(Function->GetName());
			}
		}
	}

	return FunctionNames;
}

void ULuaUserDataObject::ReceiveLuaUserDataTableInit_Implementation()
{

}

void ULuaUserDataObject::ReceiveLuaGC_Implementation()
{

}

FLuaValue ULuaUserDataObject::ReceiveLuaMetaIndex_Implementation(FLuaValue Key)
{
	return FLuaValue();
}

FLuaValue ULuaUserDataObject::UFunctionToLuaValue(const FString& FunctionName)
{
	FName FunctionFName = FName(*FunctionName);
	UFunction* Function = FindFunction(FunctionFName);
	if (!Function)
	{
		return FLuaValue();
	}

	return FLuaValue::Function(FunctionFName);
}

FLuaValue ULuaUserDataObject::LuaCallFunction(const FString& Name, TArray<FLuaValue> Args, bool bGlobal)
{
	FLuaValue ReturnValue;

	ULuaState* L = GetLuaStateInstance();
	if (!L)
		return ReturnValue;

	// push userdata pointer as userdata
	L->NewUObject(this, nullptr);
	L->SetupAndAssignUserDataMetatable(this, Metatable, nullptr);

	int32 ItemsToPop = L->GetFieldFromTree(Name, bGlobal);

	// first argument (self/actor)
	L->PushValue(-(ItemsToPop + 1));
	int NArgs = 1;
	for (FLuaValue& Arg : Args)
	{
		L->FromLuaValue(Arg);
		NArgs++;
	}

	L->PCall(NArgs, ReturnValue);

	// the return value and the function has been removed, so we do not need to change ItemsToPop
	L->Pop(ItemsToPop + 1);

	return ReturnValue;
}

```

`Source/LuaMachine/Private/LuaValue.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaValue.h"
#include "LuaState.h"
#include "Misc/Base64.h"

FString FLuaValue::ToString() const
{
	switch (Type)
	{
	case ELuaValueType::Bool:
		return Bool ? FString(TEXT("true")) : FString(TEXT("false"));
	case ELuaValueType::Integer:
		return FString::Printf(TEXT("%lld"), Integer);
	case ELuaValueType::Number:
		return FString::SanitizeFloat(Number);
	case ELuaValueType::String:
		return String;
	case ELuaValueType::Table:
		return FString::Printf(TEXT("table: %d"), LuaRef);
	case ELuaValueType::Function:
		return FString::Printf(TEXT("function: %d"), LuaRef);
	case ELuaValueType::UObject:
		return Object->GetFullName();
	case ELuaValueType::UFunction:
		return Object ? (FunctionName.ToString() + " @ " + Object->GetClass()->GetPathName()) : FunctionName.ToString();
	case ELuaValueType::Thread:
		return FString::Printf(TEXT("thread: %d"), LuaRef);
	}
	return FString(TEXT("nil"));
}

FName FLuaValue::ToName() const
{
	return FName(*ToString());
}

int64 FLuaValue::ToInteger() const
{
	switch (Type)
	{
	case ELuaValueType::Bool:
		return Bool ? 1 : 0;
	case ELuaValueType::Integer:
		return Integer;
	case ELuaValueType::Number:
		return Number;
	case ELuaValueType::String:
		return FCString::Atoi(*String);
	}
	return 0;
}

double FLuaValue::ToFloat() const
{
	switch (Type)
	{
	case ELuaValueType::Bool:
		return Bool ? 1.0 : 0.0;
	case ELuaValueType::Integer:
		return Integer;
	case ELuaValueType::Number:
		return Number;
	case ELuaValueType::String:
		return FCString::Atod(*String);
	}
	return 0.0;
}

bool FLuaValue::ToBool() const
{
	switch (Type)
	{
	case ELuaValueType::Nil:
		return false;
	case ELuaValueType::Bool:
		return Bool;
	case ELuaValueType::Integer:
		return Integer != 0;
	case ELuaValueType::Number:
		return Number != 0;
	}
	return true;
}

void FLuaValue::Unref()
{
	if (!LuaState.IsValid())
	{
		LuaRef = LUA_NOREF;
		return;
	}

	if (Type == ELuaValueType::Table || Type == ELuaValueType::Function || Type == ELuaValueType::Thread)
	{
		if (LuaRef != LUA_NOREF)
		{
			// special case for when the engine is shutting down
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 24
			if (IsEngineExitRequested())
#else
			if (GIsRequestingExit)
#endif
			{
				if (!LuaState->IsValidLowLevel())
				{
					LuaRef = LUA_NOREF;
					return;
				}
			}
			// use UnrefCheck here to support moving of LuaState
			LuaState->UnrefChecked(LuaRef);
		}
		LuaRef = LUA_NOREF;
	}
}

FLuaValue::~FLuaValue()
{
	Unref();
}

FLuaValue::FLuaValue(const FLuaValue& SourceValue)
{
	Type = SourceValue.Type;
	Object = SourceValue.Object;
	LuaRef = SourceValue.LuaRef;
	LuaState = SourceValue.LuaState;
	Bool = SourceValue.Bool;
	Integer = SourceValue.Integer;
	Number = SourceValue.Number;
	String = SourceValue.String;
	FunctionName = SourceValue.FunctionName;
	MulticastScriptDelegate = SourceValue.MulticastScriptDelegate;

	// make a new reference to the table, to avoid it being destroyed
	if (LuaRef != LUA_NOREF)
	{
		LuaState->GetRef(LuaRef);
		LuaRef = LuaState->NewRef();
	}
}

FLuaValue& FLuaValue::operator = (const FLuaValue& SourceValue)
{
	Type = SourceValue.Type;
	Object = SourceValue.Object;
	LuaRef = SourceValue.LuaRef;
	LuaState = SourceValue.LuaState;
	Bool = SourceValue.Bool;
	Integer = SourceValue.Integer;
	Number = SourceValue.Number;
	String = SourceValue.String;
	FunctionName = SourceValue.FunctionName;
	MulticastScriptDelegate = SourceValue.MulticastScriptDelegate;

	// make a new reference to the table, to avoid it being destroyed
	if (LuaRef != LUA_NOREF)
	{
		LuaState->GetRef(LuaRef);
		LuaRef = LuaState->NewRef();
	}

	return *this;
}

FLuaValue FLuaValue::SetField(const FString& Key, FLuaValue Value)
{
	if (Type != ELuaValueType::Table)
		return *this;

	if (!LuaState.IsValid())
		return *this;

	LuaState->FromLuaValue(*this);
	LuaState->FromLuaValue(Value);
	LuaState->SetField(-2, TCHAR_TO_ANSI(*Key));
	LuaState->Pop();
	return *this;
}

FLuaValue FLuaValue::SetField(const FString& Key, lua_CFunction CFunction)
{
	if (Type != ELuaValueType::Table)
		return *this;

	if (!LuaState.IsValid())
		return *this;

	LuaState->FromLuaValue(*this);
	LuaState->PushCFunction(CFunction);
	LuaState->SetField(-2, TCHAR_TO_ANSI(*Key));
	LuaState->Pop();
	return *this;
}

FLuaValue FLuaValue::SetMetaTable(FLuaValue MetaTable)
{
	if (Type != ELuaValueType::Table || MetaTable.Type != ELuaValueType::Table)
		return *this;

	if (!LuaState.IsValid())
		return *this;

	LuaState->FromLuaValue(*this);
	LuaState->FromLuaValue(MetaTable);
	LuaState->SetMetaTable(-2);
	LuaState->Pop();

	return *this;
}


FLuaValue FLuaValue::GetField(const FString& Key)
{
	if (Type != ELuaValueType::Table)
		return FLuaValue();

	if (!LuaState.IsValid())
		return FLuaValue();

	LuaState->FromLuaValue(*this);
	LuaState->GetField(-1, TCHAR_TO_ANSI(*Key));
	FLuaValue ReturnValue = LuaState->ToLuaValue(-1);
	LuaState->Pop(2);
	return ReturnValue;
}

FLuaValue FLuaValue::GetFieldByIndex(const int32 Index)
{
	if (Type != ELuaValueType::Table)
	{
		return FLuaValue();
	}

	if (!LuaState.IsValid())
	{
		return FLuaValue();
	}

	LuaState->FromLuaValue(*this);
	LuaState->RawGetI(-1, Index);
	FLuaValue ReturnValue = LuaState->ToLuaValue(-1);
	LuaState->Pop(2);
	return ReturnValue;
}

FLuaValue FLuaValue::SetFieldByIndex(const int32 Index, FLuaValue Value)
{
	if (Type != ELuaValueType::Table)
	{
		return *this;
	}

	if (!LuaState.IsValid())
	{
		return *this;
	}

	LuaState->FromLuaValue(*this);
	LuaState->FromLuaValue(Value);
	LuaState->RawSetI(-2, Index);
	LuaState->Pop();
	return *this;
}

bool FLuaValue::IsReferencedInLuaRegistry() const
{
	return LuaRef != LUA_NOREF;
}

bool FLuaValue::IsNil() const
{
	return Type == ELuaValueType::Nil;
}

FLuaValue FLuaValue::FromJsonValue(ULuaState* L, FJsonValue& JsonValue)
{
	if (JsonValue.Type == EJson::String)
	{
		return FLuaValue(JsonValue.AsString());
	}
	else if (JsonValue.Type == EJson::Number)
	{
		return FLuaValue(JsonValue.AsNumber());
	}
	else if (JsonValue.Type == EJson::Boolean)
	{
		return FLuaValue(JsonValue.AsBool());
	}
	else if (JsonValue.Type == EJson::Array)
	{
		FLuaValue LuaArray = L->CreateLuaTable();
		int32 Index = 1;
		auto JsonValues = JsonValue.AsArray();
		for (auto JsonItem : JsonValues)
		{
			FLuaValue LuaItem;
			if (JsonItem.IsValid())
			{
				LuaItem = FromJsonValue(L, *JsonItem);
			}
			LuaArray.SetFieldByIndex(Index++, LuaItem);
		}
		return LuaArray;
	}
	else if (JsonValue.Type == EJson::Object)
	{
		FLuaValue LuaTable = L->CreateLuaTable();
		auto JsonObject = JsonValue.AsObject();
		for (TPair<FString, TSharedPtr<FJsonValue>> Pair : JsonObject->Values)
		{
			FLuaValue LuaItem;
			if (Pair.Value.IsValid())
			{
				LuaItem = FromJsonValue(L, *Pair.Value);
			}
			LuaTable.SetField(Pair.Key, LuaItem);
		}
		return LuaTable;
	}

	// default to nil
	return FLuaValue();
}

TSharedPtr<FJsonValue> FLuaValue::ToJsonValue()
{
	switch (Type)
	{
	case ELuaValueType::Integer:
		return MakeShared<FJsonValueNumber>(Integer);
	case ELuaValueType::Number:
		return MakeShared<FJsonValueNumber>(Number);
	case ELuaValueType::String:
		return MakeShared<FJsonValueString>(String);
	case ELuaValueType::UFunction:
		return MakeShared<FJsonValueString>(FunctionName.ToString());
	case ELuaValueType::UObject:
		return MakeShared<FJsonValueString>(Object ? Object->GetFullName() : "");
	case ELuaValueType::Table:
	{

		ULuaState* L = LuaState.Get();
		if (!L)
			return MakeShared<FJsonValueNull>();

		bool bIsArray = true;

		TArray<TPair<FLuaValue, FLuaValue>> Items;
		L->FromLuaValue(*this); // push the table
		L->PushNil(); // first key
		while (L->Next(-2))
		{
			auto Key = L->ToLuaValue(-2);
			auto Value = L->ToLuaValue(-1);
			Items.Add(TPair<FLuaValue, FLuaValue>(Key, Value));
			if (Key.Type != ELuaValueType::Integer)
			{
				bIsArray = false;
			}
			L->Pop(); // pop the value
		}
		L->Pop(); // pop the table

		// check if it is a valid lua "array"
		if (bIsArray)
		{
			TArray<TSharedPtr<FJsonValue>> JsonValues;
			int32 Index = 1;
			for (;;)
			{
				FLuaValue Item = GetFieldByIndex(Index++);
				if (Item.Type == ELuaValueType::Nil)
					break;
				JsonValues.Add(Item.ToJsonValue());
			}
			return MakeShared<FJsonValueArray>(JsonValues);
		}

		auto JsonObject = MakeShared<FJsonObject>();
		for (auto Pair : Items)
		{
			JsonObject->SetField(Pair.Key.ToString(), Pair.Value.ToJsonValue());
		}
		auto JsonValueObject = MakeShared<FJsonValueObject>(JsonObject);
		return JsonValueObject;
	}
	return MakeShared<FJsonValueNull>();
	}

	return MakeShared<FJsonValueNull>();
}

TArray<uint8> FLuaValue::ToBytes() const
{
	TArray<uint8> Bytes;
	if (Type != ELuaValueType::String)
		return Bytes;

	const int32 StringLength = String.Len();
	Bytes.AddUninitialized(StringLength);
	for (int32 i = 0; i < StringLength; i++)
	{
		uint16 CharValue = (uint16)String[i];
		if (CharValue == 0xffff)
		{
			Bytes[i] = 0;
		}
		else
		{
			Bytes[i] = (uint8)String[i];
		}
	}

	return Bytes;
}

FLuaValue FLuaValue::FromBase64(const FString& Base64)
{
	TArray<uint8> Bytes;
	FBase64::Decode(Base64, Bytes);
	return FLuaValue(Bytes);
}

FString FLuaValue::ToBase64() const
{
	return FBase64::Encode(ToBytes());
}
```

`Source/LuaMachine/Public/LuaBlueprintFunctionLibrary.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "LuaState.h"
#include "LuaValue.h"
#include "LuaTableAsset.h"
#include "UObject/TextProperty.h"
#include "Runtime/Engine/Classes/Engine/World.h"
#include "Runtime/Online/HTTP/Public/HttpModule.h"
#include "Sound/SoundWave.h"
#include "LuaBlueprintFunctionLibrary.generated.h"

/**
 * 
 */

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FLuaHttpSuccess, FLuaValue, ReturnValue, bool, bWasSuccessful, int32, StatusCode);
DECLARE_DYNAMIC_DELEGATE_TwoParams(FLuaHttpResponseReceived, FLuaValue, Context, FLuaValue, Response);
DECLARE_DYNAMIC_DELEGATE_OneParam(FLuaHttpError, FLuaValue, Context);

UENUM(BlueprintType)
enum class ELuaReflectionType : uint8
{
	Unknown,
	Property,
	Function,
};


UCLASS()
class LUAMACHINE_API ULuaBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaCreateNil();

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaCreateString(const FString& String);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaCreateNumber(const float Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaCreateInteger(const int32 Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FLuaValue LuaCreateInteger64(const int64 Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaCreateBool(const bool bInBool);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue LuaCreateTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaCreateThread(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value /* Function */);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaCreateObject(UObject* InObject);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue LuaCreateObjectInState(UObject* WorldContextObject, TSubclassOf<ULuaState> State, UObject* InObject);

	UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject"), Category="Lua")
	static FLuaValue LuaGetGlobal(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static void LuaSetGlobal(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name, FLuaValue Value);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static void LuaSetUserDataMetaTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue MetaTable);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue AssignLuaValueToLuaState(UObject* WorldContextObject, FLuaValue Value, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaTableGetField(FLuaValue Table, const FString& Key);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue GetLuaComponentAsLuaValue(AActor* Actor);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue GetLuaComponentByStateAsLuaValue(AActor* Actor, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue GetLuaComponentByNameAsLuaValue(AActor* Actor, const FString& Name);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue GetLuaComponentByStateAndNameAsLuaValue(AActor* Actor, TSubclassOf<ULuaState> State, const FString& Name);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaComponentGetField(FLuaValue LuaComponent, const FString& Key);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static FLuaValue LuaTableGetByIndex(FLuaValue Table, const int32 Index);

	/* Assigns a value to a table index, returned value is the table itself */
	UFUNCTION(BlueprintCallable, Category="Lua")
	static FLuaValue LuaTableSetByIndex(FLuaValue Table, const int32 Index, FLuaValue Value);

	/* Returns the array of keys in the table */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static TArray<FLuaValue> LuaTableGetKeys(FLuaValue Table);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static TArray<FLuaValue> LuaTableGetValues(FLuaValue Table);

	/* Assigns a value to a table key, returned value is the table itself */
	UFUNCTION(BlueprintCallable, Category="Lua")
	static FLuaValue LuaTableSetField(FLuaValue Table, const FString& Key, FLuaValue Value);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"), Category="Lua")
	static FLuaValue LuaGlobalCall(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"), Category="Lua")
	static TArray<FLuaValue> LuaGlobalCallMulti(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Name, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"), Category="Lua")
	static FLuaValue LuaGlobalCallValue(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"), Category="Lua")
	static TArray<FLuaValue> LuaGlobalCallValueMulti(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintPure, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Args"), Category = "Lua")
	static ULuaState* LuaGetState(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	/* Calls a lua value (must be callable) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category="Lua")
	static FLuaValue LuaValueCall(FLuaValue Value, TArray<FLuaValue> Args);

	/* Calls a lua value (must be callable and not nil) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category="Lua")
	static FLuaValue LuaValueCallIfNotNil(FLuaValue Value, TArray<FLuaValue> Args);

	/* Calls a lua value taken from a table by key (must be callable) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category="Lua")
	static FLuaValue LuaTableKeyCall(FLuaValue InTable, const FString& Key, TArray<FLuaValue> Args);

	/* Calls a lua value taken from a table by key (must be callable), passing the table itself as the first argument (useful for table:function syntax) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category = "Lua")
	static FLuaValue LuaTableKeyCallWithSelf(FLuaValue InTable, const FString& Key, TArray<FLuaValue> Args);

	/* Calls a lua value taken from a table by index (must be callable) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category="Lua")
	static FLuaValue LuaTableIndexCall(FLuaValue InTable, const int32 Index, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static TArray<FLuaValue> LuaTableUnpack(FLuaValue InTable);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaTablePack(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TArray<FLuaValue> Values);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaTableMergePack(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TArray<FLuaValue> Values1, TArray<FLuaValue> Values2);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static TArray<FLuaValue> LuaTableMergeUnpack(FLuaValue InTable1, FLuaValue InTable2);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static void LuaTableFillObject(FLuaValue InTable, UObject* InObject);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaTableFromMap(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TMap<FString, FLuaValue> Map);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static TArray<FLuaValue> LuaTableRange(FLuaValue InTable, const int32 First, const int32 Last);
	
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static TArray<FLuaValue> LuaValueArrayMerge(TArray<FLuaValue> Array1, TArray<FLuaValue> Array2);
	
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static TArray<FLuaValue> LuaValueArrayAppend(TArray<FLuaValue> Array, FLuaValue Value);

	/* Calls a lua value with multiple return values (must be callable) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category="Lua")
	static TArray<FLuaValue> LuaValueCallMulti(FLuaValue Value, TArray<FLuaValue> Args);

	/* Resume a lua coroutine/thread with multiple return values (must be callable) */
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category = "Lua")
	static TArray<FLuaValue> LuaValueResumeMulti(FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static ELuaThreadStatus LuaThreadGetStatus(FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static int32 LuaThreadGetStackTop(FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static int32 LuaValueLength(FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static bool LuaValueIsReferencedInLuaRegistry(FLuaValue Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static UClass* LuaValueToBlueprintGeneratedClass(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static UObject* LuaValueLoadObject(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static UClass* LuaValueLoadClass(const FLuaValue& Value, const bool bDetectBlueprintGeneratedClass);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static bool LuaValueFromJson(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Json, FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FString LuaValueToJson(FLuaValue Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static FLuaValue LuaValueFromBase64(const FString& Base64);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FString LuaValueToBase64(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static FLuaValue LuaValueFromUTF16(const FString& String);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FString LuaValueToUTF16(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static FLuaValue LuaValueFromUTF8(const FString& String);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FString LuaValueToUTF8(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static FLuaValue LuaValueFromUTF32(const FString& String);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FString LuaValueToUTF32(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static int64 LuaValueToPointer(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FString LuaValueToHexPointer(UObject* WorldContextObject, TSubclassOf<ULuaState> State, FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static int32 LuaGetTop(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static void LuaStateDestroy(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static void LuaStateReload(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue LuaRunFile(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Filename, const bool bIgnoreNonExistent);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaRunNonContentFile(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Filename, const bool bIgnoreNonExistent);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue LuaRunCodeAsset(UObject* WorldContextObject, TSubclassOf<ULuaState> State, ULuaCode* CodeAsset);
	
	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue LuaRunByteCode(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const TArray<uint8>& ByteCode, const FString& CodePath);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static FLuaValue LuaRunString(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& CodeString, FString CodePath="");

	/* Make an HTTP GET request to the specified URL to download the Lua script to run */
	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Headers"), Category = "Lua")
	static void LuaRunURL(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& URL, TMap<FString, FString> Headers, const FString& SecurityHeader, const FString& SignaturePublicExponent, const FString& SignatureModulus, FLuaHttpSuccess Completed);

	/* Make an HTTP GET request to the specified URL to download the Lua script to run */
	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject", AutoCreateRefTerm = "Headers,Error,ResponseReceived"), Category = "Lua")
	static void LuaHttpRequest(UObject* WorldContextObject, TSubclassOf<ULuaState> State, const FString& Method, const FString& URL, TMap<FString, FString> Headers, FLuaValue Body, FLuaValue Context, const FLuaHttpResponseReceived& ResponseReceived, const FLuaHttpError& Error);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static UTexture2D* LuaValueToTransientTexture(const int32 Width, const int32 Height, const FLuaValue& Value, const EPixelFormat PixelFormat = EPixelFormat::PF_B8G8R8A8, bool bDetectFormat = false);


	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Args"), Category = "Lua")
	static void LuaValueYield(FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static bool LuaLoadPakFile(const FString& Filename, FString Mountpoint, TArray<FLuaValue>& Assets, FString ContentPath, FString AssetRegistryPath);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaNewLuaUserDataObject(UObject* WorldContextObject, TSubclassOf<ULuaState> State, TSubclassOf<ULuaUserDataObject> UserDataObjectClass, bool bTrackObject=true);

	UFUNCTION(BlueprintCallable, BlueprintPure, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static int32 LuaGetUsedMemory(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static void LuaGCCollect(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static void LuaGCStop(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category="Lua")
	static void LuaGCRestart(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaTableAssetToLuaTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State, ULuaTableAsset* TableAsset);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static bool LuaTableImplements(FLuaValue Table, ULuaTableAsset* TableAsset);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static bool LuaTableImplementsAll(FLuaValue Table, TArray<ULuaTableAsset*> TableAssets);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static bool LuaTableImplementsAny(FLuaValue Table, TArray<ULuaTableAsset*> TableAssets);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsNil(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsOwned(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static TSubclassOf<ULuaState> LuaValueGetOwner(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsNotNil(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsTable(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsBoolean(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsNumber(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsInteger(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsString(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsFunction(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	static bool LuaValueIsThread(const FLuaValue& Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FVector LuaTableToVector(FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FRotator LuaTableToRotator(FLuaValue Value);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static FLuaValue LuaTableSetMetaTable(FLuaValue InTable, FLuaValue InMetaTable);

	UFUNCTION(BlueprintPure, meta=(DisplayName = "To String (LuaValue)", BlueprintAutocast), Category="Lua")
	static FString Conv_LuaValueToString(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Text (LuaValue)", BlueprintAutocast), Category="Lua")
	static FText Conv_LuaValueToText(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Name (LuaValue)", BlueprintAutocast), Category="Lua")
	static FName Conv_LuaValueToName(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Object (LuaValue)", BlueprintAutocast), Category="Lua")
	static UObject* Conv_LuaValueToObject(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Class (LuaValue)", BlueprintAutocast), Category="Lua")
	static UClass* Conv_LuaValueToClass(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (Object)", BlueprintAutocast), Category="Lua")
	static FLuaValue Conv_ObjectToLuaValue(UObject* Object);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (Float)", BlueprintAutocast), Category="Lua")
	static FLuaValue Conv_FloatToLuaValue(const float Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Int (LuaValue)", BlueprintAutocast), Category="Lua")
	static int32 Conv_LuaValueToInt(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Int64 (LuaValue)", BlueprintAutocast), Category = "Lua")
	static int64 Conv_LuaValueToInt64(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Float (LuaValue)", BlueprintAutocast), Category="Lua")
	static float Conv_LuaValueToFloat(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Vector (LuaValue)", BlueprintAutocast), Category = "Lua")
	static FVector Conv_LuaValueToFVector(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Rotator (LuaValue)", BlueprintAutocast), Category = "Lua")
	static FRotator Conv_LuaValueToFRotator(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To Bool (LuaValue)", BlueprintAutocast), Category="Lua")
	static bool Conv_LuaValueToBool(const FLuaValue& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (Int)", BlueprintAutocast), Category="Lua")
	static FLuaValue Conv_IntToLuaValue(const int32 Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (Int64)", BlueprintAutocast), Category = "Lua")
	static FLuaValue Conv_Int64ToLuaValue(const int64 Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (String)", BlueprintAutocast), Category="Lua")
	static FLuaValue Conv_StringToLuaValue(const FString& Value);

	UFUNCTION(BlueprintPure, meta = (BDisplayName = "To LuaValue (Text)", lueprintAutocast), Category="Lua")
	static FLuaValue Conv_TextToLuaValue(const FText& Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (Name)", BlueprintAutocast), Category="Lua")
	static FLuaValue Conv_NameToLuaValue(const FName Value);

	UFUNCTION(BlueprintPure, meta = (DisplayName = "To LuaValue (Bool)", BlueprintAutocast), Category="Lua")
	static FLuaValue Conv_BoolToLuaValue(const bool Value);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static FLuaValue LuaCreateLazyTable(UObject* WorldContextObject, TSubclassOf<ULuaState> State);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static FLuaValue LuaCreateUFunction(UObject* InObject, const FString& FunctionName);

	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "LuaValueTypes"), Category = "Lua")
	static void SwitchOnLuaValueType(const FLuaValue& LuaValue, ELuaValueType& LuaValueTypes);

	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "LuaReflectionTypes"), Category = "Lua")
	static void GetLuaReflectionType(UObject* InObject, const FString& Name, ELuaReflectionType& LuaReflectionTypes);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static void RegisterLuaConsoleCommand(const FString& CommandName, const FLuaValue& LuaConsoleCommand);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	static void UnregisterLuaConsoleCommand(const FString& CommandName);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"), Category = "Lua")
	static ULuaState* CreateDynamicLuaState(UObject* WorldContextObject, TSubclassOf<ULuaState> LuaStateClass);

private:
	static void HttpRequestDone(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful, TSubclassOf<ULuaState> LuaState, TWeakObjectPtr<UWorld> World, const FString SecurityHeader, const FString SignaturePublicExponent, const FString SignatureModulus, FLuaHttpSuccess Completed);
	static void HttpGenericRequestDone(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful, TWeakPtr<FLuaSmartReference> Context, FLuaHttpResponseReceived ResponseReceived, FLuaHttpError Error);

};

```

`Source/LuaMachine/Public/LuaBlueprintPackage.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "LuaState.h"
#include "LuaBlueprintPackage.generated.h"

/**
 * 
 */
UCLASS(Abstract, Blueprintable, HideDropdown)
class LUAMACHINE_API ULuaBlueprintPackage : public UObject
{
	GENERATED_BODY()


public:
	UPROPERTY(EditAnywhere, Category = "Lua")
	TMap<FString, FLuaValue> Table;

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	TSubclassOf<ULuaState> GetLuaState() const;

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	ULuaState* GetLuaStateInstance() const;
	
	virtual UWorld* GetWorld() const override;

	UPROPERTY()
	FLuaValue SelfTable;

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	FLuaValue GetSelfLuaTable() const { return SelfTable; }

	virtual void Init();

	UFUNCTION(BlueprintImplementableEvent, meta = (DisplayName = "Init"), Category = "Lua")
	void ReceiveInit();
};

```

`Source/LuaMachine/Public/LuaCode.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris
// Reimport system by yama2akira (Akira Yamamoto)

#pragma once

#include "CoreMinimal.h"
#include "Runtime/Launch/Resources/Version.h"
#include "Engine/DataAsset.h"
#if ENGINE_MAJOR_VERSION > 4
#include "UObject/ObjectSaveContext.h"
#endif
#include "LuaCode.generated.h"

struct LUAMACHINE_API FLuaCodeObjectVersion
{
    enum Type
    {
        // Before any version changes were made
        BeforeCustomVersionWasAdded = 0,

        // Fixed duplication of properties
        FixDuplicationOfProperties,

		VersionPlusOne,
		LatestVersion = VersionPlusOne - 1

    };

    // The GUID for this custom version number
    const static FGuid GUID;

private:
	FLuaCodeObjectVersion() {}
};


/**
 * 
 */
UCLASS(BlueprintType)
class LUAMACHINE_API ULuaCode : public UDataAsset
{
	GENERATED_BODY()
	
public:

	ULuaCode();

	UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Lua")
	FText Code;
	
	UPROPERTY(EditAnywhere, Category="Lua")
	bool bCookAsBytecode;

	UPROPERTY()
	TArray<uint8> ByteCode;

	UPROPERTY()
	bool bCooked;

	virtual void Serialize(FArchive& Ar) override;

#if ENGINE_MAJOR_VERSION > 4
	virtual void PreSave(FObjectPreSaveContext ObjectSaveContext) override;
#else
	virtual void PreSave(const ITargetPlatform* TargetPlatform) override;
#endif

#if WITH_EDITORONLY_DATA
	virtual void PostInitProperties() override;
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
	virtual void GetAssetRegistryTags(FAssetRegistryTagsContext Context) const override;
#else
	virtual void GetAssetRegistryTags(TArray<FAssetRegistryTag>& OutTags) const override;
#endif


	UPROPERTY(VisibleAnywhere, Instanced, Category = Reimport)
	class UAssetImportData* AssetImportData;
#endif
};

```

`Source/LuaMachine/Public/LuaCommandExecutor.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "HAL/IConsoleManager.h"
#include "Framework/Commands/InputChord.h"
#include "Runtime/Launch/Resources/Version.h"

class ULuaState;

/**
 * 
 */
class LUAMACHINE_API FLuaCommandExecutor : public IConsoleCommandExecutor
{
public:
	FLuaCommandExecutor();
	~FLuaCommandExecutor();

	FName GetName() const override;
	FText GetDisplayName() const override;
	FText GetDescription() const override;
	FText GetHintText() const override;
	void GetAutoCompleteSuggestions(const TCHAR* Input, TArray<FString>& Out) override;
	void GetExecHistory(TArray<FString>& Out) override;
	bool Exec(const TCHAR* Input) override;
	bool AllowHotKeyClose() const override;
	bool AllowMultiLine() const override;
	FInputChord GetHotKey() const override;

#if ENGINE_MAJOR_VERSION > 4 && ENGINE_MINOR_VERSION > 0
	FInputChord GetIterateExecutorHotKey() const
	{
		return {};
	}
#endif

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 5
	void GetSuggestedCompletions(const TCHAR* Input, TArray<FConsoleSuggestion>& Out) override {}
#endif

	ULuaState* LuaState;
};

```

`Source/LuaMachine/Public/LuaComponent.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "LuaState.h"
#include "LuaValue.h"
#include "LuaComponent.generated.h"

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FLuaComponentError, FString, Message);


UCLASS(Blueprintable, ClassGroup=(Scripting), meta=(BlueprintSpawnableComponent) )
class LUAMACHINE_API ULuaComponent : public UActorComponent
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	ULuaComponent();

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	TSubclassOf<ULuaState> LuaState;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	TMap<FString, FLuaValue> Table;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	TMap<FString, FLuaValue> Metatable;

	UPROPERTY(EditAnywhere, Category="Lua")
	bool bLazy;

	UPROPERTY(EditAnywhere, Category="Lua")
	bool bLogError;

	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bImplicitSelf;

	UPROPERTY(EditAnywhere, Category = "Lua")
	TArray<FString> GlobalNames;

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	FLuaValue LuaCallFunction(const FString& Name, TArray<FLuaValue> Args, bool bGlobal);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	FLuaValue LuaCallValue(FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	FLuaValue LuaCallValueIfNotNil(FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	FLuaValue LuaCallTableKey(FLuaValue InTable, FString Key, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	FLuaValue LuaCallTableIndex(FLuaValue InTable, int32 Index, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	TArray<FLuaValue> LuaCallFunctionMulti(FString Name, TArray<FLuaValue> Args, bool bGlobal);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	TArray<FLuaValue> LuaCallValueMulti(FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	TArray<FLuaValue> LuaCallValueMultiIfNotNil(FLuaValue Value, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	TArray<FLuaValue> LuaCallTableKeyMulti(FLuaValue InTable, FString Key, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, Category="Lua", meta = (AutoCreateRefTerm = "Args"))
	TArray<FLuaValue> LuaCallTableIndexMulti(FLuaValue InTable, int32 Index, TArray<FLuaValue> Args);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category="Lua")
	FLuaValue LuaGetField(const FString& Name);

	UFUNCTION(BlueprintCallable, Category="Lua")
	void LuaSetField(const FString& Name, FLuaValue Value);

	UPROPERTY(BlueprintAssignable, Category = "Lua", meta = (DisplayName = "On Lua Error"))
	FLuaComponentError OnLuaError;

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Component Metatable __index"))
	FLuaValue ReceiveLuaMetaIndex(FLuaValue Key);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Component Metatable __newindex"))
	bool ReceiveLuaMetaNewIndex(FLuaValue Key, FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	ULuaState* LuaComponentGetState();

	virtual void OnRegister() override;

};

```

`Source/LuaMachine/Public/LuaDelegate.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "LuaValue.h"
#include "UObject/NoExportTypes.h"
#include "LuaDelegate.generated.h"

/**
 * 
 */
UCLASS()
class LUAMACHINE_API ULuaDelegate : public UObject
{
	GENERATED_BODY()
	
public:

	void SetupLuaDelegate(UFunction* InSignature, ULuaState* InLuaState, FLuaValue InLuaValue);

	virtual void ProcessEvent(UFunction* Function, void* Parms) override;

	UFUNCTION()
	void LuaDelegateFunction();

private:
	TWeakObjectPtr<ULuaState> LuaState;
	FLuaValue LuaValue;
	UFunction* LuaDelegateSignature;
};

```

`Source/LuaMachine/Public/LuaGlobalNameComponent.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "LuaState.h"
#include "LuaGlobalNameComponent.generated.h"


UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class LUAMACHINE_API ULuaGlobalNameComponent : public UActorComponent
{
	GENERATED_BODY()

public:	
	// Sets default values for this component's properties
	ULuaGlobalNameComponent();

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	virtual void OnRegister() override;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Lua")
	TSubclassOf<ULuaState> LuaState;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Lua")
	FString LuaGlobalName;
		
};

```

`Source/LuaMachine/Public/LuaMachine.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"
#include "UObject/GCObject.h"
#include "LuaState.h"
#include "HAL/IConsoleManager.h"

DECLARE_MULTICAST_DELEGATE(FOnRegisteredLuaStatesChanged);
DECLARE_MULTICAST_DELEGATE_OneParam(FOnNewLuaState, ULuaState*);

class LUAMACHINE_API FLuaMachineModule : public IModuleInterface, public FGCObject, public FSelfRegisteringExec
{
public:

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

	static FLuaMachineModule& Get();

	void CleanupLuaStates(bool bIsSimulating);
	void UnregisterLuaState(ULuaState* LuaState);

	ULuaState* GetLuaState(TSubclassOf<ULuaState> LuaStateClass, UWorld* InWorld, bool bCheckOnly=false);

	TArray<ULuaState*> GetRegisteredLuaStates();

	FOnNewLuaState OnNewLuaState;
	FOnRegisteredLuaStatesChanged OnRegisteredLuaStatesChanged;

	void LuaLevelAddedToWorld(ULevel* Level, UWorld* World);
	void LuaLevelRemovedFromWorld(ULevel* Level, UWorld* World);

	void AddReferencedObjects(FReferenceCollector& Collector) override;

	void RegisterLuaConsoleCommand(const FString& CommandName, const FLuaValue& LuaConsoleCommand);
	void UnregisterLuaConsoleCommand(const FString& CommandName);

	void RunLuaConsoleCommand(const TArray<FString>& Args, FLuaValue LuaConsoleCommand);

#if ENGINE_MAJOR_VERSION > 4
	virtual FString GetReferencerName() const override
	{
		return TEXT("FLuaMachineModule");
	}
#endif

	virtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar);

private:
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
	TMap<TSubclassOf<ULuaState>, TObjectPtr<ULuaState>> LuaStates;
#else
	TMap<TSubclassOf<ULuaState>, ULuaState*> LuaStates;
#endif
	TSet<FString> LuaConsoleCommands;
};

```

`Source/LuaMachine/Public/LuaMultiLineEditableTextBox.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Components/TextWidgetTypes.h"
#include "Components/MultiLineEditableTextBox.h"
#include "Runtime/Launch/Resources/Version.h"
#include "LuaMultiLineEditableTextBox.generated.h"

USTRUCT(BlueprintType)
struct LUAMACHINE_API FLuaCustomHighlighter
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Lua")
	FLinearColor Color;

	UPROPERTY(EditAnywhere, Category = "Lua")
	TArray<FString> Tokens;

	FLuaCustomHighlighter();
};

/**
 * 
 */
UCLASS(meta=(DisplayName="Lua Code Box"))
class LUAMACHINE_API ULuaMultiLineEditableTextBox : public UTextLayoutWidget
{
	GENERATED_BODY()

public:
	ULuaMultiLineEditableTextBox();

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "Style"))
	FEditableTextBoxStyle WidgetStyle;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "Code Style"))
	FTextBlockStyle CodeStyle;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "Comment Color"))
	FLinearColor CommentColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "String Color"))
	FLinearColor StringColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "Keyword Color"))
	FLinearColor KeywordColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "Nil Color"))
	FLinearColor NilColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "Basic Color"))
	FLinearColor BasicColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style", meta = (DisplayName = "StdLib Color"))
	FLinearColor StdLibColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Lua Code", meta = (DisplayName = "Tab Size"))
	int32 TabSize;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Appearance")
	bool bIsReadonly;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Lua Code")
	bool bHandleTab;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Lua Code")
	bool bHandleArrows;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Style")
	TArray<FLuaCustomHighlighter> CustomTokensMapping;

	UFUNCTION(BlueprintPure, Category = "Widget", meta = (DisplayName = "GetText (Lua Code Box)"))
	FText GetText() const;

	UFUNCTION(BlueprintCallable, Category = "Widget", meta = (DisplayName = "SetText (Lua Code Box)"))
	void SetText(FText InText);

	UFUNCTION(BlueprintPure, Category = "Widget", meta = (DisplayName = "GetCursorLine (Lua Code Box)"))
	int32 GetCursorLine() const;

	UFUNCTION(BlueprintPure, Category = "Widget", meta = (DisplayName = "GetCursorColumn (Lua Code Box)"))
	int32 GetCursorColumn() const;

	UFUNCTION(BlueprintCallable, Category = "Widget", meta = (DisplayName = "MoveCursorUp (Lua Code Box)"))
	void MoveCursorUp();

	UFUNCTION(BlueprintCallable, Category = "Widget", meta = (DisplayName = "MoveCursorDown (Lua Code Box)"))
	void MoveCursorDown();

	UFUNCTION(BlueprintCallable, Category = "Widget", meta = (DisplayName = "MoveCursorRight (Lua Code Box)"))
	void MoveCursorRight();

	UFUNCTION(BlueprintCallable, Category = "Widget", meta = (DisplayName = "MoveCursorLeft (Lua Code Box)"))
	void MoveCursorLeft();

	UFUNCTION(BlueprintCallable, Category = "Widget", meta = (DisplayName = "CursorGoTo (Lua Code Box)"))
	void CursorGoTo(int32 Line, int32 Column);

	UFUNCTION(BlueprintPure, Category = "Widget", meta = (DisplayName = "GetSelectedText (Lua Code Box)"))
	FText GetSelectedText() const;

	virtual FReply OnKeyChar(const FGeometry& InGeometry, const FCharacterEvent& InCharacterEvent);

	virtual FReply OnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent);

	virtual void OnCursorMoved(const FTextLocation& Location);

	virtual void SynchronizeProperties() override;

#if WITH_EDITOR
	virtual const FText GetPaletteCategory() override;
#endif

	virtual void ReleaseSlateResources(bool bReleaseChildren) override;

protected:
	virtual TSharedRef<SWidget> RebuildWidget() override;
	
	TSharedPtr<SMultiLineEditableTextBox> EditableTextBoxPtr;

	FTextLocation CursorLocation;

#if ENGINE_MAJOR_VERSION >=5 && ENGINE_MINOR_VERSION >= 1
	FEditableTextBoxStyle EditableTextBoxStyle;
#endif
};

```

`Source/LuaMachine/Public/LuaState.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Engine/Blueprint.h"
#include "ThirdParty/lua/lua.hpp"
#include "LuaValue.h"
#include "LuaCode.h"
#include "Runtime/Core/Public/Containers/Queue.h"
#include "Runtime/Launch/Resources/Version.h"
#include "LuaDelegate.h"
#include "LuaCommandExecutor.h"
#include "LuaState.generated.h"

LUAMACHINE_API DECLARE_LOG_CATEGORY_EXTERN(LogLuaMachine, Log, All);

/**
 *
 */

class ULuaBlueprintPackage;

struct FLuaUserData
{
	ELuaValueType Type;
	// we use weak pointers as both fields can eventually be garbage collected
	// while the lua VM hold a reference to the userdata
	TWeakObjectPtr<UObject> Context;
	TWeakObjectPtr<UFunction> Function;

	// meaningful only for multicast delegates broadcasting
	FMulticastScriptDelegate* MulticastScriptDelegate;

	FLuaUserData(UObject* InObject)
	{
		Type = ELuaValueType::UObject;
		Context = InObject;
		MulticastScriptDelegate = nullptr;
	}

	FLuaUserData(UObject* InObject, UFunction* InFunction)
	{
		Type = ELuaValueType::UFunction;
		Context = InObject;
		Function = InFunction;
		MulticastScriptDelegate = nullptr;
	}
};

UENUM(BlueprintType)
enum class ELuaThreadStatus : uint8
{
	Invalid,
	Ok,
	Suspended,
	Error,
};

USTRUCT()
struct FLuaLibsLoader
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load base"))
	bool bLoadBase;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load coroutine"))
	bool bLoadCoroutine;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load table"))
	bool bLoadTable;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load io"))
	bool bLoadIO;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load os"))
	bool bLoadOS;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load string"))
	bool bLoadString;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load math"))
	bool bLoadMath;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load utf8"))
	bool bLoadUTF8;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load debug"))
	bool bLoadDebug;

	FLuaLibsLoader()
		: bLoadBase(true)
		, bLoadCoroutine(true)
		, bLoadTable(true)
		, bLoadIO(true)
		, bLoadOS(true)
		, bLoadString(true)
		, bLoadMath(true)
		, bLoadUTF8(true)
		, bLoadDebug(false)
	{}

};

USTRUCT(BlueprintType)
struct FLuaDebug
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	int32 CurrentLine;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	FString Source;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	FString Name;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	FString NameWhat;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	FString What;

	FLuaDebug()
		: CurrentLine(0)
	{

	}
};

USTRUCT(BlueprintType)
struct FLuaDelegateGroup
{
	GENERATED_BODY()

	UPROPERTY()
	TArray<ULuaDelegate*> LuaDelegates;
};


struct FLuaSmartReference : public TSharedFromThis<FLuaSmartReference>
{
	ULuaState* LuaState;
	FLuaValue Value;
};


class ULuaUserDataObject;

UCLASS(Abstract, Blueprintable, HideDropdown)
class LUAMACHINE_API ULuaState : public UObject
{
	GENERATED_BODY()

public:
	ULuaState();
	~ULuaState();

	virtual UWorld* GetWorld() const override { return CurrentWorld; }

	UPROPERTY(EditAnywhere, Category = "Lua")
	ULuaCode* LuaCodeAsset;

	UPROPERTY(EditAnywhere, Category = "Lua")
	FString LuaFilename;

	UPROPERTY(EditAnywhere, Category = "Lua")
	TMap<FString, FLuaValue> Table;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Lua Blueprint Packages Table"))
	TMap<FString, TSubclassOf<ULuaBlueprintPackage>> LuaBlueprintPackagesTable;

	UPROPERTY(EditAnywhere, Category = "Lua")
	TMap<FString, ULuaCode*> RequireTable;

	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bLuaOpenLibs;

	UPROPERTY(EditAnywhere, Category = "Lua", meta = (DisplayName = "Load Specific Lua Libraries (only if \"Lua Open Libs\" is false)"))
	FLuaLibsLoader LuaLibsLoader;

	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bAddProjectContentDirToPackagePath;

	UPROPERTY(EditAnywhere, Category = "Lua")
	TArray<FString> AppendProjectContentDirSubDir;

	UPROPERTY(EditAnywhere, Category = "Lua")
	FString OverridePackagePath;

	UPROPERTY(EditAnywhere, Category = "Lua")
	FString OverridePackageCPath;

	UPROPERTY(EditAnywhere, meta = (DisplayName = "UserData MetaTable from CodeAsset"), Category = "Lua")
	ULuaCode* UserDataMetaTableFromCodeAsset;

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Error"))
	void ReceiveLuaError(const FString& Message);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Line Hook"))
	void ReceiveLuaLineHook(const FLuaDebug& LuaDebug);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Call Hook"))
	void ReceiveLuaCallHook(const FLuaDebug& LuaDebug);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Return Hook"))
	void ReceiveLuaReturnHook(const FLuaDebug& LuaDebug);

	// Not BlueprintNativeEvent, as throwing a luaL_error from an RTTI call results in leaving the VM in an unexpected
	// state and will result in exceptions
	UFUNCTION(Category = "Lua", meta = (DisplayName = "Lua Count Hook"))
	virtual void ReceiveLuaCountHook(const FLuaDebug& LuaDebug);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	FLuaValue NewLuaUserDataObject(TSubclassOf<ULuaUserDataObject> LuaUserDataObjectClass, bool bTrackObject=true);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	FLuaDebug LuaGetInfo(const int32 Level);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	TMap<FString, FLuaValue> LuaGetLocals(const int32 Level);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	TSubclassOf<ULuaState> GetSelfLuaState() const { return GetClass(); }

	template<class T>
	FLuaValue NewLuaUserDataObject(bool bTrackObject = true)
	{
		return NewLuaUserDataObject(T::StaticClass(), bTrackObject);
	}

	UFUNCTION(BlueprintCallable, Category = "Lua")
	void SetLuaUserDataField(FLuaValue UserData, const FString& Key, FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	FLuaValue GetLuaUserDataField(FLuaValue UserData, const FString& Key);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	FLuaValue GetLuaValueFromProperty(UObject* InObject, const FString& PropertyName);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	bool SetPropertyFromLuaValue(UObject* InObject, const FString& PropertyName, FLuaValue Value);

	UFUNCTION(BlueprintCallable, BlueprintPure,  Category = "Lua")
	FLuaValue GetLuaBlueprintPackageTable(const FString& PackageName);

	void FromLuaValue(FLuaValue& LuaValue, UObject* CallContext = nullptr, lua_State* State = nullptr);
	FLuaValue ToLuaValue(int Index, lua_State* State = nullptr);

	ELuaThreadStatus GetLuaThreadStatus(FLuaValue Value);
	int32 GetLuaThreadStackTop(FLuaValue Value);

	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bLogError;

	/* Enable it if you want this Lua state to not be destroyed during PIE. Useful for editor scripting */
	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bPersistent;

	/* Enable debug of each Lua line. The LuaLineHook event will be triggered */
	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bEnableLineHook;

	/* Enable debug of each Lua call. The LuaCallHook event will be triggered */
	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bEnableCallHook;

	/* Enable debug of each Lua return. The LuaReturnHook event will be triggered */
	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bEnableReturnHook;

	/* Enable debug for reaching a number of Lua instruction. The LuaCountHook event will be triggered */
	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bEnableCountHook;

	/* Number of instructions to wait for when the Count Hook is enabled */
	UPROPERTY(EditAnywhere, Category = "Lua", Meta = (EditCondition = "bEnableCountHook"))
	int32 HookInstructionCount = 25000;

	UPROPERTY()
	TMap<FString, ULuaBlueprintPackage*> LuaBlueprintPackages;

	TArray<TSharedRef<FLuaSmartReference>> LuaSmartReferences;

	UPROPERTY()
	TArray<ULuaUserDataObject*> TrackedLuaUserDataObjects;

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Level Added To World"))
	void ReceiveLuaLevelAddedToWorld(ULevel* Level, UWorld* World);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua Level Removed From World"))
	void ReceiveLuaLevelRemovedFromWorld(ULevel* Level, UWorld* World);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua State Pre Initialization"))
	void ReceiveLuaStatePreInitialized();
	
	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua State Initialized"))
	void ReceiveLuaStateInitialized();

	int32 GetTop();

	FString LastError;

	int32 InceptionLevel;

	TQueue<FString> InceptionErrors;

	void NewTable();

	void SetMetaTable(int Index);
	void GetMetaTable(int Index);

	void SetField(int Index, const char* FieldName);

	void GetField(int Index, const char* FieldName);

	void NewUObject(UObject* Object, lua_State* State);

	void* NewUserData(size_t DataSize);

	void GetGlobal(const char* Name);

	int32 GetFieldFromTree(const FString& Tree, bool bGlobal = true);

	void SetFieldFromTree(const FString& Tree, FLuaValue& Value, bool bGlobal, UObject* CallContext = nullptr);

	void SetGlobal(const char* Name);

	void PushValue(int Index);

	void PushGlobalTable();

	bool PCall(int NArgs, FLuaValue& Value, int NRet = 1);
	bool Call(int NArgs, FLuaValue& Value, int NRet = 1);

	void Pop(int32 Amount = 1);

	void PushNil();

	void Unref(int Ref);
	void UnrefChecked(int Ref);
	int NewRef();
	void GetRef(int Ref);
	int Next(int Index);

	bool Resume(int Index, int NArgs);
	bool Yield(int Index, int NArgs);

	int GC(int What, int Data = 0);

	int32 ToInteger(int Index);

	void Len(int Index);

	int32 ILen(int Index);

	void RawGetI(int Index, int N);
	void RawSetI(int Index, int N);

	void PushCFunction(lua_CFunction Function);

	ULuaState* GetLuaState(UWorld* InWorld);

	bool RunCode(const TArray<uint8>& Code, const FString& CodePath, int NRet = 0);
	bool RunCode(const FString& Code, const FString& CodePath, int NRet = 0);

	bool RunCodeAsset(ULuaCode* CodeAsset, int NRet = 0);

	FLuaValue CreateLuaTable();
	FLuaValue CreateLuaThread(FLuaValue Value);

	FLuaValue CreateLuaLazyTable();

	bool RunFile(const FString& Filename, bool bIgnoreNonExistent, int NRet = 0, bool bNonContentDirectory=false);

	static int MetaTableFunctionUserData__index(lua_State* L);
	static int MetaTableFunctionUserData__newindex(lua_State* L);

	static int TableFunction_print(lua_State* L);
	static int TableFunction_package_preload(lua_State* L);
	static int TableFunction_package_loader(lua_State* L);
	static int TableFunction_package_loader_codeasset(lua_State* L);
	static int TableFunction_package_loader_asset(lua_State* L);

	static int MetaTableFunction__call(lua_State* L);
	static int MetaTableFunction__rawcall(lua_State* L);
	static int MetaTableFunction__rawbroadcast(lua_State* L);

	static int MetaTableFunctionUserData__eq(lua_State* L);
	static int MetaTableFunctionUserData__gc(lua_State* L);

	static int ToByteCode_Writer(lua_State* L, const void* Ptr, size_t Size, void* UserData);

	static void Debug_Hook(lua_State* L, lua_Debug* ar);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	static TArray<uint8> ToByteCode(const FString& Code, const FString& CodePath, FString& ErrorString);

#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
	FLuaValue FromUProperty(void* Buffer, FProperty* Property, bool& bSuccess, int32 Index = 0);
	void ToUProperty(void* Buffer, FProperty* Property, FLuaValue Value, bool& bSuccess, int32 Index = 0);
	FLuaValue FromFProperty(void* Buffer, FProperty* Property, bool& bSuccess, int32 Index = 0);
	void ToFProperty(void* Buffer, FProperty* Property, FLuaValue Value, bool& bSuccess, int32 Index = 0);
	FLuaValue FromProperty(void* Buffer, FProperty* Property, bool& bSuccess, int32 Index = 0);
	void ToProperty(void* Buffer, FProperty* Property, FLuaValue Value, bool& bSuccess, int32 Index = 0);
#else
	FLuaValue FromUProperty(void* Buffer, UProperty* Property, bool& bSuccess, int32 Index = 0);
	void ToUProperty(void* Buffer, UProperty* Property, FLuaValue Value, bool& bSuccess, int32 Index = 0);
	FLuaValue FromProperty(void* Buffer, UProperty* Property, bool& bSuccess, int32 Index = 0);
	void ToProperty(void* Buffer, UProperty* Property, FLuaValue Value, bool& bSuccess, int32 Index = 0);
#endif

	static ULuaState* GetFromExtraSpace(lua_State* L)
	{
		ULuaState** LuaExtraSpacePtr = (ULuaState**)lua_getextraspace(L);
		return *LuaExtraSpacePtr;
	}

	void Log(const FString& Message)
	{
		UE_LOG(LogLuaMachine, Log, TEXT("%s"), *Message);
	}

	void LogWarning(const FString& Message)
	{
		UE_LOG(LogLuaMachine, Warning, TEXT("%s"), *Message);
	}

	void LogError(const FString& Message)
	{
		UE_LOG(LogLuaMachine, Error, TEXT("%s"), *Message);
	}

	void SetUserDataMetaTable(FLuaValue MetaTable);

	FORCEINLINE lua_State* GetInternalLuaState() const { return L; }

	void PushRegistryTable();

	TSharedRef<FLuaSmartReference> AddLuaSmartReference(FLuaValue Value);
	void RemoveLuaSmartReference(TSharedRef<FLuaSmartReference> Ref);

	void SetupAndAssignUserDataMetatable(UObject* Context, TMap<FString, FLuaValue>& Metatable, lua_State* State);

	const void* ToPointer(int Index);

	UPROPERTY(EditAnywhere, Category = "Lua")
	bool bRawLuaFunctionCall;

	void GCLuaDelegatesCheck();

	void RegisterLuaDelegate(UObject* InObject, ULuaDelegate* InLuaDelegate);
	void UnregisterLuaDelegatesOfObject(UObject* InObject);

	TArray<FString> GetPropertiesNames(UObject* InObject);
	TArray<FString> GetFunctionsNames(UObject* InObject);

	FLuaValue StructToLuaTable(UScriptStruct* InScriptStruct, const uint8* StructData);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	FLuaValue StructToLuaTable(UScriptStruct* InScriptStruct, const TArray<uint8>& StructData);

	void LuaTableToStruct(FLuaValue& LuaValue, UScriptStruct* InScriptStruct, uint8* StructData);

	template<class T>
	FLuaValue StructToLuaValue(T& InStruct)
	{
		return StructToLuaTable(T::StaticStruct(), (const uint8*)&InStruct);
	}

	template<class T>
	T LuaValueToStruct(FLuaValue& LuaValue)
	{
		T InStruct;
		LuaTableToStruct(LuaValue, T::StaticStruct(), (uint8*)&InStruct);
		return InStruct;
	}

	template<class T>
	T LuaValueToBaseStruct(FLuaValue& LuaValue)
	{
		T InStruct;
		LuaTableToStruct(LuaValue, TBaseStructure<T>::Get(), (uint8*)&InStruct);
		return InStruct;
	}

	FORCEINLINE FLuaCommandExecutor* GetLuaConsole() { return &LuaConsole; }

	UFUNCTION(BlueprintCallable, Category = "Lua")
	void AddLuaValueToLuaState(const FString& Name, FLuaValue LuaValue);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	FLuaValue RunString(const FString& CodeString, FString CodePath);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	void Error(const FString& ErrorString);

protected:
	lua_State* L;
	bool bDisabled;

	UWorld* CurrentWorld;

	FLuaValue UserDataMetaTable;

	virtual void LuaStateInit();

	FDelegateHandle GCLuaDelegatesHandle;

	UPROPERTY()
	TMap<TWeakObjectPtr<UObject>, FLuaDelegateGroup> LuaDelegatesMap;

	FLuaCommandExecutor LuaConsole;
};

#define LUACFUNCTION(FuncClass, FuncName, NumRetValues, NumArgs) static int FuncName ## _C(lua_State* L)\
{\
	FuncClass* LuaState = (FuncClass*)ULuaState::GetFromExtraSpace(L);\
	int TrueNumArgs = lua_gettop(L);\
	if (TrueNumArgs != NumArgs)\
	{\
		return luaL_error(L, "invalid number of arguments for %s (got %d, expected %d)", #FuncName, TrueNumArgs, NumArgs);\
	}\
	TArray<FLuaValue> LuaArgs;\
	for (int32 LuaArgIndex = 0; LuaArgIndex < NumArgs; LuaArgIndex++)\
	{\
		LuaArgs.Add(LuaState->ToLuaValue(LuaArgIndex + 1, L));\
	}\
	FLuaValue NilValue;\
	TArray<FLuaValue> RetValues = LuaState->FuncName(LuaArgs);\
	for (int32 RetIndex = 0; RetIndex < NumRetValues; RetIndex++)\
	{\
		if (RetIndex < RetValues.Num())\
		{\
			LuaState->FromLuaValue(RetValues[RetIndex]);\
		}\
		else\
		{\
			LuaState->FromLuaValue(NilValue);\
		}\
	}\
	return NumRetValues;\
}\
TArray<FLuaValue> FuncName(TArray<FLuaValue> LuaArgs)
```

`Source/LuaMachine/Public/LuaSyntaxHighlighter.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "Runtime/Slate/Public/Framework/Text/SyntaxHighlighterTextLayoutMarshaller.h"

struct FLuaSyntaxTextStyle
{
	FTextBlockStyle NormalTextStyle;
	FTextBlockStyle CommentTextStyle;
	FTextBlockStyle StringTextStyle;
	FTextBlockStyle KeywordTextStyle;
	FTextBlockStyle NilTextStyle;
	FTextBlockStyle BasicTextStyle;
	FTextBlockStyle StdLibTextStyle;
	TMap<FString, FLinearColor> CustomTextColorMapping;
	TMap<FString, FTextBlockStyle> CustomTextStyleMapping;
};


class LUAMACHINE_API FLuaMachineSyntaxHighlighterTextLayoutMarshaller : public FSyntaxHighlighterTextLayoutMarshaller
{
public:

	FLuaMachineSyntaxHighlighterTextLayoutMarshaller(TSharedPtr<FSyntaxTokenizer> InTokenizer, TArray<const TCHAR *> InBasicTokens, TArray<const TCHAR *> InStdLibTokens, FLuaSyntaxTextStyle InLuaSyntaxTextStyle);

	static TSharedRef<FLuaMachineSyntaxHighlighterTextLayoutMarshaller> Create(FLuaSyntaxTextStyle LuaSyntaxTextStyle);

protected:
	virtual void ParseTokens(const FString& SourceString, FTextLayout& TargetTextLayout, TArray<FSyntaxTokenizer::FTokenizedLine> TokenizedLines) override;

	TArray<const TCHAR *> BasicTokens;
	TArray<const TCHAR *> StdLibTokens;

	FLuaSyntaxTextStyle SyntaxTextStyle;
};

```

`Source/LuaMachine/Public/LuaTableAsset.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "LuaState.h"
#include "LuaValue.h"
#include "LuaTableAsset.generated.h"

/**
 * 
 */
UCLASS(BlueprintType)
class LUAMACHINE_API ULuaTableAsset : public UDataAsset
{
	GENERATED_BODY()
	
public:

	UPROPERTY(EditAnywhere, Category = "Lua")
	TMap<FString, FLuaValue> Table;

	FLuaValue ToLuaTable(ULuaState* LuaState);
};

```

`Source/LuaMachine/Public/LuaUserDataObject.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "LuaState.h"
#include "LuaUserDataObject.generated.h"

/**
 * 
 */
UCLASS(Abstract, Blueprintable, HideDropdown)
class LUAMACHINE_API ULuaUserDataObject : public UObject
{
	GENERATED_BODY()
	
public:

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	TSubclassOf<ULuaState> GetLuaState() const;

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	ULuaState* GetLuaStateInstance() const;

	virtual UWorld* GetWorld() const override;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	TMap<FString, FLuaValue> Table;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	TMap<FString, FLuaValue> Metatable;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Lua")
	bool bImplicitSelf;

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	FLuaValue LuaGetField(const FString& Name);

	UFUNCTION(BlueprintCallable, Category = "Lua")
	void LuaSetField(const FString& Name, FLuaValue Value);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua UserData Metatable __gc"))
	void ReceiveLuaGC();

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua UserData Metatable __index"))
	FLuaValue ReceiveLuaMetaIndex(FLuaValue Key);

	UFUNCTION(BlueprintNativeEvent, Category = "Lua", meta = (DisplayName = "Lua UserData Table Init"))
	void ReceiveLuaUserDataTableInit();

	UFUNCTION(BlueprintCallable, Category = "Lua", meta = (AutoCreateRefTerm = "Args"))
	FLuaValue LuaCallFunction(const FString& Name, TArray<FLuaValue> Args, bool bGlobal);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	FLuaValue UFunctionToLuaValue(const FString& FunctionName);

	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Lua")
	TArray<FString> GetObjectUFunctions(bool bOnlyPublic=true);

protected:
	TSharedPtr<FLuaSmartReference> AddLuaSmartReference(FLuaValue Value);
	void RemoveLuaSmartReference(TSharedPtr<FLuaSmartReference> Ref);
};

```

`Source/LuaMachine/Public/LuaValue.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "ThirdParty/lua/lua.hpp"
#include "Serialization/JsonSerializer.h"
#include "LuaValue.generated.h"

// required for Mac
#ifdef Nil
#undef Nil
#endif

/**
 *
 */

UENUM(BlueprintType)
enum class ELuaValueType : uint8
{
	Nil,
	Bool,
	Integer,
	Number,
	String,
	Function,
	Table,
	UFunction,
	UObject,
	Thread,
	MulticastDelegate,
};

class ULuaState;

USTRUCT(BlueprintType)
struct LUAMACHINE_API FLuaValue
{
	GENERATED_BODY()

	FLuaValue()
	{
		Type = ELuaValueType::Nil;
		Object = nullptr;
		LuaRef = LUA_NOREF;
		LuaState = nullptr;
		Bool = false;
		Integer = 0;
		Number = 0;
		MulticastScriptDelegate = nullptr;
	}

	FLuaValue(const FLuaValue& SourceValue);
	FLuaValue& operator = (const FLuaValue &SourceValue);

	FLuaValue(const FString& InString) : FLuaValue()
	{
		Type = ELuaValueType::String;
		String = InString;
	}

	FLuaValue(const char* InChars) : FLuaValue(FString(InChars))
	{
	}

	FLuaValue(const TCHAR* InChars) : FLuaValue(FString(InChars))
	{
	}

	FLuaValue(const char* InChars, size_t Length) : FLuaValue()
	{
		Type = ELuaValueType::String;
		for (size_t i = 0; i < Length; i++)
		{
			uint16 TChar = (uint16)InChars[i];
			// cleanup garbage
			TChar &= 0xFF;
			// hack for allowing binary data
			if (TChar == 0)
			{
				TChar = 0xffff;
			}
			String += (TCHAR)TChar;
		}
	}

	FLuaValue(const TArray<uint8>& InBytes) : FLuaValue(reinterpret_cast<const char*>(InBytes.GetData()), InBytes.Num())
	{
	}

	FLuaValue(const double Value) : FLuaValue()
	{
		Type = ELuaValueType::Number;
		Number = Value;
	}

	FLuaValue(const float Value) : FLuaValue()
	{
		Type = ELuaValueType::Number;
		Number = Value;
	}

	FLuaValue(const int64 Value) : FLuaValue()
	{
		Type = ELuaValueType::Integer;
		Integer = Value;
	}

	FLuaValue(const int32 Value) : FLuaValue()
	{
		Type = ELuaValueType::Integer;
		Integer = Value;
	}

	FLuaValue(const bool bInBool) : FLuaValue()
	{
		Type = ELuaValueType::Bool;
		Bool = bInBool;
	}

	FLuaValue(UObject* InObject) : FLuaValue()
	{
		if (InObject)
		{
			Type = ELuaValueType::UObject;
			Object = InObject;
		}
	}

	~FLuaValue();

	static FLuaValue Function(FName FunctionName)
	{
		FLuaValue LuaValue;
		LuaValue.Type = ELuaValueType::UFunction;
		LuaValue.FunctionName = FunctionName;
		return LuaValue;
	}

	static FLuaValue FunctionOfObject(UObject* InObject, FName FunctionName)
	{
		FLuaValue LuaValue;
		LuaValue.Type = ELuaValueType::UFunction;
		LuaValue.Object = InObject;
		LuaValue.FunctionName = FunctionName;
		return LuaValue;
	}

	FString ToString() const;
	FName ToName() const;
	int64 ToInteger() const;
	double ToFloat() const;
	bool ToBool() const;

	TArray<uint8> ToBytes() const;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	ELuaValueType Type;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	bool Bool;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	int64 Integer;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	double Number;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	FString String;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	UObject* Object;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Lua")
	FName FunctionName;

	int LuaRef;

	TWeakObjectPtr<ULuaState> LuaState;

	FLuaValue GetField(const FString& Key);
	FLuaValue SetField(const FString& Key, FLuaValue Value);

	FLuaValue SetField(const FString& Key, lua_CFunction CFunction);

	FLuaValue GetFieldByIndex(const int32 Index);
	FLuaValue SetFieldByIndex(const int32 Index, FLuaValue Value);

	FLuaValue SetMetaTable(FLuaValue MetaTable);

	bool IsReferencedInLuaRegistry() const;

	static FLuaValue FromJsonValue(ULuaState* L, FJsonValue& JsonValue);
	TSharedPtr<FJsonValue> ToJsonValue();

	static FLuaValue FromBase64(const FString& Base64);
	FString ToBase64() const;

	bool IsNil() const;

	void Unref();

	FMulticastScriptDelegate* MulticastScriptDelegate = nullptr;
};

```

`Source/LuaMachineEditor/LuaMachineEditor.Build.cs`:

```cs
// Copyright 2018-2023 - Roberto De Ioris

using UnrealBuildTool;

public class LuaMachineEditor : ModuleRules
{
    public LuaMachineEditor(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicIncludePaths.AddRange(
            new string[] {
				// ... add public include paths required here ...
			}
            );


        PrivateIncludePaths.AddRange(
            new string[] {
				// ... add other private include paths required here ...
			}
            );


        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
				// ... add other public dependencies that you statically link with here ...
			}
            );


        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "CoreUObject",
                "Engine",
                "Slate",
                "SlateCore",
				// ... add private dependencies that you statically link with here ...
                "UnrealEd",
                "Projects",
                "InputCore",
                "EditorStyle",
                "LuaMachine"
            }
            );


        DynamicallyLoadedModuleNames.AddRange(
            new string[]
            {
				// ... add any modules that your module loads dynamically here ...
			}
            );
    }
}

```

`Source/LuaMachineEditor/Private/LuaCodeCustomization.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaCodeCustomization.h"
#include "LuaMachineEditor.h"
#include "Runtime/Slate/Public/Widgets/Input/SMultiLineEditableTextBox.h"
#include "Editor/PropertyEditor/Public/PropertyHandle.h"
#include "Editor/PropertyEditor/Public/DetailLayoutBuilder.h"
#include "Editor/PropertyEditor/Public/DetailCategoryBuilder.h"
#include "Editor/PropertyEditor/Public/IDetailChildrenBuilder.h"
#include "Editor/PropertyEditor/Public/DetailWidgetRow.h"
#include "Runtime/Slate/Public/Widgets/Text/STextBlock.h"
#include "Runtime/SlateCore/Public/Brushes/SlateColorBrush.h"
#include "Runtime/Slate/Public/Widgets/Text/SlateEditableTextLayout.h"
#include "Runtime/SlateCore/Public/Fonts/FontMeasure.h"
#include "Runtime/Slate/Public/Framework/Application/SlateApplication.h"
#include "Runtime/Slate/Public/Framework/MultiBox/MultiBoxBuilder.h"
#include "LuaMachine/Public/LuaCode.h"
#include "LuaMachine/Public/LuaSyntaxHighlighter.h"


class SLuaMultiLineEditableTextBox : public SMultiLineEditableTextBox
{
public:
	SLATE_BEGIN_ARGS(SLuaMultiLineEditableTextBox) {}

	SLATE_ARGUMENT(TWeakObjectPtr<ULuaCode>, LuaCodeOwner);

	SLATE_END_ARGS()

		void Construct(const FArguments& InArgs)
	{
		LuaCode = InArgs._LuaCodeOwner;
		CurrentLine = 1;
		CurrentColumn = 1;

		FLuaSyntaxTextStyle LuaTextStyle;

		LuaTextStyle.NormalTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.Normal");
		LuaTextStyle.CommentTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.Comment");
		LuaTextStyle.StringTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.String");
		LuaTextStyle.KeywordTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.Keyword");
		LuaTextStyle.NilTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.Nil");
		LuaTextStyle.BasicTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.Basic");
		LuaTextStyle.StdLibTextStyle = FLuaMachineEditorModule::Get().GetStyleSet()->GetWidgetStyle<FTextBlockStyle>("SyntaxHighlight.LuaMachine.StdLib");

		SyntaxHighlighter = FLuaMachineSyntaxHighlighterTextLayoutMarshaller::Create(LuaTextStyle);

		FMenuExtensionDelegate Delegate;
		Delegate.BindLambda([&](FMenuBuilder &Builder)
		{
			Builder.AddWidget(SNew(STextBlock).Text_Lambda([&]() {
				return FText::FromString(FString::Printf(TEXT("Line: %d Column: %d"), CurrentLine, CurrentColumn));
			}), FText::GetEmpty());

		});

		SMultiLineEditableTextBox::Construct(
			SMultiLineEditableTextBox::FArguments()
			.AutoWrapText(false)
			.Margin(0.0f)
			.Text(LuaCode->Code)
			.Marshaller(SyntaxHighlighter)
			.OnTextChanged(this, &SLuaMultiLineEditableTextBox::UpdateLuaCode)
			.BackgroundColor(FSlateColor(FLinearColor::Black))
			.ForegroundColor(FSlateColor(FLinearColor::White))
			.ContextMenuExtender(Delegate)
			.OnCursorMoved_Lambda([&](const FTextLocation& Location) {
			CurrentLine = Location.GetLineIndex() + 1;
			CurrentColumn = Location.GetOffset() + 1;
		})
		);

	}

	void UpdateLuaCode(const FText& InCode)
	{
		LuaCode->Code = InCode;
		LuaCode->MarkPackageDirty();
	}

protected:

	int32 CurrentLine;
	int32 CurrentColumn;

	float GetFontHeight(const FSlateFontInfo& FontInfo) const
	{
		const TSharedRef<FSlateFontMeasure> FontMeasure = FSlateApplication::Get().GetRenderer()->GetFontMeasureService();
		return FontMeasure->GetMaxCharacterHeight(FontInfo);
	}

	virtual FVector2D ComputeDesiredSize(float LayoutScaleMultiplier) const override
	{
		float MinimumHeight = 500;
		float MaxHeight = 800;

		FVector2D Size = SMultiLineEditableTextBox::ComputeDesiredSize(LayoutScaleMultiplier);
		if (Size.Y < MinimumHeight)
			Size.Y = MinimumHeight;
		if (Size.Y > MaxHeight)
			Size.Y = MaxHeight;
		return Size;
	}

	virtual FReply OnKeyChar(const FGeometry& InGeometry, const FCharacterEvent& InCharacterEvent) override
	{
		const TCHAR Character = InCharacterEvent.GetCharacter();
		if (Character == TEXT('\t'))
		{
			ClearSelection();
			InsertTextAtCursor(FString("  "));
			return FReply::Handled();
		}
		return SMultiLineEditableTextBox::OnKeyChar(InGeometry, InCharacterEvent);
	}

	virtual FReply OnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent) override
	{

		if (InKeyEvent.GetKeyCode() == 9)
		{
			return FReply::Handled();
		}
		return SMultiLineEditableTextBox::OnKeyDown(InGeometry, InKeyEvent);
	}

private:
	TWeakObjectPtr<ULuaCode> LuaCode;
	TSharedPtr<FLuaMachineSyntaxHighlighterTextLayoutMarshaller> SyntaxHighlighter;
};

class SLuaEditor : public SCompoundWidget
{
public:
	SLATE_BEGIN_ARGS(SLuaEditor) {}

	SLATE_ARGUMENT(TWeakObjectPtr<ULuaCode>, LuaCodeOwner);

	SLATE_END_ARGS()

		void Construct(const FArguments& InArgs)
	{
		LuaCode = InArgs._LuaCodeOwner;

		BackgroundColor = FSlateColorBrush(FLinearColor::Black);

		ChildSlot.Padding(4)[
			SNew(SBorder).BorderImage(&BackgroundColor).BorderBackgroundColor(FSlateColor(FLinearColor::White))
				[

					SNew(SLuaMultiLineEditableTextBox)
					.LuaCodeOwner(LuaCode)

				]
		];
	}



private:
	TWeakObjectPtr<ULuaCode> LuaCode;
	FSlateBrush BackgroundColor;
};

void FLuaCodeCustomization::CustomizeDetails(IDetailLayoutBuilder& DetailBuilder)
{
	TArray<TWeakObjectPtr<UObject>> Objects;
	DetailBuilder.GetObjectsBeingCustomized(Objects);

	if (Objects.Num() != 1)
	{
		return;
	}

	TWeakObjectPtr<ULuaCode> LuaCode = Cast<ULuaCode>(Objects[0].Get());

	TSharedRef<IPropertyHandle> Prop = DetailBuilder.GetProperty(GET_MEMBER_NAME_CHECKED(ULuaCode, Code));
	DetailBuilder.HideProperty(Prop);


	IDetailCategoryBuilder& Category = DetailBuilder.EditCategory("Code");
	Category.AddCustomRow(FText::FromString("Code")).WholeRowContent()[

		SNew(SLuaEditor).LuaCodeOwner(LuaCode)

	];

}





```

`Source/LuaMachineEditor/Private/LuaCodeFactory.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris
// Reimport system by yama2akira (Akira Yamamoto)

#include "LuaCodeFactory.h"
#include "LuaCode.h"
#include "EditorFramework/AssetImportData.h"
#include "Misc/FileHelper.h"
#include "LuaMachineEditor.h"

ULuaCodeFactory::ULuaCodeFactory(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer) {

	Formats.Add(FString("lua;Lua Script"));

	bCreateNew = true;
	bEditAfterNew = true;

	bEditorImport = true;

	SupportedClass = ULuaCode::StaticClass();
}

UObject* ULuaCodeFactory::FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn, FName CallingContext)
{
	return NewObject<ULuaCode>(InParent, InClass, InName, Flags);
}

UObject* ULuaCodeFactory::FactoryCreateBinary(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, const TCHAR* Type, const uint8*& Buffer, const uint8* BufferEnd, FFeedbackContext* Warn, bool& bOutOperationCanceled)
{
	bOutOperationCanceled = false;
	FString Code = ANSI_TO_TCHAR((const char*)Buffer);
	ULuaCode *NewAsset = NewObject<ULuaCode>(InParent, InClass, InName, Flags);
	NewAsset->Code = FText::FromString(Code);

	if (NewAsset->AssetImportData != nullptr) {
		NewAsset->AssetImportData->Update(GetCurrentFilename());
		NewAsset->MarkPackageDirty();
	}
	return NewAsset;
}

uint32 ULuaCodeFactory::GetMenuCategories() const
{
	return FLuaMachineEditorModule::Get().GetAssetCategory();
}

bool ULuaCodeFactory::CanReimport(UObject* Obj, TArray<FString>& OutFilenames)
{
	ULuaCode* Asset = Cast<ULuaCode>(Obj);
	if (Asset && Asset->AssetImportData)
	{
		Asset->AssetImportData->ExtractFilenames(OutFilenames);

		for (auto FileName : OutFilenames)
		{
			FString FileContent;
			if (FFileHelper::LoadFileToString(/*out*/ FileContent, *FileName))
			{
				if (Asset->Code.ToString().Compare(FileContent) == 0)
				{
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

void ULuaCodeFactory::SetReimportPaths(UObject* Obj, const TArray<FString>& NewReimportPaths)
{
	ULuaCode* Asset = Cast<ULuaCode>(Obj);
	if (Asset && ensure(NewReimportPaths.Num() == 1))
	{
		Asset->AssetImportData->UpdateFilenameOnly(NewReimportPaths[0]);
	}
}

EReimportResult::Type ULuaCodeFactory::Reimport(UObject* Obj)
{
	ULuaCode* Asset = Cast<ULuaCode>(Obj);
	if (!Asset)
	{
		return EReimportResult::Failed;
	}

	const FString Filename = Asset->AssetImportData->GetFirstFilename();
	if (!Filename.Len() || IFileManager::Get().FileSize(*Filename) == INDEX_NONE)
	{
		return EReimportResult::Failed;
	}

	EReimportResult::Type Result = EReimportResult::Failed;
	if (UFactory::StaticImportObject(
		Asset->GetClass(), Asset->GetOuter(),
		*Asset->GetName(), RF_Public | RF_Standalone, *Filename, NULL, this))
	{
		if (Asset->GetOuter())
		{
			Asset->GetOuter()->MarkPackageDirty();
		}
		else
		{
			Asset->MarkPackageDirty();
		}
		return EReimportResult::Succeeded;
	}

	return EReimportResult::Failed;
}

FLuaCodeAssetTypeActions::FLuaCodeAssetTypeActions( EAssetTypeCategories::Type InAssetCategory )
{

}

FText FLuaCodeAssetTypeActions::GetName() const
{
	return NSLOCTEXT( "LuaMachine", "LuaCodeAssetActions", "Lua Code" );
}

FColor FLuaCodeAssetTypeActions::GetTypeColor() const
{
	return FColor::Red;
}

UClass* FLuaCodeAssetTypeActions::GetSupportedClass() const
{
	return ULuaCode::StaticClass();
}

uint32 FLuaCodeAssetTypeActions::GetCategories()
{
	return FLuaMachineEditorModule::Get().GetAssetCategory();
}

bool FLuaCodeAssetTypeActions::IsImportedAsset() const
{
	return true;
}

void FLuaCodeAssetTypeActions::GetResolvedSourceFilePaths( const TArray<UObject*>& TypeAssets, TArray<FString>& OutSourceFilePaths ) const
{
	for ( auto& Asset : TypeAssets )
	{
		const auto LuaCode = CastChecked<ULuaCode>( Asset );
		if ( LuaCode->AssetImportData )
		{
			LuaCode->AssetImportData->ExtractFilenames( OutSourceFilePaths );
		}
	}
}


```

`Source/LuaMachineEditor/Private/LuaMachineEditor.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaMachineEditor.h"
#include "Editor/UnrealEd/Public/Editor.h"
#include "Editor/PropertyEditor/Public/PropertyEditorModule.h"
#include "EditorStyleSet.h"
#include "Runtime/Projects/Public/Interfaces/IPluginManager.h"
#include "LuaCodeCustomization.h"
#include "LuaValueCustomization.h"
#include "Editor/WorkspaceMenuStructure/Public/WorkspaceMenuStructure.h"
#include "Editor/WorkspaceMenuStructure/Public/WorkspaceMenuStructureModule.h"
#include "Runtime/Slate/Public/Widgets/Text/STextBlock.h"
#include "Runtime/Slate/Public/Widgets/Views/STreeView.h"
#include "Runtime/Slate/Public/Widgets/Input/SButton.h"
#include "Runtime/Slate/Public/Widgets/Input/STextComboBox.h"
#include "LuaMachine/Public/LuaMachine.h"
#include "LuaMachine/Public/LuaBlueprintFunctionLibrary.h"
#include "Widgets/Layout/SScrollBox.h"
#include "LuaUserDataObject.h"
#include "LuaCodeFactory.h"

#define LOCTEXT_NAMESPACE "FLuaMachineEditorModule"

FLuaMachineEditorModule::FLuaMachineEditorModule()
	: LuaMachineAssetCategoryBit(EAssetTypeCategories::Misc)
{

}

void FLuaMachineEditorModule::StartupModule()
{
	FCoreDelegates::OnPostEngineInit.AddRaw(this, &FLuaMachineEditorModule::OnPostEngineInit);

	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module

	StyleSet = MakeShareable(new FSlateStyleSet("LuaMachineEditor"));
	StyleSet->SetContentRoot(IPluginManager::Get().FindPlugin("LuaMachine")->GetBaseDir() / "Resources");
	StyleSet->Set("ClassThumbnail.LuaCode", new FSlateImageBrush(StyleSet->RootToContentDir("Icon128.png"), FVector2D(128.0f, 128.0f)));
	StyleSet->Set("ClassThumbnail.LuaTableAsset", new FSlateImageBrush(StyleSet->RootToContentDir("LuaTableAsset256.png"), FVector2D(256.0f, 256.0f)));

	const FSlateFontInfo Consolas9 = FCoreStyle::GetDefaultFontStyle("Mono", 9);

	const FTextBlockStyle CodeBaseStyle = FTextBlockStyle()
		.SetFont(Consolas9)
		.SetColorAndOpacity(FLinearColor::White)
		.SetShadowOffset(FVector2D::ZeroVector)
		.SetShadowColorAndOpacity(FLinearColor::Black);

	StyleSet->Set("SyntaxHighlight.LuaMachine.Normal", CodeBaseStyle);
	StyleSet->Set("SyntaxHighlight.LuaMachine.Comment", FTextBlockStyle(CodeBaseStyle).SetColorAndOpacity(FLinearColor::Green));
	StyleSet->Set("SyntaxHighlight.LuaMachine.String", FTextBlockStyle(CodeBaseStyle).SetColorAndOpacity(FLinearColor(FColor::Orange)));
	StyleSet->Set("SyntaxHighlight.LuaMachine.Keyword", FTextBlockStyle(CodeBaseStyle).SetColorAndOpacity(FLinearColor(FColor::Cyan)));
	StyleSet->Set("SyntaxHighlight.LuaMachine.Nil", FTextBlockStyle(CodeBaseStyle).SetColorAndOpacity(FLinearColor::Red));
	StyleSet->Set("SyntaxHighlight.LuaMachine.StdLib", FTextBlockStyle(CodeBaseStyle).SetColorAndOpacity(FLinearColor::Yellow));
	StyleSet->Set("SyntaxHighlight.LuaMachine.Basic", FTextBlockStyle(CodeBaseStyle).SetColorAndOpacity(FLinearColor::FromSRGBColor(FColor::Magenta)));

#if ENGINE_MINOR_VERSION >= 3
	FSlateStyleRegistry::RegisterSlateStyle(*StyleSet.Get());
#endif

	FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>(TEXT("PropertyEditor"));

	PropertyModule.RegisterCustomPropertyTypeLayout(TEXT("LuaValue"), FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FLuaValueCustomization::MakeInstance));
	PropertyModule.RegisterCustomClassLayout(TEXT("LuaCode"), FOnGetDetailCustomizationInstance::CreateStatic(&FLuaCodeCustomization::MakeInstance));

	PropertyModule.NotifyCustomizationModuleChanged();

	FGlobalTabmanager::Get()->RegisterNomadTabSpawner("LuaMachineDebugger", FOnSpawnTab::CreateStatic(&FLuaMachineEditorModule::CreateLuaMachineDebugger))
		.SetDisplayName(LOCTEXT("LuaMachine Debugger", "LuaMachine Debugger"))
		.SetTooltipText(LOCTEXT("Open the LuaMachine Debugger", "Open the LuaMachine Debugger"))
		.SetIcon(FSlateIcon(
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 1
			FAppStyle::GetAppStyleSetName()
#else
			FEditorStyle::GetStyleSetName()
#endif
			, "DebugTools.TabIcon"))
		.SetGroup(WorkspaceMenu::GetMenuStructure().GetDeveloperToolsMiscCategory());
}

void FLuaMachineEditorModule::OnPostEngineInit()
{
	IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();

	LuaMachineAssetCategoryBit = AssetTools.RegisterAdvancedAssetCategory(FName(TEXT("LuaMachine")), LOCTEXT("AssetCategory", "Lua Machine"));

	//Add LuaCode to Filters.
	RegisterAssetTypeAction(AssetTools, MakeShareable(new FLuaCodeAssetTypeActions(LuaMachineAssetCategoryBit)));
}

TSharedPtr<FSlateStyleSet> FLuaMachineEditorModule::GetStyleSet()
{
	return StyleSet;
}

void FLuaMachineEditorModule::RegisterAssetTypeAction(IAssetTools& AssetTools, TSharedRef<IAssetTypeActions> Action)
{
	AssetTools.RegisterAssetTypeActions(Action);
	CreatedAssetTypeActions.Add(Action);
}

struct FTableViewLuaValue : public TSharedFromThis<FTableViewLuaValue>
{
	FString LuaTableKey;
	FLuaValue LuaTableValue;
	bool bExpanded;
	TArray<TSharedRef<FTableViewLuaValue>> Children;
};

class SLuaMachineDebugger : public SCompoundWidget, public FGCObject
{
	SLATE_BEGIN_ARGS(SLuaMachineDebugger)
		{}

	SLATE_END_ARGS()

	void RebuildLuaValues()
	{
		LuaValues.Empty();

		if (!SelectedLuaState)
		{
			return;
		}

		SelectedLuaState->PushGlobalTable();
		SelectedLuaState->PushNil(); // first key
		while (SelectedLuaState->Next(-2))
		{
			FLuaValue CurrentLuaKey = SelectedLuaState->ToLuaValue(-2);
			FLuaValue CurrentLuaValue = SelectedLuaState->ToLuaValue(-1);
			TSharedRef<FTableViewLuaValue> LuaItem = MakeShared<FTableViewLuaValue>();
			LuaItem->LuaTableKey = CurrentLuaKey.ToString();
			LuaItem->LuaTableValue = CurrentLuaValue;
			LuaItem->bExpanded = false;
			LuaValues.Add(LuaItem); // add key
			SelectedLuaState->Pop(); // pop the value
		}

		SelectedLuaState->Pop(); // pop the table

		LuaValues.Sort([](const TSharedRef<FTableViewLuaValue>& LHS, const TSharedRef<FTableViewLuaValue>& RHS) { return LHS->LuaTableKey < RHS->LuaTableKey; });
	}

	void OnGetChildren(TSharedRef<FTableViewLuaValue> Item, TArray<TSharedRef<FTableViewLuaValue>>& OutChildren)
	{
		if (!SelectedLuaState)
			return;

		if (Item->LuaTableValue.Type == ELuaValueType::Table)
		{
			if (!Item->bExpanded)
			{
				SelectedLuaState->FromLuaValue(Item->LuaTableValue);
				SelectedLuaState->PushNil(); // first key
				while (SelectedLuaState->Next(-2))
				{
					FLuaValue CurrentLuaKey = SelectedLuaState->ToLuaValue(-2);
					FLuaValue CurrentLuaValue = SelectedLuaState->ToLuaValue(-1);
					TSharedRef<FTableViewLuaValue> LuaItem = MakeShared<FTableViewLuaValue>();
					LuaItem->LuaTableKey = CurrentLuaKey.ToString();
					LuaItem->LuaTableValue = CurrentLuaValue;
					LuaItem->bExpanded = false;
					Item->Children.Add(LuaItem); // add key
					SelectedLuaState->Pop(); // pop the value
				}
				SelectedLuaState->Pop(); // pop the table
				Item->bExpanded = true;
				Item->Children.Sort([](const TSharedRef<FTableViewLuaValue>& LHS, const TSharedRef<FTableViewLuaValue>& RHS) { return LHS->LuaTableKey < RHS->LuaTableKey; });
			}
			OutChildren.Append(Item->Children);
		}
		else if (Item->LuaTableValue.Type == ELuaValueType::UObject && Item->LuaTableValue.Object)
		{
			if (Item->LuaTableValue.Object->IsA<ULuaUserDataObject>())
			{
				if (!Item->bExpanded)
				{
					ULuaUserDataObject* LuaUserDataObject = Cast<ULuaUserDataObject>(Item->LuaTableValue.Object);
					if (LuaUserDataObject)
					{
						for (TPair<FString, FLuaValue> Pair : LuaUserDataObject->Table)
						{
							TSharedRef<FTableViewLuaValue> LuaItem = MakeShared<FTableViewLuaValue>();
							LuaItem->LuaTableKey = Pair.Key;
							LuaItem->LuaTableValue = Pair.Value;
							LuaItem->bExpanded = false;
							Item->Children.Add(LuaItem);
						}
					}
					Item->bExpanded = true;
					Item->Children.Sort([](const TSharedRef<FTableViewLuaValue>& LHS, const TSharedRef<FTableViewLuaValue>& RHS) { return LHS->LuaTableKey < RHS->LuaTableKey; });
				}
				OutChildren.Append(Item->Children);
			}
		}
	}

	void OnRegisteredLuaStatesChanged()
	{
		DetectedLuaStates.Empty();
		TArray<ULuaState*> States = FLuaMachineModule::Get().GetRegisteredLuaStates();
		for (ULuaState* State : States)
		{
			DetectedLuaStates.Add(MakeShared<FString>(State->GetClass()->GetName()));
		}

		if (LuaStatesComboBox.IsValid())
		{
			LuaStatesComboBox->RefreshOptions();
		}

		RefreshDebugText();
	}

	FReply CallGC()
	{
		GEngine->ForceGarbageCollection(true);
		return RefreshDebugger();
	}

	FReply CallLuaGC()
	{
		// avoid calling Lua GC on invalid lua state
		RefreshDebugger();
		if (SelectedLuaState && SelectedLuaState->GetInternalLuaState())
		{
			SelectedLuaState->GC(LUA_GCCOLLECT);
		}
		return RefreshDebugger();
	}

	void RefreshDebugText()
	{
		DebugTextContext.Empty();
		ReferencersTextContext.Empty();

		for (TObjectIterator<ULuaState> StatesIterator; StatesIterator; ++StatesIterator)
		{
			ULuaState* LuaState = *StatesIterator;
#if ENGINE_MAJOR_VERSION > 4
			if (LuaState->IsValidLowLevel() && !IsValid(LuaState))
#else
			if (LuaState->IsValidLowLevel() && !LuaState->IsPendingKill())
#endif
			{
				TArray<UObject*> Referencers;
				FReferenceFinder Collector(Referencers, nullptr, false, true, false, false);
				Collector.FindReferences(LuaState);

				if (LuaState->GetInternalLuaState())
				{
					LuaState->PushRegistryTable();
					int32 RegistrySize = LuaState->ILen(-1);
					LuaState->Pop();
					DebugTextContext += FString::Printf(TEXT("%s at 0x%p (%sused memory: %dk) (top of the stack: %d) (registry size: %d) (uobject refs: %d) (tracked user data: %d)\n"), *LuaState->GetName(), LuaState, LuaState->bPersistent ? TEXT("persistent, ") : TEXT(""), LuaState->GC(LUA_GCCOUNT), LuaState->GetTop(), RegistrySize, Referencers.Num(), LuaState->TrackedLuaUserDataObjects.Num());
				}
				else
				{
					DebugTextContext += FString::Printf(TEXT("%s at 0x%p (%sinactive) (uobject refs: %d)\n"), *LuaState->GetName(), LuaState, LuaState->bPersistent ? TEXT("persistent, ") : TEXT(""), Referencers.Num());
				}
			}
		}

		if (SelectedLuaState)
		{
			TArray<UObject*> Referencers;
			FReferenceFinder Collector(Referencers, nullptr, false, true, false, false);
			Collector.FindReferences(SelectedLuaState);

			for (UObject* Referencer : Referencers)
			{
				ReferencersTextContext += FString::Printf(TEXT("%s\n"), *Referencer->GetFullName());
			}
		}

		if (DebugText.IsValid())
		{
			DebugText->SetText(FText::FromString(DebugTextContext));
		}

		if (ReferencersText.IsValid())
		{
			ReferencersText->SetText(FText::FromString(ReferencersTextContext));
		}
	}

	FSlateColor GetLuaTypeColor(TSharedRef<FTableViewLuaValue> Item)
	{
		switch (Item->LuaTableValue.Type)
		{
		case ELuaValueType::Nil:
		case ELuaValueType::Number:
		case ELuaValueType::Integer:
			return FSlateColor(FColor::Red);
		case ELuaValueType::String:
			return FSlateColor(FColor::Orange);
		case ELuaValueType::Bool:
			return FSlateColor(FColor::Purple);
		case ELuaValueType::UFunction:
			return FSlateColor(FColor::Magenta);
		case ELuaValueType::UObject:
			return FSlateColor(FColor::Cyan);
		case ELuaValueType::Thread:
			return FSlateColor(FColor::Yellow);
		default:
			return FSlateColor(FLinearColor::White);
		}
	}

	FText GetLuaTypeText(TSharedRef<FTableViewLuaValue> Item)
	{
		FString Value = "nil";
		switch (Item->LuaTableValue.Type)
		{
		case ELuaValueType::String:
			Value = "string";
			break;
		case ELuaValueType::Bool:
			Value = "boolean";
			break;
		case ELuaValueType::Integer:
			Value = "integer";
			break;
		case ELuaValueType::Number:
			Value = "number";
			break;
		case ELuaValueType::Function:
			Value = "function";
			break;
		case ELuaValueType::Table:
			Value = "table";
			break;
		case ELuaValueType::Thread:
			Value = "thread";
			break;
		case ELuaValueType::UFunction:
			Value = "UFunction";
			break;
		case ELuaValueType::UObject:
			Value = "UObject";
			break;
		default:
			break;
		}

		return FText::FromString(Value);
	}

	FText GetLuaValueText(TSharedRef<FTableViewLuaValue> Item)
	{
		FString Value = "";
		switch (Item->LuaTableValue.Type)
		{
		case ELuaValueType::String:
		case ELuaValueType::Bool:
		case ELuaValueType::Integer:
		case ELuaValueType::Number:
		case ELuaValueType::UFunction:
		case ELuaValueType::UObject:
			Value = Item->LuaTableValue.ToString();
			break;
		case ELuaValueType::Thread:
			if (SelectedLuaState == Item->LuaTableValue.LuaState)
			{
				Value = "status: " + FindObject<UEnum>(nullptr, TEXT("/Script/LuaMachine.ELuaThreadStatus"), true)->GetNameStringByIndex((int32)SelectedLuaState->GetLuaThreadStatus(Item->LuaTableValue)) + ", stack top: " + FString::FromInt(SelectedLuaState->GetLuaThreadStackTop(Item->LuaTableValue));
			}
			break;
		default:
			break;
		}

		return FText::FromString(Value);
	}

	FReply RefreshDebugger()
	{
		if (LuaTreeView.IsValid())
		{
			if (LuaStatesComboBox.IsValid())
			{
				SelectedLuaState = nullptr;
				TSharedPtr<FString> SelectedText = LuaStatesComboBox->GetSelectedItem();
				if (SelectedText.IsValid())
				{
					TArray<ULuaState*> States = FLuaMachineModule::Get().GetRegisteredLuaStates();
					for (ULuaState* State : States)
					{
						if (State->GetClass()->GetName() == *SelectedText.Get())
						{
							if (State->GetInternalLuaState())
								SelectedLuaState = State;
							break;
						}
					}
				}
			}
			RebuildLuaValues();
			LuaTreeView->RequestTreeRefresh();
		}

		RefreshDebugText();
		return FReply::Handled();
	}

	TSharedRef<ITableRow> OnGenerateDebuggerRow(TSharedRef<FTableViewLuaValue> Item, const TSharedRef<STableViewBase>& OwnerTable)
	{
		return SNew(STableRow<TSharedRef<FTableViewLuaValue>>, OwnerTable)
			[
				SNew(SHorizontalBox)
					+ SHorizontalBox::Slot()
					[
						SNew(STextBlock).Text(FText::FromString(Item->LuaTableKey))
					]
					+ SHorizontalBox::Slot().FillWidth(0.2)
					[
						SNew(STextBlock).Text(GetLuaTypeText(Item))
					]
					+ SHorizontalBox::Slot()
					[
						SNew(STextBlock).Text(GetLuaValueText(Item)).ColorAndOpacity(GetLuaTypeColor(Item)).ToolTipText(GetLuaValueText(Item))
					]
			];
	}

	void Construct(const FArguments& InArgs)
	{
		SelectedLuaState = nullptr;
		OnRegisteredLuaStatesChanged();
		RebuildLuaValues();
		ChildSlot[
			SNew(SVerticalBox)
				+ SVerticalBox::Slot().AutoHeight()
				[
					SNew(SHorizontalBox)
						+ SHorizontalBox::Slot().AutoWidth().VAlign(EVerticalAlignment::VAlign_Center).HAlign(EHorizontalAlignment::HAlign_Left)
						[
							SNew(STextBlock).Text(FText::FromString("Select LuaState to Debug: "))
						]
						+ SHorizontalBox::Slot().FillWidth(0.6)
						[
							SAssignNew(LuaStatesComboBox, STextComboBox).OptionsSource(&DetectedLuaStates)
						]
				]

				+ SVerticalBox::Slot().AutoHeight()
				[
					SNew(SButton).Text(FText::FromString("Refresh")).OnClicked(this, &SLuaMachineDebugger::RefreshDebugger)
				]
				+ SVerticalBox::Slot().AutoHeight()
				[
					SNew(SButton).Text(FText::FromString("Call Unreal GC")).OnClicked(this, &SLuaMachineDebugger::CallGC)
				]
				+ SVerticalBox::Slot().AutoHeight()
				[
					SNew(SButton).Text(FText::FromString("Call Lua GC")).OnClicked(this, &SLuaMachineDebugger::CallLuaGC)
				]
				+ SVerticalBox::Slot().FillHeight(1)
				[
					SNew(SScrollBox).AllowOverscroll(EAllowOverscroll::Yes)
						+ SScrollBox::Slot()
						[
							SAssignNew(LuaTreeView, STreeView<TSharedRef<FTableViewLuaValue>>).TreeItemsSource(&LuaValues).OnGetChildren(this, &SLuaMachineDebugger::OnGetChildren).OnGenerateRow(this, &SLuaMachineDebugger::OnGenerateDebuggerRow)
						]
				]
				+ SVerticalBox::Slot().FillHeight(0.1)
				[
					SNew(SBorder).BorderBackgroundColor(FColor::White).Padding(4)
						[
							SNew(SScrollBox).AllowOverscroll(EAllowOverscroll::Yes)
								+ SScrollBox::Slot()
								[
									SAssignNew(ReferencersText, STextBlock).Text(FText::FromString(ReferencersTextContext))
								]
						]
				]
				+ SVerticalBox::Slot().VAlign(EVerticalAlignment::VAlign_Bottom).AutoHeight()
				[
					SNew(SBorder).BorderBackgroundColor(FColor::Red).Padding(4)
						[
							SAssignNew(DebugText, STextBlock).Text(FText::FromString(DebugTextContext))
						]
				]
		];
		FLuaMachineModule::Get().OnRegisteredLuaStatesChanged.AddSP(this, &SLuaMachineDebugger::OnRegisteredLuaStatesChanged);
	}

	void AddReferencedObjects(FReferenceCollector& Collector) override
	{
		Collector.AddReferencedObject(SelectedLuaState);
	}

#if ENGINE_MAJOR_VERSION > 4
	virtual FString GetReferencerName() const override
	{
		return TEXT("SLuaMachineDebugger");
	}
#endif

protected:
	TArray<TSharedRef<FTableViewLuaValue>> LuaValues;
	TSharedPtr<STreeView<TSharedRef<FTableViewLuaValue>>> LuaTreeView;
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 4
	TObjectPtr<ULuaState> SelectedLuaState;
#else
	ULuaState* SelectedLuaState;
#endif
	TArray<TSharedPtr<FString>> DetectedLuaStates;
	TSharedPtr<STextComboBox> LuaStatesComboBox;
	TSharedPtr<STextBlock> DebugText;
	FString DebugTextContext;
	TSharedPtr<STextBlock> ReferencersText;
	FString ReferencersTextContext;
};

TSharedRef<SDockTab> FLuaMachineEditorModule::CreateLuaMachineDebugger(const FSpawnTabArgs& Args)
{
	return SNew(SDockTab).TabRole(ETabRole::NomadTab)
		[
			SNew(SLuaMachineDebugger)
		];
}

void FLuaMachineEditorModule::ShutdownModule()
{
	FCoreDelegates::OnPostEngineInit.RemoveAll(this);

	// Unregister all the asset types that we registered
	if (FModuleManager::Get().IsModuleLoaded("AssetTools"))
	{
		IAssetTools& AssetTools = FModuleManager::GetModuleChecked<FAssetToolsModule>("AssetTools").Get();
		for (int32 Index = 0; Index < CreatedAssetTypeActions.Num(); ++Index)
		{
			AssetTools.UnregisterAssetTypeActions(CreatedAssetTypeActions[Index].ToSharedRef());
		}
	}
	CreatedAssetTypeActions.Empty();
}

FLuaMachineEditorModule& FLuaMachineEditorModule::Get()
{
	static FLuaMachineEditorModule* Singleton = nullptr;
	if (Singleton == nullptr)
	{
		Singleton = &FModuleManager::LoadModuleChecked<FLuaMachineEditorModule>("LuaMachineEditor");
	}
	return *Singleton;
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FLuaMachineEditorModule, LuaMachineEditor)
```

`Source/LuaMachineEditor/Private/LuaValueCustomization.cpp`:

```cpp
// Copyright 2018-2023 - Roberto De Ioris

#include "LuaValueCustomization.h"
#include "LuaMachine/Public/LuaValue.h"
#include "LuaMachine/Public/LuaComponent.h"
#include "GameFramework/Actor.h"
#include "Editor/PropertyEditor/Public/PropertyHandle.h"
#include "Editor/PropertyEditor/Public/DetailLayoutBuilder.h"
#include "Editor/PropertyEditor/Public/IDetailChildrenBuilder.h"
#include "Editor/PropertyEditor/Public/DetailWidgetRow.h"
#include "Runtime/Slate/Public/Widgets/Text/STextBlock.h"
#include "Runtime/Slate/Public/Widgets/Input/STextComboBox.h"
#include "Runtime/Engine/Classes/Engine/BlueprintGeneratedClass.h"
#include "Modules/ModuleManager.h"


void FLuaValueCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> PropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& CustomizationUtils)
{
	TSharedPtr<IPropertyHandle> LuaValueTypeProperty = PropertyHandle->GetChildHandle(FName(TEXT("Type")));

	HeaderRow.NameContent()
		[
			PropertyHandle->CreatePropertyNameWidget()
		].ValueContent()[
			LuaValueTypeProperty->CreatePropertyValueWidget()
		];
}

EVisibility FLuaValueCustomization::IsPropertyVisible(TSharedRef<IPropertyHandle> PropertyHandle, ELuaValueType WantedValueType)
{
	TSharedPtr<IPropertyHandle> LuaValueTypeProperty = PropertyHandle->GetChildHandle(FName(TEXT("Type")));
	if (!LuaValueTypeProperty.IsValid())
		return EVisibility::Hidden;

	uint8 ValueType;
	LuaValueTypeProperty->GetValue(ValueType);

	if ((ELuaValueType)ValueType == WantedValueType)
		return EVisibility::Visible;

	return EVisibility::Hidden;
}

void FLuaValueCustomization::LuaFunctionChanged(TSharedPtr<FString> Value, ESelectInfo::Type SelectionType, TSharedRef<IPropertyHandle> PropertyHandle)
{
	TArray<UObject*> Objects;
	PropertyHandle->GetOuterObjects(Objects);

	if (Objects.Num() != 1)
		return;

	UClass* ObjectClass = Objects[0]->GetClass();

	ULuaComponent* LuaComponent = Cast<ULuaComponent>(Objects[0]);
	if (LuaComponent)
	{
		AActor* Actor = LuaComponent->GetOwner();
		if (Actor)
		{
			ObjectClass = Actor->GetClass();
		}
		else
		{
			UBlueprintGeneratedClass* BlueprintClass = Cast<UBlueprintGeneratedClass>(LuaComponent->GetOuter());
			if (BlueprintClass)
			{
				ObjectClass = BlueprintClass;
			}
		}
	}


	UFunction* FoundFunction = ObjectClass->FindFunctionByName(FName(*(*Value.Get())));
	if (FoundFunction)
	{
		PropertyHandle->SetValue(FoundFunction->GetName());
	}
}

void FLuaValueCustomization::CustomizeChildren(TSharedRef<IPropertyHandle> PropertyHandle, IDetailChildrenBuilder& Builder, IPropertyTypeCustomizationUtils& CustomizationUtils)
{
	TArray<UObject*> Objects;
	PropertyHandle->GetOuterObjects(Objects);

	if (Objects.Num() != 1)
		return;

	TSharedPtr<IPropertyHandle> LuaValueBoolProperty = PropertyHandle->GetChildHandle(FName(TEXT("Bool")));
	IDetailPropertyRow& PropertyBoolRow = Builder.AddProperty(LuaValueBoolProperty.ToSharedRef());
	PropertyBoolRow.Visibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &FLuaValueCustomization::IsPropertyVisible, PropertyHandle, ELuaValueType::Bool)));

	TSharedPtr<IPropertyHandle> LuaValueStringProperty = PropertyHandle->GetChildHandle(FName(TEXT("String")));
	IDetailPropertyRow& PropertyStringRow = Builder.AddProperty(LuaValueStringProperty.ToSharedRef());
	PropertyStringRow.Visibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &FLuaValueCustomization::IsPropertyVisible, PropertyHandle, ELuaValueType::String)));

	TSharedPtr<IPropertyHandle> LuaValueIntegerProperty = PropertyHandle->GetChildHandle(FName(TEXT("Integer")));
	IDetailPropertyRow& PropertyIntegerRow = Builder.AddProperty(LuaValueIntegerProperty.ToSharedRef());
	PropertyIntegerRow.Visibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &FLuaValueCustomization::IsPropertyVisible, PropertyHandle, ELuaValueType::Integer)));

	TSharedPtr<IPropertyHandle> LuaValueNumberProperty = PropertyHandle->GetChildHandle(FName(TEXT("Number")));
	IDetailPropertyRow& PropertyNumberRow = Builder.AddProperty(LuaValueNumberProperty.ToSharedRef());
	PropertyNumberRow.Visibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &FLuaValueCustomization::IsPropertyVisible, PropertyHandle, ELuaValueType::Number)));

	TSharedPtr<IPropertyHandle> LuaValueObjectProperty = PropertyHandle->GetChildHandle(FName(TEXT("Object")));
	IDetailPropertyRow& PropertyObjectRow = Builder.AddProperty(LuaValueObjectProperty.ToSharedRef());
	PropertyObjectRow.Visibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &FLuaValueCustomization::IsPropertyVisible, PropertyHandle, ELuaValueType::UObject)));

	TSharedPtr<IPropertyHandle> LuaValueFunctionProperty = PropertyHandle->GetChildHandle(FName(TEXT("FunctionName")));

	FString CurrentFunctionName;
	LuaValueFunctionProperty->GetValue(CurrentFunctionName);

	TSharedPtr<FString> CurrentSelectedFunction;

	UClass* ObjectClass = Objects[0]->GetClass();

	bool bAllowsRawCall = false;

	ULuaComponent* LuaComponent = Cast<ULuaComponent>(Objects[0]);
	if (LuaComponent)
	{
		AActor* Actor = LuaComponent->GetOwner();
		if (Actor)
		{
			ObjectClass = Actor->GetClass();
		}
		else
		{
			UBlueprintGeneratedClass* BlueprintClass = Cast<UBlueprintGeneratedClass>(LuaComponent->GetOuter());
			if (BlueprintClass)
			{
				ObjectClass = BlueprintClass;
			}
		}
	}
	else if (ULuaState* LuaState = Cast<ULuaState>(Objects[0]))
	{
		bAllowsRawCall = LuaState->bRawLuaFunctionCall;
	}

	for (TFieldIterator<UFunction> Funcs(ObjectClass); Funcs; ++Funcs)
	{
		UFunction* Function = *Funcs;

		/*if (!Function->HasAnyFunctionFlags(EFunctionFlags::FUNC_Public))
			continue;*/

		bool bIsValid = true;

		if (!bAllowsRawCall)
		{
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
			for (TFieldIterator<FProperty> FArgs(Function); FArgs && FArgs->PropertyFlags & CPF_Parm; ++FArgs)
#else
			for (TFieldIterator<UProperty> FArgs(Function); FArgs && FArgs->PropertyFlags & CPF_Parm; ++FArgs)
#endif
			{
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
				FProperty* Prop = *FArgs;
				FStructProperty* LuaProp = CastField<FStructProperty>(Prop);
#else
				UProperty* Prop = *FArgs;
				UStructProperty* LuaProp = Cast<UStructProperty>(Prop);
#endif
				if (!LuaProp)
				{
					// check for array ?
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
					FArrayProperty* ArrayProp = CastField<FArrayProperty>(Prop);
#else
					UArrayProperty* ArrayProp = Cast<UArrayProperty>(Prop);
#endif
					if (ArrayProp)
					{
#if ENGINE_MAJOR_VERSION > 4 || ENGINE_MINOR_VERSION >= 25
						LuaProp = CastField<FStructProperty>(ArrayProp->Inner);
#else
						LuaProp = Cast<UStructProperty>(ArrayProp->Inner);
#endif
						if (!LuaProp)
						{
							bIsValid = false;
							break;
						}
					}
					else {
						bIsValid = false;
						break;
					}
				}
				if (LuaProp->Struct != FLuaValue::StaticStruct())
				{
					bIsValid = false;
					break;
				}
			}
		}

		if (!bIsValid)
		{
			continue;
		}

		TSharedPtr<FString> FunctionNameSP = MakeShareable(new FString(Function->GetName()));

		if (CurrentFunctionName == Function->GetName())
		{
			CurrentSelectedFunction = FunctionNameSP;
		}

		ValidLuaFunctions.Add(FunctionNameSP);
	}


	Builder.AddCustomRow(FText::FromString(TEXT("Function"))).ValueContent()[
		SNew(STextComboBox).OptionsSource(&ValidLuaFunctions).OnSelectionChanged_Raw(this, &FLuaValueCustomization::LuaFunctionChanged, LuaValueFunctionProperty.ToSharedRef()).InitiallySelectedItem(CurrentSelectedFunction)
	].Visibility(TAttribute<EVisibility>::Create(TAttribute<EVisibility>::FGetter::CreateRaw(this, &FLuaValueCustomization::IsPropertyVisible, PropertyHandle, ELuaValueType::UFunction)));
}
```

`Source/LuaMachineEditor/Public/LuaCodeCustomization.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Editor/PropertyEditor/Public/IDetailCustomization.h"

/**
 * 
 */

class FLuaCodeCustomization : public IDetailCustomization
{
public:
	// IDetailCustomization interface
	virtual void CustomizeDetails(IDetailLayoutBuilder& DetailBuilder) override;

	static TSharedRef<IDetailCustomization> MakeInstance()
	{
		return MakeShareable(new FLuaCodeCustomization());
	}
};


```

`Source/LuaMachineEditor/Public/LuaCodeFactory.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris
// Reimport system by yama2akira (Akira Yamamoto)

#pragma once

#include "CoreMinimal.h"
#include "Factories/Factory.h"
#include "Developer/AssetTools/Public/AssetTypeCategories.h"
#include "Runtime/Engine/Classes/Engine/Level.h"
#include "EditorReimportHandler.h"
#include "AssetTypeActions_Base.h"
#include "LuaCodeFactory.generated.h"

/**
 * 
 */
UCLASS()
class LUAMACHINEEDITOR_API ULuaCodeFactory : public UFactory, public FReimportHandler
{
	GENERATED_UCLASS_BODY()

	virtual UObject* FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn, FName CallingContext) override;
	virtual UObject* FactoryCreateBinary(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, const TCHAR* Type, const uint8*& Buffer, const uint8* BufferEnd, FFeedbackContext* Warn, bool& bOutOperationCanceled) override;
	
	virtual FText GetDisplayName() const override
	{
		return FText::FromString("Lua Code");
	}

	virtual uint32 GetMenuCategories() const override;

	virtual UObject* ImportObject(UClass* InClass, UObject* InOuter, FName InName, EObjectFlags Flags, const FString& Filename, const TCHAR* Parms, bool& OutCanceled) override
	{
		if (!Filename.IsEmpty())
		{
			CurrentFilename = Filename;
			return FactoryCreateFile(InClass, InOuter, InName, Flags, Filename, Parms, nullptr, OutCanceled);
		}

		return FactoryCreateNew(InClass, InOuter, InName, Flags, nullptr, GWarn, NAME_None);
	}

public:
	virtual bool CanReimport(UObject* Obj, TArray<FString>& OutFilenames) override;
	virtual void SetReimportPaths(UObject* Obj, const TArray<FString>& NewReimportPaths) override;
	virtual EReimportResult::Type Reimport(UObject* Obj) override;
};


/**
 * Add AssetType Actions, so it can show up in Filters, etc.
 */
class FLuaCodeAssetTypeActions : public FAssetTypeActions_Base
{
public:
	FLuaCodeAssetTypeActions( EAssetTypeCategories::Type InAssetCategory );
	// IAssetTypeActions interface
	virtual FText GetName() const override;
	virtual FColor GetTypeColor() const override;
	virtual UClass* GetSupportedClass() const override;
	//virtual bool HasActions(const TArray<UObject*>& InObjects) const override { return true; }
	//virtual void GetActions(const TArray<UObject*>& InObjects, FMenuBuilder& MenuBuilder) override;
	//virtual void OpenAssetEditor(const TArray<UObject*>& InObjects, TSharedPtr<class IToolkitHost> EditWithinLevelEditor = TSharedPtr<IToolkitHost>()) override;
	virtual uint32 GetCategories() override;
	virtual bool IsImportedAsset() const override;
	virtual void GetResolvedSourceFilePaths( const TArray<UObject*>& TypeAssets, TArray<FString>& OutSourceFilePaths ) const override;
	// End of IAssetTypeActions interface
};

```

`Source/LuaMachineEditor/Public/LuaMachineEditor.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "Runtime/Launch/Resources/Version.h"
#include "Modules/ModuleManager.h"
#include "LuaState.h"
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
#include "Styling/SlateStyle.h"
#include "Styling/SlateStyleRegistry.h"
#else
#include "SlateCore/Public/Styling/SlateStyle.h"
#endif
#include "Runtime/Slate/Public/Widgets/Docking/SDockTab.h"
#include "IAssetTools.h"
#include "IAssetTypeActions.h"
#include "AssetTypeCategories.h"

class FLuaMachineEditorModule : public IModuleInterface
{
public:
	FLuaMachineEditorModule();

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
	virtual void OnPostEngineInit();
	static FLuaMachineEditorModule& Get();

	TSharedPtr<FSlateStyleSet> GetStyleSet();

	virtual uint32 GetAssetCategory() const { return LuaMachineAssetCategoryBit; }
	void RegisterAssetTypeAction( IAssetTools& AssetTools, TSharedRef<IAssetTypeActions> Action );
private:
	TSharedPtr<FSlateStyleSet> StyleSet;
	static TSharedRef<SDockTab> CreateLuaMachineDebugger(const FSpawnTabArgs& Args); 
	EAssetTypeCategories::Type LuaMachineAssetCategoryBit;
	/** All created asset type actions.  Cached here so that we can unregister them during shutdown. */
	TArray< TSharedPtr<IAssetTypeActions> > CreatedAssetTypeActions;
};

```

`Source/LuaMachineEditor/Public/LuaValueCustomization.h`:

```h
// Copyright 2018-2023 - Roberto De Ioris

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Editor/PropertyEditor/Public/IPropertyTypeCustomization.h"
#include "Runtime/SlateCore/Public/Layout/Visibility.h"
#include "LuaMachine/Public/LuaValue.h"

class FLuaValueCustomization : public IPropertyTypeCustomization
{
public:
	// IPropertyTypeCustomization interface
	virtual void CustomizeHeader(TSharedRef<IPropertyHandle> PropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& CustomizationUtils) override;

	virtual void CustomizeChildren(TSharedRef<IPropertyHandle> PropertyHandle, IDetailChildrenBuilder& Builder, IPropertyTypeCustomizationUtils& CustomizationUtils) override;

	static TSharedRef<IPropertyTypeCustomization> MakeInstance()
	{
		return MakeShareable(new FLuaValueCustomization());
	}

	EVisibility IsPropertyVisible(TSharedRef<IPropertyHandle> PropertyHandle, ELuaValueType WantedValueType);

	void LuaFunctionChanged(TSharedPtr<FString> Value, ESelectInfo::Type SelectionType, TSharedRef<IPropertyHandle> PropertyHandle);
protected:
	TArray<TSharedPtr<FString>> ValidLuaFunctions;
};


```

`Source/ThirdParty/lua/lauxlib.h`:

```h
/*
** $Id: lauxlib.h,v 1.131.1.1 2017/04/19 17:20:42 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include <stddef.h>
#include <stdio.h>

#include "lua.h"



/* extra error code for 'luaL_loadfilex' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


/* key, in the registry, for table of loaded modules */
#define LUA_LOADED_TABLE	"_LOADED"


/* key, in the registry, for table of preloaded loaders */
#define LUA_PRELOAD_TABLE	"_PRELOAD"


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;


#define LUAL_NUMSIZES	(sizeof(lua_Integer)*16 + sizeof(lua_Number))

LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);
#define luaL_checkversion(L)  \
	  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)

LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int arg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
LUALIB_API int (luaL_execresult) (lua_State *L, int stat);

/* predefined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
                                               const char *mode);

#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)

LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
                                   const char *name, const char *mode);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);

LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);

LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);

LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);

LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
                                  const char *msg, int level);

LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
                                 lua_CFunction openf, int glb);

/*
** ===============================================================
** some useful macros
** ===============================================================
*/


#define luaL_newlibtable(L,l)	\
  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)

#define luaL_newlib(L,l)  \
  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))

#define luaL_argcheck(L, cond,arg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (arg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)


/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

typedef struct luaL_Buffer {
  char *b;  /* buffer address */
  size_t size;  /* buffer size */
  size_t n;  /* number of characters in buffer */
  lua_State *L;
  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
} luaL_Buffer;


#define luaL_addchar(B,c) \
  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
   ((B)->b[(B)->n++] = (c)))

#define luaL_addsize(B,s)	((B)->n += (s))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);

#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)

/* }====================================================== */



/*
** {======================================================
** File handles for IO library
** =======================================================
*/

/*
** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
** initial structure 'luaL_Stream' (it may contain other fields
** after that initial structure).
*/

#define LUA_FILEHANDLE          "FILE*"


typedef struct luaL_Stream {
  FILE *f;  /* stream (NULL for incompletely created streams) */
  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
} luaL_Stream;

/* }====================================================== */



/* compatibility with old module system */
#if defined(LUA_COMPAT_MODULE)

LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
                                   int sizehint);
LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);

#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))

#endif


/*
** {==================================================================
** "Abstraction Layer" for basic report of messages and errors
** ===================================================================
*/

/* print a string */
#if !defined(lua_writestring)
#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)
#endif

/* print a newline and flush the output */
#if !defined(lua_writeline)
#define lua_writeline()        (lua_writestring("\n", 1), fflush(stdout))
#endif

/* print an error message */
#if !defined(lua_writestringerror)
#define lua_writestringerror(s,p) \
        (fprintf(stderr, (s), (p)), fflush(stderr))
#endif

/* }================================================================== */


/*
** {============================================================
** Compatibility with deprecated conversions
** =============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define luaL_checkunsigned(L,a)	((lua_Unsigned)luaL_checkinteger(L,a))
#define luaL_optunsigned(L,a,d)	\
	((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))

#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))

#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#endif
/* }============================================================ */



#endif



```

`Source/ThirdParty/lua/lua.h`:

```h
/*
** $Id: lua.h,v 1.332.1.2 2018/06/13 16:58:17 roberto Exp $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include <stdarg.h>
#include <stddef.h>


#include "luaconf.h"


#define LUA_VERSION_MAJOR	"5"
#define LUA_VERSION_MINOR	"3"
#define LUA_VERSION_NUM		503
#define LUA_VERSION_RELEASE	"5"

#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2018 Lua.org, PUC-Rio"
#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"


/* mark for precompiled code ('<esc>Lua') */
#define LUA_SIGNATURE	"\x1bLua"

/* option for multiple returns in 'lua_pcall' and 'lua_call' */
#define LUA_MULTRET	(-1)


/*
** Pseudo-indices
** (-LUAI_MAXSTACK is the minimum valid index; we keep some free empty
** space after that to help overflow detection)
*/
#define LUA_REGISTRYINDEX	(-LUAI_MAXSTACK - 1000)
#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))


/* thread status */
#define LUA_OK		0
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRGCMM	5
#define LUA_ERRERR	6


typedef struct lua_State lua_State;


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8

#define LUA_NUMTAGS		9



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/* predefined values in the registry */
#define LUA_RIDX_MAINTHREAD	1
#define LUA_RIDX_GLOBALS	2
#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;

/* unsigned integer type */
typedef LUA_UNSIGNED lua_Unsigned;

/* type for continuation-function contexts */
typedef LUA_KCONTEXT lua_KContext;


/*
** Type for C functions registered with Lua
*/
typedef int (*lua_CFunction) (lua_State *L);

/*
** Type for continuation functions
*/
typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);


/*
** Type for functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);


/*
** Type for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);



/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/*
** RCS ident string
*/
extern const char lua_ident[];


/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


LUA_API const lua_Number *(lua_version) (lua_State *L);


/*
** basic stack manipulation
*/
LUA_API int   (lua_absindex) (lua_State *L, int idx);
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_rotate) (lua_State *L, int idx, int n);
LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
LUA_API int   (lua_checkstack) (lua_State *L, int n);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isinteger) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** Comparison and arithmetic functions
*/

#define LUA_OPADD	0	/* ORDER TM, ORDER OP */
#define LUA_OPSUB	1
#define LUA_OPMUL	2
#define LUA_OPMOD	3
#define LUA_OPPOW	4
#define LUA_OPDIV	5
#define LUA_OPIDIV	6
#define LUA_OPBAND	7
#define LUA_OPBOR	8
#define LUA_OPBXOR	9
#define LUA_OPSHL	10
#define LUA_OPSHR	11
#define LUA_OPUNM	12
#define LUA_OPBNOT	13

LUA_API void  (lua_arith) (lua_State *L, int op);

#define LUA_OPEQ	0
#define LUA_OPLT	1
#define LUA_OPLE	2

LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);


/*
** push functions (C -> stack)
*/
LUA_API void        (lua_pushnil) (lua_State *L);
LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);
LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API int (lua_getglobal) (lua_State *L, const char *name);
LUA_API int (lua_gettable) (lua_State *L, int idx);
LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawget) (lua_State *L, int idx);
LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);

LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API int  (lua_getuservalue) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_setglobal) (lua_State *L, const char *name);
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_setuservalue) (lua_State *L, int idx);


/*
** 'load' and 'call' functions (load and run Lua code)
*/
LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,
                           lua_KContext ctx, lua_KFunction k);
#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)

LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
                            lua_KContext ctx, lua_KFunction k);
#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)

LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                          const char *chunkname, const char *mode);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);


/*
** coroutine functions
*/
LUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,
                               lua_KFunction k);
LUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg);
LUA_API int  (lua_status)     (lua_State *L);
LUA_API int (lua_isyieldable) (lua_State *L);

#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)


/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7
#define LUA_GCISRUNNING		9

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);
LUA_API void  (lua_len)    (lua_State *L, int idx);

LUA_API size_t   (lua_stringtonumber) (lua_State *L, const char *s);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);



/*
** {==============================================================
** some useful macros
** ===============================================================
*/

#define lua_getextraspace(L)	((void *)((char *)(L) - LUA_EXTRASPACE))

#define lua_tonumber(L,i)	lua_tonumberx(L,(i),NULL)
#define lua_tointeger(L,i)	lua_tointegerx(L,(i),NULL)

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	lua_pushstring(L, "" s)

#define lua_pushglobaltable(L)  \
	((void)lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS))

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)


#define lua_insert(L,idx)	lua_rotate(L, (idx), 1)

#define lua_remove(L,idx)	(lua_rotate(L, (idx), -1), lua_pop(L, 1))

#define lua_replace(L,idx)	(lua_copy(L, -1, (idx)), lua_pop(L, 1))

/* }============================================================== */


/*
** {==============================================================
** compatibility macros for unsigned conversions
** ===============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define lua_pushunsigned(L,n)	lua_pushinteger(L, (lua_Integer)(n))
#define lua_tounsignedx(L,i,is)	((lua_Unsigned)lua_tointegerx(L,i,is))
#define lua_tounsigned(L,i)	lua_tounsignedx(L,(i),NULL)

#endif
/* }============================================================== */

/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILCALL 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debugger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);

LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
                                               int fidx2, int n2);

LUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook (lua_gethook) (lua_State *L);
LUA_API int (lua_gethookmask) (lua_State *L);
LUA_API int (lua_gethookcount) (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  unsigned char nups;	/* (u) number of upvalues */
  unsigned char nparams;/* (u) number of parameters */
  char isvararg;        /* (u) */
  char istailcall;	/* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  struct CallInfo *i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2018 Lua.org, PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

```

`Source/ThirdParty/lua/lua.hpp`:

```hpp
// lua.hpp
// Lua header files for C++
// <<extern "C">> not supplied automatically because Lua also compiles as C++

extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

```

`Source/ThirdParty/lua/luaconf.h`:

```h
/*
** $Id: luaconf.h,v 1.259.1.1 2017/04/19 17:29:57 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef luaconf_h
#define luaconf_h

#include <limits.h>
#include <stddef.h>


/*
** ===================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
** {====================================================================
** System Configuration: macros to adapt (if needed) Lua to some
** particular platform, for instance compiling it with 32-bit numbers or
** restricting it to C89.
** =====================================================================
*/

/*
@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You
** can also define LUA_32BITS in the make file, but changing here you
** ensure that all software connected to Lua will be compiled with the
** same configuration.
*/
/* #define LUA_32BITS */


/*
@@ LUA_USE_C89 controls the use of non-ISO-C89 features.
** Define it if you want Lua to avoid the use of a few C99 features
** or Windows-specific features on Windows.
*/
/* #define LUA_USE_C89 */


/*
** By default, Lua on Windows use (some) specific Windows features
*/
#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
#endif


#if defined(LUA_USE_WINDOWS)
#define LUA_DL_DLL	/* enable support for DLL */
#define LUA_USE_C89	/* broadly, Windows is C89 */
#endif


#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif


#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
#endif


/*
@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for
** C89 ('long' and 'double'); Windows always has '__int64', so it does
** not need to use this case.
*/
#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)
#define LUA_C89_NUMBERS
#endif



/*
@@ LUAI_BITSINT defines the (minimum) number of bits in an 'int'.
*/
/* avoid undefined shifts */
#if ((INT_MAX >> 15) >> 15) >= 1
#define LUAI_BITSINT	32
#else
/* 'int' always must have at least 16 bits */
#define LUAI_BITSINT	16
#endif


/*
@@ LUA_INT_TYPE defines the type for Lua integers.
@@ LUA_FLOAT_TYPE defines the type for Lua floats.
** Lua should work fine with any mix of these options (if supported
** by your C compiler). The usual configurations are 64-bit integers
** and 'double' (the default), 32-bit integers and 'float' (for
** restricted platforms), and 'long'/'double' (for C compilers not
** compliant with C99, which may not have support for 'long long').
*/

/* predefined options for LUA_INT_TYPE */
#define LUA_INT_INT		1
#define LUA_INT_LONG		2
#define LUA_INT_LONGLONG	3

/* predefined options for LUA_FLOAT_TYPE */
#define LUA_FLOAT_FLOAT		1
#define LUA_FLOAT_DOUBLE	2
#define LUA_FLOAT_LONGDOUBLE	3

#if defined(LUA_32BITS)		/* { */
/*
** 32-bit integers and 'float'
*/
#if LUAI_BITSINT >= 32  /* use 'int' if big enough */
#define LUA_INT_TYPE	LUA_INT_INT
#else  /* otherwise use 'long' */
#define LUA_INT_TYPE	LUA_INT_LONG
#endif
#define LUA_FLOAT_TYPE	LUA_FLOAT_FLOAT

#elif defined(LUA_C89_NUMBERS)	/* }{ */
/*
** largest types available for C89 ('long' and 'double')
*/
#define LUA_INT_TYPE	LUA_INT_LONG
#define LUA_FLOAT_TYPE	LUA_FLOAT_DOUBLE

#endif				/* } */


/*
** default configuration for 64-bit Lua ('long long' and 'double')
*/
#if !defined(LUA_INT_TYPE)
#define LUA_INT_TYPE	LUA_INT_LONGLONG
#endif

#if !defined(LUA_FLOAT_TYPE)
#define LUA_FLOAT_TYPE	LUA_FLOAT_DOUBLE
#endif

/* }================================================================== */




/*
** {==================================================================
** Configuration for Paths.
** ===================================================================
*/

/*
** LUA_PATH_SEP is the character that separates templates in a path.
** LUA_PATH_MARK is the string that marks the substitution points in a
** template.
** LUA_EXEC_DIR in a Windows path is replaced by the executable's
** directory.
*/
#define LUA_PATH_SEP            ";"
#define LUA_PATH_MARK           "?"
#define LUA_EXEC_DIR            "!"


/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
** Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
** C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#if defined(_WIN32)	/* { */
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\"
#define LUA_SHRDIR	"!\\..\\share\\lua\\" LUA_VDIR "\\"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" \
		LUA_SHRDIR"?.lua;" LUA_SHRDIR"?\\init.lua;" \
		".\\?.lua;" ".\\?\\init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.dll;" \
		LUA_CDIR"..\\lib\\lua\\" LUA_VDIR "\\?.dll;" \
		LUA_CDIR"loadall.dll;" ".\\?.dll"

#else			/* }{ */

#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
		"./?.lua;" "./?/init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
#endif			/* } */


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif

/* }================================================================== */


/*
** {==================================================================
** Marks for exported symbols in the C code
** ===================================================================
*/

/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all auxiliary library functions.
@@ LUAMOD_API is a mark for all standard library opening functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)	/* { */

#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
#define LUA_API __declspec(dllexport)
#else						/* }{ */
#define LUA_API __declspec(dllimport)
#endif						/* } */

#else				/* }{ */

#define LUA_API		extern

#endif				/* } */


/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API
#define LUAMOD_API	LUALIB_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
** exported to outside modules.
@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
** that are not to be exported to outside modules (LUAI_DDEF for
** definitions and LUAI_DDEC for declarations).
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library. Not all elf targets support
** this attribute. Unfortunately, gcc does not offer a way to check
** whether the target offers that support, and those without support
** give a warning about it. To avoid these warnings, change to the
** default definition.
*/
#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
    defined(__ELF__)		/* { */
#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
#else				/* }{ */
#define LUAI_FUNC	extern
#endif				/* } */

#define LUAI_DDEC	LUAI_FUNC
#define LUAI_DDEF	/* empty */

/* }================================================================== */


/*
** {==================================================================
** Compatibility with previous versions
** ===================================================================
*/

/*
@@ LUA_COMPAT_5_2 controls other macros for compatibility with Lua 5.2.
@@ LUA_COMPAT_5_1 controls other macros for compatibility with Lua 5.1.
** You can define it to get all options, or change specific options
** to fit your specific needs.
*/
#if defined(LUA_COMPAT_5_2)	/* { */

/*
@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated
** functions in the mathematical library.
*/
#define LUA_COMPAT_MATHLIB

/*
@@ LUA_COMPAT_BITLIB controls the presence of library 'bit32'.
*/
#define LUA_COMPAT_BITLIB

/*
@@ LUA_COMPAT_IPAIRS controls the effectiveness of the __ipairs metamethod.
*/
#define LUA_COMPAT_IPAIRS

/*
@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for
** manipulating other integer types (lua_pushunsigned, lua_tounsigned,
** luaL_checkint, luaL_checklong, etc.)
*/
#define LUA_COMPAT_APIINTCASTS

#endif				/* } */


#if defined(LUA_COMPAT_5_1)	/* { */

/* Incompatibilities from 5.2 -> 5.3 */
#define LUA_COMPAT_MATHLIB
#define LUA_COMPAT_APIINTCASTS

/*
@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
** You can replace it with 'table.unpack'.
*/
#define LUA_COMPAT_UNPACK

/*
@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
** You can replace it with 'package.searchers'.
*/
#define LUA_COMPAT_LOADERS

/*
@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
** You can call your C function directly (with light C functions).
*/
#define lua_cpcall(L,f,u)  \
	(lua_pushcfunction(L, (f)), \
	 lua_pushlightuserdata(L,(u)), \
	 lua_pcall(L,1,0,0))


/*
@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
** You can rewrite 'log10(x)' as 'log(x, 10)'.
*/
#define LUA_COMPAT_LOG10

/*
@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
** library. You can rewrite 'loadstring(s)' as 'load(s)'.
*/
#define LUA_COMPAT_LOADSTRING

/*
@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
*/
#define LUA_COMPAT_MAXN

/*
@@ The following macros supply trivial compatibility for some
** changes in the API. The macros themselves document how to
** change your code to avoid using them.
*/
#define lua_strlen(L,i)		lua_rawlen(L, (i))

#define lua_objlen(L,i)		lua_rawlen(L, (i))

#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)

/*
@@ LUA_COMPAT_MODULE controls compatibility with previous
** module functions 'module' (Lua) and 'luaL_register' (C).
*/
#define LUA_COMPAT_MODULE

#endif				/* } */


/*
@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a
@@ a float mark ('.0').
** This macro is not on by default even in compatibility mode,
** because this is not really an incompatibility.
*/
/* #define LUA_COMPAT_FLOATSTRING */

/* }================================================================== */



/*
** {==================================================================
** Configuration for Numbers.
** Change these definitions if no predefined LUA_FLOAT_* / LUA_INT_*
** satisfy your needs.
** ===================================================================
*/

/*
@@ LUA_NUMBER is the floating-point type used by Lua.
@@ LUAI_UACNUMBER is the result of a 'default argument promotion'
@@ over a floating number.
@@ l_mathlim(x) corrects limit name 'x' to the proper float type
** by prefixing it with one of FLT/DBL/LDBL.
@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.
@@ LUA_NUMBER_FMT is the format for writing floats.
@@ lua_number2str converts a float to a string.
@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.
@@ l_floor takes the floor of a float.
@@ lua_str2number converts a decimal numeric string to a number.
*/


/* The following definitions are good for most cases here */

#define l_floor(x)		(l_mathop(floor)(x))

#define lua_number2str(s,sz,n)  \
	l_sprintf((s), sz, LUA_NUMBER_FMT, (LUAI_UACNUMBER)(n))

/*
@@ lua_numbertointeger converts a float number to an integer, or
** returns 0 if float is not within the range of a lua_Integer.
** (The range comparisons are tricky because of rounding. The tests
** here assume a two-complement representation, where MININTEGER always
** has an exact representation as a float; MAXINTEGER may not have one,
** and therefore its conversion to float may have an ill-defined value.)
*/
#define lua_numbertointeger(n,p) \
  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \
   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \
      (*(p) = (LUA_INTEGER)(n), 1))


/* now the variable definitions */

#if LUA_FLOAT_TYPE == LUA_FLOAT_FLOAT		/* { single float */

#define LUA_NUMBER	float

#define l_mathlim(n)		(FLT_##n)

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.7g"

#define l_mathop(op)		op##f

#define lua_str2number(s,p)	strtof((s), (p))


#elif LUA_FLOAT_TYPE == LUA_FLOAT_LONGDOUBLE	/* }{ long double */

#define LUA_NUMBER	long double

#define l_mathlim(n)		(LDBL_##n)

#define LUAI_UACNUMBER	long double

#define LUA_NUMBER_FRMLEN	"L"
#define LUA_NUMBER_FMT		"%.19Lg"

#define l_mathop(op)		op##l

#define lua_str2number(s,p)	strtold((s), (p))

#elif LUA_FLOAT_TYPE == LUA_FLOAT_DOUBLE	/* }{ double */

#define LUA_NUMBER	double

#define l_mathlim(n)		(DBL_##n)

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.14g"

#define l_mathop(op)		op

#define lua_str2number(s,p)	strtod((s), (p))

#else						/* }{ */

#error "numeric float type not defined"

#endif					/* } */



/*
@@ LUA_INTEGER is the integer type used by Lua.
**
@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.
**
@@ LUAI_UACINT is the result of a 'default argument promotion'
@@ over a lUA_INTEGER.
@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.
@@ LUA_INTEGER_FMT is the format for writing integers.
@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.
@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.
@@ lua_integer2str converts an integer to a string.
*/


/* The following definitions are good for most cases here */

#define LUA_INTEGER_FMT		"%" LUA_INTEGER_FRMLEN "d"

#define LUAI_UACINT		LUA_INTEGER

#define lua_integer2str(s,sz,n)  \
	l_sprintf((s), sz, LUA_INTEGER_FMT, (LUAI_UACINT)(n))

/*
** use LUAI_UACINT here to avoid problems with promotions (which
** can turn a comparison between unsigneds into a signed comparison)
*/
#define LUA_UNSIGNED		unsigned LUAI_UACINT


/* now the variable definitions */

#if LUA_INT_TYPE == LUA_INT_INT		/* { int */

#define LUA_INTEGER		int
#define LUA_INTEGER_FRMLEN	""

#define LUA_MAXINTEGER		INT_MAX
#define LUA_MININTEGER		INT_MIN

#elif LUA_INT_TYPE == LUA_INT_LONG	/* }{ long */

#define LUA_INTEGER		long
#define LUA_INTEGER_FRMLEN	"l"

#define LUA_MAXINTEGER		LONG_MAX
#define LUA_MININTEGER		LONG_MIN

#elif LUA_INT_TYPE == LUA_INT_LONGLONG	/* }{ long long */

/* use presence of macro LLONG_MAX as proxy for C99 compliance */
#if defined(LLONG_MAX)		/* { */
/* use ISO C99 stuff */

#define LUA_INTEGER		long long
#define LUA_INTEGER_FRMLEN	"ll"

#define LUA_MAXINTEGER		LLONG_MAX
#define LUA_MININTEGER		LLONG_MIN

#elif defined(LUA_USE_WINDOWS) /* }{ */
/* in Windows, can use specific Windows types */

#define LUA_INTEGER		__int64
#define LUA_INTEGER_FRMLEN	"I64"

#define LUA_MAXINTEGER		_I64_MAX
#define LUA_MININTEGER		_I64_MIN

#else				/* }{ */

#error "Compiler does not support 'long long'. Use option '-DLUA_32BITS' \
  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)"

#endif				/* } */

#else				/* }{ */

#error "numeric integer type not defined"

#endif				/* } */

/* }================================================================== */


/*
** {==================================================================
** Dependencies with C99 and other C details
** ===================================================================
*/

/*
@@ l_sprintf is equivalent to 'snprintf' or 'sprintf' in C89.
** (All uses in Lua have only one format item.)
*/
#if !defined(LUA_USE_C89)
#define l_sprintf(s,sz,f,i)	snprintf(s,sz,f,i)
#else
#define l_sprintf(s,sz,f,i)	((void)(sz), sprintf(s,f,i))
#endif


/*
@@ lua_strx2number converts an hexadecimal numeric string to a number.
** In C99, 'strtod' does that conversion. Otherwise, you can
** leave 'lua_strx2number' undefined and Lua will provide its own
** implementation.
*/
#if !defined(LUA_USE_C89)
#define lua_strx2number(s,p)		lua_str2number(s,p)
#endif


/*
@@ lua_pointer2str converts a pointer to a readable string in a
** non-specified way.
*/
#define lua_pointer2str(buff,sz,p)	l_sprintf(buff,sz,"%p",p)


/*
@@ lua_number2strx converts a float to an hexadecimal numeric string.
** In C99, 'sprintf' (with format specifiers '%a'/'%A') does that.
** Otherwise, you can leave 'lua_number2strx' undefined and Lua will
** provide its own implementation.
*/
#if !defined(LUA_USE_C89)
#define lua_number2strx(L,b,sz,f,n)  \
	((void)L, l_sprintf(b,sz,f,(LUAI_UACNUMBER)(n)))
#endif


/*
** 'strtof' and 'opf' variants for math functions are not valid in
** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the
** availability of these variants. ('math.h' is already included in
** all files that use these macros.)
*/
#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))
#undef l_mathop  /* variants not available */
#undef lua_str2number
#define l_mathop(op)		(lua_Number)op  /* no variant */
#define lua_str2number(s,p)	((lua_Number)strtod((s), (p)))
#endif


/*
@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation
** functions.  It must be a numerical type; Lua will use 'intptr_t' if
** available, otherwise it will use 'ptrdiff_t' (the nearest thing to
** 'intptr_t' in C89)
*/
#define LUA_KCONTEXT	ptrdiff_t

#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \
    __STDC_VERSION__ >= 199901L
#include <stdint.h>
#if defined(INTPTR_MAX)  /* even in C99 this type is optional */
#undef LUA_KCONTEXT
#define LUA_KCONTEXT	intptr_t
#endif
#endif


/*
@@ lua_getlocaledecpoint gets the locale "radix character" (decimal point).
** Change that if you do not want to use C locales. (Code using this
** macro must include header 'locale.h'.)
*/
#if !defined(lua_getlocaledecpoint)
#define lua_getlocaledecpoint()		(localeconv()->decimal_point[0])
#endif

/* }================================================================== */


/*
** {==================================================================
** Language Variations
** =====================================================================
*/

/*
@@ LUA_NOCVTN2S/LUA_NOCVTS2N control how Lua performs some
** coercions. Define LUA_NOCVTN2S to turn off automatic coercion from
** numbers to strings. Define LUA_NOCVTS2N to turn off automatic
** coercion from strings to numbers.
*/
/* #define LUA_NOCVTN2S */
/* #define LUA_NOCVTS2N */


/*
@@ LUA_USE_APICHECK turns on several consistency checks on the C API.
** Define it as a help when debugging C code.
*/
#if defined(LUA_USE_APICHECK)
#include <assert.h>
#define luai_apicheck(l,e)	assert(e)
#endif

/* }================================================================== */


/*
** {==================================================================
** Macros that affect the API and must be stable (that is, must be the
** same when you compile Lua and when you compile code that links to
** Lua). You probably do not want/need to change them.
** =====================================================================
*/

/*
@@ LUAI_MAXSTACK limits the size of the Lua stack.
** CHANGE it if you need a different limit. This limit is arbitrary;
** its only purpose is to stop Lua from consuming unlimited stack
** space (and to reserve some numbers for pseudo-indices).
*/
#if LUAI_BITSINT >= 32
#define LUAI_MAXSTACK		1000000
#else
#define LUAI_MAXSTACK		15000
#endif


/*
@@ LUA_EXTRASPACE defines the size of a raw memory area associated with
** a Lua state with very fast access.
** CHANGE it if you need a different size.
*/
#define LUA_EXTRASPACE		(sizeof(void *))


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@@ of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
** CHANGE it if it uses too much C-stack space. (For long double,
** 'string.format("%.99f", -1e4932)' needs 5034 bytes, so a
** smaller buffer would force a memory allocation for each call to
** 'string.format'.)
*/
#if LUA_FLOAT_TYPE == LUA_FLOAT_LONGDOUBLE
#define LUAL_BUFFERSIZE		8192
#else
#define LUAL_BUFFERSIZE   ((int)(0x80 * sizeof(void*) * sizeof(lua_Integer)))
#endif

/* }================================================================== */


/*
@@ LUA_QL describes how error messages quote program elements.
** Lua does not use these macros anymore; they are here for
** compatibility only.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")




/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/





#endif


```

`Source/ThirdParty/lua/lualib.h`:

```h
/*
** $Id: lualib.h,v 1.45.1.1 2017/04/19 17:20:42 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include "lua.h"


/* version suffix for environment variable names */
#define LUA_VERSUFFIX          "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR


LUAMOD_API int (luaopen_base) (lua_State *L);

#define LUA_COLIBNAME	"coroutine"
LUAMOD_API int (luaopen_coroutine) (lua_State *L);

#define LUA_TABLIBNAME	"table"
LUAMOD_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	"io"
LUAMOD_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	"os"
LUAMOD_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	"string"
LUAMOD_API int (luaopen_string) (lua_State *L);

#define LUA_UTF8LIBNAME	"utf8"
LUAMOD_API int (luaopen_utf8) (lua_State *L);

#define LUA_BITLIBNAME	"bit32"
LUAMOD_API int (luaopen_bit32) (lua_State *L);

#define LUA_MATHLIBNAME	"math"
LUAMOD_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	"debug"
LUAMOD_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	"package"
LUAMOD_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L);



#if !defined(lua_assert)
#define lua_assert(x)	((void)0)
#endif


#endif

```

`Tutorials/JsonLuaBlueprintPackage.md`:

```md
```c++

#pragma once

#include "CoreMinimal.h"
#include "LuaBlueprintPackage.h"
#include "JsonLuaBlueprintPackage.generated.h"

/**
 * 
 */
UCLASS()
class RPGLUA_API UJsonLuaBlueprintPackage : public ULuaBlueprintPackage
{
	GENERATED_BODY()

public:

	UJsonLuaBlueprintPackage();

	UFUNCTION()
	FLuaValue ToJson(FLuaValue Value);

	UFUNCTION()
	FLuaValue FromJson(FLuaValue Value);
	
};

```

```c++
#include "JsonLuaBlueprintPackage.h"
#include "LuaBlueprintFunctionLibrary.h"

UJsonLuaBlueprintPackage::UJsonLuaBlueprintPackage()
{
	Table.Add("to_json", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UJsonLuaBlueprintPackage, ToJson)));
	Table.Add("from_json", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UJsonLuaBlueprintPackage, FromJson)));
}

FLuaValue UJsonLuaBlueprintPackage::FromJson(FLuaValue Value)
{
	FLuaValue ReturnValue;
	ULuaBlueprintFunctionLibrary::LuaValueFromJson(GetWorld(), GetLuaState(), Value.ToString(), ReturnValue);
	return ReturnValue;
}

FLuaValue UJsonLuaBlueprintPackage::ToJson(FLuaValue Value)
{
	return(ULuaBlueprintFunctionLibrary::LuaValueToJson(Value));
}
```

```

`Tutorials/ReflectionShell.md`:

```md
# Implementing a Lua Reflection Shell (WORK IN PROGRESS)

The main objective of the LuaMachine project is to safely expose Lua apis to scripters (and modders), so the Unreal Engine reflection system is
completely hidden by default.

If you know what you are doing, you can implement UObject's reflection easily in LuaMachine using C++.

This tutorial will show you how (with a bunch of C++ lines) you can inspect/modify UObject's at runtime (and obviously make mess everywhere).

Note: this has been tested with LuaMachine 20190122 and Unreal Engine 4.21 using the ThirdPersonCharacter template.

## Creating the LuaReflectionState

As always, we start by creating a new ULuaState. This will be the base (we will work on an inherited Blueprint class) for the Lua VM targeted at reflection.

Just create a new C++ class named 'LuaReflectionStateBase' inheriting from 'LuaState', and create a blueprint subclass of it named 'LuaReflectionState'

## Assigning a 'Lua name' to an Actor

Next step is creating a component that will automatically assign an actor to a Lua global name:

* Create a new Blueprint Class of type ActorComponent and name it 'LuaReflectionComponent'
* Add a variable of type 'class of LuaReflectionStateBase' named 'State', and assign it a default value of 'LuaReflectionState'
* Add a public variable of type 'String' (this will be the name exposed to the Lua VM)
* Finally assign the 'GetOwner()' return value to the Lua name (in the 'Begin Play' event)

Note the usage of 'Lua Create Object in State' that will enforce this LuaValue to be mapped to a specific state (this will avoid mess in case of various Lua VM running in the same process)

## Adding the Runtime Shell

Time to add the 'overlay shell' to our screen. From this Multiline Editable Text we will issue lua commands

## The core of our reflection system: adding a MetaTable to a UObject

```cpp
LuaReflectionStateBase::ULuaReflectionStateBase()
{
	Table.Add("unreal_get_name", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaReflectionStateBase, UnrealGetName)));
}
```

```cpp
FLuaValue ULuaReflectionStateBase::UnrealGetName(FLuaValue Value)
{
	if (!Value.Object)
		return FLuaValue();

	return FLuaValue(Value.Object->GetName());
}
```

```lua
local reflection = {}

function reflection:__tostring()
  return string.format('uobject: %s', unreal_get_name(self))
end

function reflection:__index(key)
  return unreal_get_property(self, key)
end

function reflection:__newindex(key, value)
  return unreal_set_property(self, key, value)
end

return reflection
```

## Getting the list of UProperties

```cpp
FLuaValue ULuaReflectionStateBase::UnrealGetProperties(FLuaValue Value)
{
	if (!Value.Object)
		return FLuaValue();

	UStruct* Class = Cast<UStruct>(Value.Object);
	if (!Class)
		Class = Value.Object->GetClass();

	FLuaValue PropertiesArray = CreateLuaTable();
	// remember that Lua starts counting from 1
	int32 Index = 1;

	for (TFieldIterator<UProperty> PropsIterator(Class); PropsIterator; ++PropsIterator)
	{
		UProperty* Property = *PropsIterator;
		PropertiesArray.SetFieldByIndex(Index++, FLuaValue(Property->GetName()));
	}

	return PropertiesArray;
}
```

Please py attention to the weird naming scheme as i am casting to UStruct but i am calling it 'Class'. This will be able to support USTRUCT's too if you want to improve the system.

Now let's test it by calling Lua's unreal_get_properties() from the Mannequin's graph:



## Getting/Setting Properties

```cpp
FLuaValue ULuaReflectionStateBase::UnrealGetProperty(FLuaValue Value, FLuaValue Name, FLuaValue Index)
{
	if (!Value.Object)
		return FLuaValue();
	
	UStruct* Class = Cast<UStruct>(Value.Object);
	if (!Class)
		Class = Value.Object->GetClass();

	UProperty* Property = Class->FindPropertyByName(Name.ToName());
	if (Property)
	{
		bool bSuccess;
		return FromUProperty(Value.Object, Property, bSuccess, Index.ToInteger());
	}

	return FLuaValue();
}

void ULuaReflectionStateBase::UnrealSetProperty(FLuaValue Value, FLuaValue Name, FLuaValue NewValue, FLuaValue Index)
{
	if (!Value.Object)
		return;

	UStruct* Class = Cast<UStruct>(Value.Object);
	if (!Class)
		Class = Value.Object->GetClass();

	UProperty* Property = Class->FindPropertyByName(Name.ToName());
	if (Property)
	{
		bool bSuccess;
		ToUProperty(Value.Object, Property, NewValue, bSuccess, Index.ToInteger());
	}
}
```


## Managing ArrayProperties

## Bonus: calling UObject's methods

```cpp
FLuaValue ULuaReflectionState::CallUObjectMethod(FLuaValue Object, FLuaValue Method, FLuaValue Args)
{
	if (Object.Type != ELuaValueType::UObject)
		return FLuaValue();

	if (Method.Type != ELuaValueType::UObject)
		return FLuaValue();

	UFunction* Function = (UFunction *)Method.Object;

	FScopeCycleCounterUObject ObjectScope(Object.Object);
	FScopeCycleCounterUObject FunctionScope(Function);

	void* Parameters = FMemory_Alloca(Function->ParmsSize);
	FMemory::Memzero(Parameters, Function->ParmsSize);

	// arguments
	if (Args.Type == ELuaValueType::Table)
	{
		int32 NArgs = 1;
		for (TFieldIterator<UProperty> FArgs(Function); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
		{
			UProperty *Prop = *FArgs;

			FLuaValue Parameter = Args.GetFieldByIndex(NArgs++);
			bool bSuccess;
			ToUProperty((UObject *)Parameters, Prop, Parameter, bSuccess);
		}
	}

	Object.Object->ProcessEvent(Function, Parameters);

	// get return value
	for (TFieldIterator<UProperty> FArgs(Function); FArgs; ++FArgs)
	{
		UProperty *Prop = *FArgs;
		if (!Prop->HasAnyPropertyFlags(CPF_ReturnParm | CPF_OutParm))
			continue;
		bool bSuccess;
		return FromUProperty((UObject *)Parameters, Prop, bSuccess);
	}

	return FLuaValue();
}
```

## Bonus: calling static methods from Blueprint Function Libraries

## Bonus: binding Lua functions to UObject's events

```cpp
void ULuaReflectionState::BindEvent(FLuaValue Object, FLuaValue Name, FLuaValue Callable)
{
	if (Object.Type != ELuaValueType::UObject)
		return;

	if (Name.Type != ELuaValueType::String)
		return;

	UStruct* Class = Cast<UStruct>(Object.Object);
	if (!Class)
		Class = Object.Object->GetClass();

	UProperty* Property = Class->FindPropertyByName(Name.ToName());
	if (Property)
	{
		UMulticastDelegateProperty* MulticastDelegateProperty = Cast<UMulticastDelegateProperty>(Property);
		if (MulticastDelegateProperty)
		{
			FMulticastScriptDelegate* MulticastDelegate = MulticastDelegateProperty->GetPropertyValuePtr_InContainer(Object.Object);
			ULuaDelegate *LuaDelegate = NewObject<ULuaDelegate>();
			LuaDelegate->SetLuaCallableAndSignature(Callable, MulticastDelegateProperty->SignatureFunction);
			FScriptDelegate Delegate;
			Delegate.BindUFunction(LuaDelegate, "LuaFakeUFunction");
			MulticastDelegate->Add(Delegate);
		}
	}
}

void ULuaDelegate::ProcessEvent(UFunction *Function, void *Parms)
{
	if (!Callable.LuaState)
		return;

	// arguments
	TArray<FLuaValue> Args;
	for (TFieldIterator<UProperty> FArgs(CallableSignature); FArgs && ((FArgs->PropertyFlags & (CPF_Parm | CPF_ReturnParm)) == CPF_Parm); ++FArgs)
	{
		UProperty *Prop = *FArgs;
		bool bSuccess;
		Args.Add(Callable.LuaState->FromUProperty((UObject *)Parms, Prop, bSuccess));
	}

	ULuaBlueprintFunctionLibrary::LuaValueCall(Callable, Args);
}

void ULuaDelegate::LuaFakeUFunction()
{

}
```

## Bonus: working with USTRUCTs

## Super Bonus: running lua scripts from the Unreal Editor



```

`Tutorials/RickAndMortyAPI.md`:

```md
# Using the HTTP + JSON Functions with RickAndMorty API

LuaMachine includes out of the box UFUNCTION's for interfacing with HTTP services.

In this tutorial we will see how to retrieve JSON data as well as raw images/textures from an HTTP service.

The objective is to build a User Widget listing all of the Rick And Morty characters available at https://rickandmortyapi.com/

![RickAndMortyAPI](RickAndMortyAPI_Data/RickAndMorty.PNG?raw=true "RickAndMortyAPI")

## Step 1: adding http_get() and from_json() lua functions

By default a LuaMachine state has no function exposed to the user/scripter. You generally want to carefully choose what to expose to the final scripter/modder, so the default behaviour
is to expose nothing (except the lua standard functions [and this is configurable too]).

We want to expose two functions: one for making http requests (we will call it http_get()) and another for converting json strings to lua tables (we will call it from_json())

Let's add a new LuaState called RickAndMortyLuaState:

![RickAndMortyNewLuaState](RickAndMortyAPI_Data/RickAndMorty001.PNG?raw=true "RickAndMortyNewLuaState")

![RickAndMortyNewLuaStateContentBrowser](RickAndMortyAPI_Data/RickAndMorty002.PNG?raw=true "RickAndMortyNewLuaStateContentBrowser")

And add a new Custom Event (note: not a plain function!) named HttpGet:

![RickAndMortyHttpGet](RickAndMortyAPI_Data/RickAndMorty003.PNG?raw=true "RickAndMortyHttpGet")

As you can see the event will trigger the HTTP request, and two additional events are generated (one for successful connection, the other for failures) mapped to lua callbacks.

Now expose the event as a lua function:

![RickAndMortyHttpGetTable](RickAndMortyAPI_Data/RickAndMorty004.PNG?raw=true "RickAndMortyHttpGetTable")

And create a Lua Code Asset for working with http_get():

```lua
http_get('https://rickandmortyapi.com/api/character',
  function(status, headers, content, data)
    print(status)
    print(content)
  end,
  function(data)
    error('unable to connect to http service')
  end
)
```

The successful callback will get status, headers, content and a context object (nil for now), while the error one will only get the context.

Now in your level blueprint add a node for calling the Lua Code Asset, play the level and check Unreal logs (they should show both http status and http response):

![RickAndMortyLevelBlueprint](RickAndMortyAPI_Data/RickAndMorty010.PNG?raw=true "RickAndMortyLevelBlueprint")

Time to add the from_json() function. This time is a standard UFUNCTION (not a custom event like http_get()):

![RickAndMortyFromJSON](RickAndMortyAPI_Data/RickAndMorty009.PNG?raw=true "RickAndMortyFromJSON")

Add from_json() to the Lua State Table and update the Lua Code Asset for parsing the json response:

```lua
http_get('https://rickandmortyapi.com/api/character',
  function(status, headers, content, data)
    print(status)
    foo = from_json(content)
  end,
  function(data)
    error('unable to connect to http service')
  end
)
```

Before hitting play again, open the Lua Machine Debugger (it is under the Window/Developer Tools menu). When the level runs hit "refresh" in the debugger and you should see the 'foo' object tree:

![RickAndMortyLuaDebugger](RickAndMortyAPI_Data/RickAndMorty005.PNG?raw=true "RickAndMortyLuaDebugger")

## Step 2: adding a LuaUserDataObject representing a RickAndMorty character

In addition to Lua native types (strings, integers, booleans, tables...), LuaMachine allows you to define new types based on UObjects.

We will now create a new Lua UserData type for representing a RickAndMorty Character:

![RickAndMortyUserData](RickAndMortyAPI_Data/RickAndMorty006.PNG?raw=true "RickAndMortyUserData")

This new UObject includes a variable named "Image" of type SlateBrush (will show the character image/texture retrieved via HTTP), a UFUNCTION SetImage (exposed as a lua method named set_image()) and 4 pure UFUNCTIONS for retrieving specific fields:


![RickAndMortyLuaUserDataObject](RickAndMortyAPI_Data/RickAndMorty012.PNG?raw=true "RickAndMortyLuaUserDataObject")

Note that you have dozens of different ways to expose the UObject fields to the other systems, adding pure functions is only one of them.
As this object needs to be accessed by the widget subsystem, this approach reduces the amount of nodes in the widget itself.

Time to add a new 'character()" function to the LuaState to create new lua userdata characters:

![RickAndMortyNewCharacter](RickAndMortyAPI_Data/RickAndMorty007.PNG?raw=true "RickAndMortyNewCharacter")

![RickAndMortyNewCharacterTable](RickAndMortyAPI_Data/RickAndMorty008.PNG?raw=true "RickAndMortyNewCharacterTable")

Time to refactor the code to create a character() for each result returned by the HTTP api and to download the images/textures by issuing another http_get() call:

```lua
http_get('https://rickandmortyapi.com/api/character',
  function(status, headers, content, data)
    if status ~= 200 then
      error('HTTP error code: ' .. status)
    end
    local response = from_json(content)
    for _, result in ipairs(response.results) do
      local new_character = character()
      new_character.name = result.name
      new_character.gender = result.gender
      new_character.status = result.status
      new_character.species = result.species
      http_get(result.image,
        function(status, headers, content, data)
          if status ~= 200 then
            error('HTTP error code for image: ' .. status)
          end
          local current_character = data
          current_character.set_image(content)
        end,
        function(data)
          error('unable to connect to http image service')
        end,
        new_character
      )
    end
  end,
  function(data)
    error('unable to connect to http service')
  end
)
```

## Step 3: creating the widgets

The Lua Virtual Machine has now a bunch of 'lua character' objects hanging around just waiting to be visualized.

Create a new User Widget containing a "List View" (the 'CharactersList' in the screenshot):

![RickAndMortyListView](RickAndMortyAPI_Data/RickAndMorty013.PNG?raw=true "RickAndMortyListView")

List Widgets require "Entry Widgets". They are UserWidget implementing the "User List Entry" interface. You can create
the Entry Widget for the List View by clicking on the "+" button of the "Entry Widget Class" property:

![RickAndMortyEntryWidget](RickAndMortyAPI_Data/RickAndMorty015.PNG?raw=true "RickAndMortyEntryWidget")

We now need to add an "Add Character" function to the main widget (not the entry widget!):

![RickAndMortyAddCharacter](RickAndMortyAPI_Data/RickAndMorty016.PNG?raw=true "RickAndMortyAddCharacter")

This function will populate the internal list of the "List View" widget, and will generate "Entry Widgets" on-demand.

We are adding the Lua UserData Objects we created before as the list item. Our next task is to view them in the "Entry Widget".

The "Entry Widget" (the one implementing the "User List Entry" interface) has one image widget and 4 text widgets, each of them exposing one of the Lua UserData Object fields:

![RickAndMortyEntryWidgetDesign](RickAndMortyAPI_Data/RickAndMorty018.PNG?raw=true "RickAndMortyEntryWidgetDesign")

In the Widget Editor Graph section add a variable of the Lua UserData Character type:

![RickAndMortyEntryWidgetLua](RickAndMortyAPI_Data/RickAndMorty021.PNG?raw=true "RickAndMortyEntryWidgetLua")

This is the object exposing values to the various sub-widgets (the image and the 4 text boxes).

Now you can configure the image widget to read the 'Image' property from the Character User Data:

![RickAndMortyEntryWidgetImage](RickAndMortyAPI_Data/RickAndMorty019.PNG?raw=true "RickAndMortyEntryWidgetImage")

And specify the "pure function" to call for each text block:

![RickAndMortyEntryWidgetTextBlock](RickAndMortyAPI_Data/RickAndMorty020.PNG?raw=true "RickAndMortyEntryWidgetTextBlock")

Once compiled, you should see in the main widget preview something like this:

![RickAndMortyWidgetPreview](RickAndMortyAPI_Data/RickAndMorty014.PNG?raw=true "RickAndMortyWidgetPreview")

Last step is setting the Lua UserData Character field in the Entry widget whenever a new Entry widget is generated by the list view (by overriding the "On Entry Initialied" event:

![RickAndMortyOnEntryInitialized](RickAndMortyAPI_Data/RickAndMorty017.PNG?raw=true "RickAndMortyOnEntryInitialized")

## Step 4: placing all together

Now we need to improve the 'character()' lua function to call the 'AddCharacter' method of the main widget. For doing this we are adding a reference to the main widget in the lua state (as a variable):

![RickAndMortyNewCharacter2](RickAndMortyAPI_Data/RickAndMorty022.PNG?raw=true "RickAndMortyNewCharacter2")

Finally, the level blueprint will be modified for generating the widget and passing its reference to the LuaState:

![RickAndMortyLevelBlueprint2](RickAndMortyAPI_Data/RickAndMorty011.PNG?raw=true "RickAndMortyLevelBlueprint2")

## Step 5: pagination
The RickAndMorty API is based on 'pages'. Currently we are only retrieving the page 1.

For each page the api exposes the info.prev and info.next fields containing the urls of the previous page (if available) and the next page (if available).

Let's refactor the code again:

```lua

function load_page_from_url(url)

  http_get(url,
    function(status, headers, content, data)
      if status ~= 200 then
        error('HTTP error code: ' .. status)
      end
      local response = from_json(content)
      prev_page_url = response.info.prev
      next_page_url = response.info.next
      for _, result in ipairs(response.results) do
        local new_character = character()
        new_character.name = result.name
        new_character.gender = result.gender
        new_character.status = result.status
        new_character.species = result.species
        http_get(result.image,
          function(status, headers, content, data)
            if status ~= 200 then
              error('HTTP error code for image: ' .. status)
            end
            local current_character = data
            current_character.set_image(content)
          end,
          function(data)
            error('unable to connect to http image service')
          end,
          new_character
        )
      end
    end,
    function(data)
      error('unable to connect to http service')
    end
  )

end

load_page_from_url('https://rickandmortyapi.com/api/character')
```

The 'load_page_from_url()' function, now takes an arbitrary url.

Let's add two buttons to the main widget and set their 'click event':

![RickAndMortyPrevNext](RickAndMortyAPI_Data/RickAndMorty023.PNG?raw=true "RickAndMortyPrevNext")

![RickAndMortyPrevNextClick](RickAndMortyAPI_Data/RickAndMorty024.PNG?raw=true "RickAndMortyPrevNextClick")

Note that we are using two different approaches: in the 'prev' case we retrieve each lua object (function and url) and then we call it. This approach is way more elegant than the 'next' one (where we simply invoke a lua string) but obviously requires more nodes.

Clicking on 'next' will show the next api page (after having cleared the list of items):

![RickAndMortyPage2](RickAndMortyAPI_Data/RickAndMorty025.PNG?raw=true "RickAndMortyPage2")

## Optional Step 6: using C++

While it is pretty easy to define lua apis from blueprints, using C++ is way faster and less verbose. This is the equivalent C++ code for the previously defined LuaState as well as the Lua UserData Object:

### RickAndMortyLuaStateBase.h
```cpp
#pragma once

#include "CoreMinimal.h"
#include "LuaState.h"
#include "RickAndMortyLuaStateBase.generated.h"

/**
 * 
 */
UCLASS()
class LUARICKANDMORTY_API URickAndMortyLuaStateBase : public ULuaState
{
	GENERATED_BODY()

public:
	URickAndMortyLuaStateBase();

	UFUNCTION()
	void HttpGet(FLuaValue Url, FLuaValue SuccessCallback, FLuaValue ErrorCallback, FLuaValue Data);
	
	UFUNCTION()
	void HttpSuccessCallback(FLuaValue Context, FLuaValue Response);

	UFUNCTION()
	void HttpErrorCallback(FLuaValue Data);

	UFUNCTION()
	bool FromJSON(FLuaValue Data, FLuaValue& Value);

	UFUNCTION()
	FLuaValue NewCharacter();
};

```

### RickAndMortyCharacterBase.h
```cpp

#pragma once

#include "CoreMinimal.h"
#include "LuaUserDataObject.h"
#include "Styling/SlateBrush.h"
#include "RickAndMortyCharacterBase.generated.h"

/**
 * 
 */
UCLASS()
class LUARICKANDMORTY_API URickAndMortyCharacterBase : public ULuaUserDataObject
{
	GENERATED_BODY()

public:
	URickAndMortyCharacterBase();

	UPROPERTY(EditAnywhere)
	FSlateBrush Image;

	UFUNCTION()
	void SetImage(FLuaValue Data);

	UFUNCTION(BlueprintCallable, BlueprintPure)
	FText GetName();

	UFUNCTION(BlueprintCallable, BlueprintPure)
	FText GetStatus();

	UFUNCTION(BlueprintCallable, BlueprintPure)
	FText GetGender();

	UFUNCTION(BlueprintCallable, BlueprintPure)
	FText GetSpecies();

};

```

### RickAndMortyLuaStateBase.cpp
```cpp

#include "RickAndMortyLuaStateBase.h"
#include "LuaBlueprintFunctionLibrary.h"
#include "RickAndMortyCharacterBase.h"

URickAndMortyLuaStateBase::URickAndMortyLuaStateBase()
{
	Table.Add("http_get", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(URickAndMortyLuaStateBase, HttpGet)));
	Table.Add("from_json", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(URickAndMortyLuaStateBase, FromJSON)));
	Table.Add("character", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(URickAndMortyLuaStateBase, NewCharacter)));
}

void URickAndMortyLuaStateBase::HttpGet(FLuaValue Url, FLuaValue SuccessCallback, FLuaValue ErrorCallback, FLuaValue Data)
{
	FLuaValue Context = CreateLuaTable();
	Context.SetFieldByIndex(1, SuccessCallback);
	Context.SetFieldByIndex(2, ErrorCallback);
	Context.SetFieldByIndex(3, Data);

	FLuaHttpResponseReceived ResponseReceived;
	ResponseReceived.BindUFunction(this, GET_FUNCTION_NAME_CHECKED(URickAndMortyLuaStateBase, HttpSuccessCallback));

	FLuaHttpError ErrorReceived;
	ErrorReceived.BindUFunction(this, GET_FUNCTION_NAME_CHECKED(URickAndMortyLuaStateBase, HttpErrorCallback));

	ULuaBlueprintFunctionLibrary::LuaHttpRequest(GetWorld(), GetClass(), "GET", Url.ToString(), TMap<FString, FString>(), FLuaValue(), Context, ResponseReceived, ErrorReceived);
}

void URickAndMortyLuaStateBase::HttpSuccessCallback(FLuaValue Context, FLuaValue Response)
{
	FLuaValue Callback = Context.GetFieldByIndex(1);
	FLuaValue StatusCode = Response.GetFieldByIndex(1);
	FLuaValue Headers = Response.GetFieldByIndex(2);
	FLuaValue Content = Response.GetFieldByIndex(3);
	TArray<FLuaValue> Args = { StatusCode, Headers, Content, Context.GetFieldByIndex(3) };
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(Callback, Args);
}

void URickAndMortyLuaStateBase::HttpErrorCallback(FLuaValue Data)
{
	FLuaValue Callback = Data.GetFieldByIndex(2);
	TArray<FLuaValue> Args = { Data.GetFieldByIndex(3) };
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(Callback, Args);
}

bool URickAndMortyLuaStateBase::FromJSON(FLuaValue Data, FLuaValue& Value)
{
	return ULuaBlueprintFunctionLibrary::LuaValueFromJson(GetWorld(), GetClass(), Data.ToString(), Value);
}

FLuaValue URickAndMortyLuaStateBase::NewCharacter()
{
	return NewLuaUserDataObject(URickAndMortyCharacterBase::StaticClass());
}
```

### RickAndMortyCharacterBase.cpp
```cpp

#include "RickAndMortyCharacterBase.h"
#include "LuaBlueprintFunctionLibrary.h"
#include "Engine/Texture2D.h"

URickAndMortyCharacterBase::URickAndMortyCharacterBase()
{
	Table.Add("set_image", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(URickAndMortyCharacterBase, SetImage)));
}

void URickAndMortyCharacterBase::SetImage(FLuaValue Data)
{
	UTexture2D* Texture = ULuaBlueprintFunctionLibrary::LuaValueToTransientTexture(0, 0, Data, PF_B8G8R8A8, true);
	if (Texture)
	{
		Image.DrawAs = ESlateBrushDrawType::Image;
		Image.ImageSize = FVector2D(200, 200);
		Image.SetResourceObject(Texture);
	}
}

FText URickAndMortyCharacterBase::GetName()
{
	return FText::FromString(LuaGetField("name").ToString());
}

FText URickAndMortyCharacterBase::GetGender()
{
	return FText::FromString(LuaGetField("gender").ToString());
}

FText URickAndMortyCharacterBase::GetSpecies()
{
	return FText::FromString(LuaGetField("species").ToString());
}

FText URickAndMortyCharacterBase::GetStatus()
{
	return FText::FromString(LuaGetField("status").ToString());
}
```

```

`Tutorials/SimpleDialogueSystem.md`:

```md
# A simple Dialogue System with LuaMachine

In this tutorial we will see how to use the LuaMachine plugin to create a dialogue system (versatile enough to implement a shop/inventory too) controlled by Lua scripts.

![Intro](SimpleDialogueSystem_Data/Intro.PNG?raw=true "Intro")

The Lua scripts will be part of the final build (they will be cooked in the pak file as bytecode) so you will not be able to change them after the game is packaged (check the 'Variations' section at the end of the tutorial for alternative approaches like using normal scripts in the filesystem).

The tutorial has been tested on Unreal Engine 4.21 and LuaMachine 20181230 starting from the 'Third Person' Blueprint Template.

Blueprints will be used for the whole tutorial, at the end of the page you will find a C++ implementation too.

## Installing the LuaMachine plugin

Download the latest zip file for your specific Unreal Engine version and operating system from the releases page: (https://github.com/rdeioris/LuaMachine/releases) and unzip it into the Plugins/ directory of your project (create it if it does not exist).

Restart Unreal Engine, and create the LuaState for our dialogue system:

* add new Blueprint Class
* select 'LuaState' from 'all classes'
* name it 'DialogueLuaState'

![DialogueLuaState](SimpleDialogueSystem_Data/DialogueLuaState.PNG?raw=true "DialogueLuaState")

A LuaState represents a specific Lua virtual machine (there can be multiple isolated Lua virtual machines in the same project).

For this project we need a single LuaState.

## The Talking Character

For the 'talking characters' (actors implementing dialogues in Lua) we will use the 'Twinblast' asset from Paragon.

![Twinblast](SimpleDialogueSystem_Data/Twinblast.PNG?raw=true "Twinblast")

It is a perfect choice as it includes facial morph targets that will give more emphasis to the dialogues by visually reporting emotional states.

![ContentBrowser](SimpleDialogueSystem_Data/ContentBrowser.PNG?raw=true "ContentBrowser")

Create a new Character Blueprint and add a camera component pointing to the face of Twinblast, a Sphere Collider for detecting when the player is near enough, a Text Render for simple in-world messages and (obviously) a LuaComponent.

Finally, add a variable of type 'LuaValue' named 'TalkingTable' (i will explain it later)

![TalkingCharacter](SimpleDialogueSystem_Data/TalkingCharacter.PNG?raw=true "TalkingCharacter")

The camera will be useful if you want to point to the face of the character during a dialogue (you will control the camera switch from lua).

Remember to assign an animation to the Mesh component to avoid Twinblast to be in 'A pose' while speaking (my choice is Idle_Relaxed)

## Preparing the DialogueLuaState

To allow the TalkingCharacter to be governed by Lua, we need to setup a new Lua virtual machine exposing a bunch of Unreal functions to Lua scripts. To accomplish this, we need to add Unreal/Blueprint functions to the DialogueLuaState class and expose them in the Table property of the LuaState.

We start with a simple 'Print' function that we will expose as the lua 'print' (overriding the default one), a 'Quit' function ending the game exposed as 'quit' and a LuaError event that will be triggered automatically when a Lua call fails:

![PrintAndLuaError](SimpleDialogueSystem_Data/PrintAndLuaError.PNG?raw=true "PrintAndLuaError")

Note that 'Print' expects a LuaValue argument (named 'Message', check it at the right of the screenshot). The only allowed parameters type (included the return value) is the LuaValue one. Functions violating this rule will not be selectable in the interface.

Once defined you can expose them using the 'Table' property of the LuaState (you can access it using the 'Class Defaults' button:

![LuaStateTable1](SimpleDialogueSystem_Data/LuaStateTable1.PNG?raw=true "LuaStateTable1")

## The first script

Create a new LuaCode asset in your Content Browser (it is under the 'Miscellaneous' group) and insert the following code:

```lua
local character = {}

function character:begin_play()
  print('Hello World')
end

return character
```

You should get something very similar: (note syntax highlight ;)

![CodeAsset](SimpleDialogueSystem_Data/CodeAsset.PNG?raw=true "CodeAsset")

![TalkingScript](SimpleDialogueSystem_Data/TalkingScript.PNG?raw=true "TalkingScript")

Now setup the TalkingCharacter Event Graph to load and execute the specific CodeAsset on BeginPlay event and to call the character:begin_play function (note the colon syntactic sugar to allow the Lua vm to automatically includes a 'self' variable mapped to the LuaComponent, more on this later)

![BeginPlay](SimpleDialogueSystem_Data/BeginPlay.PNG?raw=true "BeginPlay")

The 'LuaRunCodeAsset' node will load and execute a LuaCode asset and will store its return value (the 'character' local table) in the TalkingTable variable (we created it earlier).

We can use this variable for the whole lifecycle of the TalkingCharacter to call the functions exposed by the lua table mapped to it (only begin_play() for now).

Pay attention to the 'State' parameter of 'LuaRunCodeAsset' as you must set it to 'DialogueLuaState'.

Finally, the 'LuaCallTableKey' node (exposed by the LuaComponent) will check if the passed table exposes the specified 'Key' and, if it is a function, will call it.

Note that nodes exposed by the LuaComponent will automatically pass the LuaComponent itself as the first argument of called functions. As we are using the 'table:function' syntax in our script, we will get this parameter in the 'self' variable automagically. We will use the 'self' variable later in the tutorial.

Drag the TalkingCharacter blueprint to the Level and hit Play.

If all goes well you should get a 'Hello World' message on screen.

## More Unreal Engine events with Lua

Time to implement overlapping events for the sphere collider as well as a custom 'Speak' event that will be triggered by the player when wanting to talk to a specific 'TalkingCharacter':

```lua
local character = {}

function character:begin_play()
  print('Hello World')
end

function character:begin_overlap(other)
  print('Begin Overlap')
end

function character:end_overlap(other)
  print('End Overlap')
end

function character:speak()
  print('Speaking...')
end

return character
```

Add the new events to the TalkingCharacter's Event Graph (pay attention to the overlapping events as they must be related to the sphere, not the capsule of the character):

![Overlap](SimpleDialogueSystem_Data/Overlap.PNG?raw=true "Overlap")

Note that the overlapping actor is passed as the first argument of the Lua function

'Speak' is a custom event:

![Speak](SimpleDialogueSystem_Data/Speak.PNG?raw=true "Speak")

Re-Play and try to overlap the TalkingCharacter Sphere with the Mannequin, if all goes well you should see 'Begin Overlap' printed when the player is near the TalkingCharacter and 'End Overlap' printed when the player is far from it.

## Dealing with multiple TalkingCharacters and checking which actor is overlapping

Our game could include dozens of characters or objects overlapping the collision sphere of the TalkingCharacter. For this reason
we need a way to check that the overlapping actor is the player pawn.

As getting the player pawn from Lua is a pretty handy function, very probably the best thing to do is exposing it as a global Lua function in the same way we exposed 'print':

![GetPlayer](SimpleDialogueSystem_Data/GetPlayer.PNG?raw=true "GetPlayer")

![LuaStateTable2](SimpleDialogueSystem_Data/LuaStateTable2.PNG?raw=true "LuaStateTable2")

Now we can simply do a comparison in the begin_overlap/end_overlap functions:

```lua
function character:begin_overlap(other)
  if get_player() == other then
    print('Begin Overlap')
  end
end

function character:end_overlap(other)
  if get_player() == other then
    print('End Overlap')
  end
end
```

Hit Play again and check if the overlap system still works (if you want, try placing other overlapping objects in the level to check the comparison works correctly)

As said before, multiple TalkingCharacter's could be spawned in the level, so we need a way to 'mark' which one is the currently focused character, both visually and from the Lua point of view.

Let's start with the visual part: we want to set a message (from Lua) in the TextRender component of the TalkingCharacter.

This is a function specific of the TalkingCharacter so we should expose it in its LuaComponent (we can access it using the automagic 'self' table)

Add the function to the TalkingCharacter Blueprint

![SetFlash](SimpleDialogueSystem_Data/SetFlash.PNG?raw=true "SetFlash")

And expose it to Lua (select the LuaComponent to access the properties in the Details panel)

![SetFlashExposed](SimpleDialogueSystem_Data/SetFlashExposed.PNG?raw=true "SetFlashExposed")

Update the code again:

```lua

function character:begin_play()
  -- ensure the TextRender content is empty
  self.flash('')
end

function character:begin_overlap(other)
  if get_player() == other then
    self.flash('Speak with Twinblast')
  end
end

function character:end_overlap(other)
  if get_player() == other then
    self.flash('')
  end
end
```

Play and check if the TextRender component activates itself when you are near the TalkingCharacter and disappears when you move away:

![SpeakWithTwinblast](SimpleDialogueSystem_Data/SpeakWithTwinblast.PNG?raw=true "SpeakWithTwinblast")

To set which one is the currently 'focused' TalkingCharacter we will use a global Lua variable. We can just set it in the DialogueLuaState Table (and set/unset it in the begin_overlap/end_overlap functions of the TalkingCharacter script).

![CurrentTarget](SimpleDialogueSystem_Data/CurrentTarget.PNG?raw=true "CurrentTarget")

Note that we want to store the Actor reference of the TalkingCharacter in the lua variable, but the 'self' table maps to the LuaComponent object. We can add a field to the 'self' table exposing the component's owner (the Actor) value:

![Owner](SimpleDialogueSystem_Data/Owner.PNG?raw=true "Owner")

The 'owner' field is now added to the LuaComponent's lua table (the one you get via 'self')

This is the updated script:

```lua
function character:begin_overlap(other)
  if get_player() == other then
    self.flash('Speak with Twinblast')
    current_target = self.owner
  end
end

function character:end_overlap(other)
  if get_player() == other then
    self.flash('')
    current_target = nil
  end
end
```

## Triggering the 'Speak' event

When a TalkingCharacter is highlighted/targeted we want to trigger its 'Speak' event by clicking the left mouse button. To accomplish
this we can manage the mouse click in the ThirdPersonCharacter Blueprint (would be the most logical choice), but to avoid clobbering the template blueprint we will use the Level Blueprint instead (suboptimal but it should work flawlessly):

![LevelBlueprint](SimpleDialogueSystem_Data/LevelBlueprint.PNG?raw=true "LevelBlueprint")

Play again, and if you click the left mouse button wile the TalkingCharacter is the current target, its 'speak' function will be called.

## Showing dialogues and choices

We are at the core of the tutorial: showing dialogues with questions/choices.

We need two widgets: one for the dialogue text (a simple big multiline text box) and another one for questions/choices/answers (a simple text button triggering a Lua function when clicked)

Let's start with the DialogueQuestion Widget:

![DialogueQuestionDesigner](SimpleDialogueSystem_Data/DialogueQuestionDesigner.PNG?raw=true "DialogueQuestionDesigner")

![DialogueQuestionGraph](SimpleDialogueSystem_Data/DialogueQuestionGraph.PNG?raw=true "DialogueQuestionGraph")

We have a widget with a button and a text (note: no canvas panel is required, you can remove it).

The QuestionTable variable is a LuaValue marked as 'Expose on Spawn'. To generate a question widget we need to pass it a lua table (well an array) composed of 2 items: the first one is the content of the button text, the second is a lua function triggered when the user click on the question/choice/answer (spoiler: the 'Question' name is probably not a good choice as no questions will be generated in the examples, only answers and choices :( )

Now the DialogueScreen Widget:

![DialogueScreenDesigner](SimpleDialogueSystem_Data/DialogueScreenDesigner.PNG?raw=true "DialogueScreenDesigner")

![DialogueScreenGraph](SimpleDialogueSystem_Data/DialogueScreenGraph.PNG?raw=true "DialogueScreenGraph")

This widget requires two 'Expose on Spawn' variables (again LuaValue's). The first one is the content of the Multiline TextBox (note: it is marked as readonly in the properties), the second one is a table (well an array again) with the list of questions/answers/choices from which the various DialogueQuestion Widgets will be generated.

To allow Lua opening and closing the dialogue widgets we need to expose two new functions:

![OpenDialogue](SimpleDialogueSystem_Data/OpenDialogue.PNG?raw=true "OpenDialogue")

(Note: you need to add the variable 'CurrentDialogueScreen' as a DialogueScreen Widget reference)

![CloseDialogue](SimpleDialogueSystem_Data/CloseDialogue.PNG?raw=true "CloseDialogue")

![LuaStateTable3](SimpleDialogueSystem_Data/LuaStateTable3.PNG?raw=true "LuaStateTable3")

We can now update the code to manage the dialogues when the 'Speak' event is triggered

```lua
function character:speak()

  function page1()
    open_dialogue('Go to page 2?', {
      {'Yes', page2},
      {'No', close_dialogue},
    })  
  end

  function page2()
    open_dialogue('Back to page 1?', {
      {'Yes', page1},
      {'No', close_dialogue},
      {'Go to page 3, please...', page3}
    }) 
  end

  function page3()
    open_dialogue([[
This is the last page,
What do you want to do ?
    ]], {
      {'Quit Game', quit},
      {'Close Dialogue', close_dialogue},      
    })
  end

  -- called by the 'Speak' event
  page1()
end
```

Note that the open/close dialogue logic implemented in the Blueprint will prevent multiple dialogues from opening concurrently. This will simplify scripting too as we just need to call
open_dialogue() again from the callback to change the content.

If all goes well you should end with something very similar:

![Page2](SimpleDialogueSystem_Data/Page2.PNG?raw=true "Page2")

## More Lua functions: change the current camera and Character's face

We will add two more blueprint functions to the TalkingCharacter Blueprint (remember to expose them the to the Table property of the LuaComponent)

![SetCamera](SimpleDialogueSystem_Data/SetCamera.PNG?raw=true "SetCamera")

![SetFace](SimpleDialogueSystem_Data/SetFace.PNG?raw=true "SetFace")

Now refactor the code to change the camera when starting a dialogue session and resetting it when exiting:

```lua
function character:speak()

  -- set camera to the character's one
  self.set_camera(self.owner)

  -- implement a close callback that will reset both camera and face
  function close()
    close_dialogue()
    -- we can use self here as we are in a closure
    self.set_camera(get_player())
    self.set_face(0.0)
  end

  function page1()
    open_dialogue('Go to page 2?', {
      {'Yes', page2},
      {'No', close},
    })  
  end

  function page2()
    open_dialogue('Back to page 1?', {
      {'Yes', page1},
      {'No', close},
      {'Go to page 3, please...', page3}
    }) 
  end

  function page3()
    self.set_face(1.0)
    open_dialogue([[
This is the last page,
What do you want to do ?
    ]], {
      {'Quit Game', quit},
      {'Close Dialogue', close},      
    })
  end

  -- called by the 'Speak' event
  page1()
end
```

When going to page3 the facial expression of Twinblast should change to the 'angry' one:

![Page3](SimpleDialogueSystem_Data/Page3.PNG?raw=true "Page3")

Challenge: improve the set_camera() function to allow for custom blend time specified from Lua.

Note: is it better to place set_camera() as a global function in the DialogueLuaState ?

## More Talking Characters

We can now refactor the TalkingCharacter Blueprint to allow to map a different script to each instance:

![MultipleCharacters](SimpleDialogueSystem_Data/MultipleCharacters.PNG?raw=true "MultipleCharacters")

Just create two more simple scripts (you are not required to implement all the events):

```lua
local character = {}

function character:begin_play()
  self.flash('I am another begin_play() function...')
end

return character
```

```lua
local character = {}

function character:begin_play()
  self.flash('Too far to see my name...')
  self.set_face(1.0)
end

return character
```

![ThreeScripts](SimpleDialogueSystem_Data/ThreeScripts.PNG?raw=true "ThreeScripts")

## Inventory/Shop system

We can easily implement shops/inventories:

```lua
local merchant = {}

merchant.shop_sign = string.format('Shop managed by %s', _VERSION)

merchant.items = {'Shotgun', 'Grenade', 'Guns', 'LaserGun', 'Bazooka'}

function merchant:begin_play()
  self.flash(merchant.shop_sign)
end

function merchant:begin_overlap(other)
  if get_player() == other then
    self.flash('Buy something')
    current_target = self.owner
  end
end

function merchant:end_overlap(other)
  if get_player() == other then
    self.flash(merchant.shop_sign)
    current_target = nil
  end
end

function merchant:speak()

  -- reset when closing the shop
  function close()
    self.set_camera(get_player())
    close_dialogue()
  end

  -- special closure for generating a callback with the index of the item to buy
  function buy(index)
    return function()
        table.remove(merchant.items, index)
        show_items()
    end
  end

  function show_items()
    self.set_camera(self.owner)

    -- build the list of items (and the related callbacks)
    local items = {}
    for k,v in pairs(merchant.items) do
      -- v is the item name, k is its index (we use it as in lua we can only remove efficiently by index)
      table.insert(items, {'Buy ' .. v, buy(k)})
    end
    table.insert(items, {'Nothing, Thanks', close})

    open_dialogue('Welcome to my humble shop', items)
  end

  -- triggered by 'Speak' event
  show_items()
end

return merchant
```

![Shop](SimpleDialogueSystem_Data/Shop.PNG?raw=true "Shop")

Let's improve it by adding the 'gold/money' concept:

First, add a player_gold Integer item in the Table of the DialogueLuaState and set to something like '4'. In this
way the merchant will be able to access the amount of player gold.

```lua
local merchant = {}

merchant.shop_sign = string.format('Shop managed by %s', _VERSION)

merchant.items = {'Shotgun', 'Grenade', 'Guns', 'LaserGun', 'Bazooka'}

-- increases whenever the merchant sells something
merchant.gold = 0

function merchant:begin_play()
  self.flash(merchant.shop_sign)
end

function merchant:begin_overlap(other)
  if get_player() == other then
    self.flash('Buy something')
    current_target = self.owner
  end
end

function merchant:end_overlap(other)
  if get_player() == other then
    self.flash(merchant.shop_sign)
    current_target = nil
  end
end

function merchant:speak()

  -- reset when closing the shop
  function close()
    self.set_camera(get_player())
    close_dialogue()
  end

  -- special closure for generating a callback with the index of the item to buy
  function buy(index)
    return function()
        if player_gold <= 0 then
          open_dialogue('Not enough gold', {{'Sorry', show_items}})
        else
          table.remove(merchant.items, index)
          merchant.gold = merchant.gold + 1
          player_gold = player_gold - 1
          show_items()
        end
    end
  end

  function show_items()
    self.set_camera(self.owner)

    -- build the list of items (and the related callbacks)
    local items = {}
    for k,v in pairs(merchant.items) do
      -- v is the item name, k is its index (we use it as in lua we can only remove efficiently by index)
      table.insert(items, {'Buy ' .. v, buy(k)})
    end
    table.insert(items, {'Nothing, Thanks', close})

    open_dialogue([[Welcome to my humble shop,
      You have ]] .. player_gold .. ' gold', items)
  end

  -- triggered by 'Speak' event
  show_items()
end

return merchant
```

## Cooking and Packaging

One of the advantages of using LuaCode assets, is that they will be built as normal assets and they will be converted to bytecode by default. The cooking system is smart enough to adapt the bytecode even if you want to build the project for systems (like android) having low level differences (that would break on bytecode generated on another system).

## Variations

The tutorial aims at showing a simple approach, but you can obviously using various techniques. The following variations could be of interest:

### From LuaCode Asset to filesystem-based scripts

If you want to allow the user to modify/hack your game after it has been built, you can use normal filesystem-based lua scripts.

Just place them in the Content directory (it is added by default to the Lua package search path) and change the TalkingCharacter Blueprint to use the filename as the source script:

![FromFile](SimpleDialogueSystem_Data/FromFile.PNG?raw=true "FromFile")

Eventually you can use both (to allow some form of modding):

![Modding](SimpleDialogueSystem_Data/Modding.PNG?raw=true "Modding")

We first check for a Lua file, if it is not available (returns nil in such a case), we use the LuaCode asset.

### Using C++ instead of Blueprint Nodes

Instead of exposing Blueprint functions to Lua, you can expose Cpp functions.

This is the code for a CppDialogueLuaState class that you can use in place of the DialogueLuaState one:

```cpp
#pragma once

#include "CoreMinimal.h"
#include "LuaState.h"
#include "CppDialogueLuaState.generated.h"

/**
 * 
 */
UCLASS()
class TUTORIALLUADIALOGUE_API UCppDialogueLuaState : public ULuaState
{
	GENERATED_BODY()

public:
	UCppDialogueLuaState();

	UFUNCTION()
	FLuaValue GetPlayer();

	UFUNCTION()
	void Quit();

	UFUNCTION()
	void Print(FLuaValue Message);
	
};
```

```cpp
#include "CppDialogueLuaState.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"
#include "GameFramework/Pawn.h"
#include "Engine/GameEngine.h"

UCppDialogueLuaState::UCppDialogueLuaState()
{
	Table.Add("get_player", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UCppDialogueLuaState, GetPlayer)));
	Table.Add("quit", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UCppDialogueLuaState, Quit)));
	Table.Add("print", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UCppDialogueLuaState, Print)));

	Table.Add("current_target", FLuaValue());
	Table.Add("player_gold", FLuaValue(4));
}

FLuaValue UCppDialogueLuaState::GetPlayer()
{
	APlayerController* PlayerController = GetWorld()->GetFirstPlayerController();
	return PlayerController ? FLuaValue(PlayerController->GetPawn()) : FLuaValue();
}

void UCppDialogueLuaState::Quit()
{
	APlayerController* PlayerController = GetWorld()->GetFirstPlayerController();
	if (PlayerController)
	{
		PlayerController->ConsoleCommand("quit");
	}
}

void UCppDialogueLuaState::Print(FLuaValue Message)
{
	GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Cyan, *Message.ToString());
}

```

```

`Tutorials/WebSocketsWithLuaUserDataObjects.md`:

```md
# Implementing a WebSockets API using LuaUserDataObjects

## LuaUserDataObjects ?

The 'ULuaUserDataObject' UCLASS allows you to create new kinds of LuaValues built over the UObject system.

In addition to 'primitive' types (string, boolean, numbers, tables ...) Lua allows for so called "userdata". At the lowest level they are pointers to custom data with (eventually) a metatable
attached to them. Having a metatable allows them to expose parameters/methods like normal tables.

If you want to expose methods or attributes for LuaValues wrapping UObjects, you can create a new Unreal Engine UCLASS (Blueprint or C++) inheriting from ULuaUserDataObject and add items to its Table and Metatable properties
(like with LuaStates, LuaBlueprintPackages and LuaComponents).


The following code shows what we are trying to accomplish:

```lua
local ws = websocket()

-- internally print() will call the __tostring metamethod of the ws object
print(ws)

-- this will be called whenever a new message is received
function ws:on_message(message)
  print(message)
  --ws:close(17, 'End of the World')
end

-- this is called on connection close
function ws:on_closed(code, reason, user)
  print('websocket connection closed: ' .. reason)
end

-- the first function/callback is called on successful connection
-- the second one on failure
ws:connect('wss://echo.websocket.org', function(self)
  print('connected')
  print(self)
end, function(self, reason)
  print('unable to connect: ' .. reason)
end)

-- this can be called from any part of your project to trigger sending of messages
function send_event(message)
  print('sending...')
  ws:send(message)
end
```

'Note' that is not responsibility of the Lua VM to manage the lifetime of the associated ULuaUserDataObject: if the Unreal Garbage Collector frees it, the FLuaValue will become nil.

## The ULuaWebSocketConnection UCLASS

The objective is to define a new lua type representing a WebSocket connection to a url exposing a bunch of methods (connect, disconnect, send and close) and attributes/callbacks (on_message, on_closed).

We start by subclassing UluaUserDataObject: 

```c++
#pragma once

#include "CoreMinimal.h"
#include "LuaUserDataObject.h"
#include "IWebSocket.h"
#include "LuaWebsocketConnection.generated.h"

/**
 * 
 */
UCLASS()
class RPGLUA_API ULuaWebsocketConnection : public ULuaUserDataObject
{
	GENERATED_BODY()

public:
	ULuaWebsocketConnection();
	~ULuaWebsocketConnection();

	UFUNCTION()
	void Connect(FLuaValue Url, FLuaValue InOnConnectedCallback, FLuaValue InOnConnectionErrorCallback);

	UFUNCTION()
	void Disconnect();

	UFUNCTION()
	void Send(FLuaValue Message);

	UFUNCTION()
	FLuaValue ToLuaString();

	UFUNCTION()
	void Close(FLuaValue Code, FLuaValue Reason);

protected:
	TSharedPtr<IWebSocket> WebSocketConnection;
	TSharedPtr<FLuaSmartReference> OnConnectedCallback;
	TSharedPtr<FLuaSmartReference> OnConnectionErrorCallback;

	void OnMessageDelegate(const FString& Message);
	void OnClosedDelegate(int32 Code, const FString& Reason, bool bUserClose);

	void OnConnectedDelegate(TWeakPtr<FLuaSmartReference> OnConnectedCallbackRef);
	void OnConnectionErrorDelegate(const FString& Message, TWeakPtr<FLuaSmartReference> OnConnectionErrorCallbackRef);

	FString CurrentUrl;
};
```

The 4 UFUNCTIONs will be exposed as lua functions (see the constructor below) while the two `TSharedPtr<FLuaSmartReference>` members are required for the OnConnectedDelegate and OnConnectionErrorDelegate functions.

Delegates can be triggered at any moment, even after the related FLuaValues (callback/functions) are destroyed. The FLuaSmartReference object allows you to link a LuaValue to a LuaState, avoiding it to be garbaged (note: remember to unlink them !).

The OnMessageDelegate and OnClosedDelegate do not require a FLuaSmartReference as they are based on attributes of the object itself (see ws:on_message() and ws:on_closed() functions defined in the previous lua code).

Time for functions definitions:

```c++
#include "LuaWebsocketConnection.h"
#include "LuaBlueprintFunctionLibrary.h"
#include "WebSocketsModule.h"

ULuaWebsocketConnection::ULuaWebsocketConnection()
{
	Table.Add("connect", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaWebsocketConnection, Connect)));
	Table.Add("disconnect", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaWebsocketConnection, Disconnect)));
	Table.Add("send", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaWebsocketConnection, Send)));
	Table.Add("close", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaWebsocketConnection, Close)));

	Metatable.Add("__tostring", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(ULuaWebsocketConnection, ToLuaString)));

	bImplicitSelf = true;
}

ULuaWebsocketConnection::~ULuaWebsocketConnection()
{
	Disconnect();
	UE_LOG(LogLuaMachine, Log, TEXT("Websocket Destroyed"));
}

void ULuaWebsocketConnection::Connect(FLuaValue Url, FLuaValue InOnConnectedCallback, FLuaValue InOnConnectionErrorCallback)
{
	Disconnect();

	CurrentUrl = Url.ToString();

	WebSocketConnection = FWebSocketsModule::Get().CreateWebSocket(Url.ToString(), TEXT("ws"));
	WebSocketConnection->OnMessage().AddUObject(this, &ULuaWebsocketConnection::OnMessageDelegate);
	WebSocketConnection->OnClosed().AddUObject(this, &ULuaWebsocketConnection::OnClosedDelegate);

	OnConnectedCallback = AddLuaSmartReference(InOnConnectedCallback);
	OnConnectionErrorCallback = AddLuaSmartReference(InOnConnectionErrorCallback);

	WebSocketConnection->OnConnectionError().AddUObject(this, &ULuaWebsocketConnection::OnConnectionErrorDelegate, TWeakPtr<FLuaSmartReference>(OnConnectionErrorCallback));
	WebSocketConnection->OnConnected().AddUObject(this, &ULuaWebsocketConnection::OnConnectedDelegate, TWeakPtr<FLuaSmartReference>(OnConnectedCallback));
	WebSocketConnection->Connect();
}

void ULuaWebsocketConnection::Disconnect()
{
	OnConnectedCallback.Reset();
	OnConnectionErrorCallback.Reset();

	if (WebSocketConnection.IsValid())
	{
		WebSocketConnection->Close();
		WebSocketConnection.Reset();
	}
}

void ULuaWebsocketConnection::Send(FLuaValue Message)
{
	if (WebSocketConnection.IsValid() && WebSocketConnection->IsConnected())
	{
		WebSocketConnection->Send(Message.ToString());
	}
}

void ULuaWebsocketConnection::Close(FLuaValue Code, FLuaValue Reason)
{
	if (WebSocketConnection.IsValid() && WebSocketConnection->IsConnected())
	{
		WebSocketConnection->Close(Code.Integer, Reason.ToString());
	}
}

FLuaValue ULuaWebsocketConnection::ToLuaString()
{
	if (WebSocketConnection.IsValid() && WebSocketConnection->IsConnected())
	{
		return FLuaValue(FString::Printf(TEXT("WebSocket Connected to %s"), *CurrentUrl));
	}
	return FLuaValue("Unconnected WebSocket");
}

void ULuaWebsocketConnection::OnMessageDelegate(const FString& Message)
{
	FLuaValue Callback = LuaGetField("on_message");
	TArray<FLuaValue> Args = { FLuaValue(this), FLuaValue(Message) };
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(Callback, Args);
}

void ULuaWebsocketConnection::OnClosedDelegate(int32 Code, const FString& Reason, bool bUserClose)
{
	FLuaValue Callback = LuaGetField("on_closed");
	TArray<FLuaValue> Args = { FLuaValue(this), FLuaValue(Code), FLuaValue(Reason), FLuaValue(bUserClose) };
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(Callback, Args);
}

void ULuaWebsocketConnection::OnConnectedDelegate(TWeakPtr<FLuaSmartReference> OnConnectedCallbackRef)
{
	if (!OnConnectedCallbackRef.IsValid())
		return;

	TArray<FLuaValue> Args = { FLuaValue(this) };
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(OnConnectedCallbackRef.Pin()->Value, Args);
}

void ULuaWebsocketConnection::OnConnectionErrorDelegate(const FString& Message, TWeakPtr<FLuaSmartReference> OnConnectionErrorCallbackRef)
{
	if (!OnConnectionErrorCallbackRef.IsValid())
		return;

	TArray<FLuaValue> Args = { FLuaValue(this), FLuaValue(Message) };
	ULuaBlueprintFunctionLibrary::LuaValueCallIfNotNil(OnConnectionErrorCallbackRef.Pin()->Value, Args);
}
```

Note the checks for .IsValid() for the OnConnectedDelegate() and OnConnectionErrorDelegate() functions: they can be called at any moment, so we must be sure the native lua callbacks/functions are still valid. This is not required for OnMessageDelegate() and OnClosedDelegate() as they make use of the LuaGetField() function to retrieve the related lua callback.

Here the destructor prints a log message to allow the user/developer to track unexpected deallocations (see below)

## The LuaState

This is a simple LuaState showing how to exposed the previously create ULuaUserDataObject:

```c++
#pragma once

#include "CoreMinimal.h"
#include "LuaState.h"
#include "LuaWebsocketConnection.h"
#include "WebSocketsLuaStateBase.generated.h"

/**
 * 
 */
UCLASS()
class RPGLUA_API UWebSocketsLuaStateBase : public ULuaState
{
	GENERATED_BODY()

public:
	UWebSocketsLuaStateBase();

	UFUNCTION()
	FLuaValue GetWebSocketConnectionSingleton();

protected:
	UPROPERTY()
	ULuaWebsocketConnection* WebSocketConnectionSingleton;
	
};

```

The WebSocketConnectionSingleton member allows you to have a single instance of the websocket() object and, in addition to this, it will avoid the Unreal Garbage Collector to destroy it. If you want to allow the user/scripter to create more instances just use a TArray for tracking them (but implement a way to "untrack" them or to limit the amount of instances).

Let's go to the implementation:

```c++
#include "WebSocketsLuaStateBase.h"

UWebSocketsLuaStateBase::UWebSocketsLuaStateBase()
{
	Table.Add("websocket", FLuaValue::Function(GET_FUNCTION_NAME_CHECKED(UWebSocketsLuaStateBase, GetWebSocketConnectionSingleton)));
}

FLuaValue UWebSocketsLuaStateBase::GetWebSocketConnectionSingleton()
{
	if (!WebSocketConnectionSingleton)
	{
		WebSocketConnectionSingleton = NewObject<ULuaWebsocketConnection>(this);
	}
	return FLuaValue(WebSocketConnectionSingleton);
}
```


```