Project Path: arc_libriscv_godot-sandbox_9znxmq6j

Source Tree:

```txt
arc_libriscv_godot-sandbox_9znxmq6j
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ SConstruct
â”œâ”€â”€ SCsub
â”œâ”€â”€ THIRDPARTY.txt
â”œâ”€â”€ banner.png
â”œâ”€â”€ bin
â”‚   â”œâ”€â”€ addons
â”‚   â”‚   â””â”€â”€ godot_sandbox
â”‚   â”‚       â”œâ”€â”€ Build.svg
â”‚   â”‚       â”œâ”€â”€ Build.svg.import
â”‚   â”‚       â”œâ”€â”€ CPPScript.svg
â”‚   â”‚       â”œâ”€â”€ CPPScript.svg.import
â”‚   â”‚       â”œâ”€â”€ ELFScript.svg
â”‚   â”‚       â”œâ”€â”€ ELFScript.svg.import
â”‚   â”‚       â”œâ”€â”€ JSScript.svg
â”‚   â”‚       â”œâ”€â”€ JSScript.svg.import
â”‚   â”‚       â”œâ”€â”€ RustScript.svg
â”‚   â”‚       â”œâ”€â”€ RustScript.svg.import
â”‚   â”‚       â”œâ”€â”€ SafeGDScript.svg
â”‚   â”‚       â”œâ”€â”€ SafeGDScript.svg.import
â”‚   â”‚       â”œâ”€â”€ Sandbox.svg
â”‚   â”‚       â”œâ”€â”€ Sandbox.svg.import
â”‚   â”‚       â”œâ”€â”€ TSScript.svg
â”‚   â”‚       â”œâ”€â”€ TSScript.svg.import
â”‚   â”‚       â”œâ”€â”€ ZigScript.svg
â”‚   â”‚       â”œâ”€â”€ ZigScript.svg.import
â”‚   â”‚       â”œâ”€â”€ bin
â”‚   â”‚       â”œâ”€â”€ downloader.gd
â”‚   â”‚       â”œâ”€â”€ downloader.tscn
â”‚   â”‚       â”œâ”€â”€ icon.png.import
â”‚   â”‚       â”œâ”€â”€ plugin.cfg
â”‚   â”‚       â””â”€â”€ plugin.gd
â”‚   â”œâ”€â”€ cmake
â”‚   â”‚   â””â”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ icon.png
â”‚   â”œâ”€â”€ icon.png.import
â”‚   â”œâ”€â”€ project.godot
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ example.cpp
â”‚   â”‚   â””â”€â”€ test.gd
â”‚   â””â”€â”€ test.tscn
â”œâ”€â”€ build.sh
â”œâ”€â”€ build_android.sh
â”œâ”€â”€ build_mingw.sh
â”œâ”€â”€ config.py
â”œâ”€â”€ doc_classes
â”‚   â”œâ”€â”€ CPPScript.xml
â”‚   â”œâ”€â”€ CPPScriptLanguage.xml
â”‚   â”œâ”€â”€ ELFScript.xml
â”‚   â”œâ”€â”€ ELFScriptLanguage.xml
â”‚   â”œâ”€â”€ ResourceFormatLoaderCPP.xml
â”‚   â”œâ”€â”€ ResourceFormatLoaderELF.xml
â”‚   â”œâ”€â”€ ResourceFormatLoaderRust.xml
â”‚   â”œâ”€â”€ ResourceFormatLoaderZig.xml
â”‚   â”œâ”€â”€ ResourceFormatSaverCPP.xml
â”‚   â”œâ”€â”€ ResourceFormatSaverELF.xml
â”‚   â”œâ”€â”€ ResourceFormatSaverRust.xml
â”‚   â”œâ”€â”€ ResourceFormatSaverZig.xml
â”‚   â”œâ”€â”€ RustScript.xml
â”‚   â”œâ”€â”€ RustScriptLanguage.xml
â”‚   â”œâ”€â”€ Sandbox.xml
â”‚   â”œâ”€â”€ ZigScript.xml
â”‚   â””â”€â”€ ZigScriptLanguage.xml
â”œâ”€â”€ ext
â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ Gut
â”‚   â”œâ”€â”€ godot-cpp
â”‚   â””â”€â”€ libriscv
â”œâ”€â”€ godot-sandbox.code-workspace
â”œâ”€â”€ icons
â”‚   â”œâ”€â”€ Build.svg
â”‚   â”œâ”€â”€ CPPScript.svg
â”‚   â”œâ”€â”€ ELFScript.svg
â”‚   â”œâ”€â”€ JSScript.svg
â”‚   â”œâ”€â”€ RustScript.svg
â”‚   â”œâ”€â”€ SafeGDScript.svg
â”‚   â”œâ”€â”€ Sandbox.svg
â”‚   â”œâ”€â”€ TSScript.svg
â”‚   â””â”€â”€ ZigScript.svg
â”œâ”€â”€ program
â”‚   â”œâ”€â”€ cpp
â”‚   â”‚   â”œâ”€â”€ cmake
â”‚   â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”‚   â”‚   â”œâ”€â”€ atomic.c
â”‚   â”‚   â”‚   â”œâ”€â”€ autobuild.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ example
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ build.sh
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ example.cpp
â”‚   â”‚   â”‚   â””â”€â”€ toolchain.cmake
â”‚   â”‚   â”œâ”€â”€ docker
â”‚   â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â”‚   â”œâ”€â”€ api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ api.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ api.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ api_inline.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ array.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ array.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ basis.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ basis.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ callable.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ canvas_item.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ color.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dictionary.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dictionary.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ function.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ native.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ node.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ node.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ node2d.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ node2d.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ node3d.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ node3d.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ object.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ object.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ packed_array.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ packed_array.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ packed_byte_array.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ plane.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ quaternion.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ quaternion.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ rect2.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ rect2i.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ rid.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ string.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ string.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ syscalls.h
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ syscalls_fwd.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ timer.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ timer.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ transform2d.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ transform2d.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ transform3d.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ transform3d.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ variant.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ variant.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector.cpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector2.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector2i.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector3.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector3i.hpp
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vector4.hpp
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ vector4i.hpp
â”‚   â”‚   â”‚   â”œâ”€â”€ build.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ container_build.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ docker.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ start.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ stop_and_remove.sh
â”‚   â”‚   â”‚   â””â”€â”€ test_local_compiler.sh
â”‚   â”‚   â””â”€â”€ project
â”‚   â”‚       â”œâ”€â”€ CMakeLists.txt
â”‚   â”‚       â”œâ”€â”€ README.md
â”‚   â”‚       â”œâ”€â”€ build.sh
â”‚   â”‚       â””â”€â”€ src
â”‚   â”‚           â””â”€â”€ program.cpp
â”‚   â”œâ”€â”€ rust
â”‚   â”‚   â”œâ”€â”€ docker
â”‚   â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â”‚   â”œâ”€â”€ build.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ container_build.sh
â”‚   â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ godot
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ api.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ array.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ dictionary.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ node.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ string.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ sysalloc.rs
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ syscalls.rs
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ variant.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ start.sh
â”‚   â”‚   â”‚   â””â”€â”€ stop_and_remove.sh
â”‚   â”‚   â””â”€â”€ project
â”‚   â”‚       â”œâ”€â”€ Cargo.toml
â”‚   â”‚       â”œâ”€â”€ build.sh
â”‚   â”‚       â””â”€â”€ src
â”‚   â”‚           â”œâ”€â”€ godot
â”‚   â”‚           â””â”€â”€ main.rs
â”‚   â””â”€â”€ zig
â”‚       â”œâ”€â”€ docker
â”‚       â”‚   â”œâ”€â”€ Dockerfile
â”‚       â”‚   â”œâ”€â”€ api
â”‚       â”‚   â”‚   â””â”€â”€ api.zig
â”‚       â”‚   â”œâ”€â”€ build.sh
â”‚       â”‚   â”œâ”€â”€ container_build.sh
â”‚       â”‚   â”œâ”€â”€ start.sh
â”‚       â”‚   â””â”€â”€ stop_and_remove.sh
â”‚       â””â”€â”€ project
â”‚           â””â”€â”€ api
â”œâ”€â”€ register_types.cpp
â”œâ”€â”€ register_types.h
â”œâ”€â”€ sandbox-logo.png
â”œâ”€â”€ sandbox.png
â”œâ”€â”€ scripts
â”‚   â”œâ”€â”€ clang-format.sh
â”‚   â””â”€â”€ clang-tidy.sh
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ bintr
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ cpp
â”‚   â”‚   â”œâ”€â”€ resource_loader_cpp.cpp
â”‚   â”‚   â”œâ”€â”€ resource_loader_cpp.h
â”‚   â”‚   â”œâ”€â”€ resource_saver_cpp.cpp
â”‚   â”‚   â”œâ”€â”€ resource_saver_cpp.h
â”‚   â”‚   â”œâ”€â”€ script_cpp.cpp
â”‚   â”‚   â”œâ”€â”€ script_cpp.h
â”‚   â”‚   â”œâ”€â”€ script_cpp_instance.cpp
â”‚   â”‚   â”œâ”€â”€ script_cpp_instance.h
â”‚   â”‚   â”œâ”€â”€ script_language_cpp.cpp
â”‚   â”‚   â””â”€â”€ script_language_cpp.h
â”‚   â”œâ”€â”€ docker.cpp
â”‚   â”œâ”€â”€ docker.h
â”‚   â”œâ”€â”€ elf
â”‚   â”‚   â”œâ”€â”€ resource_loader_elf.cpp
â”‚   â”‚   â”œâ”€â”€ resource_loader_elf.h
â”‚   â”‚   â”œâ”€â”€ resource_saver_elf.cpp
â”‚   â”‚   â”œâ”€â”€ resource_saver_elf.h
â”‚   â”‚   â”œâ”€â”€ script_elf.cpp
â”‚   â”‚   â”œâ”€â”€ script_elf.h
â”‚   â”‚   â”œâ”€â”€ script_instance.cpp
â”‚   â”‚   â”œâ”€â”€ script_instance.h
â”‚   â”‚   â”œâ”€â”€ script_instance_helper.h
â”‚   â”‚   â”œâ”€â”€ script_language_elf.cpp
â”‚   â”‚   â””â”€â”€ script_language_elf.h
â”‚   â”œâ”€â”€ gdscript
â”‚   â”‚   â””â”€â”€ compiler
â”‚   â”‚       â”œâ”€â”€ CMakeLists.txt
â”‚   â”‚       â”œâ”€â”€ OPTIMIZATIONS.md
â”‚   â”‚       â”œâ”€â”€ ast.h
â”‚   â”‚       â”œâ”€â”€ codegen.cpp
â”‚   â”‚       â”œâ”€â”€ codegen.h
â”‚   â”‚       â”œâ”€â”€ compiler.cpp
â”‚   â”‚       â”œâ”€â”€ compiler.h
â”‚   â”‚       â”œâ”€â”€ compiler_exception.cpp
â”‚   â”‚       â”œâ”€â”€ compiler_exception.h
â”‚   â”‚       â”œâ”€â”€ dump_ir.cpp
â”‚   â”‚       â”œâ”€â”€ elf_builder.cpp
â”‚   â”‚       â”œâ”€â”€ elf_builder.h
â”‚   â”‚       â”œâ”€â”€ gdscript_to_riscv.cpp
â”‚   â”‚       â”œâ”€â”€ ir.cpp
â”‚   â”‚       â”œâ”€â”€ ir.h
â”‚   â”‚       â”œâ”€â”€ ir_interpreter.cpp
â”‚   â”‚       â”œâ”€â”€ ir_interpreter.h
â”‚   â”‚       â”œâ”€â”€ ir_optimizer.cpp
â”‚   â”‚       â”œâ”€â”€ ir_optimizer.h
â”‚   â”‚       â”œâ”€â”€ lexer.cpp
â”‚   â”‚       â”œâ”€â”€ lexer.h
â”‚   â”‚       â”œâ”€â”€ parser.cpp
â”‚   â”‚       â”œâ”€â”€ parser.h
â”‚   â”‚       â”œâ”€â”€ register_allocator.cpp
â”‚   â”‚       â”œâ”€â”€ register_allocator.h
â”‚   â”‚       â”œâ”€â”€ riscv_codegen.cpp
â”‚   â”‚       â”œâ”€â”€ riscv_codegen.h
â”‚   â”‚       â”œâ”€â”€ test_compiler.cpp
â”‚   â”‚       â”œâ”€â”€ tests
â”‚   â”‚       â”‚   â”œâ”€â”€ test_codegen.cpp
â”‚   â”‚       â”‚   â”œâ”€â”€ test_compilation.cpp
â”‚   â”‚       â”‚   â”œâ”€â”€ test_constant_pool.cpp
â”‚   â”‚       â”‚   â”œâ”€â”€ test_integration.cpp
â”‚   â”‚       â”‚   â”œâ”€â”€ test_ir_optimizer.cpp
â”‚   â”‚       â”‚   â”œâ”€â”€ test_lexer.cpp
â”‚   â”‚       â”‚   â”œâ”€â”€ test_parser.cpp
â”‚   â”‚       â”‚   â””â”€â”€ test_primitives.cpp
â”‚   â”‚       â”œâ”€â”€ token.cpp
â”‚   â”‚       â”œâ”€â”€ token.h
â”‚   â”‚       â””â”€â”€ variant_types.h
â”‚   â”œâ”€â”€ godot
â”‚   â”‚   â”œâ”€â”€ script_instance.cpp
â”‚   â”‚   â””â”€â”€ script_instance.h
â”‚   â”œâ”€â”€ guest_datatypes.h
â”‚   â”œâ”€â”€ guest_variant.cpp
â”‚   â”œâ”€â”€ libriscv_settings.h
â”‚   â”œâ”€â”€ override_libriscv.cpp
â”‚   â”œâ”€â”€ register_types.cpp
â”‚   â”œâ”€â”€ register_types.h
â”‚   â”œâ”€â”€ rust
â”‚   â”‚   â”œâ”€â”€ resource_loader_rust.cpp
â”‚   â”‚   â”œâ”€â”€ resource_loader_rust.h
â”‚   â”‚   â”œâ”€â”€ resource_saver_rust.cpp
â”‚   â”‚   â”œâ”€â”€ resource_saver_rust.h
â”‚   â”‚   â”œâ”€â”€ script_language_rust.cpp
â”‚   â”‚   â”œâ”€â”€ script_language_rust.h
â”‚   â”‚   â”œâ”€â”€ script_rust.cpp
â”‚   â”‚   â””â”€â”€ script_rust.h
â”‚   â”œâ”€â”€ safegdscript
â”‚   â”‚   â”œâ”€â”€ resource_loader_safegdscript.cpp
â”‚   â”‚   â”œâ”€â”€ resource_loader_safegdscript.h
â”‚   â”‚   â”œâ”€â”€ resource_saver_safegdscript.cpp
â”‚   â”‚   â”œâ”€â”€ resource_saver_safegdscript.h
â”‚   â”‚   â”œâ”€â”€ script_instance_safegdscript.cpp
â”‚   â”‚   â”œâ”€â”€ script_instance_safegdscript.h
â”‚   â”‚   â”œâ”€â”€ script_language_safegdscript.cpp
â”‚   â”‚   â”œâ”€â”€ script_language_safegdscript.h
â”‚   â”‚   â”œâ”€â”€ script_safegdscript.cpp
â”‚   â”‚   â””â”€â”€ script_safegdscript.h
â”‚   â”œâ”€â”€ sandbox.cpp
â”‚   â”œâ”€â”€ sandbox.h
â”‚   â”œâ”€â”€ sandbox_bintr.cpp
â”‚   â”œâ”€â”€ sandbox_debug.cpp
â”‚   â”œâ”€â”€ sandbox_exception.cpp
â”‚   â”œâ”€â”€ sandbox_functions.cpp
â”‚   â”œâ”€â”€ sandbox_generated_api.cpp
â”‚   â”œâ”€â”€ sandbox_globals.cpp
â”‚   â”œâ”€â”€ sandbox_profiling.cpp
â”‚   â”œâ”€â”€ sandbox_programs.cpp
â”‚   â”œâ”€â”€ sandbox_project_settings.cpp
â”‚   â”œâ”€â”€ sandbox_project_settings.h
â”‚   â”œâ”€â”€ sandbox_restrictions.cpp
â”‚   â”œâ”€â”€ sandbox_shm.cpp
â”‚   â”œâ”€â”€ sandbox_syscalls.cpp
â”‚   â”œâ”€â”€ sandbox_syscalls_2d.cpp
â”‚   â”œâ”€â”€ sandbox_syscalls_3d.cpp
â”‚   â”œâ”€â”€ scoped_tree_base.h
â”‚   â”œâ”€â”€ script_language_common.h
â”‚   â”œâ”€â”€ syscalls.h
â”‚   â”œâ”€â”€ syscalls_helpers.hpp
â”‚   â”œâ”€â”€ tests
â”‚   â”‚   â”œâ”€â”€ assault.cpp
â”‚   â”‚   â””â”€â”€ dummy_assault.cpp
â”‚   â”œâ”€â”€ vmcallable.h
â”‚   â”œâ”€â”€ vmproperty.h
â”‚   â””â”€â”€ zig
â”‚       â”œâ”€â”€ resource_loader_zig.cpp
â”‚       â”œâ”€â”€ resource_loader_zig.h
â”‚       â”œâ”€â”€ resource_saver_zig.cpp
â”‚       â”œâ”€â”€ resource_saver_zig.h
â”‚       â”œâ”€â”€ script_language_zig.cpp
â”‚       â”œâ”€â”€ script_language_zig.h
â”‚       â”œâ”€â”€ script_zig.cpp
â”‚       â””â”€â”€ script_zig.h
â””â”€â”€ tests
    â”œâ”€â”€ CMakeLists.txt
    â”œâ”€â”€ addons
    â”‚   â”œâ”€â”€ godot_sandbox
    â”‚   â””â”€â”€ gut
    â”œâ”€â”€ debug.sh
    â”œâ”€â”€ extensions
    â”‚   â”œâ”€â”€ bin
    â”‚   â”‚   â”œâ”€â”€ libgodot-riscv.linux.debug.x86_64.so
    â”‚   â”‚   â””â”€â”€ libgodot-riscv.linux.release.x86_64.so
    â”‚   â””â”€â”€ libgodot-riscv.gdextension
    â”œâ”€â”€ icon.svg
    â”œâ”€â”€ icon.svg.import
    â”œâ”€â”€ project.godot
    â”œâ”€â”€ run_unittests.sh
    â”œâ”€â”€ tests
    â”‚   â”œâ”€â”€ test_basic.cpp
    â”‚   â”œâ”€â”€ test_basic.gd
    â”‚   â”œâ”€â”€ test_cppscript.gd
    â”‚   â”œâ”€â”€ test_gdscript_compiler.cpp
    â”‚   â”œâ”€â”€ test_gdscript_compiler.gd
    â”‚   â”œâ”€â”€ test_generate_api.gd
    â”‚   â”œâ”€â”€ test_math.cpp
    â”‚   â”œâ”€â”€ test_math.gd
    â”‚   â”œâ”€â”€ test_properties.cpp
    â”‚   â”œâ”€â”€ test_properties.gd
    â”‚   â”œâ”€â”€ test_restrictions.gd
    â”‚   â”œâ”€â”€ test_shm.cpp
    â”‚   â””â”€â”€ test_shm.gd
    â”œâ”€â”€ toolchain.cmake
    â””â”€â”€ zig_unittests.sh

```

`CLAUDE.md`:

```md
This project is a sandbox addon for the Godot engine. It implements a Sandbox node which can load a RISC-V ELF binary, which can then execute code and access the host Godot instance. The access can be restricted by class names, methods, properties etc. Execution is memory safe and has an optional execution timeout using instruction counting. The underlying emulator is libriscv. The emulator runs either in JIT or interpreter mode. This can be toggled during init. Both JIT and interpreter modes are faster than GDScript. Whitespace is tabs.

The Sandbox node can be instantiated, given an ELF and then it can export functions and properties making it a sort-of script-like instance. It can also be used as a Script, by attaching it to the Script of any Node. In that case, calling functions on the node will be forwarded to the script, which again calls into the sandboxed guest program. The sandbox node is implemented in src/sandbox.cpp and src/sandbox.h as well as a few src/sandbox_*.cpp files. The cpp ScriptLanguage is in src/cpp/*. The sandbox API is implemented in src/sandbox_syscalls.cpp and sandbox_syscalls_*.cpp.

The API inside the Sandbox follows the public GDScript API closely, simply because it implements the complete Variant with all types, as well as the ability to call functions on objects.

The Sandbox API is written in C++. It accesses the host using system calls. Most system calls are dedicated to handling methods in the very common Variant types. Eg. the most important methods in PackedVector3Array will have dedicated system calls, while the rest are achieved through vcall (a call on a Variant which holds the PackedVector3Array). This also means that the Godot Sandbox API is complete, matching the GDScript capabilities.

ELFScript is a Godot-specific Resource type that is the result of loading and ELF into a Godot Project. It can be placed into a Node, which will make a Sandbox with that resource (ELF) loaded. It really has nothing to do with the ELF format. It's just a handler for resources that end with .elf (which _are_ ELF binaries), but any actual ELF parsing happens only in the libriscv emulator.

The host-side and guest-side share a common system call API for all languages supported. The system calls are defined in syscalls.h, and are fixed numbers that cannot be reassigned, as that would break existing users programs. Instead new functionality is added as new system calls, or as options to existing system calls when that is possible.

There is an ongoing GDScript-to-RISC-V compiler project under the src/gdscript/compiler folder. It's parsing GDScript into AST, then to IR and it will finally be transformed to 64-bit RISC-V and packed into an ELF container as the last step. At that point the goal is to make it executable inside Godot Sandbox. It has written like a CMake library, and it currently being used in the unit tests. One unit test compiles an ELF inside the sandbox and then runs the result in another sandbox. When running tests for the compiler, they should have a timeout as loops may run forever. Do NOT under any circumstance disable tests, FIX the problem. The unit tests can be executed with `ctest .` in the src/gdscript/compiler/build folder.

## Compiler Debugging Tools

Two debugging tools are available in the compiler build folder:

### dump_ir
Inspects the IR (Intermediate Representation) generated from GDScript.

**Usage:**
```bash
cat script.gd | ./dump_ir                    # Basic IR dump
cat script.gd | ./dump_ir --no-optimize      # IR without optimizations
cat script.gd | ./dump_ir --codegen          # IR with register allocation info
cat script.gd | ./dump_ir -v --codegen       # Verbose with detailed operands
```

**What it shows:**
- Virtual registers (r0, r1, ...)
- Physical register allocation when using `--codegen` (t0, t1, s0, a0, etc.)
- Stack slot assignments for spilled values
- Type hints and instruction operands

### gdscript_to_riscv
Compiles GDScript to RISC-V ELF and immediately shows the disassembled machine code.

**Usage:**
```bash
cat script.gd | ./gdscript_to_riscv              # Disassemble all functions
cat script.gd | ./gdscript_to_riscv -f test      # Disassemble specific function
```

**What it shows:**
- Actual RISC-V instructions generated
- Machine code bytes
- Memory addresses
- Equivalent assembly with register names

These tools are essential for tracking down bugs in the compiler pipeline by showing what's generated at each stage.

The GDScript-to-RISC-V unit tests are under /tests/tests. You can only visually inspect RISC-V ELFs using riscv64-linux-gnu-objdump. Executing the unit tests specific to GDScript is from the tests folder:
./run_unittests.sh -gselect compiler
Always run unit tests from the tests folder. There is a separate script for running Zig C++ unit tests:
./zig_unittests.sh -gselect compiler
Also must be run from the tests folder. The GDScript compiler is RUNNING INSIDE a sandbox instance in all unit tests. That means when there's a failure and the originating call is `compile_to_elf`, it means the compiler crashed/failed INSIDE the sandbox instance.

The Godot Sandbox ABI has a complex passing scheme in order to be fast and low-latency. However, it has a second mode where all arguments in and out are always Variants. Using Variant only is the best choice for the GDScript compiler, as it makes it fully dynamic just like real GDScript. Most people don't use type hints anyway, and we'd have to verify them regardless. Real GDScript has an optimization phase where bytecodes are replaced with faster specific bytecodes once types have been checked. We are not going to focus on that, but rather on getting everything up and working.

Register A0 is always the Variant return value pointer. A1-A7 are function arguments as pointers.
The Variant ABI is a 4-byte type, 4-byte padding and then 16-bytes of inlined data (for certain types), making it 24 bytes with regular settings. Variants are placed on the stack and the pointer is placed in registers for calls. In order to make the sandbox not unbox Variants into registers `vmcallv()` is used instead of `vmcall()`. Variants don't need be zeroed. Only the relevant portion has to have non-garbage value. For example Integer type needs only m_type and v.i to be valid, covering only 12/24 bytes.

The GDScript compiler has a register allocator that can be used to avoid clobbered registers especially when performing system calls. Any new feature needs an internal (CMake) test before an integration test in the unit tests is written.

The RISC-V codegen has to use Variants as that is the fundamental unit of GDScript. The structure of the Variant can be seen in program/cpp/docker/api/variant.hpp, including the enum types. This means we can actually add together two Vector2's, two Vector4i's, concatenate strings etc. without really knowing what they are. Any optimization needs to carefully consider whether or not we know the actual Variant types being dealt with before reconstructing the logic. With proper type hints we can perform arithmetic on two Variants without VEVAL. Sandboxed Variants aren't real Variants - they are closely guarded, so "using them wrong" is not going to hurt the host (unless there is a bug). So, for example adding two type-hinted integers or floats can be performed in physical registers.

When dealing with floats it's CRUCIAL to understand that:
1. v.f (the regular float) in the Variant structure is _always_ 64-bit.
2. real_t is CONFIGURABLE, but 32-bit float by default. Vectors use real_t.
3. Adding integer and float (whether constant or not) produces a float result

When dealing with object references, they are 32-bit integers which are stored in the data section of the Variant. When the sandbox stores this value, it's stored as a 64-bit value, so it won't matter if loaded as 32-bit or 64-bit int, however it does matter when storing the value: Use 64-bit sd instruction.

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.9.4)
project(riscv CXX)

option(SANITIZE    "Enable sanitizers" OFF)
option(STATIC_BUILD "Build statically" OFF)

set(SOURCES
	src/cpp/resource_loader_cpp.cpp
	src/cpp/resource_saver_cpp.cpp
	src/cpp/script_cpp.cpp
	src/cpp/script_cpp_instance.cpp
	src/cpp/script_language_cpp.cpp
	src/elf/resource_loader_elf.cpp
	src/elf/resource_saver_elf.cpp
	src/elf/script_elf.cpp
	src/elf/script_instance.cpp
	src/elf/script_language_elf.cpp
	src/rust/resource_loader_rust.cpp
	src/rust/resource_saver_rust.cpp
	src/rust/script_rust.cpp
	src/rust/script_language_rust.cpp
	src/zig/resource_loader_zig.cpp
	src/zig/resource_saver_zig.cpp
	src/zig/script_zig.cpp
	src/zig/script_language_zig.cpp
	src/safegdscript/script_instance_safegdscript.cpp
	src/safegdscript/script_language_safegdscript.cpp
	src/safegdscript/script_safegdscript.cpp
	src/safegdscript/resource_loader_safegdscript.cpp
	src/safegdscript/resource_saver_safegdscript.cpp
	src/docker.cpp
	src/godot/script_instance.cpp
	src/guest_variant.cpp
	src/register_types.cpp
	src/sandbox.cpp
	src/sandbox_bintr.cpp
	src/sandbox_debug.cpp
	src/sandbox_exception.cpp
	src/sandbox_functions.cpp
	src/sandbox_globals.cpp
	src/sandbox_generated_api.cpp
	src/sandbox_profiling.cpp
	src/sandbox_programs.cpp
	src/sandbox_project_settings.cpp
	src/sandbox_restrictions.cpp
	src/sandbox_shm.cpp
	src/sandbox_syscalls.cpp
	src/sandbox_syscalls_2d.cpp
	src/sandbox_syscalls_3d.cpp
	src/override_libriscv.cpp

	src/tests/assault.cpp
)

# Add bintr sources
file(GLOB BINTR_FILES src/bintr/*.cpp)
list(APPEND SOURCES ${BINTR_FILES})

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -fvisibility=hidden -fvisibility-inlines-hidden")

if (MINGW OR MINGW_TOOLCHAIN)
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -static-libgcc -static-libstdc++ -static")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++20")
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -static-libgcc -static-libstdc++ -static")
endif()

add_subdirectory(ext)

add_library(godot-riscv SHARED ${SOURCES})
target_link_libraries(godot-riscv PUBLIC riscv godot-cpp)

if (STATIC_BUILD)
	target_link_libraries(godot-riscv PUBLIC -static)
endif()
if (SANITIZE)
	#target_compile_options(godot-riscv PUBLIC -fsanitize=scudo,undefined)
	#target_link_libraries(godot-riscv PUBLIC -fsanitize=scudo,undefined -L/usr/lib/llvm-18/lib/clang/18/lib/linux -l:libclang_rt.ubsan_standalone-x86_64.so -l:libclang_rt.scudo_standalone-x86_64.so -Wl,-rpath=/usr/lib/llvm-18/lib/clang/18/lib/linux)
	target_compile_options(godot-riscv PUBLIC -fsanitize=undefined -fno-sanitize=vptr)
	target_link_libraries(godot-riscv PUBLIC -fsanitize=undefined -L/usr/lib/llvm-18/lib/clang/18/lib/linux -l:libclang_rt.ubsan_standalone-x86_64.a)
endif()
if (ANDROID_TOOLCHAIN)
	target_link_libraries(godot-riscv PUBLIC android log)
endif()

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2024, Alf-AndrÃ© Walla

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
<p align="center">
<img src="https://github.com/libriscv/godot-sandbox/blob/main/banner.png?raw=true" width="312px"/>
</p>
<p align="center">

<p align="center">
        <img src="https://github.com/libriscv/godot-sandbox/actions/workflows/runner.yml/badge.svg?branch=main"
            alt="Godot Sandbox Build"></a>
        <img src="https://img.shields.io/badge/Godot-4.3-%23478cbf?logo=godot-engine&logoColor=white" />
</p>

<p align = "center">
    <strong>
        <a href="https://libriscv.no">Website</a> | <a href="https://github.com/libriscv/godot-sandbox-programs">Code Examples</a> | <a href="https://discord.gg/n4GcXr66X5">Discord</a> | <a href="https://gonzerelli.itch.io/demo">Web Demo</a>
    </strong>
</p>


-----

<p align = "center">
<b>Safe, low-latency and fast sandbox</b>
<i>for the Godot game engine.</i>
</p>

<p align = "center">
	<strong>
  		<a href="https://github.com/user-attachments/files/17729740/Introducing.the.New.Godot.Sandbox.pdf">GodotCon 2024 Presentation</a>
	</strong>
</p>

-----

Godot Sandbox allows Godot creators to implement safe modding support, such that they can pass around programs built by other players, knowing that _restricted_ programs cannot harm other players. All Godot platforms are supported.


## Installation

- Automatic (Recommended): Download the plugin from the official [Godot Asset Store](https://godotengine.org/asset-library/asset/3192) using the **AssetLib** tab in Godot by searching for **Godot Sandbox**.

- Manual: Download the [latest github release](https://github.com/libriscv/godot-sandbox/releases/latest) and move only the **addons** folder into your project **addons** folder.

### What can I do?

- Modding API
	- You can implement a modding API for your game. This API can then be used by other players to extend your game, in a safe manner.
	- Put restrictions on resources, classes and objects to say what is accessible inside the sandbox.
- Build once, run everywhere
	- You can publish your game for all mobile and console platforms, without paying a performance penalty. It's not going to be laggy on some platforms, which is a risk with solutions that are only fast when JIT is available.
- High-performance
	- You can use this extension as a way to write higher performance code than GDScript permits, without having to resort to writing and maintaining a GDExtension for all platforms.
	- Enable full binary translation to increase performance drastically. Also works on all platforms, but has to be [embedded in the project or loaded as a DLL](https://libriscv.no/docs/godot_docs/bintr).
	- Yields [2.5-10x performance boost by default](https://libriscv.no/docs/performance/#godot-sandbox-performance), 5-50x with binary translation
	- JIT builds are also available in the Releases section for Windows, macOS, Android and Linux. The JIT will enhance performance automatically in the background for all programs, including SafeGDScript.
- Publish and then make updates without re-publishing
	- You can distribute programs from a server to clients as part of the login sequence. You can use this to live-distribute changes like bugfixes or even new features to the game without having to re-publish the game itself. I do this in my game.

## Usage

- Write C++, Rust and SafeGDScript in the Godot editor. An accompanying ELF resource is created. This resource can be loaded into any Sandbox instance on every platform without recompiling. In the case of SafeGDScript it should be attached as a script, and it will work similarly to GDScript.

- Create a new `Sandbox` and [assign the ELF resource to it](https://libriscv.no/docs/godot/sandbox/#create-a-sandbox)
	- Lifetime as any other node
	- Auto-completion from other GDScripts using @export

- Or, [directly assign an ELF script resource to a node](https://libriscv.no/docs/godot/sandbox/#using-programs-directly-as-scripts)
	- Shared sandbox among all instances with that script
	- Maximum scalability
	- Call functions and attach signals like GDScript

## Examples

```C++
#include "api.hpp"
static int coins = 0;

static Variant reset_game() {
	coins = 0;
	return Nil;
}

static inline void add_coin(const Node& player) {
	coins ++;
	// In our demo project we can access the coin label from the player
	// using a node path: Player -> get_parent() -> Texts -> CoinLabel
	Label coinlabel = player.get_node<Label>("../Texts/CoinLabel");
	coinlabel.set_text("You have collected "
		+ std::to_string(coins) + ((coins == 1) ? " coinyboys" : " coins"));
}

static Variant _on_body_entered(CharacterBody2D body) {
	if (body.get_name() != "Player")
		return Nil;

	get_node().queue_free(); // Remove the current coin!
	add_coin(body);
	return Nil;
}

static Variant _ready() {
	if (is_editor_hint()) {
		get_node().set_process_input(false);
	}
	return Nil; //
}

static Variant _process(double delta) {
	if (is_editor_hint()) {
		AnimatedSprite2D sprite("AnimatedSprite2D");
		sprite.play("idle");
		sprite.set_speed_scale(1.0f);
	}
	return Nil;
}

static Variant _input(InputEvent event) {
	if (event.is_action_pressed("jump")) {
		get_node<Node2D>().set_modulate(0xFF6060FF);
	} else if (event.is_action_released("jump")) {
		get_node<Node2D>().set_modulate(0xFFFFFFFF);
	}
	return Nil;
}

int main() {
	ADD_API_FUNCTION(_on_body_entered, "void", "CharacterBody2D");
	ADD_API_FUNCTION(_ready, "void");
	ADD_API_FUNCTION(_process, "void", "double");
	ADD_API_FUNCTION(_input, "void", "InputEvent");
	ADD_API_FUNCTION(reset_game, "void");
}
```

Script of a simple Coin pickup, with a counter that updates a label in the outer tree. This script can be attached to the Coin in the editor just like GDScript.

You may also have a look at our [demo repository](https://github.com/libriscv/godot-sandbox-demo) for the Godot Sandbox. It's a tiny platformer that uses C++ and Rust. There is also [a 3D plane demo](https://github.com/libriscv/godot_bird_plane) that enables controlling the plane from C++ scripts.

## Module Build

In order to build module, add it to a godot repo:

```
git submodule add https://github.com/libriscv/godot-sandbox modules/sandbox
cd modules/sandbox
git submodule update --init --recursive
```

## Contributing

Requirements:
- [SCons](https://www.scons.org)
- [python3](https://www.python.org)

If you want to contribute to this repo, here are steps on how to build locally:

```sh
./build.sh
```

You can also use `scons` similar to how godot-cpp addons are built.

## Contributors âœ¨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center" valign="top" width="14.28%"><a href="https://github.com/fwsGonzo"><img src="https://avatars.githubusercontent.com/u/3758947?v=4?s=100" width="100px;" alt="Alf-AndrÃ© Walla"/><br /><sub><b>Alf-AndrÃ© Walla</b></sub></a><br /><a href="https://github.com/libriscv/godot-sandbox/commits?author=fwsGonzo" title="Code">ğŸ’»</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://chibifire.com"><img src="https://avatars.githubusercontent.com/u/32321?v=4?s=100" width="100px;" alt="K. S. Ernest (iFire) Lee"/><br /><sub><b>K. S. Ernest (iFire) Lee</b></sub></a><br /><a href="https://github.com/libriscv/godot-sandbox/commits?author=fire" title="Code">ğŸ’»</a> <a href="#research-fire" title="Research">ğŸ”¬</a> <a href="https://github.com/libriscv/godot-sandbox/commits?author=fire" title="Tests">âš ï¸</a></td>
      <td align="center" valign="top" width="14.28%"><a href="https://appsinacup.com"><img src="https://avatars.githubusercontent.com/u/2369380?v=4?s=100" width="100px;" alt="Dragos Daian"/><br /><sub><b>Dragos Daian</b></sub></a><br /><a href="https://github.com/libriscv/godot-sandbox/commits?author=Ughuuu" title="Code">ğŸ’»</a></td>
    </tr>
  </tbody>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

This project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!

## Other Projects

The [Jenova Framework](https://github.com/Jenova-Framework/) has a built-in C++ compiler, and supports writing C++ in the Godot editor with hot-reloading support.

```

`SConstruct`:

```
#!/usr/bin/env python
import os
import sys

ARGUMENTS["disable_exceptions"] = "0"
ARGUMENTS["use_mingw"] = "yes"

env = SConscript("ext/godot-cpp/SConstruct")

env.Append(CPPDEFINES = ['RISCV_SYSCALLS_MAX=600', 'RISCV_BRK_MEMORY_SIZE=0x100000'])
env.Prepend(CPPPATH=["ext/libriscv/lib"])
env.Append(CPPPATH=["src/", "."])

sources = [Glob("src/*.cpp"), Glob("src/cpp/*.cpp"), Glob("src/rust/*.cpp"), Glob("src/zig/*.cpp"), Glob("src/elf/*.cpp"), Glob("src/godot/*.cpp"), Glob("src/safegdscript/*.cpp"), ["src/tests/dummy_assault.cpp"], Glob("src/bintr/*.cpp")]

librisc_sources = [
    # threaded fast-path:
    "ext/libriscv/lib/libriscv/threaded_dispatch.cpp",
    "ext/libriscv/lib/libriscv/threaded_inaccurate_dispatch.cpp",

    "ext/libriscv/lib/libriscv/cpu.cpp",
    "ext/libriscv/lib/libriscv/debug.cpp",
    "ext/libriscv/lib/libriscv/decode_bytecodes.cpp",
    "ext/libriscv/lib/libriscv/decoder_cache.cpp",
    "ext/libriscv/lib/libriscv/machine.cpp",
    "ext/libriscv/lib/libriscv/machine_defaults.cpp",
    "ext/libriscv/lib/libriscv/memory.cpp",
    "ext/libriscv/lib/libriscv/memory_elf.cpp",
    "ext/libriscv/lib/libriscv/memory_mmap.cpp",
    "ext/libriscv/lib/libriscv/memory_rw.cpp",
    "ext/libriscv/lib/libriscv/native_libc.cpp",
    "ext/libriscv/lib/libriscv/native_threads.cpp",
    #"ext/libriscv/lib/libriscv/rv32i.cpp",
    "ext/libriscv/lib/libriscv/rv64i.cpp",
    "ext/libriscv/lib/libriscv/serialize.cpp",

    # POSIX
    "ext/libriscv/lib/libriscv/posix/minimal.cpp",
    "ext/libriscv/lib/libriscv/posix/signals.cpp",
    "ext/libriscv/lib/libriscv/posix/threads.cpp",
    "ext/libriscv/lib/libriscv/util/crc32c.cpp",

    # Binary translator
    "ext/libriscv/lib/libriscv/tr_api.cpp",
    "ext/libriscv/lib/libriscv/tr_emit.cpp",
    "ext/libriscv/lib/libriscv/tr_translate.cpp",
]

if env["platform"] == "windows":
    librisc_sources += [
        "ext/libriscv/lib/libriscv/win32/dlfcn.cpp",
        "ext/libriscv/lib/libriscv/win32/system_calls.cpp",
        "ext/libriscv/lib/libriscv/win32/tr_msvc.cpp",
    ]
else:
    librisc_sources += [
        "ext/libriscv/lib/libriscv/linux/system_calls.cpp",

        # Binary translator - TCC
        #"ext/libriscv/lib/libriscv/tr_tcc.cpp"
        # Binary translator - System compiler
        "ext/libriscv/lib/libriscv/tr_compiler.cpp",
    ]

if env["platform"] != "windows" or env["use_mingw"]:
    env.Append(CXXFLAGS=["-std=c++20"])
else:
    env.Append(CXXFLAGS=["/std:c++20"])

sources.extend(librisc_sources)

# GodotCPP XML documenation
def add_godot_cpp_doc_data(env, sources):
    try:
        doc_data = env.GodotCPPDocData("src/gen/doc_data.gen.cpp", source=Glob("doc_classes/*.xml"))
        sources.append(doc_data)
    except AttributeError:
        print("Not including class reference as we're targeting a pre-4.3 baseline.")

if env["platform"] == "windows":
    env.Prepend(CPPPATH=["ext/libriscv/lib/libriscv/lib/win32"])
    env.Prepend(LIBS=['ws2_32']) # for socket calls
    add_godot_cpp_doc_data(env, sources)
elif env["platform"] == "macos":
    env.Prepend(CPPPATH=["ext/libriscv/lib/libriscv/lib/macos"])
    env.Append(LINKFLAGS=["-framework", "Security"])
    add_godot_cpp_doc_data(env, sources)
elif env["platform"] == "linux" or env["platform"] == "android":
    env.Prepend(CPPPATH=["ext/libriscv/lib/libriscv/lib/linux"])
    add_godot_cpp_doc_data(env, sources)

if "static_build" not in ARGUMENTS or ARGUMENTS["static_build"]!="yes":
    if env["platform"] == "macos" or env["platform"] == "ios":
        library = env.SharedLibrary(
            "bin/addons/godot_sandbox/bin/libgodot_riscv{}.framework/libgodot_riscv{}".format(
                env["suffix"], env["suffix"]
            ),
            source=sources,
        )
    else:
        library = env.SharedLibrary(
            "bin/addons/godot_sandbox/bin/libgodot_riscv{}{}".format(env["suffix"], env["SHLIBSUFFIX"]),
            source=sources,
        )
    Default(library)
else:
    library = env.StaticLibrary(
        "bin/libsandbox{}{}".format(env["suffix"], env["LIBSUFFIX"]),
        source=sources,
    )
    Default(library)

```

`SCsub`:

```
#!/usr/bin/env python
from misc.utility.scons_hints import *
import os

Import("env")
Import("env_modules")


#region Helpers
def get_addon_platform():
    return env["platform"].replace("linuxbsd", "linux")

def get_addon_threads():
    return "yes" if env["threads"] else "no"

def get_addon_llvm():
    return "yes" if env.get("use_llvm", False) else "no"

def get_addon_devbuild():
    return "yes" if env.get("dev_build", False) else "no"

def get_addon_target():
    return "template_release" if env["target"] == "editor" else env["target"]

def get_addon_mingw():
    return "yes" if env.get("use_mingw", False) else "no"

if (env.get("use_mingw", False) and env["platform"] == "windows") or env["platform"] != "windows":
    # TODO remove when godot-cpp 4.5 is released
    # Replace in godot-cpp android ndk from "23.2.8568313" to "28.1.13356709"
    if env["platform"] == "android":
        os.system("sed -i 's/23.2.8568313/28.1.13356709/g' ext/godot-cpp/tools/android.py")

    # Only build if we are not using MSVC
    os.system(f"scons static_build=yes platform={get_addon_platform()} target={get_addon_target()} arch={env['arch']} precision={env['precision']} threads={get_addon_threads()} dev_build={get_addon_devbuild()} use_llvm={get_addon_llvm()} lto={env['lto']} use_mingw={get_addon_mingw()}")

    def get_sufix_before():
        suffix = f".{get_addon_platform()}.{env['target']}"
        if env["dev_build"]:
            suffix += ".dev"
        if env["precision"] == "double":
            suffix += ".double"
        suffix += f".{env['arch']}"
        if not env["threads"]:
            suffix += ".nothreads"
        if env.get("use_llvm", False):
            suffix += ".llvm"
        return suffix


    def get_sufix_after():
        suffix = f".{get_addon_platform()}.{get_addon_target()}"
        if env["dev_build"]:
            suffix += ".dev"
        if env["precision"] == "double":
            suffix += ".double"
        suffix += f".{env['arch']}"
        if not env["threads"]:
            suffix += ".nothreads"
        return suffix
    os.system("ls -l bin/")
    # Rename if target is editor
    if env["target"] == "editor" or env["platform"] == "windows":
        lib_extension = ".a" if env["platform"] != "windows" else ".lib"
        lib_prefix = "lib" if env["platform"] != "windows" else ""
        if env.get("use_mingw", False):
            lib_extension = ".a"
            lib_prefix = "lib"
        # Rename our lib
        os.rename(
            f"bin/libsandbox{get_sufix_after()}{lib_extension}",
            f"bin/{lib_prefix}sandbox{get_sufix_before()}{lib_extension}"
        )
        # Rename godot-cpp lib
        os.rename(
            f"ext/godot-cpp/bin/libgodot-cpp{get_sufix_after()}{lib_extension}",
            f"ext/godot-cpp/bin/{lib_prefix}godot-cpp{get_sufix_before()}{lib_extension}"
        )
            
    # Do an ls on bin folder
    os.system("ls -l bin/")
else:
    print("Skipping sandbox build. All platforms minus windows without mingw are supported.")
#endregion


env_sandbox = env_modules.Clone()
suffix = get_sufix_before()
godot_cpp_path = "#modules/sandbox/ext/godot-cpp/bin"
if env["platform"] == "ios":
    sandbox = f"#modules/sandbox/bin/libsandbox{suffix}.a"
    godotcpp_path = f"#modules/sandbox/ext/godot-cpp/bin/libgodot-cpp{suffix}.a"
    env.Append(LIBS=[env.File(sandbox), env.File(godotcpp_path)])
elif env["platform"] != "windows" or env.get("use_mingw", False):
    env.Append(LIBPATH=["#modules/sandbox/bin", godot_cpp_path])
    env.Append(LIBS=[f"sandbox{suffix}", f"godot-cpp{suffix}"])
else:
    env.Append(LIBPATH=["#modules/sandbox/bin", godot_cpp_path])
    env.Append(LIBS=["sandbox", "godot-cpp"])


env.add_source_files(env.modules_sources, "register_types.cpp")

```

`THIRDPARTY.txt`:

```txt
GDRust Syntax incorporates third-party material from the projects listed below.

Godot Engine (https://github.com/godotengine/godot)

    Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md).
    Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

godot-cpp (https://github.com/godotengine/godot-cpp)

    Copyright (c) 2017-present Godot Engine contributors.
    Copyright (c) 2022-present Mikael Hermansson.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

Godot Jolt (https://github.com/godot-jolt/godot-jolt)

    Copyright (c) Mikael Hermansson and Godot Jolt contributors.

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


```

`bin/addons/godot_sandbox/Build.svg`:

```svg
<svg height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="m2.256 4.85 1.7 2.945 2.598-1.5 4.5 7.794a1 1-30 0 0 2.598-1.5l-4.65-8.054 3.464-2-.25-.433s-1.25-2.165-3.848-.665l-3.464 2-.31.063z" fill="#e0e0e0"/></svg>

```

`bin/addons/godot_sandbox/Build.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://dekr76nttv4lp"
path="res://.godot/imported/Build.svg-ec0c58031cc54b14eee4218baaf5b061.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/Build.svg"
dest_files=["res://.godot/imported/Build.svg-ec0c58031cc54b14eee4218baaf5b061.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/CPPScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(7.03086,0,0,7.03086,1.8125,15.1961)">
            <path d="M0.395,-0.566C0.372,-0.566 0.352,-0.561 0.334,-0.552C0.316,-0.542 0.301,-0.528 0.288,-0.51C0.275,-0.492 0.266,-0.469 0.259,-0.443C0.252,-0.417 0.249,-0.387 0.249,-0.354C0.249,-0.309 0.255,-0.271 0.266,-0.241C0.278,-0.21 0.295,-0.187 0.318,-0.171C0.341,-0.156 0.371,-0.148 0.406,-0.148C0.438,-0.148 0.468,-0.152 0.498,-0.161C0.527,-0.17 0.557,-0.181 0.587,-0.193L0.587,-0.03C0.555,-0.016 0.523,-0.006 0.49,0C0.457,0.007 0.422,0.01 0.385,0.01C0.307,0.01 0.244,-0.006 0.195,-0.036C0.145,-0.067 0.109,-0.11 0.086,-0.165C0.062,-0.219 0.051,-0.283 0.051,-0.355C0.051,-0.409 0.058,-0.458 0.073,-0.503C0.089,-0.548 0.111,-0.587 0.14,-0.62C0.169,-0.653 0.206,-0.679 0.249,-0.697C0.292,-0.715 0.341,-0.724 0.397,-0.724C0.431,-0.724 0.468,-0.72 0.506,-0.712C0.544,-0.704 0.582,-0.691 0.618,-0.674L0.559,-0.522C0.533,-0.534 0.507,-0.545 0.48,-0.553C0.453,-0.562 0.425,-0.566 0.395,-0.566Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,6.375,15.1961)">
            <path d="M0.358,-0.418L0.54,-0.418L0.54,-0.287L0.358,-0.287L0.358,-0.111L0.227,-0.111L0.227,-0.287L0.045,-0.287L0.045,-0.418L0.227,-0.418L0.227,-0.597L0.358,-0.597L0.358,-0.418Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,10.4946,15.1961)">
            <path d="M0.358,-0.418L0.54,-0.418L0.54,-0.287L0.358,-0.287L0.358,-0.111L0.227,-0.111L0.227,-0.287L0.045,-0.287L0.045,-0.418L0.227,-0.418L0.227,-0.597L0.358,-0.597L0.358,-0.418Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,14.6143,15.1961)">
        </g>
    </g>
</svg>

```

`bin/addons/godot_sandbox/CPPScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://dgdqxloioqcr6"
path="res://.godot/imported/CPPScript.svg-5893a7b0f23507340347760d609793b5.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/CPPScript.svg"
dest_files=["res://.godot/imported/CPPScript.svg-5893a7b0f23507340347760d609793b5.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/ELFScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(7.03086,0,0,7.03086,2.3429,15.1961)">
            <path d="M0.501,-0L0.077,-0L0.077,-0.714L0.501,-0.714L0.501,-0.559L0.27,-0.559L0.27,-0.447L0.484,-0.447L0.484,-0.292L0.27,-0.292L0.27,-0.157L0.501,-0.157L0.501,-0Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,6.20164,15.1961)">
            <path d="M0.077,-0L0.077,-0.714L0.27,-0.714L0.27,-0.156L0.545,-0.156L0.545,-0L0.077,-0Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,10.2938,15.1961)">
            <path d="M0.267,-0L0.077,-0L0.077,-0.714L0.499,-0.714L0.499,-0.559L0.267,-0.559L0.267,-0.423L0.481,-0.423L0.481,-0.268L0.267,-0.268L0.267,-0Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,14.0839,15.1961)">
        </g>
    </g>
</svg>

```

`bin/addons/godot_sandbox/ELFScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://c1hyk3aurfy38"
path="res://.godot/imported/ELFScript.svg-17bdc324794d9b10d64000e9fdd221e6.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/ELFScript.svg"
dest_files=["res://.godot/imported/ELFScript.svg-17bdc324794d9b10d64000e9fdd221e6.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/JSScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(0.0264047,0,0,0.0264047,1.27202,3.31788)">
            <path d="M142.705,427.548C142.705,422.51 144.182,416.647 147.135,409.959C150.088,403.271 153.302,398.711 156.776,396.279C163.377,401.143 170.066,403.575 176.841,403.575L184.918,402.272C194.299,399.493 199.163,392.023 199.511,379.863L199.511,313.416L178.665,313.416C175.711,313.416 173.627,309.681 172.411,302.211C171.89,298.563 171.629,294.828 171.629,291.006C171.629,287.184 171.89,283.449 172.411,279.801C173.627,272.332 175.711,268.597 178.665,268.597L240.682,268.597C244.156,268.597 246.762,269.596 248.499,271.593C250.236,273.591 251.105,275.98 251.105,278.759L251.105,401.751C251.105,418.775 245.416,431.717 234.037,440.577C222.659,449.437 209.022,453.866 193.127,453.866C177.231,453.866 164.854,451.521 155.994,446.831C147.135,442.14 142.705,435.713 142.705,427.548Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M280.55,387.419C283.851,390.025 289.54,393.586 297.618,398.103C305.696,402.62 313.426,404.878 320.809,404.878C328.192,404.878 331.883,402.012 331.883,396.279C331.883,393.673 330.841,391.371 328.757,389.374C326.672,387.376 322.85,385.074 317.291,382.468C311.732,379.863 307.563,377.822 304.784,376.345C302.004,374.868 298.313,372.436 293.709,369.049C289.106,365.661 285.588,362.144 283.156,358.495C276.207,348.594 272.733,335.999 272.733,320.712C272.733,305.425 278.422,292.526 289.8,282.016C301.179,271.506 316.075,266.251 334.489,266.251C346.997,266.251 358.549,267.598 369.146,270.29C379.743,272.983 385.215,276.501 385.562,280.844L385.562,282.407C385.562,288.487 383.651,296.174 379.829,305.468C376.008,314.762 373.315,319.93 371.752,320.972C360.634,315.24 350.688,312.373 341.916,312.373C333.143,312.373 328.757,315.5 328.757,321.754C328.757,325.576 331.97,328.963 338.398,331.917C339.788,332.612 341.785,333.567 344.391,334.783C346.997,335.999 349.993,337.432 353.381,339.083C356.768,340.733 360.417,342.817 364.325,345.336C368.234,347.855 372.446,351.199 376.963,355.369C386.17,364.054 390.774,375.52 390.774,389.765C390.774,408.352 385.649,423.553 375.4,435.365C365.15,447.178 349.342,453.258 327.975,453.606C317.552,453.606 308.128,452.737 299.702,451C291.277,449.263 283.937,445.875 277.684,440.838C271.43,435.8 268.303,429.72 268.303,422.597C268.303,415.475 269.606,408.396 272.211,401.36C274.817,394.325 277.597,389.678 280.55,387.419Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
    </g>
</svg>

```

`bin/addons/godot_sandbox/JSScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://dyngc5hvivrwq"
path="res://.godot/imported/JSScript.svg-23ea76ef5bb204bfc79c51e96fbd0440.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/JSScript.svg"
dest_files=["res://.godot/imported/JSScript.svg-23ea76ef5bb204bfc79c51e96fbd0440.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/RustScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1,0,0,1,1.14211,14.6817)">
        <g>
            <g transform="matrix(6,0,0,6,0,0)">
                <path d="M0.241,-0.014C0.241,-0.003 0.209,0.002 0.146,0.002C0.082,0.002 0.05,-0.003 0.05,-0.013L0.05,-0.665C0.05,-0.688 0.062,-0.7 0.087,-0.7L0.278,-0.7C0.453,-0.7 0.541,-0.632 0.541,-0.495C0.541,-0.454 0.533,-0.416 0.517,-0.383C0.501,-0.349 0.478,-0.322 0.449,-0.302L0.575,-0.092C0.57,-0.076 0.552,-0.058 0.523,-0.037C0.483,-0.008 0.45,0.006 0.424,0.006C0.398,0.006 0.379,-0.003 0.366,-0.022L0.272,-0.241L0.241,-0.241L0.241,-0.014ZM0.241,-0.523L0.241,-0.373L0.246,-0.373C0.309,-0.373 0.341,-0.399 0.341,-0.452C0.341,-0.476 0.335,-0.494 0.323,-0.506C0.31,-0.517 0.29,-0.523 0.262,-0.523L0.241,-0.523Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(6,0,0,6,3.54,0)">
                <path d="M0.377,-0.68C0.377,-0.693 0.413,-0.7 0.486,-0.7C0.558,-0.7 0.594,-0.693 0.594,-0.68L0.594,-0.221C0.594,-0.153 0.57,-0.098 0.521,-0.055C0.472,-0.012 0.405,0.01 0.32,0.01C0.234,0.01 0.164,-0.012 0.111,-0.057C0.057,-0.101 0.03,-0.161 0.03,-0.236L0.03,-0.679C0.03,-0.692 0.066,-0.699 0.139,-0.699C0.211,-0.699 0.247,-0.692 0.247,-0.679L0.247,-0.228C0.247,-0.215 0.254,-0.204 0.268,-0.196C0.283,-0.188 0.298,-0.184 0.314,-0.184C0.33,-0.184 0.345,-0.188 0.358,-0.195C0.371,-0.202 0.377,-0.213 0.377,-0.228L0.377,-0.68Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(6,0,0,6,7.308,0)">
                <path d="M0.076,-0.244C0.089,-0.234 0.111,-0.22 0.142,-0.203C0.173,-0.186 0.202,-0.177 0.231,-0.177C0.259,-0.177 0.273,-0.188 0.273,-0.21C0.273,-0.22 0.269,-0.229 0.261,-0.237C0.253,-0.244 0.238,-0.253 0.217,-0.263C0.196,-0.273 0.18,-0.281 0.169,-0.287C0.158,-0.292 0.144,-0.302 0.127,-0.315C0.109,-0.328 0.095,-0.341 0.086,-0.355C0.059,-0.393 0.046,-0.441 0.046,-0.5C0.046,-0.559 0.068,-0.608 0.112,-0.649C0.155,-0.689 0.212,-0.709 0.283,-0.709C0.331,-0.709 0.375,-0.704 0.416,-0.694C0.457,-0.683 0.478,-0.67 0.479,-0.653L0.479,-0.647C0.479,-0.624 0.472,-0.594 0.457,-0.559C0.442,-0.523 0.432,-0.503 0.426,-0.499C0.383,-0.521 0.345,-0.532 0.312,-0.532C0.278,-0.532 0.261,-0.52 0.261,-0.496C0.261,-0.481 0.273,-0.468 0.298,-0.457C0.303,-0.454 0.343,-0.436 0.356,-0.43C0.369,-0.423 0.383,-0.415 0.398,-0.406C0.413,-0.396 0.429,-0.383 0.446,-0.367C0.481,-0.334 0.499,-0.29 0.499,-0.235C0.499,-0.164 0.479,-0.105 0.44,-0.06C0.401,-0.015 0.34,0.009 0.258,0.01C0.218,0.01 0.182,0.007 0.15,-0C0.117,-0.007 0.089,-0.02 0.065,-0.039C0.041,-0.058 0.029,-0.082 0.029,-0.109C0.029,-0.136 0.034,-0.164 0.044,-0.191C0.054,-0.218 0.065,-0.235 0.076,-0.244Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(6,0,0,6,10.494,0)">
                <path d="M0.351,-0.016C0.351,-0.003 0.318,0.004 0.252,0.004C0.186,0.004 0.153,-0.003 0.153,-0.016L0.153,-0.518L0.033,-0.518C0.022,-0.518 0.014,-0.533 0.009,-0.564C0.007,-0.579 0.006,-0.594 0.006,-0.609C0.006,-0.624 0.007,-0.639 0.009,-0.654C0.014,-0.685 0.022,-0.7 0.033,-0.7L0.468,-0.7C0.479,-0.7 0.487,-0.685 0.492,-0.654C0.494,-0.639 0.495,-0.624 0.495,-0.609C0.495,-0.594 0.494,-0.579 0.492,-0.564C0.487,-0.533 0.479,-0.518 0.468,-0.518L0.351,-0.518L0.351,-0.016Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
        </g>
    </g>
</svg>

```

`bin/addons/godot_sandbox/RustScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://bby34e4wi848l"
path="res://.godot/imported/RustScript.svg-f6bb6849e5f67b9483951f43842fbc0a.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/RustScript.svg"
dest_files=["res://.godot/imported/RustScript.svg-f6bb6849e5f67b9483951f43842fbc0a.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/SafeGDScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(255,200,41);fill-rule:nonzero;"/>
    <g transform="matrix(1,0,0,-1,0,16)">
        <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(255,218,95);fill-rule:nonzero;"/>
    </g>
    <g transform="matrix(1,0,0,-1,0,16)">
        <path d="M12.742,6.435C12.736,6.417 11.581,5.996 8,5.996C4.419,5.996 3.254,6.437 3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435Z" style="fill:rgb(255,200,41);fill-rule:nonzero;"/>
    </g>
</svg>

```

`bin/addons/godot_sandbox/SafeGDScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://buylpocthb23k"
path="res://.godot/imported/SafeGDScript.svg-ddcc62be8683292014c894723f385993.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/SafeGDScript.svg"
dest_files=["res://.godot/imported/SafeGDScript.svg-ddcc62be8683292014c894723f385993.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/uastc_level=0
compress/rdo_quality_loss=0.0
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/channel_remap/red=0
process/channel_remap/green=1
process/channel_remap/blue=2
process/channel_remap/alpha=3
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/Sandbox.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M8,1L1,4L1,12L8,15L15,12L15,4L8,1Z" style="fill:rgb(255,200,41);fill-rule:nonzero;"/>
    <path d="M8,15L1,12L1,4L8,7L8,15Z" style="fill:rgb(255,218,95);fill-rule:nonzero;"/>
    <path d="M1,4L8,7L15,4L8,1L1,4Z" style="fill:rgb(255,226,162);fill-rule:nonzero;"/>
</svg>

```

`bin/addons/godot_sandbox/Sandbox.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://c6t7ct1k43itk"
path="res://.godot/imported/Sandbox.svg-133e2183fe3e2e6e1ce418581d6346e9.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/Sandbox.svg"
dest_files=["res://.godot/imported/Sandbox.svg-133e2183fe3e2e6e1ce418581d6346e9.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/TSScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(0.0264047,0,0,0.0264047,1.27202,3.31788)">
            <path d="M226.611,446.831C226.611,450.305 218.012,452.042 200.814,452.042C183.616,452.042 175.017,450.305 175.017,446.831L175.017,316.022L143.747,316.022C140.794,316.022 138.71,312.026 137.494,304.035C136.972,300.213 136.712,296.305 136.712,292.309C136.712,288.314 136.972,284.405 137.494,280.583C138.71,272.592 140.794,268.597 143.747,268.597L257.098,268.597C260.051,268.597 262.136,272.592 263.352,280.583C263.873,284.405 264.134,288.314 264.134,292.309C264.134,296.305 263.873,300.213 263.352,304.035C262.136,312.026 260.051,316.022 257.098,316.022L226.611,316.022L226.611,446.831Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M285.761,387.419C289.062,390.025 294.751,393.586 302.829,398.103C310.907,402.62 318.637,404.878 326.02,404.878C333.403,404.878 337.095,402.012 337.095,396.279C337.095,393.673 336.053,391.371 333.968,389.374C331.883,387.376 328.062,385.074 322.503,382.468C316.944,379.863 312.775,377.822 309.995,376.345C307.216,374.868 303.524,372.436 298.921,369.049C294.317,365.661 290.799,362.144 288.367,358.495C281.419,348.594 277.944,335.999 277.944,320.712C277.944,305.425 283.633,292.526 295.012,282.016C306.39,271.506 321.287,266.251 339.701,266.251C352.208,266.251 363.761,267.598 374.357,270.29C384.954,272.983 390.426,276.501 390.774,280.844L390.774,282.407C390.774,288.487 388.863,296.174 385.041,305.468C381.219,314.762 378.527,319.93 376.963,320.972C365.845,315.24 355.9,312.373 347.127,312.373C338.354,312.373 333.968,315.5 333.968,321.754C333.968,325.576 337.182,328.963 343.609,331.917C344.999,332.612 346.997,333.567 349.603,334.783C352.208,335.999 355.205,337.432 358.592,339.083C361.98,340.733 365.628,342.817 369.537,345.336C373.445,347.855 377.658,351.199 382.175,355.369C391.382,364.054 395.985,375.52 395.985,389.765C395.985,408.352 390.861,423.553 380.611,435.365C370.362,447.178 354.554,453.258 333.186,453.606C322.763,453.606 313.339,452.737 304.914,451C296.488,449.263 289.149,445.875 282.895,440.838C276.641,435.8 273.514,429.72 273.514,422.597C273.514,415.475 274.817,408.396 277.423,401.36C280.029,394.325 282.808,389.678 285.761,387.419Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
    </g>
</svg>

```

`bin/addons/godot_sandbox/TSScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://dwt18y2lxiwdp"
path="res://.godot/imported/TSScript.svg-ed1342b6ff41130286cd9355ab299965.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/TSScript.svg"
dest_files=["res://.godot/imported/TSScript.svg-ed1342b6ff41130286cd9355ab299965.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/ZigScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(0.0264047,0,0,0.0264047,1.27202,3.31788)">
            <path d="M79.385,316.022C76.432,316.022 74.347,312.026 73.131,304.035C72.61,300.734 72.35,297.086 72.35,293.091C72.35,289.095 72.784,284.926 73.652,280.583C75.216,272.592 77.822,268.597 81.47,268.597L177.883,268.597C188.48,268.597 195.341,278.238 198.468,297.521C199.163,301.69 199.511,304.73 199.511,306.641L138.536,399.145L186.742,399.145C190.564,399.145 193.257,403.315 194.82,411.653C195.515,415.648 195.863,419.818 195.863,424.161C195.863,428.504 195.341,433.107 194.299,437.971C192.388,446.657 189.435,451 185.44,451L84.075,451C82.512,451 79.689,445.745 75.607,435.235C71.524,424.725 69.483,418.167 69.483,415.562C69.483,412.956 69.744,411.306 70.265,410.611L131.24,316.022L79.385,316.022Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M236.513,406.181L236.513,313.416L218.012,313.416C215.058,313.416 212.974,309.681 211.758,302.211C211.237,298.563 210.976,294.828 210.976,291.006C210.976,287.184 211.237,283.449 211.758,279.801C212.974,272.332 215.058,268.597 218.012,268.597L305.565,268.597C308.518,268.597 310.516,272.332 311.558,279.801C312.253,283.449 312.601,287.184 312.601,291.006C312.601,294.828 312.253,298.563 311.558,302.211C310.516,309.681 308.518,313.416 305.565,313.416L288.107,313.416L288.107,406.181L306.347,406.181C309.3,406.181 311.385,409.916 312.601,417.386C313.296,421.034 313.643,424.769 313.643,428.59C313.643,432.412 313.296,436.147 312.601,439.795C311.385,447.265 309.3,451 306.347,451L218.533,451C215.58,451 213.582,447.265 212.54,439.795C211.845,436.147 211.497,432.412 211.497,428.59C211.497,424.769 211.845,421.034 212.54,417.386C213.582,409.916 215.58,406.181 218.533,406.181L236.513,406.181Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M427.515,396.54L428.036,361.101C428.036,358.669 430.555,357.062 435.593,356.281C440.631,355.499 444.8,355.108 448.1,355.108L458.263,355.89C464.864,356.932 468.165,358.756 468.165,361.362L467.122,442.922C463.648,445.354 456.656,447.743 446.146,450.088C435.636,452.433 423.606,453.606 410.056,453.606C384.867,453.606 364.542,445.441 349.081,429.112C333.621,412.782 325.89,388.809 325.89,357.193C325.89,330.266 333.447,308.378 348.56,291.527C363.674,274.677 384.607,266.251 411.359,266.251C423.519,266.251 434.507,267.424 444.322,269.769C454.137,272.114 460.869,275.285 464.517,279.28C464.69,280.67 464.777,283.276 464.777,287.098C464.777,290.919 463.474,296.348 460.869,303.384C458.263,310.419 455.31,315.674 452.009,319.148C448.708,322.623 446.32,324.36 444.843,324.36C443.367,324.36 441.803,323.709 440.153,322.406C438.503,321.103 435.245,319.713 430.381,318.236C425.517,316.76 420.827,316.022 416.31,316.022C405.54,316.022 396.81,319.496 390.122,326.445C383.434,333.393 380.09,344.164 380.09,358.756C380.09,373.348 383.521,384.423 390.383,391.979C397.245,399.536 405.149,403.315 414.095,403.315C423.042,403.315 427.515,401.056 427.515,396.54Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
    </g>
</svg>

```

`bin/addons/godot_sandbox/ZigScript.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://cqvle38bxnums"
path="res://.godot/imported/ZigScript.svg-98a55c5bce519950f034c0bae8cd8a3b.ctex"
metadata={
"has_editor_variant": true,
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/ZigScript.svg"
dest_files=["res://.godot/imported/ZigScript.svg-98a55c5bce519950f034c0bae8cd8a3b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=true
editor/convert_colors_with_editor_theme=false

```

`bin/addons/godot_sandbox/downloader.gd`:

```gd
@tool
extends Window

var http_cmake: HTTPRequest
var http_zig: HTTPRequest
var http_ninja: HTTPRequest

@export var cmake_status: RichTextLabel
@export var make_status: RichTextLabel
@export var git_status: RichTextLabel
@export var zig_status: RichTextLabel
@export var os_tab_container: TabContainer

var status = {
	"not_installed": "[color=red]Not installed[/color]",
	"installed": "[color=green]Installed[/color]",
	"installing": "[color=yellow]Installing[/color]"
}

func _ready():
	match OS.get_name():
		"Windows":
			os_tab_container.current_tab = 0
		"Linux":
			os_tab_container.current_tab = 2
		"macOS":
			os_tab_container.current_tab = 1
			
	title = "Godot Sandbox Dependencies" + " ( " + OS.get_name() + " " + Engine.get_architecture_name() + " )"
	http_cmake = HTTPRequest.new()
	http_zig = HTTPRequest.new()
	http_ninja = HTTPRequest.new()
	add_child(http_cmake)
	add_child(http_zig)
	add_child(http_ninja)

	http_cmake.request_completed.connect(_on_download_complete.bind("cmake"))
	http_zig.request_completed.connect(_on_download_complete.bind("zig"))
	http_ninja.request_completed.connect(_on_download_complete.bind("ninja"))

	_update_status()

func _update_status():
	if ProjectSettings.get_setting("editor/script/skip", false):
		hide()
		return
	# CMake
	var output := []
	var exit_code := OS.execute(ProjectSettings.get_setting("editor/script/cmake", "cmake"), ["--version"], output, true)
	
	if exit_code == 0:
		cmake_status.text = "CMake: " + status["installed"]
	else:
		print("CMake not installed: ", output)
		cmake_status.text = "CMake: " + status["not_installed"]
		show()
	output = []
	# Make (Linux/macOS) or Ninja (Windows)
	if OS.get_name() == "Windows":
		exit_code = OS.execute(ProjectSettings.get_setting("editor/script/make", "ninja"), ["--version"], output, true)
		if exit_code == 0:
			make_status.text = "Ninja: " + status["installed"]
		else:
			print("Ninja not installed: ", output)
			make_status.text = "Ninja: " + status["not_installed"]
			show()
	else:
		exit_code = OS.execute(ProjectSettings.get_setting("editor/script/make", "make"), ["--version"], output, true)
		if exit_code == 0:
			make_status.text = "Make: " + status["installed"]
		else:
			print("Make not installed: ", output)
			make_status.text = "Make: " + status["not_installed"]
			show()

	output = []
	# Git
	exit_code = OS.execute(ProjectSettings.get_setting("editor/script/git", "git"), ["--version"], output, true)
	
	if exit_code == 0:
		git_status.text = "Git: " + status["installed"]
	else:
		print("Git not installed: ", output)
		git_status.text = "Git: " + status["not_installed"]
		show()
	output = []
	# Zig
	exit_code = OS.execute(ProjectSettings.get_setting("editor/script/zig", "zig"), ["--help"], output, true)
	
	if exit_code == 0:
		zig_status.text = "Zig: " + status["installed"]
	else:
		print("Zig not installed: ", output)
		zig_status.text = "Zig: " + status["not_installed"]
		show()

func _on_label_meta_clicked(meta: Variant) -> void:
	OS.shell_open(str(meta))

func _on_cmake_button_pressed() -> void:
	cmake_status.text = status["installing"]
	var download_url = "None"
	match OS.get_name():
		"Windows":
			if OS.has_feature("x86_64"):
				download_url = "https://github.com/Kitware/CMake/releases/download/v4.1.0-rc3/cmake-4.1.0-rc3-windows-x86_64.zip"
			elif OS.has_feature("x86_32"):
				download_url = "https://github.com/Kitware/CMake/releases/download/v4.1.0-rc3/cmake-4.1.0-rc3-windows-i386.zip"
			elif OS.has_feature("arm64"):
				download_url = "https://github.com/Kitware/CMake/releases/download/v4.1.0-rc3/cmake-4.1.0-rc3-windows-arm64.zip"
		"Linux":
			if OS.has_feature("x86_64"):
				download_url = "https://github.com/Kitware/CMake/releases/download/v4.1.0-rc3/cmake-4.1.0-rc3-linux-x86_64.tar.gz"
			elif OS.has_feature("arm64"):
				download_url = "https://github.com/Kitware/CMake/releases/download/v4.1.0-rc3/cmake-4.1.0-rc3-linux-aarch64.tar.gz"
		"macOS":
			download_url = "https://github.com/Kitware/CMake/releases/download/v4.1.0-rc3/cmake-4.1.0-rc3-macos-universal.tar.gz"
		_:
			print("Cannot find download URL")
			_update_status()
			return
	var err = http_cmake.request(download_url)
	if err != OK:
		print("Failed to start HTTP request: %s" % err)

func extract_all_from_zip(path: String, dest: String):
	DirAccess.make_dir_recursive_absolute(dest)
	# On Linux and Mac, use tar
	var os_name = OS.get_name()
	if os_name == "Linux" or os_name == "macOS":
		var args = ["-xzf", ProjectSettings.globalize_path(path), "-C", ProjectSettings.globalize_path(dest)]
		var output := []
		var exit_code := OS.execute("tar", args, output)
		
		if exit_code == 0:
			print("âœ… Extraction succeeded:\n", output)
		else:
			print("âŒ Extraction failed (code %d):\n%s" % [exit_code, output])
		return
	# On windows use zipreader
	var reader = ZIPReader.new()
	var err = reader.open(path)
	if err != OK:
		print("Error opening zip: ", path, " ", err)
		return
	DirAccess.make_dir_recursive_absolute(dest)
	var root_dir = DirAccess.open(dest)

	var files = reader.get_files()
	for file_path in files:
		if file_path.ends_with("/"):
			root_dir.make_dir_recursive(file_path)
			continue

		root_dir.make_dir_recursive(root_dir.get_current_dir().path_join(file_path).get_base_dir())
		var file = FileAccess.open(root_dir.get_current_dir().path_join(file_path), FileAccess.WRITE)
		var buffer = reader.read_file(file_path)
		file.store_buffer(buffer)

func _on_download_complete(result, response_code, headers, body, downloaded_name):
	if result != HTTPRequest.RESULT_SUCCESS:
		print("Download failed with code: %d" % response_code)
		_update_status()
		return

	DirAccess.make_dir_recursive_absolute("user://godot-sandbox/tmp")
	var path = "user://godot-sandbox/tmp/%s.zip" % downloaded_name
	var file = FileAccess.open(path, FileAccess.WRITE)
	if not file:
		print("Failed to save downloaded file")
		_update_status()
		return

	file.store_buffer(body)
	file.close()

	print("CMake downloaded to: %s" % path)
	extract_all_from_zip(path, "user://godot-sandbox/tmp/%s" % downloaded_name)
	DirAccess.make_dir_recursive_absolute("user://godot-sandbox/%s" % downloaded_name)
	var first_subfolder = ("user://godot-sandbox/tmp/%s" % downloaded_name) + "/" + DirAccess.open("user://godot-sandbox/tmp/%s" % downloaded_name).get_directories()[0]
	print("Renaming ", first_subfolder, " to ", "user://godot-sandbox/%s" % downloaded_name)
	await get_tree().create_timer(1.0).timeout
	var err = DirAccess.rename_absolute(first_subfolder, "user://godot-sandbox/%s" % downloaded_name)
	if err != OK:
		print("Error renaming %s " % downloaded_name)
		push_error("Error code: ", err)
	var binary_name = downloaded_name
	match OS.get_name():
		"Windows":
			if downloaded_name == "cmake":
				binary_name = "bin/cmake.exe"
		"Linux":
			if downloaded_name == "cmake":
				binary_name = "bin/cmake"
		"macOS":
			if downloaded_name == "cmake":
				binary_name = "CMake.app/Contents/bin/cmake"
	ProjectSettings.set("editor/script/%s" % downloaded_name, ProjectSettings.globalize_path("user://godot-sandbox/%s" % downloaded_name).path_join(binary_name))
	ProjectSettings.save()
	_update_status()


func _on_about_to_popup() -> void:
	_update_status()


func _on_zig_button_pressed() -> void:
	zig_status.text = status["installing"]
	var download_url = "None"
	match OS.get_name():
		"Windows":
			if OS.has_feature("x86_64"):
				download_url = "https://ziglang.org/download/0.14.1/zig-x86_64-windows-0.14.1.zip"
			elif OS.has_feature("x86_32"):
				download_url = "https://ziglang.org/download/0.14.1/zig-x86-windows-0.14.1.zip"
			elif OS.has_feature("arm64"):
				download_url = "https://ziglang.org/download/0.14.1/zig-aarch64-windows-0.14.1.zip"
		"Linux":
			if OS.has_feature("x86_64"):
				download_url = "https://ziglang.org/download/0.14.1/zig-x86_64-linux-0.14.1.tar.xz"
			elif OS.has_feature("arm64"):
				download_url = "https://ziglang.org/download/0.14.1/zig-aarch64-linux-0.14.1.tar.xz"
		"macOS":
			if OS.has_feature("x86_64"):
				download_url = "https://ziglang.org/download/0.14.1/zig-x86_64-macos-0.14.1.tar.xz"
			elif OS.has_feature("arm64"):
				download_url = "https://ziglang.org/download/0.14.1/zig-aarch64-macos-0.14.1.tar.xz"
		_:
			print("Cannot find download URL")
			_update_status()
			return
	var err = http_zig.request(download_url)
	if err != OK:
		print("Failed to start HTTP request: %s" % err)


func _on_button_pressed() -> void:
	hide()


func _on_skip_pressed() -> void:
	ProjectSettings.set_setting("editor/script/skip", true)
	ProjectSettings.save()
	hide()

```

`bin/addons/godot_sandbox/downloader.tscn`:

```tscn
[gd_scene load_steps=3 format=3 uid="uid://l82vam6qgpgf"]

[ext_resource type="Script" uid="uid://dyk2fnsixyben" path="res://addons/godot_sandbox/downloader.gd" id="1_843n5"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_843n5"]
bg_color = Color(0.129412, 0.14902, 0.180392, 1)

[node name="Downloader" type="Window" node_paths=PackedStringArray("cmake_status", "make_status", "git_status", "zig_status", "os_tab_container")]
oversampling_override = 1.0
title = "Godot Sandbox Dependencies ( macOS arm64 )"
initial_position = 2
size = Vector2i(1240, 950)
visible = false
wrap_controls = true
script = ExtResource("1_843n5")
cmake_status = NodePath("Panel/VBoxContainer/CmakeStatus")
make_status = NodePath("Panel/VBoxContainer/MakeStatus")
git_status = NodePath("Panel/VBoxContainer/GitStatus")
zig_status = NodePath("Panel/VBoxContainer/ZigStatus")
os_tab_container = NodePath("Panel/VBoxContainer/TabContainer")

[node name="Panel" type="Panel" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="VBoxContainer" type="VBoxContainer" parent="Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3

[node name="Label2" type="RichTextLabel" parent="Panel/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 4
focus_mode = 2
bbcode_enabled = true
text = "If you don't use Safe GDScript, you need to install the following dependencies (for elf compilation): [url=https://cmake.org/download/]CMake[/url], [url=https://ziglang.org/download/]Zig[/url], [url=https://git-scm.com/downloads]Git[/url]. On windows need additionally [url=https://ninja-build.org]Ninja[/url].
Either install with the following [b]commands[/b], or download manually to user://godot-sandbox using the below [b]buttons[/b].
Aslo make sure the paths are set correctly in the [b]PATH[/b] or in the following Project Settings:
[color=gray]\"editor/script/cmake\", \"editor/script/zig\", \"editor/script/git\", \"editor/script/make\"[/color]"
fit_content = true
selection_enabled = true

[node name="TabContainer" type="TabContainer" parent="Panel/VBoxContainer"]
layout_mode = 2
current_tab = 1

[node name="Windows" type="VBoxContainer" parent="Panel/VBoxContainer/TabContainer"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
metadata/_tab_index = 0

[node name="Label" type="RichTextLabel" parent="Panel/VBoxContainer/TabContainer/Windows"]
layout_mode = 2
size_flags_vertical = 3
focus_mode = 2
bbcode_enabled = true
text = "Commands:
[color=teal]
winget install --id Kitware.CMake -e
winget install --id=zig.zig -e
winget install --id Git.Git -e
winget install --id Ninja-build.Ninja -e
[/color]"
fit_content = true
selection_enabled = true

[node name="macOS" type="VBoxContainer" parent="Panel/VBoxContainer/TabContainer"]
layout_mode = 2
size_flags_horizontal = 3
metadata/_tab_index = 1

[node name="Label" type="RichTextLabel" parent="Panel/VBoxContainer/TabContainer/macOS"]
layout_mode = 2
size_flags_vertical = 3
focus_mode = 2
bbcode_enabled = true
text = "Commands:
[color=teal]
/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"
brew install git cmake zig
[/color]"
fit_content = true
selection_enabled = true

[node name="Linux" type="VBoxContainer" parent="Panel/VBoxContainer/TabContainer"]
visible = false
layout_mode = 2
size_flags_horizontal = 3
metadata/_tab_index = 2

[node name="Label" type="RichTextLabel" parent="Panel/VBoxContainer/TabContainer/Linux"]
layout_mode = 2
size_flags_vertical = 3
focus_mode = 2
bbcode_enabled = true
text = "Commands:
[color=teal]
sudo apt install git cmake
[/color]"
fit_content = true
selection_enabled = true

[node name="HBoxContainer" type="HBoxContainer" parent="Panel/VBoxContainer"]
layout_mode = 2

[node name="CmakeButton" type="Button" parent="Panel/VBoxContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_styles/normal = SubResource("StyleBoxFlat_843n5")
text = "Download CMake"

[node name="ZigButton" type="Button" parent="Panel/VBoxContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_styles/normal = SubResource("StyleBoxFlat_843n5")
text = "Download Zig"

[node name="CmakeStatus" type="RichTextLabel" parent="Panel/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "CMake: [color=green]Installed[/color]"
fit_content = true

[node name="ZigStatus" type="RichTextLabel" parent="Panel/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Zig: [color=red]Not installed[/color]"
fit_content = true

[node name="GitStatus" type="RichTextLabel" parent="Panel/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Git: [color=green]Installed[/color]"
fit_content = true

[node name="MakeStatus" type="RichTextLabel" parent="Panel/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Make: [color=green]Installed[/color]"
fit_content = true

[node name="Panel" type="VBoxContainer" parent="Panel/VBoxContainer"]
layout_mode = 2

[node name="Close" type="Button" parent="Panel/VBoxContainer/Panel"]
layout_mode = 2
text = "Close"

[node name="Skip" type="Button" parent="Panel/VBoxContainer/Panel"]
layout_mode = 2
text = "Skip"

[connection signal="about_to_popup" from="." to="." method="_on_about_to_popup"]
[connection signal="meta_clicked" from="Panel/VBoxContainer/Label2" to="." method="_on_label_meta_clicked"]
[connection signal="meta_clicked" from="Panel/VBoxContainer/TabContainer/Windows/Label" to="." method="_on_label_meta_clicked"]
[connection signal="meta_clicked" from="Panel/VBoxContainer/TabContainer/macOS/Label" to="." method="_on_label_meta_clicked"]
[connection signal="meta_clicked" from="Panel/VBoxContainer/TabContainer/Linux/Label" to="." method="_on_label_meta_clicked"]
[connection signal="pressed" from="Panel/VBoxContainer/HBoxContainer/CmakeButton" to="." method="_on_cmake_button_pressed"]
[connection signal="pressed" from="Panel/VBoxContainer/HBoxContainer/ZigButton" to="." method="_on_zig_button_pressed"]
[connection signal="pressed" from="Panel/VBoxContainer/Panel/Close" to="." method="_on_button_pressed"]
[connection signal="pressed" from="Panel/VBoxContainer/Panel/Skip" to="." method="_on_skip_pressed"]

```

`bin/addons/godot_sandbox/icon.png.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://ysbqgjhowuoc"
path="res://.godot/imported/icon.png-3d7f32ebbcba2efd139dc1f187e0edc1.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://addons/godot_sandbox/icon.png"
dest_files=["res://.godot/imported/icon.png-3d7f32ebbcba2efd139dc1f187e0edc1.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1

```

`bin/addons/godot_sandbox/plugin.cfg`:

```cfg
[plugin]
name="Sandbox Dependencies Plugin"
description="Shows a dependencies window"
author="godot-sandbox"
version="1.0"
script="plugin.gd"

```

`bin/addons/godot_sandbox/plugin.gd`:

```gd
@tool
extends EditorPlugin

var popup_window: Window

func _enter_tree():
	# Load your popup scene
	var popup_scene = preload("res://addons/godot_sandbox/downloader.tscn")
	popup_window = popup_scene.instantiate()
	popup_window.close_requested.connect(popup_window.hide)
	
	# Add it to the editor's main screen
	get_editor_interface().get_base_control().add_child(popup_window)
	
	# Optional: Add a menu item to trigger it
	add_tool_menu_item("Godot Sandbox Dependencies...", show_popup)

func _exit_tree():
	remove_tool_menu_item("Godot Sandbox Dependencies...")
	if popup_window:
		popup_window.queue_free()

func show_popup():
	popup_window.popup_centered()

```

`bin/cmake/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(example LANGUAGES CXX)

# Fetch godot-sandbox C++ API
include(FetchContent)
FetchContent_Declare(
	godot-sandbox
	GIT_REPOSITORY https://github.com/libriscv/godot-sandbox.git
	GIT_TAG        main
	GIT_SHALLOW    TRUE
	GIT_SUBMODULES ""
	SOURCE_SUBDIR  "program/cpp/cmake"
)
FetchContent_MakeAvailable(godot-sandbox)

# Create example.elf in the src folder
add_sandbox_program_at(example.elf ../src
	../src/example.cpp
)

```

`bin/icon.png.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://byns6ageysyf0"
path="res://.godot/imported/icon.png-487276ed1e3a0c39cad0279d744ee560.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.png"
dest_files=["res://.godot/imported/icon.png-487276ed1e3a0c39cad0279d744ee560.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1

```

`bin/project.godot`:

```godot
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Godot RISCV"
run/main_scene="res://test.tscn"
config/features=PackedStringArray("4.4", "Forward Plus")
config/icon="res://icon.png"

[editor]

script/docker_enabled=false

[editor_plugins]

enabled=PackedStringArray("res://addons/godot_sandbox/plugin.cfg")

```

`bin/src/example.cpp`:

```cpp
#include "api.hpp"

static Variant my_function(Vector4 v) {
	print("Arg: ", v);
	return 123;
}

static Variant my_function2(String s, Array a) {
	print("Args: ", s, a);
	return s;
}

static Variant _ready() {
	print("_ready called!");
	return Nil;
}

static Variant _process() {
	static int counter = 0;
	if (++counter % 100 == 0) {
		print("Process called " + std::to_string(counter) + " times");
	}
	return Nil;
}

static Vector4 my_vector4(1.0f, 2.0f, 3.0f, 4.0f);
static String my_string("Hello, World!");
int main() {
	ADD_PROPERTY(my_vector4, Variant::VECTOR4);
	ADD_PROPERTY(my_string, Variant::STRING);

	ADD_API_FUNCTION(my_function, "int", "Vector4 v");
	ADD_API_FUNCTION(my_function2, "Dictionary", "String s, Array a");

	ADD_API_FUNCTION(_ready, "void");
	ADD_API_FUNCTION(_process, "void");
}

```

`bin/src/test.gd`:

```gd
extends Node

@export var sandbox : Sandbox_SrcExample

func _ready() -> void:
	print(sandbox.my_function(Vector4(1, 1, 1, 1)))
	print(sandbox.my_function2("Hello Sandboxed World!", ["An array"]))

```

`bin/test.tscn`:

```tscn
[gd_scene load_steps=4 format=3 uid="uid://cvdqbqcr3b6cy"]

[ext_resource type="Script" uid="uid://c6g2q1leheg3n" path="res://src/test.gd" id="1_8uh7m"]
[ext_resource type="Script" uid="uid://bmvqihc88irwr" path="res://src/example.elf" id="3_6uqi0"]
[ext_resource type="Script" uid="uid://bmvqihc88irwr" path="res://src/example.elf" id="3_ppyta"]

[node name="Node" type="Node" node_paths=PackedStringArray("sandbox")]
script = ExtResource("1_8uh7m")
sandbox = NodePath("Sandbox_Example")

[node name="Sandbox_Example" type="Sandbox" parent="."]
program = ExtResource("3_6uqi0")
script = ExtResource("3_ppyta")
my_vector4 = Vector4(1, 2, 3, 4)
my_string = "Hello, World!"
program = ExtResource("3_6uqi0")
metadata/_custom_type_script = "uid://bmvqihc88irwr"

```

`build.sh`:

```sh
set -e

mkdir -p .build
pushd .build
cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release
ninja
popd

```

`build_android.sh`:

```sh
set -e
PROJECT="/sdcard/Documents/new-game-project"
VERSION="24.0.8215888"
# ANDROID_HOME and ANDROID_NDK_ROOT are already set in .bashrc
if [ ! -d "$ANDROID_NDK_ROOT" ]; then
	echo "Error: ANDROID_NDK_ROOT directory does not exist: $ANDROID_NDK_ROOT"
	exit 1
fi
if [ ! -d "$ANDROID_HOME" ]; then
	echo "Error: ANDROID_HOME directory does not exist: $ANDROID_HOME"
	exit 1
fi

## For --debug argument:
if [ "$1" == "--debug" ]; then
	echo "Building in debug mode..."
	scons platform=android target=template_debug debug_symbols=yes ndk_version=24.0.8215888
	#adb push bin/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so $PROJECT/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so
	cp bin/addons/godot_sandbox/bin/libgodot_riscv.android.template_debug.arm64.so bin/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so
	adb push bin/addons/godot_sandbox/bin/libgodot_riscv.android.template_debug.arm64.so $PROJECT/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so
## For --cmake build:
elif [ "$1" == "--cmake" ]; then
	echo "Building with CMake..."
	mkdir -p .build_android
	pushd .build_android
	cmake -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_ROOT/build/cmake/android.toolchain.cmake \
	      -DANDROID_ABI=arm64-v8a \
	      -DANDROID_PLATFORM=android-24 \
	      -DANDROID_STL=c++_shared \
	      -DANDROID_NDK=$ANDROID_NDK_ROOT \
	      -DANDROID_NATIVE_API_LEVEL=24 \
	      -DCMAKE_BUILD_TYPE=Release \
		  -DRISCV_LIBTCC=ON -DANDROID_TOOLCHAIN=ON \
		  ..
	make -j$(nproc)
	popd
	# This produces .build_android/libgodot-riscv.so
	adb push .build_android/libgodot-riscv.so $PROJECT/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so
## For --backtrace:
elif [ "$1" == "--backtrace" ]; then
	adb logcat | /usr/lib/android-ndk/ndk-stack -sym bin/addons/godot_sandbox/bin
else
## Default case: build in release mode
	echo "Building in release mode..."
	scons platform=android target=template_release ndk_version=24.0.8215888
	adb push bin/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so $PROJECT/addons/godot_sandbox/bin/libgodot_riscv.android.template_release.arm64.so
fi

```

`build_mingw.sh`:

```sh
CC=x86_64-w64-mingw32-gcc-win32
CXX=x86_64-w64-mingw32-g++-win32

mkdir -p .build_mingw
pushd .build_mingw
cmake .. -DCMAKE_BUILD_TYPE=Release -DRISCV_LIBTCC=ON -DMINGW_TOOLCHAIN=ON -DGODOT_DISABLE_EXCEPTIONS=OFF -DGODOTCPP_DISABLE_EXCEPTIONS=OFF -DGODOTCPP_TARGET=template_release
make -j16
popd

mv .build_mingw/libgodot-riscv.so .build_mingw/libgodot_riscv.windows.template_release.x86_64.dll
cp .build_mingw/*.dll /srv/samba/share
cp .build_mingw/libgodot_riscv.windows.template_release.x86_64.dll ~/New\ Game\ Project/extensions/bin/libgodot_riscv.windows.template_release.x86_64.dll

```

`config.py`:

```py
def can_build(env, platform):
    print("Building with ", env)
    if env.get("use_asan", False):
        print("Sandbox module cannot be built with ASAN enabled.")
        return False
    if env.get("module_mono_enabled", False):
        print("Sandbox module cannot be built with Mono enabled.")
        return False
    if env["platform"] == "web" and env.get("disable_exceptions", True):
        print("Sandbox module cannot be built for web with exceptions enabled.")
        return False
    # All platforms minus windows without mingw
    return (env["platform"] == "windows" and env.get("use_mingw", False)) or env["platform"] != "windows"


def configure(env):
    True

def get_doc_classes():
    return [
        "Sandbox",
        "ELFScript",
        "ELFScriptLanguage",
        "CPPScript",
        "CPPScriptLanguage",
        "RustScript",
        "RustScriptLanguage",
        "ZigScript",
        "ZigScriptLanguage",
    ]

def get_doc_path():
    return "doc_classes"

```

`doc_classes/CPPScript.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="CPPScript" inherits="ScriptExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/CPPScriptLanguage.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="CPPScriptLanguage" inherits="ScriptLanguageExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ELFScript.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ELFScript" inherits="ScriptExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	A container for binary ELF files that can be attached to and executed inside Sandbox nodes.
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="get_content">
			<return type="PackedByteArray" />
			<description>
				Returns the binary content of the program. This is the ELF binary data that can be executed by Godot Sandbox.
			</description>
		</method>
		<method name="get_sandbox_for" qualifiers="const">
			<return type="Sandbox" />
			<param index="0" name="for_object" type="Object" />
			<description>
				Find a shared Sandbox instance associated with the given Object.
			</description>
		</method>
		<method name="get_sandbox_objects" qualifiers="const">
			<return type="Array" />
			<description>
				Returns an Array of all Objects associated with the Sandbox instances that use this ELF script.
			</description>
		</method>
	</methods>
</class>

```

`doc_classes/ELFScriptLanguage.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ELFScriptLanguage" inherits="ScriptLanguageExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatLoaderCPP.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatLoaderCPP" inherits="ResourceFormatLoader" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatLoaderELF.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatLoaderELF" inherits="ResourceFormatLoader" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatLoaderRust.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatLoaderRust" inherits="ResourceFormatLoader" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatLoaderZig.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatLoaderZig" inherits="ResourceFormatLoader" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatSaverCPP.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatSaverCPP" inherits="ResourceFormatSaver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatSaverELF.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatSaverELF" inherits="ResourceFormatSaver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatSaverRust.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatSaverRust" inherits="ResourceFormatSaver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ResourceFormatSaverZig.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ResourceFormatSaverZig" inherits="ResourceFormatSaver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/RustScript.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="RustScript" inherits="ScriptExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/RustScriptLanguage.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="RustScriptLanguage" inherits="ScriptLanguageExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/Sandbox.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="Sandbox" inherits="Node" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
		Sandbox is designed to run programs in a controlled environment, providing a safe way to execute code with restricted access to the Godot engine's API and resources.
	</brief_description>
	<description>
		The Sandbox class is designed to run ELFScript resources or byte arrays from unknown sources, encapsulating them in a controlled environment. It provides a way to execute code with restricted access to the Godot engine's API and resources.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="FromBuffer" qualifiers="static">
			<return type="Sandbox" />
			<param index="0" name="buffer" type="PackedByteArray" />
			<description>
				Creates a new Sandbox instance from a PackedByteArray buffer containing the binary data of an ELF program.
				This is useful for loading ELF programs dynamically at runtime. Eg. from a downloaded file.
			</description>
		</method>
		<method name="FromProgram" qualifiers="static">
			<return type="Sandbox" />
			<param index="0" name="program" type="ELFScript" />
			<description>
				Creates a new Sandbox instance from an ELF resource.
				[codeblocks]
				[gdscript]
				var sandbox = Sandbox.FromProgram(Sandbox_TestTest)
				[/gdscript]
				[/codeblocks]
			</description>
		</method>
		<method name="add_allowed_object">
			<return type="void" />
			<param index="0" name="instance" type="Object" />
			<description>
				Adds an Object instance to the list of allowed objects in the Sandbox.
				Allowed objects can be referred to, accessed and potentially manipulated by the sandboxed program.
			</description>
		</method>
		<method name="address_of" qualifiers="const">
			<return type="int" />
			<param index="0" name="symbol" type="String" />
			<description>
				Returns the address of a symbol in the sandboxed program.
				This can be used to get the memory address of functions or variables defined in the ELF program.
			</description>
		</method>
		<method name="assault">
			<return type="void" />
			<param index="0" name="test" type="String" />
			<param index="1" name="iterations" type="int" />
			<description>
				Performs a stress test on the sandboxed program by executing a specified test function multiple times. For internal testing only.
			</description>
		</method>
		<method name="clear_allowed_objects">
			<return type="void" />
			<description>
				Clears the list of allowed objects in the Sandbox.
				After calling this method, no objects will be accessible to the sandboxed program until new ones are added.
			</description>
		</method>
		<method name="clear_hotspots" qualifiers="static">
			<return type="void" />
			<description>
				Clears the list of hotspots measured by profiling.
			</description>
		</method>
		<method name="download_program" qualifiers="static">
			<return type="PackedByteArray" />
			<param index="0" name="program_name" type="String" default="&quot;hello_world&quot;" />
			<description>
				Downloads a program from a GitHub release page and returns its binary content as a PackedByteArray. This is a blocking operation that will wait until the download is complete.
			</description>
		</method>
		<method name="emit_binary_translation" qualifiers="const">
			<return type="String" />
			<param index="0" name="ignore_instruction_limit" type="bool" default="false" />
			<param index="1" name="automatic_nbit_address_space" type="bool" default="false" />
			<description>
				Generates a binary translation of the sandboxed program as textual C code.
				This C source file can then be compiled into a shared library for execution. Loading the
				resulting shared library will allow the sandboxed program to run closer to native performance.
				If `ignore_instruction_limit` is true, the instruction limit will not be enforced, improving performance. Having an execution limit is only really recommended while building programs, as the worst case scenario is that the program or game appears to hang, which is not a security issue in most cases.
				If `automatic_nbit_address_space` is true, the translation will automatically use an n-bit (masked) address space, which can greatly improve performance for certain programs. It is however, somewhat experimental and may not work with all programs.
			</description>
		</method>
		<method name="generate_api" qualifiers="static">
			<return type="String" />
			<param index="0" name="language" type="String" default="&quot;cpp&quot;" />
			<param index="1" name="header_extra" type="String" default="&quot;&quot;" />
			<param index="2" name="use_argument_names" type="bool" default="false" />
			<description>
				Generates an API header file for the sandboxed program in the specified language.
				This header file contains function declarations and type definitions for the sandboxed program's API.
				It can be used to interact with the entire/full Godot API from the sandboxed program.
			</description>
		</method>
		<method name="get">
			<return type="Variant" />
			<param index="0" name="name" type="StringName" />
			<description>
				Retrieves the value of a property by its name from the Sandbox.
			</description>
		</method>
		<method name="get_current_instruction" qualifiers="const">
			<return type="String" />
			<description>
				Returns the current instruction being executed in the sandboxed program.
				This can be useful for debugging or profiling purposes.
			</description>
		</method>
		<method name="get_floating_point_registers" qualifiers="const">
			<return type="Array" />
			<description>
				Returns an Array of floating-point registers used by the sandboxed program.
				This can be useful for inspecting the state of floating-point computations.
			</description>
		</method>
		<method name="get_general_registers" qualifiers="const">
			<return type="Array" />
			<description>
				Returns an Array of general-purpose registers used by the sandboxed program.
				This can be useful for inspecting the state of the program's execution.
			</description>
		</method>
		<method name="get_hotspots" qualifiers="static">
			<return type="Array" />
			<param index="0" name="total" type="int" default="6" />
			<param index="1" name="callable" type="Callable" default="Callable()" />
			<description>
				Returns an Array of hotspots used for profiling.
				Hotspots are functions or code segments that are frequently executed in the sandboxed program.
			</description>
		</method>
		<method name="get_property_list" qualifiers="const">
			<return type="Array" />
			<description>
				Returns a list of all properties available in the Sandbox, including properties that are
				defined in the sandboxed program (by the program).
			</description>
		</method>
		<method name="has_function" qualifiers="const">
			<return type="bool" />
			<param index="0" name="function" type="StringName" />
			<description>
				Checks if the sandboxed program has a function with the specified name.
				This can be used to verify the existence of functions before attempting to call them.
			</description>
		</method>
		<method name="has_program_loaded" qualifiers="const">
			<return type="bool" />
			<description>
				Checks if the sandboxed program has been successfully loaded.
				This is useful to ensure that the program is ready for execution before making any calls.
			</description>
		</method>
		<method name="is_allowed_class" qualifiers="const">
			<return type="bool" />
			<param index="0" name="name" type="String" />
			<description>
				Checks if a class with the specified name is allowed in the Sandbox.
				This is used to restrict access to certain classes for security or performance reasons.
			</description>
		</method>
		<method name="is_allowed_method" qualifiers="const">
			<return type="bool" />
			<param index="0" name="instance" type="Object" />
			<param index="1" name="method" type="Variant" />
			<description>
				Checks if a method is allowed to be called on the specified Object instance.
				This is used to enforce restrictions on method calls in the sandboxed program.
			</description>
		</method>
		<method name="is_allowed_object" qualifiers="const">
			<return type="bool" />
			<param index="0" name="instance" type="Object" />
			<description>
				Checks if an Object instance is allowed to be accessed in the Sandbox.
				This is used to restrict access to certain objects for security or performance reasons.
			</description>
		</method>
		<method name="is_allowed_property" qualifiers="const">
			<return type="bool" />
			<param index="0" name="instance" type="Object" />
			<param index="1" name="property" type="Variant" />
			<param index="2" name="is_set" type="bool" default="true" />
			<description>
				Checks if a property is allowed to be accessed or set on the specified Object instance.
				This is used to enforce restrictions on property access in the sandboxed program.
			</description>
		</method>
		<method name="is_allowed_resource" qualifiers="const">
			<return type="bool" />
			<param index="0" name="res" type="String" />
			<description>
				Checks if a resource with the specified name is allowed in the Sandbox.
				This is used to restrict access to certain resources for security or performance reasons.
			</description>
		</method>
		<method name="is_binary_translated" qualifiers="const">
			<return type="bool" />
			<description>
				Checks if the sandboxed program has been binary translated.
				This means that the program has been compiled into a shared library for execution, allowing it to run closer to native performance.
			</description>
		</method>
		<method name="load_binary_translation" qualifiers="static">
			<return type="bool" />
			<param index="0" name="shared_library_path" type="String" />
			<description>
				Loads a binary translation of the sandboxed program from a shared library.
				This allows the sandboxed program to run closer to native performance by executing pre-compiled code.
			</description>
		</method>
		<method name="load_buffer">
			<return type="void" />
			<param index="0" name="buffer" type="PackedByteArray" />
			<description>
				Loads a sandboxed program from a PackedByteArray buffer containing the binary data of an ELF program.
			</description>
		</method>
		<method name="lookup_address" qualifiers="const">
			<return type="String" />
			<param index="0" name="address" type="int" />
			<description>
				Looks up the name of a symbol at a specific memory address in the sandboxed program.
				This can be useful for debugging or profiling purposes to identify which function or variable is located at a given address.
			</description>
		</method>
		<method name="make_resumable">
			<return type="void" />
			<description>
				Makes the sandboxed program resumable, allowing it to be paused and resumed later.
				Does not work properly right now. Do not use.
			</description>
		</method>
		<method name="remove_allowed_object">
			<return type="void" />
			<param index="0" name="instance" type="Object" />
			<description>
				Removes an Object from the list of allowed objects in the Sandbox.
				After calling this method, the specified object will no longer be accessible to the sandboxed program.
			</description>
		</method>
		<method name="reset">
			<return type="void" />
			<param index="0" name="unload" type="bool" default="false" />
			<description>
				Resets the Sandbox to its initial state.
				If `unload` is true, it will also unload the currently loaded program, clearing all state.
			</description>
		</method>
		<method name="restrictive_callback_function" qualifiers="static">
			<return type="bool" />
			<param index="0" name="arg" type="Variant" />
			<description>
				A restrictive callback function that can be used to enforce restrictions on method calls in the Sandbox.
				This function can be set as a callback to restrict access to certain methods or properties.
			</description>
		</method>
		<method name="resume">
			<return type="bool" />
			<param index="0" name="max_instructions" type="int" />
			<description>
				Resumes the execution of the sandboxed program after it has been paused.
				Does not work properly right now. Do not use.
			</description>
		</method>
		<method name="set">
			<return type="void" />
			<param index="0" name="name" type="StringName" />
			<param index="1" name="value" type="Variant" />
			<description>
				Sets the value of a property by its name in the Sandbox.
				This can be used to modify properties of the sandboxed program or its environment.
			</description>
		</method>
		<method name="set_argument_registers">
			<return type="void" />
			<param index="0" name="args" type="Array" />
			<description>
				Sets the argument registers for the sandboxed program.
				This allows you to specify the initial values of registers that will be used when the program starts executing.
			</description>
		</method>
		<method name="set_class_allowed_callback">
			<return type="void" />
			<param index="0" name="instance" type="Callable" />
			<description>
				Sets a callback that determines whether a class may be instantiated in the Sandbox.
				This can be used to restrict access to certain classes for security reasons.

				Please note that the sandboxed program is always allowed to instantiate Variant types.
			</description>
		</method>
		<method name="set_method_allowed_callback">
			<return type="void" />
			<param index="0" name="instance" type="Callable" />
			<description>
				Sets a callback that determines whether a method is allowed to be called on an Object instance in the Sandbox.
				This can be used to enforce restrictions on method calls in the sandboxed program.
			</description>
		</method>
		<method name="set_object_allowed_callback">
			<return type="void" />
			<param index="0" name="instance" type="Callable" />
			<description>
				Sets a callback that determines whether an Object instance is allowed to be accessed in the Sandbox.
				This can be used to restrict access to certain objects for security or performance reasons.
			</description>
		</method>
		<method name="set_property_allowed_callback">
			<return type="void" />
			<param index="0" name="instance" type="Callable" />
			<description>
				Sets a callback that determines whether a property is allowed to be accessed or set on an Object instance in the Sandbox.
				This can be used to enforce restrictions on property access in the sandboxed program.
			</description>
		</method>
		<method name="set_redirect_stdout">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
				Sets a callback to redirect the standard output (stdout) of the sandboxed program.
				This allows you to capture and process output generated by the program, such as print statements.
			</description>
		</method>
		<method name="set_resource_allowed_callback">
			<return type="void" />
			<param index="0" name="instance" type="Callable" />
			<description>
				Sets a callback that determines whether a resource is allowed in the Sandbox.
				This can be used to restrict access to certain resources for security reasons.
			</description>
		</method>
		<method name="try_compile_binary_translation">
			<return type="bool" />
			<param index="0" name="shared_library_path" type="String" default="&quot;res://bintr&quot;" />
			<param index="1" name="compiler" type="String" default="&quot;cc&quot;" />
			<param index="2" name="extra_cflags" type="String" default="&quot;&quot;" />
			<param index="3" name="ignore_instruction_limit" type="bool" default="false" />
			<param index="4" name="automatic_nbit_as" type="bool" default="false" />
			<description>
				Attempts to generate and then compile a binary translation of the sandboxed program into a shared library. This allows the sandboxed program to run closer to native performance by executing pre-compiled code. If the compilation is successful, the shared library will be loaded automatically on platforms that support loading shared libraries.
			</description>
		</method>
		<method name="vmcall" qualifiers="const vararg">
			<return type="Variant" />
			<description>
				Calls a function in the sandboxed program with the provided arguments. This is used to make function calls defined in the ELF program from the Godot engine. Functions in the Sandbox always return a Variant.
				The first argument is the string name of the function to call, and subsequent arguments are passed as parameters to that function. If the function does not exist, an error will be thrown.
				Calling a function with the wrong arguments can lead to undefined behavior, so it is important to ensure that the function signature matches the arguments being passed. If this is undesirable please have a look at [code]vmcallv()[/code] which uses Variant for all arguments and is more resistant to mistakes, but also less performant.
				[codeblocks]
				[gdscript]
				var sandbox = Sandbox.new()
				sandbox.set_program(Sandbox_TestTest)
				sandbox.vmcall("my_function", 123, "hello", [4.0, 5.0, 6.0])
				[/gdscript]
				[/codeblocks]
				In order for the above function call to work, the sandboxed program must have a function that expects those exact arguments. C++ example:
				[codeblocks]
				[gdscript]
				Variant my_function(int a, String b, Array c) {
					print("my_function called with args: ", a, ", ", b, ", ", c)
					return c[0] + c[1] + c[2];
				}
				[/gdscript]
				[/codeblocks]
			</description>
		</method>
		<method name="vmcallable">
			<return type="Variant" />
			<param index="0" name="function" type="String" />
			<param index="1" name="args" type="Array" default="[]" />
			<description>
				Creates a Callable that can be used to later make a function call into the sandbox. The args parameter allows you to specify the pre-defined arguments that will be passed to the function when it is called. Regular callable arguments will then be appended when the callable is invoked. Eg. [1, 2, 3] will call the function with the arguments 1, 2, 3, and after that any arguments passed to the callable will be appended to the end of the argument list.
			</description>
		</method>
		<method name="vmcallable_address">
			<return type="Variant" />
			<param index="0" name="address" type="int" />
			<param index="1" name="args" type="Array" default="[]" />
			<description>
				Creates a callable object that can be used to later call a function at a specific memory address in the sandboxed program. Works the same way as [code]vmcallable()[/code], but instead of a function name, it takes any executable address.
			</description>
		</method>
		<method name="vmcallv" qualifiers="const vararg">
			<return type="Variant" />
			<description>
				Calls a function in the sandboxed program with the provided arguments, similar to vmcall, but uses Variants for all arguments. This is more resistant to mistakes, as it does not require knowing argument types in advance, but is less performant than vmcall. The first argument is the string name of the function to call, and subsequent arguments are passed as Variants to that function. If the function does not exist, an error will be thrown.
				Note that the function inside the sandboxed program must also take each argument as a Variant, otherwise it will not work correctly. For maximum flexibility, one could use vmcallv with an Array as the first argument, which lets you iterate the arguments inside the function.
			</description>
		</method>
	</methods>
	<members>
		<member name="allocations_max" type="int" setter="set_allocations_max" getter="get_allocations_max" default="4000">
			The maximum number of heap allocations allowed inside the sandbox.
		</member>
		<member name="execution_timeout" type="int" setter="set_instructions_max" getter="get_instructions_max" default="8000">
			The maximum number of instructions that can be executed in a single function call.
			If this limit is reached, the current function call will be terminated to prevent infinite loops or excessive resource consumption.
		</member>
		<member name="memory_max" type="int" setter="set_memory_max" getter="get_memory_max" default="16">
			The maximum amount of memory (in megabytes) that the sandboxed program can use.
		</member>
		<member name="monitor_accumulated_startup_time" type="float" setter="" getter="get_accumulated_startup_time" default="0.0">
			The total accumulated time spent on initializing all sandboxes.
		</member>
		<member name="monitor_calls_made" type="int" setter="" getter="get_calls_made" default="0">
			The total number of function calls made to this sandbox.
		</member>
		<member name="monitor_exceptions" type="int" setter="" getter="get_exceptions" default="0">
			The total number of exceptions thrown by the sandbox.
		</member>
		<member name="monitor_execution_timeouts" type="int" setter="" getter="get_timeouts" default="0">
			The total number of execution timeouts that have occurred in the sandbox.
		</member>
		<member name="monitor_global_calls_made" type="int" setter="" getter="get_global_calls_made" default="0">
			The total number of function calls made across all sandboxes.
		</member>
		<member name="monitor_global_exceptions" type="int" setter="" getter="get_global_exceptions" default="0">
			The total number of exceptions thrown across all sandboxes.
		</member>
		<member name="monitor_global_execution_timeouts" type="int" setter="" getter="get_global_timeouts" default="0">
			The total number of execution timeouts that have occurred across all sandboxes.
		</member>
		<member name="monitor_global_instance_count" type="int" setter="" getter="get_global_instance_count" default="1">
			The total number of sandbox instances currently active.
		</member>
		<member name="monitor_heap_allocation_counter" type="int" setter="" getter="get_heap_allocation_counter" default="0">
			The total number of heap allocations made in the sandbox.
		</member>
		<member name="monitor_heap_chunk_count" type="int" setter="" getter="get_heap_chunk_count" default="0">
			The total number of heap chunks currently allocated by the sandbox.
		</member>
		<member name="monitor_heap_deallocation_counter" type="int" setter="" getter="get_heap_deallocation_counter" default="0">
			The total number of heap deallocations made in the sandbox.
		</member>
		<member name="monitor_heap_usage" type="int" setter="" getter="get_heap_usage" default="0">
			The current amount of memory (in bytes) used by the heap in the sandbox.
		</member>
		<member name="profiling" type="bool" setter="set_profiling" getter="get_profiling" default="false">
			Enables or disables profiling for the sandboxed program. When enabled, the sandbox will collect profiling data about function calls and execution times.
		</member>
		<member name="program" type="ELFScript" setter="set_program" getter="get_program">
			The ELFScript program that is currently loaded in the Sandbox. This is the program that will be executed when the sandbox is run and when functions are called.

			[codeblocks]
			[gdscript]
			var sandbox = Sandbox.new()
			sandbox.set_program(Sandbox_TestTest)
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="references_max" type="int" setter="set_max_refs" getter="get_max_refs" default="100">
			The maximum number of object references that can be held in the sandboxed program.
		</member>
		<member name="restrictions" type="bool" setter="set_restrictions" getter="get_restrictions" default="false">
			Enables or disables restrictions on the sandboxed program. When enabled, the program will have limited access to the Godot engine's API and resources.
		</member>
		<member name="precise_simulation" type="bool" setter="set_precise_simulation" getter="get_precise_simulation" default="false">
			Enables or disables precise simulation mode for the sandboxed program. When enabled, the program will use a more accurate simulation, producing better backtraces and profiling data, but at the cost of performance.
		</member>
		<member name="unboxed_arguments" type="bool" setter="set_unboxed_arguments" getter="get_unboxed_arguments" default="true">
			Enables or disables the use of unboxed arguments for function calls. When enabled, function arguments will be passed as their real types instead of Variants, which improves performance.
		</member>
	</members>
</class>

```

`doc_classes/ZigScript.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ZigScript" inherits="ScriptExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`doc_classes/ZigScriptLanguage.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<class name="ZigScriptLanguage" inherits="ScriptLanguageExtension" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
	</description>
	<tutorials>
	</tutorials>
</class>

```

`ext/CMakeLists.txt`:

```txt
# Add godot-cpp library
option(GODOTCPP_DISABLE_EXCEPTIONS "" OFF)
set(GODOTCPP_TARGET "template_release" CACHE STRING "")
add_subdirectory(godot-cpp)

# Add sandboxing library
option(RISCV_32I "" OFF)
option(RISCV_BINARY_TRANSLATION "" ON)
option(RISCV_MEMORY_TRAPS "" OFF)
add_subdirectory(libriscv/lib libriscv)
target_compile_definitions(riscv PUBLIC
	RISCV_SYSCALLS_MAX=600
	RISCV_BRK_MEMORY_SIZE=0x100000  # 1MB (we don't need much)
)

```

`godot-sandbox.code-workspace`:

```code-workspace
{
	"folders": [
		{
			"name": "godot-sandbox",
			"path": "."
		},
		{
			"name": "godot",
			"path": "../godot"
		}
	],
	"settings": {
		"lldb.launch.sourceMap": {
			"src/": "${workspaceFolder:godot-sandbox}/src"
		},
		"files.associations": {
			"vector": "cpp",
			"chrono": "cpp",
			"*.inc": "cpp",
			"__bit_reference": "cpp",
			"bitset": "cpp",
			"map": "cpp",
			"set": "cpp",
			"unordered_map": "cpp",
			"unordered_set": "cpp",
			"algorithm": "cpp",
			"__locale": "cpp",
			"string": "cpp",
			"string_view": "cpp",
			"__config": "cpp",
			"deque": "cpp",
			"list": "cpp",
			"__hash_table": "cpp",
			"__split_buffer": "cpp",
			"__tree": "cpp",
			"array": "cpp",
			"initializer_list": "cpp",
			"queue": "cpp",
			"span": "cpp",
			"stack": "cpp",
			"__node_handle": "cpp"
		},
	},
	"launch": {
		"version": "0.2.0",
		"configurations": [
			{
				"name": "Launch",
				"program": "${workspaceFolder:godot}/bin/godot.macos.editor.dev.arm64",
				"type": "cppdbg",
				"request": "launch",
				"cwd": "${workspaceFolder:godot-sandbox}",
				"osx": {
					"MIMode": "lldb"
				},
				"args": [
					"--path",
					"${workspaceFolder:godot-sandbox}/Godot-Physics-Tests",
					"--debug-collisions",
					"test.tscn"
				]
			},
		]
	},
	"tasks": {
		"version": "2.0.0",
		"tasks": [
			{
				"type": "shell",
				"label": "godot build dev",
				"command": "scons",
				"args": [
					"arch=arm64",
					"tools=yes",
					"target=editor",
					"dev_build=true",
					"debug_symbols=true",
					"precision=single",
					"--jobs=8"
				],
				"options": {
				  "cwd": "${workspaceFolder:godot}"
				},
				"problemMatcher": ["$gcc"],
				"group": {
					"kind": "build",
					"isDefault": true
				},
				"detail": "godot build dev"
			}, 
			{
				"type": "shell",
				"label": "godot build",
				"command": "scons",
				"args": [
					"arch=arm64",
					"tools=yes",
					"target=editor",
					"debug_symbols=false",
					"precision=single",
					"--jobs=8"
				],
				"options": {
				  "cwd": "${workspaceFolder:godot}"
				},
				"problemMatcher": ["$gcc"],
				"group": {
					"kind": "build",
					"isDefault": true
				},
				"detail": "build godot"
			}
		]
	}
}

```

`icons/Build.svg`:

```svg
<svg height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="m2.256 4.85 1.7 2.945 2.598-1.5 4.5 7.794a1 1-30 0 0 2.598-1.5l-4.65-8.054 3.464-2-.25-.433s-1.25-2.165-3.848-.665l-3.464 2-.31.063z" fill="#e0e0e0"/></svg>

```

`icons/CPPScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(7.03086,0,0,7.03086,1.8125,15.1961)">
            <path d="M0.395,-0.566C0.372,-0.566 0.352,-0.561 0.334,-0.552C0.316,-0.542 0.301,-0.528 0.288,-0.51C0.275,-0.492 0.266,-0.469 0.259,-0.443C0.252,-0.417 0.249,-0.387 0.249,-0.354C0.249,-0.309 0.255,-0.271 0.266,-0.241C0.278,-0.21 0.295,-0.187 0.318,-0.171C0.341,-0.156 0.371,-0.148 0.406,-0.148C0.438,-0.148 0.468,-0.152 0.498,-0.161C0.527,-0.17 0.557,-0.181 0.587,-0.193L0.587,-0.03C0.555,-0.016 0.523,-0.006 0.49,0C0.457,0.007 0.422,0.01 0.385,0.01C0.307,0.01 0.244,-0.006 0.195,-0.036C0.145,-0.067 0.109,-0.11 0.086,-0.165C0.062,-0.219 0.051,-0.283 0.051,-0.355C0.051,-0.409 0.058,-0.458 0.073,-0.503C0.089,-0.548 0.111,-0.587 0.14,-0.62C0.169,-0.653 0.206,-0.679 0.249,-0.697C0.292,-0.715 0.341,-0.724 0.397,-0.724C0.431,-0.724 0.468,-0.72 0.506,-0.712C0.544,-0.704 0.582,-0.691 0.618,-0.674L0.559,-0.522C0.533,-0.534 0.507,-0.545 0.48,-0.553C0.453,-0.562 0.425,-0.566 0.395,-0.566Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,6.375,15.1961)">
            <path d="M0.358,-0.418L0.54,-0.418L0.54,-0.287L0.358,-0.287L0.358,-0.111L0.227,-0.111L0.227,-0.287L0.045,-0.287L0.045,-0.418L0.227,-0.418L0.227,-0.597L0.358,-0.597L0.358,-0.418Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,10.4946,15.1961)">
            <path d="M0.358,-0.418L0.54,-0.418L0.54,-0.287L0.358,-0.287L0.358,-0.111L0.227,-0.111L0.227,-0.287L0.045,-0.287L0.045,-0.418L0.227,-0.418L0.227,-0.597L0.358,-0.597L0.358,-0.418Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,14.6143,15.1961)">
        </g>
    </g>
</svg>

```

`icons/ELFScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(7.03086,0,0,7.03086,2.3429,15.1961)">
            <path d="M0.501,-0L0.077,-0L0.077,-0.714L0.501,-0.714L0.501,-0.559L0.27,-0.559L0.27,-0.447L0.484,-0.447L0.484,-0.292L0.27,-0.292L0.27,-0.157L0.501,-0.157L0.501,-0Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,6.20164,15.1961)">
            <path d="M0.077,-0L0.077,-0.714L0.27,-0.714L0.27,-0.156L0.545,-0.156L0.545,-0L0.077,-0Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,10.2938,15.1961)">
            <path d="M0.267,-0L0.077,-0L0.077,-0.714L0.499,-0.714L0.499,-0.559L0.267,-0.559L0.267,-0.423L0.481,-0.423L0.481,-0.268L0.267,-0.268L0.267,-0Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
        <g transform="matrix(7.03086,0,0,7.03086,14.0839,15.1961)">
        </g>
    </g>
</svg>

```

`icons/JSScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(0.0264047,0,0,0.0264047,1.27202,3.31788)">
            <path d="M142.705,427.548C142.705,422.51 144.182,416.647 147.135,409.959C150.088,403.271 153.302,398.711 156.776,396.279C163.377,401.143 170.066,403.575 176.841,403.575L184.918,402.272C194.299,399.493 199.163,392.023 199.511,379.863L199.511,313.416L178.665,313.416C175.711,313.416 173.627,309.681 172.411,302.211C171.89,298.563 171.629,294.828 171.629,291.006C171.629,287.184 171.89,283.449 172.411,279.801C173.627,272.332 175.711,268.597 178.665,268.597L240.682,268.597C244.156,268.597 246.762,269.596 248.499,271.593C250.236,273.591 251.105,275.98 251.105,278.759L251.105,401.751C251.105,418.775 245.416,431.717 234.037,440.577C222.659,449.437 209.022,453.866 193.127,453.866C177.231,453.866 164.854,451.521 155.994,446.831C147.135,442.14 142.705,435.713 142.705,427.548Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M280.55,387.419C283.851,390.025 289.54,393.586 297.618,398.103C305.696,402.62 313.426,404.878 320.809,404.878C328.192,404.878 331.883,402.012 331.883,396.279C331.883,393.673 330.841,391.371 328.757,389.374C326.672,387.376 322.85,385.074 317.291,382.468C311.732,379.863 307.563,377.822 304.784,376.345C302.004,374.868 298.313,372.436 293.709,369.049C289.106,365.661 285.588,362.144 283.156,358.495C276.207,348.594 272.733,335.999 272.733,320.712C272.733,305.425 278.422,292.526 289.8,282.016C301.179,271.506 316.075,266.251 334.489,266.251C346.997,266.251 358.549,267.598 369.146,270.29C379.743,272.983 385.215,276.501 385.562,280.844L385.562,282.407C385.562,288.487 383.651,296.174 379.829,305.468C376.008,314.762 373.315,319.93 371.752,320.972C360.634,315.24 350.688,312.373 341.916,312.373C333.143,312.373 328.757,315.5 328.757,321.754C328.757,325.576 331.97,328.963 338.398,331.917C339.788,332.612 341.785,333.567 344.391,334.783C346.997,335.999 349.993,337.432 353.381,339.083C356.768,340.733 360.417,342.817 364.325,345.336C368.234,347.855 372.446,351.199 376.963,355.369C386.17,364.054 390.774,375.52 390.774,389.765C390.774,408.352 385.649,423.553 375.4,435.365C365.15,447.178 349.342,453.258 327.975,453.606C317.552,453.606 308.128,452.737 299.702,451C291.277,449.263 283.937,445.875 277.684,440.838C271.43,435.8 268.303,429.72 268.303,422.597C268.303,415.475 269.606,408.396 272.211,401.36C274.817,394.325 277.597,389.678 280.55,387.419Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
    </g>
</svg>

```

`icons/RustScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1,0,0,1,1.14211,14.6817)">
        <g>
            <g transform="matrix(6,0,0,6,0,0)">
                <path d="M0.241,-0.014C0.241,-0.003 0.209,0.002 0.146,0.002C0.082,0.002 0.05,-0.003 0.05,-0.013L0.05,-0.665C0.05,-0.688 0.062,-0.7 0.087,-0.7L0.278,-0.7C0.453,-0.7 0.541,-0.632 0.541,-0.495C0.541,-0.454 0.533,-0.416 0.517,-0.383C0.501,-0.349 0.478,-0.322 0.449,-0.302L0.575,-0.092C0.57,-0.076 0.552,-0.058 0.523,-0.037C0.483,-0.008 0.45,0.006 0.424,0.006C0.398,0.006 0.379,-0.003 0.366,-0.022L0.272,-0.241L0.241,-0.241L0.241,-0.014ZM0.241,-0.523L0.241,-0.373L0.246,-0.373C0.309,-0.373 0.341,-0.399 0.341,-0.452C0.341,-0.476 0.335,-0.494 0.323,-0.506C0.31,-0.517 0.29,-0.523 0.262,-0.523L0.241,-0.523Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(6,0,0,6,3.54,0)">
                <path d="M0.377,-0.68C0.377,-0.693 0.413,-0.7 0.486,-0.7C0.558,-0.7 0.594,-0.693 0.594,-0.68L0.594,-0.221C0.594,-0.153 0.57,-0.098 0.521,-0.055C0.472,-0.012 0.405,0.01 0.32,0.01C0.234,0.01 0.164,-0.012 0.111,-0.057C0.057,-0.101 0.03,-0.161 0.03,-0.236L0.03,-0.679C0.03,-0.692 0.066,-0.699 0.139,-0.699C0.211,-0.699 0.247,-0.692 0.247,-0.679L0.247,-0.228C0.247,-0.215 0.254,-0.204 0.268,-0.196C0.283,-0.188 0.298,-0.184 0.314,-0.184C0.33,-0.184 0.345,-0.188 0.358,-0.195C0.371,-0.202 0.377,-0.213 0.377,-0.228L0.377,-0.68Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(6,0,0,6,7.308,0)">
                <path d="M0.076,-0.244C0.089,-0.234 0.111,-0.22 0.142,-0.203C0.173,-0.186 0.202,-0.177 0.231,-0.177C0.259,-0.177 0.273,-0.188 0.273,-0.21C0.273,-0.22 0.269,-0.229 0.261,-0.237C0.253,-0.244 0.238,-0.253 0.217,-0.263C0.196,-0.273 0.18,-0.281 0.169,-0.287C0.158,-0.292 0.144,-0.302 0.127,-0.315C0.109,-0.328 0.095,-0.341 0.086,-0.355C0.059,-0.393 0.046,-0.441 0.046,-0.5C0.046,-0.559 0.068,-0.608 0.112,-0.649C0.155,-0.689 0.212,-0.709 0.283,-0.709C0.331,-0.709 0.375,-0.704 0.416,-0.694C0.457,-0.683 0.478,-0.67 0.479,-0.653L0.479,-0.647C0.479,-0.624 0.472,-0.594 0.457,-0.559C0.442,-0.523 0.432,-0.503 0.426,-0.499C0.383,-0.521 0.345,-0.532 0.312,-0.532C0.278,-0.532 0.261,-0.52 0.261,-0.496C0.261,-0.481 0.273,-0.468 0.298,-0.457C0.303,-0.454 0.343,-0.436 0.356,-0.43C0.369,-0.423 0.383,-0.415 0.398,-0.406C0.413,-0.396 0.429,-0.383 0.446,-0.367C0.481,-0.334 0.499,-0.29 0.499,-0.235C0.499,-0.164 0.479,-0.105 0.44,-0.06C0.401,-0.015 0.34,0.009 0.258,0.01C0.218,0.01 0.182,0.007 0.15,-0C0.117,-0.007 0.089,-0.02 0.065,-0.039C0.041,-0.058 0.029,-0.082 0.029,-0.109C0.029,-0.136 0.034,-0.164 0.044,-0.191C0.054,-0.218 0.065,-0.235 0.076,-0.244Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(6,0,0,6,10.494,0)">
                <path d="M0.351,-0.016C0.351,-0.003 0.318,0.004 0.252,0.004C0.186,0.004 0.153,-0.003 0.153,-0.016L0.153,-0.518L0.033,-0.518C0.022,-0.518 0.014,-0.533 0.009,-0.564C0.007,-0.579 0.006,-0.594 0.006,-0.609C0.006,-0.624 0.007,-0.639 0.009,-0.654C0.014,-0.685 0.022,-0.7 0.033,-0.7L0.468,-0.7C0.479,-0.7 0.487,-0.685 0.492,-0.654C0.494,-0.639 0.495,-0.624 0.495,-0.609C0.495,-0.594 0.494,-0.579 0.492,-0.564C0.487,-0.533 0.479,-0.518 0.468,-0.518L0.351,-0.518L0.351,-0.016Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            </g>
        </g>
    </g>
</svg>

```

`icons/SafeGDScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(255,200,41);fill-rule:nonzero;"/>
    <g transform="matrix(1,0,0,-1,0,16)">
        <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(255,218,95);fill-rule:nonzero;"/>
    </g>
    <g transform="matrix(1,0,0,-1,0,16)">
        <path d="M12.742,6.435C12.736,6.417 11.581,5.996 8,5.996C4.419,5.996 3.254,6.437 3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435Z" style="fill:rgb(255,200,41);fill-rule:nonzero;"/>
    </g>
</svg>

```

`icons/Sandbox.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M8,1L1,4L1,12L8,15L15,12L15,4L8,1Z" style="fill:rgb(255,200,41);fill-rule:nonzero;"/>
    <path d="M8,15L1,12L1,4L8,7L8,15Z" style="fill:rgb(255,218,95);fill-rule:nonzero;"/>
    <path d="M1,4L8,7L15,4L8,1L1,4Z" style="fill:rgb(255,226,162);fill-rule:nonzero;"/>
</svg>

```

`icons/TSScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(0.0264047,0,0,0.0264047,1.27202,3.31788)">
            <path d="M226.611,446.831C226.611,450.305 218.012,452.042 200.814,452.042C183.616,452.042 175.017,450.305 175.017,446.831L175.017,316.022L143.747,316.022C140.794,316.022 138.71,312.026 137.494,304.035C136.972,300.213 136.712,296.305 136.712,292.309C136.712,288.314 136.972,284.405 137.494,280.583C138.71,272.592 140.794,268.597 143.747,268.597L257.098,268.597C260.051,268.597 262.136,272.592 263.352,280.583C263.873,284.405 264.134,288.314 264.134,292.309C264.134,296.305 263.873,300.213 263.352,304.035C262.136,312.026 260.051,316.022 257.098,316.022L226.611,316.022L226.611,446.831Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M285.761,387.419C289.062,390.025 294.751,393.586 302.829,398.103C310.907,402.62 318.637,404.878 326.02,404.878C333.403,404.878 337.095,402.012 337.095,396.279C337.095,393.673 336.053,391.371 333.968,389.374C331.883,387.376 328.062,385.074 322.503,382.468C316.944,379.863 312.775,377.822 309.995,376.345C307.216,374.868 303.524,372.436 298.921,369.049C294.317,365.661 290.799,362.144 288.367,358.495C281.419,348.594 277.944,335.999 277.944,320.712C277.944,305.425 283.633,292.526 295.012,282.016C306.39,271.506 321.287,266.251 339.701,266.251C352.208,266.251 363.761,267.598 374.357,270.29C384.954,272.983 390.426,276.501 390.774,280.844L390.774,282.407C390.774,288.487 388.863,296.174 385.041,305.468C381.219,314.762 378.527,319.93 376.963,320.972C365.845,315.24 355.9,312.373 347.127,312.373C338.354,312.373 333.968,315.5 333.968,321.754C333.968,325.576 337.182,328.963 343.609,331.917C344.999,332.612 346.997,333.567 349.603,334.783C352.208,335.999 355.205,337.432 358.592,339.083C361.98,340.733 365.628,342.817 369.537,345.336C373.445,347.855 377.658,351.199 382.175,355.369C391.382,364.054 395.985,375.52 395.985,389.765C395.985,408.352 390.861,423.553 380.611,435.365C370.362,447.178 354.554,453.258 333.186,453.606C322.763,453.606 313.339,452.737 304.914,451C296.488,449.263 289.149,445.875 282.895,440.838C276.641,435.8 273.514,429.72 273.514,422.597C273.514,415.475 274.817,408.396 277.423,401.36C280.029,394.325 282.808,389.678 285.761,387.419Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
    </g>
</svg>

```

`icons/ZigScript.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="16" viewBox="0 0 16 16" width="16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <path d="M7,1L6.436,3.258C6.199,3.334 5.969,3.427 5.746,3.538L3.758,2.343L2.344,3.758L3.539,5.752L3.254,6.437L1,7L1,9L6.27,9C6.093,8.695 6,8.349 6,7.996C6,6.899 6.903,5.996 8,5.996C9.097,5.996 10,6.899 10,7.996C10,8.349 9.907,8.695 9.73,9L15,9L15,7L12.742,6.435C12.666,6.199 12.572,5.97 12.462,5.748L13.656,3.758L12.242,2.344L10.248,3.539C10.027,3.427 9.797,3.332 9.562,3.254L9,1L7,1Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
    <g transform="matrix(1.04463,0,0,1.04463,-0.637841,-0.681276)">
        <g transform="matrix(0.0264047,0,0,0.0264047,1.27202,3.31788)">
            <path d="M79.385,316.022C76.432,316.022 74.347,312.026 73.131,304.035C72.61,300.734 72.35,297.086 72.35,293.091C72.35,289.095 72.784,284.926 73.652,280.583C75.216,272.592 77.822,268.597 81.47,268.597L177.883,268.597C188.48,268.597 195.341,278.238 198.468,297.521C199.163,301.69 199.511,304.73 199.511,306.641L138.536,399.145L186.742,399.145C190.564,399.145 193.257,403.315 194.82,411.653C195.515,415.648 195.863,419.818 195.863,424.161C195.863,428.504 195.341,433.107 194.299,437.971C192.388,446.657 189.435,451 185.44,451L84.075,451C82.512,451 79.689,445.745 75.607,435.235C71.524,424.725 69.483,418.167 69.483,415.562C69.483,412.956 69.744,411.306 70.265,410.611L131.24,316.022L79.385,316.022Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M236.513,406.181L236.513,313.416L218.012,313.416C215.058,313.416 212.974,309.681 211.758,302.211C211.237,298.563 210.976,294.828 210.976,291.006C210.976,287.184 211.237,283.449 211.758,279.801C212.974,272.332 215.058,268.597 218.012,268.597L305.565,268.597C308.518,268.597 310.516,272.332 311.558,279.801C312.253,283.449 312.601,287.184 312.601,291.006C312.601,294.828 312.253,298.563 311.558,302.211C310.516,309.681 308.518,313.416 305.565,313.416L288.107,313.416L288.107,406.181L306.347,406.181C309.3,406.181 311.385,409.916 312.601,417.386C313.296,421.034 313.643,424.769 313.643,428.59C313.643,432.412 313.296,436.147 312.601,439.795C311.385,447.265 309.3,451 306.347,451L218.533,451C215.58,451 213.582,447.265 212.54,439.795C211.845,436.147 211.497,432.412 211.497,428.59C211.497,424.769 211.845,421.034 212.54,417.386C213.582,409.916 215.58,406.181 218.533,406.181L236.513,406.181Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
            <path d="M427.515,396.54L428.036,361.101C428.036,358.669 430.555,357.062 435.593,356.281C440.631,355.499 444.8,355.108 448.1,355.108L458.263,355.89C464.864,356.932 468.165,358.756 468.165,361.362L467.122,442.922C463.648,445.354 456.656,447.743 446.146,450.088C435.636,452.433 423.606,453.606 410.056,453.606C384.867,453.606 364.542,445.441 349.081,429.112C333.621,412.782 325.89,388.809 325.89,357.193C325.89,330.266 333.447,308.378 348.56,291.527C363.674,274.677 384.607,266.251 411.359,266.251C423.519,266.251 434.507,267.424 444.322,269.769C454.137,272.114 460.869,275.285 464.517,279.28C464.69,280.67 464.777,283.276 464.777,287.098C464.777,290.919 463.474,296.348 460.869,303.384C458.263,310.419 455.31,315.674 452.009,319.148C448.708,322.623 446.32,324.36 444.843,324.36C443.367,324.36 441.803,323.709 440.153,322.406C438.503,321.103 435.245,319.713 430.381,318.236C425.517,316.76 420.827,316.022 416.31,316.022C405.54,316.022 396.81,319.496 390.122,326.445C383.434,333.393 380.09,344.164 380.09,358.756C380.09,373.348 383.521,384.423 390.383,391.979C397.245,399.536 405.149,403.315 414.095,403.315C423.042,403.315 427.515,401.056 427.515,396.54Z" style="fill:rgb(224,224,224);fill-rule:nonzero;"/>
        </g>
    </g>
</svg>

```

`program/cpp/cmake/CMakeLists.txt`:

```txt
# Contents: CMake configuration for a Godot Sandbox C++ program
# This file is part of the Godot Sandbox project
#
# This file is licensed under the BSD-3-Clause license
# See the LICENSE file in the project root for more information
#
set(CMAKE_TRY_COMPILE_TARGET_TYPE "STATIC_LIBRARY")
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_EXTENSIONS ON)
set(VERSION 10)

option(DOWNLOAD_RUNTIME_API "Download the run-time generated API" ON)
option(SANDBOX_RISCV_EXT_C "Enable RISC-V C extension" ON)
option(DOUBLE_PRECISION    "Enable double precision real_t" OFF)
option(STRIPPED            "Strip executables" OFF)
option(FLTO                "Enable link-time optimization" OFF)
option(MINIMAL             "Build minimal programs using -Oz" OFF)

set(CXXFLAGS -O3 -std=gnu++23 -fno-stack-protector -fno-threadsafe-statics)
set(CFLAGS   -O3 -std=gnu11 -fno-stack-protector -fno-threadsafe-statics)
if (CMAKE_BUILD_TYPE STREQUAL "Debug")
	set(CXXFLAGS ${CXXFLAGS} -O0 -gdwarf-4)
	set(CFLAGS   ${CFLAGS} -O0 -gdwarf-4)
elseif (CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
	set(CXXFLAGS ${CXXFLAGS} -O3 -gdwarf-4)
	set(CFLAGS   ${CFLAGS} -O3 -gdwarf-4)
endif()
if (CMAKE_BUILD_TYPE STREQUAL "Release" OR CMAKE_BUILD_TYPE STREQUAL "MinSizeRel" OR CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
	set(CXXFLAGS ${CXXFLAGS} -fomit-frame-pointer)
	set(CFLAGS   ${CFLAGS} -fomit-frame-pointer)
endif()

if (MINIMAL)
	set(CXXFLAGS ${CXXFLAGS} -Oz)
	set(CFLAGS ${CFLAGS} -Oz)
endif()

if ("${CMAKE_CXX_COMPILER}" MATCHES "riscv64-unknown-elf*")
	set(EMBEDDED_RISCV 1 CACHE BOOL "Building for embedded RISC-V")
	message(STATUS "Building for embedded RISC-V")
elseif ("${CMAKE_CXX_COMPILER}" MATCHES "zig")
	set(ZIG_COMPILER 1 CACHE BOOL "Building using zig c++")
	message(STATUS "Building using zig c++")
	# This doesn't work on macOS
	if (NOT CMAKE_HOST_APPLE)
		# Not necessary, but lowers binary size dramatically
		configure_file("${CMAKE_CURRENT_LIST_DIR}/atomic.c" "${CMAKE_BINARY_DIR}/atomic.c" COPYONLY)
		add_library(atomic STATIC "${CMAKE_BINARY_DIR}/atomic.c")
		set_target_properties(atomic PROPERTIES LINKER_LANGUAGE CXX)
		link_directories("${CMAKE_BINARY_DIR}")
	endif()
endif()

# If the compiler contains Zig, don't set RISCV_ARCH and RISCV_ABI
if (${CMAKE_CXX_COMPILER} MATCHES "zig")
	# If Clang is version 19.0 or higher, we can use the -mcpu flag
	if (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 19.0)
		set(RISCV_ARCH "-mcpu=baseline_rv64+rva22u64")
	else()
		set(RISCV_ARCH "")
	endif()
	set(RISCV_ABI "-mabi=lp64d")
else()
	if (SANDBOX_RISCV_EXT_C)
		set(RISCV_ARCH "-march=rv64gc_zba_zbb_zbs_zbc")
	else()
		set(RISCV_ARCH "-march=rv64g_zba_zbb_zbs_zbc")
	endif()
	set(RISCV_ABI "-mabi=lp64d")
endif()

if (FLTO)
	set(CXXFLAGS ${CXXFLAGS} -flto)
	set(CFLAGS ${CFLAGS} -flto)
endif()

# Optional download of the run-time generated API
# This won't cover all classes since Godot 4.4 or when using custom extensions
# but it gets you 99% of the way there
if (DOWNLOAD_RUNTIME_API)
	if (NOT EXISTS "${CMAKE_BINARY_DIR}/generated_api.hpp")
		message(STATUS "Downloading generated API")
		file(DOWNLOAD
			https://github.com/libriscv/godot-sandbox-programs/releases/download/v0.1/generated_api.hpp
			"${CMAKE_BINARY_DIR}/generated_api.hpp")
	endif()
	set_source_files_properties("${CMAKE_BINARY_DIR}/generated_api.hpp" PROPERTIES GENERATED TRUE)
endif()

set(API_DIR "${CMAKE_CURRENT_LIST_DIR}/../docker/api")

set(API_SOURCES
	"${API_DIR}/api.cpp"
	"${API_DIR}/array.cpp"
	"${API_DIR}/basis.cpp"
	"${API_DIR}/dictionary.cpp"
	"${API_DIR}/native.cpp"
	"${API_DIR}/node.cpp"
	"${API_DIR}/node2d.cpp"
	"${API_DIR}/node3d.cpp"
	"${API_DIR}/object.cpp"
	"${API_DIR}/packed_array.cpp"
	"${API_DIR}/quaternion.cpp"
	"${API_DIR}/string.cpp"
	"${API_DIR}/timer.cpp"
	"${API_DIR}/transform2d.cpp"
	"${API_DIR}/transform3d.cpp"
	"${API_DIR}/variant.cpp"
	"${API_DIR}/vector.cpp"
)

# Sandbox API library
add_library(sandbox_api STATIC ${API_SOURCES})
target_compile_definitions(sandbox_api PUBLIC
	VERSION=${VERSION}
)
target_compile_options(sandbox_api PUBLIC
	${RISCV_ARCH} ${RISCV_ABI}
	$<$<COMPILE_LANGUAGE:CXX>:${CXXFLAGS}>
	$<$<COMPILE_LANGUAGE:C>:${CFLAGS}>
)
target_include_directories(sandbox_api PUBLIC
	${API_DIR}
)
if (NOT ZIG_COMPILER)
	target_link_libraries(sandbox_api PUBLIC
		-Wl,--wrap=memcpy,--wrap=memset,--wrap=memcmp,--wrap=memmove
		-Wl,--wrap=strlen,--wrap=strcmp,--wrap=strncmp
		-Wl,--wrap=malloc,--wrap=calloc,--wrap=realloc,--wrap=free
	)
else()
	target_compile_definitions(sandbox_api PUBLIC
		ZIG_COMPILER=1
	)
	target_link_libraries(sandbox_api PUBLIC
		-Wl,--image-base=0x100000
	)
endif()
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
	# If the GCC version is 14.0 or higher, we can use the -fuse-ld=mold flag
	if (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 14.0)
		find_program(MOLD_LINKER "mold")
		if (MOLD_LINKER)
			message(STATUS "Using MOLD linker")
			target_link_libraries(sandbox_api PUBLIC -fuse-ld=mold)
		endif()
	endif()
endif()

function (add_sandbox_program name)
	add_executable(${name} ${ARGN})
	target_link_libraries(${name} PRIVATE
		-Wl,--whole-archive sandbox_api -Wl,--no-whole-archive
	)
	target_link_libraries(${name} PUBLIC
		-static
	)
	if (DOUBLE_PRECISION)
		target_compile_definitions(${name} PUBLIC
			DOUBLE_PRECISION_REAL_T
		)
	endif()
	if (MINIMAL)
		target_link_options(${name} PRIVATE -Oz)
	endif()
	if (STRIPPED)
		target_link_options(${name} PRIVATE -s)
	endif()
	target_include_directories(${name} PRIVATE
		${CMAKE_CURRENT_SOURCE_DIR}
	)
	if (DOWNLOAD_RUNTIME_API)
		# The header is automatically found using <generated_api.hpp>
		# We simply need to add the binary directory to the include path
		target_include_directories(${name} PRIVATE
			${CMAKE_BINARY_DIR}
		)
		target_sources(${name} PRIVATE
			"${CMAKE_BINARY_DIR}/generated_api.hpp"
		)
	endif()
endfunction()

function (add_sandbox_program_at name path)
	add_sandbox_program(${name} ${ARGN})
	# if the path is relative, make it relative to
	# the CMake source directory
	if (NOT IS_ABSOLUTE "${path}")
		set(path "${CMAKE_SOURCE_DIR}/${path}")
	endif()
	set_target_properties(${name} PROPERTIES
		RUNTIME_OUTPUT_DIRECTORY ${path}
		RUNTIME_OUTPUT_NAME ${name}
	)
endfunction()

function (add_sandbox_library name)
	add_library(${name} STATIC ${ARGN})
	target_link_libraries(${name} INTERFACE
		sandbox_api
	)
endfunction()

function (enable_flto_for target)
	target_compile_options(${target} PRIVATE -flto)
	target_link_options(${target} PRIVATE -flto)
endfunction()
function (enable_stripped_for target)
	target_link_options(${target} PRIVATE -s)
endfunction()

# Example:
# add_sandbox_program(<name> <source_files>)
# add_sandbox_library(<name> <source_files>)

```

`program/cpp/cmake/autobuild.sh`:

```sh
#!/bin/sh

#
# Start ./autobuild.sh in your project folder with a ./build.sh script.
#
# This script will watch for changes in the project folder and subfolders
# and run the ./build.sh script when a .cpp file is saved.
#

set -e -u

FPATH=".."
PATTERN="\.cpp$"
COMMAND="./build.sh"

inotifywait -q --format '%f' -m -r -e close_write $FPATH \
    | grep --line-buffered $PATTERN \
    | xargs -I{} -r sh -c "echo [\$(date -Is)] $COMMAND && $COMMAND"

```

`program/cpp/cmake/example/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(example LANGUAGES CXX)

add_subdirectory(../ cmake)

# Fetch fmt from GitHub
include(FetchContent)
FetchContent_Declare(libfmt
  GIT_REPOSITORY https://github.com/fmtlib/fmt
  GIT_TAG        master
  )
FetchContent_MakeAvailable(libfmt)

add_sandbox_program(example
  "example.cpp"
)
target_link_libraries(example PRIVATE fmt::fmt)

```

`program/cpp/cmake/example/build.sh`:

```sh
#!/bin/bash

# Change this to reflect your RISC-V toolchain
# ccache is optional, but recommended
export CXX="ccache riscv64-linux-gnu-g++-12"

# Create build directory
mkdir -p .build
pushd .build
cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake
ninja
popd

```

`program/cpp/cmake/example/example.cpp`:

```cpp
#include <fmt/format.h>
#include <api.hpp>

extern "C" Variant test_function() {
	fmt::print("Hello, World!\n");
	return 42;
}

```

`program/cpp/cmake/toolchain.cmake`:

```cmake
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_CROSSCOMPILING 1)
set(CMAKE_TRY_COMPILE_TARGET_TYPE "STATIC_LIBRARY")

```

`program/cpp/docker/Dockerfile`:

```
FROM ubuntu:24.04
#
# To build the image:
# docker build -t riscv64-linux-gnu .
#
# To run the container:
# docker run --name godot-cpp-compiler -dv .:/usr/src riscv64-linux-gnu
#
# Install dependencies
RUN apt-get update && apt-get install -y \
	g++-14-riscv64-linux-gnu \
	mold ccache \
	&& rm -rf /var/lib/apt/lists/* \
	&& apt-get clean


# Enter the shared directory
WORKDIR /usr/src
# Copy API files
RUN mkdir -p /usr/api
COPY build.sh api/* /usr/api/

# Set the entrypoint to the build script
#ENTRYPOINT "/usr/api/build.sh" "$0" "$@"
CMD ["/bin/bash", "-c", "tail -f /dev/null"]

```

`program/cpp/docker/api/api.cpp`:

```cpp
#include "api.hpp"

#include "syscalls.h"
#include <cstring>
#include <exception>

/* void sys_print(const Variant *, size_t) */
MAKE_SYSCALL(ECALL_PRINT, void, sys_print, const Variant *, size_t);
MAKE_SYSCALL(ECALL_THROW, void, sys_throw, const char *, size_t, const char *, size_t, ...);
EXTERN_SYSCALL(uint64_t, sys_node_create, Node_Create_Shortlist, const char *, size_t, const char *, size_t);
MAKE_SYSCALL(ECALL_LOAD, void, sys_load, const char *, size_t, Variant *);
MAKE_SYSCALL(ECALL_SANDBOX_ADD, void, sys_sandbox_add, int, ...);

/* Default main: Do nothing */
__attribute__((weak)) int main() {
	halt(); // Prevent closing pipes, calling global destructors etc.
}

/* fast_exit */
extern "C" __attribute__((used, retain, noreturn)) void fast_exit() {
	asm(".insn i SYSTEM, 0, x0, x0, 0x7ff");
	__builtin_unreachable();
}

// ClassDB::instantiate
Object ClassDB::instantiate(std::string_view class_name, std::string_view name) {
	return Object(sys_node_create(Node_Create_Shortlist::CREATE_CLASSDB, class_name.data(), class_name.size(), name.data(), name.size()));
}

// Resource loader
Variant loadv(std::string_view path) {
	Variant result;
	sys_load(path.data(), path.size(), &result);
	return result;
}

__attribute__((constructor, used)) void setup_native_stuff() {
	/* Set exit address to fast_exit */
	sys_sandbox_add(2, &fast_exit);
	/* Handle uncaught C++ exceptions */
	std::set_terminate([] {
		try {
			std::rethrow_exception(std::current_exception());
		} catch (const std::exception &e) {
			const auto *name = typeid(e).name();
			sys_throw(name, strlen(name), e.what(), strlen(e.what()), nullptr);
			__builtin_unreachable();
		}
	});
}

// Use Godot-Sandbox Math system calls for some math functions.
// 32-bit floating point math functions:
extern "C" __attribute__((used)) float sinf(float x) {
	return Math::sinf(x);
}
extern "C" __attribute__((used)) float cosf(float x) {
	return Math::cosf(x);
}
extern "C" __attribute__((used)) float tanf(float x) {
	return Math::tanf(x);
}
extern "C" __attribute__((used)) float asinf(float x) {
	return Math::asinf(x);
}
extern "C" __attribute__((used)) float acosf(float x) {
	return Math::acosf(x);
}
extern "C" __attribute__((used)) float atanf(float x) {
	return Math::atanf(x);
}
extern "C" __attribute__((used)) float atan2f(float y, float x) {
	return Math::atan2f(y, x);
}
extern "C" __attribute__((used)) float powf(float x, float y) {
	return Math::powf(x, y);
}
// 64-bit floating point math functions:
extern "C" __attribute__((used)) double sin(double x) {
	return Math::sin(x);
}
extern "C" __attribute__((used)) double cos(double x) {
	return Math::cos(x);
}
extern "C" __attribute__((used)) double tan(double x) {
	return Math::tan(x);
}
extern "C" __attribute__((used)) double asin(double x) {
	return Math::asin(x);
}
extern "C" __attribute__((used)) double acos(double x) {
	return Math::acos(x);
}
extern "C" __attribute__((used)) double atan(double x) {
	return Math::atan(x);
}
extern "C" __attribute__((used)) double atan2(double y, double x) {
	return Math::atan2(y, x);
}
extern "C" __attribute__((used)) double pow(double x, double y) {
	return Math::pow(x, y);
}

// clang-format off
#define STR2(x) #x
#define STR(x) STR2(x)
__asm__(".pushsection .comment\n\t"
		".string \"Godot C++ API v" STR(VERSION) "\"\n\t"
		".popsection");
// clang-format on

```

`program/cpp/docker/api/api.hpp`:

```hpp
#pragma once
#include <cstddef>
// Variant types
#include "string.hpp"
#include "array.hpp"
#include "callable.hpp"
#include "dictionary.hpp"
#include "basis.hpp"
#include "transform2d.hpp"
#include "transform3d.hpp"
#include "quaternion.hpp"
#include "rid.hpp"
// Objects and nodes
#include "node2d.hpp"
#include "node3d.hpp"
#include "syscalls_fwd.hpp"
#include "timer.hpp"
// Individual packed arrays
#include "packed_byte_array.hpp"

template <typename T>
using remove_cvref = std::remove_cv_t<std::remove_reference_t<T>>;

/// @brief Print a message to the console.
/// @param ...vars A list of Variants to print.
template <typename... Args>
inline void print(Args &&...vars) {
	std::array<Variant, sizeof...(Args)> vptrs;
	int idx = 0;
	([&] {
		if constexpr (std::is_same_v<Variant, remove_cvref<Args>>)
			vptrs[idx++] = vars;
		else
			vptrs[idx++] = Variant(vars);
	}(),
			...);
	sys_print(vptrs.data(), vptrs.size());
}

/// @brief Get a node by its path. By default, this returns the current node.
/// @param path The path to the node.
/// @return The node at the given path.
template <typename T = Node>
inline T get_node(std::string_view path = ".") {
	return T(path);
}

/// @brief Get the parent of the current node.
/// @return The parent node.
template <typename T = Node>
inline T get_parent() {
	return T("..");
}

#include <unordered_map>
/// @brief A macro to define a static function that returns a custom state object
/// tied to a Node object. For shared sandbox instances, this is the simplest way
/// to store per-node-instance state.
/// @param State The type of the state object.
/// @note There is currently no way to clear the state objects, so be careful
/// with memory usage.
/// @example
/// struct SlimeState {
/// 	int direction = 1;
/// };
/// PER_OBJECT(SlimeState);
/// // Then use it like this:
/// auto& state = GetSlimeState(slime);
#define PER_OBJECT(State) \
	static State &Get ## State(const Node &node) { \
		static std::unordered_map<uint64_t, State> state; \
		return state[node.address()]; \
	}

/// @brief A property struct that must be instantiated in the global scope.
/// @note This is used to define custom properties for the Sandbox class.
/// On program load, the properties are automatically exposed on the script instance.
/// @example
/// SANDBOXED_PROPERTIES(1, {
/// 	.name = "my_property",
/// 	.type = Variant::Type::INT,
/// 	.getter = []() -> Variant { return 42; },
/// 	.setter = [](Variant value) { print("Set to: ", value); },
/// 	.default_value = Variant{42},
/// });
struct Property {
	using getter_t = Variant (*)();
	using setter_t = Variant (*)(Variant);

	const char * const name = 0;
	const unsigned size = sizeof(Property);
	const Variant::Type type;
	const getter_t getter;
	const setter_t setter;
	const Variant default_value;
};
#define SANDBOXED_PROPERTIES(num, ...) \
	extern "C" const Property properties[num+1] { __VA_ARGS__, {0} };

/// @brief Add a new property to the Sandbox class.
/// @param name The name of the property.
/// @param type The type of the property.
/// @param default_value The default value of the property.
/// @param getter A function that returns the property value.
/// @param setter A function that sets the property value.
/// @note This function must be called during the initialization phase of the program.
/// @example
/// add_property("meaning_of_life", Variant::Type::INT, 42,
/// 	[]() -> Variant { return 42; },
/// 	[](Variant value) -> Variant { print("Set to: ", value); return Nil; });
static inline void add_property(std::string_view name, Variant::Type type, const Variant &default_value, Variant (*getter)(), Variant (*setter)(Variant)) {
	sys_sandbox_add(0, name.data(), name.size(), type, setter, getter, &default_value);
}

/// @brief Add a new property to the Sandbox class. Simplified version.
/// @param name The name of the property.
/// @param type The type of the property.
/// The ADD_PROPERTY macro is a convenience macro that allows you to define a property
/// without a default value, or getter and setter. It assumes there's a global variable
/// with the same name as the property, and uses that as the getter and setter. The default
/// value is set to the current value of the variable.
/// @example
/// static double player_speed = 60.0;
/// int main() {
/// 	ADD_PROPERTY(player_speed, Variant::FLOAT);
/// }
#define ADD_PROPERTY(name, type) \
	add_property(#name, type, name, []() -> Variant { return name; }, [](Variant value) -> Variant { name = (decltype(name))value; return {}; });

/// @brief Stop execution of the program.
/// @note This function may return if the program is resumed. However, no such
/// functionality is currently implemented.
inline void halt() {
	fast_exit();
}

/// @brief Check if the program is running in the Godot editor.
/// @return True if running in the editor, false otherwise.
inline bool is_editor() {
	static constexpr int ECALL_IS_EDITOR = 512;
	register int a0 asm("a0");
	register int a7 asm("a7") = ECALL_IS_EDITOR;
	asm volatile("ecall" : "=r"(a0) : "r"(a7));
	return a0;
}
inline bool is_editor_hint() {
	return is_editor(); // Alias
}

/// @brief Load a resource (at run-time) from the given path. Can be denied.
/// @param path The path to the resource.
/// @return The loaded resource.
extern Variant loadv(std::string_view path);

/// @brief The class database for instantiating Godot objects.
struct ClassDB {
	/// @brief Instantiate a new object of the given class.
	/// @param class_name The name of the class to instantiate.
	/// @param name The name of the object, if it's a Node. Otherwise, this is ignored.
	/// @return The new object.
	static Object instantiate(std::string_view class_name, std::string_view name = "");

	template <typename T>
	static T instantiate(std::string_view class_name, std::string_view name = "") {
		return T(instantiate(class_name, name).address());
	}
};

/// @brief Math and interpolation operations.
struct Math {
	/// @brief The available 64-bit FP math operations.
	static double sin(double x);
	static double cos(double x);
	static double tan(double x);
	static double asin(double x);
	static double acos(double x);
	static double atan(double x);
	static double atan2(double y, double x);
	static double pow(double x, double y);

	/// @brief The available 32-bit FP math operations.
	static float sinf(float x);
	static float cosf(float x);
	static float tanf(float x);
	static float asinf(float x);
	static float acosf(float x);
	static float atanf(float x);
	static float atan2f(float y, float x);
	static float powf(float x, float y);

	/// @brief Linearly interpolate between two values.
	/// @param a The start value.
	/// @param b The end value.
	/// @param t The interpolation factor (between 0 and 1).
	static double lerp(double a, double b, double t);
	static float lerpf(float a, float b, float t);

	/// @brief Smoothly interpolate between two values.
	/// @param from The start value.
	/// @param to The end value.
	/// @param t The interpolation factor (between 0 and 1).
	static double smoothstep(double from, double to, double t);
	static float smoothstepf(float from, float to, float t);

	/// @brief Clamp a value between two bounds.
	/// @param x The value to clamp.
	/// @param min The minimum value.
	/// @param max The maximum value.
	static double clamp(double x, double min, double max);
	static float clampf(float x, float min, float max);

	/// @brief Spherical linear interpolation between two values.
	/// @param a The start value in radians.
	/// @param b The end value in radians.
	/// @param t The interpolation factor (between 0 and 1).
	static double slerp(double a, double b, double t);
	static float slerpf(float a, float b, float t);
};

/* Embed binary data into executable. This data has no guaranteed alignment. */
#define EMBED_BINARY(name, filename) \
	asm(".pushsection .rodata\n" \
	"	.global " #name "\n" \
	#name ":\n" \
	"	.incbin " #filename "\n" \
	#name "_end:\n" \
	"	.int  0\n" \
	"	.global " #name "_size\n" \
	"	.type   " #name "_size, @object\n" \
	"	.align 4\n" \
	#name "_size:\n" \
	"	.int  " #name "_end - " #name "\n" \
	".popsection"); \
	extern char name[]; \
	extern unsigned name ##_size;

#include "api_inline.hpp"

#if __has_include(<generated_api.hpp>)
#include <generated_api.hpp>

template <typename T = Resource>
inline T load(std::string_view path) {
	return Object(loadv(path)).address();
}

/// @brief Get the current scene tree.
/// @return The root node of the scene tree.
inline SceneTree get_tree() {
	return Object("SceneTree").address();
}

/// @brief Check if the given Node is a part of the current scene tree. Not an instance of another scene.
/// @param node The Node to check.
/// @return True if the Node is a part of the current scene tree, false otherwise.
inline bool is_part_of_tree(Node node) {
	return get_tree().get_edited_scene_root() == node.get_owner();
}
#endif

/// @brief Add a new public API function to the program during initialization.
/// @param name  The name of the function. Eg. "my_function".
/// @param address  The address of the function. Eg. my_function.
/// @param return_type  The return type of the function. Eg. void, int, String, Dictionary, etc.
/// @param args  The comma-separated arguments of the function. Eg. "int a, double b, String c"
/// @param description  The description of the function. Can be empty.
/// @example add_sandbox_api_function(
///    "add_numbers", (void *)add_numbers, "int", "int a, int b", "Adds two numbers together.");
template <typename F>
static inline void add_sandbox_api_function(std::string_view name, F *address, std::string_view return_type, std::string_view args = "", std::string_view description = "") {
	struct GuestFunctionExtra {
		const char *desc;
		size_t desc_len;
		const char *ret;
		size_t ret_len;
		const char *args;
		size_t args_len;
	};
	GuestFunctionExtra extra = {
		.desc = description.data(),
		.desc_len = description.size(),
		.ret = return_type.data(),
		.ret_len = return_type.size(),
		.args = args.data(),
		.args_len = args.size(),
	};
	sys_sandbox_add(1, name.data(), name.size(), address, &extra);
}
#define ADD_API_FUNCTION(func, return_type, ...) \
	add_sandbox_api_function(#func, func, return_type, ##__VA_ARGS__)

```

`program/cpp/docker/api/api_inline.hpp`:

```hpp
#include "syscalls.h"

/// Math and interpolation operations.
// clang-format off
template <typename Float>
static inline Float perform_math_op(Math_Op math_op, Float x) {
	register Float fa0 asm("fa0") = x;
	register int   iop asm("a0") = static_cast<int>(math_op);
	register long snum asm("a7") = (sizeof(Float) == 4) ? ECALL_MATH_OP32 : ECALL_MATH_OP64;

	asm volatile ("ecall"
		: "+f"(fa0) : "r"(iop), "r"(snum));
	return Float(fa0);
}

template <typename Float>
static inline Float perform_math_op2(Math_Op math_op, Float x, Float y) {
	register Float fa0 asm("fa0") = x;
	register Float fa1 asm("fa1") = y;
	register int   iop asm("a0") = static_cast<int>(math_op);
	register long snum asm("a7") = (sizeof(Float) == 4) ? ECALL_MATH_OP32 : ECALL_MATH_OP64;

	asm volatile ("ecall"
		: "+f"(fa0) : "f"(fa1), "r"(iop), "r"(snum));
	return Float(fa0);
}

template <typename Float>
static inline Float perform_lerp_op(Lerp_Op lerp_op, Float x, Float y, Float t) {
	register Float fa0 asm("fa0") = x;
	register Float fa1 asm("fa1") = y;
	register Float fa2 asm("fa2") = t;
	register int   iop asm("a0") = static_cast<int>(lerp_op);
	register long snum asm("a7") = (sizeof(Float) == 4) ? ECALL_LERP_OP32 : ECALL_LERP_OP64;

	asm volatile ("ecall"
		: "+f"(fa0) : "f"(fa1), "f"(fa2), "r"(iop), "r"(snum));
	return Float(fa0);
}
// clang-format on

// 64-bit FP math operations.

inline double Math::sin(double x) {
	return perform_math_op<double>(Math_Op::SIN, x);
}

inline double Math::cos(double x) {
	return perform_math_op<double>(Math_Op::COS, x);
}

inline double Math::tan(double x) {
	return perform_math_op<double>(Math_Op::TAN, x);
}

inline double Math::asin(double x) {
	return perform_math_op<double>(Math_Op::ASIN, x);
}

inline double Math::acos(double x) {
	return perform_math_op<double>(Math_Op::ACOS, x);
}

inline double Math::atan(double x) {
	return perform_math_op<double>(Math_Op::ATAN, x);
}

inline double Math::atan2(double y, double x) {
	return perform_math_op2<double>(Math_Op::ATAN2, y, x);
}

inline double Math::pow(double x, double y) {
	return perform_math_op2<double>(Math_Op::POW, x, y);
}

// 32-bit FP math operations.

inline float Math::sinf(float x) {
	return perform_math_op<float>(Math_Op::SIN, x);
}

inline float Math::cosf(float x) {
	return perform_math_op<float>(Math_Op::COS, x);
}

inline float Math::tanf(float x) {
	return perform_math_op<float>(Math_Op::TAN, x);
}

inline float Math::asinf(float x) {
	return perform_math_op<float>(Math_Op::ASIN, x);
}

inline float Math::acosf(float x) {
	return perform_math_op<float>(Math_Op::ACOS, x);
}

inline float Math::atanf(float x) {
	return perform_math_op<float>(Math_Op::ATAN, x);
}

inline float Math::atan2f(float y, float x) {
	return perform_math_op2<float>(Math_Op::ATAN2, y, x);
}

inline float Math::powf(float x, float y) {
	return perform_math_op2<float>(Math_Op::POW, x, y);
}

// 64-bit FP interpolation operations.

inline double Math::lerp(double x, double y, double t) {
	return perform_lerp_op<double>(Lerp_Op::LERP, x, y, t);
}

inline double Math::smoothstep(double from, double to, double t) {
	return perform_lerp_op<double>(Lerp_Op::SMOOTHSTEP, from, to, t);
}

inline double Math::clamp(double x, double a, double b) {
	return perform_lerp_op<double>(Lerp_Op::CLAMP, x, a, b);
}

inline double Math::slerp(double a, double b, double t) {
	return perform_lerp_op<double>(Lerp_Op::SLERP, a, b, t);
}

// 32-bit FP interpolation operations.

inline float Math::lerpf(float x, float y, float t) {
	return perform_lerp_op<float>(Lerp_Op::LERP, x, y, t);
}

inline float Math::smoothstepf(float from, float to, float t) {
	return perform_lerp_op<float>(Lerp_Op::SMOOTHSTEP, from, to, t);
}

inline float Math::clampf(float x, float a, float b) {
	return perform_lerp_op<float>(Lerp_Op::CLAMP, x, a, b);
}

inline float Math::slerpf(float a, float b, float t) {
	return perform_lerp_op<float>(Lerp_Op::SLERP, a, b, t);
}

```

`program/cpp/docker/api/array.cpp`:

```cpp
#include "array.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_ARRAY_OPS, void, sys_array_ops, Array_Op, unsigned, int, Variant *);
MAKE_SYSCALL(ECALL_ARRAY_AT, void, sys_array_at, unsigned, int, Variant *);
MAKE_SYSCALL(ECALL_ARRAY_SIZE, int, sys_array_size, unsigned);
EXTERN_SYSCALL(unsigned, sys_vassign, unsigned, unsigned);

Array &Array::operator=(const std::vector<Variant> &values) {
	Variant v = Variant::from_array(values);
	this->m_idx = sys_vassign(m_idx, v.get_internal_index());
	return *this;
}

Array &Array::operator=(const Array &other) {
	this->m_idx = sys_vassign(this->m_idx, other.m_idx);
	return *this;
}

void Array::push_back(const Variant &value) {
	sys_array_ops(Array_Op::PUSH_BACK, m_idx, 0, (Variant *)&value);
}

void Array::push_front(const Variant &value) {
	sys_array_ops(Array_Op::PUSH_FRONT, m_idx, 0, (Variant *)&value);
}

void Array::pop_at(int idx) {
	sys_array_ops(Array_Op::POP_AT, m_idx, idx, nullptr);
}

void Array::pop_back() {
	sys_array_ops(Array_Op::POP_BACK, m_idx, 0, nullptr);
}

void Array::pop_front() {
	sys_array_ops(Array_Op::POP_FRONT, m_idx, 0, nullptr);
}

void Array::insert(int idx, const Variant &value) {
	sys_array_ops(Array_Op::INSERT, m_idx, idx, (Variant *)&value);
}

void Array::erase(const Variant &value) {
	sys_array_ops(Array_Op::ERASE, m_idx, 0, (Variant *)&value);
}

void Array::resize(int size) {
	sys_array_ops(Array_Op::RESIZE, m_idx, size, nullptr);
}

void Array::clear() {
	sys_array_ops(Array_Op::CLEAR, m_idx, 0, nullptr);
}

void Array::sort() {
	sys_array_ops(Array_Op::SORT, m_idx, 0, nullptr);
}

int Array::size() const {
	return sys_array_size(m_idx);
}

bool Array::has(const Variant &value) const {
	Variant v = value;
	sys_array_ops(Array_Op::HAS, m_idx, 0, &v);
	return v;
}

Array::Array(unsigned size) {
	Variant v;
	sys_array_ops(Array_Op::CREATE, size, 0, &v);
	this->m_idx = v.get_internal_index();
}

Array::Array(const std::vector<Variant> &values) {
	Variant v = Variant::from_array(values);
	this->m_idx = v.get_internal_index();
}

std::vector<Variant> Array::to_vector() const {
	std::vector<Variant> result;
	sys_array_ops(Array_Op::FETCH_TO_VECTOR, m_idx, 0, (Variant *)&result);
	return result;
}


ArrayProxy &ArrayProxy::operator=(const Variant &value) { // set
	const int set_idx = -this->m_idx - 1;
	sys_array_at(this->m_array.get_variant_index(), set_idx, (Variant *)&value);
	return *this;
}

Variant ArrayProxy::get() const { // get
	Variant v;
	sys_array_at(this->m_array.get_variant_index(), this->m_idx, &v);
	return v;
}

```

`program/cpp/docker/api/array.hpp`:

```hpp
#pragma once

#include "variant.hpp"

class ArrayIterator;
class ArrayProxy;

struct Array {
	constexpr Array() {} // DON'T TOUCH
	Array(unsigned size);
	Array(const std::vector<Variant> &values);
	static Array Create(unsigned size = 0) { return Array(size); }

	Array &operator =(const std::vector<Variant> &values);
	Array &operator =(const Array &other);

	// Array operations
	void append(const Variant &value) { push_back(value); }
	void push_back(const Variant &value);
	void push_front(const Variant &value);
	void pop_at(int idx);
	void pop_back();
	void pop_front();
	void insert(int idx, const Variant &value);
	void erase(const Variant &value);
	void resize(int size);
	void clear();
	void sort();

	// Array access
	ArrayProxy operator[](int idx) const;
	Variant at(int idx) const;
	Variant at_or(int idx, const Variant &default_value) const;
	Variant front() const;
	Variant back() const;
	bool has(const Variant &value) const;

	std::vector<Variant> to_vector() const;

	// Array size
	int size() const;
	bool is_empty() const { return size() == 0; }

	METHOD(bool, all);
	METHOD(bool, any);
	VMETHOD(append_array);
	VMETHOD(assign);
	METHOD(int64_t, bsearch);
	METHOD(int64_t, bsearch_custom);
	METHOD(int64_t, count);
	METHOD(Array, duplicate);
	VMETHOD(fill);
	METHOD(Array, filter);
	METHOD(int64_t, find);
	METHOD(int64_t, hash);
	METHOD(bool, is_read_only);
	METHOD(bool, is_same_typed);
	METHOD(bool, is_typed);
	VMETHOD(make_read_only);
	METHOD(Array, map);
	METHOD(Variant, max);
	METHOD(Variant, min);
	METHOD(Variant, pick_random);
	METHOD(Variant, reduce);
	VMETHOD(remove_at);
	METHOD(int64_t, reverse);
	METHOD(int64_t, rfind);
	VMETHOD(shuffle);
	METHOD(Array, slice);
	VMETHOD(sort_custom);

	// Call methods on the Array
	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	inline auto begin();
	inline auto end();
	inline auto rbegin();
	inline auto rend();

	template <typename... Args>
	static Array make(Args... p_args) {
		return Array(std::vector<Variant>{Variant(p_args)...});
	}

	static Array from_variant_index(unsigned idx) { Array a; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }
	bool is_permanent() const { return Variant::is_permanent_index(m_idx); }

private:
	unsigned m_idx = INT32_MIN;
};

inline Array Variant::as_array() const {
	if (m_type != ARRAY) {
		api_throw("std::bad_cast", "Failed to cast Variant to Array", this);
	}
	return Array::from_variant_index(v.i);
}

inline Variant::Variant(const Array& a) {
	m_type = ARRAY;
	v.i = a.get_variant_index();
}

inline Variant::operator Array() const {
	return as_array();
}

inline Variant Array::at_or(int idx, const Variant &default_value) const {
	return (idx >= 0 && idx < size()) ? at(idx) : default_value;
}


struct ArrayProxy {
	ArrayProxy(const Array &array, int idx)
		: m_array(Array::from_variant_index(array.get_variant_index())), m_idx(idx) {}

	ArrayProxy &operator =(const Variant &value);

	template <typename T>
	ArrayProxy &operator =(const T &value) {
		return operator =(Variant(value));
	}

	template <typename T>
	operator T() const { return get(); }

	operator Variant() const { return get(); }

	template <typename T>
	bool operator ==(const T &value) const { return get() == Variant(value); }
	template <typename T>
	bool operator !=(const T &value) const { return get() != Variant(value); }
	template <typename T>
	bool operator <(const T &value) const { return get() < Variant(value); }

	/// @brief Get the value at the given index in the array.
	/// @return The value at the given index.
	Variant get() const;

	/// @brief Get the value at the given index in the array, or a default value if the index is out of bounds.
	/// @param default_value The default value to return if the index is out of bounds.
	Variant get_or(const Variant &default_value = {}) const { return (m_idx >= 0 && m_idx < m_array.size()) ? get() : default_value; }

	/// @brief Get the value as a specific type, by storing it in the given reference.
	/// @tparam T The type to convert the value to.
	/// @param type  The expected Variant type of the value.
	/// @param value The reference to store the value in. It will be converted to the expected type from a Variant.
	/// @return True if the value was successfully converted, false otherwise.
	template <typename T>
	bool get_as_type(Variant::Type type, T &value) const {
		if (m_idx >= 0 && m_idx < m_array.size()) {
			Variant v = get();
			if (v.get_type() == type) {
				value = v;
				return true;
			}
		}
		return false;
	}

private:
	Array m_array;
	const int m_idx;
};

inline ArrayProxy Array::operator[](int idx) const {
	return ArrayProxy(*this, idx);
}
inline Variant Array::at(int idx) const {
	return ArrayProxy(*this, idx).get();
}
inline Variant Array::front() const {
	return ArrayProxy(*this, 0).get();
}
inline Variant Array::back() const {
	return ArrayProxy(*this, size() - 1).get();
}


class ArrayIterator {
public:
	ArrayIterator(const Array &array, unsigned idx) : m_array(array), m_idx(idx) {}

	bool operator!=(const ArrayIterator &other) const { return m_idx != other.m_idx; }
	ArrayIterator &operator++() { m_idx++; return *this; }
	Variant operator*() const { return m_array[m_idx]; }

private:
	const Array m_array;
	unsigned m_idx;
};

inline auto Array::begin() {
	return ArrayIterator(*this, 0);
}
inline auto Array::end() {
	return ArrayIterator(*this, size());
}
inline auto Array::rbegin() {
	return ArrayIterator(*this, size() - 1);
}
inline auto Array::rend() {
	return ArrayIterator(*this, -1);
}

template <typename... Args>
inline Variant Array::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/basis.cpp`:

```cpp
#include "basis.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_BASIS_OPS, void, sys_basis_ops, unsigned idx, Basis_Op, ...);

Basis::Basis(const Vector3 &x, const Vector3 &y, const Vector3 &z) {
	sys_basis_ops(0, Basis_Op::CREATE, this, &x, &y, &z);
}

Basis Basis::identity() {
	Basis b;
	sys_basis_ops(0, Basis_Op::IDENTITY, &b);
	return b;
}

void Basis::assign(const Basis &basis) {
	sys_basis_ops(this->m_idx, Basis_Op::ASSIGN, this, basis.get_variant_index());
}

Vector3 Basis::get_row(int idx) const {
	Vector3 v;
	sys_basis_ops(this->m_idx, Basis_Op::GET_ROW, idx, &v);
	return v;
}

void Basis::set_row(int idx, const Vector3 &axis) {
	sys_basis_ops(this->m_idx, Basis_Op::SET_ROW, this, idx, &axis);
}

Vector3 Basis::get_column(int idx) const {
	Vector3 v;
	sys_basis_ops(this->m_idx, Basis_Op::GET_COLUMN, idx, &v);
	return v;
}

void Basis::set_column(int idx, const Vector3 &axis) {
	sys_basis_ops(this->m_idx, Basis_Op::SET_COLUMN, this, idx, &axis);
}

Basis Basis::inverse() const {
	Basis b;
	sys_basis_ops(this->m_idx, Basis_Op::INVERTED, &b);
	return b;
}

Basis Basis::transposed() const {
	Basis b;
	sys_basis_ops(this->m_idx, Basis_Op::TRANSPOSED, &b);
	return b;
}

double Basis::determinant() const {
	double det;
	sys_basis_ops(this->m_idx, Basis_Op::DETERMINANT, &det);
	return det;
}

Basis Basis::rotated(const Vector3 &axis, double angle) const {
	Basis b;
	sys_basis_ops(this->m_idx, Basis_Op::ROTATED, &b, &axis, angle);
	return b;
}

Basis Basis::lerp(const Basis &to, double t) const {
	Basis b;
	sys_basis_ops(this->m_idx, Basis_Op::LERP, &b, to.get_variant_index(), t);
	return b;
}

Basis Basis::slerp(const Basis &to, double t) const {
	Basis b;
	sys_basis_ops(this->m_idx, Basis_Op::SLERP, &b, to.get_variant_index(), t);
	return b;
}

```

`program/cpp/docker/api/basis.hpp`:

```hpp
#pragma once

#include "variant.hpp"

/**
 * @brief Basis wrapper for godot-cpp Basis.
 * Implemented by referencing and mutating a host-side Basis Variant.
 */
struct Basis {
	constexpr Basis() {} // DON'T TOUCH

	/// @brief Create a new identity basis.
	/// @return The identity basis.
	static Basis identity();

	/// @brief Create a new basis from three axes.
	/// @param x  The x-axis of the basis.
	/// @param y  The y-axis of the basis.
	/// @param z  The z-axis of the basis.
	Basis(const Vector3 &x, const Vector3 &y, const Vector3 &z);

	Basis &operator =(const Basis &basis);
	void assign(const Basis &basis);

	// Basis operations
	void invert();
	void transpose();
	Basis inverse() const;
	Basis transposed() const;
	double determinant() const;

	Basis rotated(const Vector3 &axis, double angle) const;
	Basis lerp(const Basis &to, double t) const;
	Basis slerp(const Basis &to, double t) const;

	// Basis access
	Vector3 operator[](int idx) const { return get_row(idx); }

	void set_row(int idx, const Vector3 &axis);
	Vector3 get_row(int idx) const;
	void set_column(int idx, const Vector3 &axis);
	Vector3 get_column(int idx) const;

	// Basis size
	static constexpr int size() { return 3; }

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Basis,  from_euler);
	METHOD(Basis,  from_scale);
	METHOD(Vector3, get_euler);
	VMETHOD(get_rotation_quaternion);
	METHOD(Vector3, get_scale);
	METHOD(bool,   is_conformal);
	METHOD(bool,   is_equal_approx);
	METHOD(bool,   is_finite);
	METHOD(Basis,  looking_at);
	METHOD(Basis,  orthonormalized);
	METHOD(Basis,  scaled);
	METHOD(real_t, tdotx);
	METHOD(real_t, tdoty);
	METHOD(real_t, tdotz);

	static Basis from_variant_index(unsigned idx) { Basis a {}; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }
private:
	unsigned m_idx = INT32_MIN;
};

inline Variant::Variant(const Basis &b) {
	m_type = Variant::BASIS;
	v.i = b.get_variant_index();
}

inline Variant::operator Basis() const {
	if (m_type != Variant::BASIS) {
		api_throw("std::bad_cast", "Failed to cast Variant to Basis", this);
	}
	return Basis::from_variant_index(v.i);
}

inline Basis Variant::as_basis() const {
	return static_cast<Basis>(*this);
}

inline Basis &Basis::operator =(const Basis &basis) {
	if (this->m_idx != INT32_MIN) {
		this->assign(basis);
	} else {
		this->m_idx = basis.m_idx;
	}
	return *this;
}

template <typename... Args>
inline Variant Basis::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/callable.hpp`:

```hpp
#pragma once

#include "variant.hpp"

struct Callable {
	constexpr Callable() {}
	template <typename F>
	Callable(F *f, const Variant &args = Nil);

	/// @brief Create a callable from a function pointer, which always returns a Variant.
	/// @tparam F The function type.
	/// @param f The function pointer.
	/// @param args The arguments to pass to the function.
	template <typename F>
	static Callable Create(F *f, const Variant &args = Nil);

	/// @brief Call the function with the given arguments.
	/// @tparam Args The argument types.
	/// @param args The arguments.
	template <typename... Args>
	Variant operator () (Args&&... args);

	/// @brief Call the function with the given arguments.
	/// @tparam Args The argument types.
	/// @param args The arguments.
	template <typename... Args>
	Variant call(Args&&... args);

	static Callable from_variant_index(unsigned idx) { Callable a; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }

private:
	unsigned m_idx = INT32_MIN;
};

inline Variant::Variant(const Callable &callable) {
	m_type = CALLABLE;
	v.i = callable.get_variant_index();
}

inline Callable Variant::as_callable() const {
	if (m_type != CALLABLE) {
		api_throw("std::bad_cast", "Failed to cast Variant to Callable", this);
	}
	return Callable::from_variant_index(v.i);
}

inline Variant::operator Callable() const {
	return as_callable();
}

template <typename... Args>
inline Variant Callable::operator () (Args&&... args) {
	return Variant(*this)(std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Callable::call(Args&&... args) {
	return Variant(*this).call(std::forward<Args>(args)...);
}

template <typename F>
inline Callable Callable::Create(F *f, const Variant &args) {
	unsigned idx = sys_callable_create((void (*)())f, &args, nullptr, 0);

	return Callable::from_variant_index(idx);
}

template <typename F>
inline Callable::Callable(F *f, const Variant &args)
	: m_idx(sys_callable_create((void (*)())f, &args, nullptr, 0)) {
}

```

`program/cpp/docker/api/canvas_item.hpp`:

```hpp
#pragma once
#include "node.hpp"
#include "dictionary.hpp"
#include "transform2d.hpp"
#include "rid.hpp"

struct CanvasItem : public Node {
    using Node::Node;
    PROPERTY(visible, bool);
    PROPERTY(modulate, Color);
    PROPERTY(self_modulate, Color);
    PROPERTY(show_behind_parent, bool);
    PROPERTY(top_level, bool);
    PROPERTY(clip_children, int64_t);
    PROPERTY(light_mask, int64_t);
    PROPERTY(visibility_layer, int64_t);
    PROPERTY(z_index, int64_t);
    PROPERTY(z_as_relative, bool);
    PROPERTY(y_sort_enabled, bool);
    PROPERTY(texture_filter, int64_t);
    PROPERTY(texture_repeat, int64_t);
    PROPERTY(material, Object);
    PROPERTY(use_parent_material, bool);
    VMETHOD(_draw);
    VMETHOD(_top_level_raise_self);
    VMETHOD(_edit_set_state);
    METHOD(Dictionary, _edit_get_state);
    VMETHOD(_edit_set_position);
    METHOD(Vector2, _edit_get_position);
    VMETHOD(_edit_set_scale);
    METHOD(Vector2, _edit_get_scale);
    VMETHOD(_edit_set_rect);
    METHOD(Rect2, _edit_get_rect);
    METHOD(bool, _edit_use_rect);
    VMETHOD(_edit_set_rotation);
    METHOD(double, _edit_get_rotation);
    METHOD(bool, _edit_use_rotation);
    VMETHOD(_edit_set_pivot);
    METHOD(Vector2, _edit_get_pivot);
    METHOD(bool, _edit_use_pivot);
    METHOD(Transform2D, _edit_get_transform);
    METHOD(::RID, get_canvas_item);
    METHOD(void, set_visible);
    METHOD(bool, is_visible);
    METHOD(bool, is_visible_in_tree);
    VMETHOD(show);
    VMETHOD(hide);
    VMETHOD(queue_redraw);
    VMETHOD(move_to_front);
    METHOD(void, set_as_top_level);
    METHOD(bool, is_set_as_top_level);
    METHOD(void, set_light_mask);
    METHOD(int64_t, get_light_mask);
    METHOD(void, set_modulate);
    METHOD(Color, get_modulate);
    METHOD(void, set_self_modulate);
    METHOD(Color, get_self_modulate);
    METHOD(void, set_z_index);
    METHOD(int64_t, get_z_index);
    METHOD(void, set_z_as_relative);
    METHOD(bool, is_z_relative);
    METHOD(void, set_y_sort_enabled);
    METHOD(bool, is_y_sort_enabled);
    METHOD(void, set_draw_behind_parent);
    METHOD(bool, is_draw_behind_parent_enabled);
    VMETHOD(draw_line);
    VMETHOD(draw_dashed_line);
    VMETHOD(draw_polyline);
    VMETHOD(draw_polyline_colors);
    VMETHOD(draw_arc);
    VMETHOD(draw_multiline);
    VMETHOD(draw_multiline_colors);
    VMETHOD(draw_rect);
    VMETHOD(draw_circle);
    VMETHOD(draw_texture);
    VMETHOD(draw_texture_rect);
    VMETHOD(draw_texture_rect_region);
    VMETHOD(draw_msdf_texture_rect_region);
    VMETHOD(draw_lcd_texture_rect_region);
    VMETHOD(draw_style_box);
    VMETHOD(draw_primitive);
    VMETHOD(draw_polygon);
    VMETHOD(draw_colored_polygon);
    VMETHOD(draw_string);
    VMETHOD(draw_multiline_string);
    VMETHOD(draw_string_outline);
    VMETHOD(draw_multiline_string_outline);
    VMETHOD(draw_char);
    VMETHOD(draw_char_outline);
    VMETHOD(draw_mesh);
    VMETHOD(draw_multimesh);
    VMETHOD(draw_set_transform);
    VMETHOD(draw_set_transform_matrix);
    VMETHOD(draw_animation_slice);
    VMETHOD(draw_end_animation);
    METHOD(Transform2D, get_transform);
    METHOD(Transform2D, get_global_transform);
    METHOD(Transform2D, get_global_transform_with_canvas);
    METHOD(Transform2D, get_viewport_transform);
    METHOD(Rect2, get_viewport_rect);
    METHOD(Transform2D, get_canvas_transform);
    METHOD(Transform2D, get_screen_transform);
    METHOD(Vector2, get_local_mouse_position);
    METHOD(Vector2, get_global_mouse_position);
    METHOD(::RID, get_canvas);
    METHOD(Object, get_canvas_layer_node);
    METHOD(Object, get_world_2d);
    METHOD(void, set_material);
    METHOD(Object, get_material);
    METHOD(void, set_use_parent_material);
    METHOD(bool, get_use_parent_material);
    METHOD(void, set_notify_local_transform);
    METHOD(bool, is_local_transform_notification_enabled);
    METHOD(void, set_notify_transform);
    METHOD(bool, is_transform_notification_enabled);
    VMETHOD(force_update_transform);
    METHOD(Vector2, make_canvas_position_local);
    METHOD(Object, make_input_local);
    METHOD(void, set_visibility_layer);
    METHOD(int64_t, get_visibility_layer);
    METHOD(void, set_visibility_layer_bit);
    METHOD(bool, get_visibility_layer_bit);
    METHOD(void, set_texture_filter);
    METHOD(int64_t, get_texture_filter);
    METHOD(void, set_texture_repeat);
    METHOD(int64_t, get_texture_repeat);
    METHOD(void, set_clip_children_mode);
    METHOD(int64_t, get_clip_children_mode);
    static constexpr int64_t NOTIFICATION_TRANSFORM_CHANGED = 2000;
    static constexpr int64_t NOTIFICATION_LOCAL_TRANSFORM_CHANGED = 35;
    static constexpr int64_t NOTIFICATION_DRAW = 30;
    static constexpr int64_t NOTIFICATION_VISIBILITY_CHANGED = 31;
    static constexpr int64_t NOTIFICATION_ENTER_CANVAS = 32;
    static constexpr int64_t NOTIFICATION_EXIT_CANVAS = 33;
    static constexpr int64_t NOTIFICATION_WORLD_2D_CHANGED = 36;
    static constexpr int64_t TEXTURE_FILTER_PARENT_NODE = 0;
    static constexpr int64_t TEXTURE_FILTER_NEAREST = 1;
    static constexpr int64_t TEXTURE_FILTER_LINEAR = 2;
    static constexpr int64_t TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 3;
    static constexpr int64_t TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 4;
    static constexpr int64_t TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC = 5;
    static constexpr int64_t TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC = 6;
    static constexpr int64_t TEXTURE_FILTER_MAX = 7;
    static constexpr int64_t TEXTURE_REPEAT_PARENT_NODE = 0;
    static constexpr int64_t TEXTURE_REPEAT_DISABLED = 1;
    static constexpr int64_t TEXTURE_REPEAT_ENABLED = 2;
    static constexpr int64_t TEXTURE_REPEAT_MIRROR = 3;
    static constexpr int64_t TEXTURE_REPEAT_MAX = 4;
    static constexpr int64_t CLIP_CHILDREN_DISABLED = 0;
    static constexpr int64_t CLIP_CHILDREN_ONLY = 1;
    static constexpr int64_t CLIP_CHILDREN_AND_DRAW = 2;
    static constexpr int64_t CLIP_CHILDREN_MAX = 3;
};

```

`program/cpp/docker/api/color.hpp`:

```hpp
#pragma once
#include <cmath>
#include "syscalls_fwd.hpp"

struct Color {
	float r;
	float g;
	float b;
	float a;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Color, blend);
	METHOD(Color, clamp);
	METHOD(Color, darkened);
	METHOD(Color, from_hsv);
	METHOD(Color, from_ok_hsl);
	METHOD(Color, from_rgbe9995);
	METHOD(Color, from_string);
	METHOD(float, get_luminance);
	METHOD(Color, hex);
	METHOD(Color, hex64);
	METHOD(Color, html);
	METHOD(bool, html_is_valid);
	METHOD(Color, inverted);
	METHOD(bool, is_equal_approx);
	METHOD(Color, lerp);
	METHOD(Color, lightened);
	METHOD(Color, linear_to_srgb);
	METHOD(Color, srgb_to_linear);
	METHOD(int, to_abgr32);
	METHOD(int, to_abgr64);
	METHOD(int, to_argb32);
	METHOD(int, to_argb64);
	//METHOD(String, to_html);
	METHOD(int, to_rgba32);
	METHOD(int, to_rgba64);

	Color& operator += (const Color& other);
	Color& operator -= (const Color& other);
	Color& operator *= (const Color& other);
	Color& operator /= (const Color& other);

	Color& operator += (float other);
	Color& operator -= (float other);
	Color& operator *= (float other);
	Color& operator /= (float other);

	bool operator == (const Color& other) const {
		return __builtin_memcmp(this, &other, sizeof(Color)) == 0;
	}
	bool operator != (const Color& other) const {
		return !(*this == other);
	}

	constexpr Color() : r(0), g(0), b(0), a(0) {}
	constexpr Color(float val) : r(val), g(val), b(val), a(val) {}
	constexpr Color(float r, float g, float b) : r(r), g(g), b(b), a(1) {}
	constexpr Color(float r, float g, float b, float a) : r(r), g(g), b(b), a(a) {}
	Color(std::string_view code);
	Color(std::string_view code, float a);

	static const Color ALICE_BLUE;
	static const Color ANTIQUE_WHITE;
	static const Color AQUA;
	static const Color AQUAMARINE;
	static const Color AZURE;
	static const Color BEIGE;
	static const Color BISQUE;
	static const Color BLACK;
	static const Color BLANCHED_ALMOND;
	static const Color BLUE;
	static const Color BLUE_VIOLET;
	static const Color BROWN;
	static const Color BURLYWOOD;
	static const Color CADET_BLUE;
	static const Color CHARTREUSE;
	static const Color CHOCOLATE;
	static const Color CORAL;
	static const Color CORNFLOWER_BLUE;
	static const Color CORNSILK;
	static const Color CRIMSON;
	static const Color CYAN;
	static const Color DARK_BLUE;
	static const Color DARK_CYAN;
	static const Color DARK_GOLDENROD;
	static const Color DARK_GRAY;
	static const Color DARK_GREEN;
	static const Color DARK_KHAKI;
	static const Color DARK_MAGENTA;
	static const Color DARK_OLIVE_GREEN;
	static const Color DARK_ORANGE;
	static const Color DARK_ORCHID;
	static const Color DARK_RED;
	static const Color DARK_SALMON;
	static const Color DARK_SEA_GREEN;
	static const Color DARK_SLATE_BLUE;
	static const Color DARK_SLATE_GRAY;
	static const Color DARK_TURQUOISE;
	static const Color DARK_VIOLET;
	static const Color DEEP_PINK;
	static const Color DEEP_SKY_BLUE;
	static const Color DIM_GRAY;
	static const Color DODGER_BLUE;
	static const Color FIREBRICK;
	static const Color FLORAL_WHITE;
	static const Color FOREST_GREEN;
	static const Color FUCHSIA;
	static const Color GAINSBORO;
	static const Color GHOST_WHITE;
	static const Color GOLD;
	static const Color GOLDENROD;
	static const Color GRAY;
	static const Color GREEN;
	static const Color GREEN_YELLOW;
	static const Color HONEYDEW;
	static const Color HOT_PINK;
	static const Color INDIAN_RED;
	static const Color INDIGO;
	static const Color IVORY;
	static const Color KHAKI;
	static const Color LAVENDER;
	static const Color LAVENDER_BLUSH;
	static const Color LAWN_GREEN;
	static const Color LEMON_CHIFFON;
	static const Color LIGHT_BLUE;
	static const Color LIGHT_CORAL;
	static const Color LIGHT_CYAN;
	static const Color LIGHT_GOLDENROD;
	static const Color LIGHT_GRAY;
	static const Color LIGHT_GREEN;
	static const Color LIGHT_PINK;
	static const Color LIGHT_SALMON;
	static const Color LIGHT_SEA_GREEN;
	static const Color LIGHT_SKY_BLUE;
	static const Color LIGHT_SLATE_GRAY;
	static const Color LIGHT_STEEL_BLUE;
	static const Color LIGHT_YELLOW;
	static const Color LIME;
	static const Color LIME_GREEN;
	static const Color LINEN;
	static const Color MAGENTA;
	static const Color MAROON;
	static const Color MEDIUM_AQUAMARINE;
	static const Color MEDIUM_BLUE;
	static const Color MEDIUM_ORCHID;
	static const Color MEDIUM_PURPLE;
	static const Color MEDIUM_SEA_GREEN;
	static const Color MEDIUM_SLATE_BLUE;
	static const Color MEDIUM_SPRING_GREEN;
	static const Color MEDIUM_TURQUOISE;
	static const Color MEDIUM_VIOLET_RED;
	static const Color MIDNIGHT_BLUE;
	static const Color MINT_CREAM;
	static const Color MISTY_ROSE;
	static const Color MOCCASIN;
	static const Color NAVAJO_WHITE;
	static const Color NAVY_BLUE;
	static const Color OLD_LACE;
	static const Color OLIVE;
	static const Color OLIVE_DRAB;
	static const Color ORANGE;
	static const Color ORANGE_RED;
	static const Color ORCHID;
	static const Color PALE_GOLDENROD;
	static const Color PALE_GREEN;
	static const Color PALE_TURQUOISE;
	static const Color PALE_VIOLET_RED;
	static const Color PAPAYA_WHIP;
	static const Color PEACH_PUFF;
	static const Color PERU;
	static const Color PINK;
	static const Color PLUM;
	static const Color POWDER_BLUE;
	static const Color PURPLE;
	static const Color REBECCA_PURPLE;
	static const Color RED;
	static const Color ROSY_BROWN;
	static const Color ROYAL_BLUE;
	static const Color SADDLE_BROWN;
	static const Color SALMON;
	static const Color SANDY_BROWN;
	static const Color SEA_GREEN;
	static const Color SEASHELL;
	static const Color SIENNA;
	static const Color SILVER;
	static const Color SKY_BLUE;
	static const Color SLATE_BLUE;
	static const Color SLATE_GRAY;
	static const Color SNOW;
	static const Color SPRING_GREEN;
	static const Color STEEL_BLUE;
	static const Color TAN;
	static const Color TEAL;
	static const Color THISTLE;
	static const Color TOMATO;
	static const Color TRANSPARENT;
	static const Color TURQUOISE;
	static const Color VIOLET;
	static const Color WEB_GRAY;
	static const Color WEB_GREEN;
	static const Color WEB_MAROON;
	static const Color WEB_PURPLE;
	static const Color WHEAT;
	static const Color WHITE;
	static const Color WHITE_SMOKE;
	static const Color YELLOW;
	static const Color YELLOW_GREEN;
};

inline constexpr auto operator + (const Color& a, float b) noexcept {
	return Color{a.r + b, a.g + b, a.b + b, a.a + b};
}
inline constexpr auto operator - (const Color& a, float b) noexcept {
	return Color{a.r - b, a.g - b, a.b - b, a.a - b};
}
inline constexpr auto operator * (const Color& a, float b) noexcept {
	return Color{a.r * b, a.g * b, a.b * b, a.a * b};
}
inline constexpr auto operator / (const Color& a, float b) noexcept {
	return Color{a.r / b, a.g / b, a.b / b, a.a / b};
}

inline constexpr auto operator + (const Color& a, const Color& b) noexcept {
	return Color{a.r + b.r, a.g + b.g, a.b + b.b, a.a + b.a};
}
inline constexpr auto operator - (const Color& a, const Color& b) noexcept {
	return Color{a.r - b.r, a.g - b.g, a.b - b.b, a.a - b.a};
}
inline constexpr auto operator * (const Color& a, const Color& b) noexcept {
	return Color{a.r * b.r, a.g * b.g, a.b * b.b, a.a * b.a};
}
inline constexpr auto operator / (const Color& a, const Color& b) noexcept {
	return Color{a.r / b.r, a.g / b.g, a.b / b.b, a.a / b.a};
}

inline Color& Color::operator += (const Color& other) {
	r += other.r;
	g += other.g;
	b += other.b;
	a += other.a;
	return *this;
}
inline Color& Color::operator -= (const Color& other) {
	r -= other.r;
	g -= other.g;
	b -= other.b;
	a -= other.a;
	return *this;
}
inline Color& Color::operator *= (const Color& other) {
	r *= other.r;
	g *= other.g;
	b *= other.b;
	a *= other.a;
	return *this;
}
inline Color& Color::operator /= (const Color& other) {
	r /= other.r;
	g /= other.g;
	b /= other.b;
	a /= other.a;
	return *this;
}

inline Color& Color::operator += (float other) {
	r += other;
	g += other;
	b += other;
	a += other;
	return *this;
}
inline Color& Color::operator -= (float other) {
	r -= other;
	g -= other;
	b -= other;
	a -= other;
	return *this;
}
inline Color& Color::operator *= (float other) {
	r *= other;
	g *= other;
	b *= other;
	a *= other;
	return *this;
}
inline Color& Color::operator /= (float other) {
	r /= other;
	g /= other;
	b /= other;
	a /= other;
	return *this;
}

inline constexpr Color const ALICE_BLUE = Color(0.941176, 0.972549, 1, 1);
inline constexpr Color const ANTIQUE_WHITE = Color(0.980392, 0.921569, 0.843137, 1);
inline constexpr Color const AQUA = Color(0, 1, 1, 1);
inline constexpr Color const AQUAMARINE = Color(0.498039, 1, 0.831373, 1);
inline constexpr Color const AZURE = Color(0.941176, 1, 1, 1);
inline constexpr Color const BEIGE = Color(0.960784, 0.960784, 0.862745, 1);
inline constexpr Color const BISQUE = Color(1, 0.894118, 0.768627, 1);
inline constexpr Color const BLACK = Color(0, 0, 0, 1);
inline constexpr Color const BLANCHED_ALMOND = Color(1, 0.921569, 0.803922, 1);
inline constexpr Color const BLUE = Color(0, 0, 1, 1);
inline constexpr Color const BLUE_VIOLET = Color(0.541176, 0.168627, 0.886275, 1);
inline constexpr Color const BROWN = Color(0.647059, 0.164706, 0.164706, 1);
inline constexpr Color const BURLYWOOD = Color(0.870588, 0.721569, 0.529412, 1);
inline constexpr Color const CADET_BLUE = Color(0.372549, 0.619608, 0.627451, 1);
inline constexpr Color const CHARTREUSE = Color(0.498039, 1, 0, 1);
inline constexpr Color const CHOCOLATE = Color(0.823529, 0.411765, 0.117647, 1);
inline constexpr Color const CORAL = Color(1, 0.498039, 0.313726, 1);
inline constexpr Color const CORNFLOWER_BLUE = Color(0.392157, 0.584314, 0.929412, 1);
inline constexpr Color const CORNSILK = Color(1, 0.972549, 0.862745, 1);
inline constexpr Color const CRIMSON = Color(0.862745, 0.0784314, 0.235294, 1);
inline constexpr Color const CYAN = Color(0, 1, 1, 1);
inline constexpr Color const DARK_BLUE = Color(0, 0, 0.545098, 1);
inline constexpr Color const DARK_CYAN = Color(0, 0.545098, 0.545098, 1);
inline constexpr Color const DARK_GOLDENROD = Color(0.721569, 0.52549, 0.0431373, 1);
inline constexpr Color const DARK_GRAY = Color(0.662745, 0.662745, 0.662745, 1);
inline constexpr Color const DARK_GREEN = Color(0, 0.392157, 0, 1);
inline constexpr Color const DARK_KHAKI = Color(0.741176, 0.717647, 0.419608, 1);
inline constexpr Color const DARK_MAGENTA = Color(0.545098, 0, 0.545098, 1);
inline constexpr Color const DARK_OLIVE_GREEN = Color(0.333333, 0.419608, 0.184314, 1);
inline constexpr Color const DARK_ORANGE = Color(1, 0.54902, 0, 1);
inline constexpr Color const DARK_ORCHID = Color(0.6, 0.196078, 0.8, 1);
inline constexpr Color const DARK_RED = Color(0.545098, 0, 0, 1);
inline constexpr Color const DARK_SALMON = Color(0.913725, 0.588235, 0.478431, 1);
inline constexpr Color const DARK_SEA_GREEN = Color(0.560784, 0.737255, 0.560784, 1);
inline constexpr Color const DARK_SLATE_BLUE = Color(0.282353, 0.239216, 0.545098, 1);
inline constexpr Color const DARK_SLATE_GRAY = Color(0.184314, 0.309804, 0.309804, 1);
inline constexpr Color const DARK_TURQUOISE = Color(0, 0.807843, 0.819608, 1);
inline constexpr Color const DARK_VIOLET = Color(0.580392, 0, 0.827451, 1);
inline constexpr Color const DEEP_PINK = Color(1, 0.0784314, 0.576471, 1);
inline constexpr Color const DEEP_SKY_BLUE = Color(0, 0.74902, 1, 1);
inline constexpr Color const DIM_GRAY = Color(0.411765, 0.411765, 0.411765, 1);
inline constexpr Color const DODGER_BLUE = Color(0.117647, 0.564706, 1, 1);
inline constexpr Color const FIREBRICK = Color(0.698039, 0.133333, 0.133333, 1);
inline constexpr Color const FLORAL_WHITE = Color(1, 0.980392, 0.941176, 1);
inline constexpr Color const FOREST_GREEN = Color(0.133333, 0.545098, 0.133333, 1);
inline constexpr Color const FUCHSIA = Color(1, 0, 1, 1);
inline constexpr Color const GAINSBORO = Color(0.862745, 0.862745, 0.862745, 1);
inline constexpr Color const GHOST_WHITE = Color(0.972549, 0.972549, 1, 1);
inline constexpr Color const GOLD = Color(1, 0.843137, 0, 1);
inline constexpr Color const GOLDENROD = Color(0.854902, 0.647059, 0.12549, 1);
inline constexpr Color const GRAY = Color(0.745098, 0.745098, 0.745098, 1);
inline constexpr Color const GREEN = Color(0, 1, 0, 1);
inline constexpr Color const GREEN_YELLOW = Color(0.678431, 1, 0.184314, 1);
inline constexpr Color const HONEYDEW = Color(0.941176, 1, 0.941176, 1);
inline constexpr Color const HOT_PINK = Color(1, 0.411765, 0.705882, 1);
inline constexpr Color const INDIAN_RED = Color(0.803922, 0.360784, 0.360784, 1);
inline constexpr Color const INDIGO = Color(0.294118, 0, 0.509804, 1);
inline constexpr Color const IVORY = Color(1, 1, 0.941176, 1);
inline constexpr Color const KHAKI = Color(0.941176, 0.901961, 0.54902, 1);
inline constexpr Color const LAVENDER = Color(0.901961, 0.901961, 0.980392, 1);
inline constexpr Color const LAVENDER_BLUSH = Color(1, 0.941176, 0.960784, 1);
inline constexpr Color const LAWN_GREEN = Color(0.486275, 0.988235, 0, 1);
inline constexpr Color const LEMON_CHIFFON = Color(1, 0.980392, 0.803922, 1);
inline constexpr Color const LIGHT_BLUE = Color(0.678431, 0.847059, 0.901961, 1);
inline constexpr Color const LIGHT_CORAL = Color(0.941176, 0.501961, 0.501961, 1);
inline constexpr Color const LIGHT_CYAN = Color(0.878431, 1, 1, 1);
inline constexpr Color const LIGHT_GOLDENROD = Color(0.980392, 0.980392, 0.823529, 1);
inline constexpr Color const LIGHT_GRAY = Color(0.827451, 0.827451, 0.827451, 1);
inline constexpr Color const LIGHT_GREEN = Color(0.564706, 0.933333, 0.564706, 1);
inline constexpr Color const LIGHT_PINK = Color(1, 0.713726, 0.756863, 1);
inline constexpr Color const LIGHT_SALMON = Color(1, 0.627451, 0.478431, 1);
inline constexpr Color const LIGHT_SEA_GREEN = Color(0.12549, 0.698039, 0.666667, 1);
inline constexpr Color const LIGHT_SKY_BLUE = Color(0.529412, 0.807843, 0.980392, 1);
inline constexpr Color const LIGHT_SLATE_GRAY = Color(0.466667, 0.533333, 0.6, 1);
inline constexpr Color const LIGHT_STEEL_BLUE = Color(0.690196, 0.768627, 0.870588, 1);
inline constexpr Color const LIGHT_YELLOW = Color(1, 1, 0.878431, 1);
inline constexpr Color const LIME = Color(0, 1, 0, 1);
inline constexpr Color const LIME_GREEN = Color(0.196078, 0.803922, 0.196078, 1);
inline constexpr Color const LINEN = Color(0.980392, 0.941176, 0.901961, 1);
inline constexpr Color const MAGENTA = Color(1, 0, 1, 1);
inline constexpr Color const MAROON = Color(0.690196, 0.188235, 0.376471, 1);
inline constexpr Color const MEDIUM_AQUAMARINE = Color(0.4, 0.803922, 0.666667, 1);
inline constexpr Color const MEDIUM_BLUE = Color(0, 0, 0.803922, 1);
inline constexpr Color const MEDIUM_ORCHID = Color(0.729412, 0.333333, 0.827451, 1);
inline constexpr Color const MEDIUM_PURPLE = Color(0.576471, 0.439216, 0.858824, 1);
inline constexpr Color const MEDIUM_SEA_GREEN = Color(0.235294, 0.701961, 0.443137, 1);
inline constexpr Color const MEDIUM_SLATE_BLUE = Color(0.482353, 0.407843, 0.933333, 1);
inline constexpr Color const MEDIUM_SPRING_GREEN = Color(0, 0.980392, 0.603922, 1);
inline constexpr Color const MEDIUM_TURQUOISE = Color(0.282353, 0.819608, 0.8, 1);
inline constexpr Color const MEDIUM_VIOLET_RED = Color(0.780392, 0.0823529, 0.521569, 1);
inline constexpr Color const MIDNIGHT_BLUE = Color(0.0980392, 0.0980392, 0.439216, 1);
inline constexpr Color const MINT_CREAM = Color(0.960784, 1, 0.980392, 1);
inline constexpr Color const MISTY_ROSE = Color(1, 0.894118, 0.882353, 1);
inline constexpr Color const MOCCASIN = Color(1, 0.894118, 0.709804, 1);
inline constexpr Color const NAVAJO_WHITE = Color(1, 0.870588, 0.678431, 1);
inline constexpr Color const NAVY_BLUE = Color(0, 0, 0.501961, 1);
inline constexpr Color const OLD_LACE = Color(0.992157, 0.960784, 0.901961, 1);
inline constexpr Color const OLIVE = Color(0.501961, 0.501961, 0, 1);
inline constexpr Color const OLIVE_DRAB = Color(0.419608, 0.556863, 0.137255, 1);
inline constexpr Color const ORANGE = Color(1, 0.647059, 0, 1);
inline constexpr Color const ORANGE_RED = Color(1, 0.270588, 0, 1);
inline constexpr Color const ORCHID = Color(0.854902, 0.439216, 0.839216, 1);
inline constexpr Color const PALE_GOLDENROD = Color(0.933333, 0.909804, 0.666667, 1);
inline constexpr Color const PALE_GREEN = Color(0.596078, 0.984314, 0.596078, 1);
inline constexpr Color const PALE_TURQUOISE = Color(0.686275, 0.933333, 0.933333, 1);
inline constexpr Color const PALE_VIOLET_RED = Color(0.858824, 0.439216, 0.576471, 1);
inline constexpr Color const PAPAYA_WHIP = Color(1, 0.937255, 0.835294, 1);
inline constexpr Color const PEACH_PUFF = Color(1, 0.854902, 0.72549, 1);
inline constexpr Color const PERU = Color(0.803922, 0.521569, 0.247059, 1);
inline constexpr Color const PINK = Color(1, 0.752941, 0.796078, 1);
inline constexpr Color const PLUM = Color(0.866667, 0.627451, 0.866667, 1);
inline constexpr Color const POWDER_BLUE = Color(0.690196, 0.878431, 0.901961, 1);
inline constexpr Color const PURPLE = Color(0.627451, 0.12549, 0.941176, 1);
inline constexpr Color const REBECCA_PURPLE = Color(0.4, 0.2, 0.6, 1);
inline constexpr Color const RED = Color(1, 0, 0, 1);
inline constexpr Color const ROSY_BROWN = Color(0.737255, 0.560784, 0.560784, 1);
inline constexpr Color const ROYAL_BLUE = Color(0.254902, 0.411765, 0.882353, 1);
inline constexpr Color const SADDLE_BROWN = Color(0.545098, 0.270588, 0.0745098, 1);
inline constexpr Color const SALMON = Color(0.980392, 0.501961, 0.447059, 1);
inline constexpr Color const SANDY_BROWN = Color(0.956863, 0.643137, 0.376471, 1);
inline constexpr Color const SEA_GREEN = Color(0.180392, 0.545098, 0.341176, 1);
inline constexpr Color const SEASHELL = Color(1, 0.960784, 0.933333, 1);
inline constexpr Color const SIENNA = Color(0.627451, 0.321569, 0.176471, 1);
inline constexpr Color const SILVER = Color(0.752941, 0.752941, 0.752941, 1);
inline constexpr Color const SKY_BLUE = Color(0.529412, 0.807843, 0.921569, 1);
inline constexpr Color const SLATE_BLUE = Color(0.415686, 0.352941, 0.803922, 1);
inline constexpr Color const SLATE_GRAY = Color(0.439216, 0.501961, 0.564706, 1);
inline constexpr Color const SNOW = Color(1, 0.980392, 0.980392, 1);
inline constexpr Color const SPRING_GREEN = Color(0, 1, 0.498039, 1);
inline constexpr Color const STEEL_BLUE = Color(0.27451, 0.509804, 0.705882, 1);
inline constexpr Color const TAN = Color(0.823529, 0.705882, 0.54902, 1);
inline constexpr Color const TEAL = Color(0, 0.501961, 0.501961, 1);
inline constexpr Color const THISTLE = Color(0.847059, 0.74902, 0.847059, 1);
inline constexpr Color const TOMATO = Color(1, 0.388235, 0.278431, 1);
inline constexpr Color const TRANSPARENT = Color(1, 1, 1, 0);
inline constexpr Color const TURQUOISE = Color(0.25098, 0.878431, 0.815686, 1);
inline constexpr Color const VIOLET = Color(0.933333, 0.509804, 0.933333, 1);
inline constexpr Color const WEB_GRAY = Color(0.501961, 0.501961, 0.501961, 1);
inline constexpr Color const WEB_GREEN = Color(0, 0.501961, 0, 1);
inline constexpr Color const WEB_MAROON = Color(0.501961, 0, 0, 1);
inline constexpr Color const WEB_PURPLE = Color(0.501961, 0, 0.501961, 1);
inline constexpr Color const WHEAT = Color(0.960784, 0.870588, 0.701961, 1);
inline constexpr Color const WHITE = Color(1, 1, 1, 1);
inline constexpr Color const WHITE_SMOKE = Color(0.960784, 0.960784, 0.960784, 1);
inline constexpr Color const YELLOW = Color(1, 1, 0, 1);
inline constexpr Color const YELLOW_GREEN = Color(0.603922, 0.803922, 0.196078, 1);

```

`program/cpp/docker/api/dictionary.cpp`:

```cpp
#include "dictionary.hpp"

#include "syscalls.h"

EXTERN_SYSCALL(void, sys_vcreate, Variant *, int, int, ...);
MAKE_SYSCALL(ECALL_DICTIONARY_OPS, int, sys_dict_ops, Dictionary_Op, unsigned, ...);
EXTERN_SYSCALL(unsigned, sys_vassign, unsigned, unsigned);

Dictionary &Dictionary::operator=(const Dictionary &other) {
	this->m_idx = sys_vassign(this->m_idx, other.m_idx);
	return *this;
}

void Dictionary::clear() {
	(void)sys_dict_ops(Dictionary_Op::CLEAR, m_idx);
}

void Dictionary::erase(const Variant &key) {
	(void)sys_dict_ops(Dictionary_Op::ERASE, m_idx, &key);
}

bool Dictionary::has(const Variant &key) const {
	return sys_dict_ops(Dictionary_Op::HAS, m_idx, &key);
}

int Dictionary::size() const {
	return sys_dict_ops(Dictionary_Op::GET_SIZE, m_idx);
}

Variant Dictionary::get(const Variant &key) const {
	Variant v;
	(void)sys_dict_ops(Dictionary_Op::GET, m_idx, &key, &v);
	return v;
}
void Dictionary::set(const Variant &key, const Variant &value) {
	(void)sys_dict_ops(Dictionary_Op::SET, m_idx, &key, &value);
}
Variant Dictionary::get_or_add(const Variant &key, const Variant &default_value) {
	Variant v;
	(void)sys_dict_ops(Dictionary_Op::GET_OR_ADD, m_idx, &key, &v, &default_value);
	return v;
}

void Dictionary::merge(const Dictionary &other) {
	Variant v(other);
	(void)sys_dict_ops(Dictionary_Op::MERGE, m_idx, &v);
}

Dictionary Dictionary::Create() {
	Variant v;
	sys_vcreate(&v, Variant::DICTIONARY, 0);
	Dictionary d;
	d.m_idx = v.get_internal_index();
	return d;
}

```

`program/cpp/docker/api/dictionary.hpp`:

```hpp
#pragma once

#include "variant.hpp"
struct DictAccessor;

struct Dictionary {
	constexpr Dictionary() {} // DON'T TOUCH
	static Dictionary Create();

	Dictionary &operator =(const Dictionary &other);

	DictAccessor operator[](const Variant &key);
	Variant get(const Variant &key) const;
	void set(const Variant &key, const Variant &value);
	Variant get_or_add(const Variant &key, const Variant &default_value = Variant());

	int size() const;
	bool is_empty() const { return size() == 0; }

	void clear();
	void erase(const Variant &key);
	bool has(const Variant &key) const;
	void merge(const Dictionary &other);
	Dictionary duplicate(bool deep = false) const;
	Variant find_key(const Variant &key) const;
	bool has_all(const Array &keys) const;
	int hash() const;
	bool is_read_only() const;
	Variant keys() const;
	void make_read_only();
	void merge(const Dictionary &dictionary, bool overwrite = false);
	Dictionary merged(const Dictionary &dictionary, bool overwrite = false) const;
	bool recursive_equal(const Dictionary &dictionary, int recursion_count) const;
	Variant values() const;

	// Call methods on the Dictionary
	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);
	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args) const;

	static Dictionary from_variant_index(unsigned idx) { Dictionary d; d.m_idx = idx; return d; }
	unsigned get_variant_index() const noexcept { return m_idx; }
	bool is_permanent() const { return Variant::is_permanent_index(m_idx); }

private:
	unsigned m_idx = INT32_MIN;
};

inline Dictionary Variant::as_dictionary() const {
	if (m_type != DICTIONARY) {
		api_throw("std::bad_cast", "Failed to cast Variant to Dictionary", this);
	}
	return Dictionary::from_variant_index(v.i);
}

inline Variant::Variant(const Dictionary &d) {
	m_type = DICTIONARY;
	v.i = d.get_variant_index();
}

inline Variant::operator Dictionary() const {
	return as_dictionary();
}

struct DictAccessor {
	DictAccessor(const Dictionary &dict, const Variant &key) : m_dict_idx(dict.get_variant_index()), m_key(key) {}

	operator Variant() const { return dict().get(m_key); }
	Variant operator *() const { return dict().get(m_key); }
	Variant value() const { return dict().get(m_key); }
	Variant value_or(const Variant &def) const { return dict().get_or_add(m_key, def); }

	void operator=(const Variant &value) { dict().set(m_key, value); }

	template <typename... Args>
	Variant operator ()(Args &&...args) {
		return value()(std::forward<Args>(args)...);
	}

	Dictionary dict() const { return Dictionary::from_variant_index(m_dict_idx); }

private:
	unsigned m_dict_idx;
	Variant m_key;
};

inline DictAccessor Dictionary::operator[](const Variant &key) {
	return DictAccessor(*this, key);
}

template <typename... Args>
inline Variant Dictionary::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Dictionary::operator () (std::string_view method, Args&&... args) const {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

inline Dictionary Dictionary::duplicate(bool deep) const {
	return this->operator()("duplicate", deep);
}
inline Variant Dictionary::find_key(const Variant &key) const {
	return this->operator()("find_key", key);
}
inline bool Dictionary::has_all(const Array &keys) const {
	return this->operator()("has_all", Variant(keys));
}
inline int Dictionary::hash() const {
	return this->operator()("hash");
}
inline bool Dictionary::is_read_only() const {
	return this->operator()("is_read_only");
}
inline Variant Dictionary::keys() const {
	return this->operator()("keys");
}
inline void Dictionary::make_read_only() {
	this->operator()("make_read_only");
}
inline void Dictionary::merge(const Dictionary &dictionary, bool overwrite) {
	this->operator()("merge", Variant(dictionary), overwrite);
}
inline Dictionary Dictionary::merged(const Dictionary &dictionary, bool overwrite) const {
	return this->operator()("merged", Variant(dictionary), overwrite);
}
inline bool Dictionary::recursive_equal(const Dictionary &dictionary, int recursion_count) const {
	return this->operator()("recursive_equal", Variant(dictionary), recursion_count);
}
inline Variant Dictionary::values() const {
	return this->operator()("values");
}

```

`program/cpp/docker/api/function.hpp`:

```hpp
/*
 * Copyright (c) 2017 Ambroz Bizjak
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once
#include <cstddef>

#include <type_traits>
#include <functional>
#include <utility>
#include <new>

/**
 * @ingroup misc
 * @defgroup function Function Wrapper
 * @brief Lightweight polymorphic function wrapper and related utilities
 * 
 * The @ref Function<Ret(Args...)> "Function" class is a general-purpose lightweight
 * polymorphic function wrapper. It has intentionally very limited storage capabilities
 * in order to ensure minimal overhead and no possibility of exceptions when copying.
 * In this documentation, "function object" refers to an instance of @ref
 * Function<Ret(Args...)> "Function".
 * 
 * Function objects are most often used for asynchronous callbacks. However this is not
 * the only possible mechanism for that purpose, virtual functions being the other major
 * one as used in the stack. The choice of which to use is often not simple, but a
 * general rule is that if more than one callback function is needed then virtual
 * functions in the same class should be considered.
 * 
 * In practical use, valid function objects are created in the following ways:
 * - From a combination of non-static member function and pointer to object, using the
 *   macros @ref AIPSTACK_BIND_MEMBER and @ref AIPSTACK_BIND_MEMBER_TN (which one depends
 *   on the context). This approach should be preferred when function objects are used
 *   for asynchronous callbacks.
 * - From a lambda object using the Function(Callable) constructor. The lambda object
 *   must meet the requirements specified for this constructor which means that one
 *   is very limited in what the lambda can capture, though capturing a single pointer
 *   or reference specifically should work.
 * 
 * @{
 */

/**
 * Maximum size of callable objects that @ref Function<Ret(Args...)> "Function" can
 * store when using the Function(Callable) constructor.
 */
inline constexpr std::size_t FunctionStorageSize = sizeof(void *) * 3;

template<typename>
class Function;

/**
 * A general-purpose lightweight polymorphic function wrapper.
 * 
 * Consult the @ref function module description for an introduction.
 * 
 * A function object is always either empty or stores a callable object. The @ref
 * operator bool() "bool operator" can be used to determine which is the case.
 * 
 * @tparam Ret Return type (may be void).
 * @tparam Args Argument types.
 */
template<typename Ret, typename ...Args>
class Function<Ret(Args...)>
{
    struct Storage {
        alignas(alignof(void*)) char data[FunctionStorageSize];
    };

    using FunctionPointerType = Ret (*) (Storage, Args...);

public:
    /**
     * Default constructor, constructs an empty function object.
     */
    inline Function () noexcept :
        m_func_ptr(nullptr)
    {}

    /**
     * Constructor from nullptr, constructs an empty function object.
     */
    inline Function (std::nullptr_t) noexcept :
        Function()
    {}

    /**
     * Constructor from a callable, constructs a function object storing the
     * callable.
     * 
     * The `Callable` type must satisfy the following requirements:
     * - Its size must be less than or equal to @ref FunctionStorageSize.
     * - It must be trivially copy-constructible.
     * - It must be trivially destructible.
     * - It must be possible to "call" a const object of that type with arguments
     *   of types `Args` and convert the return value to type `Ret` (see below for
     *   details).
     * 
     * When the function object storing this callable is invoked using @ref
     * operator()() "operator()", the callable is invoked using an expression like
     * `callable(std::forward<Args>(args)...)`, where `callable` is a const
     * reference to a copy of the `Callable` object and `args` are the arguments
     * declared as `Args ...args`. The result of this expression is returned in
     * the context of a function returning type `Ret`, so it must be implicitly
     * convertible to `Ret`.
     * 
     * @tparam Callable Type of callable object to be stored (see description for
     *         requirements).
     * @param callable Callable object to be stored in the function object.
     */
    template<typename Callable>
    Function (Callable callable) noexcept
    {
        static_assert(sizeof(Callable) <= FunctionStorageSize,
                      "Callable too large (greater than FunctionStorageSize)");
        static_assert(std::is_trivially_copy_constructible_v<Callable>,
                      "Callable not trivially copy constructible");
        static_assert(std::is_trivially_destructible_v<Callable>,
                      "Callable not trivially destructible");

        m_func_ptr = &trampoline<Callable>;

        new(reinterpret_cast<Callable *>(m_storage.data)) Callable(callable);
    }

    /**
     * Determine whether the function object stores a callable.
     * 
     */
	bool operator==(std::nullptr_t) const noexcept { return m_func_ptr == nullptr; }
	bool operator!=(std::nullptr_t) const noexcept { return m_func_ptr != nullptr; }

    /**
     * Invoke the stored callable object.
     * 
     * @note The behavior is undefined if the function object is empty.
     * 
     * @param args Arguments forwarded to the stored callable object.
     * @return Value returned by the invocation of the callable object.
     */
    inline Ret operator() (Args ...args) const
    {
        return (*m_func_ptr)(m_storage, std::forward<Args>(args)...);
    }

    inline FunctionPointerType get() const noexcept
    {
        return m_func_ptr;
    }

private:
    template<typename Callable>
    static Ret trampoline (Storage storage, Args ...args)
    {
        Callable const *c = reinterpret_cast<Callable const *>(storage.data);
        return (*c)(std::forward<Args>(args)...);
    }

private:
    FunctionPointerType m_func_ptr;
    Storage m_storage;
};

/**
 * Wrap a const reference using `std::reference_wrapper`.
 * 
 * This is intended to be used together with the Function(Callable) constructor to
 * bypass the restrictions regarding object size and trivial
 * copy-construction/destruction.
 * 
 * @warning When this is used to construct a function object, the resulting function
 * object references the original callable as passed to this function and must not
 * be invoked after the callable has been destructed.
 * 
 * @tparam Callable Type of object to which a reference is to be wrapped.
 * @param callable Reference to object to be wrapped.
 * @return Wrapped reference: `std::reference_wrapper<Callable const>(callable)`.
 */
template<typename Callable>
inline std::reference_wrapper<Callable const> RefFunc (Callable const &callable) noexcept
{
    return std::reference_wrapper<Callable const>(callable);
}

namespace BindPrivate {
    template<typename Container, typename Ret, typename ...Args>
    struct BindImpl {
        template<Ret (Container::*MemberFunc)(Args...)>
        class Callable {
        public:
            inline constexpr Callable (Container *container) :
                m_container(container)
            {}

            inline Ret operator() (Args ...args) const
            {
                return (m_container->*MemberFunc)(std::forward<Args>(args)...);
            }

            inline Function<Ret(Args...)> toFunction() const
            {
                return Function<Ret(Args...)>(*this);
            }

        private:
            Container *m_container;
        };
    };

    template<typename Container, typename Ret, typename ...Args>
    struct BindImplConst {
        template<Ret (Container::*MemberFunc)(Args...) const>
        class Callable {
        public:
            inline constexpr Callable (Container const *container) :
                m_container(container)
            {}

            inline Ret operator() (Args ...args) const
            {
                return (m_container->*MemberFunc)(std::forward<Args>(args)...);
            }

            inline Function<Ret(Args...)> toFunction() const
            {
                return Function<Ret(Args...)>(*this);
            }

        private:
            Container const *m_container;
        };
    };

    template<typename Container, typename Ret, typename ...Args>
    BindImpl<Container, Ret, Args...> DeduceImpl (Ret (Container::*)(Args...));

    template<typename Container, typename Ret, typename ...Args>
    BindImplConst<Container, Ret, Args...> DeduceImpl (Ret (Container::*)(Args...) const);
}

```

`program/cpp/docker/api/native.cpp`:

```cpp
#include "syscalls.h"
#include <array>
#include <cstddef>
#include <cstdint>

#define NATIVE_MEM_FUNCATTR /* */
#define NATIVE_SYSCALLS_BASE 480 /* libc starts at 480 */

#define SYSCALL_MALLOC (NATIVE_SYSCALLS_BASE + 0)
#define SYSCALL_CALLOC (NATIVE_SYSCALLS_BASE + 1)
#define SYSCALL_REALLOC (NATIVE_SYSCALLS_BASE + 2)
#define SYSCALL_FREE (NATIVE_SYSCALLS_BASE + 3)
#define SYSCALL_MEMINFO (NATIVE_SYSCALLS_BASE + 4)

#define SYSCALL_MEMCPY (NATIVE_SYSCALLS_BASE + 5)
#define SYSCALL_MEMSET (NATIVE_SYSCALLS_BASE + 6)
#define SYSCALL_MEMMOVE (NATIVE_SYSCALLS_BASE + 7)
#define SYSCALL_MEMCMP (NATIVE_SYSCALLS_BASE + 8)

#define SYSCALL_STRLEN (NATIVE_SYSCALLS_BASE + 10)
#define SYSCALL_STRCMP (NATIVE_SYSCALLS_BASE + 11)

#define SYSCALL_BACKTRACE (NATIVE_SYSCALLS_BASE + 19)

#define STR1(x) #x
#define STR(x) STR1(x)

// clang-format off
#define CREATE_SYSCALL(name, syscall_id)                 \
	__asm__(".pushsection .text\n"                  \
			".global " #name "\n"            \
			".type " #name ", @function\n"   \
			"" #name ":\n"                   \
			"	li a7, " STR(syscall_id) "\n"       \
			"	ecall\n" \
			"	ret\n"   \
			".popsection .text\n")
#define CREATE_SYSCALL_STRCMP(name, syscall_id) \
	__asm__(".pushsection .text\n"              \
			".global " #name "\n"            \
			".type " #name ", @function\n"   \
			"" #name ":\n"                   \
			"   li a2, 4096\n"               \
			"	li a7, " STR(syscall_id) "\n"       \
			"	ecall\n" \
			"	ret\n"   \
			".popsection .text\n")

// clang-format on

#ifdef ZIG_COMPILER
#define WRAP_FANCY 0
#else
#define WRAP_FANCY 1
#endif

#if !WRAP_FANCY
CREATE_SYSCALL(malloc, SYSCALL_MALLOC);
CREATE_SYSCALL(calloc, SYSCALL_CALLOC);
CREATE_SYSCALL(realloc, SYSCALL_REALLOC);
CREATE_SYSCALL(free, SYSCALL_FREE);
CREATE_SYSCALL(memset, SYSCALL_MEMSET);
CREATE_SYSCALL(memcpy, SYSCALL_MEMCPY);
CREATE_SYSCALL(memmove, SYSCALL_MEMMOVE);
CREATE_SYSCALL(memcmp, SYSCALL_MEMCMP);
CREATE_SYSCALL(strlen, SYSCALL_STRLEN);
CREATE_SYSCALL_STRCMP(strcmp, SYSCALL_STRCMP);
CREATE_SYSCALL(strncmp, SYSCALL_STRCMP);

extern "C" void *__wrap_malloc(size_t size) {
	register void *ret __asm__("a0");
	register size_t a0 __asm__("a0") = size;
	register long syscall_id __asm__("a7") = SYSCALL_MALLOC;

	asm volatile("ecall"
				 : "=m"(*(char(*)[size])ret), "=r"(ret)
				 : "r"(a0), "r"(syscall_id));
	return ret;
}
extern "C" void __wrap_free(void *ptr) {
	register void *a0 __asm__("a0") = ptr;
	register long syscall_id __asm__("a7") = SYSCALL_FREE;

	asm volatile("ecall"
				 :
				 : "r"(a0), "r"(syscall_id));
}
#else // WRAP_FANCY

CREATE_SYSCALL(__wrap_malloc, SYSCALL_MALLOC);
CREATE_SYSCALL(__wrap_calloc, SYSCALL_CALLOC);
CREATE_SYSCALL(__wrap_realloc, SYSCALL_REALLOC);
CREATE_SYSCALL(__wrap_free, SYSCALL_FREE);
CREATE_SYSCALL(__wrap_memset, SYSCALL_MEMSET);
CREATE_SYSCALL(__wrap_memcpy, SYSCALL_MEMCPY);
CREATE_SYSCALL(__wrap_memmove, SYSCALL_MEMMOVE);
CREATE_SYSCALL(__wrap_memcmp, SYSCALL_MEMCMP);
CREATE_SYSCALL(__wrap_strlen, SYSCALL_STRLEN);
CREATE_SYSCALL_STRCMP(__wrap_strcmp, SYSCALL_STRCMP);
CREATE_SYSCALL_STRCMP(__wrap_strncmp, SYSCALL_STRCMP);

extern "C" void *__wrap_malloc(size_t size);
extern "C" void __wrap_free(void *ptr);
#endif // WRAP_FANCY

// extern "C" void *__wrap_memset(void *vdest, const int ch, size_t size) {
// 	register char *a0 __asm__("a0") = (char *)vdest;
// 	register int a1 __asm__("a1") = ch;
// 	register size_t a2 __asm__("a2") = size;
// 	register long syscall_id __asm__("a7") = SYSCALL_MEMSET;

// 	asm volatile("ecall"
// 				 : "=m"(*(char(*)[size])a0)
// 				 : "r"(a0), "r"(a1), "r"(a2), "r"(syscall_id));
// 	return vdest;
// }
// extern "C" void *__wrap_memcpy(void *vdest, const void *vsrc, size_t size) {
// 	register char *a0 __asm__("a0") = (char *)vdest;
// 	register const char *a1 __asm__("a1") = (const char *)vsrc;
// 	register size_t a2 __asm__("a2") = size;
// 	register long syscall_id __asm__("a7") = SYSCALL_MEMCPY;

// 	asm volatile("ecall"
// 				 : "=m"(*(char(*)[size])a0), "+r"(a0)
// 				 : "r"(a1), "m"(*(const char(*)[size])a1),
// 				 "r"(a2), "r"(syscall_id));
// 	return vdest;
// }
// extern "C" void *__wrap_memmove(void *vdest, const void *vsrc, size_t size) {
// 	// An assumption is being made here that since vsrc might be
// 	// inside vdest, we cannot assume that vsrc is const anymore.
// 	register char *a0 __asm__("a0") = (char *)vdest;
// 	register char *a1 __asm__("a1") = (char *)vsrc;
// 	register size_t a2 __asm__("a2") = size;
// 	register long syscall_id __asm__("a7") = SYSCALL_MEMMOVE;

// 	asm volatile("ecall"
// 				 : "=m"(*(char(*)[size])a0), "=m"(*(char(*)[size])a1)
// 				 : "r"(a0), "r"(a1), "r"(a2), "r"(syscall_id));
// 	return vdest;
// }
// extern "C" int __wrap_memcmp(const void *m1, const void *m2, size_t size) {
// 	register const char *a0 __asm__("a0") = (const char *)m1;
// 	register const char *a1 __asm__("a1") = (const char *)m2;
// 	register size_t a2 __asm__("a2") = size;
// 	register long syscall_id __asm__("a7") = SYSCALL_MEMCMP;
// 	register int a0_out __asm__("a0");

// 	asm volatile("ecall"
// 				 : "=r"(a0_out)
// 				 : "r"(a0), "m"(*(const char(*)[size])a0),
// 				 "r"(a1), "m"(*(const char(*)[size])a1),
// 				 "r"(a2), "r"(syscall_id));
// 	return a0_out;
// }
// extern "C" size_t __wrap_strlen(const char *str) {
// 	register const char *a0 __asm__("a0") = str;
// 	register size_t a0_out __asm__("a0");
// 	register long syscall_id __asm__("a7") = SYSCALL_STRLEN;

// 	asm volatile("ecall"
// 				 : "=r"(a0_out)
// 				 : "r"(a0), "m"(*(const char(*)[4096])a0), "r"(syscall_id));
// 	return a0_out;
// }
// extern "C" int __wrap_strcmp(const char *str1, const char *str2) {
// 	register const char *a0 __asm__("a0") = str1;
// 	register const char *a1 __asm__("a1") = str2;
// 	register size_t a2 __asm__("a2") = 4096;
// 	register size_t a0_out __asm__("a0");
// 	register long syscall_id __asm__("a7") = SYSCALL_STRCMP;

// 	asm volatile("ecall"
// 				 : "=r"(a0_out)
// 				 : "r"(a0), "m"(*(const char(*)[4096])a0),
// 				 "r"(a1), "m"(*(const char(*)[4096])a1),
// 				 "r"(a2), "r"(syscall_id));
// 	return a0_out;
// }
// extern "C" int __wrap_strncmp(const char *str1, const char *str2, size_t maxlen) {
// 	register const char *a0 __asm__("a0") = str1;
// 	register const char *a1 __asm__("a1") = str2;
// 	register size_t a2 __asm__("a2") = maxlen;
// 	register size_t a0_out __asm__("a0");
// 	register long syscall_id __asm__("a7") = SYSCALL_STRCMP;

// 	asm volatile("ecall"
// 				 : "=r"(a0_out)
// 				 : "r"(a0), "m"(*(const char(*)[maxlen])a0),
// 				 "r"(a1), "m"(*(const char(*)[maxlen])a1),
// 				 "r"(a2), "r"(syscall_id));
// 	return a0_out;
// }

// Fallback implementation of aligned allocations
extern "C" void *memalign(size_t alignment, size_t size) {
	if (alignment <= 16) {
		return __wrap_malloc(size);
	}

	std::array<void *, 16> list;
	size_t i = 0;
	void *result = nullptr;
	for (i = 0; i < list.size(); i++) {
		result = __wrap_malloc(size);
		list[i] = result;
		const bool aligned = ((uintptr_t)result % alignment) == 0;
		if (result && aligned) {
			break;
		} else if (result) {
			__wrap_free(result);
			list[i] = __wrap_malloc(16);
		} else {
			result = nullptr;
			break;
		}
	}
	for (size_t j = 0; j < i; j++) {
		__wrap_free(list[j]);
	}
	return result;
}
extern "C" void *aligned_alloc(size_t alignment, size_t size) {
	return memalign(alignment, size);
}
extern "C" int posix_memalign(void **memptr, size_t alignment, size_t size) {
	void *result = memalign(alignment, size);
	if (result) {
		*memptr = result;
		return 0;
	}
	return 1;
}

void *operator new(size_t size) noexcept(false) {
	return __wrap_malloc(size);
}
void *operator new[](size_t size) noexcept(false) {
	return __wrap_malloc(size);
}
void operator delete(void *ptr) noexcept(true) {
	__wrap_free(ptr);
}
void operator delete[](void *ptr) noexcept(true) {
	__wrap_free(ptr);
}
void *operator new(size_t size, size_t alignment) noexcept(false) {
	return memalign(alignment, size);
}
void *operator new[](size_t size, size_t alignment) noexcept(false) {
	return memalign(alignment, size);
}
void operator delete(void *ptr, size_t alignment) noexcept(true) {
	__wrap_free(ptr);
}
void operator delete[](void *ptr, size_t alignment) noexcept(true) {
	__wrap_free(ptr);
}

```

`program/cpp/docker/api/node.cpp`:

```cpp
#include "node.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_GET_NODE, uint64_t, sys_get_node, uint64_t, const char *, size_t);
MAKE_SYSCALL(ECALL_NODE, void, sys_node, Node_Op, uint64_t, ...);
MAKE_SYSCALL(ECALL_NODE_CREATE, uint64_t, sys_node_create, Node_Create_Shortlist, const char *, size_t, const char *, size_t);

static uint64_t sys_fast_get_node(uint64_t parent, const char *path, size_t path_len) {
	// uses sys_get_node
	register uint64_t addr asm("a0") = parent;
	register const char *path_ptr asm("a1") = path;
	register size_t path_size asm("a2") = path_len;
	register int syscall_number asm("a7") = ECALL_GET_NODE;

	asm volatile(
		"ecall"
		: "+r"(addr)
		: "r"(path_ptr), "m"(*path_ptr), "r"(path_size), "r"(syscall_number)
	);

	return addr;
}

Node::Node(std::string_view path) :
		Object(sys_fast_get_node(0, path.begin(), path.size())) {
}

Variant Node::get_name() const {
	Variant var;
	sys_node(Node_Op::GET_NAME, address(), &var);
	return var;
}

void Node::set_name(Variant name) {
	sys_node(Node_Op::SET_NAME, address(), &name);
}

Variant Node::get_path() const {
	Variant var;
	sys_node(Node_Op::GET_PATH, address(), &var);
	return var;
}

Node Node::get_parent() const {
	uint64_t addr;
	sys_node(Node_Op::GET_PARENT, address(), &addr);
	return Node(addr);
}

unsigned Node::get_child_count() const {
	int64_t result;
	sys_node(Node_Op::GET_CHILD_COUNT, address(), &result);
	return result;
}

Node Node::get_child(unsigned index) const {
	Variant var;
	sys_node(Node_Op::GET_CHILD, address(), &var);
	return var.as_node();
}

void Node::add_child(const Node &child, bool deferred) {
	Variant v(int64_t(child.address()));
	sys_node(deferred ? Node_Op::ADD_CHILD_DEFERRED : Node_Op::ADD_CHILD, this->address(), &v);
}

void Node::add_sibling(const Node &sibling, bool deferred) {
	Variant v(int64_t(sibling.address()));
	sys_node(deferred ? Node_Op::ADD_SIBLING_DEFERRED : Node_Op::ADD_SIBLING, this->address(), &v);
}

void Node::move_child(const Node &child, unsigned index) {
	Variant v(int64_t(child.address()));
	sys_node(Node_Op::MOVE_CHILD, this->address(), &v);
}

void Node::remove_child(const Node &child, bool deferred) {
	Variant v(int64_t(child.address()));
	sys_node(deferred ? Node_Op::REMOVE_CHILD_DEFERRED : Node_Op::REMOVE_CHILD, this->address(), &v);
}

std::vector<Node> Node::get_children() const {
	std::vector<Node> children;
	sys_node(Node_Op::GET_CHILDREN, address(), &children);
	return children;
}

Node Node::get_node(std::string_view name) const {
	return Node(sys_fast_get_node(address(), name.begin(), name.size()));
}

void Node::queue_free() {
	sys_node(Node_Op::QUEUE_FREE, address(), nullptr);
	//this->m_address = 0;
}

Node Node::duplicate(int flags) const {
	uint64_t result;
	sys_node(Node_Op::DUPLICATE, this->address(), &result, flags);
	return Node(result);
}

Node Node::Create(std::string_view path) {
	return Node(sys_node_create(Node_Create_Shortlist::CREATE_NODE, nullptr, 0, path.data(), path.size()));
}

void Node::reparent(const Node &new_parent, bool keep_global_transform) {
	sys_node(Node_Op::REPARENT, this->address(), new_parent.address(), keep_global_transform);
}

void Node::replace_by(const Node &node, bool keep_groups) {
	sys_node(Node_Op::REPLACE_BY, this->address(), node.address(), keep_groups);
}

void Node::add_to_group(std::string_view group) {
	sys_node(Node_Op::ADD_TO_GROUP, this->address(), group.data(), group.size());
}

void Node::remove_from_group(std::string_view group) {
	sys_node(Node_Op::REMOVE_FROM_GROUP, this->address(), group.data(), group.size());
}

bool Node::is_in_group(std::string_view group) const {
	bool result;
	sys_node(Node_Op::IS_IN_GROUP, this->address(), group.data(), group.size(), &result);
	return result;
}

bool Node::is_inside_tree() const {
	bool result;
	sys_node(Node_Op::IS_INSIDE_TREE, this->address(), &result);
	return result;
}

```

`program/cpp/docker/api/node.hpp`:

```hpp
#pragma once
#include "object.hpp"

struct Node : public Object {
	/// @brief Construct a Node object from an existing in-scope Node object.
	/// @param addr The address of the Node object.
	constexpr Node(uint64_t addr) : Object{addr} {}
	constexpr Node(Object obj) : Object{obj.address()} {}

	/// @brief Construct a Node object from a path.
	/// @param path The path to the Node object.
	Node(std::string_view path);

	/// @brief Get the name of the node.
	/// @return The name of the node.
	Variant get_name() const;

	/// @brief Set the name of the node.
	/// @param name The new name of the node.
	void set_name(Variant name);

	/// @brief Get the path of the node, relative to the root node.
	/// @return The path of the node.
	Variant get_path() const;

	/// @brief Get the parent of the node.
	/// @return The parent node.
	Node get_parent() const;

	/// @brief Get the Node object at the given path, relative to this node.
	/// @param path The path to the Node object.
	/// @return The Node object.
	Node get_node(std::string_view path) const;

	template <typename T>
	T get_node(std::string_view path) const {
		return T(get_node(path));
	}

	/// @brief Get the number of children of the node.
	/// @return The number of children.
	unsigned get_child_count() const;

	/// @brief Get the child of the node at the given index.
	/// @param index The index of the child.
	/// @return The child node.
	Node get_child(unsigned index) const;

	/// @brief Add a child to the node.
	/// @param child The child node to add.
	/// @param deferred If true, the child will be added next frame.
	void add_child(const Node &child, bool deferred = false);

	/// @brief Add a sibling to the node.
	/// @param sibling The sibling node to add.
	/// @param deferred If true, the sibling will be added next frame.
	void add_sibling(const Node &sibling, bool deferred = false);

	/// @brief Move a child of the node to a new index.
	/// @param child The child node to move.
	/// @param index The new index of the child.
	void move_child(const Node &child, unsigned index);

	/// @brief Remove a child from the node. The child is *not* freed.
	/// @param child The child node to remove.
	/// @param deferred If true, the child will be removed next frame.
	void remove_child(const Node &child, bool deferred = false);

	/// @brief Get a list of children of the node.
	/// @return A list of children nodes.
	std::vector<Node> get_children() const;

	/// @brief Add the node to a group.
	/// @param group The group to add the node to.
	void add_to_group(std::string_view group);

	/// @brief Remove the node from a group.
	/// @param group The group to remove the node from.
	void remove_from_group(std::string_view group);

	/// @brief Check if the node is in a group.
	/// @param group The group to check.
	/// @return True if the node is in the group, false otherwise.
	bool is_in_group(std::string_view group) const;

	/// @brief Check if the node is inside the scene tree.
	/// @return True if the node is inside the scene tree, false otherwise.
	bool is_inside_tree() const;

	/// @brief Replace the node with another node.
	/// @param node The node to replace this node with.
	void replace_by(const Node &node, bool keep_groups = false);

	/// @brief Changes the parent of this Node to the new_parent.
	/// The node needs to already have a parent.
	/// The node's owner is preserved if its owner is still reachable
	/// from the new location (i.e., the node is still a descendant
	/// of the new parent after the operation).
	/// @param new_parent The new parent node.
	/// @param keep_global_transform If true, the node's global transform is preserved.
	void reparent(const Node &new_parent, bool keep_global_transform = true);

	/// @brief Remove this node from its parent, freeing it.
	/// @note This is a potentially deferred operation.
	void queue_free();

	/// @brief  Duplicate the node.
	/// @return A new Node object with the same properties and children.
	Node duplicate(int flags = 15) const;

	/// @brief Create a new Node object.
	/// @param path The path to the Node object.
	/// @return The Node object.
	static Node Create(std::string_view path);

	//- Properties -//
	PROPERTY(name, String);
	PROPERTY(owner, Node);
	PROPERTY(unique_name_in_owner, bool);
	PROPERTY(editor_description, String);
	PROPERTY(physics_interpolation_mode, int64_t);
	PROPERTY(process_mode, int64_t);
	PROPERTY(process_priority, int64_t);

	//- Methods -//
	METHOD(bool, can_process);
	METHOD(Object, create_tween);
	METHOD(Node, find_child);
	METHOD(Variant, find_children);
	METHOD(Node, find_parent);
	METHOD(Node, get_viewport);
	METHOD(Node, get_window);
	METHOD(bool, has_node);
	METHOD(bool, has_node_and_resource);
	METHOD(bool, is_ancestor_of);
	METHOD(void, set_physics_process);
	METHOD(bool, is_physics_processing);
	METHOD(void, set_physics_process_internal);
	METHOD(bool, is_physics_processing_internal);
	METHOD(void, set_process);
	METHOD(bool, is_processing);
	METHOD(void, set_process_input);
	METHOD(bool, is_processing_input);
	METHOD(void, set_process_internal);
	METHOD(bool, is_processing_internal);
	METHOD(void, set_process_unhandled_input);
	METHOD(bool, is_processing_unhandled_input);
	METHOD(void, set_process_unhandled_key_input);
	METHOD(bool, is_processing_unhandled_key_input);
	METHOD(void, set_process_shortcut_input);
	METHOD(bool, is_processing_shortcut_input);
	METHOD(bool, is_node_ready);
	METHOD(void, set_thread_safe);
	METHOD(void, set_owner);
	METHOD(Node, get_owner);
	METHOD(void, set_scene_file_path);
	METHOD(String, get_scene_file_path);
	METHOD(void, print_tree);
	METHOD(void, print_tree_pretty);
	METHOD(void, print_orphan_nodes);
	METHOD(void, propagate_call);


	//- Signals -//

	//- Constants -//
	static constexpr int PROCESS_MODE_INHERIT = 0;
	static constexpr int PROCESS_MODE_PAUSABLE = 1;
	static constexpr int PROCESS_MODE_WHEN_PAUSED = 2;
	static constexpr int PROCESS_MODE_ALWAYS = 3;
	static constexpr int PROCESS_MODE_DISABLED = 4;

	static constexpr int PHYSICS_INTERPOLATION_MODE_INHERIT = 0;
	static constexpr int PHYSICS_INTERPOLATION_MODE_ON = 1;
	static constexpr int PHYSICS_INTERPOLATION_MODE_OFF = 2;

	static constexpr int DUPLICATE_SIGNALS = 1;
	static constexpr int DUPLICATE_GROUPS = 2;
	static constexpr int DUPLICATE_SCRIPTS = 4;
	static constexpr int DUPLICATE_USE_INSTANTIATION = 8;
};

inline Node Variant::as_node() const {
	if (get_type() == Variant::OBJECT)
		return Node{uintptr_t(v.i)};
	else if (get_type() == Variant::NODE_PATH)
		return Node{this->internal_fetch_string()};

	api_throw("std::bad_cast", "Variant is not a Node or NodePath", this);
}

inline Node Object::as_node() const {
	return Node{address()};
}

template <typename T>
static inline T cast_to(const Variant &var) {
	if (var.get_type() == Variant::OBJECT)
		return T{uintptr_t(var)};
	api_throw("std::bad_cast", "Variant is not an Object", &var);
}

inline Variant::Variant(const Node &node) {
	m_type = OBJECT;
	v.i = node.address();
}

inline Variant::operator Node() const {
	return as_node();
}

```

`program/cpp/docker/api/node2d.cpp`:

```cpp
#include "node2d.hpp"

#include "syscalls.h"
#include "transform2d.hpp"

// API call to get/set Node2D properties.
MAKE_SYSCALL(ECALL_NODE2D, void, sys_node2d, Node2D_Op, uint64_t, Variant *);
EXTERN_SYSCALL(void, sys_node, Node_Op, uint64_t, Variant *);
EXTERN_SYSCALL(uint64_t, sys_node_create, Node_Create_Shortlist, const char *, size_t, const char *, size_t);

static inline void node2d(Node2D_Op op, uint64_t address, const Variant &value) {
	sys_node2d(op, address, const_cast<Variant *>(&value));
}

Vector2 Node2D::get_position() const {
	Variant var;
	node2d(Node2D_Op::GET_POSITION, address(), var);
	return var.v2();
}

void Node2D::set_position(const Vector2 &position) {
	Variant value(position);
	node2d(Node2D_Op::SET_POSITION, address(), value);
}

float Node2D::get_rotation() const {
	Variant var;
	node2d(Node2D_Op::GET_ROTATION, address(), var);
	return var.operator float();
}

void Node2D::set_rotation(real_t angle) {
	Variant value(angle);
	node2d(Node2D_Op::SET_ROTATION, address(), value);
}

Vector2 Node2D::get_scale() const {
	Variant var;
	node2d(Node2D_Op::GET_SCALE, address(), var);
	return var.v2();
}

void Node2D::set_scale(const Vector2 &scale) {
	Variant value(scale);
	node2d(Node2D_Op::SET_SCALE, address(), value);
}

float Node2D::get_skew() const {
	Variant var;
	node2d(Node2D_Op::GET_SKEW, address(), var);
	return var.operator float();
}

void Node2D::set_skew(const Variant &value) {
	node2d(Node2D_Op::SET_SKEW, address(), value);
}

void Node2D::set_transform(const Transform2D &value) {
	Variant var(value);
	node2d(Node2D_Op::SET_TRANSFORM, address(), var);
}

Transform2D Node2D::get_transform() const {
	Variant var;
	node2d(Node2D_Op::GET_TRANSFORM, address(), var);
	return var.as_transform2d();
}

Node2D Node2D::duplicate(int flags) const {
	return Node::duplicate(flags);
}

Node2D Node2D::Create(std::string_view path) {
	return Node2D(sys_node_create(Node_Create_Shortlist::CREATE_NODE2D, nullptr, 0, path.data(), path.size()));
}

```

`program/cpp/docker/api/node2d.hpp`:

```hpp
#pragma once
#include "canvas_item.hpp"
struct Transform2D;

// Node2D: Contains 2D transformations.
// Such as: position, rotation, scale, and skew.
struct Node2D : public CanvasItem {
	/// @brief Construct a Node2D object from an existing in-scope Node object.
	/// @param addr The address of the Node2D object.
	constexpr Node2D(uint64_t addr) : CanvasItem(addr) {}
	constexpr Node2D(Object obj) : CanvasItem(obj) {}
	constexpr Node2D(Node node) : CanvasItem(node) {}

	/// @brief Construct a Node2D object from a path.
	/// @param path The path to the Node2D object.
	Node2D(std::string_view path) : CanvasItem(path) {}

	/// @brief Get the position of the node.
	/// @return The position of the node.
	Vector2 get_position() const;
	/// @brief Set the position of the node.
	/// @param value The new position of the node.
	void set_position(const Vector2 &value);

	/// @brief Get the rotation of the node.
	/// @return The rotation of the node.
	real_t get_rotation() const;
	/// @brief Set the rotation of the node.
	/// @param value The new rotation of the node.
	void set_rotation(real_t value);

	/// @brief Get the scale of the node.
	/// @return The scale of the node.
	Vector2 get_scale() const;
	/// @brief Set the scale of the node.
	/// @param value The new scale of the node.
	void set_scale(const Vector2 &value);

	/// @brief Get the skew of the node.
	/// @return The skew of the node.
	float get_skew() const;
	/// @brief Set the skew of the node.
	/// @param value The new skew of the node.
	void set_skew(const Variant &value);

	/// @brief Set the 2D transform of the node.
	/// @param value The new 2D transform of the node.
	void set_transform(const Transform2D &value);

	/// @brief Get the 2D transform of the node.
	/// @return The 2D transform of the node.
	Transform2D get_transform() const;

	/// @brief  Duplicate the node.
	/// @return A new Node2D with the same properties and children.
	Node2D duplicate(int flags = 15) const;

	/// @brief Create a new Node2D node.
	/// @param path The path to the Node2D node.
	/// @return The Node2D node.
	static Node2D Create(std::string_view path);
};

inline Node2D Variant::as_node2d() const {
	if (get_type() == Variant::OBJECT)
		return Node2D{uintptr_t(v.i)};
	else if (get_type() == Variant::NODE_PATH)
		return Node2D{this->internal_fetch_string()};

	api_throw("std::bad_cast", "Variant is not a Node2D or NodePath", this);
}

inline Node2D Object::as_node2d() const {
	return Node2D{address()};
}

inline Variant::Variant(const Node2D &node) {
	m_type = OBJECT;
	v.i = node.address();
}

```

`program/cpp/docker/api/node3d.cpp`:

```cpp
#include "node3d.hpp"

#include "quaternion.hpp"
#include "syscalls.h"
#include "transform3d.hpp"

// API call to get/set Node3D properties.
MAKE_SYSCALL(ECALL_NODE3D, void, sys_node3d, Node3D_Op, uint64_t, Variant *);
EXTERN_SYSCALL(void, sys_node, Node_Op, uint64_t, Variant *);
EXTERN_SYSCALL(uint64_t, sys_node_create, Node_Create_Shortlist, const char *, size_t, const char *, size_t);

static inline void node3d(Node3D_Op op, uint64_t address, const Variant &value) {
	sys_node3d(op, address, const_cast<Variant *>(&value));
}

Vector3 Node3D::get_position() const {
	Variant var;
	node3d(Node3D_Op::GET_POSITION, address(), var);
	return var.v3();
}

void Node3D::set_position(const Variant &value) {
	node3d(Node3D_Op::SET_POSITION, address(), value);
}

Vector3 Node3D::get_rotation() const {
	Variant var;
	node3d(Node3D_Op::GET_ROTATION, address(), var);
	return var.v3();
}

void Node3D::set_rotation(const Variant &value) {
	node3d(Node3D_Op::SET_ROTATION, address(), value);
}

Vector3 Node3D::get_scale() const {
	Variant var;
	node3d(Node3D_Op::GET_SCALE, address(), var);
	return var.v3();
}

void Node3D::set_scale(const Variant &value) {
	node3d(Node3D_Op::SET_SCALE, address(), value);
}

Node3D Node3D::duplicate(int flags) const {
	return Node::duplicate(flags);
}

Node3D Node3D::Create(std::string_view path) {
	return Node3D(sys_node_create(Node_Create_Shortlist::CREATE_NODE3D, nullptr, 0, path.data(), path.size()));
}

Transform3D Node3D::get_transform() const {
	Variant var;
	sys_node3d(Node3D_Op::GET_TRANSFORM, address(), &var);
	return var.as_transform3d();
}

void Node3D::set_transform(const Transform3D &value) {
	Variant var(value);
	sys_node3d(Node3D_Op::SET_TRANSFORM, address(), &var);
}

Quaternion Node3D::get_quaternion() const {
	Variant var;
	sys_node3d(Node3D_Op::GET_QUATERNION, address(), &var);
	return var;
}

void Node3D::set_quaternion(const Quaternion &value) {
	Variant var(value);
	sys_node3d(Node3D_Op::SET_QUATERNION, address(), &var);
}

```

`program/cpp/docker/api/node3d.hpp`:

```hpp
#pragma once
#include "node.hpp"
struct Transform3D;
struct Quaternion;

// Node3D: Contains 3D tranformations.
// Such as: position, rotation, scale, and skew.
struct Node3D : public Node {
	/// @brief Construct a Node3D object from an existing in-scope Node object.
	/// @param addr The address of the Node3D object.
	constexpr Node3D(uint64_t addr) : Node(addr) {}
	Node3D(Object obj) : Node(obj) {}
	Node3D(Node node) : Node(node) {}

	/// @brief Construct a Node3D object from a path.
	/// @param path The path to the Node3D object.
	Node3D(std::string_view path) : Node(path) {}

	/// @brief Get the position of the node.
	/// @return The position of the node.
	Vector3 get_position() const;
	/// @brief Set the position of the node.
	/// @param value The new position of the node.
	void set_position(const Variant &value);

	/// @brief Get the rotation of the node.
	/// @return The rotation of the node.
	Vector3 get_rotation() const;
	/// @brief Set the rotation of the node.
	/// @param value The new rotation of the node.
	void set_rotation(const Variant &value);

	/// @brief Get the scale of the node.
	/// @return The scale of the node.
	Vector3 get_scale() const;
	/// @brief Set the scale of the node.
	/// @param value The new scale of the node.
	void set_scale(const Variant &value);

	/// @brief Set the 3D transform of the node.
	/// @param value The new 3D transform of the node.
	void set_transform(const Transform3D &value);

	/// @brief Get the 3D transform of the node.
	/// @return The 3D transform of the node.
	Transform3D get_transform() const;

	/// @brief Access to the node rotation as a Quaternion. This property is ideal for tweening complex rotations.
	/// @param value The new quaternion of the node.
	void set_quaternion(const Quaternion &value);

	/// @brief Get the rotation of the node as a Quaternion.
	/// @return The rotation of the node as a Quaternion.
	Quaternion get_quaternion() const;

	/// @brief  Duplicate the node.
	/// @return A new Node3D object with the same properties and children.
	Node3D duplicate(int flags = 15) const;

	/// @brief Create a new Node3D node.
	/// @param path The path to the Node3D node.
	/// @return The Node3D node.
	static Node3D Create(std::string_view path);
};

inline Node3D Variant::as_node3d() const {
	if (get_type() == Variant::OBJECT)
		return Node3D{uintptr_t(v.i)};
	else if (get_type() == Variant::NODE_PATH)
		return Node3D{this->internal_fetch_string()};

	api_throw("std::bad_cast", "Variant is not a Node3D or NodePath", this);
}

inline Node3D Object::as_node3d() const {
	return Node3D{address()};
}

inline Variant::Variant(const Node3D &node) {
	m_type = OBJECT;
	v.i = node.address();
}

```

`program/cpp/docker/api/object.cpp`:

```cpp
#include "object.hpp"

#include "syscalls.h"
#include "variant.hpp"
#include <stdexcept>

MAKE_SYSCALL(ECALL_GET_OBJ, uint64_t, sys_get_obj, const char *, size_t);
MAKE_SYSCALL(ECALL_OBJ, void, sys_obj, Object_Op, uint64_t, Variant *);
MAKE_SYSCALL(ECALL_OBJ_CALLP, void, sys_obj_callp, uint64_t, const char *, size_t, bool, Variant *, const Variant *, unsigned);
MAKE_SYSCALL(ECALL_OBJ_PROP_GET, void, sys_obj_property_get, uint64_t, const char *, size_t, Variant *);
MAKE_SYSCALL(ECALL_OBJ_PROP_SET, void, sys_obj_property_set, uint64_t, const char *, size_t, const Variant *);

static_assert(sizeof(std::vector<std::string>) == 24, "std::vector<std::string> is not 24 bytes");

Object::Object(const std::string &name) :
		m_address{ sys_get_obj(name.c_str(), name.size()) } {
}

std::vector<std::string> Object::get_method_list() const {
	if constexpr (sizeof(std::string) == 32) {
		std::vector<std::string> methods;
		sys_obj(Object_Op::GET_METHOD_LIST, address(), (Variant *)&methods);
		return methods;
	} else {
		throw std::runtime_error("Fast-path std::string is not supported on this platform");
	}
}

Variant Object::get(std::string_view name) const {
	Variant var;
#if 0
	sys_obj_property_get(address(), name.data(), name.size(), &var);
#else
	register uint64_t object asm("a0") = address();
	register const char *property asm("a1") = name.data();
	register size_t property_size asm("a2") = name.size();
	register Variant *var_ptr asm("a3") = &var;
	register int syscall_number asm("a7") = ECALL_OBJ_PROP_GET;

	asm volatile(
		"ecall"
		: "=m"(*var_ptr)
		: "r"(object), "r"(property), "m"(*property), "r"(property_size), "r"(var_ptr), "r"(syscall_number)
	);
#endif
	return var;
}

void Object::set(std::string_view name, const Variant &value) {
#if 0
	sys_obj_property_set(address(), name.data(), name.size(), &value);
#else
	register uint64_t object asm("a0") = address();
	register const char *property asm("a1") = name.data();
	register size_t property_size asm("a2") = name.size();
	register const Variant *value_ptr asm("a3") = &value;
	register int syscall_number asm("a7") = ECALL_OBJ_PROP_SET;

	asm volatile(
		"ecall"
		:
		: "r"(object), "r"(property), "m"(*property), "r"(property_size), "r"(value_ptr), "m"(*value_ptr), "r"(syscall_number)
	);
#endif
}

std::vector<std::string> Object::get_property_list() const {
	if constexpr (sizeof(std::string) == 32) {
		std::vector<std::string> properties;
		sys_obj(Object_Op::GET_PROPERTY_LIST, address(), (Variant *)&properties);
		return properties;
	} else {
		throw std::runtime_error("Fast-path std::string is not supported on this platform");
	}
}

void Object::connect(Object target, const std::string &signal, std::string_view method) {
	Variant vars[3];
	vars[0] = target.address();
	vars[1] = signal;
	vars[2] = std::string(method);
	sys_obj(Object_Op::CONNECT, address(), vars);
}

void Object::disconnect(Object target, const std::string &signal, std::string_view method) {
	Variant vars[3];
	vars[0] = target.address();
	vars[1] = signal;
	vars[2] = std::string(method);
	sys_obj(Object_Op::DISCONNECT, address(), vars);
}

std::vector<std::string> Object::get_signal_list() const {
	if constexpr (sizeof(std::string) == 32) {
		std::vector<std::string> signals;
		sys_obj(Object_Op::GET_SIGNAL_LIST, address(), (Variant *)&signals);
		return signals;
	} else {
		throw std::runtime_error("Fast-path std::string is not supported on this platform");
	}
}

```

`program/cpp/docker/api/object.hpp`:

```hpp
#pragma once
#include "callable.hpp"
#include "string.hpp"
#include "syscalls_fwd.hpp"

struct Object {
	/// @brief Construct an Object object from an allowed global object.
	explicit Object(const std::string &name);

	/// @brief Construct an Object object from an existing in-scope Object object.
	/// @param addr The address of the Object object.
	constexpr Object(uint64_t addr) : m_address{addr} {}

	/// Call a method on the node.
	/// @param method The method to call.
	/// @param deferred If true, the method will be called next frame.
	/// @param args The arguments to pass to the method.
	/// @return The return value of the method.
	Variant callv(std::string_view method, bool deferred, const Variant *argv, unsigned argc);

	/// Call a method on the node without returning a value.
	/// @param method The method to call.
	/// @param deferred If true, the method will be called next frame.
	/// @param args The arguments to pass to the method.
	void voidcallv(std::string_view method, bool deferred, const Variant *argv, unsigned argc);

	template <typename... Args>
	Variant call(std::string_view method, Args... args);

	template <typename... Args>
	Variant call(std::string_view method, Args... args) const;

	template <typename... Args>
	void voidcall(std::string_view method, Args... args);

	template <typename... Args>
	Variant operator () (std::string_view method, Args... args);

	template <typename... Args>
	void call_deferred(std::string_view method, Args... args);

	/// @brief Get a list of methods available on the object.
	/// @return A list of method names.
	std::vector<std::string> get_method_list() const;

	/// @brief Get a property of the object.
	/// @param name The name of the property.
	/// @return The value of the property.
	Variant get(std::string_view name) const;

	/// @brief Set a property of the object.
	/// @param name The name of the property.
	/// @param value The value to set the property to.
	void set(std::string_view name, const Variant &value);

	/// @brief Assign a value to a property of the object, at the end of the frame.
	/// @param property The name of the property.
	/// @param value The value to set the property to.
	void set_deferred(const String &property, const Variant &value) {
		voidcall("set_deferred", property, value);
	}

	// Get a list of properties available on the object.
	// @return A list of property names.
	std::vector<std::string> get_property_list() const;

	// Connect a signal to a method on another object.
	// @param signal The signal to connect.
	// @param target The object to connect to.
	// @param method The method to call when the signal is emitted.
	void connect(Object target, const std::string &signal, std::string_view method);
	void connect(const std::string &signal, std::string_view method);
	void connect(const std::string &signal, Callable method);

	// Disconnect a signal from a method on another object.
	// @param signal The signal to disconnect.
	// @param target The object to disconnect from.
	// @param method The method to disconnect.
	void disconnect(Object target, const std::string &signal, std::string_view method);
	void disconnect(const std::string &signal, std::string_view method);

	// Get a list of signals available on the object.
	// @return A list of signal names.
	std::vector<std::string> get_signal_list() const;

	// Various casts.
	Node as_node() const;
	Node2D as_node2d() const;
	Node3D as_node3d() const;

	bool operator== (const Object &other) const {
		return address() == other.address();
	}
	bool operator!= (const Object &other) const {
		return address() != other.address();
	}
	bool operator< (const Object &other) const {
		return address() < other.address();
	}

	// Other member functions
	String get_class() const {
		return this->call("get_class");
	}
	bool is_class(const String &name) const {
		return this->call("is_class", name);
	}
	String to_string() const {
		return this->call("to_string");
	}

	METHOD(Variant, _get);
	METHOD(Variant, _get_property_list);
	METHOD(void, _init);
	METHOD(void, _notification);
	METHOD(bool, _property_can_revert);
	METHOD(Variant, _property_get_revert);
	METHOD(bool, _set);
	METHOD(String, _to_string);
	METHOD(void, _validate_property);
	METHOD(void, add_user_signal);
	METHOD(bool, can_translate_messages);
	METHOD(void, cancel_free);
	METHOD(Variant, emit_signal);
	METHOD(void, free);
	METHOD(Variant, get_incoming_connections);
	METHOD(Variant, get_indexed);
	METHOD(int, get_instance_id);
	METHOD(Variant, get_meta);
	METHOD(Variant, get_meta_list);
	METHOD(int, get_method_argument_count);
	METHOD(Variant, get_script);
	METHOD(Variant, get_signal_connection_list);
	METHOD(bool, has_meta);
	METHOD(bool, has_method);
	METHOD(bool, has_signal);
	METHOD(bool, has_user_signal);
	METHOD(bool, is_blocking_signals);
	METHOD(bool, is_connected);
	METHOD(bool, is_queued_for_deletion);
	METHOD(void, notification);
	METHOD(void, notify_property_list_changed);
	METHOD(bool, property_can_revert);
	METHOD(Variant, property_get_revert);
	METHOD(void, remove_meta);
	METHOD(void, remove_user_signal);
	METHOD(void, set_block_signals);
	METHOD(void, set_indexed);
	METHOD(void, set_message_translation);
	METHOD(void, set_meta);
	METHOD(void, set_script);
	METHOD(String, tr);
	METHOD(String, tr_n);

	// Get the object identifier.
	constexpr uint64_t address() const { return m_address; }

	// Check if the node is valid.
	constexpr bool is_valid() const { return m_address != 0; }

protected:
	uint64_t m_address;
};

inline Object Variant::as_object() const {
	if (get_type() == Variant::OBJECT)
		return Object{uintptr_t(v.i)};
	api_throw("std::bad_cast", "Variant is not an Object", this);
}

inline Variant::operator Object() const {
	return as_object();
}

template <typename T>
static inline T cast_to(const Object &obj) {
	return T{obj.address()};
}

inline Variant::Variant(const Object &obj) {
	m_type = OBJECT;
	v.i = obj.address();
}

template <typename... Args>
inline Variant Object::call(std::string_view method, Args... args) {
	Variant argv[] = {args...};
	return callv(method, false, argv, sizeof...(Args));
}

template <typename... Args>
inline Variant Object::call(std::string_view method, Args... args) const {
	Variant argv[] = {args...};
	return const_cast<Object *>(this)->callv(method, false, argv, sizeof...(Args));
}

template <typename... Args>
inline void Object::voidcall(std::string_view method, Args... args) {
	Variant argv[] = {args...};
	this->voidcallv(method, false, argv, sizeof...(Args));
}

template <typename... Args>
inline Variant Object::operator () (std::string_view method, Args... args) {
	return call(method, args...);
}

template <typename... Args>
inline void Object::call_deferred(std::string_view method, Args... args) {
	Variant argv[] = {args...};
	this->voidcallv(method, true, argv, sizeof...(Args));
}

inline void Object::connect(const std::string &signal, std::string_view method) {
	this->connect(*this, signal, method);
}
inline void Object::disconnect(const std::string &signal, std::string_view method) {
	this->disconnect(*this, signal, method);
}

// This is one of the most heavily used functions in the API, so it's worth optimizing.
inline Variant Object::callv(std::string_view method, bool deferred, const Variant *argv, unsigned argc) {
	static constexpr int ECALL_OBJ_CALLP = 506; // Call a method on an object
	Variant var;
	// We will attempt to call the method using inline assembly.
	register uint64_t object asm("a0") = address();
	register const char *method_ptr asm("a1") = method.begin();
	register size_t method_size asm("a2") = method.size();
	register bool deferred_flag asm("a3") = deferred;
	register Variant *var_ptr asm("a4") = &var;
	register const Variant *argv_ptr asm("a5") = argv;
	register unsigned argc_reg asm("a6") = argc;
	register int syscall_number asm("a7") = ECALL_OBJ_CALLP;

	asm volatile(
		"ecall"
		: "=m"(*var_ptr)
		: "r"(object), "r"(method_ptr), "r"(method_size), "r"(deferred_flag), "r"(var_ptr), "r"(argv_ptr), "m"(*argv_ptr), "r"(argc_reg), "r"(syscall_number)
	);
	return var;
}

// This variation of the function is used when the return value is not needed. We simply don't pass a pointer to the return value.
inline void Object::voidcallv(std::string_view method, bool deferred, const Variant *argv, unsigned argc) {
	static constexpr int ECALL_OBJ_CALLP = 506; // Call a method on an object
	// We will attempt to call the method using inline assembly.
	register uint64_t object asm("a0") = address();
	register const char *method_ptr asm("a1") = method.begin();
	register size_t method_size asm("a2") = method.size();
	register bool deferred_flag asm("a3") = deferred;
	register Variant *var_ptr asm("a4") = nullptr;
	register const Variant *argv_ptr asm("a5") = argv;
	register unsigned argc_reg asm("a6") = argc;
	register int syscall_number asm("a7") = ECALL_OBJ_CALLP;

	asm volatile(
		"ecall"
		: /* no outputs */
		: "r"(object), "r"(method_ptr), "r"(method_size), "r"(deferred_flag), "r"(var_ptr), "r"(argv_ptr), "m"(*argv_ptr), "r"(argc_reg), "r"(syscall_number)
	);
}

inline void Object::connect(const std::string &signal, Callable method) {
	this->call("connect", signal, method);
}

template <typename T, typename P = Variant>
struct PropertyProxy {
	const T &obj;
	const std::string_view property;

	constexpr PropertyProxy(const T &obj, std::string_view property)
			: obj(obj), property(property) {}

	PropertyProxy &operator=(const P &v) {
		const_cast<T&>(obj).set(property, v);
		return *this;
	}

	bool operator== (const P &v) const { return P(obj.get(property)) == v; }
	bool operator!=(const P &v) const { return P(obj.get(property)) != v; }

	operator P() {
		return obj.get(property);
	}
};

#define PROPERTY(name, Type)      \
	auto name() { return PropertyProxy<decltype(*this), Type>(*this, #name); } \
	auto name() const { return PropertyProxy<decltype(*this), Type>(*this, #name); }

#define CUSTOM_PROPERTY(name, Type, getter, setter)      \
	auto name() { return PropertyProxy(*this, #name); } \
	auto name() const { return PropertyProxy(*this, #name); } \
	void setter(const Type &v) { Object::set(#name, v); } \
	Type getter() const { return Object::get(#name); }

```

`program/cpp/docker/api/packed_array.cpp`:

```cpp
#include "variant.hpp"

#include "syscalls_fwd.hpp"

EXTERN_SYSCALL(void, sys_vcreate, Variant *, int, int, const void *);
EXTERN_SYSCALL(void, sys_vstore, unsigned *, Variant::Type, const void *, size_t);
EXTERN_SYSCALL(void, sys_vfetch, unsigned, void *, int);

template <>
PackedArray<uint8_t>::PackedArray(const std::vector<uint8_t> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_BYTE_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<uint8_t>::PackedArray(const uint8_t *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_BYTE_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<int32_t>::PackedArray(const std::vector<int32_t> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_INT32_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<int32_t>::PackedArray(const int32_t *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_INT32_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<int64_t>::PackedArray(const std::vector<int64_t> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_INT64_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<int64_t>::PackedArray(const int64_t *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_INT64_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<float>::PackedArray(const std::vector<float> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_FLOAT32_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<float>::PackedArray(const float *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_FLOAT32_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<double>::PackedArray(const std::vector<double> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_FLOAT64_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<double>::PackedArray(const double *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_FLOAT64_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Vector2>::PackedArray(const std::vector<Vector2> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_VECTOR2_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Vector2>::PackedArray(const Vector2 *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_VECTOR2_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Vector3>::PackedArray(const std::vector<Vector3> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_VECTOR3_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Vector3>::PackedArray(const Vector3 *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_VECTOR3_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Vector4>::PackedArray(const std::vector<Vector4> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_VECTOR4_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Vector4>::PackedArray(const Vector4 *data, size_t size) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_VECTOR4_ARRAY, size, data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<Color>::PackedArray(const std::vector<Color> &data) {
	Variant v;
	sys_vcreate(&v, Variant::PACKED_COLOR_ARRAY, -1, &data);
	this->m_idx = v.get_internal_index();
}
template <>
PackedArray<std::string>::PackedArray(const std::vector<std::string> &data) {
	Variant v;
	if constexpr (sizeof(std::string) == 32) {
		sys_vcreate(&v, Variant::PACKED_STRING_ARRAY, -1, &data);
	} else {
		// Work-around for libc++'s std::string implementation.
		struct Buffer {
			const char *ptr;
			size_t size;
		};
		std::vector<Buffer> buffers;
		buffers.reserve(data.size());
		for (const auto &str : data) {
			buffers.push_back({ str.data(), str.size() });
		}
		sys_vcreate(&v, Variant::PACKED_STRING_ARRAY, -2, &buffers);
	}
	this->m_idx = v.get_internal_index();
}

template <>
std::vector<uint8_t> PackedArray<uint8_t>::fetch() const {
	std::vector<uint8_t> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<int32_t> PackedArray<int32_t>::fetch() const {
	std::vector<int32_t> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<int64_t> PackedArray<int64_t>::fetch() const {
	std::vector<int64_t> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<float> PackedArray<float>::fetch() const {
	std::vector<float> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<double> PackedArray<double>::fetch() const {
	std::vector<double> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<Vector2> PackedArray<Vector2>::fetch() const {
	std::vector<Vector2> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<Vector3> PackedArray<Vector3>::fetch() const {
	std::vector<Vector3> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<Vector4> PackedArray<Vector4>::fetch() const {
	std::vector<Vector4> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<Color> PackedArray<Color>::fetch() const {
	std::vector<Color> result;
	sys_vfetch(m_idx, &result, 0);
	return result;
}
template <>
std::vector<std::string> PackedArray<std::string>::fetch() const {
	std::vector<std::string> result;
	if constexpr (sizeof(std::string) == 32) {
		sys_vfetch(m_idx, &result, 0);
	} else {
		// Work-around for libc++'s std::string implementation.
		struct Buffer {
			const char *ptr;
			size_t size;
		};
		std::vector<Buffer> buffers;
		sys_vfetch(m_idx, &buffers, 1);
		result.reserve(buffers.size());
		for (const auto &buffer : buffers) {
			result.emplace_back(buffer.ptr, buffer.size);
			delete[] buffer.ptr;
		}
	}
	return result;
}

template <>
void PackedArray<uint8_t>::store(const std::vector<uint8_t> &data) {
	sys_vstore(&m_idx, Variant::PACKED_BYTE_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<int32_t>::store(const std::vector<int32_t> &data) {
	sys_vstore(&m_idx, Variant::PACKED_INT32_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<int64_t>::store(const std::vector<int64_t> &data) {
	sys_vstore(&m_idx, Variant::PACKED_INT64_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<float>::store(const std::vector<float> &data) {
	sys_vstore(&m_idx, Variant::PACKED_FLOAT32_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<double>::store(const std::vector<double> &data) {
	sys_vstore(&m_idx, Variant::PACKED_FLOAT64_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<Vector2>::store(const std::vector<Vector2> &data) {
	sys_vstore(&m_idx, Variant::PACKED_VECTOR2_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<Vector3>::store(const std::vector<Vector3> &data) {
	sys_vstore(&m_idx, Variant::PACKED_VECTOR3_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<Vector4>::store(const std::vector<Vector4> &data) {
	sys_vstore(&m_idx, Variant::PACKED_VECTOR4_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<Color>::store(const std::vector<Color> &data) {
	sys_vstore(&m_idx, Variant::PACKED_COLOR_ARRAY, data.data(), data.size());
}
template <>
void PackedArray<std::string>::store(const std::vector<std::string> &data) {
	sys_vstore(&m_idx, Variant::PACKED_STRING_ARRAY, data.data(), data.size());
}

template <>
void PackedArray<uint8_t>::store(const uint8_t *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_BYTE_ARRAY, data, size);
}
template <>
void PackedArray<int32_t>::store(const int32_t *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_INT32_ARRAY, data, size);
}
template <>
void PackedArray<int64_t>::store(const int64_t *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_INT64_ARRAY, data, size);
}
template <>
void PackedArray<float>::store(const float *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_FLOAT32_ARRAY, data, size);
}
template <>
void PackedArray<double>::store(const double *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_FLOAT64_ARRAY, data, size);
}
template <>
void PackedArray<Vector2>::store(const Vector2 *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_VECTOR2_ARRAY, data, size);
}
template <>
void PackedArray<Vector3>::store(const Vector3 *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_VECTOR3_ARRAY, data, size);
}
template <>
void PackedArray<Vector4>::store(const Vector4 *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_VECTOR4_ARRAY, data, size);
}
template <>
void PackedArray<Color>::store(const Color *data, size_t size) {
	sys_vstore(&m_idx, Variant::PACKED_COLOR_ARRAY, data, size);
}
template <>
void PackedArray<std::string>::store(const std::string *data, size_t size) {
	if constexpr (sizeof(std::string) == 32) {
		sys_vstore(&m_idx, Variant::PACKED_STRING_ARRAY, data, size);
	} else {
		// Work-around for libc++'s std::string implementation.
		struct Buffer {
			const char *ptr;
			size_t size;
		};
		std::vector<Buffer> buffers;
		buffers.reserve(size);
		for (size_t i = 0; i < size; ++i) {
			buffers.push_back({ data[i].data(), data[i].size() });
		}
		sys_vstore(&m_idx, Variant::PACKED_STRING_ARRAY, buffers.data(), size | 0x80000000);
	}
}

```

`program/cpp/docker/api/packed_array.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <vector>
#include "color.hpp"
#include "vector.hpp"
struct Variant;

/**
 * @brief A reference to a host-side Packed Array.
 * Supported:
 * - PackedByteArray
 * - PackedInt32Array
 * - PackedInt64Array
 * - PackedFloat32Array
 * - PackedFloat64Array
 * - PackedVector2Array
 * - PackedVector3Array
 * - PackedVector4Array
 * - PackedColorArray
 * - PackedStringArray
 * 
 * @tparam T uint8_t, int32_t, int64_t, float, double, Vector2, Vector3, Vector4, Color or std::string.
 */
template <typename T>
struct PackedArray {
	constexpr PackedArray() {}

	/// @brief Create a PackedArray from a Variant.
	/// @param v The Variant.
	explicit PackedArray(const Variant& v);

	/// @brief Create a PackedArray from a vector of data.
	/// @param data The initial data.
	PackedArray(const std::vector<T> &data);

	/// @brief Create a PackedArray from an array of data.
	/// @param data The initial data.
	/// @param size The size of the data in elements.
	PackedArray(const T *data, size_t size);

	/// @brief Retrieve the size of the host-side array.
	/// @return size_t The size of the host-side array.
	size_t size() const { return const_cast<PackedArray*>(this)->operator ()("size"); }

	/// @brief Check if the host-side array is empty.
	/// @return bool True if the host-side array is empty, false otherwise.
	bool is_empty() const { return this->size() == 0; }

	/// @brief Retrieve the host-side array data.
	/// @return std::vector<T> The host-side array data.
	std::vector<T> fetch() const;

	/// @brief Store a vector of data into the host-side array.
	/// @param data The data to store.
	void store(const std::vector<T> &data);

	/// @brief Store an array of data into the host-side array.
	/// @param data The data to store.
	void store(const T *data, size_t size);

	/// @brief Call a method on the packed array.
	/// @tparam Args The method arguments.
	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args) const;

	/// @brief Create a PackedArray from a host-side Variant index.
	/// @param idx The host-side Variant index.
	/// @return PackedArray<T> The PackedArray.
	static PackedArray<T> from_index(unsigned idx) { PackedArray<T> pa{}; pa.m_idx = idx; return pa; }
	unsigned get_variant_index() const noexcept { return m_idx; }

private:
	unsigned m_idx = INT32_MIN; // Host-side Variant index.

	static_assert(std::is_same_v<T, uint8_t> || std::is_same_v<T, int32_t> || std::is_same_v<T, int64_t> || std::is_same_v<T, float> || std::is_same_v<T, double>
		|| std::is_same_v<T, Vector2> || std::is_same_v<T, Vector3> || std::is_same_v<T, Vector4> || std::is_same_v<T, Color> || std::is_same_v<T, std::string>,
		"PackedArray type must be uint8_t, int32_t, int64_t, float, double, Vector2, Vector3 or Color.");
};

// Aliases for common PackedArray types.
using PackedInt32Array = PackedArray<int32_t>;
using PackedInt64Array = PackedArray<int64_t>;
using PackedFloat32Array = PackedArray<float>;
using PackedFloat64Array = PackedArray<double>;
using PackedVector2Array = PackedArray<Vector2>;
using PackedVector3Array = PackedArray<Vector3>;
using PackedVector4Array = PackedArray<Vector4>;
using PackedColorArray = PackedArray<Color>;
using PackedStringArray = PackedArray<std::string>;

```

`program/cpp/docker/api/packed_byte_array.hpp`:

```hpp
#pragma once
#include "packed_array.hpp"
#include "string.hpp"

struct PackedByteArray final : public PackedArray<uint8_t> {
	using PackedArray::PackedArray;
	constexpr PackedByteArray(const PackedArray<uint8_t> &other) : PackedArray<uint8_t>(other) {}

	operator Variant() const {
		return *static_cast<const PackedArray<uint8_t>*>(this);
	}

	PackedByteArray decompress(int64_t buffer_size, int64_t compression_mode) const {
		return static_cast<const PackedArray<uint8_t> *>(this)->operator()("decompress", buffer_size, compression_mode).as_byte_array();
	}

	String get_string_from_ascii() const {
		return static_cast<const PackedArray<uint8_t> *>(this)->operator()("get_string_from_ascii");
	}
	String get_string_from_utf8() const {
		return static_cast<const PackedArray<uint8_t> *>(this)->operator()("get_string_from_utf8");
	}
	String get_string_from_utf16() const {
		return static_cast<const PackedArray<uint8_t> *>(this)->operator()("get_string_from_utf16");
	}
	String get_string_from_utf32() const {
		return static_cast<const PackedArray<uint8_t> *>(this)->operator()("get_string_from_utf32");
	}

	PackedFloat32Array to_float32_array() const {
		return static_cast<const PackedArray<uint8_t>*>(this)->operator ()("to_float32");
	}
	PackedFloat64Array to_float64_array() const {
		return static_cast<const PackedArray<uint8_t>*>(this)->operator ()("to_float64");
	}
	PackedInt32Array to_int32_array() const {
		return static_cast<const PackedArray<uint8_t>*>(this)->operator ()("to_int32");
	}
	PackedInt64Array to_int64_array() const {
		return static_cast<const PackedArray<uint8_t>*>(this)->operator ()("to_int64");
	}
};

```

`program/cpp/docker/api/plane.hpp`:

```hpp
#pragma once
#include "vector.hpp"

struct Plane {
	Vector3 normal = Vector3(0, 1, 0);
	real_t d = 0.0f;

	void set_normal(const Vector3 &p_normal) { normal = p_normal; }
	const Vector3 &get_normal() const { return normal; }

	Vector3 center() const { return normal * d; }
	Vector3 get_any_perpendicular_normal() const;

	bool is_point_over(const Vector3 &p_point) const { return normal.dot(p_point) > d; }
	real_t distance_to(const Vector3 &p_point) const { return normal.dot(p_point) - d; }
	bool has_point(const Vector3 &p_point, real_t p_tolerance = 0.00001f) const;

	Vector3 project(const Vector3 &p_point) const {
		return p_point - normal * distance_to(p_point);
	}

	bool operator==(const Plane &p_plane) const;
	bool operator!=(const Plane &p_plane) const;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	constexpr Plane() {}
	constexpr Plane(real_t p_a, real_t p_b, real_t p_c, real_t p_d) :
			normal(p_a, p_b, p_c),
			d(p_d) {}

	constexpr Plane(const Vector3 &p_normal, real_t p_d = 0.0);
	Plane(const Vector3 &p_normal, const Vector3 &p_point);
	Plane(const Vector3 &p_point1, const Vector3 &p_point2, const Vector3 &p_point3, ClockDirection p_dir = CLOCKWISE);
};

inline constexpr Plane::Plane(const Vector3 &p_normal, real_t p_d) :
		normal(p_normal),
		d(p_d) {
}

inline Plane::Plane(const Vector3 &p_normal, const Vector3 &p_point) :
		normal(p_normal),
		d(p_normal.dot(p_point)) {
}

inline Plane::Plane(const Vector3 &p_point1, const Vector3 &p_point2, const Vector3 &p_point3, ClockDirection p_dir) {
	if (p_dir == CLOCKWISE) {
		normal = (p_point1 - p_point3).cross(p_point1 - p_point2);
	} else {
		normal = (p_point1 - p_point2).cross(p_point1 - p_point3);
	}

	normal.normalize();
	d = normal.dot(p_point1);
}

inline bool Plane::has_point(const Vector3 &p_point, real_t p_tolerance) const {
	real_t dist = normal.dot(p_point) - d;
	dist = fabs(dist);
	return dist <= p_tolerance;
}

inline Vector3 Plane::get_any_perpendicular_normal() const {
	Vector3 n = normal;
	n.normalize();
	Vector3 tangent = n.cross(Vector3(1, 0, 0));
	if (tangent.length_squared() < 0.00001f) {
		tangent = n.cross(Vector3(0, 1, 0));
	}
	tangent.normalize();
	return n.cross(tangent);
}

inline bool Plane::operator==(const Plane &p_plane) const {
	return normal == p_plane.normal && d == p_plane.d;
}

inline bool Plane::operator!=(const Plane &p_plane) const {
	return normal != p_plane.normal || d != p_plane.d;
}

```

`program/cpp/docker/api/quaternion.cpp`:

```cpp
#include "quaternion.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_QUAT_OPS, void, sys_quat_ops, unsigned idx, Quaternion_Op, ...);

Quaternion Quaternion::identity() {
	// CREATE uses idx for the constructor type
	Quaternion q;
	sys_quat_ops(0, Quaternion_Op::CREATE, &q);
	return q;
}

Quaternion::Quaternion(double p_x, double p_y, double p_z, double p_w) {
	sys_quat_ops(1, Quaternion_Op::CREATE, Vector3(p_x, p_y, p_z), p_w);
}

Quaternion::Quaternion(const Vector3 &axis, double angle) {
	sys_quat_ops(2, Quaternion_Op::CREATE, axis, angle);
}

Quaternion::Quaternion(const Vector3 &euler) {
	sys_quat_ops(3, Quaternion_Op::CREATE, euler);
}

void Quaternion::assign(const Quaternion &quat) {
	// ASSIGN uses idx for the source quaternion, and target quaternion is this
	sys_quat_ops(this->m_idx, Quaternion_Op::ASSIGN, this, quat.get_variant_index());
}

double Quaternion::dot(const Quaternion &q) const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::DOT, q.get_variant_index(), &d);
	return d;
}

double Quaternion::length_squared() const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::LENGTH_SQUARED, &d);
	return d;
}

double Quaternion::length() const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::LENGTH, &d);
	return d;
}

void Quaternion::normalize() {
	sys_quat_ops(this->m_idx, Quaternion_Op::NORMALIZE, this);
}

Quaternion Quaternion::normalized() const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::NORMALIZE, &q);
	return q;
}

bool Quaternion::is_normalized() const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::LENGTH_SQUARED, &d);
	return d > 0.999999f && d < 1.000001f;
}

Quaternion Quaternion::inverse() const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::INVERSE, &q);
	return q;
}

Quaternion Quaternion::log() const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::LOG, &q);
	return q;
}

Quaternion Quaternion::exp() const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::EXP, &q);
	return q;
}

double Quaternion::angle_to(const Quaternion &to) const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::ANGLE_TO, to.get_variant_index(), &d);
	return d;
}

Quaternion Quaternion::slerp(const Quaternion &to, double t) const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::SLERP, to.get_variant_index(), t, &q);
	return q;
}

Quaternion Quaternion::slerpni(const Quaternion &to, double t) const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::SLERPNI, to.get_variant_index(), t, &q);
	return q;
}

Quaternion Quaternion::cubic_interpolate(const Quaternion &b, const Quaternion &pre_a, const Quaternion &post_b, double t) const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::CUBIC_INTERPOLATE, b.get_variant_index(), pre_a.get_variant_index(), post_b.get_variant_index(), t, &q);
	return q;
}

Quaternion Quaternion::cubic_interpolate_in_time(const Quaternion &b, const Quaternion &pre_a, const Quaternion &post_b, double t, double b_t, double pre_a_t, double post_b_t) const {
	Quaternion q;
	sys_quat_ops(this->m_idx, Quaternion_Op::CUBIC_INTERPOLATE_IN_TIME, b.get_variant_index(), pre_a.get_variant_index(), post_b.get_variant_index(), t, b_t, pre_a_t, post_b_t, &q);
	return q;
}

Vector3 Quaternion::get_axis() const {
	Vector3 v;
	sys_quat_ops(this->m_idx, Quaternion_Op::GET_AXIS, &v);
	return v;
}

double Quaternion::get_angle() const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::GET_ANGLE, &d);
	return d;
}

void Quaternion::operator*=(const Quaternion &q) {
	sys_quat_ops(this->m_idx, Quaternion_Op::MUL, this, q.get_variant_index());
}

Quaternion Quaternion::operator*(const Quaternion &q) const {
	Quaternion r;
	sys_quat_ops(this->m_idx, Quaternion_Op::MUL, &r, q.get_variant_index());
	return r;
}

double Quaternion::operator[](int idx) const {
	double d;
	sys_quat_ops(this->m_idx, Quaternion_Op::AT, idx, &d);
	return d;
}

```

`program/cpp/docker/api/quaternion.hpp`:

```hpp
#pragma once

#include "variant.hpp"

/**
 * @brief Quaternion wrapper for godot-cpp Quaternion.
 * Implemented by referencing and mutating a host-side Basis Variant.
**/
struct Quaternion {
	constexpr Quaternion() {} // DON'T TOUCH

	static Quaternion identity();
	Quaternion(double p_x, double p_y, double p_z, double p_w);
	Quaternion(const Vector3 &axis, double angle);
	Quaternion(const Vector3 &euler);

	Quaternion &operator =(const Quaternion &quat);
	void assign(const Quaternion &quat);

	// Quaternion operations
	double dot(const Quaternion &q) const;
	double length_squared() const;
	double length() const;
	void normalize();
	Quaternion normalized() const;
	bool is_normalized() const;
	Quaternion inverse() const;
	Quaternion log() const;
	Quaternion exp() const;
	double angle_to(const Quaternion &to) const;

	Quaternion slerp(const Quaternion &to, double t) const;
	Quaternion slerpni(const Quaternion &to, double t) const;
	Quaternion cubic_interpolate(const Quaternion &b, const Quaternion &pre_a, const Quaternion &post_b, double t) const;
	Quaternion cubic_interpolate_in_time(const Quaternion &b, const Quaternion &pre_a, const Quaternion &post_b, double t, double b_t, double pre_a_t, double post_b_t) const;

	Vector3 get_axis() const;
	double get_angle() const;

	void operator*=(const Quaternion &q);
	Quaternion operator*(const Quaternion &q) const;

	// Quaternion access
	static constexpr int size() { return 4; }
	double operator[](int idx) const;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Quaternion, from_euler);
	METHOD(Vector3,    get_euler);
	METHOD(bool,       is_equal_approx);
	METHOD(bool,       is_finite);
	METHOD(Quaternion, spherical_cubic_interpolate);
	METHOD(Quaternion, spherical_cubic_interpolate_in_time);

	static Quaternion from_variant_index(unsigned idx) { Quaternion a {}; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }
private:
	unsigned m_idx = INT32_MIN;
};

inline Variant::Variant(const Quaternion &q) {
	m_type = Variant::QUATERNION;
	v.i = q.get_variant_index();
}

inline Variant::operator Quaternion() const {
	if (m_type != Variant::QUATERNION) {
		api_throw("std::bad_cast", "Failed to cast Variant to Quaternion", this);
	}
	return Quaternion::from_variant_index(v.i);
}

inline Quaternion Variant::as_quaternion() const {
	return static_cast<Quaternion>(*this);
}

inline Quaternion &Quaternion::operator =(const Quaternion &q) {
	if (this->m_idx != INT32_MIN) {
		this->assign(q);
	} else {
		this->m_idx = q.m_idx;
	}
	return *this;
}

template <typename... Args>
inline Variant Quaternion::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/rect2.hpp`:

```hpp
#pragma once
#include "vector2.hpp"

struct Rect2 {
	Vector2 position;
	Vector2 size;

	const Vector2& get_position() const { return position; }
	void set_position(const Vector2& p_pos) { position = p_pos; }
	const Vector2& get_size() const { return size; }
	void set_size(const Vector2& p_size) { size = p_size; }
	Vector2 get_end() const { return position + size; }
	void set_end(const Vector2& p_end) { size = p_end - position; }

	real_t get_area() const { return size.x * size.y; }
	Vector2 get_center() const { return position + size * real_t(0.5); }

	bool has_area() const { return size.x > 0 && size.y > 0; }

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Rect2, abs);
	METHOD(bool,  encloses);
	METHOD(Rect2, expand);
	METHOD(Rect2, grow);
	METHOD(Rect2, grow_individual);
	METHOD(Rect2, grow_side);
	METHOD(bool,  has_point);
	METHOD(Rect2, intersection);
	METHOD(bool,  intersects);
	METHOD(bool,  is_equal_approx);
	METHOD(bool,  is_finite);
	METHOD(Rect2, merge);

	bool operator == (const Rect2& other) const {
		return __builtin_memcmp(this, &other, sizeof(Rect2)) == 0;
	}
	bool operator != (const Rect2& other) const {
		return !this->operator==(other);
	}

	constexpr Rect2() : position(), size() {}
	constexpr Rect2(Vector2 position, Vector2 size) : position(position), size(size) {}
	constexpr Rect2(real_t x, real_t y, real_t width, real_t height) : position(x, y), size(width, height) {}
};

inline constexpr auto operator + (const Rect2& a, const Vector2& b) noexcept {
	return Rect2{a.position + b, a.size};
}
inline constexpr auto operator - (const Rect2& a, const Vector2& b) noexcept {
	return Rect2{a.position - b, a.size};
}
inline constexpr auto operator * (const Rect2& a, const Vector2& b) noexcept {
	return Rect2{a.position * b, a.size * b};
}
inline constexpr auto operator / (const Rect2& a, const Vector2& b) noexcept {
	return Rect2{a.position / b, a.size / b};
}

inline constexpr auto operator + (const Rect2& a, real_t b) noexcept {
	return Rect2{a.position + b, a.size};
}
inline constexpr auto operator - (const Rect2& a, real_t b) noexcept {
	return Rect2{a.position - b, a.size};
}
inline constexpr auto operator * (const Rect2& a, real_t b) noexcept {
	return Rect2{a.position * b, a.size * b};
}
inline constexpr auto operator / (const Rect2& a, real_t b) noexcept {
	return Rect2{a.position / b, a.size / b};
}

```

`program/cpp/docker/api/rect2i.hpp`:

```hpp
#pragma once
#include "vector2i.hpp"

struct Rect2i {
	Vector2i position;
	Vector2i size;

	const Vector2i &get_position() const { return position; }
	void set_position(Vector2i p_position) { position = p_position; }
	const Vector2i &get_size() const { return size; }
	void set_size(Vector2i p_size) { size = p_size; }
	Vector2i get_end() const { return position + size; }
	void set_end(Vector2i p_end) { size = p_end - position; }

	int get_area() const { return size.x * size.y; }
	bool has_area() const { return size.x > 0 && size.y > 0; }
	Vector2i get_center() const { return position + size / 2; }

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Rect2i, abs);
	METHOD(bool,   encloses);
	METHOD(Rect2i, expand);
	METHOD(Rect2i, grow);
	METHOD(Rect2i, grow_individual);
	METHOD(Rect2i, grow_side);
	METHOD(bool,   has_point);
	METHOD(Rect2i, intersection);
	METHOD(bool,   intersects);
	METHOD(bool,   merge);

	bool operator == (const Rect2i& other) const {
		return __builtin_memcmp(this, &other, sizeof(Rect2i)) == 0;
	}
	bool operator != (const Rect2i& other) const {
		return !this->operator==(other);
	}

	constexpr Rect2i() : position(), size() {}
	constexpr Rect2i(Vector2i position, Vector2i size) : position(position), size(size) {}
	constexpr Rect2i(int x, int y, int width, int height) : position(x, y), size(width, height) {}
};

inline constexpr auto operator + (const Rect2i& a, const Vector2i& b) noexcept {
	return Rect2i{a.position + b, a.size};
}
inline constexpr auto operator - (const Rect2i& a, const Vector2i& b) noexcept {
	return Rect2i{a.position - b, a.size};
}
inline constexpr auto operator * (const Rect2i& a, const Vector2i& b) noexcept {
	return Rect2i{a.position * b, a.size * b};
}
inline constexpr auto operator / (const Rect2i& a, const Vector2i& b) noexcept {
	return Rect2i{a.position / b, a.size / b};
}

inline constexpr auto operator + (const Rect2i& a, int b) noexcept {
	return Rect2i{a.position + b, a.size};
}
inline constexpr auto operator - (const Rect2i& a, int b) noexcept {
	return Rect2i{a.position - b, a.size};
}
inline constexpr auto operator * (const Rect2i& a, int b) noexcept {
	return Rect2i{a.position * b, a.size * b};
}
inline constexpr auto operator / (const Rect2i& a, int b) noexcept {
	return Rect2i{a.position / b, a.size / b};
}

```

`program/cpp/docker/api/rid.hpp`:

```hpp
#pragma once
#include <cstdint>
#include "variant.hpp"
struct Variant;

struct RID {
	int64_t index;

	constexpr RID() : index(0) {}
	constexpr RID(int64_t p_index) : index(p_index) {}
	RID(const Variant &v);
};

inline Variant::Variant(const ::RID& rid) {
	m_type = RID;
	v.i = rid.index;
}

inline Variant::operator ::RID() const {
	return ::RID{v.i};
}

```

`program/cpp/docker/api/string.cpp`:

```cpp
#include "string.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_STRING_CREATE, unsigned, sys_string_create, const char *, size_t);
MAKE_SYSCALL(ECALL_STRING_OPS, int, sys_string_ops, String_Op, unsigned, int, ...);
MAKE_SYSCALL(ECALL_STRING_AT, unsigned, sys_string_at, unsigned, int);
MAKE_SYSCALL(ECALL_STRING_SIZE, int, sys_string_size, unsigned);
MAKE_SYSCALL(ECALL_STRING_APPEND, void, sys_string_append, unsigned, const char *, size_t);
EXTERN_SYSCALL(unsigned, sys_vassign, unsigned, unsigned);

String &String::operator=(const String &value) {
	this->m_idx = sys_vassign(m_idx, value.m_idx);
	return *this;
}

void String::append(const String &value) {
	(void)sys_string_ops(String_Op::APPEND, m_idx, 0, &value);
}

void String::insert(int idx, const String &value) {
	(void)sys_string_ops(String_Op::INSERT, m_idx, 0, &value);
}

void String::append(std::string_view value) {
	(void)sys_string_append(m_idx, value.data(), value.size());
}

void String::erase(int idx, int count) {
	sys_string_ops(String_Op::ERASE, m_idx, idx, count);
}

int String::find(const String &value) const {
	return sys_string_ops(String_Op::FIND, m_idx, 0, &value);
}

String String::operator[](int idx) const {
	unsigned new_stridx = sys_string_at(m_idx, idx);
	return String::from_variant_index(new_stridx);
}

int String::size() const {
	return sys_string_size(m_idx);
}

unsigned String::Create(const char *data, size_t size) {
	return sys_string_create(data, size);
}

std::string String::utf8() const {
	std::string str;
	if constexpr (sizeof(std::string) == 32) {
		sys_string_ops(String_Op::TO_STD_STRING, m_idx, 0, &str);
	} else {
		// Guesstimate that the string is less than 32 bytes.
		str.resize_and_overwrite(32, [idx = m_idx](char *data, size_t size) -> std::size_t {
			struct Buffer {
				char *data;
				size_t size;
			} buffer;
			buffer.data = data;
			buffer.size = size;
			// This syscall will either copy to the existing buffer or allocate a new one,
			// and then update the buffer struct with the new data, freeing the old buffer.
			sys_string_ops(String_Op::TO_STD_STRING, idx, 1, &buffer);
			return buffer.size;
		});
	}
	return str;
}

std::u32string String::utf32() const {
	std::u32string str;
	sys_string_ops(String_Op::TO_STD_STRING, m_idx, 2, &str);
	return str;
}

bool String::operator==(const String &other) const {
	return sys_string_ops(String_Op::COMPARE, m_idx, 0, &other);
}

bool String::operator==(const char *other) const {
	return sys_string_ops(String_Op::COMPARE_CSTR, m_idx, 0, other);
}

```

`program/cpp/docker/api/string.hpp`:

```hpp
#pragma once

#include "variant.hpp"
#include <string>

/**
 * @brief String wrapper for Godot String.
 * Implemented by referencing and mutating a host-side String Variant.
 */
union String {
	constexpr String() {} // DON'T TOUCH
	String(std::string_view value);
	template <size_t N>
	String(const char (&value)[N]);
	String(const std::string &value);

	String &operator =(std::string_view value);
	String &operator =(const String &value);

	// String operations
	void append(const String &value);
	void append(std::string_view value);
	void erase(int idx, int count = 1);
	void insert(int idx, const String &value);
	int find(const String &value) const;
	bool contains(std::string_view value) const { return find(value) != -1; }
	bool empty() const { return size() == 0; }

	// Call methods on the String
	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	String &operator +=(const String &value) { append(value); return *this; }
	String &operator +=(std::string_view value) { append(value); return *this; }

	// String access
	String operator[](int idx) const;
	String at(int idx) const { return (*this)[idx]; }

	operator std::string() const { return utf8(); }
	operator std::u32string() const { return utf32(); }
	std::string utf8() const;
	std::u32string utf32() const;

	bool operator ==(const String &other) const;
	bool operator ==(const char *other) const;

	// String size
	int size() const;
	bool is_empty() const { return size() == 0; }

	METHOD(bool, begins_with);
	METHOD(PackedArray<std::string>, bigrams);
	METHOD(int64_t, bin_to_int);
	METHOD(String, c_escape);
	METHOD(String, c_unescape);
	METHOD(String, capitalize);
	METHOD(int64_t, casecmp_to);
	METHOD(String, chr);
	METHOD(bool, containsn);
	METHOD(int64_t, count);
	METHOD(int64_t, countn);
	METHOD(String, dedent);
	METHOD(bool, ends_with);
	METHOD(int64_t, filecasecmp_to);
	METHOD(int64_t, filenocasecmp_to);
	METHOD(int64_t, findn);
	METHOD(String, format);
	METHOD(String, get_base_dir);
	METHOD(String, get_basename);
	METHOD(String, get_extension);
	METHOD(String, get_file);
	METHOD(String, get_slice);
	METHOD(String, get_slice_count);
	METHOD(String, get_slicec);
	METHOD(int64_t, hash);
	METHOD(PackedArray<uint8_t>, hex_decode);
	METHOD(int64_t, hex_to_int);
	METHOD(String, humanize_size);
	METHOD(String, indent);
	METHOD(bool, is_absolute_path);
	METHOD(bool, is_relative_path);
	METHOD(bool, is_subsequence_of);
	METHOD(bool, is_subsequence_ofn);
	METHOD(bool, is_valid_filename);
	METHOD(bool, is_valid_float);
	METHOD(bool, is_valid_hex_number);
	METHOD(bool, is_valid_html_color);
	METHOD(bool, is_valid_identifier);
	METHOD(bool, is_valid_int);
	METHOD(bool, is_valid_ip_address);
	METHOD(String, join);
	METHOD(String, json_escape);
	METHOD(String, left);
	METHOD(int64_t, length);
	METHOD(String, lpad);
	METHOD(String, lstrip);
	METHOD(bool, match);
	METHOD(bool, matchn);
	METHOD(PackedArray<uint8_t>, md5_buffer);
	METHOD(String, md5_text);
	METHOD(int64_t, naturalcasecmp_to);
	METHOD(int64_t, naturalnocasecmp_to);
	METHOD(int64_t, nocasecmp_to);
	METHOD(String, num);
	METHOD(String, num_int64);
	METHOD(String, num_scientific);
	METHOD(String, num_uint64);
	METHOD(String, pad_decimals);
	METHOD(String, pad_zeros);
	METHOD(String, path_join);
	METHOD(String, repeat);
	METHOD(String, replace);
	METHOD(String, replacen);
	METHOD(String, reverse);
	METHOD(int64_t, rfind);
	METHOD(int64_t, rfindn);
	METHOD(String, right);
	METHOD(String, rpad);
	METHOD(PackedArray<std::string>, rsplit);
	METHOD(String, rstrip);
	METHOD(PackedArray<uint8_t>, sha1_buffer);
	METHOD(String, sha1_text);
	METHOD(PackedArray<uint8_t>, sha256_buffer);
	METHOD(String, sha256_text);
	METHOD(double, similarity);
	METHOD(String, simplify_path);
	METHOD(PackedArray<uint8_t>, split);
	METHOD(PackedArray<double>, split_floats);
	METHOD(String, strip_edges);
	METHOD(String, strip_escapes);
	METHOD(String, substr);
	METHOD(PackedArray<uint8_t>, to_ascii_buffer);
	METHOD(String, to_camel_case);
	METHOD(double, to_float);
	METHOD(int64_t, to_int);
	METHOD(String, to_lower);
	METHOD(String, to_pascal_case);
	METHOD(String, to_snake_case);
	METHOD(String, to_upper);
	METHOD(PackedArray<uint8_t>, to_utf8_buffer);
	METHOD(PackedArray<uint8_t>, to_utf16_buffer);
	METHOD(PackedArray<uint8_t>, to_utf32_buffer);
	METHOD(PackedArray<uint8_t>, to_wchar_buffer);
	METHOD(String, trim_prefix);
	METHOD(String, trim_suffix);
	METHOD(int64_t, unicode_at);
	METHOD(String, uri_decode);
	METHOD(String, uri_encode);
	METHOD(String, validate_filename);
	METHOD(String, validate_node_name);
	METHOD(String, xml_escape);
	METHOD(String, xml_unescape);

	static String from_variant_index(unsigned idx) { String a {}; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }
	bool is_permanent() const { return Variant::is_permanent_index(m_idx); }
	static unsigned Create(const char *data, size_t size);

private:
	unsigned m_idx = INT32_MIN;
};
using NodePath = String; // NodePath is compatible with String

inline Variant::Variant(const String &s) {
	m_type = Variant::STRING;
	v.i = s.get_variant_index();
}

inline Variant::operator String() const {
	return as_string();
}

inline String Variant::as_string() const {
	if (m_type != STRING && m_type != STRING_NAME && m_type != NODE_PATH) {
		api_throw("std::bad_cast", "Failed to cast Variant to String", this);
	}
	return String::from_variant_index(v.i);
}

inline String::String(std::string_view value)
	: m_idx(Create(value.data(), value.size())) {}
inline String &String::operator =(std::string_view value) {
	m_idx = Create(value.data(), value.size());
	return *this;
}
template <size_t N>
inline String::String(const char (&value)[N])
	: m_idx(Create(value, N - 1)) {}

inline String::String(const std::string &value)
	: m_idx(Create(value.data(), value.size())) {}

template <typename... Args>
inline Variant String::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/syscalls.h`:

```h
#pragma once
#define GAME_API_BASE 500

// System calls written in assembly
#define ECALL_PRINT (GAME_API_BASE + 0)
#define ECALL_VCALL (GAME_API_BASE + 1)
#define ECALL_VEVAL (GAME_API_BASE + 2)
#define ECALL_VASSIGN (GAME_API_BASE + 3)
#define ECALL_GET_OBJ (GAME_API_BASE + 4) // Get an object by name
#define ECALL_OBJ (GAME_API_BASE + 5) // All the Object functions
#define ECALL_OBJ_CALLP (GAME_API_BASE + 6) // Call a method on an object
#define ECALL_GET_NODE (GAME_API_BASE + 7) // Get a node by path
#define ECALL_NODE (GAME_API_BASE + 8) // All the Node functions
#define ECALL_NODE2D (GAME_API_BASE + 9) // All the Node2D functions
#define ECALL_NODE3D (GAME_API_BASE + 10) // All the Node3D functions

#define ECALL_THROW (GAME_API_BASE + 11)
#define ECALL_IS_EDITOR (GAME_API_BASE + 12)

#define ECALL_SINCOS (GAME_API_BASE + 13)
#define ECALL_VEC2_LENGTH (GAME_API_BASE + 14)
#define ECALL_VEC2_NORMALIZED (GAME_API_BASE + 15)
#define ECALL_VEC2_ROTATED (GAME_API_BASE + 16)

#define ECALL_VCREATE (GAME_API_BASE + 17)
#define ECALL_VCLONE (GAME_API_BASE + 18)
#define ECALL_VFETCH (GAME_API_BASE + 19)
#define ECALL_VSTORE (GAME_API_BASE + 20)

#define ECALL_ARRAY_OPS (GAME_API_BASE + 21)
#define ECALL_ARRAY_AT (GAME_API_BASE + 22)
#define ECALL_ARRAY_SIZE (GAME_API_BASE + 23)

#define ECALL_DICTIONARY_OPS (GAME_API_BASE + 24)

#define ECALL_STRING_CREATE (GAME_API_BASE + 25)
#define ECALL_STRING_OPS (GAME_API_BASE + 26)
#define ECALL_STRING_AT (GAME_API_BASE + 27)
#define ECALL_STRING_SIZE (GAME_API_BASE + 28)
#define ECALL_STRING_APPEND (GAME_API_BASE + 29)

#define ECALL_TIMER_PERIODIC (GAME_API_BASE + 30)
#define ECALL_TIMER_STOP (GAME_API_BASE + 31)

#define ECALL_NODE_CREATE (GAME_API_BASE + 32)

#define ECALL_MATH_OP32 (GAME_API_BASE + 33)
#define ECALL_MATH_OP64 (GAME_API_BASE + 34)
#define ECALL_LERP_OP32 (GAME_API_BASE + 35)
#define ECALL_LERP_OP64 (GAME_API_BASE + 36)

#define ECALL_VEC3_OPS (GAME_API_BASE + 37)

#define ECALL_CALLABLE_CREATE (GAME_API_BASE + 38)

#define ECALL_LOAD (GAME_API_BASE + 39)

#define ECALL_TRANSFORM_2D_OPS (GAME_API_BASE + 40)
#define ECALL_TRANSFORM_3D_OPS (GAME_API_BASE + 41)
#define ECALL_BASIS_OPS (GAME_API_BASE + 42)

#define ECALL_VEC2_OPS (GAME_API_BASE + 43)

#define ECALL_QUAT_OPS (GAME_API_BASE + 44)

#define ECALL_OBJ_PROP_GET (GAME_API_BASE + 45)
#define ECALL_OBJ_PROP_SET (GAME_API_BASE + 46)

#define ECALL_SANDBOX_ADD (GAME_API_BASE + 47)

#define ECALL_PACKED_ARRAY_OPS (GAME_API_BASE + 48)

#define ECALL_LAST (GAME_API_BASE + 49)

#define STRINGIFY_HELPER(x) #x
#define STRINGIFY(x) STRINGIFY_HELPER(x)

#define MAKE_SYSCALL(number, rval, name, ...)                      \
	__asm__(".pushsection .text\n"                                 \
			".global " #name "\n"                                  \
			".type " #name ", @function\n"                         \
			"" #name ":\n"                                         \
			"	li a7, " STRINGIFY(number) "\n"                    \
										   "   ecall\n"            \
										   "   ret\n"              \
										   ".popsection .text\n"); \
	extern "C" rval name(__VA_ARGS__);

#define EXTERN_SYSCALL(rval, name, ...) \
	extern "C" rval name(__VA_ARGS__);

enum class Object_Op {
	GET_METHOD_LIST,
	GET,
	SET,
	GET_PROPERTY_LIST,
	CONNECT,
	DISCONNECT,
	GET_SIGNAL_LIST,
};

enum class Node_Create_Shortlist {
	CREATE_CLASSDB = 0,
	CREATE_NODE,
	CREATE_NODE2D,
	CREATE_NODE3D,
};

enum class Node_Op {
	GET_NAME = 0,
	GET_PATH,
	GET_PARENT,
	QUEUE_FREE,
	DUPLICATE,
	GET_CHILD_COUNT,
	GET_CHILD,
	ADD_CHILD,
	ADD_CHILD_DEFERRED,
	ADD_SIBLING,
	ADD_SIBLING_DEFERRED,
	MOVE_CHILD,
	REMOVE_CHILD,
	REMOVE_CHILD_DEFERRED,
	GET_CHILDREN,
	SET_NAME,
	REPARENT,
	REPLACE_BY,
	ADD_TO_GROUP,
	REMOVE_FROM_GROUP,
	IS_IN_GROUP,
	IS_INSIDE_TREE,
};

enum class Node2D_Op {
	GET_POSITION = 0,
	SET_POSITION,
	GET_ROTATION,
	SET_ROTATION,
	GET_SCALE,
	SET_SCALE,
	GET_SKEW,
	SET_SKEW,
	GET_TRANSFORM,
	SET_TRANSFORM,
};

enum class Node3D_Op {
	GET_POSITION = 0,
	SET_POSITION,
	GET_ROTATION,
	SET_ROTATION,
	GET_SCALE,
	SET_SCALE,
	GET_TRANSFORM,
	SET_TRANSFORM,
	GET_QUATERNION,
	SET_QUATERNION,
};

enum class Array_Op {
	CREATE = 0,
	PUSH_BACK,
	PUSH_FRONT,
	POP_AT,
	POP_BACK,
	POP_FRONT,
	INSERT,
	ERASE,
	RESIZE,
	CLEAR,
	SORT,
	FETCH_TO_VECTOR,
	HAS,
};

enum class Dictionary_Op {
	GET = 0,
	SET,
	ERASE,
	HAS,
	GET_KEYS,
	GET_VALUES,
	GET_SIZE,
	CLEAR,
	MERGE,
	GET_OR_ADD,
};

enum class String_Op {
	COPY = 0,
	GET_LENGTH,
	GET_CHAR,
	APPEND,
	INSERT,
	FIND,
	ERASE,
	TO_STD_STRING,
	COMPARE,
	COMPARE_CSTR,
};

enum class Math_Op {
	SIN = 0,
	COS,
	TAN,
	ASIN,
	ACOS,
	ATAN,
	ATAN2,
	POW,
};

enum class Lerp_Op {
	LERP = 0,
	SMOOTHSTEP,
	CLAMP,
	SLERP,
};

enum class Vec2_Op {
	NORMALIZE = 0,
	LENGTH,
	LENGTH_SQ,
	ANGLE,
	ANGLE_TO,
	ANGLE_TO_POINT,
	PROJECT,
	DIRECTION_TO,
	SLIDE,
	BOUNCE,
	REFLECT,
	LIMIT_LENGTH,
	LERP,
	CUBIC_INTERPOLATE,
	SLERP,
	MOVE_TOWARD,
	ROTATED,
};

enum class Vec3_Op {
	HASH = 0,
	LENGTH,
	NORMALIZE,
	DOT,
	CROSS,
	DISTANCE_TO,
	DISTANCE_SQ_TO,
	ANGLE_TO,
	PROJECT,
	REFLECT,
	ROTATED,
	FLOOR,
};

enum class Transform2D_Op {
	IDENTITY = 0,
	CREATE,
	ASSIGN,
	GET_COLUMN,
	SET_COLUMN,
	ROTATED,
	SCALED,
	TRANSLATED,
	INVERTED,
	AFFINE_INVERTED,
	ORTHONORMALIZED,
	LOOKING_AT,
	INTERPOLATE_WITH,
	XFORM,
	XFORM_INV,
};

enum class Transform3D_Op {
	IDENTITY = 0,
	CREATE,
	ASSIGN,
	GET_BASIS,
	SET_BASIS,
	GET_ORIGIN,
	SET_ORIGIN,
	ROTATED,
	ROTATED_LOCAL,
	SCALED,
	SCALED_LOCAL,
	TRANSLATED,
	TRANSLATED_LOCAL,
	INVERTED,
	AFFINE_INVERTED,
	ORTHONORMALIZED,
	LOOKING_AT,
	INTERPOLATE_WITH,
	XFORM,
	XFORM_INV,
};

enum class Basis_Op {
	IDENTITY = 0,
	CREATE,
	ASSIGN,
	GET_ROW,
	SET_ROW,
	GET_COLUMN,
	SET_COLUMN,
	INVERTED,
	TRANSPOSED,
	DETERMINANT,
	ROTATED,
	LERP,
	SLERP,
};

enum class Quaternion_Op {
	CREATE = 0,
	ASSIGN,
	DOT,
	LENGTH_SQUARED,
	LENGTH,
	NORMALIZE,
	INVERSE,
	LOG,
	EXP,
	ANGLE_TO,
	SLERP,
	SLERPNI,
	CUBIC_INTERPOLATE,
	CUBIC_INTERPOLATE_IN_TIME,
	AT,
	GET_AXIS,
	GET_ANGLE,
	MUL,
};

```

`program/cpp/docker/api/syscalls_fwd.hpp`:

```hpp
#pragma once
#include <cstddef>
#include <cstdint>
#include <string_view>
struct Object;
struct Variant;
#ifdef DOUBLE_PRECISION_REAL_T
using real_t = double;
#else
using real_t = float;
#endif

#define PUBLIC extern "C" __attribute__((used, retain))

#define UNLIKELY(x) __builtin_expect(!!(x), 0)

#define EXTERN_SYSCALL(rval, name, ...) \
	extern "C" rval name(__VA_ARGS__);

EXTERN_SYSCALL(void, sys_print, const Variant *, size_t);
EXTERN_SYSCALL(void, sys_throw, const char *, size_t, const char *, size_t, ...);
EXTERN_SYSCALL(unsigned, sys_callable_create, void (*)(), const Variant *, const void *, size_t);
EXTERN_SYSCALL(void, sys_sandbox_add, int, ...);

inline __attribute__((noreturn)) void api_throw_at(std::string_view type, std::string_view msg, const Variant *srcVar, const char *func) {
	sys_throw(type.data(), type.size(), msg.data(), msg.size(), srcVar, func);
	__builtin_unreachable();
}
#define API_THROW(type, msg, srcVar) api_throw_at(type, msg, srcVar, __FUNCTION__)

inline __attribute__((noreturn)) void api_throw(std::string_view type, std::string_view msg, const Variant *srcVar = nullptr) {
	sys_throw(type.data(), type.size(), msg.data(), msg.size(), srcVar, nullptr);
	__builtin_unreachable();
}
#define EXPECT(cond, msg) if (UNLIKELY(!(cond))) { api_throw(__FUNCTION__, msg); }

extern "C" __attribute__((noreturn)) void fast_exit();

// Helper method to call a method on any type that can be wrapped in a Variant
#define VMETHOD(name) \
	template <typename... Args> \
	inline Variant name(Args&&... args) { \
		return operator() (#name, std::forward<Args>(args)...); \
	}

#define METHOD(Type, name) \
	template <typename... Args> \
	inline Type name(Args&&... args) { \
		if constexpr (std::is_same_v<Type, void>) { \
			voidcall(#name, std::forward<Args>(args)...); \
		} else { \
			return operator() (#name, std::forward<Args>(args)...); \
		} \
	}

// Helpers for static method calls
#define SMETHOD(Type, name) METHOD(Type, name)
#define SVMETHOD(name) VMETHOD(name)

```

`program/cpp/docker/api/timer.cpp`:

```cpp
#include "timer.hpp"

#include "object.hpp"
#include "syscalls.h"

using TimerEngineCallback = Variant (*)(Variant, Variant);
using TimerEngineNativeCallback = Variant (*)(Object, PackedArray<uint8_t>);
MAKE_SYSCALL(ECALL_TIMER_PERIODIC, void, sys_timer_periodic, CallbackTimer::period_t, bool, TimerEngineCallback, void *, Variant *);
MAKE_SYSCALL(ECALL_TIMER_PERIODIC, void, sys_timer_periodic_native, CallbackTimer::period_t, bool, TimerEngineNativeCallback, void *, Variant *);
MAKE_SYSCALL(ECALL_TIMER_STOP, void, sys_timer_stop, unsigned);

// clang-format off
Variant CallbackTimer::create(period_t period, bool oneshot, TimerCallback callback) {
	Variant timer;
	sys_timer_periodic(period, oneshot, [](Variant timer, Variant storage) -> Variant {
		std::vector<uint8_t> callback = storage.as_byte_array().fetch();
		CallbackTimer::TimerCallback *timerfunc = (CallbackTimer::TimerCallback *)callback.data();
		return (*timerfunc)(timer);
	}, &callback, &timer);
	return timer;
}

Variant CallbackTimer::create_native(period_t period, bool oneshot, TimerNativeCallback callback) {
	Variant timer;
	sys_timer_periodic_native(period, oneshot, [](Object timer, PackedArray<uint8_t> storage) -> Variant {
		std::vector<uint8_t> callback = storage.fetch();
		CallbackTimer::TimerNativeCallback *timerfunc = (CallbackTimer::TimerNativeCallback *)callback.data();
		return (*timerfunc)(timer);
	}, &callback, &timer);
	return timer;
}
// clang-format on

```

`program/cpp/docker/api/timer.hpp`:

```hpp
#pragma once

#include "function.hpp"
#include "variant.hpp"
struct Object;

struct CallbackTimer {
	using period_t = double;
	using TimerCallback = Function<Variant(Variant)>;
	using TimerNativeCallback = Function<Variant(Object)>;

	// For when native/register-based arguments are enabled (the default)
	static Variant oneshot(period_t secs, TimerNativeCallback callback);

	static Variant periodic(period_t period, TimerNativeCallback callback);

	// For when all arguments are Variants (not the default)
	static Variant oneshotv(period_t secs, TimerCallback callback);

	static Variant periodicv(period_t period, TimerCallback callback);

private:
	static Variant create(period_t p, bool oneshot, TimerCallback callback);
	static Variant create_native(period_t p, bool oneshot, TimerNativeCallback callback);
};

inline Variant CallbackTimer::oneshotv(period_t secs, TimerCallback callback) {
	return create(secs, true, callback);
}

inline Variant CallbackTimer::periodicv(period_t period, TimerCallback callback) {
	return create(period, false, callback);
}

inline Variant CallbackTimer::oneshot(period_t secs, TimerNativeCallback callback) {
	return create_native(secs, true, callback);
}

inline Variant CallbackTimer::periodic(period_t period, TimerNativeCallback callback) {
	return create_native(period, false, callback);
}

```

`program/cpp/docker/api/transform2d.cpp`:

```cpp
#include "transform2d.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_TRANSFORM_2D_OPS, void, sys_transform2d_ops, unsigned, Transform2D_Op, ...);

Transform2D::Transform2D(const Vector2 &x, const Vector2 &y, const Vector2 &origin) {
	sys_transform2d_ops(0, Transform2D_Op::CREATE, this, &x, &y, &origin);
}

Transform2D Transform2D::identity() {
	Transform2D t;
	sys_transform2d_ops(0, Transform2D_Op::IDENTITY, &t);
	return t;
}

void Transform2D::assign(const Transform2D &transform) {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::ASSIGN, this, &transform);
}

Transform2D Transform2D::inverse() const {
	Transform2D t;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::INVERTED, &t);
	return t;
}

void Transform2D::invert() {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::INVERTED, this);
}

Transform2D Transform2D::orthonormalized() const {
	Transform2D t;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::ORTHONORMALIZED, &t);
	return t;
}

void Transform2D::affine_invert() {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::AFFINE_INVERTED, this);
}

Transform2D Transform2D::rotated(double angle) const {
	Transform2D t;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::ROTATED, &t, angle);
	return t;
}

void Transform2D::rotate(double angle) {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::ROTATED, this, angle);
}

Transform2D Transform2D::scaled(const Vector2 &scale) const {
	Transform2D t;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::SCALED, &t, &scale);
	return t;
}

void Transform2D::scale(const Vector2 &scale) {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::SCALED, this, &scale);
}

Transform2D Transform2D::translated(const Vector2 &offset) const {
	Transform2D t;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::TRANSLATED, &t, &offset);
	return t;
}

void Transform2D::translate(const Vector2 &offset) {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::TRANSLATED, this, &offset);
}

Transform2D Transform2D::interpolate_with(const Transform2D &p_transform, double weight) const {
	Transform2D t;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::INTERPOLATE_WITH, &t, &p_transform, weight);
	return t;
}

void Transform2D::interpolate_with(const Transform2D &p_transform, double weight) {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::INTERPOLATE_WITH, this, &p_transform, weight);
}

Vector2 Transform2D::get_column(int idx) const {
	Vector2 v;
	sys_transform2d_ops(this->m_idx, Transform2D_Op::GET_COLUMN, &v, idx);
	return v;
}

void Transform2D::set_column(int idx, const Vector2 &axis) {
	sys_transform2d_ops(this->m_idx, Transform2D_Op::SET_COLUMN, this, idx, &axis);
}

```

`program/cpp/docker/api/transform2d.hpp`:

```hpp
#pragma once

#include "variant.hpp"

/**
 * @brief Transform2D wrapper for godot-cpp Transform2D.
 * Implemented by referencing and mutating a host-side Transform2D Variant.
**/
struct Transform2D {
	constexpr Transform2D() {} // DON'T TOUCH

	/// @brief Create a new identity transform.
	/// @return The identity transform.
	static Transform2D identity();

	/// @brief Create a new transform from two axes and an origin.
	/// @param x  The x-axis of the transform.
	/// @param y  The y-axis of the transform.
	/// @param origin The origin of the transform.
	Transform2D(const Vector2 &x, const Vector2 &y, const Vector2 &origin);

	Transform2D &operator =(const Transform2D &transform);
	void assign(const Transform2D &transform);

	// Transform2D operations
	void invert();
	void affine_invert();
	void rotate(const double angle);
	void scale(const Vector2 &scale);
	void translate(const Vector2 &offset);
	void interpolate_with(const Transform2D &transform, double weight);

	Transform2D inverse() const;
	Transform2D orthonormalized() const;
	Transform2D rotated(double angle) const;
	Transform2D scaled(const Vector2 &scale) const;
	Transform2D translated(const Vector2 &offset) const;
	Transform2D interpolate_with(const Transform2D &p_transform, double weight) const;

	// Transform2D access
	Vector2 get_column(int idx) const;
	void set_column(int idx, const Vector2 &axis);
	Vector2 operator[](int idx) const { return get_column(idx); }

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Transform2D, affine_inverse);
	METHOD(Vector2, basis_xform);
	METHOD(Vector2, basis_xform_inv);
	METHOD(real_t,  determinant);
	METHOD(Vector2, get_origin);
	METHOD(real_t,  get_rotation);
	METHOD(Vector2, get_scale);
	METHOD(real_t,  get_skew);
	METHOD(bool,    is_conformal);
	METHOD(bool,    is_equal_approx);
	METHOD(bool,    is_finite);
	METHOD(Transform2D, looking_at);
	METHOD(Transform2D, rotated_local);
	METHOD(Transform2D, scaled_local);
	METHOD(Transform2D, translated_local);

	static Transform2D from_variant_index(unsigned idx) { Transform2D a {}; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }
private:
	unsigned m_idx = INT32_MIN;
};

inline Variant::Variant(const Transform2D &t) {
	m_type = Variant::TRANSFORM2D;
	v.i = t.get_variant_index();
}

inline Variant::operator Transform2D() const {
	if (m_type != Variant::TRANSFORM2D) {
		api_throw("std::bad_cast", "Failed to cast Variant to Transform2D", this);
	}
	return Transform2D::from_variant_index(v.i);
}

inline Transform2D Variant::as_transform2d() const {
	return static_cast<Transform2D>(*this);
}

inline Transform2D &Transform2D::operator =(const Transform2D &transform) {
	if (this->m_idx != INT32_MIN) {
		this->assign(transform);
	} else {
		this->m_idx = transform.m_idx;
	}
	return *this;
}

template <typename... Args>
inline Variant Transform2D::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/transform3d.cpp`:

```cpp
#include "transform3d.hpp"

#include "syscalls.h"

MAKE_SYSCALL(ECALL_TRANSFORM_3D_OPS, void, sys_transform3d_ops, unsigned, Transform3D_Op, ...);

Transform3D Transform3D::identity() {
	Transform3D t;
	sys_transform3d_ops(0, Transform3D_Op::IDENTITY, &t);
	return t;
}

Transform3D::Transform3D(const Vector3 &origin, const Basis &basis) {
	sys_transform3d_ops(0, Transform3D_Op::CREATE, this, &origin, basis.get_variant_index());
}

void Transform3D::assign(const Transform3D &transform) {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::ASSIGN, this, transform.get_variant_index());
}

Transform3D Transform3D::inverse() const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::INVERTED, &t);
	return t;
}

void Transform3D::invert() {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::INVERTED, this);
}

Transform3D Transform3D::orthonormalized() const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::ORTHONORMALIZED, &t);
	return t;
}

void Transform3D::affine_invert() {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::AFFINE_INVERTED, this);
}

void Transform3D::rotate(const Vector3 &axis, double angle) {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::ROTATED, this, axis, angle);
}

Transform3D Transform3D::rotated(const Vector3 &axis, double angle) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::ROTATED, &t, axis, angle);
	return t;
}

Transform3D Transform3D::rotated_local(const Vector3 &axis, double angle) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::ROTATED_LOCAL, &t, axis, angle);
	return t;
}

void Transform3D::scale(const Vector3 &scale) {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::SCALED, this, &scale);
}

Transform3D Transform3D::scaled(const Vector3 &scale) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::SCALED, &t, &scale);
	return t;
}

Transform3D Transform3D::scaled_local(const Vector3 &scale) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::SCALED_LOCAL, &t, &scale);
	return t;
}

void Transform3D::translate(const Vector3 &offset) {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::TRANSLATED, this, &offset);
}

Transform3D Transform3D::translated(const Vector3 &offset) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::TRANSLATED, &t, &offset);
	return t;
}

Transform3D Transform3D::translated_local(const Vector3 &offset) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::TRANSLATED_LOCAL, &t, &offset);
	return t;
}

Vector3 Transform3D::get_origin() const {
	Vector3 v;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::GET_ORIGIN, &v);
	return v;
}

void Transform3D::set_origin(const Vector3 &origin) {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::SET_ORIGIN, this, &origin);
}

Basis Transform3D::get_basis() const {
	Basis b;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::GET_BASIS, &b);
	return b;
}

void Transform3D::set_basis(const Basis &basis) {
	sys_transform3d_ops(this->m_idx, Transform3D_Op::SET_BASIS, this, basis.get_variant_index());
}

Transform3D Transform3D::looking_at(const Vector3 &target, const Vector3 &up) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::LOOKING_AT, &t, &target, &up);
	return t;
}

Transform3D Transform3D::interpolate_with(const Transform3D &to, double weight) const {
	Transform3D t;
	sys_transform3d_ops(this->m_idx, Transform3D_Op::INTERPOLATE_WITH, &t, to.get_variant_index(), weight);
	return t;
}

```

`program/cpp/docker/api/transform3d.hpp`:

```hpp
#pragma once

#include "variant.hpp"
#include "basis.hpp"

struct Transform3D {
	constexpr Transform3D() {}

	/// @brief Create a new identity transform.
	/// @return The identity transform.
	static Transform3D identity();

	/// @brief Create a new transform from a basis and origin.
	/// @param origin The origin of the transform.
	/// @param basis The basis of the transform.
	Transform3D(const Vector3 &origin, const Basis &basis);

	Transform3D &operator =(const Transform3D &transform);
	void assign(const Transform3D &transform);

	// Transform3D operations
	void invert();
	void affine_invert();
	void translate(const Vector3 &offset);
	void rotate(const Vector3 &axis, double angle);
	void scale(const Vector3 &scale);

	Transform3D inverse() const;
	Transform3D orthonormalized() const;
	Transform3D rotated(const Vector3 &axis, double angle) const;
	Transform3D rotated_local(const Vector3 &axis, double angle) const;
	Transform3D scaled(const Vector3 &scale) const;
	Transform3D scaled_local(const Vector3 &scale) const;
	Transform3D translated(const Vector3 &offset) const;
	Transform3D translated_local(const Vector3 &offset) const;
	Transform3D looking_at(const Vector3 &target, const Vector3 &up) const;
	Transform3D interpolate_with(const Transform3D &to, double weight) const;

	// Transform3D access
	Vector3 get_origin() const;
	void set_origin(const Vector3 &origin);
	Basis get_basis() const;
	void set_basis(const Basis &basis);

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Transform3D, affine_inverse);
	METHOD(bool, is_equal_approx);
	METHOD(bool, is_finite);

	static Transform3D from_variant_index(unsigned idx) { Transform3D a {}; a.m_idx = idx; return a; }
	unsigned get_variant_index() const noexcept { return m_idx; }
private:
	unsigned m_idx = INT32_MIN;
};

inline Variant::Variant(const Transform3D &t) {
	m_type = Variant::TRANSFORM3D;
	v.i = t.get_variant_index();
}

inline Variant::operator Transform3D() const {
	if (m_type != Variant::TRANSFORM3D) {
		api_throw("std::bad_cast", "Failed to cast Variant to Transform3D", this);
	}
	return Transform3D::from_variant_index(v.i);
}

inline Transform3D Variant::as_transform3d() const {
	return static_cast<Transform3D>(*this);
}

inline Transform3D &Transform3D::operator =(const Transform3D &transform) {
	if (this->m_idx != INT32_MIN) {
		this->assign(transform);
	} else {
		this->m_idx = transform.m_idx;
	}
	return *this;
}

template <typename... Args>
Variant Transform3D::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/variant.cpp`:

```cpp
#include "variant.hpp"

#include "callable.hpp"
#include "syscalls.h"

MAKE_SYSCALL(ECALL_VCALL, void, sys_vcall, Variant *, const char *, size_t, const Variant *, size_t, Variant &);
MAKE_SYSCALL(ECALL_VEVAL, bool, sys_veval, int, const Variant *, const Variant *, Variant *);
MAKE_SYSCALL(ECALL_VASSIGN, unsigned, sys_vassign, unsigned, Variant *);

MAKE_SYSCALL(ECALL_VCREATE, void, sys_vcreate, Variant *, int, int, ...);
MAKE_SYSCALL(ECALL_VFETCH, void, sys_vfetch, unsigned, void *, int);
MAKE_SYSCALL(ECALL_VCLONE, void, sys_vclone, const Variant *, Variant *);
MAKE_SYSCALL(ECALL_VSTORE, void, sys_vstore, unsigned *, const void *, size_t);

MAKE_SYSCALL(ECALL_CALLABLE_CREATE, unsigned, sys_callable_create, void (*)(), const Variant *, const void *, size_t);

Variant Variant::new_array() {
	Variant v;
	sys_vcreate(&v, ARRAY, 0, nullptr);
	return v;
}

Variant Variant::from_array(const std::vector<Variant> &values) {
	Variant v;
	sys_vcreate(&v, ARRAY, -1, &values);
	return v;
}
Variant Variant::from_array(std::span<const Variant> array) {
	Variant v;
	sys_vcreate(&v, ARRAY, array.size(), array.data());
	return v;
}

Variant Variant::new_dictionary() {
	Variant v;
	sys_vcreate(&v, DICTIONARY, 0, nullptr);
	return v;
}

void Variant::evaluate(const Operator &op, const Variant &a, const Variant &b, Variant &r_ret, bool &r_valid) {
	r_valid = sys_veval(op, &a, &b, &r_ret);
}

void Variant::internal_create_string(Type type, const std::string &value) {
	if constexpr (sizeof(std::string) == 32) {
		sys_vcreate(this, type, 0, &value);
	} else {
		struct Buffer {
			const char *data;
			size_t size;
		} buffer = { value.data(), value.size() };
		sys_vcreate(this, type, 1, &buffer);
	}
}

void Variant::internal_create_u32string(Type type, const std::u32string &value) {
	sys_vcreate(this, type, 2, &value);
}

std::string Variant::internal_fetch_string() const {
	std::string result;
	if constexpr (sizeof(std::string) == 32) {
		sys_vfetch(this->v.i, &result, 0); // Fetch as std::string
	} else {
		struct Buffer {
			char *data;
			size_t size;
		} buffer;
		sys_vfetch(this->v.i, &buffer, 1); // Fetch as const char*, size_t struct
		result.assign(buffer.data, buffer.size);
		delete[] buffer.data;
	}
	return result;
}

std::u32string Variant::internal_fetch_u32string() const {
	std::u32string result;
	sys_vfetch(this->v.i, &result, 2); // Fetch as std::u32string
	return result;
}

void Variant::internal_clone(const Variant &other) {
	sys_vclone(&other, this);
}

Variant Variant::duplicate() const {
	Variant v;
	sys_vclone(this, &v);
	return v;
}

void Variant::clear() {
	// TODO: If the Variant is a reference, we should clear the reference.
	this->m_type = NIL;
}

Variant &Variant::make_permanent() {
	sys_vclone(this, nullptr);
	return *this;
}

bool Variant::is_permanent() const noexcept {
	return int32_t(uint32_t(this->v.i)) < 0;
}

```

`program/cpp/docker/api/variant.hpp`:

```hpp
#pragma once
#include <array>
#include <cstdint>
#include <type_traits>
#include <string_view>
#include <span>
#include <string>
#include <vector>
#include "syscalls_fwd.hpp"

template<typename T>
struct is_string
	: public std::disjunction<
		std::is_same<char *, typename std::decay<T>::type>,
		std::is_same<const char *, typename std::decay<T>::type>
> {};

template<typename T>
struct is_u32string
	: public std::disjunction<
		std::is_same<char32_t *, typename std::decay<T>::type>,
		std::is_same<const char32_t *, typename std::decay<T>::type>
> {};

template<class T>
struct is_stdstring : public std::is_same<T, std::basic_string<char>> {};

struct Object; struct Node; struct Node2D; struct Node3D; struct Array; struct Dictionary; union String; struct Callable; struct Basis; struct Transform2D; struct Transform3D; struct Quaternion; struct RID;
#include "color.hpp"
#include "plane.hpp"
#include "packed_array.hpp"
#include "vector.hpp"

struct Variant
{
	enum Type : uint32_t {
		NIL,

		// atomic types
		BOOL,
		INT,
		FLOAT,
		STRING,

		// math types
		VECTOR2,
		VECTOR2I,
		RECT2,
		RECT2I,
		VECTOR3,
		VECTOR3I,
		TRANSFORM2D,
		VECTOR4,
		VECTOR4I,
		PLANE,
		QUATERNION,
		AABB,
		BASIS,
		TRANSFORM3D,
		PROJECTION,

		// misc types
		COLOR,
		STRING_NAME,
		NODE_PATH,
		RID,
		OBJECT,
		CALLABLE,
		SIGNAL,
		DICTIONARY,
		ARRAY,

		// typed arrays
		PACKED_BYTE_ARRAY,
		PACKED_INT32_ARRAY,
		PACKED_INT64_ARRAY,
		PACKED_FLOAT32_ARRAY,
		PACKED_FLOAT64_ARRAY,
		PACKED_STRING_ARRAY,
		PACKED_VECTOR2_ARRAY,
		PACKED_VECTOR3_ARRAY,
		PACKED_COLOR_ARRAY,
		PACKED_VECTOR4_ARRAY,

		VARIANT_MAX
	};

	enum Operator {
		// comparison
		OP_EQUAL,
		OP_NOT_EQUAL,
		OP_LESS,
		OP_LESS_EQUAL,
		OP_GREATER,
		OP_GREATER_EQUAL,
		// mathematic
		OP_ADD,
		OP_SUBTRACT,
		OP_MULTIPLY,
		OP_DIVIDE,
		OP_NEGATE,
		OP_POSITIVE,
		OP_MODULE,
		OP_POWER,
		// bitwise
		OP_SHIFT_LEFT,
		OP_SHIFT_RIGHT,
		OP_BIT_AND,
		OP_BIT_OR,
		OP_BIT_XOR,
		OP_BIT_NEGATE,
		// logic
		OP_AND,
		OP_OR,
		OP_XOR,
		OP_NOT,
		// containment
		OP_IN,
		OP_MAX
	};

	constexpr Variant() { m_type = NIL; }
	Variant(const Variant &other);
	Variant(Variant &&other);
	~Variant() {}

	// Constructor for common types
	template <typename T>
	constexpr Variant(T value);

	Variant(const Array&);
	Variant(const Dictionary&);
	Variant(const String&);
	Variant(const Callable&);
	Variant(const ::RID&);
	Variant(const Object&);
	Variant(const Node&);
	Variant(const Node2D&);
	Variant(const Node3D&);
	Variant(const Basis&);
	Variant(const Transform2D&);
	Variant(const Transform3D&);
	Variant(const Quaternion&);
	Variant(const PackedArray<uint8_t>&);
	Variant(const PackedArray<float>&);
	Variant(const PackedArray<double>&);
	Variant(const PackedArray<int32_t>&);
	Variant(const PackedArray<int64_t>&);
	Variant(const PackedArray<Vector2>&);
	Variant(const PackedArray<Vector3>&);
	Variant(const PackedArray<Vector4>&);
	Variant(const PackedArray<Color>&);
	Variant(const PackedArray<std::string>&);

	// Constructor specifically the STRING_NAME type
	static Variant string_name(const std::string &name);

	// Create a new empty Array
	static Variant new_array();
	// Create a new Array from a vector of Variants
	static Variant from_array(const std::vector<Variant> &array);
	// Create a new Array from a span of Variants
	static Variant from_array(std::span<const Variant> array);

	// Empty Dictionary constructor
	static Variant new_dictionary();

	// Conversion operators
	Basis as_basis() const;
	Transform2D as_transform2d() const;
	Transform3D as_transform3d() const;
	Quaternion as_quaternion() const;
	Object as_object() const;
	Node as_node() const;
	Node2D as_node2d() const;
	Node3D as_node3d() const;
	Array as_array() const;
	Dictionary as_dictionary() const;
	String as_string() const;
	Callable as_callable() const;
	std::string as_std_string() const;
	std::u32string as_std_u32string() const;

	operator bool() const;
	operator int64_t() const;
	operator int32_t() const;
	operator int16_t() const;
	operator int8_t() const;
	operator uint64_t() const;
	operator uint32_t() const;
	operator uint16_t() const;
	operator uint8_t() const;
	operator double() const;
	operator float() const;
	operator Basis() const;
	operator Transform2D() const;
	operator Transform3D() const;
	operator Quaternion() const;
	operator std::string() const;
	operator std::u32string() const;
	operator String() const;
	operator Array() const;
	operator Dictionary() const;
	operator Object() const;
	operator Node() const;
	operator ::RID() const;
	operator Callable() const;

	const Vector2 &v2() const;
	Vector2 &v2();
	const Vector2i &v2i() const;
	Vector2i &v2i();
	const Vector3 &v3() const;
	Vector3 &v3();
	const Vector3i &v3i() const;
	Vector3i &v3i();
	const Vector4 &v4() const;
	Vector4 &v4();
	const Vector4i &v4i() const;
	Vector4i &v4i();
	const Rect2 &r2() const;
	Rect2 &r2();
	const Rect2i &r2i() const;
	Rect2i &r2i();
	const Color &color() const;
	Color &color();
	const Plane &plane() const;
	Plane &plane();

	operator Vector2() const { return v2(); }
	operator Vector2i() const { return v2i(); }
	operator Vector3() const { return v3(); }
	operator Vector3i() const { return v3i(); }
	operator Vector4() const { return v4(); }
	operator Vector4i() const { return v4i(); }
	operator Rect2() const { return r2(); }
	operator Rect2i() const { return r2i(); }
	operator Color() const { return color(); }
	operator Plane() const { return plane(); }

	PackedArray<uint8_t> as_byte_array() const;
	PackedArray<float> as_float32_array() const;
	PackedArray<double> as_float64_array() const;
	PackedArray<int32_t> as_int32_array() const;
	PackedArray<int64_t> as_int64_array() const;
	PackedArray<Vector2> as_vector2_array() const;
	PackedArray<Vector3> as_vector3_array() const;
	PackedArray<Vector4> as_vector4_array() const;
	PackedArray<Color> as_color_array() const;
	PackedArray<std::string> as_string_array() const;

	operator PackedArray<uint8_t>() const { return as_byte_array(); }
	operator PackedArray<float>() const { return as_float32_array(); }
	operator PackedArray<double>() const { return as_float64_array(); }
	operator PackedArray<int32_t>() const { return as_int32_array(); }
	operator PackedArray<int64_t>() const { return as_int64_array(); }
	operator PackedArray<Vector2>() const { return as_vector2_array(); }
	operator PackedArray<Vector3>() const { return as_vector3_array(); }
	operator PackedArray<Vector4>() const { return as_vector4_array(); }
	operator PackedArray<Color>() const { return as_color_array(); }
	operator PackedArray<std::string>() const { return as_string_array(); }

	void callp(std::string_view method, const Variant *args, int argcount, Variant &r_ret);
	void voidcallp(std::string_view method, const Variant *args, int argcount);

	template <typename... Args>
	Variant method_call(std::string_view method, Args&&... args);

	template <typename... Args>
	void voidcall(std::string_view method, Args&&... args);

	template <typename... Args>
	Variant call(Args... args);

	template <typename... Args>
	Variant operator ()(std::string_view method, Args... args);

	/// @brief Check if the Variant is nil.
	/// @return true if the Variant is nil, false otherwise.
	bool is_nil() const noexcept { return m_type == NIL; }

	static void evaluate(const Operator &op, const Variant &a, const Variant &b, Variant &r_ret, bool &r_valid);

	Variant duplicate() const;
	void clear();

	/// @brief Make the Variant permanent, by moving it to permanent storage.
	/// @return Updates the Variant to the new permanent Variant and returns it.
	Variant &make_permanent();
	bool is_permanent() const noexcept;

	Variant &operator=(const Variant &other);
	Variant &operator=(Variant &&other);
	bool operator==(const Variant &other) const;
	bool operator!=(const Variant &other) const;
	bool operator<(const Variant &other) const;

	Type get_type() const noexcept { return m_type; }
	unsigned get_internal_index() const noexcept { return v.i; }
	static bool is_permanent_index(unsigned idx) noexcept { return int32_t(idx) < 0; }

private:
	Type m_type = NIL;
	union {
		int64_t  i;
		bool     b;
		double   f;
		real_t   v4[4];
		int32_t  v4i[4];
	} v;

	void internal_create_string(Type type, const std::string &value);
	void internal_create_u32string(Type type, const std::u32string &value);
	void internal_clone(const Variant &other);
	std::string internal_fetch_string() const;
	std::u32string internal_fetch_u32string() const;
};
#ifdef DOUBLE_PRECISION_REAL_T
static_assert(sizeof(Variant) == 40, "Variant size mismatch");
#else
static_assert(sizeof(Variant) == 24, "Variant size mismatch");
#endif

template <typename T>
inline constexpr Variant::Variant(T value)
{
	if constexpr (std::is_same_v<T, bool>) {
		m_type = BOOL;
		v.b = value;
	}
	else if constexpr (std::is_integral_v<T>) {
		m_type = INT;
		v.i = value;
	}
	else if constexpr (std::is_floating_point_v<T>) {
		m_type = FLOAT;
		v.f = value;
	}
	else if constexpr (std::is_same_v<T, Vector2>) {
		m_type = VECTOR2;
		v.v4[0] = value.x;
		v.v4[1] = value.y;
	}
	else if constexpr (std::is_same_v<T, Vector2i>) {
		m_type = VECTOR2I;
		v.v4i[0] = value.x;
		v.v4i[1] = value.y;
	}
	else if constexpr (std::is_same_v<T, Vector3>) {
		m_type = VECTOR3;
		v.v4[0] = value.x;
		v.v4[1] = value.y;
		v.v4[2] = value.z;
	}
	else if constexpr (std::is_same_v<T, Vector3i>) {
		m_type = VECTOR3I;
		v.v4i[0] = value.x;
		v.v4i[1] = value.y;
		v.v4i[2] = value.z;
	}
	else if constexpr (std::is_same_v<T, Vector4>) {
		m_type = VECTOR4;
		v.v4[0] = value.x;
		v.v4[1] = value.y;
		v.v4[2] = value.z;
		v.v4[3] = value.w;
	}
	else if constexpr (std::is_same_v<T, Vector4i>) {
		m_type = VECTOR4I;
		v.v4i[0] = value.x;
		v.v4i[1] = value.y;
		v.v4i[2] = value.z;
		v.v4i[3] = value.w;
	}
	else if constexpr (std::is_same_v<T, Rect2>) {
		m_type = RECT2;
		v.v4[0] = value.position.x;
		v.v4[1] = value.position.y;
		v.v4[2] = value.size.x;
		v.v4[3] = value.size.y;
	}
	else if constexpr (std::is_same_v<T, Rect2i>) {
		m_type = RECT2I;
		v.v4i[0] = value.position.x;
		v.v4i[1] = value.position.y;
		v.v4i[2] = value.size.x;
		v.v4i[3] = value.size.y;
	}
	else if constexpr (std::is_same_v<T, Color>) {
		m_type = COLOR;
		v.v4[0] = value.r;
		v.v4[1] = value.g;
		v.v4[2] = value.b;
		v.v4[3] = value.a;
	}
	else if constexpr (std::is_same_v<T, Plane>) {
		m_type = PLANE;
		v.v4[0] = value.normal.x;
		v.v4[1] = value.normal.y;
		v.v4[2] = value.normal.z;
		v.v4[3] = value.d;
	}
	else if constexpr (is_u32string<T>::value || std::is_same_v<T, std::u32string>) {
		internal_create_u32string(STRING, value);
	}
	else if constexpr (is_string<T>::value || is_stdstring<T>::value || std::is_same_v<T, std::string>) {
		internal_create_string(STRING, value);
	}
	else if constexpr (std::is_same_v<T, std::string_view>) {
		internal_create_string(STRING, std::string(value));
	}
	// Derives from Object
	else if constexpr (std::is_base_of_v<Object, T>) {
		m_type = OBJECT;
		v.i = value.address();
	}
	else
		static_assert(!std::is_same_v<T, T>, "Unsupported type");
}

#define Nil Variant()

inline Variant::Variant(const PackedArray<uint8_t> &array)
{
	m_type = PACKED_BYTE_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<float> &array)
{
	m_type = PACKED_FLOAT32_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<double> &array)
{
	m_type = PACKED_FLOAT64_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<int32_t> &array)
{
	m_type = PACKED_INT32_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<int64_t> &array)
{
	m_type = PACKED_INT64_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<Vector2> &array)
{
	m_type = PACKED_VECTOR2_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<Vector3> &array)
{
	m_type = PACKED_VECTOR3_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<Vector4> &array)
{
	m_type = PACKED_VECTOR4_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<Color> &array)
{
	m_type = PACKED_COLOR_ARRAY;
	v.i = array.get_variant_index();
}
inline Variant::Variant(const PackedArray<std::string> &array)
{
	m_type = PACKED_STRING_ARRAY;
	v.i = array.get_variant_index();
}
template <typename T>
inline PackedArray<T>::PackedArray(const Variant& v) {
	if (v.get_type() < Variant::PACKED_BYTE_ARRAY || v.get_type() > Variant::PACKED_VECTOR4_ARRAY) {
		API_THROW("std::bad_cast", "Failed to cast Variant to PackedArray", &v);
	}
	m_idx = v.get_internal_index();
}

inline Variant Variant::string_name(const std::string &name) {
	Variant v;
	v.internal_create_string(STRING_NAME, name);
	return v;
}

inline Variant::operator bool() const
{
	if (m_type == BOOL || m_type == INT)
		return v.b;
	API_THROW("std::bad_cast", "Failed to cast Variant to bool", this);
}

inline Variant::operator int64_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return v.i;
	API_THROW("std::bad_cast", "Failed to cast Variant to int64", this);
}

inline Variant::operator int32_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return static_cast<int32_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to int32", this);
}

inline Variant::operator int16_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return static_cast<int16_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to int16", this);
}

inline Variant::operator int8_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return static_cast<int8_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to int8", this);
}

inline Variant::operator uint64_t() const
{
	if (m_type == INT || m_type == FLOAT || m_type == OBJECT)
		return static_cast<uint64_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to uint64", this);
}

inline Variant::operator uint32_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return static_cast<uint32_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to uint32", this);
}

inline Variant::operator uint16_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return static_cast<uint16_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to uint16", this);
}

inline Variant::operator uint8_t() const
{
	if (m_type == INT || m_type == FLOAT)
		return static_cast<uint8_t>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to uint8", this);
}

inline Variant::operator double() const
{
	if (m_type == FLOAT)
		return v.f;
	if (m_type == INT)
		return static_cast<double>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to double", this);
}

inline Variant::operator float() const
{
	if (m_type == FLOAT)
		return static_cast<float>(v.f);
	if (m_type == INT)
		return static_cast<float>(v.i);
	API_THROW("std::bad_cast", "Failed to cast Variant to float", this);
}

inline Variant::operator std::string() const
{
	if (m_type == STRING || m_type == STRING_NAME || m_type == NODE_PATH || m_type == PACKED_BYTE_ARRAY)
		return internal_fetch_string();
	API_THROW("std::bad_cast", "Failed to cast Variant to const std::string&", this);
}

inline Variant::operator std::u32string() const
{
	if (m_type == STRING || m_type == STRING_NAME)
		return internal_fetch_u32string();
	API_THROW("std::bad_cast", "Failed to cast Variant to const std::u32string&", this);
}

inline std::string Variant::as_std_string() const {
	return static_cast<std::string>(*this);
}

inline std::u32string Variant::as_std_u32string() const {
	return static_cast<std::u32string>(*this);
}

inline const Vector2 &Variant::v2() const
{
	if (m_type == VECTOR2)
		return *reinterpret_cast<const Vector2 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector2", this);
}

inline Vector2 &Variant::v2()
{
	if (m_type == VECTOR2)
		return *reinterpret_cast<Vector2 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector2", this);
}

inline const Vector2i &Variant::v2i() const
{
	if (m_type == VECTOR2I)
		return *reinterpret_cast<const Vector2i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector2i", this);
}

inline Vector2i &Variant::v2i()
{
	if (m_type == VECTOR2I)
		return *reinterpret_cast<Vector2i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector2o", this);
}

inline const Vector3 &Variant::v3() const
{
	if (m_type == VECTOR3)
		return *reinterpret_cast<const Vector3 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector3", this);
}

inline Vector3 &Variant::v3()
{
	if (m_type == VECTOR3)
		return *reinterpret_cast<Vector3 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector3", this);
}

inline const Vector3i &Variant::v3i() const
{
	if (m_type == VECTOR3I)
		return *reinterpret_cast<const Vector3i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector3i", this);
}

inline Vector3i &Variant::v3i()
{
	if (m_type == VECTOR3I)
		return *reinterpret_cast<Vector3i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector3i", this);
}

inline const Vector4 &Variant::v4() const
{
	if (m_type == VECTOR4)
		return *reinterpret_cast<const Vector4 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector4", this);
}

inline Vector4 &Variant::v4()
{
	if (m_type == VECTOR4)
		return *reinterpret_cast<Vector4 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector4", this);
}

inline const Vector4i &Variant::v4i() const
{
	if (m_type == VECTOR4I)
		return *reinterpret_cast<const Vector4i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector4i", this);
}

inline Vector4i &Variant::v4i()
{
	if (m_type == VECTOR4I)
		return *reinterpret_cast<Vector4i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Vector4i", this);
}

inline const Rect2& Variant::r2() const
{
	if (m_type == RECT2)
		return *reinterpret_cast<const Rect2 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Rect2", this);
}

inline Rect2 &Variant::r2()
{
	if (m_type == RECT2)
		return *reinterpret_cast<Rect2 *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Rect2", this);
}

inline const Rect2i &Variant::r2i() const
{
	if (m_type == RECT2I)
		return *reinterpret_cast<const Rect2i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Rect2i", this);
}

inline Rect2i &Variant::r2i()
{
	if (m_type == RECT2I)
		return *reinterpret_cast<Rect2i *>(v.v4i);
	API_THROW("std::bad_cast", "Failed to cast Variant to Rect2i", this);
}

inline const Color &Variant::color() const
{
	if (m_type == COLOR)
		return *reinterpret_cast<const Color *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Color", this);
}

inline Color &Variant::color()
{
	if (m_type == COLOR)
		return *reinterpret_cast<Color *>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Color", this);
}

inline const Plane &Variant::plane() const
{
	if (m_type == PLANE)
		return reinterpret_cast<const Plane &>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Plane", this);
}

inline Plane &Variant::plane()
{
	if (m_type == PLANE)
		return reinterpret_cast<Plane &>(v.v4);
	API_THROW("std::bad_cast", "Failed to cast Variant to Plane", this);
}

inline PackedArray<uint8_t> Variant::as_byte_array() const {
	if (m_type == PACKED_BYTE_ARRAY) {
		return PackedArray<uint8_t>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedByteArray", this);
}

inline PackedArray<float> Variant::as_float32_array() const {
	if (m_type == PACKED_FLOAT32_ARRAY) {
		return PackedArray<float>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedFloat32Array", this);
}

inline PackedArray<double> Variant::as_float64_array() const {
	if (m_type == PACKED_FLOAT64_ARRAY) {
		return PackedArray<double>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedFloat64Array", this);
}

inline PackedArray<int32_t> Variant::as_int32_array() const {
	if (m_type == PACKED_INT32_ARRAY) {
		return PackedArray<int32_t>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedInt32Array", this);
}

inline PackedArray<int64_t> Variant::as_int64_array() const {
	if (m_type == PACKED_INT64_ARRAY) {
		return PackedArray<int64_t>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedInt64Array", this);
}

inline PackedArray<Vector2> Variant::as_vector2_array() const {
	if (m_type == PACKED_VECTOR2_ARRAY) {
		return PackedArray<Vector2>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedVector2Array", this);
}

inline PackedArray<Vector3> Variant::as_vector3_array() const {
	if (m_type == PACKED_VECTOR3_ARRAY) {
		return PackedArray<Vector3>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedVector3Array", this);
}

inline PackedArray<Vector4> Variant::as_vector4_array() const {
	if (m_type == PACKED_VECTOR4_ARRAY) {
		return PackedArray<Vector4>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedVector4Array", this);
}

inline PackedArray<Color> Variant::as_color_array() const {
	if (m_type == PACKED_COLOR_ARRAY) {
		return PackedArray<Color>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedColorArray", this);
}

inline PackedArray<std::string> Variant::as_string_array() const {
	if (m_type == PACKED_STRING_ARRAY) {
		return PackedArray<std::string>::from_index(v.i);
	}
	API_THROW("std::bad_cast", "Failed to cast Variant to PackedStringArray", this);
}

inline Variant::Variant(const Variant &other)
{
	m_type = other.m_type;
	if (m_type == STRING || m_type == NODE_PATH || m_type == STRING_NAME)
		this->internal_clone(other);
	else
		v = other.v;
}
inline Variant::Variant(Variant &&other)
{
	m_type = other.m_type;
	v = other.v;

	other.m_type = NIL;
}

inline Variant &Variant::operator=(const Variant &other) {
	m_type = other.m_type;
	if (m_type == STRING || m_type == NODE_PATH || m_type == STRING_NAME)
		this->internal_clone(other);
	else
		v = other.v;

	return *this;
}
inline Variant &Variant::operator=(Variant &&other) {
	m_type = other.m_type;
	v = other.v;

	other.m_type = NIL;
	return *this;
}

inline bool Variant::operator==(const Variant &other) const {
	bool valid = false;
	Variant result;
	evaluate(OP_EQUAL, *this, other, result, valid);
	return result.operator bool();
}
inline bool Variant::operator!=(const Variant &other) const {
	bool valid = false;
	Variant result;
	evaluate(OP_NOT_EQUAL, *this, other, result, valid);
	return result.operator bool();
}
inline bool Variant::operator<(const Variant &other) const {
	bool valid = false;
	Variant result;
	evaluate(OP_LESS, *this, other, result, valid);
	return result.operator bool();
}

template <typename... Args>
inline Variant Variant::method_call(std::string_view method, Args&&... args) {
	if constexpr (sizeof...(args) == 0) {
		Variant result;
		callp(method, nullptr, 0, result);
		return result;
	}
	std::array<Variant, sizeof...(args)> vargs = { args... };
	Variant result;
	callp(method, vargs.data(), vargs.size(), result);
	return result;
}

template <typename... Args>
inline void Variant::voidcall(std::string_view method, Args&&... args) {
	if constexpr (sizeof...(args) == 0) {
		voidcallp(method, nullptr, 0);
		return;
	}
	std::array<Variant, sizeof...(args)> vargs = { args... };
	voidcallp(method, vargs.data(), vargs.size());
}

template <typename... Args>
inline Variant Variant::call(Args... args) {
	std::array<Variant, sizeof...(args)> vargs = { args... };
	Variant result;
	callp("call", vargs.data(), vargs.size(), result);
	return result;
}

template <typename... Args>
inline Variant Variant::operator ()(std::string_view method, Args... args) {
	return method_call(method, args...);
}

/* Variant::callp() requires maximum performance, so implement using inline assembly */
inline void Variant::callp(std::string_view method, const Variant *args, int argcount, Variant &r_ret) {
	//sys_vcall(this, method.begin(), method.size(), args, argcount, r_ret);
	static constexpr int ECALL_VCALL = 501; // Call a method on a Variant
	register const Variant *object asm("a0") = this;
	register const char *method_ptr asm("a1") = method.begin();
	register size_t method_size asm("a2") = method.size();
	register const Variant *args_ptr asm("a3") = args;
	register size_t argcount_reg asm("a4") = argcount;
	register Variant *ret_ptr asm("a5") = &r_ret;
	register int syscall_number asm("a7") = ECALL_VCALL;

	asm volatile(
		"ecall"
		: "=m"(*ret_ptr)
		: "r"(object), "m"(*object), "r"(method_ptr), "r"(method_size), "m"(*method_ptr), "r"(args_ptr), "r"(argcount_reg), "r"(ret_ptr), "m"(*args_ptr), "r"(syscall_number)
	);
}

inline void Variant::voidcallp(std::string_view method, const Variant *args, int argcount) {
	static constexpr int ECALL_VCALL = 501; // Call a method on a Variant
	register const Variant *object asm("a0") = this;
	register const char *method_ptr asm("a1") = method.begin();
	register size_t method_size asm("a2") = method.size();
	register const Variant *args_ptr asm("a3") = args;
	register size_t argcount_reg asm("a4") = argcount;
	register Variant *ret_ptr asm("a5") = nullptr;
	register int syscall_number asm("a7") = ECALL_VCALL;

	asm volatile(
		"ecall"
		: /* no outputs */
		: "r"(object), "m"(*object), "r"(method_ptr), "r"(method_size), "m"(*method_ptr), "r"(args_ptr), "r"(argcount_reg), "r"(ret_ptr), "m"(*args_ptr), "r"(syscall_number)
	);
}

/* Call operators on simple wrapper objects */

template <typename... Args>
inline Variant Vector2::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Vector2i::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Vector3::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Vector3i::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Vector4::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Vector4i::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Rect2::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Rect2i::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Color::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename... Args>
inline Variant Plane::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

/* Call operators on packed arrays */

template <typename T>
template <typename... Args>
inline Variant PackedArray<T>::operator () (std::string_view method, Args&&... args) {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

template <typename T>
template <typename... Args>
inline Variant PackedArray<T>::operator()(std::string_view method, Args &&...args) const {
	return Variant(*this).method_call(method, std::forward<Args>(args)...);
}

```

`program/cpp/docker/api/vector.cpp`:

```cpp
#include <vector> // std::hash

#include "syscalls.h"
#include "vector.hpp"

MAKE_SYSCALL(ECALL_VEC2_OPS, void, sys_vec2_ops, Vec2_Op op, Vector2 *v, ...); // NOLINT
MAKE_SYSCALL(ECALL_VEC3_OPS, void, sys_vec3_ops, Vector3 *v, Vector3 *other, Vec3_Op op); // NOLINT

Vector2 Vector2::limit_length(double length) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::LIMIT_LENGTH, &result, length);
	return result;
}

Vector2 Vector2::lerp(const Vector2 &to, double weight) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::LERP, &result, &to, weight);
	return result;
}

Vector2 Vector2::slerp(const Vector2 &to, double weight) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::SLERP, &result, &to, weight);
	return result;
}

Vector2 Vector2::cubic_interpolate(const Vector2 &b, const Vector2 &pre_a, const Vector2 &post_b, double weight) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::CUBIC_INTERPOLATE, &result, &b, &pre_a, &post_b, weight);
	return result;
}

Vector2 Vector2::slide(const Vector2 &normal) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::SLIDE, &result, &normal);
	return result;
}

Vector2 Vector2::bounce(const Vector2 &normal) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::BOUNCE, &result, &normal);
	return result;
}

Vector2 Vector2::reflect(const Vector2 &normal) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::REFLECT, &result, &normal);
	return result;
}

Vector2 Vector2::project(const Vector2 &by) const noexcept {
	Vector2 result = *this;
	sys_vec2_ops(Vec2_Op::PROJECT, &result, &by);
	return result;
}

float Vector3::length() const noexcept {
	register const Vector3 *vptr asm("a0") = this;
	register int op asm("a2") = int(Vec3_Op::LENGTH);
	register float length asm("fa0");
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=f"(length)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(syscall));
	return length;
}

Vector3 Vector3::normalized() const noexcept {
	Vector3 result;

	register const Vector3 *vptr asm("a0") = this;
	register Vector3 *resptr asm("a1") = &result;
	register int op asm("a2") = int(Vec3_Op::NORMALIZE);
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=m"(*resptr)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(resptr), "r"(syscall));
	return result;
}

float Vector3::dot(const Vector3 &other) const noexcept {
	register const Vector3 *vptr asm("a0") = this;
	register const Vector3 *otherptr asm("a1") = &other;
	register int op asm("a2") = int(Vec3_Op::DOT);
	register float dot asm("fa0");
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=f"(dot)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(otherptr), "m"(*otherptr), "r"(syscall));
	return dot;
}

Vector3 Vector3::cross(const Vector3 &other) const noexcept {
	Vector3 result;

	register const Vector3 *vptr asm("a0") = this;
	register const Vector3 *otherptr asm("a1") = &other;
	register int op asm("a2") = int(Vec3_Op::CROSS);
	register Vector3 *resptr asm("a3") = &result;
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=m"(*resptr)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(otherptr), "m"(*otherptr), "r"(resptr), "r"(syscall));
	return result;
}

float Vector3::distance_to(const Vector3 &other) const noexcept {
	register const Vector3 *vptr asm("a0") = this;
	register const Vector3 *otherptr asm("a1") = &other;
	register int op asm("a2") = int(Vec3_Op::DISTANCE_TO);
	register float distance asm("fa0");
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=f"(distance)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(otherptr), "m"(*otherptr), "r"(syscall));
	return distance;
}

float Vector3::distance_squared_to(const Vector3 &other) const noexcept {
	register const Vector3 *vptr asm("a0") = this;
	register const Vector3 *otherptr asm("a1") = &other;
	register int op asm("a2") = int(Vec3_Op::DISTANCE_SQ_TO);
	register float distance asm("fa0");
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=f"(distance)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(otherptr), "m"(*otherptr), "r"(syscall));
	return float(distance);
}

float Vector3::angle_to(const Vector3 &other) const noexcept {
	register const Vector3 *vptr asm("a0") = this;
	register const Vector3 *otherptr asm("a1") = &other;
	register int op asm("a2") = int(Vec3_Op::ANGLE_TO);
	register float angle asm("fa0");
	register int syscall asm("a7") = ECALL_VEC3_OPS;

	__asm__ volatile("ecall"
					 : "=f"(angle)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(otherptr), "m"(*otherptr), "r"(syscall));
	return angle;
}

Vector3 Vector3::direction_to(const Vector3 &other) const noexcept {
	Vector3 ret(other.x - x, other.y - y, other.z - z);
	ret.normalize();
	return ret;
}

static_assert(sizeof(Vector3) == 12, "Vector3 size mismatch");
static_assert(alignof(Vector3) == 4, "Vector3 alignment mismatch");

```

`program/cpp/docker/api/vector.hpp`:

```hpp
#pragma once
enum ClockDirection {
	CLOCKWISE = 0,
	COUNTERCLOCKWISE = 1,
};

#include "vector2.hpp"
#include "vector2i.hpp"
#include "rect2.hpp"
#include "rect2i.hpp"
#include "vector3.hpp"
#include "vector3i.hpp"
#include "vector4.hpp"
#include "vector4i.hpp"

namespace std
{
	inline void hash_combine(std::size_t &seed, std::size_t hash)
	{
		hash += 0x9e3779b9 + (seed << 6) + (seed >> 2);
		seed ^= hash;
	}

	template <>
	struct hash<Vector2>
	{
		std::size_t operator()(const Vector2 &v) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<real_t>{}(v.x));
			hash_combine(seed, std::hash<real_t>{}(v.y));
			return seed;
		}
	};

	template <>
	struct hash<Vector2i>
	{
		std::size_t operator()(const Vector2i &v) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<int>{}(v.x));
			hash_combine(seed, std::hash<int>{}(v.y));
			return seed;
		}
	};

	template <>
	struct hash<Rect2>
	{
		std::size_t operator()(const Rect2 &r) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<real_t>{}(r.position.x));
			hash_combine(seed, std::hash<real_t>{}(r.position.y));
			hash_combine(seed, std::hash<real_t>{}(r.size.x));
			hash_combine(seed, std::hash<real_t>{}(r.size.y));
			return seed;
		}
	};

	template <>
	struct hash<Rect2i>
	{
		std::size_t operator()(const Rect2i &r) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<int>{}(r.position.x));
			hash_combine(seed, std::hash<int>{}(r.position.y));
			hash_combine(seed, std::hash<int>{}(r.size.x));
			hash_combine(seed, std::hash<int>{}(r.size.y));
			return seed;
		}
	};

	template <>
	struct hash<Vector3>
	{
		inline std::size_t operator()(const Vector3 &v) const {
			register const Vector3 *vptr asm("a0") = &v;
			register std::size_t hash asm("a0");
			register int op asm("a2") = 0; // Vec3_Op::HASH
			register int syscall asm("a7") = 537; // ECALL_VEC3_OPS

			__asm__ volatile("ecall"
							: "=r"(hash)
							: "r"(op), "r"(vptr), "m"(*vptr), "r"(syscall));
			return hash;
		}
	};

	template <>
	struct hash<Vector3i>
	{
		std::size_t operator()(const Vector3i &v) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<int>{}(v.x));
			hash_combine(seed, std::hash<int>{}(v.y));
			hash_combine(seed, std::hash<int>{}(v.z));
			return seed;
		}
	};

	template <>
	struct hash<Vector4>
	{
		std::size_t operator()(const Vector4 &v) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<real_t>{}(v.x));
			hash_combine(seed, std::hash<real_t>{}(v.y));
			hash_combine(seed, std::hash<real_t>{}(v.z));
			hash_combine(seed, std::hash<real_t>{}(v.w));
			return seed;
		}
	};

	template <>
	struct hash<Vector4i>
	{
		std::size_t operator()(const Vector4i &v) const
		{
			std::size_t seed = 0;
			hash_combine(seed, std::hash<int>{}(v.x));
			hash_combine(seed, std::hash<int>{}(v.y));
			hash_combine(seed, std::hash<int>{}(v.z));
			hash_combine(seed, std::hash<int>{}(v.w));
			return seed;
		}
	};
}

```

`program/cpp/docker/api/vector2.hpp`:

```hpp
#pragma once
#include <cmath>
#include <string_view>
#include "syscalls_fwd.hpp"

struct Vector2 {
	real_t x;
	real_t y;

	float length() const noexcept;
	float length_squared() const noexcept { return x * x + y * y; }
	Vector2 limit_length(double length) const noexcept;

	void normalize() { *this = normalized(); }
	Vector2 normalized() const noexcept;
	float distance_to(const Vector2& other) const noexcept;
	Vector2 direction_to(const Vector2& other) const noexcept;
	float dot(const Vector2& other) const noexcept;
	static Vector2 sincos(float angle) noexcept;
	static Vector2 from_angle(float angle) noexcept;

	Vector2 lerp(const Vector2& to, double weight) const noexcept;
	Vector2 cubic_interpolate(const Vector2& b, const Vector2& pre_a, const Vector2& post_b, double weight) const noexcept;
	Vector2 slerp(const Vector2& to, double weight) const noexcept;

	Vector2 slide(const Vector2& normal) const noexcept;
	Vector2 bounce(const Vector2& normal) const noexcept;
	Vector2 reflect(const Vector2& normal) const noexcept;

	void rotate(real_t angle) noexcept { *this = rotated(angle); }
	Vector2 rotated(real_t angle) const noexcept;

	Vector2 project(const Vector2& vec) const noexcept;
	Vector2 orthogonal() const noexcept { return {y, -x}; }
	float aspect() const noexcept { return x / y; }

	real_t operator [] (int index) const {
		return index == 0 ? x : y;
	}
	real_t& operator [] (int index) {
		return index == 0 ? x : y;
	}

	METHOD(Vector2, abs);
	METHOD(Vector2, bezier_derivative);
	METHOD(Vector2, bezier_interpolate);
	METHOD(Vector2, ceil);
	METHOD(Vector2, clamp);
	METHOD(Vector2, clampf);
	METHOD(real_t,  cross);
	METHOD(Vector2, cubic_interpolate_in_time);
	METHOD(Vector2, floor);
	METHOD(bool,    is_equal_approx);
	METHOD(bool,    is_finite);
	METHOD(bool,    is_normalized);
	METHOD(bool,    is_zero_approx);
	METHOD(Vector2, max);
	METHOD(Vector2, maxf);
	METHOD(int,     max_axis_index);
	METHOD(Vector2, min);
	METHOD(Vector2, minf);
	METHOD(int,     min_axis_index);
	METHOD(Vector2, move_toward);
	METHOD(Vector2, posmod);
	METHOD(Vector2, posmodv);
	METHOD(Vector2, round);
	METHOD(Vector2, sign);
	METHOD(Vector2, snapped);
	METHOD(Vector2, snappedf);

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	constexpr Vector2& operator += (const Vector2& other) {
		x += other.x;
		y += other.y;
		return *this;
	}
	constexpr Vector2& operator -= (const Vector2& other) {
		x -= other.x;
		y -= other.y;
		return *this;
	}
	constexpr Vector2& operator *= (const Vector2& other) {
		x *= other.x;
		y *= other.y;
		return *this;
	}
	constexpr Vector2& operator /= (const Vector2& other) {
		x /= other.x;
		y /= other.y;
		return *this;
	}

	bool operator == (const Vector2& other) const {
		return x == other.x && y == other.y;
	}

	constexpr Vector2() : x(0), y(0) {}
	constexpr Vector2(real_t val) : x(val), y(val) {}
	constexpr Vector2(real_t x, real_t y) : x(x), y(y) {}

	static Vector2 const ZERO;
	static Vector2 const ONE;
	static Vector2 const LEFT;
	static Vector2 const RIGHT;
	static Vector2 const UP;
	static Vector2 const DOWN;
};
inline constexpr Vector2 const Vector2::ZERO = Vector2(0, 0);
inline constexpr Vector2 const Vector2::ONE = Vector2(1, 1);
inline constexpr Vector2 const Vector2::LEFT = Vector2(-1, 0);
inline constexpr Vector2 const Vector2::RIGHT = Vector2(1, 0);
inline constexpr Vector2 const Vector2::UP = Vector2(0, -1);
inline constexpr Vector2 const Vector2::DOWN = Vector2(0, 1);


inline constexpr auto operator + (const Vector2& a, const Vector2& b) noexcept {
	return Vector2{a.x + b.x, a.y + b.y};
}
inline constexpr auto operator - (const Vector2& a, const Vector2& b) noexcept {
	return Vector2{a.x - b.x, a.y - b.y};
}
inline constexpr auto operator * (const Vector2& a, const Vector2& b) noexcept {
	return Vector2{a.x * b.x, a.y * b.y};
}
inline constexpr auto operator / (const Vector2& a, const Vector2& b) noexcept {
	return Vector2{a.x / b.x, a.y / b.y};
}

inline constexpr auto operator + (const Vector2& a, real_t b) noexcept {
	return Vector2{a.x + b, a.y + b};
}
inline constexpr auto operator - (const Vector2& a, real_t b) noexcept {
	return Vector2{a.x - b, a.y - b};
}
inline constexpr auto operator * (const Vector2& a, real_t b) noexcept {
	return Vector2{a.x * b, a.y * b};
}
inline constexpr auto operator / (const Vector2& a, real_t b) noexcept {
	return Vector2{a.x / b, a.y / b};
}

inline float Vector2::length() const noexcept {
	register float x asm("fa0") = this->x;
	register float y asm("fa1") = this->y;
	register int syscall asm("a7") = 514; // ECALL_VEC2_LENGTH

	__asm__ volatile("ecall"
					 : "+f"(x)
					 : "f"(y), "r"(syscall));
	return x;
}

inline Vector2 Vector2::normalized() const noexcept {
	register float x asm("fa0") = this->x;
	register float y asm("fa1") = this->y;
	register int syscall asm("a7") = 515; // ECALL_VEC2_NORMALIZED

	__asm__ volatile("ecall"
					 : "+f"(x), "+f"(y)
					 : "r"(syscall));
	return {x, y};
}

inline Vector2 Vector2::rotated(real_t angle) const noexcept {
	register float x asm("fa0") = this->x;
	register float y asm("fa1") = this->y;
	register float a asm("fa2") = angle;
	register int syscall asm("a7") = 516; // ECALL_VEC2_ROTATED

	__asm__ volatile("ecall"
					 : "+f"(x), "+f"(y)
					 : "f"(a), "r"(syscall));
	return {x, y};
}

inline float Vector2::distance_to(const Vector2& other) const noexcept {
	return (*this - other).length();
}
inline Vector2 Vector2::direction_to(const Vector2& other) const noexcept {
	return (*this - other).normalized();
}
inline float Vector2::dot(const Vector2& other) const noexcept {
	return x * other.x + y * other.y;
}
inline Vector2 Vector2::sincos(float angle) noexcept {
	register float s asm("fa0") = angle;
	register float c asm("fa1");
	register int syscall asm("a7") = 513; // ECALL_SINCOS

	__asm__ volatile("ecall"
					 : "+f"(s), "=f"(c)
					 : "r"(syscall));
	return {s, c}; // (sine, cosine)
}
inline Vector2 Vector2::from_angle(float angle) noexcept {
	Vector2 v = sincos(angle);
	return {v.y, v.x}; // (cos(angle), sin(angle))
}

```

`program/cpp/docker/api/vector2i.hpp`:

```hpp
#pragma once
#include <cmath>
#include <string_view>
#include "syscalls_fwd.hpp"

struct Vector2i {
	int x;
	int y;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	Vector2i& operator += (const Vector2i& other) {
		x += other.x;
		y += other.y;
		return *this;
	}
	Vector2i& operator -= (const Vector2i& other) {
		x -= other.x;
		y -= other.y;
		return *this;
	}
	Vector2i& operator *= (const Vector2i& other) {
		x *= other.x;
		y *= other.y;
		return *this;
	}
	Vector2i& operator /= (const Vector2i& other) {
		x /= other.x;
		y /= other.y;
		return *this;
	}

	bool operator == (const Vector2i& other) const {
		return x == other.x && y == other.y;
	}
	bool operator != (const Vector2i& other) const {
		return !this->operator==(other);
	}

	constexpr Vector2i() : x(0), y(0) {}
	constexpr Vector2i(int val) : x(val), y(val) {}
	constexpr Vector2i(int x, int y) : x(x), y(y) {}
};

inline constexpr auto operator + (const Vector2i& a, const Vector2i& b) noexcept {
	return Vector2i{a.x + b.x, a.y + b.y};
}
inline constexpr auto operator - (const Vector2i& a, const Vector2i& b) noexcept {
	return Vector2i{a.x - b.x, a.y - b.y};
}
inline constexpr auto operator * (const Vector2i& a, const Vector2i& b) noexcept {
	return Vector2i{a.x * b.x, a.y * b.y};
}
inline constexpr auto operator / (const Vector2i& a, const Vector2i& b) noexcept {
	return Vector2i{a.x / b.x, a.y / b.y};
}

inline constexpr auto operator + (const Vector2i& a, int b) noexcept {
	return Vector2i{a.x + b, a.y + b};
}
inline constexpr auto operator - (const Vector2i& a, int b) noexcept {
	return Vector2i{a.x - b, a.y - b};
}
inline constexpr auto operator * (const Vector2i& a, int b) noexcept {
	return Vector2i{a.x * b, a.y * b};
}
inline constexpr auto operator / (const Vector2i& a, int b) noexcept {
	return Vector2i{a.x / b, a.y / b};
}

```

`program/cpp/docker/api/vector3.hpp`:

```hpp
#pragma once
#include <cmath>
#include "syscalls_fwd.hpp"

struct Vector3 {
	real_t x;
	real_t y;
	real_t z;

	float length() const noexcept;
	float length_squared() const noexcept { return this->dot(*this); }
	void normalize() { *this = normalized(); }
	Vector3 normalized() const noexcept;
	float dot(const Vector3& other) const noexcept;
	Vector3 cross(const Vector3& other) const noexcept;
	float distance_to(const Vector3& other) const noexcept;
	float distance_squared_to(const Vector3& other) const noexcept;
	float angle_to(const Vector3& other) const noexcept;
	Vector3 direction_to(const Vector3& other) const noexcept;
	Vector3 floor() const noexcept;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Vector3, abs);
	METHOD(Vector3, bezier_derivative);
	METHOD(Vector3, bezier_interpolate);
	METHOD(Vector3, bounce);
	METHOD(Vector3, ceil);
	METHOD(Vector3, clamp);
	METHOD(Vector3, clampf);
	METHOD(Vector3, cubic_interpolate);
	METHOD(Vector3, cubic_interpolate_in_time);
	METHOD(Vector3, inverse);
	METHOD(bool,    is_equal_approx);
	METHOD(bool,    is_finite);
	METHOD(bool,    is_normalized);
	METHOD(bool,    is_zero_approx);
	METHOD(Vector3, lerp);
	METHOD(Vector3, limit_length);
	METHOD(Vector3, max);
	METHOD(int,     max_axis_index);
	METHOD(Vector3, maxf);
	METHOD(Vector3, min);
	METHOD(int,     min_axis_index);
	METHOD(Vector3, minf);
	METHOD(Vector3, move_toward);
	METHOD(Vector3, octahedron_decode);
	//METHOD(Vector2, octahedron_encode);
	//METHOD(Basis,   outer);
	METHOD(Vector3, posmod);
	METHOD(Vector3, posmodv);
	METHOD(Vector3, project);
	METHOD(Vector3, reflect);
	METHOD(Vector3, rotated);
	METHOD(Vector3, round);
	METHOD(Vector3, sign);
	METHOD(real_t,  signed_angle_to);
	METHOD(Vector3, slerp);
	METHOD(Vector3, slide);
	METHOD(Vector3, snapped);
	METHOD(Vector3, snappedf);

	Vector3& operator += (const Vector3& other) {
		x += other.x;
		y += other.y;
		z += other.z;
		return *this;
	}
	Vector3& operator -= (const Vector3& other) {
		x -= other.x;
		y -= other.y;
		z -= other.z;
		return *this;
	}
	Vector3& operator *= (const Vector3& other) {
		x *= other.x;
		y *= other.y;
		z *= other.z;
		return *this;
	}
	Vector3& operator /= (const Vector3& other) {
		x /= other.x;
		y /= other.y;
		z /= other.z;
		return *this;
	}

	bool operator == (const Vector3& other) const {
		return __builtin_memcmp(this, &other, sizeof(Vector3)) == 0;
	}
	bool operator != (const Vector3& other) const {
		return !(*this == other);
	}

	constexpr Vector3() : x(0), y(0), z(0) {}
	constexpr Vector3(real_t val) : x(val), y(val), z(val) {}
	constexpr Vector3(real_t x, real_t y, real_t z) : x(x), y(y), z(z) {}

	static Vector3 const ZERO;
	static Vector3 const ONE;
	static Vector3 const LEFT;
	static Vector3 const RIGHT;
	static Vector3 const UP;
	static Vector3 const DOWN;
	static Vector3 const FORWARD;
	static Vector3 const BACK;
};
inline constexpr Vector3 const Vector3::ZERO = Vector3(0, 0, 0);
inline constexpr Vector3 const Vector3::ONE = Vector3(1, 1, 1);
inline constexpr Vector3 const Vector3::LEFT = Vector3(-1, 0, 0);
inline constexpr Vector3 const Vector3::RIGHT = Vector3(1, 0, 0);
inline constexpr Vector3 const Vector3::UP = Vector3(0, 1, 0);
inline constexpr Vector3 const Vector3::DOWN = Vector3(0, -1, 0);
inline constexpr Vector3 const Vector3::FORWARD = Vector3(0, 0, -1);
inline constexpr Vector3 const Vector3::BACK = Vector3(0, 0, 1);


inline constexpr auto operator + (const Vector3& a, const Vector3& b) noexcept {
	return Vector3{a.x + b.x, a.y + b.y, a.z + b.z};
}
inline constexpr auto operator - (const Vector3& a, const Vector3& b) noexcept {
	return Vector3{a.x - b.x, a.y - b.y, a.z - b.z};
}
inline constexpr auto operator * (const Vector3& a, const Vector3& b) noexcept {
	return Vector3{a.x * b.x, a.y * b.y, a.z * b.z};
}
inline constexpr auto operator / (const Vector3& a, const Vector3& b) noexcept {
	return Vector3{a.x / b.x, a.y / b.y, a.z / b.z};
}

inline constexpr auto operator + (const Vector3& a, real_t b) noexcept {
	return Vector3{a.x + b, a.y + b, a.z + b};
}
inline constexpr auto operator - (const Vector3& a, real_t b) noexcept {
	return Vector3{a.x - b, a.y - b, a.z - b};
}
inline constexpr auto operator * (const Vector3& a, real_t b) noexcept {
	return Vector3{a.x * b, a.y * b, a.z * b};
}
inline constexpr auto operator / (const Vector3& a, real_t b) noexcept {
	return Vector3{a.x / b, a.y / b, a.z / b};
}

inline Vector3 Vector3::floor() const noexcept {
	register const Vector3 *vptr asm("a0") = this;
	register float resultX asm("fa0");
	register float resultY asm("fa1");
	register float resultZ asm("fa2");
	register int op asm("a2") = 11; // Vec3_Op::FLOOR
	register int syscall asm("a7") = 537; // ECALL_VEC3_OPS

	__asm__ volatile("ecall"
					 : "=f"(resultX), "=f"(resultY), "=f"(resultZ)
					 : "r"(op), "r"(vptr), "m"(*vptr), "r"(syscall));
	return {resultX, resultY, resultZ};
}

```

`program/cpp/docker/api/vector3i.hpp`:

```hpp
#pragma once
#include <cmath>
#include "syscalls_fwd.hpp"

struct Vector3i {
	int x;
	int y;
	int z;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Vector3i, abs);
	METHOD(Vector3i, clamp);
	METHOD(Vector3i, clampi);
	METHOD(int,      distance_squared_to);
	METHOD(real_t,   distance_to);
	METHOD(real_t,   length);
	METHOD(int,      length_squared);
	METHOD(Vector3i, max);
	METHOD(int,      max_axis_index);
	METHOD(Vector3i, maxi);
	METHOD(Vector3i, min);
	METHOD(int,      min_axis_index);
	METHOD(Vector3i, mini);
	METHOD(Vector3i, sign);
	METHOD(Vector3i, snapped);
	METHOD(Vector3i, snappedi);

	Vector3i& operator += (const Vector3i& other) {
		x += other.x;
		y += other.y;
		z += other.z;
		return *this;
	}
	Vector3i& operator -= (const Vector3i& other) {
		x -= other.x;
		y -= other.y;
		z -= other.z;
		return *this;
	}
	Vector3i& operator *= (const Vector3i& other) {
		x *= other.x;
		y *= other.y;
		z *= other.z;
		return *this;
	}
	Vector3i& operator /= (const Vector3i& other) {
		x /= other.x;
		y /= other.y;
		z /= other.z;
		return *this;
	}

	bool operator == (const Vector3i& other) const {
		return __builtin_memcmp(this, &other, sizeof(Vector3i)) == 0;
	}
	bool operator != (const Vector3i& other) const {
		return !(*this == other);
	}

	constexpr Vector3i() : x(0), y(0), z(0) {}
	constexpr Vector3i(int val) : x(val), y(val), z(val) {}
	constexpr Vector3i(int x, int y, int z) : x(x), y(y), z(z) {}
};

inline constexpr auto operator + (const Vector3i& a, const Vector3i& b) noexcept {
	return Vector3i{a.x + b.x, a.y + b.y, a.z + b.z};
}
inline constexpr auto operator - (const Vector3i& a, const Vector3i& b) noexcept {
	return Vector3i{a.x - b.x, a.y - b.y, a.z - b.z};
}
inline constexpr auto operator * (const Vector3i& a, const Vector3i& b) noexcept {
	return Vector3i{a.x * b.x, a.y * b.y, a.z * b.z};
}
inline constexpr auto operator / (const Vector3i& a, const Vector3i& b) noexcept {
	return Vector3i{a.x / b.x, a.y / b.y, a.z / b.z};
}

inline constexpr auto operator + (const Vector3i& a, int b) noexcept {
	return Vector3i{a.x + b, a.y + b, a.z + b};
}
inline constexpr auto operator - (const Vector3i& a, int b) noexcept {
	return Vector3i{a.x - b, a.y - b, a.z - b};
}
inline constexpr auto operator * (const Vector3i& a, int b) noexcept {
	return Vector3i{a.x * b, a.y * b, a.z * b};
}
inline constexpr auto operator / (const Vector3i& a, int b) noexcept {
	return Vector3i{a.x / b, a.y / b, a.z / b};
}

```

`program/cpp/docker/api/vector4.hpp`:

```hpp
#pragma once
#include <cmath>
#include "syscalls_fwd.hpp"
#include "vector3.hpp"

struct Vector4 {
	real_t x;
	real_t y;
	real_t z;
	real_t w;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Vector4, abs);
	METHOD(Vector4, ceil);
	METHOD(Vector4, clamp);
	METHOD(Vector4, clampf);
	METHOD(Vector4, cubic_interpolate);
	METHOD(Vector4, cubic_interpolate_in_time);
	METHOD(Vector4, direction_to);
	METHOD(real_t,  distance_squared_to);
	METHOD(real_t,  distance_to);
	METHOD(real_t,  dot);
	METHOD(Vector4, floor);
	METHOD(Vector4, inverse);
	METHOD(bool,    is_equal_approx);
	METHOD(bool,    is_finite);
	METHOD(bool,    is_normalized);
	METHOD(bool,    is_zero_approx);
	METHOD(real_t,  length);
	METHOD(real_t,  length_squared);
	METHOD(Vector4, lerp);
	METHOD(Vector4, max);
	METHOD(int,     max_axis_index);
	METHOD(Vector4, maxf);
	METHOD(Vector4, min);
	METHOD(int,     min_axis_index);
	METHOD(Vector4, minf);
	METHOD(Vector4, normalized);
	METHOD(Vector4, posmod);
	METHOD(Vector4, posmodv);
	METHOD(Vector4, round);
	METHOD(Vector4, sign);
	METHOD(Vector4, snapped);
	METHOD(Vector4, snappedf);

	Vector4& operator += (const Vector4& other) {
		x += other.x;
		y += other.y;
		z += other.z;
		w += other.w;
		return *this;
	}
	Vector4& operator -= (const Vector4& other) {
		x -= other.x;
		y -= other.y;
		z -= other.z;
		w -= other.w;
		return *this;
	}
	Vector4& operator *= (const Vector4& other) {
		x *= other.x;
		y *= other.y;
		z *= other.z;
		w *= other.w;
		return *this;
	}
	Vector4& operator /= (const Vector4& other) {
		x /= other.x;
		y /= other.y;
		z /= other.z;
		w /= other.w;
		return *this;
	}

	bool operator == (const Vector4& other) const {
		return __builtin_memcmp(this, &other, sizeof(Vector4)) == 0;
	}
	bool operator != (const Vector4& other) const {
		return !(*this == other);
	}

	constexpr Vector4() : x(0), y(0), z(0), w(0) {}
	constexpr Vector4(real_t val) : x(val), y(val), z(val), w(val) {}
	constexpr Vector4(real_t x, real_t y, real_t z, real_t w) : x(x), y(y), z(z), w(w) {}
	constexpr Vector4(Vector3 v, real_t w) : x(v.x), y(v.y), z(v.z), w(w) {}
};

inline constexpr auto operator + (const Vector4& a, const Vector4& b) noexcept {
	return Vector4{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}
inline constexpr auto operator - (const Vector4& a, const Vector4& b) noexcept {
	return Vector4{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}
inline constexpr auto operator * (const Vector4& a, const Vector4& b) noexcept {
	return Vector4{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};
}
inline constexpr auto operator / (const Vector4& a, const Vector4& b) noexcept {
	return Vector4{a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};
}

inline constexpr auto operator + (const Vector4& a, real_t b) noexcept {
	return Vector4{a.x + b, a.y + b, a.z + b, a.w + b};
}
inline constexpr auto operator - (const Vector4& a, real_t b) noexcept {
	return Vector4{a.x - b, a.y - b, a.z - b, a.w - b};
}
inline constexpr auto operator * (const Vector4& a, real_t b) noexcept {
	return Vector4{a.x * b, a.y * b, a.z * b, a.w * b};
}
inline constexpr auto operator / (const Vector4& a, real_t b) noexcept {
	return Vector4{a.x / b, a.y / b, a.z / b, a.w / b};
}

```

`program/cpp/docker/api/vector4i.hpp`:

```hpp
#pragma once
#include <cmath>
#include "syscalls_fwd.hpp"

struct Vector4i {
	int x;
	int y;
	int z;
	int w;

	template <typename... Args>
	Variant operator () (std::string_view method, Args&&... args);

	METHOD(Vector4i, abs);
	METHOD(Vector4i, clamp);
	METHOD(Vector4i, clampi);
	METHOD(int,      distance_squared_to);
	METHOD(real_t,   distance_to);
	METHOD(real_t,   length);
	METHOD(int,      length_squared);
	METHOD(Vector4i, max);
	METHOD(int,      max_axis_index);
	METHOD(Vector4i, maxi);
	METHOD(Vector4i, min);
	METHOD(int,      min_axis_index);
	METHOD(Vector4i, mini);
	METHOD(Vector4i, sign);
	METHOD(Vector4i, snapped);
	METHOD(Vector4i, snappedi);

	Vector4i& operator += (const Vector4i& other) {
		x += other.x;
		y += other.y;
		z += other.z;
		w += other.w;
		return *this;
	}
	Vector4i& operator -= (const Vector4i& other) {
		x -= other.x;
		y -= other.y;
		z -= other.z;
		w -= other.w;
		return *this;
	}
	Vector4i& operator *= (const Vector4i& other) {
		x *= other.x;
		y *= other.y;
		z *= other.z;
		w *= other.w;
		return *this;
	}
	Vector4i& operator /= (const Vector4i& other) {
		x /= other.x;
		y /= other.y;
		z /= other.z;
		w /= other.w;
		return *this;
	}

	bool operator == (const Vector4i& other) const {
		return __builtin_memcmp(this, &other, sizeof(Vector4i)) == 0;
	}
	bool operator != (const Vector4i& other) const {
		return !(*this == other);
	}

	constexpr Vector4i() : x(0), y(0), z(0), w(0) {}
	constexpr Vector4i(int val) : x(val), y(val), z(val), w(val) {}
	constexpr Vector4i(int x, int y, int z, int w) : x(x), y(y), z(z), w(w) {}
};

inline constexpr auto operator + (const Vector4i& a, const Vector4i& b) noexcept {
	return Vector4i{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}
inline constexpr auto operator - (const Vector4i& a, const Vector4i& b) noexcept {
	return Vector4i{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}
inline constexpr auto operator * (const Vector4i& a, const Vector4i& b) noexcept {
	return Vector4i{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};
}
inline constexpr auto operator / (const Vector4i& a, const Vector4i& b) noexcept {
	return Vector4i{a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};
}

inline constexpr auto operator + (const Vector4i& a, int b) noexcept {
	return Vector4i{a.x + b, a.y + b, a.z + b, a.w + b};
}
inline constexpr auto operator - (const Vector4i& a, int b) noexcept {
	return Vector4i{a.x - b, a.y - b, a.z - b, a.w - b};
}
inline constexpr auto operator * (const Vector4i& a, int b) noexcept {
	return Vector4i{a.x * b, a.y * b, a.z * b, a.w * b};
}
inline constexpr auto operator / (const Vector4i& a, int b) noexcept {
	return Vector4i{a.x / b, a.y / b, a.z / b, a.w / b};
}

```

`program/cpp/docker/build.sh`:

```sh
usage() {
	echo "Usage: $0 [--api] [-o output] -- [input...]"
	echo "  --api        Instead of compiling, copy the API files to the output."
	echo "  --line addr  Convert an address to a line number."
	echo "   -o output   Compile sources into an output ELF file, including API and inputs."
	echo "  --debug      Compile with debug information."
	echo "  -D macro     Define a macro."
	echo "  --local      Compile as if locally (outside Docker), using the local API files."
	echo "  --version    Print the current version of the API."
	echo "   -v          Verbose output."
	echo "  --           Separate options from input files."
	exit 1
}

locally=false
verbose=false
current_version=10
CPPFLAGS="-O2 -std=gnu++23 -DVERSION=$current_version -fno-stack-protector -fno-threadsafe-statics"
ADDR2LINE="riscv64-linux-gnu-addr2line"

while [[ "$#" -gt 0 ]]; do
	case $1 in
		--api) cp -r /usr/api $1; exit ;;
		--line) shift; addr="$1"; shift; binary="$1"; shift; $ADDR2LINE -C -f -e $binary $addr; exit ;;
		-o) shift; output="$1"; shift; break ;;
		--debug) CPPFLAGS="$CPPFLAGS -g"; shift ;;
		-D) shift; CPPFLAGS="$CPPFLAGS -D$1"; shift ;;
		--local) locally=true; shift ;;
		--version) shift; echo "$current_version"; exit ;;
		-v) verbose=true; shift ;;
		--) shift; break ;;
		*) usage ;;
	esac
done

if [ -z "$output" ]; then
	usage
fi

MEMOPS=-Wl,--wrap=memcpy,--wrap=memset,--wrap=memcmp,--wrap=memmove
STROPS=-Wl,--wrap=strlen,--wrap=strcmp,--wrap=strncmp
HEAPOPS=-Wl,--wrap=malloc,--wrap=calloc,--wrap=realloc,--wrap=free
LINKEROPS="$MEMOPS $STROPS $HEAPOPS"

if [ "$locally" = true ]; then
	API="api"
else
	API="/usr/api"
fi

# For each C++ file in *.cpp and api/*.cpp, compile it into a .o file asynchronously
for file in $@ $API/*.cpp; do
	if [ verbose = true ]; then
		echo "Compiling $file"
	fi
	if [ "$locally" = true ]; then
		riscv64-unknown-elf-g++ $CPPFLAGS -I$API -c $file -o $file.o &
	else
		export CXX="riscv64-linux-gnu-g++-14"
		ccache $CXX $CPPFLAGS -march=rv64gc_zba_zbb_zbs_zbc -mabi=lp64d -I$API -I. -c $file -o $file.o &
	fi
done

# Wait for all files to compile
wait

# Link all .o files into the output
if [ "$locally" = true ]; then
	riscv64-unknown-elf-g++ -static $CPPFLAGS $LINKEROPS $@.o $API/*.cpp.o -o $output
else
	export CXX="riscv64-linux-gnu-g++-14"
	LINKEROPS="$LINKEROPS -fuse-ld=mold"
	ccache $CXX -static $CPPFLAGS -march=rv64gc_zba_zbb_zbs_zbc -mabi=lp64d $LINKEROPS $@.o $API/*.cpp.o -o $output
fi

```

`program/cpp/docker/container_build.sh`:

```sh
docker build -t riscv64-linux-gnu .

```

`program/cpp/docker/docker.sh`:

```sh
#!/bin/bash

usage() {
	echo "Usage: docker.sh [command] [options]"
	echo "Commands:"
	echo "  --build          Builds the initial docker image"
	echo "  --enter          Enters the docker container"
	echo "  --clean          Remove all stopped containers and dangling images"
	echo "  --help           Show this help message"
}

build() {
	docker build -t riscv64-linux-gnu .
}

clean() {
	docker rm $(docker ps -a -q)
	docker rmi $(docker images -f "dangling=true" -q)
}

enter() {
	echo "Use './build.sh' to build the RISC-V program"
	docker run -it -v .:/usr/src riscv64-linux-gnu
}

case $1 in
	--build)
		build
		;;
	--clean)
		clean
		;;
	--enter)
		enter
		;;
	--help)
		usage
		;;
	*)
		usage
		;;
esac

```

`program/cpp/docker/start.sh`:

```sh
docker run --name godot-cpp-compiler -dv .:/usr/src riscv64-linux-gnu

```

`program/cpp/docker/stop_and_remove.sh`:

```sh
docker stop -t1 godot-cpp-compiler
docker rm godot-cpp-compiler

```

`program/cpp/docker/test_local_compiler.sh`:

```sh
#!/bin/bash
FILE="$1"
OUT="$2"
API="api/*.cpp"
INCLUDES="-Iapi"
VERSION=6

echo "Compiling $FILES into $OUT"

WARN="-Wall"
OPTS="-std=gnu++23 -fno-stack-protector -fno-threadsafe-statics $INCLUDES"
MEMOPS=-Wl,--wrap=memcpy,--wrap=memset,--wrap=memcmp,--wrap=memmove
STROPS=-Wl,--wrap=strlen,--wrap=strcmp,--wrap=strncmp
HEAPOPS=-Wl,--wrap=malloc,--wrap=calloc,--wrap=realloc,--wrap=free
LINKEROPS="$MEMOPS $STROPS $HEAPOPS"

set -v -x
riscv64-unknown-elf-g++ -DVERSION=$VERSION -g -O2 $OPTS $WARN $API "$FILE" -o "$OUT"

```

`program/cpp/project/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18)
project (godot-sandbox-programs)

# Fetch godot-sandbox for add_sandbox_program and other functions
include(FetchContent)
FetchContent_Declare(
	godot-sandbox
	GIT_REPOSITORY https://github.com/libriscv/godot-sandbox.git
	GIT_TAG        main
	SOURCE_SUBDIR  "program/cpp/cmake"
)
FetchContent_MakeAvailable(godot-sandbox)

# Build the godot-sandbox program `sandbox_program.elf`:
add_sandbox_program(sandbox_program.elf
	"src/program.cpp"
)

```

`program/cpp/project/README.md`:

```md
# Example C++ CMake project

This folder contains an example CMake project that uses Zig to build RISC-V C and C++ programs with the Godot Sandbox API included.

## Building

The project is built using [build.sh](build.sh):

```sh
Usage: ./build.sh [options]

Options:
  -h, --help      Display this help and exit
  --runtime-api   Download a run-time generated Godot API header
  --no-runtime-api Do not download a run-time generated Godot API header
  --debug         Build with debug symbols
  --debinfo       Build with debug info
  --strip         Strip the binary
  --no-strip      Do not strip the binary
  --single        Build with single precision vectors
  --double        Build with double precision vectors
  --C             Enable RISC-V C extension (default)
  --no-C          Disable RISC-V C extension
  --toolchain     Specify a custom toolchain file
  --verbose       Enable verbose build
```

Example:

```sh
$ ./build.sh --strip
~/github/godot-riscv/program/cpp/project/.build ~/github/godot-riscv/program/cpp/project
-- The C compiler identification is Clang 19.1.0
-- The CXX compiler identification is Clang 19.1.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /home/gonzo/zig/zig - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /home/gonzo/zig/zig - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Building using zig c++
-- Configuring done
-- Generating done
-- Build files have been written to: /home/gonzo/github/godot-riscv/program/cpp/project/.build
[  4%] Building C object CMakeFiles/atomic.dir/src/atomic.c.o
[  9%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/array.cpp.o
[ 18%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/api.cpp.o
[ 18%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/native.cpp.o
[ 22%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/basis.cpp.o
[ 27%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/node2d.cpp.o
[ 36%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/node.cpp.o
[ 36%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/dictionary.cpp.o
[ 40%] Linking C static library libatomic.a
[ 40%] Built target atomic
[ 45%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/node3d.cpp.o
[ 50%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/object.cpp.o
[ 54%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/packed_array.cpp.o
[ 59%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/quaternion.cpp.o
[ 63%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/string.cpp.o
[ 68%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/timer.cpp.o
[ 72%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/transform2d.cpp.o
[ 77%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/transform3d.cpp.o
[ 81%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/variant.cpp.o
[ 86%] Building CXX object cmake/CMakeFiles/sandbox_api.dir/api/vector.cpp.o
[ 90%] Linking CXX static library libsandbox_api.a
[ 90%] Built target sandbox_api
[ 95%] Building CXX object CMakeFiles/sandbox_program.dir/src/program.cpp.o
[100%] Linking CXX executable sandbox_program
[100%] Built target sandbox_program
~/github/godot-riscv/program/cpp/project
```

The name of the program files built depends on the name used in CMakeLists.txt:

```cmake
cmake_minimum_required(VERSION 3.18)
project (godot-sandbox-programs)

# Fetch godot-sandbox for add_sandbox_program and other functions
include(FetchContent)
FetchContent_Declare(
	godot-sandbox
	GIT_REPOSITORY https://github.com/libriscv/godot-sandbox.git
	GIT_TAG        main
	SOURCE_SUBDIR  "program/cpp/cmake"
)
FetchContent_MakeAvailable(godot-sandbox)

# Build the godot-sandbox program `sandbox_program.elf`:
add_sandbox_program(sandbox_program.elf
	"src/program.cpp"
)
```

So, based on `add_sandbox_program(name file1 ... fileN)` it should produce an ELF binary named `sandbox_program.elf` inside the build folder.

The build process happens inside a hidden folder called `.build`:

```sh
$ ls -lah .build/
total 268K
drwxrwxr-x 4 gonzo gonzo 4,0K des.  10 11:57 .
drwxrwxr-x 4 gonzo gonzo 4,0K des.  10 11:57 ..
drwxrwxr-x 3 gonzo gonzo 4,0K des.  10 11:57 cmake
-rw-rw-r-- 1 gonzo gonzo  14K des.  10 11:57 CMakeCache.txt
drwxrwxr-x 6 gonzo gonzo 4,0K des.  10 11:57 CMakeFiles
-rw-rw-r-- 1 gonzo gonzo 1,9K des.  10 11:57 cmake_install.cmake
-rw-rw-r-- 1 gonzo gonzo 1,1K des.  10 11:57 libatomic.a
-rw-rw-r-- 1 gonzo gonzo 7,0K des.  10 11:57 Makefile
-rwxrwxr-x 1 gonzo gonzo 219K des.  10 11:57 sandbox_program.elf
```

We can see a 219kb `sandbox_program`. This program is ready to use.

```sh
$ file .build/sandbox_program.elf
.build/sandbox_program.elf: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, stripped
```

It's a statically built RISC-V program, so it can be loaded by Godot Sandbox. In order for Godot Sandbox to see the ELF file as a resource, it should have the `.elf` file extension.

```

`program/cpp/project/build.sh`:

```sh
#!/bin/bash
export CC="zig;cc;-target riscv64-linux-musl"
export CXX="zig;c++;-target riscv64-linux-musl"
ARGS=""
BTYPE="Release"

# Find zig
if ! command -v zig &> /dev/null
then
	echo "zig could not be found globally. Please install zig and try again."
	exit
fi

usage()
{
	echo "Usage: $0 [options]"
	echo
	echo "Options:"
	echo "  -h, --help      Display this help and exit"
	echo "  --runtime-api   Download a run-time generated Godot API header"
	echo "  --no-runtime-api Do not download a run-time generated Godot API header"
	echo "  --debug         Build with debug symbols"
	echo "  --debinfo       Build with debug info"
	echo "  --strip         Strip the binary"
	echo "  --no-strip      Do not strip the binary"
	echo "  --single        Build with single precision vectors"
	echo "  --double        Build with double precision vectors"
	echo "  --C             Enable RISC-V C extension (default)"
	echo "  --no-C          Disable RISC-V C extension"
	echo "  --toolchain     Specify a custom toolchain file"
	echo "  --verbose       Enable verbose build"
	echo
}

# Command-line options
while [[ "$#" -gt 0 ]]; do
    case $1 in
		-h|--help ) usage; exit; ;;
		--runtime-api) ARGS="$ARGS -DDOWNLOAD_RUNTIME_API=ON" ;;
		--no-runtime-api) ARGS="$ARGS -DDOWNLOAD_RUNTIME_API=OFF" ;;
		--debug) BTYPE="Debug" ;;
		--debinfo) BTYPE="RelWithDebInfo" ;;
		--strip) ARGS="$ARGS -DSTRIPPED=ON" ;;
		--no-strip) ARGS="$ARGS -DSTRIPPED=OFF" ;;
		--single) ARGS="$ARGS -DDOUBLE_PRECISION=OFF" ;;
		--double) ARGS="$ARGS -DDOUBLE_PRECISION=ON" ;;
		--C) ARGS="$ARGS -DSANDBOX_RISCV_EXT_C=ON" ;;
		--no-C) ARGS="$ARGS -DSANDBOX_RISCV_EXT_C=OFF" ;;
		--toolchain) ARGS="$ARGS -DCMAKE_TOOLCHAIN_FILE=$2"; shift ;;
		--verbose) ARGS="$ARGS -DCMAKE_VERBOSE_MAKEFILE=ON" ;;
		*) echo "Unknown parameter passed: $1"; exit 1 ;;
	esac
	shift
done

mkdir -p .build
pushd .build
cmake .. -DCMAKE_BUILD_TYPE=$BTYPE $ARGS -DCMAKE_C_COMPILER="$CC" -DCMAKE_CXX_COMPILER="$CXX"
make -j8
popd

```

`program/cpp/project/src/program.cpp`:

```cpp
#include <api.hpp>

static String last_string = "Hello, world!";
static Variant last_printed_string() {
	return last_string;
}
static Variant print_string(String str) {
	printf("String: %s\n", str.utf8().c_str());
	fflush(stdout);
	last_string = str;
	return Nil;
}

static long fib(long n, long acc, long prev) {
	if (n == 0)
		return acc;
	else
		return fib(n - 1, prev + acc, acc);
}

static Variant fibonacci(int n) {
	return fib(n, 0, 1);
}

int main() {
	print("Hello, world!");

	// The entire Godot API is available
	Sandbox sandbox = get_node<Sandbox>();
	print(sandbox.is_binary_translated()
		? "The current program is accelerated by binary translation."
		: "The current program is running in interpreter mode.");

	// Add public API
	ADD_API_FUNCTION(last_printed_string, "String", "", "Returns the last printed string");
	ADD_API_FUNCTION(print_string, "void", "String str", "Prints a string to the console");
	ADD_API_FUNCTION(fibonacci, "long", "int n", "Calculates the nth Fibonacci number");

	// Add a sandboxed property
	static int meaning_of_life = 42;
	add_property("meaning_of_life", Variant::Type::INT, 42,
		[]() -> Variant { return meaning_of_life; },
		[](Variant value) -> Variant { meaning_of_life = value; print("Set to: ", meaning_of_life); return Nil; });

	halt();
}

```

`program/rust/docker/Cargo.toml`:

```toml
[package]
name = "rust_program"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

[[bin]]
name = "rust_program"
path = "src/main.rs"

```

`program/rust/docker/Dockerfile`:

```
FROM ubuntu:24.04

RUN apt-get -qq update && \
	apt-get install -y -q \
	curl \
	g++-14-riscv64-linux-gnu \
	git cmake mold

RUN curl https://sh.rustup.rs -sSf | sh -s -- -y
ENV PATH="/root/.cargo/bin:${PATH}"

# Add RISC-V target
RUN rustup default nightly
RUN rustup target add riscv64gc-unknown-linux-gnu

# Create a project directory
RUN mkdir -p /usr/project
COPY build.sh Cargo.toml /usr/project/
COPY .cargo /usr/project/.cargo
COPY src /usr/project/src

# Create a source directory (which will be mounted)
RUN mkdir -p /usr/src
WORKDIR /usr/src

# Make the container a background process
CMD ["/bin/bash", "-c", "tail -f /dev/null"]

```

`program/rust/docker/build.sh`:

```sh
#!/bin/bash
set -e

usage() {
	echo "Usage: $0 [--api] [-o output] -- [input...]"
	echo "  --api        Instead of compiling, copy the API files to the output."
	echo "   -o output   Compile sources into an output ELF file, including API and inputs."
	echo "  --debug      Compile with debug information."
	echo "  --local      Compile as if locally (outside Docker), using the local API files."
	echo "  --version    Print the current version of the API."
	echo "   -v          Verbose output."
	echo "  --           Separate options from input files."
	exit 1
}

locally=false
verbose=false
current_version=5

while [[ "$#" -gt 0 ]]; do
	case $1 in
		--api) cp -r /usr/api $1; exit ;;
		-o) shift; output="$1"; shift; break ;;
		--debug) shift ;;
		--local) locally=true; shift ;;
		--version) shift; echo "$current_version"; exit ;;
		-v) verbose=true; shift ;;
		--) shift; break ;;
		*) usage ;;
	esac
done

if [ -z "$output" ]; then
	usage
fi

if [ "$locally" = true ]; then
	cargo +nightly build --release # --color never
	cp target/riscv64gc-unknown-linux-gnu/release/rust_program $output
	exit
fi

# We are in /usr/src now, so what we need to do is copy the input files to the project directory
# The project is in /usr/project
cp $@ /usr/project/src/

# Build the project
cd /usr/project
cargo +nightly build --release # --color never

# Copy the resulting ELF file to the output
cp target/riscv64gc-unknown-linux-gnu/release/rust_program /usr/src/$output

# Remove the copied files?
# TODO: Remove the copied files somehow

```

`program/rust/docker/container_build.sh`:

```sh
docker build -t riscv64-rust .

```

`program/rust/docker/src/godot/api.rs`:

```rs
#![allow(dead_code)]
use core::arch::asm;
use core::arch::global_asm;
use core::ffi::c_void;
use crate::godot::variant;

pub struct Engine
{
}

impl Engine
{
	pub fn is_editor_hint() -> bool
	{
		let is_editor: i32;
		unsafe {
			asm!("ecall",
				in("a7") 512, // ECALL_IS_EDITOR
				lateout("a0") is_editor,
				options(nostack));
		}
		return is_editor != 0;
	}
}

#[repr(C)]
struct GuestFunctionExtra
{
	pub desc: *const u8,
	pub desc_len: usize,
	pub return_type: *const u8,
	pub return_type_len: usize,
	pub args: *const u8,
	pub args_len: usize,
}

fn register_public_api_c_func(name: &str, address: *mut c_void, return_type: &str, args: &str) {
	let description = "";
	let extra = GuestFunctionExtra {
		desc: description.as_ptr(),
		desc_len: description.len(),
		return_type: return_type.as_ptr(),
		return_type_len: return_type.len(),
		args: args.as_ptr(),
		args_len: args.len(),
	};
	unsafe {
		asm!("ecall",
			in("a7") 547, // ECALL_SANDBOX_ADD
			in("a0") 1, // SANDBOX_PUBLIC_API
			in("a1") name.as_ptr(),
			in("a2") name.len(),
			in("a3") address,
			in("a4") &extra,
			options(nostack));
	}
}

// Register a public API function with a single argument
pub fn register_public_api_func0(name: &str, func: extern "C" fn() -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func1<T>(name: &str, func: extern "C" fn(T) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func2<T, U>(name: &str, func: extern "C" fn(T, U) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func3<T, U, V>(name: &str, func: extern "C" fn(T, U, V) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func4<T, U, V, W>(name: &str, func: extern "C" fn(T, U, V, W) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func5<T, U, V, W, X>(name: &str, func: extern "C" fn(T, U, V, W, X) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func6<T, U, V, W, X, Y>(name: &str, func: extern "C" fn(T, U, V, W, X, Y) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}
pub fn register_public_api_func7<T, U, V, W, X, Y, Z>(name: &str, func: extern "C" fn(T, U, V, W, X, Y, Z) -> variant::Variant, return_type: &str, args: &str) {
	register_public_api_c_func(name, func as *mut c_void, return_type, args);
}

// Godot Rust API version embedded in the binary
global_asm!(
	".pushsection .comment",
	".string \"Godot Rust API v5\"",
	".popsection",
);

```

`program/rust/docker/src/godot/array.rs`:

```rs
#![allow(dead_code)]
use core::arch::asm;
use crate::Variant;
use crate::VariantType;

#[repr(C)]
pub struct GodotArray {
	pub reference: i32
}

impl GodotArray {
	pub fn new() -> GodotArray {
		GodotArray {
			reference: i32::MIN
		}
	}

	pub fn create(array: &[Variant]) -> GodotArray {
		const ECALL_VREATE: i32 = 517;

		let mut var = Variant::new_nil();
		unsafe {
			asm!("ecall",
				in("a0") &mut var, // Result variant
				in("a1") VariantType::Array as i32, // Variant type
				in("a2") 1, // Array from pointer + length
				in("a3") array.as_ptr(),
				in("a4") array.len(),
				in("a7") ECALL_VREATE,
			);
		}
		GodotArray {
			reference: unsafe { var.u.i } as i32
		}
	}

	pub fn from_ref(var_ref: i32) -> GodotArray {
		GodotArray {
			reference: var_ref
		}
	}

	pub fn to_variant(&self) -> Variant {
		let mut v = Variant::new_nil();
		v.t = VariantType::Array;
		v.u.i = self.reference as i64;
		v
	}

	/* Godot Array API */
	pub fn len(&self) -> i64 {
		return self.call("size", &[]).to_integer();
	}

	pub fn empty(&self) -> bool {
		return self.len() == 0;
	}

	pub fn push_back(&self, var: &Variant) {
		// Use slice::from_ref to create a new Variant without copying
		self.call("push_back", std::slice::from_ref(var));
	}
	pub fn append(&self, var: &Variant) {
		self.push_back(var);
	}
	pub fn pop_back(&self) {
		self.call("pop_back", &[]);
	}

	pub fn clear(&self) {
		self.call("clear", &[]);
	}

	pub fn get(&self, idx: i32) -> Variant {
		const ECALL_ARRAY_AT: i32 = 522;
		let mut var = Variant::new_nil();
		unsafe {
			asm!("ecall",
				in("a0") self.reference,
				in("a1") idx,
				in("a2") &mut var,
				in("a7") ECALL_ARRAY_AT,
			);
		}
		var
	}
	pub fn set(&self, idx: i32, var: &Variant) {
		const ECALL_ARRAY_AT: i32 = 522;
		// Set: idx = -idx - 1 with signed overflow
		let set_idx = -(idx as i32) - 1;
		unsafe {
			asm!("ecall",
				in("a0") self.reference,
				in("a1") set_idx,
				in("a2") var,
				in("a7") ECALL_ARRAY_AT,
			);
		}
	}

	/* Make a method call on the string (as Variant) */
	pub fn call(&self, method: &str, args: &[Variant]) -> Variant {
		// Call the method using Variant::callp
		let var = Variant::from_ref(VariantType::Array, self.reference);
		var.call(method, &args)
	}
}

```

`program/rust/docker/src/godot/dictionary.rs`:

```rs
#![allow(dead_code)]
use core::arch::asm;
use crate::Variant;
use crate::VariantType;

#[repr(C)]
pub struct GodotDictionary {
	pub reference: i32
}

impl GodotDictionary {
	pub fn new() -> GodotDictionary {
		let mut var = Variant::new_nil();
		unsafe {
			asm!("ecall",
				in("a0") &mut var,
				in("a1") VariantType::Dictionary as i32,
				in("a2") 0,   // method
				in("a7") 517, // ECALL_VCREATE
			);
		}
		GodotDictionary {
			reference: unsafe { var.u.i } as i32
		}
	}

	pub fn from_ref(var_ref: i32) -> GodotDictionary {
		GodotDictionary {
			reference: var_ref
		}
	}

	pub fn to_variant(&self) -> Variant {
		let mut v = Variant::new_nil();
		v.t = VariantType::Array;
		v.u.i = self.reference as i64;
		v
	}

	/* Godot Dictionary API */
	pub fn size(&self) -> i64 {
		return self.call("size", &[]).to_integer();
	}

	pub fn empty(&self) -> bool {
		return self.size() == 0;
	}

	pub fn clear(&self) {
		self.call("clear", &[]);
	}

	pub fn get(&self, key: &Variant) -> Variant {
		const ECALL_DICTIONARY_OPS: i32 = 524;
		let mut var = Variant::new_nil();
		unsafe {
			asm!("ecall",
				in("a0") 0, // OP_GET
				in("a1") self.reference,
				in("a2") key,
				in("a3") &mut var,
				in("a7") ECALL_DICTIONARY_OPS,
			);
		}
		var
	}
	pub fn set(&self, key: &Variant, value: &Variant) {
		const ECALL_DICTIONARY_OPS: i32 = 524;
		unsafe {
			asm!("ecall",
				in("a0") 1, // OP_SET
				in("a1") self.reference,
				in("a2") key,
				in("a3") value,
				in("a7") ECALL_DICTIONARY_OPS,
			);
		}
	}

	/* Make a method call on the string (as Variant) */
	pub fn call(&self, method: &str, args: &[Variant]) -> Variant {
		// Call the method using Variant::callp
		let var = Variant::from_ref(VariantType::Array, self.reference);
		var.call(method, &args)
	}
}

```

`program/rust/docker/src/godot/mod.rs`:

```rs
pub mod api;
pub mod variant;
pub mod node;
pub mod array;
pub mod dictionary;
pub mod string;
pub mod sysalloc;
pub mod syscalls;

```

`program/rust/docker/src/godot/node.rs`:

```rs
#![allow(dead_code)]
use core::arch::asm;
use core::ffi::c_char;
use crate::godot::variant::Variant;

pub struct Node
{
	address: usize,
}

impl Node
{
	pub fn new(address: usize) -> Node
	{
		Node
		{
			address: address,
		}
	}

	pub fn new_from_path(path: &str) -> Node
	{
		let address = godot_node_get(0, path.as_ptr(), path.len());
		Node::new(address)
	}

	pub fn get_address(&self) -> usize
	{
		self.address
	}

	pub fn get_node(&self, path: &str) -> Node
	{
		let node_address = godot_node_get(self.address, path.as_ptr(), path.len());
		Node::new(node_address)
	}

	pub fn call(&self, method: &str, args: &[Variant]) -> Variant
	{
		let address = self.address;
		return godot_method_call(address, method.as_ptr(), method.len(), args.as_ptr(), args.len());
	}
}

fn godot_node_get(parent_address: usize, path: *const c_char, size: usize) -> usize
{
	const SYSCALL_NODE_GET: i32 = 507;
	let new_address: usize;
	unsafe {
		asm!("ecall",
			in("a0") parent_address,
			in("a1") path,
			in("a2") size,
			in("a7") SYSCALL_NODE_GET,
			lateout("a0") new_address,
			options(nostack));
	}
	return new_address;
}

fn godot_method_call(address: usize, method: *const c_char, msize: usize, args: *const Variant, num_args: usize) -> Variant
{
	const SYSCALL_OBJ_CALLP: i32 = 506;
	// sys_obj_callp(address: usize, method: *const c_char, size: usize, deferred: bool, result: *Variant, args: *const Variant, num_args: usize) -> Variant;
	let mut result: Variant = Variant::new_nil();
	let res_ptr = &mut result as *mut Variant;
	unsafe {
		asm!("ecall",
			in("a0") address,
			in("a1") method,
			in("a2") msize,
			in("a3") 0,
			in("a4") res_ptr,
			in("a5") args,
			in("a6") num_args,
			in("a7") SYSCALL_OBJ_CALLP,
			options(nostack));
		return result;
	}
}

/* Get the current node (owner of the Sandbox) */
pub fn get_node() -> Node
{
	Node::new_from_path(".")
}

/* Get a node relative to the current node (owner of the Sandbox) */
pub fn get_node_from_path(path: &str) -> Node
{
	Node::new_from_path(path)
}

```

`program/rust/docker/src/godot/string.rs`:

```rs
#![allow(dead_code)]
use super::syscalls::*;
use crate::Variant;
use crate::VariantType;

#[repr(C)]
pub struct GodotString {
	pub reference: i32
}

impl GodotString {
	pub fn new() -> GodotString {
		GodotString {
			reference: i32::MIN
		}
	}

	pub fn create(s: &str) -> GodotString {
		let mut godot_string = GodotString::new();
		godot_string.reference = godot_string_create(s);
		godot_string
	}

	pub fn from_ref(var_ref: i32) -> GodotString {
		GodotString {
			reference: var_ref
		}
	}

	pub fn to_string(&self) -> String {
		godot_string_to_string(self.reference)
	}

	pub fn to_variant(&self) -> Variant {
		let mut v = Variant::new_nil();
		v.t = VariantType::String;
		v.u.i = self.reference as i64;
		v
	}

	/* Godot String API */
	pub fn length(&self) -> i64 {
		return self.call("length", &[]).to_integer();
	}

	/* Make a method call on the string (as Variant) */
	pub fn call(&self, method: &str, args: &[Variant]) -> Variant {
		// Call the method using Variant::callp
		let var = Variant::from_ref(VariantType::String, self.reference);
		var.call(method, &args)
	}
}

```

`program/rust/docker/src/godot/sysalloc.rs`:

```rs
extern crate alloc;
use alloc::alloc::Layout;
use alloc::alloc::GlobalAlloc;
use std::arch::asm;
const NATIVE_SYSCALLS_BASE: i32 = 480;

struct SysAllocator;

/** Native-performance host-side implementations of common heap functions */

unsafe impl GlobalAlloc for SysAllocator {
    #[inline]
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let ret: *mut u8;
        asm!("ecall", in("a7") NATIVE_SYSCALLS_BASE + 0,
            in("a0") layout.size(), in("a1") layout.align(),
            lateout("a0") ret);
        return ret;
    }
    #[inline]
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        let ret: *mut u8;
        asm!("ecall", in("a7") NATIVE_SYSCALLS_BASE + 1,
            in("a0") layout.size(), in("a1") 1, lateout("a0") ret);
        return ret;
    }
    #[inline]
    unsafe fn realloc(&self, ptr: *mut u8, _layout: Layout, new_size: usize) -> *mut u8 {
        let ret: *mut u8;
        asm!("ecall", in("a7") NATIVE_SYSCALLS_BASE + 2,
            in("a0") ptr, in("a1") new_size, lateout("a0") ret);
        return ret;
    }
    #[inline]
    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {
        asm!("ecall", in("a7") NATIVE_SYSCALLS_BASE + 3,
            in("a0") ptr, lateout("a0") _);
    }
}

#[global_allocator]
static A: SysAllocator = SysAllocator;

/** Native-performance host-side implementations of common memory functions */

#[no_mangle]
pub fn __wrap_memcpy(dest: *mut u8, src: *const u8, n: usize) -> *mut u8
{
	unsafe {
		asm!("ecall",
			in("a0") dest,
			in("a1") src,
			in("a2") n,
			in("a7") 485+0,
			options(nostack)
		);
	}
	return dest;
}

#[no_mangle]
pub fn __wrap_memset(s: *mut u8, c: i32, n: usize) -> *mut u8
{
	unsafe {
		asm!("ecall",
			in("a0") s,
			in("a1") c,
			in("a2") n,
			in("a7") 485+1,
			options(nostack)
		);
	}
	return s;
}

#[no_mangle]
pub fn __wrap_memmove(dest: *mut u8, src: *const u8, n: usize) -> *mut u8
{
	unsafe {
		asm!("ecall",
			in("a0") dest,
			in("a1") src,
			in("a2") n,
			in("a7") 485+2,
			options(nostack)
		);
	}
	return dest;
}

#[no_mangle]
pub fn __wrap_memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32
{
	let result: i32;
	unsafe {
		asm!("ecall",
			in("a0") s1,
			in("a1") s2,
			in("a2") n,
			in("a7") 485+3,
			lateout("a0") result,
			options(nostack, readonly)
		);
	}
	return result;
}

#[no_mangle]
pub fn __wrap_strlen(s: *const u8) -> usize
{
	let result: usize;
	unsafe {
		asm!("ecall",
			in("a0") s,
			in("a7") 490,
			lateout("a0") result,
			options(nostack, readonly)
		);
	}
	return result;
}

#[no_mangle]
pub fn __wrap_strcmp(s1: *const u8, s2: *const u8) -> i32
{
	let result: i32;
	unsafe {
		asm!("ecall",
			in("a0") s1,
			in("a1") s2,
			in("a2") 4096, // MAX_STRLEN
			in("a7") 491,
			lateout("a0") result,
			options(nostack, readonly)
		);
	}
	return result;
}

#[no_mangle]
pub fn __wrap_strncmp(s1: *const u8, s2: *const u8, n: usize) -> i32
{
	let result: i32;
	unsafe {
		asm!("ecall",
			in("a0") s1,
			in("a1") s2,
			in("a2") n,
			in("a7") 491,
			lateout("a0") result,
			options(nostack, readonly)
		);
	}
	return result;
}

#[no_mangle]
pub fn fast_exit() -> ! {
	unsafe {
		asm!("ecall",
			in("a7") 93,
			options(noreturn)
		);
	}
}

```

`program/rust/docker/src/godot/syscalls.rs`:

```rs
#![allow(dead_code)]
use core::arch::asm;
const ECALL_STRING_CREATE: u32 = 525;
const ECALL_STRING_OPS: u32 = 526;
const STRING_OP_TO_STD_STRING: u32 = 7;
const STD_STRING_SSO_SIZE: usize = 16;

#[repr(C)]
pub(self) union CapacityOrSSO {
	pub cap: usize,
	pub sso: [u8; STD_STRING_SSO_SIZE],
}

#[repr(C)]
pub struct GuestStdString {
	// 64-bit pointer + 64-bit length + 64-bit capacity OR 16-byte SSO data
	pub ptr: *const char,
	pub len: usize,
	pub(self) cap_or_sso: CapacityOrSSO,
}

impl GuestStdString
{
	pub fn new(s: &str) -> GuestStdString
	{
		if s.len() <= STD_STRING_SSO_SIZE {
			let mut sso = [0; STD_STRING_SSO_SIZE];
			for i in 0..s.len() {
				sso[i] = s.as_bytes()[i];
			}
			let v = GuestStdString { ptr: s.as_ptr() as *const char, len: s.len(), cap_or_sso: CapacityOrSSO { sso: sso } };
			return v;
		}

		let v = GuestStdString { ptr: s.as_ptr() as *const char, len: s.len(), cap_or_sso: CapacityOrSSO { cap: s.len() } };
		v
	}

	pub fn new_empty() -> GuestStdString
	{
		let v = GuestStdString { ptr: std::ptr::null(), len: 0, cap_or_sso: CapacityOrSSO { cap: 0 } };
		return v;
	}

	pub fn as_str(&self) -> &str
	{
		unsafe {
			let s = std::str::from_utf8_unchecked(std::slice::from_raw_parts(self.ptr as *const u8, self.len));
			return s;
		}
	}

	pub fn as_string(&self) -> String
	{
		unsafe {
			if self.len <= STD_STRING_SSO_SIZE {
				// We want to copy self.ptr, self.len into a new String
				return std::string::String::from_utf8_unchecked(self.as_str().as_bytes().to_vec());
			}
			let s = std::string::String::from_raw_parts(self.ptr as *mut u8, self.len, self.len);
			return s;
		}
	}
}

// Create a new GodotString and return the i32 reference
// MAKE_SYSCALL(ECALL_STRING_CREATE, unsigned, sys_string_create, const char *, size_t);
pub fn godot_string_create(string: &str) -> i32 {
	unsafe {
		let mut gs_ref;
		asm!("ecall",
			in("a7") ECALL_STRING_CREATE,
			in("a0") string.as_ptr(),
			in("a1") string.len(),
			lateout("a0") gs_ref,
		);
		gs_ref
	}
}

pub fn godot_string_to_string(gs: i32) -> String {
	let mut std_string = GuestStdString::new_empty();
	unsafe {
		asm!("ecall",
			in("a7") ECALL_STRING_OPS,
			in("a0") STRING_OP_TO_STD_STRING,
			in("a1") gs,
			in("a2") 0,  // utf-8
			inout("a3") &mut std_string => _, // std::string
			lateout("a0") _,
		);
	}
	std_string.as_string()
}

```

`program/rust/docker/src/godot/variant.rs`:

```rs
#![allow(dead_code)]
use core::arch::asm;
use std::fmt;
use super::string::*;

#[repr(C)]
pub enum VariantType {
	Nil,
	Bool,
	Integer,
	Float,
	String,

	Vector2,
	Vector2i,
	Rect2,
	Rect2i,
	Vector3,
	Vector3i,
	Transform2D,
	Vector4,
	Vector4i,
	Plane,
	Quaterion,
	AABB,
	Basis,
	Transform3D,
	Projection,

	Color,
	StringName,
	NodePath,
	RID,
	Object,
	Callable,
	Signal,
	Dictionary,
	Array,

	// Packed arrays
	PackedByteArray,
	PackedInt32Array,
	PackedInt64Array,
	PackedFloat32Array,
	PackedFloat64Array,
	PackedStringArray,
	PackedVector2Array,
	PackedVector3Array,
	PackedColorArray,
	PackedVector4Array,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Vector2 {
	pub x: f32,
	pub y: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Vector2i {
	pub x: i32,
	pub y: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Vector3 {
	pub x: f32,
	pub y: f32,
	pub z: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Vector3i {
	pub x: i32,
	pub y: i32,
	pub z: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Rect2 {
	pub position: Vector2,
	pub size: Vector2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Rect2i {
	pub position: Vector2i,
	pub size: Vector2i,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Vector4 {
	pub x: f32,
	pub y: f32,
	pub z: f32,
	pub w: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Vector4i {
	pub x: i32,
	pub y: i32,
	pub z: i32,
	pub w: i32,
}

#[repr(C)]
pub union VariantUnion {
	pub b: bool,
	pub i: i64,
	pub f: f64,
	pub v2: Vector2,
	pub v2i: Vector2i,
	pub v3: Vector3,
	pub v3i: Vector3i,
	pub r2: Rect2,
	pub r2i: Rect2i,
	pub v4: Vector4,
	pub v4i: Vector4i,
}

#[repr(C)]
pub struct Variant
{
	pub t : VariantType,
	pub u : VariantUnion,
}

impl Variant
{
	pub fn new_nil() -> Variant
	{
		let v = Variant { t: VariantType::Nil, u: VariantUnion { b: false } };
		return v;
	}

	pub fn new_bool(b: bool) -> Variant
	{
		let v = Variant { t: VariantType::Bool, u: VariantUnion { b: b } };
		return v;
	}
	pub fn new_integer(i: i64) -> Variant
	{
		let v = Variant { t: VariantType::Integer, u: VariantUnion { i: i } };
		return v;
	}
	pub fn new_float(f: f64) -> Variant
	{
		let v = Variant { t: VariantType::Float, u: VariantUnion { f: f } };
		return v;
	}
	pub fn new_vec2(v: Vector2) -> Variant
	{
		let res = Variant { t: VariantType::Vector2, u: VariantUnion { v2: v } };
		return res;
	}
	pub fn new_vec2i(v: Vector2i) -> Variant
	{
		let res = Variant { t: VariantType::Vector2i, u: VariantUnion { v2i: v } };
		return res;
	}
	pub fn new_vec3(v: Vector3) -> Variant
	{
		let res = Variant { t: VariantType::Vector3, u: VariantUnion { v3: v } };
		return res;
	}
	pub fn new_vec3i(v: Vector3i) -> Variant
	{
		let res = Variant { t: VariantType::Vector3i, u: VariantUnion { v3i: v } };
		return res;
	}
	pub fn new_rect2(r: Rect2) -> Variant
	{
		let res = Variant { t: VariantType::Rect2, u: VariantUnion { r2: r } };
		return res;
	}
	pub fn new_rect2i(r: Rect2i) -> Variant
	{
		let res = Variant { t: VariantType::Rect2i, u: VariantUnion { r2i: r } };
		return res;
	}
	pub fn new_vec4(v: Vector4) -> Variant
	{
		let res = Variant { t: VariantType::Vector4, u: VariantUnion { v4: v } };
		return res;
	}
	pub fn new_vec4i(v: Vector4i) -> Variant
	{
		let res = Variant { t: VariantType::Vector4i, u: VariantUnion { v4i: v } };
		return res;
	}
	pub fn new_string(s: &str) -> Variant
	{
		let v = Variant::internal_create_string(VariantType::String, s);
		return v;
	}
	pub fn from_ref(t: VariantType, r: i32) -> Variant
	{
		let v = Variant { t: t, u: VariantUnion { i: r.into() } };
		return v;
	}

	pub fn to_bool(&self) -> bool
	{
		match self.t {
			VariantType::Bool => {
				let b = unsafe { self.u.b };
				return b
			},
			_ => panic!("Variant is not a bool"),
		}
	}

	pub fn to_integer(&self) -> i64
	{
		match self.t {
			VariantType::Integer => {
				let i = unsafe { self.u.i };
				return i
			},
			_ => panic!("Variant is not an integer"),
		}
	}

	pub fn to_float(&self) -> f64
	{
		match self.t {
			VariantType::Float => {
				let f = unsafe { self.u.f };
				return f
			},
			_ => panic!("Variant is not a float"),
		}
	}

	pub fn to_vec2(&self) -> Vector2
	{
		match self.t {
			VariantType::Vector2 => {
				let v2 = unsafe { self.u.v2 };
				return v2
			},
			_ => panic!("Variant is not a Vector2"),
		}
	}

	pub fn to_vec2i(&self) -> Vector2i
	{
		match self.t {
			VariantType::Vector2i => {
				let v2i = unsafe { self.u.v2i };
				return v2i
			},
			_ => panic!("Variant is not a Vector2i"),
		}
	}

	pub fn to_vec3(&self) -> Vector3
	{
		match self.t {
			VariantType::Vector3 => {
				let v3 = unsafe { self.u.v3 };
				return v3
			},
			_ => panic!("Variant is not a Vector3"),
		}
	}

	pub fn to_vec3i(&self) -> Vector3i
	{
		match self.t {
			VariantType::Vector3i => {
				let v3i = unsafe { self.u.v3i };
				return v3i
			},
			_ => panic!("Variant is not a Vector3i"),
		}
	}

	pub fn to_rect2(&self) -> Rect2
	{
		match self.t {
			VariantType::Rect2 => {
				let r2 = unsafe { self.u.r2 };
				return r2
			},
			_ => panic!("Variant is not a Rect2"),
		}
	}

	pub fn to_rect2i(&self) -> Rect2i
	{
		match self.t {
			VariantType::Rect2i => {
				let r2i = unsafe { self.u.r2i };
				return r2i
			},
			_ => panic!("Variant is not a Rect2i"),
		}
	}

	pub fn to_vec4(&self) -> Vector4
	{
		match self.t {
			VariantType::Vector4 => {
				let v4 = unsafe { self.u.v4 };
				return v4
			},
			_ => panic!("Variant is not a Vector4"),
		}
	}

	pub fn to_vec4i(&self) -> Vector4i
	{
		match self.t {
			VariantType::Vector4i => {
				let v4i = unsafe { self.u.v4i };
				return v4i
			},
			_ => panic!("Variant is not a Vector4i"),
		}
	}

	pub fn to_string(&self) -> String
	{
		match self.t {
			VariantType::String => {
				let gs = GodotString::from_ref(unsafe { self.u.i } as i32);
				gs.to_string()
			},
			VariantType::StringName => {
				let gs = GodotString::from_ref(unsafe { self.u.i } as i32);
				gs.to_string()
			},
			VariantType::NodePath => {
				let gs = GodotString::from_ref(unsafe { self.u.i } as i32);
				gs.to_string()
			},
			_ => panic!("Variant is not a String"),
		}
	}

	pub fn internal_create_string(t: VariantType, s: &str) -> Variant
	{
		let gs = GodotString::create(s);
		let mut v = Variant::new_nil();
		v.t = t;
		v.u.i = gs.reference as i64;
		return v;
	}

	pub fn call(&self, method: &str, args: &[Variant]) -> Variant
	{
		const SYSCALL_VCALL: i64 = 501;
		let mut res = Variant::new_nil();
		unsafe {
			asm!("ecall",
				in("a0") self,
				in("a1") method.as_ptr(),
				in("a2") method.len(),
				in("a3") args.as_ptr(),
				in("a4") args.len(),
				in("a5") &mut res,
				in("a7") SYSCALL_VCALL,
				options(nostack));
		}
		return res;
	}
}

impl Vector2
{
	pub fn new(x: f32, y: f32) -> Vector2
	{
		Vector2 { x: x, y: y }
	}
}

impl Vector2i
{
	pub fn new(x: i32, y: i32) -> Vector2i
	{
		Vector2i { x: x, y: y }
	}
}

impl Vector3
{
	pub fn new(x: f32, y: f32, z: f32) -> Vector3
	{
		Vector3 { x: x, y: y, z: z }
	}
}

impl Vector3i
{
	pub fn new(x: i32, y: i32, z: i32) -> Vector3i
	{
		Vector3i { x: x, y: y, z: z }
	}
}

impl Rect2
{
	pub fn new(position: Vector2, size: Vector2) -> Rect2
	{
		Rect2 { position: position, size: size }
	}
}

impl Rect2i
{
	pub fn new(position: Vector2i, size: Vector2i) -> Rect2i
	{
		Rect2i { position: position, size: size }
	}
}

impl Vector4
{
	pub fn new(x: f32, y: f32, z: f32, w: f32) -> Vector4
	{
		Vector4 { x: x, y: y, z: z, w: w }
	}
}

impl Vector4i
{
	pub fn new(x: i32, y: i32, z: i32, w: i32) -> Vector4i
	{
		Vector4i { x: x, y: y, z: z, w: w }
	}
}

impl fmt::Display for Variant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self.t {
			VariantType::Bool => {
        		write!(f, "{}", self.to_bool())
			},
			VariantType::Integer => {
				write!(f, "{}", self.to_integer())
			},
			VariantType::Float => {
				write!(f, "{}", self.to_float())
			},
			VariantType::Vector2 => {
				let v = self.to_vec2();
				write!(f, "({}, {})", v.x, v.y)
			},
			VariantType::Vector2i => {
				let v = self.to_vec2i();
				write!(f, "({}, {})", v.x, v.y)
			},
			VariantType::Vector3 => {
				let v = self.to_vec3();
				write!(f, "({}, {}, {})", v.x, v.y, v.z)
			},
			VariantType::Vector3i => {
				let v = self.to_vec3i();
				write!(f, "({}, {}, {})", v.x, v.y, v.z)
			},
			VariantType::Rect2 => {
				let r = self.to_rect2();
				write!(f, "({}, {},  {} {})", r.position.x, r.position.y, r.size.x, r.size.y)
			},
			VariantType::Rect2i => {
				let r = self.to_rect2i();
				write!(f, "({}, {},  {} {})", r.position.x, r.position.y, r.size.x, r.size.y)
			},
			VariantType::Vector4 => {
				let v = self.to_vec4();
				write!(f, "({}, {}, {}, {})", v.x, v.y, v.z, v.w)
			},
			VariantType::Vector4i => {
				let v = self.to_vec4i();
				write!(f, "({}, {}, {}, {})", v.x, v.y, v.z, v.w)
			},
			VariantType::String => {
				write!(f, "{}", self.to_string())
			},
			_ => {
				write!(f, "Unknown")
			},
		} // match
    } // fn
} // impl

const SYSCALL_PRINT: i64 = 500;
const SYSCALL_THROW: i64 = 511;

// The print system call takes a pointer to an array of Variant structs in A0,
// as well as the number of elements in the array in A1.
pub fn print1(v: &Variant)
{
	unsafe {
		asm!("ecall",
			in("a0") v,
			in("a1") 1,
			in("a7") SYSCALL_PRINT,
			lateout("a0") _,
			options(nostack));
	}
}
pub fn print(v: &[Variant])
{
	unsafe {
		asm!("ecall",
			in("a0") v.as_ptr(),
			in("a1") v.len(),
			in("a7") SYSCALL_PRINT,
			lateout("a0") _,
			options(nostack));
	}
}

```

`program/rust/docker/start.sh`:

```sh
PROJECT_PATH=${1:-.}
pushd $PROJECT_PATH
docker run --name godot-rust-compiler -dv .:/usr/src riscv64-rust
popd

```

`program/rust/docker/stop_and_remove.sh`:

```sh
# Ignore the error if the container is not running
docker stop -t1 godot-rust-compiler || true
docker rm godot-rust-compiler || true

```

`program/rust/project/Cargo.toml`:

```toml
[package]
name = "rust_program"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

`program/rust/project/build.sh`:

```sh
#!/bin/bash
set -e

usage() {
	echo "Usage: $0 [--api] [-o output] -- [input...]"
	echo "  --api        Instead of compiling, copy the API files to the output."
	echo "   -o output   Compile sources into an output ELF file, including API and inputs."
	echo "  --debug      Compile with debug information."
	echo "  --version    Print the current version of the API."
	echo "   -v          Verbose output."
	echo "  --           Separate options from input files."
	exit 1
}

verbose=false
current_version=5
output="rust.elf"

while [[ "$#" -gt 0 ]]; do
	case $1 in
		--api) cp -r /usr/api $1; exit ;;
		-o) shift; output="$1"; shift; break ;;
		--debug) shift ;;
		--version) shift; echo "$current_version"; exit ;;
		-v) verbose=true; shift ;;
		--) shift; break ;;
		*) usage ;;
	esac
done

cargo +nightly build --release # --color never
cp target/riscv64gc-unknown-linux-gnu/release/rust_program $output

```

`program/rust/project/src/main.rs`:

```rs
mod godot;
use godot::api::*;
use godot::node::*;
use godot::string::*;
use godot::variant::*;

const SPEED: f32 = 50.0;

extern "C"
fn _physics_process(delta: f64) -> Variant {
	if Engine::is_editor_hint() {
		return Variant::new_nil();
	}

	let slime = get_node();
	let sprite = get_node_from_path("AnimatedSprite2D");

	let flip_h = sprite.call("is_flipped_h", &[]);
	let direction: f32 = (flip_h.to_bool() as i32 as f32 - 0.5) * -2.0;

	let mut pos = slime.call("get_position", &[]).to_vec2();
	pos.x += direction * SPEED * delta as f32;

	slime.call("set_position", &[Variant::new_vec2(pos)]);

	let ray_right = get_node_from_path("raycast_right");
	let ray_left  = get_node_from_path("raycast_left");
	if direction > 0.0 && ray_right.call("is_colliding", &[]).to_bool() {
		sprite.call("set_flip_h", &[Variant::new_bool(true)]);
	}
	else if direction < 0.0 && ray_left.call("is_colliding", &[]).to_bool() {
		sprite.call("set_flip_h", &[Variant::new_bool(false)]);
	}

	Variant::new_nil()
}

extern "C"
fn test(val1: i32, val2: i32, val3: GodotString) -> Variant {
	let sum = val1 + val2 + val3.to_string().parse::<i32>().unwrap();
	Variant::new_integer(sum.into())
}

pub fn main() {
	let v = Variant::new_string("Hello, Rust World!");
	println!("{}", v.to_string());

	register_public_api_func1("_physics_process", _physics_process, "Variant", "f64");
	register_public_api_func3("test", test, "int", "int a, int b, String c");
}

```

`program/zig/docker/Dockerfile`:

```
FROM ubuntu:24.04

RUN apt-get -qq update && \
	apt-get install -y -q \
	curl xz-utils lld

# Install Zig
# https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz
RUN curl -L https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz -o zig.tar.xz
# zig-linux-x86_64-0.13.0
RUN tar -xf zig.tar.xz && rm zig.tar.xz && mv zig-linux-x86_64-0.13.0 /usr/zig

# TODO: API in /usr/api

WORKDIR /usr/src
# Copy API files
RUN mkdir -p /usr/api
COPY build.sh api/* /usr/api/

# Make the container a background process
CMD ["/bin/bash", "-c", "tail -f /dev/null"]

```

`program/zig/docker/api/api.zig`:

```zig
//
// Godot Sandbox Zig API
//
pub const V = union { b: bool, i: i64, f: f64, obj: u64, bytes: [16]u8 };
pub extern fn sys_vcall(self: *Variant, method: [*]const u8, method_len: usize, args: [*]Variant, args_len: usize, result: *Variant) void;

pub const Variant = struct {
    type: i64,
    v: V,

    pub fn nil() Variant {
        return Variant{ .type = 0, .v = V{ .b = false } };
    }

    pub fn init_bool(self: *Variant, b: bool) void {
        self.type = 1; // BOOL
        self.v.b = b;
    }

    pub fn init_int(self: *Variant, int: i64) void {
        self.type = 2; // INT
        self.v.i = int;
    }

    pub fn init_float(self: *Variant, f: f64) void {
        self.type = 3; // FLOAT
        self.v.f = f;
    }

    pub fn init_object(self: *Variant, obj: u64) void {
        self.type = 4; // OBJECT
        self.v.obj = obj;
    }

    pub fn call(self: *Variant, method: []const u8, args: []Variant) Variant {
        var result: Variant = undefined;
        sys_vcall(self, method.ptr, method.len, args.ptr, args.len, &result);
        return result;
    }
};

comptime {
    asm (
        \\.global sys_vcall;
        \\.type sys_vcall, @function;
        \\sys_vcall:
        \\  li a7, 501
        \\  ecall
        \\  ret
        \\.global fast_exit;
        \\.type fast_exit, @function;
        \\fast_exit:
        \\  .insn i SYSTEM, 0, x0, x0, 0x7ff
        \\.pushsection .comment
        \\.string "Godot Zig API v1"
        \\.popsection
    );
}

```

`program/zig/docker/build.sh`:

```sh
#!/bin/bash
set -e

usage() {
	echo "Usage: $0 [--api] [-o output] -- [input...]"
	echo "  --api        Instead of compiling, copy the API files to the output."
	echo "   -o output   Compile sources into an output ELF file, including API and inputs."
	echo "  --debug      Compile with debug information."
	echo "  --local      Compile as if locally (outside Docker), using the local API files."
	echo "  --version    Print the current version of the API."
	echo "   -v          Verbose output."
	echo "  --           Separate options from input files."
	exit 1
}

locally=false
verbose=false
current_version=1

while [[ "$#" -gt 0 ]]; do
	case $1 in
		--api) cp -r /usr/api $1; exit ;;
		-o) shift; output="$1"; shift; break ;;
		--debug) shift ;;
		--local) locally=true; shift ;;
		--version) shift; echo "$current_version"; exit ;;
		-v) verbose=true; shift ;;
		--) shift; break ;;
		*) usage ;;
	esac
done

if [ -z "$output" ]; then
	usage
fi

DIR="$(dirname "${output}")"
FILE="$(basename "${output}")"

cleanup() {
	rm -rf /usr/project
}

trap cleanup EXIT

mkdir -p /usr/project/api
cp $@ /usr/project
# Copy the API files to the project directory
cp /usr/api/*.zig /usr/project/api

cd /usr/project
/usr/zig/zig build-exe -O ReleaseSmall -fno-strip -flld -target riscv64-linux *.zig --name $FILE
# Move the output file to the correct location
mv $FILE /usr/src/$output

```

`program/zig/docker/container_build.sh`:

```sh
docker build -t riscv64-zig .

```

`program/zig/docker/start.sh`:

```sh
docker run --name godot-zig-compiler -dv .:/usr/src riscv64-zig

```

`program/zig/docker/stop_and_remove.sh`:

```sh
docker stop -t1 godot-zig-compiler
docker rm godot-zig-compiler

```

`register_types.cpp`:

```cpp
#include "register_types.h"
#include "core/extension/gdextension_interface.h"
#include "core/extension/gdextension_loader.h"
#include "core/extension/gdextension_manager.h"
#include "core/io/config_file.h"
#include "core/object/object.h"
#include "core/object/ref_counted.h"
#include "core/os/shared_object.h"
#include <functional>

class GDExtensionStaticLibraryLoader : public GDExtensionLoader {
	friend class GDExtensionManager;
	friend class GDExtension;

private:
  void *entry_funcptr = nullptr;
  String library_path;

public:
	void set_entry_funcptr(void *p_entry_funcptr) {
		entry_funcptr = p_entry_funcptr;
	}
	virtual Error open_library(const String &p_path) override {
		library_path = p_path;
		return OK;
	}
	virtual Error initialize(GDExtensionInterfaceGetProcAddress p_get_proc_address,
			 const Ref<GDExtension> &p_extension,
			 GDExtensionInitialization *r_initialization) override {
	GDExtensionInitializationFunction initialization_function =
		(GDExtensionInitializationFunction)entry_funcptr;
	if (initialization_function == nullptr) {
	  ERR_PRINT("GDExtension initialization function '" + library_path +
				"' is null.");
	  return FAILED;
	}
	GDExtensionBool ret = initialization_function(
		p_get_proc_address, p_extension.ptr(), r_initialization);

	if (ret) {
	  return OK;
	} else {
	  ERR_PRINT("GDExtension initialization function '" + library_path +
				"' returned an error.");
	  return FAILED;
	}
  }
  virtual void close_library() override {}
  virtual bool is_library_open() const override { return true; }
  virtual bool has_library_changed() const override { return false; }
  virtual bool library_exists() const override { return true; }
};

extern "C" {
	GDExtensionBool riscv_library_init(
		GDExtensionInterfaceGetProcAddress p_get_proc_address,
		GDExtensionClassLibraryPtr p_library,
		GDExtensionInitialization *r_initialization
	);
}

void initialize_sandbox_module(ModuleInitializationLevel p_level) {
	if (p_level != MODULE_INITIALIZATION_LEVEL_SERVERS) {
		return;
	}

	Ref<GDExtensionStaticLibraryLoader> loader;
	loader.instantiate();
	loader->set_entry_funcptr((void*)&riscv_library_init);
	GDExtensionManager::get_singleton()->load_extension_with_loader("sandbox", loader);
}

void uninitialize_sandbox_module(ModuleInitializationLevel p_level) {
}

```

`register_types.h`:

```h
#ifndef SANDBOX_REGISTER_TYPES_H
#define SANDBOX_REGISTER_TYPES_H

#include "modules/register_module_types.h"

void initialize_sandbox_module(ModuleInitializationLevel p_level);
void uninitialize_sandbox_module(ModuleInitializationLevel p_level);

#endif // SANDBOX_REGISTER_TYPES_H

```

`scripts/clang-format.sh`:

```sh
#!/usr/bin/env bash
# This is based on Godot's clang-format.sh

# This script runs clang-format on all relevant files in the repo.
# This is the primary script responsible for fixing style violations.

set -uo pipefail

# Loop through all code files tracked by Git.
files=$(git ls-files -- '*.h' '*.cpp' ':!thirdparty')


if [ ! -z "$files" ]; then
    clang-format --Wno-error=unknown -i $files
fi

diff=$(git diff --color)

# If no diff has been generated all is OK, clean up, and exit.
if [ -z "$diff" ] ; then
    printf "\e[1;32m*** Files in this commit comply with the clang-format style rules.\e[0m\n"
    exit 0
fi

# A diff has been created, notify the user, clean up, and exit.
printf "\n\e[1;33m*** The following changes must be made to comply with the formatting rules:\e[0m\n\n"
# Perl commands replace trailing spaces with `Â·` and tabs with `<TAB>`.
printf "$diff\n" | perl -pe 's/(.*[^ ])( +)(\e\[m)$/my $spaces="Â·" x length($2); sprintf("$1$spaces$3")/ge' | perl -pe 's/(.*[^\t])(\t+)(\e\[m)$/my $tabs="<TAB>" x length($2); sprintf("$1$tabs$3")/ge'

printf "\n\e[1;91m*** Please fix your commit(s) with 'git commit --amend' or 'git rebase -i <hash>'\e[0m\n"
exit 1

```

`scripts/clang-tidy.sh`:

```sh
#!/usr/bin/env bash
# This is based on Godot's clang-tidy.sh

# This script runs clang-tidy on all relevant files in the repo.
# This is more thorough than clang-format and thus slower; it should only be run manually.

set -uo pipefail

# Loops through all code files tracked by Git.

git ls-files -- '*.h' '*.cpp' ':!thirdparty' |
while read -r f; do
    # Run clang-tidy.
    clang-tidy --quiet --fix "$f" &> /dev/null

    # Run clang-format. This also fixes the output of clang-tidy.
    clang-format --Wno-error=unknown -i "$f"
done

diff=$(git diff --color)

# If no diff has been generated all is OK, clean up, and exit.
if [ -z "$diff" ] ; then
    printf "\e[1;32m*** Files in this commit comply with the clang-tidy style rules.\e[0m\n"
    exit 0
fi

# A diff has been created, notify the user, clean up, and exit.
printf "\n\e[1;33m*** The following changes must be made to comply with the formatting rules:\e[0m\n\n"
# Perl commands replace trailing spaces with `Â·` and tabs with `<TAB>`.
printf "$diff\n" | perl -pe 's/(.*[^ ])( +)(\e\[m)$/my $spaces="Â·" x length($2); sprintf("$1$spaces$3")/ge' | perl -pe 's/(.*[^\t])(\t+)(\e\[m)$/my $tabs="<TAB>" x length($2); sprintf("$1$tabs$3")/ge'

printf "\n\e[1;91m*** Please fix your commit(s) with 'git commit --amend' or 'git rebase -i <hash>'\e[0m\n"
exit 1

```

`src/bintr/README.md`:

```md
# Binary translations

Files put into this folder are automatically embedded into the Godot Sandbox extension

```

`src/cpp/resource_loader_cpp.cpp`:

```cpp
#include "resource_loader_cpp.h"
#include "script_cpp.h"
#include <godot_cpp/classes/file_access.hpp>

static Ref<ResourceFormatLoaderCPP> cpp_loader;

void ResourceFormatLoaderCPP::init() {
	cpp_loader.instantiate();
	ResourceLoader::get_singleton()->add_resource_format_loader(cpp_loader);
}

void ResourceFormatLoaderCPP::deinit() {
	ResourceLoader::get_singleton()->remove_resource_format_loader(cpp_loader);
	cpp_loader.unref();
}

Variant ResourceFormatLoaderCPP::_load(const String &p_path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const {
	Ref<CPPScript> cpp_model = memnew(CPPScript);
	cpp_model->set_file(p_path);
	return cpp_model;
}
PackedStringArray ResourceFormatLoaderCPP::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("cpp");
	array.push_back("cc");
	array.push_back("hh");
	array.push_back("h");
	array.push_back("hpp");
	return array;
}
bool ResourceFormatLoaderCPP::_handles_type(const StringName &type) const {
	String type_str = type;
	return type_str == "CPPScript" || type_str == "Script";
}
String ResourceFormatLoaderCPP::_get_resource_type(const String &p_path) const {
	String el = p_path.get_extension().to_lower();
	if (el == "hpp" || el == "cpp" || el == "h" || el == "cc" || el == "hh") {
		return "CPPScript";
	}
	return "";
}

```

`src/cpp/resource_loader_cpp.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_loader.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

using namespace godot;

class ResourceFormatLoaderCPP : public ResourceFormatLoader {
	GDCLASS(ResourceFormatLoaderCPP, ResourceFormatLoader);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Variant _load(const String &path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual bool _handles_type(const StringName &type) const override;
	virtual String _get_resource_type(const String &p_path) const override;
};

```

`src/cpp/resource_saver_cpp.cpp`:

```cpp
#include "resource_saver_cpp.h"
#include "../elf/script_elf.h"
#include "../elf/script_language_elf.h"
#include "../register_types.h"
#include "../sandbox.h"
#include "../sandbox_project_settings.h"
#include "script_cpp.h"
#include <libriscv/util/threadpool.h>
#include <godot_cpp/classes/dir_access.hpp>
#include <godot_cpp/classes/editor_file_system.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/editor_settings.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/os.hpp>
#include <godot_cpp/classes/project_settings.hpp>
#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_editor.hpp>
#include <godot_cpp/classes/script_editor_base.hpp>
#include <godot_cpp/variant/utility_functions.hpp>

static Ref<ResourceFormatSaverCPP> cpp_saver;
static std::unique_ptr<riscv::ThreadPool> thread_pool;
static constexpr bool VERBOSE_CMD = false;

static const char cmake_toolchain_bytes[] = R"(
if (NOT DEFINED ZIG_PATH)
	set(ZIG_PATH "zig")
endif()
set(CMAKE_SYSTEM_NAME "Linux")
set(CMAKE_SYSTEM_VERSION 1)
set(CMAKE_SYSTEM_PROCESSOR "riscv64")
set(CMAKE_CROSSCOMPILING TRUE)
set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)
set(CMAKE_C_COMPILER "${ZIG_PATH}" cc -target riscv64-linux-musl)
set(CMAKE_CXX_COMPILER "${ZIG_PATH}" c++ -target riscv64-linux-musl)

if (CMAKE_HOST_WIN32)
	# Windows: Disable .d files
	set(CMAKE_C_LINKER_DEPFILE_SUPPORTED FALSE)
	set(CMAKE_CXX_LINKER_DEPFILE_SUPPORTED FALSE)
	# Windows: Work-around for zig ar and zig ranlib
	set(CMAKE_AR "${CMAKE_CURRENT_LIST_DIR}/zig-ar.cmd")
	set(CMAKE_RANLIB "${CMAKE_CURRENT_LIST_DIR}/zig-ranlib.cmd")
endif()
)";
static const char cmake_zig_ar_bytes[] = R"(
@echo off
zig ar %*
)";
static const char cmake_zig_ranlib_bytes[] = R"(
@echo off
zig ranlib %*
)";
static const char cmake_cmakelists_bytes[] = R"(
cmake_minimum_required(VERSION 3.10)
project(example LANGUAGES CXX)

# Fetch godot-sandbox C++ API
include(FetchContent)
FetchContent_Declare(
	godot-sandbox
	GIT_REPOSITORY https://github.com/libriscv/godot-sandbox.git
	GIT_TAG        main
	GIT_SHALLOW    TRUE
	GIT_SUBMODULES ""
	SOURCE_SUBDIR  "program/cpp/cmake"
)
FetchContent_MakeAvailable(godot-sandbox)

# Put an example.cpp in a src folder and CMake
# will create example.elf in the same folder with this:
add_sandbox_program_at(example.elf ../src
	../src/example.cpp
)
)";

void ResourceFormatSaverCPP::init() {
	thread_pool = std::make_unique<riscv::ThreadPool>(1); // Maximum 1 compiler job at a time
	cpp_saver.instantiate();
	// Register the CPPScript resource saver
	ResourceSaver::get_singleton()->add_resource_format_saver(cpp_saver);
}

void ResourceFormatSaverCPP::deinit() {
	// Stop the thread pool
	thread_pool.reset();
	// Unregister the CPPScript resource saver
	ResourceSaver::get_singleton()->remove_resource_format_saver(cpp_saver);
	cpp_saver.unref();
}

static void auto_generate_cpp_api(const String &path) {
	// Check if the run-time API should be generated
	if (!SandboxProjectSettings::generate_runtime_api()) {
		return;
	}
	// Write the API to the project root
	Ref<FileAccess> api_handle = FileAccess::open(path, FileAccess::ModeFlags::WRITE);
	if (api_handle.is_valid()) {
		const bool use_argument_names = SandboxProjectSettings::generate_method_arguments();
		api_handle->store_string(Sandbox::generate_api("cpp", "", use_argument_names));
		api_handle->close();
	}
}

static bool configure_cmake(const String &path) {
	OS *os = OS::get_singleton();
	// Configure cmake to generate the build files
	// Example: cmake .. -G Ninja -DCMAKE_BUILD_TYPE=Release -DSTRIPPED=ON -DCMAKE_TOOLCHAIN_FILE=%HERE%\toolchain.cmake
	Ref<DirAccess> dir_access = DirAccess::open(path);
	if (!dir_access.is_valid()) {
		ERR_PRINT("Failed to open directory: " + path);
		return false;
	}
	// Create the .build directory if it does not exist
	if (!dir_access->dir_exists(".build")) {
		Error err = dir_access->make_dir(".build");
		if (err != Error::OK) {
			ERR_PRINT("Failed to create .build directory: " + path);
			return false;
		}
	}

	const String runtime_api_path = path + String("/.build/generated_api.hpp");
	if (!FileAccess::file_exists(runtime_api_path)) {
		// Generate the C++ run-time API in the .build directory
		// This will be used by C++ programs to access the wider Godot API
		auto_generate_cpp_api(runtime_api_path);
	}

	// Create the CMakeLists.txt file if it does not exist
	const String cmakelists_path = path + String("/CMakeLists.txt");
	if (!FileAccess::file_exists(cmakelists_path)) {
		Ref<FileAccess> cmakelists_file = FileAccess::open(cmakelists_path, FileAccess::ModeFlags::WRITE);
		if (cmakelists_file.is_valid()) {
			cmakelists_file->store_string(cmake_cmakelists_bytes);
			cmakelists_file->close();
		} else {
			ERR_PRINT("Failed to create CMakeLists.txt file: " + cmakelists_path);
			return false;
		}
	}

	// Execute cmake to configure the project
	// We assume that zig, cmake and git are available in the PATH
	// TODO: Verify that zig, cmake and git are available in the PATH?
	const String toolchain_path = path + String("/toolchain.cmake");
	if (!FileAccess::file_exists(toolchain_path)) {
		// Create the toolchain file
		Ref<FileAccess> toolchain_file = FileAccess::open(toolchain_path, FileAccess::ModeFlags::WRITE);
		if (toolchain_file.is_valid()) {
			toolchain_file->store_string(cmake_toolchain_bytes);
			toolchain_file->close();
		} else {
			ERR_PRINT("Failed to create toolchain file: " + toolchain_path);
			return false;
		}
	}
#if defined(_WIN32)
	// Create the zig-ar.cmd file, if it does not exist
	const String zig_ar_path = path + String("/zig-ar.cmd");
	if (!FileAccess::file_exists(zig_ar_path)) {
		Ref<FileAccess> zig_ar_file = FileAccess::open(zig_ar_path, FileAccess::ModeFlags::WRITE);
		if (zig_ar_file.is_valid()) {
			zig_ar_file->store_string(cmake_zig_ar_bytes);
			zig_ar_file->close();
		} else {
			ERR_PRINT("Failed to create zig-ar.cmd file: " + zig_ar_path);
			return false;
		}
	}
	// Create the zig-ranlib.cmd file, if it does not exist
	const String zig_ranlib_path = path + String("/zig-ranlib.cmd");
	if (!FileAccess::file_exists(zig_ranlib_path)) {
		Ref<FileAccess> zig_ranlib_file = FileAccess::open(zig_ranlib_path, FileAccess::ModeFlags::WRITE);
		if (zig_ranlib_file.is_valid()) {
			zig_ranlib_file->store_string(cmake_zig_ranlib_bytes);
			zig_ranlib_file->close();
		} else {
			ERR_PRINT("Failed to create zig-ranlib.cmd file: " + zig_ranlib_path);
			return false;
		}
	}
#endif

	// Create toolchain absolute path
	const String toolchain_path_absolute = ProjectSettings::get_singleton()->globalize_path("res://") + toolchain_path;

	PackedStringArray arguments;
	arguments.push_back(SandboxProjectSettings::get_cmake_path()); // CMake executable
	arguments.push_back(path); // CMake directory
	arguments.push_back("-B");
	arguments.push_back(path + String("/.build")); // Build directory
#ifdef _WIN32
	arguments.push_back("-GNinja"); // Use Ninja as the build system
#endif
	arguments.push_back("-DCMAKE_BUILD_TYPE=Release");
	arguments.push_back("-DSTRIPPED=OFF");
	arguments.push_back("-DCMAKE_TOOLCHAIN_FILE=" + toolchain_path_absolute);
	// Zig path
	const String zig_path = SandboxProjectSettings::get_zig_path();
	if (!zig_path.is_empty()) {
		arguments.push_back("-DZIG_PATH=" + zig_path + "");
	}
	//arguments.push_back("-DCMAKE_EXPORT_COMPILE_COMMANDS=ON");

	if (true) {
		UtilityFunctions::print("CMake arguments: ", arguments);
	}
	Array output;
	int32_t result = os->execute(SandboxProjectSettings::get_cmake_path(), arguments, output, true);
	if (result != 0) {
		if (!output.is_empty()) {
			output = output[0].operator String().split("\n");
			for (int i = 0; i < output.size(); i++) {
				String line = output[i].operator String();
				UtilityFunctions::printerr(line);
			}
		}
		ERR_PRINT("Failed to configure cmake: " + itos(result));
		return false;
	}
	UtilityFunctions::print("CMake configured successfully in: ", path);
	return true;
}

static Array invoke_cmake(const String &path) {
	Ref<DirAccess> dir_access = DirAccess::open(path);
	if (!dir_access.is_valid()) {
		ERR_PRINT("Failed to open directory: " + path);
		return Array();
	}
	// Check if path/.build exists, if not, configure CMake
	if (!dir_access->dir_exists(".build") ||
		(!dir_access->file_exists(".build/build.ninja")
		&& !dir_access->file_exists(".build/Makefile"))) {
		// Configure cmake to generate the build files
		if (!configure_cmake(path)) {
			ERR_PRINT("Failed to configure cmake in: " + path);
			return Array();
		}
	} else {
		// Ensure the C++ run-time API exists in the .build directory
		// Most projects will rely heavily on this, and it may be deleted
		// in order to force a re-generation (adding new classes, addons etc.)
		const String runtime_api_path = path + String("/.build/generated_api.hpp");
		if (!FileAccess::file_exists(runtime_api_path)) {
			auto_generate_cpp_api(runtime_api_path);
		}
	}

	// Invoke cmake to build the project
	PackedStringArray arguments;
	arguments.push_back("--build");
	arguments.push_back(String(path) + "/.build"); // Build directory
	arguments.push_back("-j");
	arguments.push_back(itos(OS::get_singleton()->get_processor_count()));

	OS *os = OS::get_singleton();
	UtilityFunctions::print("Invoking cmake: ", arguments);
	Array output;
	int32_t result = os->execute(SandboxProjectSettings::get_cmake_path(), arguments, output, true);

	if (result != 0) {
		if (!output.is_empty()) {
			output = output[0].operator String().split("\n");
			for (int i = 0; i < output.size(); i++) {
				String line = output[i].operator String();
				UtilityFunctions::printerr(line);
			}
		}
		ERR_PRINT("Failed to invoke cmake: " + itos(result));
	}
	return output;
}

static bool detect_and_build_cmake_project_instead() {
	// If the project root contains a CMakeLists.txt file, or a cmake/CMakeLists.txt,
	// build the project using CMake
	// Get the project root using res://
	String project_root = "res://";

	// Check for CMakeLists.txt in the project root
	const bool cmake_root = FileAccess::file_exists(project_root + "CMakeLists.txt");
	if (cmake_root) {
		(void)invoke_cmake(".");
		// Always return true, as this indicates that the project is built using CMake
		return true;
	}
	const bool cmake_dir = FileAccess::file_exists(project_root + "cmake/CMakeLists.txt");
	if (cmake_dir) {
		(void)invoke_cmake("./cmake");
		// Always return true, as this indicates that the project is built using CMake
		return true;
	}
	return false;
}

static Array invoke_scons(const String &path) {
	// Invoke scons to build the project
	PackedStringArray arguments;
	// TODO get arguments from project settings

	OS *os = OS::get_singleton();
	UtilityFunctions::print("Invoking scons: ", arguments);
	Array output;
	int32_t result = os->execute(SandboxProjectSettings::get_scons_path(), arguments, output, true);

	if (result != 0) {
		if (!output.is_empty()) {
			output = output[0].operator String().split("\n");
			for (int i = 0; i < output.size(); i++) {
				String line = output[i].operator String();
				UtilityFunctions::printerr(line);
			}
		}
		ERR_PRINT("Failed to invoke scons: " + itos(result));
	}
	return output;
}

static bool detect_and_build_scons_project_instead() {
	// If the project root contains a SConstruct file,
	// build the project using SConstruct
	// Get the project root using res://
	String project_root = "res://";

	// Check for SConstruct in the project root
	const bool scons_root = FileAccess::file_exists(project_root + "SConstruct");
	if (scons_root) {
		(void)invoke_scons(".");
		// Always return true, as this indicates that the project is built using SConstruct
		return true;
	}
	return false;
}

Error ResourceFormatSaverCPP::_save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) {
	CPPScript *script = Object::cast_to<CPPScript>(p_resource.ptr());
	if (script != nullptr) {
		Ref<FileAccess> handle = FileAccess::open(p_path, FileAccess::ModeFlags::WRITE);
		if (handle.is_valid()) {
			handle->store_string(script->_get_source_code());
			handle->close();

			if (CPPScript::DetectCMakeOrSConsProject()) {
				// Check if the project is a CMake project
				if (detect_and_build_cmake_project_instead()) {
					return Error::OK;
				}
				// Check if the project is a SCons project
				if (detect_and_build_scons_project_instead()) {
					return Error::OK;
				}
			}

			// Generate the C++ run-time API in the project root
			static bool api_written_to_project_root = false;
			if (!api_written_to_project_root) {
				api_written_to_project_root = true;
				auto_generate_cpp_api("res://generated_api.hpp");
			}

			// Get the absolute path without the file name
			String path = handle->get_path().get_base_dir().replace("res://", "") + "/";
			String inpname = path + "*.cpp";
			String foldername = Docker::GetFolderName(handle->get_path().get_base_dir());
			String outname = path + foldername + String(".elf");

			auto builder = [inpname = std::move(inpname), outname = std::move(outname)] {
				// Invoke docker to compile the file
				Array output;
				PackedStringArray arguments;
				arguments.push_back("/usr/api/build.sh");
				if (SandboxProjectSettings::debug_info())
					arguments.push_back("--debug");
				Array global_defines = SandboxProjectSettings::get_global_defines();
				for (int i = 0; i < global_defines.size(); i++) {
					arguments.push_back("-D");
					arguments.push_back(global_defines[i]);
				}
				arguments.push_back("-o");
				arguments.push_back(outname);
				arguments.push_back(inpname);
				// CPPScript::DockerContainerExecute({ "/usr/api/build.sh", "-o", outname, inpname }, output);
				CPPScript::DockerContainerExecute(arguments, output);
				if (!output.is_empty() && !output[0].operator String().is_empty()) {
					for (int i = 0; i < output.size(); i++) {
						String line = output[i].operator String();
						if constexpr (VERBOSE_CMD)
							ERR_PRINT(line);
						// Remove (most) console color codes
						line = line.replace("\033[0;31m", "");
						line = line.replace("\033[0;32m", "");
						line = line.replace("\033[0;33m", "");
						line = line.replace("\033[0;34m", "");
						line = line.replace("\033[0;35m", "");
						line = line.replace("\033[0;36m", "");
						line = line.replace("\033[0;37m", "");
						line = line.replace("\033[01;31m", "");
						line = line.replace("\033[01;32m", "");
						line = line.replace("\033[01;33m", "");
						line = line.replace("\033[01;34m", "");
						line = line.replace("\033[01;35m", "");
						line = line.replace("\033[01;36m", "");
						line = line.replace("\033[01;37m", "");
						line = line.replace("\033[m", "");
						line = line.replace("\033[0m", "");
						line = line.replace("\033[01m", "");
						line = line.replace("\033[32m", "");
						line = line.replace("[K", "");
						WARN_PRINT(line);
					}
				}
			};

			// If async compilation is enabled, enqueue the builder to the thread pool
			if (SandboxProjectSettings::async_compilation())
				thread_pool->enqueue(builder);
			else {
				builder();
			}
			return Error::OK;
		} else {
			return Error::ERR_FILE_CANT_OPEN;
		}
	}
	return Error::ERR_SCRIPT_FAILED;
}
Error ResourceFormatSaverCPP::_set_uid(const String &p_path, int64_t p_uid) {
	return Error::OK;
}
bool ResourceFormatSaverCPP::_recognize(const Ref<Resource> &p_resource) const {
	return Object::cast_to<CPPScript>(p_resource.ptr()) != nullptr;
}
PackedStringArray ResourceFormatSaverCPP::_get_recognized_extensions(const Ref<Resource> &p_resource) const {
	PackedStringArray array;
	if (Object::cast_to<CPPScript>(p_resource.ptr()) == nullptr)
		return array;
	array.push_back("cpp");
	array.push_back("cc");
	array.push_back("hh");
	array.push_back("h");
	array.push_back("hpp");
	return array;
}
bool ResourceFormatSaverCPP::_recognize_path(const Ref<Resource> &p_resource, const String &p_path) const {
	return Object::cast_to<CPPScript>(p_resource.ptr()) != nullptr;
}

```

`src/cpp/resource_saver_cpp.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_saver.hpp>
#include <godot_cpp/classes/resource_saver.hpp>

using namespace godot;

class ResourceFormatSaverCPP : public ResourceFormatSaver {
	GDCLASS(ResourceFormatSaverCPP, ResourceFormatSaver);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Error _save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) override;
	virtual Error _set_uid(const String &p_path, int64_t p_uid) override;
	virtual bool _recognize(const Ref<Resource> &p_resource) const override;
	virtual PackedStringArray _get_recognized_extensions(const Ref<Resource> &p_resource) const override;
	virtual bool _recognize_path(const Ref<Resource> &p_resource, const String &p_path) const override;
};

```

`src/cpp/script_cpp.cpp`:

```cpp
#include "script_cpp.h"

#include "../elf/script_instance.h"
#include "../sandbox_project_settings.h"
#include "script_language_cpp.h"
#include "script_cpp_instance.h"
#include "../elf/script_instance_helper.h"
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/core/class_db.hpp>
static constexpr bool VERBOSE_LOGGING = false;

bool CPPScript::DetectCMakeOrSConsProject() {
	static bool detected = false;
	static bool detected_value = false;
	// Avoid file system checks if the project type has already been detected
	if (detected) {
		return detected_value;
	}
	// If the project root contains a CMakeLists.txt file, or a cmake/CMakeLists.txt,
	// build the project using CMake
	// Get the project root using res://
	String project_root = "res://";
	detected = true;

	// Check for CMakeLists.txt in the project root
	const bool cmake_root = FileAccess::file_exists(project_root + "CMakeLists.txt");
	if (cmake_root) {
		detected_value = true;
		return true;
	}
	const bool cmake_dir = FileAccess::file_exists(project_root + "cmake/CMakeLists.txt");
	if (cmake_dir) {
		detected_value = true;
		return true;
	}
	const bool scons_root = FileAccess::file_exists(project_root + "SConstruct");
	if (scons_root) {
		detected_value = true;
		return true;
	}
	detected_value = false;
	return false;
}

bool CPPScript::_editor_can_reload_from_file() {
	return true;
}
void CPPScript::_placeholder_erased(void *p_placeholder) {}
bool CPPScript::_can_instantiate() const {
	return true;
}
Ref<Script> CPPScript::_get_base_script() const {
	return Ref<Script>();
}
StringName CPPScript::_get_global_name() const {
	return PathToGlobalName(this->path);
}
bool CPPScript::_inherits_script(const Ref<Script> &p_script) const {
	return false;
}
StringName CPPScript::_get_instance_base_type() const {
	return StringName("Sandbox");
}
void *CPPScript::_instance_create(Object *p_for_object) const {
	CPPScriptInstance *instance = memnew(CPPScriptInstance(p_for_object, Ref<CPPScript>(this)));
	instances.insert(instance);
	if (instances.size() == 1) {
		this->update_methods_info();
	}
	return ScriptInstanceExtension::create_native_instance(instance);
}
void *CPPScript::_placeholder_instance_create(Object *p_for_object) const {
	return _instance_create(p_for_object);
}
bool CPPScript::_instance_has(Object *p_object) const {
	return false;
}
bool CPPScript::_has_source_code() const {
	return true;
}
String CPPScript::_get_source_code() const {
	return source_code;
}
void CPPScript::_set_source_code(const String &p_code) {
	source_code = p_code;
}
Error CPPScript::_reload(bool p_keep_state) {
	this->set_file(this->path);
	return Error::OK;
}
TypedArray<Dictionary> CPPScript::_get_documentation() const {
	return TypedArray<Dictionary>();
}
String CPPScript::_get_class_icon_path() const {
	return String("res://addons/godot_sandbox/CPPScript.svg");
}
bool CPPScript::_has_method(const StringName &p_method) const {
	if (p_method == StringName("_init"))
		return true;
	for (const godot::MethodInfo &method_info : methods_info) {
		if (method_info.name == p_method) {
			return true;
		}
	}
	return false;
}
bool CPPScript::_has_static_method(const StringName &p_method) const {
	return false;
}
Dictionary CPPScript::_get_method_info(const StringName &p_method) const {
	Dictionary method_dict;
	for (const godot::MethodInfo &method_info : methods_info) {
		if (method_info.name == p_method) {
			method_dict["name"] = method_info.name;
			method_dict["flags"] = method_info.flags;
			method_dict["return_type"] = method_info.return_val.type;
			TypedArray<Dictionary> args;
			for (const godot::PropertyInfo &arg_info : method_info.arguments) {
				Dictionary arg_dict;
				arg_dict["name"] = arg_info.name;
				arg_dict["type"] = arg_info.type;
				arg_dict["usage"] = arg_info.usage;
				args.append(arg_dict);
			}
			method_dict["arguments"] = args;
			return method_dict;
		}
	}
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScript::_get_method_info: Method " + String(p_method) + " not found.");
	}
	return Dictionary();
}
bool CPPScript::_is_tool() const {
	return true;
}
bool CPPScript::_is_valid() const {
	return elf_script.is_valid() && !elf_script->get_content().is_empty();
}
bool CPPScript::_is_abstract() const {
	return false;
}
ScriptLanguage *CPPScript::_get_language() const {
	return CPPScriptLanguage::get_singleton();
}
bool CPPScript::_has_script_signal(const StringName &p_signal) const {
	return false;
}
TypedArray<Dictionary> CPPScript::_get_script_signal_list() const {
	return TypedArray<Dictionary>();
}
bool CPPScript::_has_property_default_value(const StringName &p_property) const {
	return false;
}
Variant CPPScript::_get_property_default_value(const StringName &p_property) const {
	return Variant();
}
void CPPScript::_update_exports() {}
TypedArray<Dictionary> CPPScript::_get_script_method_list() const {
	TypedArray<Dictionary> functions_array;
	for (const godot::MethodInfo &method_info : methods_info) {
		Dictionary method;
		method["name"] = method_info.name;
		method["args"] = Array();
		method["default_args"] = Array();
		Dictionary type;
		type["name"] = "type";
		type["type"] = Variant::Type::NIL;
		type["hint"] = PropertyHint::PROPERTY_HINT_NONE;
		type["hint_string"] = String();
		type["usage"] = PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NIL_IS_VARIANT;
		method["return"] = type;
		method["flags"] = METHOD_FLAG_VARARG;
		functions_array.push_back(method);
	}
	return functions_array;
}
TypedArray<Dictionary> CPPScript::_get_script_property_list() const {
	if (instances.is_empty()) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("CPPScript::_get_script_property_list: No instances available.");
		}
		return {};
	}
	TypedArray<Dictionary> properties;
	Dictionary property;
	property["name"] = "associated_script";
	property["type"] = Variant::OBJECT;
	property["hint"] = PROPERTY_HINT_NODE_TYPE;
	property["hint_string"] = "Node";
	property["usage"] = PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_SCRIPT_VARIABLE;
	//property["default_value"] = source_code;
	properties.push_back(property);
	for (const PropertyInfo &prop : Sandbox::create_sandbox_property_list()) {
		properties.push_back(prop_to_dict(prop));
	}
	return properties;
}
int32_t CPPScript::_get_member_line(const StringName &p_member) const {
	return 0;
}
Dictionary CPPScript::_get_constants() const {
	return Dictionary();
}
TypedArray<StringName> CPPScript::_get_members() const {
	return TypedArray<StringName>();
}
bool CPPScript::_is_placeholder_fallback_enabled() const {
	return false;
}
Variant CPPScript::_get_rpc_config() const {
	return Variant();
}

CPPScript::CPPScript() {
	source_code = R"C0D3(#include "api.hpp"

static Variant my_function(Vector4 v) {
	print("Arg: ", v);
	return 123;
}

static Variant _process() {
	static int counter = 0;
	if (++counter % 100 == 0) {
		print("Process called " + std::to_string(counter) + " times");
	}
	return Nil;
}

static Vector4 my_vector4(1.0f, 2.0f, 3.0f, 4.0f);
static String my_string("Hello, World!");
int main() {
	ADD_PROPERTY(my_vector4, Variant::VECTOR4);
	ADD_PROPERTY(my_string, Variant::STRING);

	ADD_API_FUNCTION(my_function, "int", "Vector4 v");
	ADD_API_FUNCTION(_process, "void");
}
)C0D3";
}
CPPScript::~CPPScript() {
}

void CPPScript::set_file(const String &p_path) {
	if (p_path.is_empty()) {
		WARN_PRINT("CPPScript::set_file: Empty resource path.");
		return;
	}
	this->path = p_path;
	this->source_code = FileAccess::get_file_as_string(p_path);
}

const PackedByteArray &CPPScript::get_elf_data() const {
	if (elf_script.is_valid()) {
		return elf_script->get_content();
	}
	static PackedByteArray empty;
	return empty;
}

bool CPPScript::detect_script_instance() {
	// It's possible to speculate that eg. a fitting ELFScript would be located at
	// "res://this/path.cpp" replacing the extension with ".elf".
	if (this->path.is_empty()) {
		WARN_PRINT("CPPScript::detect_script_instance: Empty resource path.");
		return false;
	}
	const String elf_path = this->path.get_basename() + ".elf";
	if (FileAccess::file_exists(elf_path)) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("CPPScript::detect_script_instance: Found ELF script at " + elf_path);
		}
		// Try to get the resource from the path
		Ref<ELFScript> res = ResourceLoader::get_singleton()->load(elf_path, "ELFScript");
		if (res.is_valid()) {
			if constexpr (VERBOSE_LOGGING) {
				ERR_PRINT("CPPScript::detect_script_instance: ELF script loaded successfully.");
			}
			this->elf_script = res;
			this->update_methods_info();
			return true;
		}
	}
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScript::detect_script_instance: No ELF script found at " + elf_path);
	}
	return false;
}

void CPPScript::set_elf_script(const Ref<ELFScript> &p_elf_script) {
	this->elf_script = p_elf_script;

	for (CPPScriptInstance *instance : instances) {
		instance->reset_to(p_elf_script);
	}

	this->update_methods_info();
}

void CPPScript::remove_instance(CPPScriptInstance *p_instance) {
	instances.erase(p_instance);
	if (instances.is_empty()) {
		this->elf_script.unref();
	}
}

void CPPScript::update_methods_info() const {
	if (!elf_script.is_valid())
		return;

	this->methods_info.clear();
	if (elf_script.is_valid() && !elf_script->function_names.is_empty()) {
		const auto& methods = elf_script->function_names;
		for (int i = 0; i < methods.size(); i++) {
			godot::MethodInfo method_info = godot::MethodInfo(methods[i]);
			methods_info.push_back(method_info);
		}
	} else {
		const PackedByteArray &elf_data = elf_script->get_content();
		Sandbox::BinaryInfo info = Sandbox::get_program_info_from_binary(elf_data);
		for (const String &func_name : info.functions) {
			methods_info.push_back(MethodInfo(func_name));
		}
	}
	methods_info.push_back(MethodInfo("get_associated_script"));
	methods_info.push_back(MethodInfo("set_associated_script"));

	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScript::update_methods_info: Updated methods info with " + itos(methods_info.size()) + " methods.");
	}
}

```

`src/cpp/script_cpp.h`:

```h
#pragma once

#include "../docker.h"
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language.hpp>
#include <godot_cpp/templates/hash_set.hpp>

using namespace godot;
class CPPScriptInstance;
class ELFScript;

class CPPScript : public ScriptExtension {
	GDCLASS(CPPScript, ScriptExtension);

protected:
	static void _bind_methods() {}
	String source_code;

public:
	virtual bool _editor_can_reload_from_file() override;
	virtual void _placeholder_erased(void *p_placeholder) override;
	virtual bool _can_instantiate() const override;
	virtual Ref<Script> _get_base_script() const override;
	virtual StringName _get_global_name() const override;
	virtual bool _inherits_script(const Ref<Script> &p_script) const override;
	virtual StringName _get_instance_base_type() const override;
	virtual void *_instance_create(Object *p_for_object) const override;
	virtual void *_placeholder_instance_create(Object *p_for_object) const override;
	virtual bool _instance_has(Object *p_object) const override;
	virtual bool _has_source_code() const override;
	virtual String _get_source_code() const override;
	virtual void _set_source_code(const String &p_code) override;
	virtual Error _reload(bool p_keep_state) override;
	virtual TypedArray<Dictionary> _get_documentation() const override;
	virtual String _get_class_icon_path() const override;
	virtual bool _has_method(const StringName &p_method) const override;
	virtual bool _has_static_method(const StringName &p_method) const override;
	virtual Dictionary _get_method_info(const StringName &p_method) const override;
	virtual bool _is_tool() const override;
	virtual bool _is_valid() const override;
	virtual bool _is_abstract() const override;
	virtual ScriptLanguage *_get_language() const override;
	virtual bool _has_script_signal(const StringName &p_signal) const override;
	virtual TypedArray<Dictionary> _get_script_signal_list() const override;
	virtual bool _has_property_default_value(const StringName &p_property) const override;
	virtual Variant _get_property_default_value(const StringName &p_property) const override;
	virtual void _update_exports() override;
	virtual TypedArray<Dictionary> _get_script_method_list() const override;
	virtual TypedArray<Dictionary> _get_script_property_list() const override;
	virtual int32_t _get_member_line(const StringName &p_member) const override;
	virtual Dictionary _get_constants() const override;
	virtual TypedArray<StringName> _get_members() const override;
	virtual bool _is_placeholder_fallback_enabled() const override;
	virtual Variant _get_rpc_config() const override;

	/// @brief Detects if the project is a CMake or SCons project,
	/// in which case Docker usage is not necessary.
	/// @return true if the project is a CMake or SCons project.
	static bool DetectCMakeOrSConsProject();

	static void DockerContainerStart() {
		if (!docker_container_started) {
			Array output;
			if (Docker::ContainerStart(docker_container_name, docker_image_name, output))
				docker_container_started = true;
			else {
				UtilityFunctions::print(output);
				ERR_PRINT("Failed to start Docker container: " + String(docker_container_name));
			}
		}
	}
	static void DockerContainerStop() {
		if (docker_container_started) {
			Docker::ContainerStop(docker_container_name);
			docker_container_started = false;
		}
	}
	static int DockerContainerVersion() {
		DockerContainerStart();
		if (docker_container_version == 0)
			docker_container_version =
					Docker::ContainerVersion(docker_container_name, { "/usr/api/build.sh", "--version" });
		return docker_container_version;
	}
	static bool DockerContainerExecute(const PackedStringArray &p_arguments, Array &output, bool verbose = true) {
		DockerContainerStart();
		return Docker::ContainerExecute(docker_container_name, p_arguments, output, verbose);
	}

	void set_file(const String &p_path);
	CPPScriptInstance *get_cpp_script_instance() const;
	const String &get_path() const { return path; }
	const PackedByteArray &get_elf_data() const;
	bool detect_script_instance();
	void remove_instance(CPPScriptInstance *p_instance);
	const Ref<ELFScript> &get_elf_script() const { return elf_script; }
	void set_elf_script(const Ref<ELFScript> &p_elf_script);

	static String PathToGlobalName(const String &p_path) {
		return "CPPScript_" + p_path.get_basename().replace("res://", "").replace("/", "_").replace("-", "_").capitalize().replace(" ", "");
	}

	CPPScript();
	~CPPScript();

private:
	void update_methods_info() const;
	static inline bool docker_container_started = false;
	static inline int docker_container_version = 0;
	static inline const char *docker_container_name = "godot-cpp-compiler";
	static inline const char *docker_image_name = "ghcr.io/libriscv/cpp_compiler";

	String path;
	mutable HashSet<CPPScriptInstance *> instances;
	Ref<ELFScript> elf_script;
	mutable std::vector<godot::MethodInfo> methods_info;
	friend class CPPScriptInstance;
};

```

`src/cpp/script_cpp_instance.cpp`:

```cpp
#include "script_cpp_instance.h"

#include "../elf/script_elf.h"
#include "../elf/script_instance.h"
#include "../elf/script_instance_helper.h"
#include "../sandbox.h"
#include "../scoped_tree_base.h"
#include "script_cpp.h"
#include "script_language_cpp.h"
#include <godot_cpp/core/object.hpp>
#include <godot_cpp/templates/local_vector.hpp>
static constexpr bool VERBOSE_LOGGING = false;

struct SandboxAndCount {
	Sandbox *sandbox = nullptr;
	unsigned count = 0;
};
static std::unordered_map<CPPScript *, SandboxAndCount> sandbox_instances;

Sandbox *CPPScriptInstance::create_sandbox(Object *p_owner, const Ref<CPPScript> &p_script) {
	auto it = sandbox_instances.find(p_script.ptr());
	if (it != sandbox_instances.end()) {
		it->second.count++;
		return it->second.sandbox;
	}

	Sandbox *sandbox_ptr = memnew(Sandbox);
	sandbox_ptr->set_tree_base(Object::cast_to<Node>(p_owner));
	sandbox_instances.insert_or_assign(p_script.ptr(), SandboxAndCount{ sandbox_ptr, 1 });

	const Ref<ELFScript> &elf = p_script->get_elf_script();
	if (elf.is_valid()) {
		sandbox_ptr->set_program(elf);
	}

	return sandbox_ptr;
}

void CPPScriptInstance::reset_to(const Ref<ELFScript> &p_elf_script) {
	Sandbox *sandbox = current_sandbox;
	if (sandbox != nullptr && sandbox->get_program() != p_elf_script) {
		sandbox->set_program(p_elf_script);
	}
}

void CPPScriptInstance::set_new_elf_script(ELFScript* p_elf_script) {
	this->script->set_elf_script(Ref<ELFScript>(p_elf_script));
}

bool CPPScriptInstance::set(const StringName &p_name, const Variant &p_value) {
	static const StringName s_script("script");
	static const StringName s_program("program");
	static const StringName s_associated_script("associated_script");
	if (p_name == s_script || p_name == s_program) {
		return false;
	} else if (p_name == s_associated_script) {
		Object *object = p_value.operator Object *();
		if (object == nullptr) { // Unset the script
			this->set_new_elf_script(nullptr);
			return true;
		}
		ELFScript *new_elf_script = Object::cast_to<ELFScript>(object);
		if (new_elf_script != nullptr) {
			this->set_new_elf_script(new_elf_script);
			return true;
		} else {
			return false;
		}
	}

	Sandbox *sandbox = current_sandbox;
	if (sandbox == nullptr) {
		return false;
	}
	ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
	if (sandbox->set_property(p_name, p_value)) {
		return true;
	}
	return false;
}

bool CPPScriptInstance::get(const StringName &p_name, Variant &r_ret) const {
	static const StringName s_script("script");
	static const StringName s_associated_script("associated_script");
	if (p_name == s_script) {
		r_ret = this->script;
		return true;
	} else if (p_name == s_associated_script) {
		r_ret = this->script->get_elf_script();
		return true;
	}

	Sandbox *sandbox = current_sandbox;
	if (sandbox == nullptr) {
		return false;
	}
	ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
	if (sandbox->get_property(p_name, r_ret)) {
		return true;
	}
	return false;
}

godot::String CPPScriptInstance::to_string(bool *r_is_valid) {
	return "<CPPScript>";
}

void CPPScriptInstance::notification(int32_t p_what, bool p_reversed) {
}

Variant CPPScriptInstance::callp(
		const StringName &p_method,
		const Variant **p_args, const int p_argument_count,
		GDExtensionCallError &r_error)
{
	static const StringName s_get_associated_script("get_associated_script");
	static const StringName s_set_associated_script("set_associated_script");

	if (p_method == s_get_associated_script) {
		r_error.error = GDEXTENSION_CALL_OK;
		return this->script->get_elf_script();
	} else if (p_method == s_set_associated_script) {
		if (p_argument_count != 1) {
			r_error.error = GDEXTENSION_CALL_ERROR_INVALID_ARGUMENT;
			return Variant();
		}
		Object *object = p_args[0]->operator Object *();
		if (object == nullptr) { // Unset the script
			this->set_new_elf_script(nullptr);
        	r_error.error = GDEXTENSION_CALL_OK;
        	return Variant();
		}
		ELFScript *new_elf_script = Object::cast_to<ELFScript>(object);
		if (new_elf_script != nullptr) {
			this->set_new_elf_script(new_elf_script);
			r_error.error = GDEXTENSION_CALL_OK;
			return Variant();
		} else {
			r_error.error = GDEXTENSION_CALL_ERROR_INVALID_ARGUMENT;
			return Variant();
		}
	}

	Sandbox *sandbox = current_sandbox;
	const auto address = sandbox->cached_address_of(p_method.hash(), p_method);
	if (address == 0) {
		const bool found = sandbox->is_sandbox_function(p_method);
		if (!found) {
			r_error.error = GDEXTENSION_CALL_ERROR_INVALID_METHOD;
			return Variant();
		}
		Array args;
		for (int i = 0; i < p_argument_count; i++) {
			args.push_back(*p_args[i]);
		}
		r_error.error = GDEXTENSION_CALL_OK;
		return sandbox->callv(p_method, args);
	}

	ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
	return sandbox->vmcall_address(address, p_args, p_argument_count, r_error);
}

const GDExtensionMethodInfo *CPPScriptInstance::get_method_list(uint32_t *r_count) const {
	const int size = script->methods_info.size();
	GDExtensionMethodInfo *list = memnew_arr(GDExtensionMethodInfo, size);
	int i = 0;
	for (const godot::MethodInfo &method_info : script->methods_info) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("CPPScriptInstance::get_method_list: method " + String(method_info.name));
		}
		list[i] = create_method_info(method_info);
		i++;
	}
	*r_count = size;

	return list;
}

static void set_property_info(
		GDExtensionPropertyInfo &p_info,
		const StringName &p_name,
		const StringName &p_class_name,
		GDExtensionVariantType p_type,
		uint32_t p_hint,
		const String &p_hint_string,
		uint32_t p_usage)
{
	p_info.name = stringname_alloc(p_name);
	p_info.class_name = stringname_alloc(p_class_name);
	p_info.type = p_type;
	p_info.hint = p_hint;
	p_info.hint_string = string_alloc(p_hint_string);
	p_info.usage = p_usage;
}

const GDExtensionPropertyInfo *CPPScriptInstance::get_property_list(uint32_t *r_count) const {
	Sandbox *sandbox = current_sandbox;
	if (sandbox == nullptr) {
		*r_count = 0;
		return nullptr;
	}

	std::vector<PropertyInfo> prop_list = sandbox->create_sandbox_property_list();
	const std::vector<SandboxProperty> &properties = sandbox->get_properties();

	*r_count = properties.size() + prop_list.size();
	GDExtensionPropertyInfo *list = memnew_arr(GDExtensionPropertyInfo, *r_count + 2);
	const GDExtensionPropertyInfo *list_ptr = list;

	for (const SandboxProperty &property : properties) {
		if constexpr (VERBOSE_LOGGING) {
			printf("CPPScriptInstance::get_property_list %s\n", String(property.name()).utf8().ptr());
			fflush(stdout);
		}
		list->name = stringname_alloc(property.name());
		list->class_name = stringname_alloc("Variant");
		list->type = (GDExtensionVariantType)property.type();
		list->hint = 0;
		list->hint_string = string_alloc("");
		list->usage = PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_STORAGE | PROPERTY_USAGE_SCRIPT_VARIABLE | PROPERTY_USAGE_NIL_IS_VARIANT;
		list++;
	}
	for (int i = 0; i < prop_list.size(); i++) {
		const PropertyInfo &prop = prop_list[i];
		if constexpr (VERBOSE_LOGGING) {
			printf("CPPScriptInstance::get_property_list %s\n", String(prop.name).utf8().ptr());
			fflush(stdout);
		}
		// Rewrite "program" property to "associated_script", disallowing 'program'
		// and publishing associated_script instead.
		if (prop.name == StringName("program")) {
			set_property_info(
				*list,
				"associated_script",
				"",
				GDEXTENSION_VARIANT_TYPE_OBJECT,
				PROPERTY_HINT_RESOURCE_TYPE,
				"ELFScript",
				PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NODE_PATH_FROM_SCENE_ROOT);
			list++;
			continue;
		}
		list->name = stringname_alloc(prop.name);
		list->class_name = stringname_alloc(prop.class_name);
		list->type = (GDExtensionVariantType) int(prop.type);
		list->hint = prop.hint;
		list->hint_string = string_alloc(prop.hint_string);
		list->usage = prop.usage;
		list++;
	}
	return list_ptr;
}

void CPPScriptInstance::free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const {
	if (p_list) {
		memdelete_arr(p_list);
	}
}

Variant::Type CPPScriptInstance::get_property_type(const StringName &p_name, bool *r_is_valid) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScriptInstance::get_property_type " + p_name);
	}
	if (p_name == StringName("associated_script")) {
		if (r_is_valid)
			*r_is_valid = true;
		return Variant::OBJECT;
	}
	Sandbox *sandbox = current_sandbox;
	if (sandbox == nullptr) {
		*r_is_valid = false;
		return Variant::NIL;
	}
	if (const SandboxProperty *prop = sandbox->find_property_or_null(p_name)) {
		*r_is_valid = true;
		return prop->type();
	}
	*r_is_valid = false;
	return Variant::NIL;
}

void CPPScriptInstance::get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) {
}

bool CPPScriptInstance::validate_property(GDExtensionPropertyInfo &p_property) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScriptInstance::validate_property");
	}
	return true;
}

GDExtensionInt CPPScriptInstance::get_method_argument_count(const StringName &p_method, bool &r_valid) const {
	r_valid = false;
	return 0;
}

bool CPPScriptInstance::has_method(const StringName &p_name) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScriptInstance::has_method " + p_name);
	}
	if (p_name == StringName("set_associated_script")
		|| p_name == StringName("get_associated_script")) {
		return true; // These methods are always available
	}
	for (const godot::MethodInfo &method_info : script->methods_info) {
		if (method_info.name == p_name) {
			return true;
		}
	}
	return false;
}

void CPPScriptInstance::free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const {
	if (p_list) {
		for (uint32_t i = 0; i < p_count; i++) {
			const GDExtensionMethodInfo &method_info = p_list[i];
			if (method_info.arguments) {
				memdelete_arr(method_info.arguments);
			}
		}
		memdelete_arr(p_list);
	}
}

bool CPPScriptInstance::property_can_revert(const StringName &p_name) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScriptInstance::property_can_revert " + p_name);
	}
	return false;
}

bool CPPScriptInstance::property_get_revert(const StringName &p_name, Variant &r_ret) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("CPPScriptInstance::property_get_revert " + p_name);
	}
	r_ret = Variant();
	return false;
}

void CPPScriptInstance::refcount_incremented() {
}

bool CPPScriptInstance::refcount_decremented() {
	return false;
}

Object *CPPScriptInstance::get_owner() {
	return owner;
}

Ref<Script> CPPScriptInstance::get_script() const {
	return script;
}

bool CPPScriptInstance::is_placeholder() const {
	return false;
}

void CPPScriptInstance::property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) {
	*r_valid = false;
}

Variant CPPScriptInstance::property_get_fallback(const StringName &p_name, bool *r_valid) {
	*r_valid = false;
	return Variant::NIL;
}

ScriptLanguage *CPPScriptInstance::_get_language() {
	return CPPScriptLanguage::get_singleton();
}

CPPScriptInstance::CPPScriptInstance(Object *p_owner, const Ref<CPPScript> p_script) :
		owner(p_owner), script(p_script)
{
	if (script->get_elf_script().is_null()) {
		script->detect_script_instance();
	}
	this->current_sandbox = create_sandbox(p_owner, p_script);
	if (this->current_sandbox != nullptr) {
		this->current_sandbox->set_tree_base(godot::Object::cast_to<godot::Node>(owner));
	}
}

CPPScriptInstance::~CPPScriptInstance() {
	auto it = sandbox_instances.find(script.ptr());
	if (it != sandbox_instances.end()) {
		it->second.count--;
		if (it->second.count == 0) {
			it->second.sandbox->queue_free();
			sandbox_instances.erase(it);
		}
	}
	this->current_sandbox = nullptr;
	script->remove_instance(this);
}

```

`src/cpp/script_cpp_instance.h`:

```h
#pragma once

#include <gdextension_interface.h>
#include <godot_cpp/classes/global_constants.hpp>
#include <godot_cpp/classes/mutex.hpp>
#include <godot_cpp/classes/ref.hpp>
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>
#include <godot_cpp/core/type_info.hpp>
#include <godot_cpp/variant/dictionary.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/typed_array.hpp>
#include <godot_cpp/variant/variant.hpp>

#include "../godot/script_instance.h"
using namespace godot;

class CPPScript;
class Sandbox;
class ELFScript;

class CPPScriptInstance : public ScriptInstanceExtension {
	Object *owner;
	Ref<CPPScript> script;
	Sandbox *current_sandbox = nullptr;
	void set_new_elf_script(ELFScript* p_elf_script);

	friend class CPPScript;

public:
	bool set(const StringName &p_name, const Variant &p_value) override;
	bool get(const StringName &p_name, Variant &r_ret) const override;
	const GDExtensionPropertyInfo *get_property_list(uint32_t *r_count) const override;
	void free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const override;
	Variant::Type get_property_type(const StringName &p_name, bool *r_is_valid) const override;
	bool validate_property(GDExtensionPropertyInfo &p_property) const override;
	bool property_can_revert(const StringName &p_name) const override;
	bool property_get_revert(const StringName &p_name, Variant &r_ret) const override;
	Object *get_owner() override;
	void get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) override;
	const GDExtensionMethodInfo *get_method_list(uint32_t *r_count) const override;
	void free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const override;
	bool has_method(const StringName &p_method) const override;
	GDExtensionInt get_method_argument_count(const StringName &p_method, bool &r_valid) const override;
	Variant callp(const StringName &p_method, const Variant **p_args, int p_argcount, GDExtensionCallError &r_error) override;
	void notification(int p_notification, bool p_reversed) override;
	String to_string(bool *r_valid) override;
	void refcount_incremented() override;
	bool refcount_decremented() override;
	Ref<Script> get_script() const override;
	bool is_placeholder() const override;
	void property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) override;
	Variant property_get_fallback(const StringName &p_name, bool *r_valid) override;
	ScriptLanguage *_get_language() override;

	static Sandbox *create_sandbox(Object *p_owner, const Ref<CPPScript> &p_script);
	void reset_to(const Ref<ELFScript> &p_elf_script);
	CPPScriptInstance(Object *p_owner, const Ref<CPPScript> p_script);
	~CPPScriptInstance();
};

```

`src/cpp/script_language_cpp.cpp`:

```cpp
#include "script_language_cpp.h"
#include "../script_language_common.h"
#include "script_cpp.h"
#include <godot_cpp/classes/control.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/texture2d.hpp>
#include <godot_cpp/classes/theme.hpp>
#include <string>
#include <unordered_set>
static constexpr const char *icon_path = "res://addons/godot_sandbox/CPPScript.svg";

static CPPScriptLanguage *cpp_language;

void CPPScriptLanguage::init() {
	cpp_language = memnew(CPPScriptLanguage);
	Engine::get_singleton()->register_script_language(cpp_language);
}
void CPPScriptLanguage::deinit() {
	if (cpp_language) {
		Engine::get_singleton()->unregister_script_language(cpp_language);
		memdelete(cpp_language);
		cpp_language = nullptr;
	}
}

CPPScriptLanguage *CPPScriptLanguage::get_singleton() {
	return cpp_language;
}

String CPPScriptLanguage::_get_name() const {
	return "CPP";
}
void CPPScriptLanguage::_init() {}
String CPPScriptLanguage::_get_type() const {
	return "CPPScript";
}
String CPPScriptLanguage::_get_extension() const {
	return "cpp";
}
void CPPScriptLanguage::_finish() {}
PackedStringArray CPPScriptLanguage::_get_reserved_words() const {
	static const PackedStringArray reserved_words{
		"alignas",
		"alignof",
		"and",
		"and_eq",
		"asm",
		"atomic_cancel",
		"atomic_commit",
		"atomic_noexcept",
		"auto",
		"bitand",
		"bitor",
		"break",
		"case",
		"catch",
		"char8_t",
		"char16_t",
		"char32_t",
		"class",
		"compl",
		"concept",
		"const",
		"consteval",
		"constexpr",
		"const_cast",
		"continue",
		"co_await",
		"co_return",
		"co_yield",
		"decltype",
		"default",
		"delete",
		"do",
		"dynamic_cast",
		"else",
		"enum",
		"explicit",
		"export",
		"extern",
		"false",
		"for",
		"friend",
		"goto",
		"if",
		"inline",
		"mutable",
		"namespace",
		"new",
		"noexcept",
		"not",
		"not_eq",
		"nullptr",
		"operator",
		"or",
		"or_eq",
		"private",
		"protected",
		"public",
		"reflexpr",
		"register",
		"reinterpret_cast",
		"requires",
		"return",
		"signed",
		"sizeof",
		"static",
		"static_assert",
		"static_cast",
		"struct",
		"switch",
		"synchronized",
		"template",
		"this",
		"thread_local",
		"throw",
		"true",
		"try",
		"typedef",
		"typeid",
		"typename",
		"union",
		"unsigned",
		"using",
		"virtual",
		"void",
		"volatile",
		"wchar_t",
		"while",
		"xor",
		"xor_eq",

		"bool",
		"char",
		"int",
		"long",
		"float",
		"double",
		"short",
		"int8_t",
		"int16_t",
		"int32_t",
		"int64_t",
		"uint8_t",
		"uint16_t",
		"uint32_t",
		"uint64_t",
		"size_t",
		"ssize_t",
		"intptr_t",
		"uintptr_t",
		"ptrdiff_t",
		"nullptr_t",
	};
	return reserved_words;
}
bool CPPScriptLanguage::_is_control_flow_keyword(const String &p_keyword) const {
	static const std::unordered_set<std::string> control_flow_keywords{
		"if", "else", "switch", "case", "default", "while", "do", "for", "break", "continue", "return", "goto", "try", "catch", "throw", "co_await", "co_return", "co_yield"
	};
	return control_flow_keywords.find(p_keyword.utf8().get_data()) != control_flow_keywords.end();
}
PackedStringArray CPPScriptLanguage::_get_comment_delimiters() const {
	PackedStringArray comment_delimiters;
	comment_delimiters.push_back("/* */");
	comment_delimiters.push_back("//");
	return comment_delimiters;
}
PackedStringArray CPPScriptLanguage::_get_doc_comment_delimiters() const {
	PackedStringArray doc_comment_delimiters;
	doc_comment_delimiters.push_back("///");
	doc_comment_delimiters.push_back("/** */");
	return doc_comment_delimiters;
}
PackedStringArray CPPScriptLanguage::_get_string_delimiters() const {
	PackedStringArray string_delimiters;
	string_delimiters.push_back("' '");
	string_delimiters.push_back("\" \"");
	return string_delimiters;
}
Ref<Script> CPPScriptLanguage::_make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const {
	CPPScript *script = memnew(CPPScript);
	return Ref<Script>(script);
}
TypedArray<Dictionary> CPPScriptLanguage::_get_built_in_templates(const StringName &p_object) const {
	return TypedArray<Dictionary>();
}
bool CPPScriptLanguage::_is_using_templates() {
	return false;
}
Dictionary CPPScriptLanguage::_validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const {
	return Dictionary();
}
String CPPScriptLanguage::_validate_path(const String &p_path) const {
	return String();
}
Object *CPPScriptLanguage::_create_script() const {
	CPPScript *script = memnew(CPPScript);
	return script;
}
bool CPPScriptLanguage::_has_named_classes() const {
	return true;
}
bool CPPScriptLanguage::_supports_builtin_mode() const {
	return true;
}
bool CPPScriptLanguage::_supports_documentation() const {
	return false;
}
bool CPPScriptLanguage::_can_inherit_from_file() const {
	return false;
}
bool CPPScriptLanguage::_can_make_function() const {
	return false;
}
int32_t CPPScriptLanguage::_find_function(const String &p_function, const String &p_code) const {
	return -1;
}
String CPPScriptLanguage::_make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const {
	return String();
}
Error CPPScriptLanguage::_open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) {
	return Error::OK;
}
bool CPPScriptLanguage::_overrides_external_editor() {
	return false;
}
Dictionary CPPScriptLanguage::_complete_code(const String &p_code, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
Dictionary CPPScriptLanguage::_lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
String CPPScriptLanguage::_auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const {
	return String();
}
void CPPScriptLanguage::_add_global_constant(const StringName &p_name, const Variant &p_value) {}
void CPPScriptLanguage::_add_named_global_constant(const StringName &p_name, const Variant &p_value) {}
void CPPScriptLanguage::_remove_named_global_constant(const StringName &p_name) {}
void CPPScriptLanguage::_thread_enter() {}
void CPPScriptLanguage::_thread_exit() {}
String CPPScriptLanguage::_debug_get_error() const {
	return String();
}
int32_t CPPScriptLanguage::_debug_get_stack_level_count() const {
	return 0;
}
int32_t CPPScriptLanguage::_debug_get_stack_level_line(int32_t p_level) const {
	return 0;
}
String CPPScriptLanguage::_debug_get_stack_level_function(int32_t p_level) const {
	return String();
}
Dictionary CPPScriptLanguage::_debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
Dictionary CPPScriptLanguage::_debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
void *CPPScriptLanguage::_debug_get_stack_level_instance(int32_t p_level) {
	return nullptr;
}
Dictionary CPPScriptLanguage::_debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
String CPPScriptLanguage::_debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) {
	return String();
}
TypedArray<Dictionary> CPPScriptLanguage::_debug_get_current_stack_info() {
	return TypedArray<Dictionary>();
}
void CPPScriptLanguage::_reload_all_scripts() {}
void CPPScriptLanguage::_reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) {}
PackedStringArray CPPScriptLanguage::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("cpp");
	array.push_back("cc");
	array.push_back("hh");
	array.push_back("h");
	array.push_back("hpp");
	return array;
}
TypedArray<Dictionary> CPPScriptLanguage::_get_public_functions() const {
	return TypedArray<Dictionary>();
}
Dictionary CPPScriptLanguage::_get_public_constants() const {
	return Dictionary();
}
TypedArray<Dictionary> CPPScriptLanguage::_get_public_annotations() const {
	return TypedArray<Dictionary>();
}
void CPPScriptLanguage::_profiling_start() {}
void CPPScriptLanguage::_profiling_stop() {}
int32_t CPPScriptLanguage::_profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
int32_t CPPScriptLanguage::_profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
void CPPScriptLanguage::_frame() {
	static bool icon_registered = register_language_icons;
	if (!icon_registered && Engine::get_singleton()->is_editor_hint()) {
		icon_registered = true;
		// Manually register CPPScript icon
		load_icon();
		// Register theme callback
		EditorInterface::get_singleton()->get_base_control()->connect("theme_changed", callable_mp(this, &CPPScriptLanguage::load_icon));
	}
}
void CPPScriptLanguage::load_icon() {
	static bool reenter = false;
	if (reenter)
		return;
	reenter = true;
	if (Engine::get_singleton()->is_editor_hint() && FileAccess::file_exists(icon_path)) {
		Ref<Theme> editor_theme = EditorInterface::get_singleton()->get_editor_theme();
		if (editor_theme.is_valid() && !editor_theme->has_icon("CPPScript", "EditorIcons"))
		{
			ResourceLoader *resource_loader = ResourceLoader::get_singleton();
			Ref<Texture2D> tex = resource_loader->load(icon_path);
			editor_theme->set_icon("CPPScript", "EditorIcons", tex);
		}
	}
	reenter = false;
}
bool CPPScriptLanguage::_handles_global_class_type(const String &p_type) const {
	return p_type == "CPPScript" || p_type == "Sandbox";
}
Dictionary CPPScriptLanguage::_get_global_class_name(const String &p_path) const {
	Dictionary dict;
	if (!p_path.is_empty()) {
		dict["name"] = CPPScript::PathToGlobalName(p_path);
		dict["base_type"] = "Sandbox";
		dict["icon_path"] = String(icon_path);
	}
	return dict;
}

```

`src/cpp/script_language_cpp.h`:

```h
#pragma once

#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>

using namespace godot;

class CPPScriptLanguage : public ScriptLanguageExtension {
	GDCLASS(CPPScriptLanguage, ScriptLanguageExtension);

protected:
	static void _bind_methods() {}
	String file;

public:
	static void init();
	static void deinit();
	static CPPScriptLanguage *get_singleton();

	virtual String _get_name() const override;
	virtual void _init() override;
	virtual String _get_type() const override;
	virtual String _get_extension() const override;
	virtual void _finish() override;
	virtual PackedStringArray _get_reserved_words() const override;
	virtual bool _is_control_flow_keyword(const String &p_keyword) const override;
	virtual PackedStringArray _get_comment_delimiters() const override;
	virtual PackedStringArray _get_doc_comment_delimiters() const override;
	virtual PackedStringArray _get_string_delimiters() const override;
	virtual Ref<Script> _make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const override;
	virtual TypedArray<Dictionary> _get_built_in_templates(const StringName &p_object) const override;
	virtual bool _is_using_templates() override;
	virtual Dictionary _validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const override;
	virtual String _validate_path(const String &p_path) const override;
	virtual Object *_create_script() const override;
	virtual bool _has_named_classes() const override;
	virtual bool _supports_builtin_mode() const override;
	virtual bool _supports_documentation() const override;
	virtual bool _can_inherit_from_file() const override;
	virtual bool _can_make_function() const override;
	virtual int32_t _find_function(const String &p_function, const String &p_code) const override;
	virtual String _make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const override;
	virtual Error _open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) override;
	virtual bool _overrides_external_editor() override;
	virtual Dictionary _complete_code(const String &p_code, const String &p_path, Object *p_owner) const override;
	virtual Dictionary _lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const override;
	virtual String _auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const override;
	virtual void _add_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _add_named_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _remove_named_global_constant(const StringName &p_name) override;
	virtual void _thread_enter() override;
	virtual void _thread_exit() override;
	virtual String _debug_get_error() const override;
	virtual int32_t _debug_get_stack_level_count() const override;
	virtual int32_t _debug_get_stack_level_line(int32_t p_level) const override;
	virtual String _debug_get_stack_level_function(int32_t p_level) const override;
	virtual Dictionary _debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual Dictionary _debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual void *_debug_get_stack_level_instance(int32_t p_level) override;
	virtual Dictionary _debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual String _debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual TypedArray<Dictionary> _debug_get_current_stack_info() override;
	virtual void _reload_all_scripts() override;
	virtual void _reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual TypedArray<Dictionary> _get_public_functions() const override;
	virtual Dictionary _get_public_constants() const override;
	virtual TypedArray<Dictionary> _get_public_annotations() const override;
	virtual void _profiling_start() override;
	virtual void _profiling_stop() override;
	virtual int32_t _profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual int32_t _profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual void _frame() override;
	virtual bool _handles_global_class_type(const String &p_type) const override;
	virtual Dictionary _get_global_class_name(const String &p_path) const override;
	void load_icon();

	CPPScriptLanguage() {}
	~CPPScriptLanguage() {}
};

```

`src/docker.cpp`:

```cpp
#include "docker.h"

#include "sandbox_project_settings.h"
#include <godot_cpp/classes/os.hpp>
#include <godot_cpp/classes/project_settings.hpp>
//#define ENABLE_TIMINGS 1
#ifdef ENABLE_TIMINGS
#include <time.h>
#endif

static constexpr bool VERBOSE_CMD = true;
using namespace godot;

static bool ContainerIsAlreadyRunning(String container_name) {
	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "container", "inspect", "-f", "{{.State.Running}}", container_name };
	Array output;
	if constexpr (VERBOSE_CMD) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	const int res = OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);
	if (res != 0) {
		return false;
	}
	const String running = output[0];
	return running.contains("true");
}

bool Docker::ContainerPullLatest(String image_name, Array &output) {
	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "pull", image_name };
	if constexpr (VERBOSE_CMD) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	const int res = OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);
	return res == 0;
}

String Docker::ContainerGetMountPath(String container_name) {
	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "inspect", "-f", "{{ (index .Mounts 0).Source }}", container_name };
	Array output;
	if constexpr (VERBOSE_CMD) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	const int res = OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);
	if (res != 0) {
		return "";
	}
	return String(output[0]).replace("\n", "");
}

bool Docker::ContainerStart(String container_name, String image_name, Array &output) {
	if (!SandboxProjectSettings::get_docker_enabled()) {
		return true;
	}
	if (ContainerIsAlreadyRunning(container_name)) {
		ProjectSettings *project_settings = ProjectSettings::get_singleton();
		// If the container mount path does not match the current project path, stop the container.
		String path = ContainerGetMountPath(container_name);
		String project_path = project_settings->globalize_path("res://");
		//printf("Container mount path: %s\n", path.utf8().get_data());
		//printf("Current project path: %s\n", project_path.utf8().get_data());
		if (!path.is_empty() && !project_path.begins_with(path)) {
			UtilityFunctions::print("Container mount path (", path, ") does not match the current project path (", project_path, "). Stopping the container.");
			Docker::ContainerStop(container_name);
		} else {
			// The container is already running and the mount path matches the current project path.
			UtilityFunctions::print("Container ", container_name, " was already running.");
			return true;
		}
	}
	// The container is not running. Try to pull the latest image.
	Array dont_care; // We don't care about the output of the image pull (for now).
	if (ContainerPullLatest(image_name, dont_care)) {
		// Delete the container if it exists. It's not running, but it might be stopped.
		ContainerDelete(container_name, dont_care);
	} else {
		WARN_PRINT("Sandbox: Failed to pull the latest container image: " + image_name);
	}
	// Start the container, even if the image pull failed. It might be locally available.
	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "run", "--name", container_name, "-dv", ".:/usr/src", image_name };
	if constexpr (VERBOSE_CMD) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	const int res = OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);
	return res == 0;
}

Array Docker::ContainerStop(String container_name) {
	if (!SandboxProjectSettings::get_docker_enabled()) {
		return Array();
	}
	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "stop", container_name, "--time", "0" };
	if constexpr (VERBOSE_CMD) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	Array output;
	OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);
	return output;
}

bool Docker::ContainerExecute(String container_name, const PackedStringArray &p_arguments, Array &output, bool verbose) {
	if (!SandboxProjectSettings::get_docker_enabled()) {
		return false;
	}
#ifdef ENABLE_TIMINGS
	timespec start;
	clock_gettime(CLOCK_MONOTONIC, &start);
#endif

	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "exec", "-t", container_name, "bash" };
	for (int i = 0; i < p_arguments.size(); i++) {
		arguments.push_back(p_arguments[i]);
	}
	if (VERBOSE_CMD && verbose) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	const int res = OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);

#ifdef ENABLE_TIMINGS
	timespec end;
	clock_gettime(CLOCK_MONOTONIC, &end);
	const double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
	fprintf(stderr, "Docker::ContainerExecute: %f seconds\n", elapsed);
#endif

	return res == 0;
}

int Docker::ContainerVersion(String container_name, const PackedStringArray &p_arguments) {
	// Execute --version in the container.
	Array output;
	if (ContainerExecute(container_name, p_arguments, output)) {
		// Docker container responds with a number, eg "1" (ASCII)
		return output[0].operator String().to_int();
	}
	return -1;
}

bool Docker::ContainerDelete(String container_name, Array &output) {
	godot::OS *OS = godot::OS::get_singleton();
	PackedStringArray arguments = { "rm", container_name };
	if constexpr (VERBOSE_CMD) {
		UtilityFunctions::print(SandboxProjectSettings::get_docker_path(), arguments);
	}
	const int res = OS->execute(SandboxProjectSettings::get_docker_path(), arguments, output);
	return res == 0;
}

```

`src/docker.h`:

```h
#pragma once

#include <godot_cpp/variant/utility_functions.hpp>
#include <godot_cpp/variant/variant.hpp>

struct Docker {
	using Array = godot::Array;
	using PackedStringArray = godot::PackedStringArray;
	using String = godot::String;

	static bool ContainerStart(String container_name, String image_name, Array &output);
	static Array ContainerStop(String container_name);
	static bool ContainerExecute(String container_name, const PackedStringArray &args, Array &output, bool verbose = true);
	static int ContainerVersion(String container_name, const PackedStringArray &args);
	static String ContainerGetMountPath(String container_name);
	static bool ContainerPullLatest(String image_name, Array &output);
	static bool ContainerDelete(String container_name, Array &output);

	static String GetFolderName(const String &path) {
		String foldername = path.replace("res://", "");
		int idx = -1;
		do {
			idx = foldername.find("/");
			if (idx != -1)
				foldername = foldername.substr(idx + 1, foldername.length());
		} while (idx != -1);
		return foldername;
	}
};

```

`src/elf/resource_loader_elf.cpp`:

```cpp
#include "resource_loader_elf.h"
#include "../sandbox.h"
#include "script_elf.h"
#include <godot_cpp/classes/file_access.hpp>
static constexpr bool VERBOSE_LOADER = false;

Variant ResourceFormatLoaderELF::_load(const String &p_path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const {
#ifdef RISCV_BINARY_TRANSLATION
	// We will automatically load .dll's or .so's with the same basename and path as the ELF file.
	String dllpath = p_path.get_basename();
# ifdef _WIN32
	dllpath += ".dll";
# elif defined(__APPLE__)
	dllpath += ".dylib";
# else
	dllpath += ".so";
# endif
	if (FileAccess::file_exists(dllpath)) {
		// Load the binary translation library.
		if (!Sandbox::load_binary_translation(dllpath, true)) {
			WARN_PRINT("Failed to auto-load binary translation library: " + dllpath);
		} else if constexpr (VERBOSE_LOADER) {
			WARN_PRINT("Auto-loaded binary translation library: " + dllpath);
		}
	} else if constexpr (VERBOSE_LOADER) {
		WARN_PRINT("Binary translation library not found: " + dllpath);
	}
#endif
	Ref<ELFScript> elf_model = memnew(ELFScript);
	elf_model->set_file(p_path);
	elf_model->reload(false);
	return elf_model;
}
PackedStringArray ResourceFormatLoaderELF::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("elf");
	return array;
}
bool ResourceFormatLoaderELF::_recognize_path(const godot::String &path, const godot::StringName &type) const {
	String el = path.get_extension().to_lower();
	if (el == "elf") {
		return true;
	}
	return false;
}
bool ResourceFormatLoaderELF::_handles_type(const StringName &type) const {
	String type_str = type;
	return type_str == "ELFScript" || type_str == "Script";
}
String ResourceFormatLoaderELF::_get_resource_type(const String &p_path) const {
	String el = p_path.get_extension().to_lower();
	if (el == "elf") {
		return "ELFScript";
	}
	return "";
}

```

`src/elf/resource_loader_elf.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_loader.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

using namespace godot;

class ResourceFormatLoaderELF : public ResourceFormatLoader {
	GDCLASS(ResourceFormatLoaderELF, ResourceFormatLoader);

protected:
	static void _bind_methods() {}

public:
	virtual Variant _load(const String &path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual bool _recognize_path(const String &path, const StringName &type) const override;
	virtual bool _handles_type(const StringName &type) const override;
	virtual String _get_resource_type(const String &p_path) const override;
};

```

`src/elf/resource_saver_elf.cpp`:

```cpp
#include "resource_saver_elf.h"
#include "../register_types.h"
#include "script_elf.h"
#include "script_language_elf.h"
#include <godot_cpp/classes/file_access.hpp>

Error ResourceFormatSaverELF::_save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) {
	// Do not save, revert instead
	Ref<ELFScript> elf_model = Object::cast_to<ELFScript>(p_resource.ptr());
	if (elf_model.is_null()) {
		return Error::OK;
	}
	elf_model->set_file(p_path);
	elf_model->reload(true);
	return Error::OK;
}
Error ResourceFormatSaverELF::_set_uid(const String &p_path, int64_t p_uid) {
	return Error::OK;
}
bool ResourceFormatSaverELF::_recognize(const Ref<Resource> &p_resource) const {
	return Object::cast_to<ELFScript>(p_resource.ptr()) != nullptr;
}
PackedStringArray ResourceFormatSaverELF::_get_recognized_extensions(const Ref<Resource> &p_resource) const {
	PackedStringArray array;
	if (Object::cast_to<ELFScript>(p_resource.ptr()) == nullptr)
		return array;
	array.push_back("elf");
	return array;
}
bool ResourceFormatSaverELF::_recognize_path(const Ref<Resource> &p_resource, const String &p_path) const {
	return Object::cast_to<ELFScript>(p_resource.ptr()) != nullptr;
}

```

`src/elf/resource_saver_elf.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_saver.hpp>
#include <godot_cpp/classes/resource_saver.hpp>

using namespace godot;

class ResourceFormatSaverELF : public ResourceFormatSaver {
	GDCLASS(ResourceFormatSaverELF, ResourceFormatSaver);

protected:
	static void _bind_methods() {}

public:
	virtual Error _save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) override;
	virtual Error _set_uid(const String &p_path, int64_t p_uid) override;
	virtual bool _recognize(const Ref<Resource> &p_resource) const override;
	virtual PackedStringArray _get_recognized_extensions(const Ref<Resource> &p_resource) const override;
	virtual bool _recognize_path(const Ref<Resource> &p_resource, const String &p_path) const override;
};

```

`src/elf/script_elf.cpp`:

```cpp
#include "script_elf.h"

#include "../cpp/script_cpp.h"
#include "../docker.h"
#include "../register_types.h"
#include "../sandbox.h"
#include "../sandbox_project_settings.h"
#include "script_instance.h"
#include "script_instance_helper.h"
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/json.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
static constexpr bool VERBOSE_ELFSCRIPT = false;

void ELFScript::_bind_methods() {
	ClassDB::bind_method(D_METHOD("get_sandbox_for", "for_object"), &ELFScript::get_sandbox_for);
	ClassDB::bind_method(D_METHOD("get_sandbox_objects"), &ELFScript::get_sandbox_objects);
	ClassDB::bind_method(D_METHOD("get_content"), &ELFScript::get_content);
}

Sandbox *ELFScript::get_sandbox_for(Object *p_for_object) const {
	for (ELFScriptInstance *instance : this->instances) {
		if (instance->get_owner() == p_for_object) {
			auto [sandbox, auto_created] = instance->get_sandbox();
			return sandbox;
		}
	}
	ERR_PRINT("ELFScript::get_sandbox_for: Sandbox not found for object " + p_for_object->get_class());
	return nullptr;
}

Array ELFScript::get_sandbox_objects() const {
	Array result;
	for (ELFScriptInstance *instance : this->instances) {
		result.push_back(instance->get_owner());
	}
	return result;
}

ELFScriptInstance *ELFScript::get_script_instance(Object *p_for_object) const {
	for (ELFScriptInstance *instance : this->instances) {
		if (instance->get_owner() == p_for_object) {
			return instance;
		}
	}
	ERR_PRINT("ELFScript::get_script_instance: Script instance not found for object " + p_for_object->get_class());
	return nullptr;
}

bool ELFScript::_editor_can_reload_from_file() {
	return true;
}
void ELFScript::_placeholder_erased(void *p_placeholder) {}
bool ELFScript::_can_instantiate() const {
	return true;
}
Ref<Script> ELFScript::_get_base_script() const {
	return Ref<Script>();
}
StringName ELFScript::_get_global_name() const {
	if (SandboxProjectSettings::use_global_sandbox_names()) {
		return global_name;
	}
	return "ELFScript";
}
bool ELFScript::_inherits_script(const Ref<Script> &p_script) const {
	return false;
}
StringName ELFScript::_get_instance_base_type() const {
	return StringName("Sandbox");
}
void *ELFScript::_instance_create(Object *p_for_object) const {
	ELFScriptInstance *instance = memnew(ELFScriptInstance(p_for_object, Ref<ELFScript>(this)));
	instances.insert(instance);
	return ScriptInstanceExtension::create_native_instance(instance);
}
void *ELFScript::_placeholder_instance_create(Object *p_for_object) const {
	return _instance_create(p_for_object);
}
bool ELFScript::_instance_has(Object *p_object) const {
	return false;
}
bool ELFScript::_has_source_code() const {
	return true;
}
String ELFScript::_get_source_code() const {
	if (source_code.is_empty()) {
		return String();
	}
	if (functions.is_empty()) {
		return JSON::stringify(function_names, "  ");
	} else {
		return JSON::stringify(functions, "  ");
	}
}
void ELFScript::_set_source_code(const String &p_code) {
}
Error ELFScript::_reload(bool p_keep_state) {
	this->source_version++;
	this->set_file(this->path);
	return Error::OK;
}
TypedArray<Dictionary> ELFScript::_get_documentation() const {
	return TypedArray<Dictionary>();
}
String ELFScript::_get_class_icon_path() const {
	return String("res://addons/godot_sandbox/Sandbox.svg");
}
bool ELFScript::_has_method(const StringName &p_method) const {
	bool result = function_names.find(p_method) != -1;
	if (!result) {
		if (p_method == StringName("_init"))
			result = true;
	}
	if constexpr (VERBOSE_ELFSCRIPT) {
		printf("ELFScript::_has_method: method %s => %s\n",
			String(p_method).utf8().ptr(), result ? "true" : "false");
	}

	return result;
}
bool ELFScript::_has_static_method(const StringName &p_method) const {
	return false;
}
Dictionary ELFScript::_get_method_info(const StringName &p_method) const {
	for (int i = 0; i < functions.size(); i++) {
		Dictionary function = functions[i];
		if (StringName(function.get("name", "")) == p_method) {
			return function;
		}
	}
	for (const String &function : function_names) {
		if (function == p_method) {
			if constexpr (VERBOSE_ELFSCRIPT) {
				printf("ELFScript::_get_method_info: method %s\n", p_method.to_ascii_buffer().ptr());
			}
			Dictionary method;
			method["name"] = function;
			method["args"] = Array();
			method["default_args"] = Array();
			Dictionary type;
			type["name"] = "type";
			type["type"] = Variant::Type::OBJECT;
			type["class_name"] = "Object";
			type["hint"] = PropertyHint::PROPERTY_HINT_NONE;
			type["hint_string"] = String("Return value");
			type["usage"] = PROPERTY_USAGE_DEFAULT;
			method["return"] = type;
			method["flags"] = METHOD_FLAG_VARARG;
			return method;
		}
	}
	return Dictionary();
}
bool ELFScript::_is_tool() const {
	return true;
}
bool ELFScript::_is_valid() const {
	return true;
}
bool ELFScript::_is_abstract() const {
	return false;
}
ScriptLanguage *ELFScript::_get_language() const {
	return get_elf_language();
}
bool ELFScript::_has_script_signal(const StringName &p_signal) const {
	return false;
}
TypedArray<Dictionary> ELFScript::_get_script_signal_list() const {
	return TypedArray<Dictionary>();
}

bool ELFScript::_has_property_default_value(const StringName &p_property) const {
	return false;
}
Variant ELFScript::_get_property_default_value(const StringName &p_property) const {
	return Variant();
}
TypedArray<Dictionary> ELFScript::_get_script_property_list() const {
	TypedArray<Dictionary> properties;
	for (const PropertyInfo &prop : Sandbox::create_sandbox_property_list()) {
		properties.push_back(prop_to_dict(prop));
	}
	return properties;
}

void ELFScript::_update_exports() {}
TypedArray<Dictionary> ELFScript::_get_script_method_list() const {
	if (!this->functions.is_empty()) {
		return functions;
	}
	TypedArray<Dictionary> functions_array;
	for (String function : function_names) {
		Dictionary method;
		method["name"] = function;
		method["args"] = Array();
		method["default_args"] = Array();
		Dictionary type;
		type["name"] = "type";
		type["type"] = Variant::Type::NIL;
		//type["class_name"] = "class";
		type["hint"] = PropertyHint::PROPERTY_HINT_NONE;
		type["hint_string"] = String();
		type["usage"] = PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NIL_IS_VARIANT;
		method["return"] = type;
		method["flags"] = METHOD_FLAG_VARARG;
		functions_array.push_back(method);
	}
	return functions_array;
}
int32_t ELFScript::_get_member_line(const StringName &p_member) const {
	PackedStringArray formatted_functions = _get_source_code().split("\n");
	for (int i = 0; i < formatted_functions.size(); i++) {
		if (formatted_functions[i].find(p_member) != -1) {
			return i + 1;
		}
	}
	return 0;
}
Dictionary ELFScript::_get_constants() const {
	return Dictionary();
}
TypedArray<StringName> ELFScript::_get_members() const {
	return TypedArray<StringName>();
}
bool ELFScript::_is_placeholder_fallback_enabled() const {
	return false;
}
Variant ELFScript::_get_rpc_config() const {
	return Variant();
}

const PackedByteArray &ELFScript::get_content() {
	return source_code;
}

String ELFScript::get_elf_programming_language() const {
	return elf_programming_language;
}

void ELFScript::set_file(const String &p_path) {
	if (p_path.is_empty()) {
		if constexpr (VERBOSE_ELFSCRIPT) {
			printf("ELFScript::set_file: Empty path provided, skipping.\n");
		}
		return;
	}
	// res://path/to/file.elf
	this->path = String(p_path);
	// path/to/file.elf as a C++ string
	CharString resless_path = p_path.replace("res://", "").utf8();
	this->std_path = std::string(resless_path.ptr(), resless_path.length());

	PackedByteArray new_source_code = FileAccess::get_file_as_bytes(this->path);
	if (new_source_code == source_code) {
		if constexpr (VERBOSE_ELFSCRIPT) {
			printf("ELFScript::set_file: No changes in %s\n", path.utf8().ptr());
		}
		return;
	} else if (new_source_code.is_empty()) {
		ERR_FAIL_MSG("ELFScript::set_file: Failed to load file '" + this->path + "'. The file is empty or does not exist.");
		return;
	}
	source_code = std::move(new_source_code);

	global_name = "Sandbox_" + path.get_basename().replace("res://", "").replace("/", "_").replace("-", "_").capitalize().replace(" ", "");
	Sandbox::BinaryInfo info = Sandbox::get_program_info_from_binary(source_code);
	this->function_names = std::move(info.functions);
	this->functions.clear();

	this->elf_programming_language = info.language;
	this->elf_api_version = info.version;

	if constexpr (VERBOSE_ELFSCRIPT) {
		printf("ELFScript::set_file: %s Sandbox instances: %u\n", std_path.c_str(), sandbox_map[path].size());
	}
	for (Sandbox *sandbox : sandbox_map[path]) {
		sandbox->set_program(Ref<ELFScript>(this));
	}

	// Update the instance methods only if functions are still empty
	if (functions.is_empty()) {
		for (ELFScriptInstance *instance : this->instances) {
			instance->update_methods();
		}
	}
}

void ELFScript::set_public_api_functions(Array &&p_functions) {
	functions = std::move(p_functions);

	if constexpr (VERBOSE_ELFSCRIPT) {
		printf("ELFScript::set_public_api_functions: %s\n", path.utf8().ptr());
	}
	this->update_public_api_functions();
}

void ELFScript::update_public_api_functions() {
	// Update the function names
	function_names.clear();
	for (int i = 0; i < functions.size(); i++) {
		Dictionary func = functions[i];
		function_names.push_back(func["name"]);
	}

	// Update the instance methods
	for (ELFScriptInstance *instance : this->instances) {
		instance->update_methods();
	}
}

String ELFScript::get_dockerized_program_path() const {
	// Get the absolute path without the file name
	String path = get_path().get_base_dir().replace("res://", "") + "/";
	String foldername = Docker::GetFolderName(get_path().get_base_dir());
	// Return the path to the folder with the name of the folder + .elf
	// Eg. res://foldername becomes foldername/foldername.elf
	return path + foldername + String(".elf");
}

```

`src/elf/script_elf.h`:

```h
#pragma once

#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language.hpp>
#include <godot_cpp/templates/hash_set.hpp>

using namespace godot;
class ELFScriptInstance;
class Sandbox;
namespace godot {
	class ScriptInstanceExtension;
}

class ELFScript : public ScriptExtension {
	GDCLASS(ELFScript, ScriptExtension);

protected:
	static void _bind_methods();
	PackedByteArray source_code;
	String global_name;
	String path;
	std::string std_path;
	int source_version = 0;
	int elf_api_version;
	String elf_programming_language;

	mutable HashSet<ELFScriptInstance *> instances;
	friend class ELFScriptInstance;
	friend class SafeGDScript;

	static inline HashMap<String, HashSet<Sandbox *>> sandbox_map;

public:
	Array functions;
	PackedStringArray function_names;

	void set_public_api_functions(Array &&p_functions);
	void update_public_api_functions();
	String get_elf_programming_language() const;
	int get_elf_api_version() const noexcept { return elf_api_version; }
	int get_source_version() const noexcept { return source_version; }
	String get_dockerized_program_path() const;
	const String &get_path() const noexcept { return path; }
	const std::string &get_std_path() const noexcept { return std_path; }

	/// @brief Retrieve a Sandbox instance based on a given owner object.
	/// @param p_for_object The owner object.
	/// @return The Sandbox instance, or nullptr if not found.
	Sandbox *get_sandbox_for(Object *p_for_object) const;

	/// @brief Retrieve all Objects that share a Sandbox instance that uses this ELF resource.
	/// @return An array of Objects that share a Sandbox instance.
	Array get_sandbox_objects() const;

	/// @brief Retrieve the content of the ELF resource as a byte array.
	/// @return An ELF program as a byte array.
	const PackedByteArray &get_content();

	/// @brief Get an ELFScript instance using a Node as the owner.
	/// @param p_for_object The owner Node.
	/// @return A reference to the ELFScript instance.
	ELFScriptInstance *get_script_instance(Object *p_for_object) const;

	void register_instance(Sandbox *p_sandbox) { sandbox_map[path].insert(p_sandbox); }
	void unregister_instance(Sandbox *p_sandbox) { sandbox_map[path].erase(p_sandbox); }

	virtual bool _editor_can_reload_from_file() override;
	virtual void _placeholder_erased(void *p_placeholder) override;
	virtual bool _can_instantiate() const override;
	virtual Ref<Script> _get_base_script() const override;
	virtual StringName _get_global_name() const override;
	virtual bool _inherits_script(const Ref<Script> &p_script) const override;
	virtual StringName _get_instance_base_type() const override;
	virtual void *_instance_create(Object *p_for_object) const override;
	virtual void *_placeholder_instance_create(Object *p_for_object) const override;
	virtual bool _instance_has(Object *p_object) const override;
	virtual bool _has_source_code() const override;
	virtual String _get_source_code() const override;
	virtual void _set_source_code(const String &p_code) override;
	virtual Error _reload(bool p_keep_state) override;
	virtual TypedArray<Dictionary> _get_documentation() const override;
	virtual String _get_class_icon_path() const override;
	virtual bool _has_method(const StringName &p_method) const override;
	virtual bool _has_static_method(const StringName &p_method) const override;
	virtual Dictionary _get_method_info(const StringName &p_method) const override;
	virtual bool _is_tool() const override;
	virtual bool _is_valid() const override;
	virtual bool _is_abstract() const override;
	virtual ScriptLanguage *_get_language() const override;
	virtual bool _has_script_signal(const StringName &p_signal) const override;
	virtual TypedArray<Dictionary> _get_script_signal_list() const override;
	virtual bool _has_property_default_value(const StringName &p_property) const override;
	virtual Variant _get_property_default_value(const StringName &p_property) const override;
	virtual void _update_exports() override;
	virtual TypedArray<Dictionary> _get_script_method_list() const override;
	virtual TypedArray<Dictionary> _get_script_property_list() const override;
	virtual int32_t _get_member_line(const StringName &p_member) const override;
	virtual Dictionary _get_constants() const override;
	virtual TypedArray<StringName> _get_members() const override;
	virtual bool _is_placeholder_fallback_enabled() const override;
	virtual Variant _get_rpc_config() const override;

	void set_file(const String &path);

	ELFScript() {}
	~ELFScript() {}
};

```

`src/elf/script_instance.cpp`:

```cpp
#include "script_instance.h"

#include "../cpp/script_cpp.h"
#include "../rust/script_rust.h"
#include "../sandbox_project_settings.h"
#include "../scoped_tree_base.h"
#include "../zig/script_zig.h"
#include "script_elf.h"
#include "script_instance_helper.h" // register_types.h
#include <godot_cpp/core/object.hpp>
#include <godot_cpp/templates/local_vector.hpp>
static constexpr bool VERBOSE_LOGGING = false;

#ifdef PLATFORM_HAS_EDITOR
static void handle_language_warnings(Array &warnings, const Ref<ELFScript> &script) {
	if (!SandboxProjectSettings::get_docker_enabled()) {
		return;
	}
	const String language = script->get_elf_programming_language();
	if (language == "C++") {
		// Check if the project is a CMake or SCons project and avoid
		// using the Docker container in that case. It's a big download.
		// This detection is cached and returns fast the second time.
		if (CPPScript::DetectCMakeOrSConsProject()) {
			return;
		}
		// Compare C++ version against Docker version
		const int docker_version = CPPScript::DockerContainerVersion();
		if (docker_version < 0) {
			warnings.push_back("C++ Docker container not found");
		} else {
			const int script_version = script->get_elf_api_version();
			if (script_version < docker_version) {
				String w = "C++ API version is newer (" + String::num_int64(script_version) + " vs " + String::num_int64(docker_version) + "), please rebuild the program";
				warnings.push_back(std::move(w));
			}
		}
	} else if (language == "Rust") {
		// Compare Rust version against Docker version
		const int docker_version = RustScript::DockerContainerVersion();
		if (docker_version < 0) {
			warnings.push_back("Rust Docker container not found");
		} else {
			const int script_version = script->get_elf_api_version();
			if (script_version < docker_version) {
				String w = "Rust API version is newer (" + String::num_int64(script_version) + " vs " + String::num_int64(docker_version) + "), please rebuild the program";
				warnings.push_back(std::move(w));
			}
		}
	} else if (language == "Zig") {
		// Compare Zig version against Docker version
		const int docker_version = ZigScript::DockerContainerVersion();
		if (docker_version < 0) {
			warnings.push_back("Zig Docker container not found");
		} else {
			const int script_version = script->get_elf_api_version();
			if (script_version < docker_version) {
				String w = "Zig API version is newer (" + String::num_int64(script_version) + " vs " + String::num_int64(docker_version) + "), please rebuild the program";
				warnings.push_back(std::move(w));
			}
		}
	}
}
#endif

bool ELFScriptInstance::set(const StringName &p_name, const Variant &p_value) {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("ELFScriptInstance::set " + p_name);
	}

	auto [sandbox, created] = get_sandbox();
	if (sandbox) {
		ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
		return sandbox->set_property(p_name, p_value);
	}

	return false;
}

bool ELFScriptInstance::get(const StringName &p_name, Variant &r_ret) const {
	static const StringName s_script("script");
	if (p_name == s_script) {
		r_ret = script;
		return true;
	}
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("ELFScriptInstance::get " + p_name);
	}

	auto [sandbox, created] = get_sandbox();
	if (sandbox) {
		ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
		return sandbox->get_property(p_name, r_ret);
	}

	return false;
}

godot::String ELFScriptInstance::to_string(bool *r_is_valid) {
	return "<ELFScript>";
}

void ELFScriptInstance::notification(int32_t p_what, bool p_reversed) {
}

Variant ELFScriptInstance::callp(
		const StringName &p_method,
		const Variant **p_args, const int p_argument_count,
		GDExtensionCallError &r_error) {
	if (script.is_null()) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("callp: script is null");
		}
		r_error.error = GDEXTENSION_CALL_ERROR_INSTANCE_IS_NULL;
		return Variant();
	}

retry_callp:
	if (script->function_names.has(p_method)) {
		if (current_sandbox && current_sandbox->has_program_loaded()) {
			// Set the Sandbox instance tree base to the owner node
			ScopedTreeBase stb(current_sandbox, godot::Object::cast_to<Node>(this->owner));
			// Perform the vmcall
			return current_sandbox->vmcall_fn(p_method, p_args, p_argument_count, r_error);
		}
	}

#ifdef PLATFORM_HAS_EDITOR
	// Handle internal methods
	if (p_method == StringName("_get_editor_name")) {
		r_error.error = GDEXTENSION_CALL_OK;
		return Variant("ELFScriptInstance");
	} else if (p_method == StringName("_hide_script_from_inspector")) {
		r_error.error = GDEXTENSION_CALL_OK;
		return false;
	} else if (p_method == StringName("_is_read_only")) {
		r_error.error = GDEXTENSION_CALL_OK;
		return false;
	} else if (p_method == StringName("_get_configuration_warnings")) {
		// Returns an array of strings with warnings about the script configuration
		Array warnings;
		if (script->function_names.is_empty()) {
			warnings.push_back("No public functions found");
		}
		if (script->get_elf_programming_language() == "Unknown") {
			warnings.push_back("Unknown programming language");
		}
		handle_language_warnings(warnings, script);
		r_error.error = GDEXTENSION_CALL_OK;
		return warnings;
	}
#endif

	// When the script instance must have a sandbox as owner,
	// use _enter_tree to get the sandbox instance.
	// Also, avoid calling internal methods.
	if (!this->auto_created_sandbox) {
		if (p_method == StringName("_enter_tree")) {
			current_sandbox->set_program(script);
		}
	}

	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("method called " + p_method);
	}

	// If the program has been loaded, but the method list has not been updated, update it and retry the vmcall
	if (!this->has_updated_methods) {
		if (current_sandbox) {
			// Only update methods if the program is already loaded
			if (current_sandbox->has_program_loaded()) {
				this->update_methods();
				goto retry_callp;
			}
		}
	}

	struct RecursiveTrap {
		bool &recursive_trap;
		RecursiveTrap(bool &trap) : recursive_trap(trap) {
			recursive_trap = true; // Set the trap
		}
		~RecursiveTrap() {
			recursive_trap = false; // Reset the trap
		}
	};

	// Try calling a method on the Sandbox instance, but only if the owner is *NOT* a Sandbox.
	// Otherwise, this will clobber the owner Sandbox instance's own methods.
	const CharString method_name = String(p_method).ascii();
	if (current_sandbox != nullptr && !recursive_trap && sandbox_functions.count(method_name.ptr()) != 0) {
		RecursiveTrap trap(this->recursive_trap);
		Array args;
		for (int i = 0; i < p_argument_count; i++) {
			args.push_back(*p_args[i]);
		}
		r_error.error = GDEXTENSION_CALL_OK;
		return current_sandbox->callv(p_method, args);
	}
	r_error.error = GDEXTENSION_CALL_ERROR_INVALID_METHOD;
	return Variant();
}

void ELFScriptInstance::update_methods() const {
	if (script.is_null()) {
		return;
	}
	this->has_updated_methods = true;
	this->methods_info.clear();

	if (script->functions.is_empty()) {
		// Fallback: Use the function names from the ELFScript
		for (const String &function : script->function_names) {
			MethodInfo method_info(
					Variant::NIL,
					StringName(function));
			this->methods_info.push_back(method_info);
		}
	} else {
		// Create highly specific MethodInfo based on 'functions' Array
		for (size_t i = 0; i < script->functions.size(); i++) {
			const Dictionary func = script->functions[i].operator Dictionary();
			this->methods_info.push_back(MethodInfo::from_dict(func));
		}
	}
}

const GDExtensionMethodInfo *ELFScriptInstance::get_method_list(uint32_t *r_count) const {
	if (script.is_null()) {
		*r_count = 0;
		return nullptr;
	}

	if (!this->has_updated_methods) {
		this->update_methods();
	}

	const int size = methods_info.size();
	GDExtensionMethodInfo *list = memnew_arr(GDExtensionMethodInfo, size);
	int i = 0;
	for (const godot::MethodInfo &method_info : methods_info) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("ELFScriptInstance::get_method_list: method " + String(method_info.name));
		}
		list[i] = create_method_info(method_info);
		i++;
	}

	*r_count = size;
	return list;
}

const GDExtensionPropertyInfo *ELFScriptInstance::get_property_list(uint32_t *r_count) const {
	auto [sandbox, auto_created] = get_sandbox();
	if (!sandbox) {
		if constexpr (VERBOSE_LOGGING) {
			printf("ELFScriptInstance::get_property_list: no sandbox\n");
		}
		*r_count = 0;
		return nullptr;
	}

	std::vector<PropertyInfo> prop_list;
	if (auto_created) {
		// This is a shared Sandbox instance that won't be able to show any properties
		// in the editor, unless we expose them here.
		prop_list = sandbox->create_sandbox_property_list();
	}

	// Sandboxed properties
	const std::vector<SandboxProperty> &properties = sandbox->get_properties();

	*r_count = properties.size() + prop_list.size();
	GDExtensionPropertyInfo *list = memnew_arr(GDExtensionPropertyInfo, *r_count + 2);
	const GDExtensionPropertyInfo *list_ptr = list;

	for (const SandboxProperty &property : properties) {
		if constexpr (VERBOSE_LOGGING) {
			printf("ELFScriptInstance::get_property_list %s\n", String(property.name()).utf8().ptr());
			fflush(stdout);
		}
		list->name = stringname_alloc(property.name());
		list->class_name = stringname_alloc("Variant");
		list->type = (GDExtensionVariantType)property.type();
		list->hint = 0;
		list->hint_string = string_alloc("");
		list->usage = PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_STORAGE | PROPERTY_USAGE_SCRIPT_VARIABLE | PROPERTY_USAGE_NIL_IS_VARIANT;
		list++;
	}
	for (int i = 0; i < prop_list.size(); i++) {
		const PropertyInfo &prop = prop_list[i];
		if constexpr (VERBOSE_LOGGING) {
			printf("ELFScriptInstance::get_property_list %s\n", String(prop.name).utf8().ptr());
			fflush(stdout);
		}
		list->name = stringname_alloc(prop.name);
		list->class_name = stringname_alloc(prop.class_name);
		list->type = (GDExtensionVariantType) int(prop.type);
		list->hint = prop.hint;
		list->hint_string = string_alloc(prop.hint_string);
		list->usage = prop.usage;
		list++;
	}

	return list_ptr;
}
void ELFScriptInstance::free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const {
	if (p_list) {
		memdelete_arr(p_list);
	}
}

Variant::Type ELFScriptInstance::get_property_type(const StringName &p_name, bool *r_is_valid) const {
	auto [sandbox, created] = get_sandbox();
	if (sandbox) {
		if (const SandboxProperty *prop = sandbox->find_property_or_null(p_name)) {
			*r_is_valid = true;
			return prop->type();
		}
	}
	*r_is_valid = false;
	return Variant::NIL;
}

void ELFScriptInstance::get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) {
}

bool ELFScriptInstance::validate_property(GDExtensionPropertyInfo &p_property) const {
	auto [sandbox, created] = get_sandbox();
	if (!sandbox) {
		if constexpr (VERBOSE_LOGGING) {
			printf("ELFScriptInstance::validate_property: no sandbox\n");
		}
		return false;
	}
	for (const SandboxProperty &property : sandbox->get_properties()) {
		if (*(StringName *)p_property.name == property.name()) {
			if constexpr (VERBOSE_LOGGING) {
				printf("ELFScriptInstance::validate_property %s => true\n", String(property.name()).utf8().ptr());
			}
			return true;
		}
	}
	if constexpr (VERBOSE_LOGGING) {
		printf("ELFScriptInstance::validate_property %s => false\n", String(*(StringName *)p_property.name).utf8().ptr());
	}
	return false;
}

GDExtensionInt ELFScriptInstance::get_method_argument_count(const StringName &p_method, bool &r_valid) const {
	r_valid = false;
	return 0;
}

bool ELFScriptInstance::has_method(const StringName &p_name) const {
	if (script.is_null()) {
		return true;
	}
	bool result = script->function_names.has(p_name);
	if (!result) {
		for (const StringName &function : godot_functions) {
			if (p_name == function) {
				result = true;
				break;
			}
		}
	}

	if constexpr (VERBOSE_LOGGING) {
		fprintf(stderr, "ELFScriptInstance::has_method %s => %d\n", String(p_name).utf8().ptr(), result);
	}
	return result;
}

void ELFScriptInstance::free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const {
	if (p_list) {
		for (uint32_t i = 0; i < p_count; i++) {
			const GDExtensionMethodInfo &method_info = p_list[i];
			if (method_info.arguments) {
				memdelete_arr(method_info.arguments);
			}
		}
		memdelete_arr(p_list);
	}
}

bool ELFScriptInstance::property_can_revert(const StringName &p_name) const {
	auto [sandbox, created] = get_sandbox();
	if (!sandbox) {
		return false;
	}
	if (const SandboxProperty *prop = sandbox->find_property_or_null(p_name)) {
		return true;
	}
	const String name = p_name;
	if (name == "references_max"
		|| name == "memory_max"
		|| name == "execution_timeout"
		|| name == "allocations_max"
		|| name == "unboxed_arguments"
		|| name == "precise_simulation"
#ifdef RISCV_LIBTCC
		|| name == "binary_translation_nbit_as"
		|| name == "binary_translation_register_caching"
#endif // RISCV_LIBTCC
		|| name == "profiling"
		|| name == "restrictions") {
		// These are default properties that can be reverted
		return true;
	}
	return false;
}

bool ELFScriptInstance::property_get_revert(const StringName &p_name, Variant &r_ret) const {
	auto [sandbox, created] = get_sandbox();
	if (!sandbox) {
		return false;
	}
	if (const SandboxProperty *prop = sandbox->find_property_or_null(p_name)) {
		r_ret = prop->default_value();
		return true;
	}
	const String name = p_name;
	if (name == "references_max") {
		r_ret = Sandbox::MAX_REFS;
		return true;
	} else if (name == "memory_max") {
		r_ret = Sandbox::MAX_VMEM;
		return true;
	} else if (name == "execution_timeout") {
		r_ret = Sandbox::MAX_INSTRUCTIONS;
		return true;
	} else if (name == "allocations_max") {
		r_ret = Sandbox::MAX_HEAP_ALLOCS;
		return true;
	} else if (name == "unboxed_arguments") {
		r_ret = true;
		return true;
	} else if (name == "precise_simulation") {
		r_ret = false;
		return true;
#ifdef RISCV_LIBTCC
	} else if (name == "binary_translation_nbit_as") {
		r_ret = false;
		return true;
	} else if (name == "binary_translation_register_caching") {
		r_ret = true;
		return true;
#endif // RISCV_LIBTCC
	} else if (name == "profiling") {
		r_ret = false;
		return true;
	} else if (name == "restrictions") {
		r_ret = false;
		return true;
	}
	return false;
}

void ELFScriptInstance::refcount_incremented() {
}

bool ELFScriptInstance::refcount_decremented() {
	return false;
}

Object *ELFScriptInstance::get_owner() {
	return owner;
}

Ref<Script> ELFScriptInstance::get_script() const {
	return script;
}

bool ELFScriptInstance::is_placeholder() const {
	return false;
}

void ELFScriptInstance::property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) {
	*r_valid = false;
}

Variant ELFScriptInstance::property_get_fallback(const StringName &p_name, bool *r_valid) {
	*r_valid = false;
	return Variant::NIL;
}

ScriptLanguage *ELFScriptInstance::_get_language() {
	return get_elf_language();
}

ELFScriptInstance::ELFScriptInstance(Object *p_owner, const Ref<ELFScript> p_script) :
		owner(p_owner), script(p_script) {
	if (godot_functions.empty()) {
		godot_functions = {
			"_get_editor_name",
			"_hide_script_from_inspector",
			"_is_read_only",
		};
		sandbox_functions = {
			"FromBuffer",
			"FromProgram",
			"load_buffer",
			"reset",
			"vmcall",
			"vmcallv",
			"vmcallable",
			"vmcallable_address",
			"set_restrictions",
			"get_restrictions",
			"add_allowed_object",
			"remove_allowed_object",
			"clear_allowed_objects",
			"set_class_allowed_callback",
			"set_object_allowed_callback",
			"set_method_allowed_callback",
			"set_property_allowed_callback",
			"set_resource_allowed_callback",
			"is_allowed_class",
			"is_allowed_object",
			"is_allowed_method",
			"is_allowed_property",
			"is_allowed_resource",
			"restrictive_callback_function",
			"set_redirect_stdout",
			"get_general_registers",
			"get_floating_point_registers",
			"set_argument_registers",
			"get_current_instruction",
			"make_resumable",
			"resume",
			"has_function",
			"address_of",
			"lookup_address",
			"generate_api",
			"download_program",
			"get_hotspots",
			"clear_hotspots",
			"emit_binary_translation",
			"load_binary_translation",
			"try_compile_binary_translation",
			"is_binary_translated",
			"set_max_refs",
			"get_max_refs",
			"set_memory_max",
			"get_memory_max",
			"set_instructions_max",
			"get_instructions_max",
			"set_allocations_max",
			"get_allocations_max",
			"set_unboxed_arguments",
			"get_unboxed_arguments",
			"set_precise_simulation",
			"get_precise_simulation",
#ifdef RISCV_LIBTCC
			"set_binary_translation_bg_compilation",
			"get_binary_translation_bg_compilation",
			"set_binary_translation_register_caching",
			"get_binary_translation_register_caching",
			"set_binary_translation_nbit_as",
			"get_binary_translation_nbit_as",
#endif // RISCV_LIBTCC
			"share_byte_array",
			"share_float32_array",
			"share_float64_array",
			"share_int32_array",
			"share_int64_array",
			"share_vec2_array",
			"share_vec3_array",
			"share_vec4_array",
			"unshare_array",
			"set_profiling",
			"get_profiling",
			"set_program",
			"get_program",
			"has_program_loaded",
			"get_heap_usage",
			"get_heap_chunk_count",
			"get_heap_allocation_counter",
			"get_heap_deallocation_counter",
			"get_exceptions",
			"get_timeouts",
			"get_calls_made",
			"get_global_calls_made",
			"get_global_exceptions",
			"get_global_timeouts",
			"get_global_instance_count",
			"get_accumulated_startup_time"
		};
	}

	this->current_sandbox = Object::cast_to<Sandbox>(p_owner);
	this->auto_created_sandbox = (this->current_sandbox == nullptr);
	if (auto_created_sandbox) {
		this->current_sandbox = create_sandbox(p_script);
		//ERR_PRINT("ELFScriptInstance: owner is not a Sandbox");
		//fprintf(stderr, "ELFScriptInstance: owner is instead a '%s'!\n", p_owner->get_class().utf8().get_data());
	}
	this->current_sandbox->set_tree_base(godot::Object::cast_to<godot::Node>(owner));

	for (const StringName &godot_function : godot_functions) {
		MethodInfo method_info = MethodInfo(
				Variant::NIL,
				godot_function);
		methods_info.push_back(method_info);
	}
}

ELFScriptInstance::~ELFScriptInstance() {
	if (this->script.is_valid()) {
		script->instances.erase(this);
	}
}

// When a Sandbox needs to be automatically created, we instead share it
// across all instances of the same script. This is done to save an
// enormous amount of memory, as each Node using an ELFScriptInstance would
// otherwise have its own Sandbox instance.
static std::unordered_map<ELFScript *, Sandbox *> sandbox_instances;

std::tuple<Sandbox *, bool> ELFScriptInstance::get_sandbox() const {
	auto it = sandbox_instances.find(this->script.ptr());
	if (it != sandbox_instances.end()) {
		return { it->second, true };
	}

	Sandbox *sandbox_ptr = Object::cast_to<Sandbox>(this->owner);
	if (sandbox_ptr != nullptr) {
		return { sandbox_ptr, false };
	}

	ERR_PRINT("ELFScriptInstance: owner is not a Sandbox");
	if constexpr (VERBOSE_LOGGING) {
		fprintf(stderr, "ELFScriptInstance: owner is instead a '%s'!\n", this->owner->get_class().utf8().get_data());
	}
	return { nullptr, false };
}

Sandbox *ELFScriptInstance::create_sandbox(const Ref<ELFScript> &p_script) {
	auto it = sandbox_instances.find(p_script.ptr());
	if (it != sandbox_instances.end()) {
		return it->second;
	}

	Sandbox *sandbox_ptr = memnew(Sandbox);
	sandbox_ptr->set_program(p_script);
	sandbox_instances.insert_or_assign(p_script.ptr(), sandbox_ptr);
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("ELFScriptInstance: created sandbox for " + Object::cast_to<Node>(owner)->get_name());
	}

	return sandbox_ptr;
}

```

`src/elf/script_instance.h`:

```h
#pragma once

#include <gdextension_interface.h>
#include <godot_cpp/classes/global_constants.hpp>
#include <godot_cpp/classes/mutex.hpp>
#include <godot_cpp/classes/ref.hpp>
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>
#include <godot_cpp/core/type_info.hpp>
#include <godot_cpp/templates/hash_map.hpp>
#include <godot_cpp/templates/hash_set.hpp>
#include <godot_cpp/templates/list.hpp>
#include <godot_cpp/templates/pair.hpp>
#include <godot_cpp/templates/self_list.hpp>
#include <godot_cpp/templates/vector.hpp>
#include <godot_cpp/variant/dictionary.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/typed_array.hpp>
#include <godot_cpp/variant/variant.hpp>

#include "../godot/script_instance.h"
#include "../sandbox.h"
using namespace godot;

class ELFScript;

class ELFScriptInstance : public ScriptInstanceExtension {
	Object *owner;
	Ref<ELFScript> script;
	Sandbox *current_sandbox = nullptr;
	mutable List<MethodInfo> methods_info;
	mutable bool has_updated_methods = false;
	bool auto_created_sandbox = false;
	bool recursive_trap = false;

	void update_methods() const;

	// Retrieve the sandbox and whether it was created automatically or not
	std::tuple<Sandbox *, bool> get_sandbox() const;
	Sandbox *create_sandbox(const Ref<ELFScript> &p_script);
	friend class ELFScript;
	friend class CPPScriptInstance;
	friend class SafeGDScriptInstance;

	static inline std::vector<StringName> godot_functions;
	static inline std::unordered_set<std::string> sandbox_functions;

public:
	bool set(const StringName &p_name, const Variant &p_value) override;
	bool get(const StringName &p_name, Variant &r_ret) const override;
	const GDExtensionPropertyInfo *get_property_list(uint32_t *r_count) const override;
	void free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const override;
	Variant::Type get_property_type(const StringName &p_name, bool *r_is_valid) const override;
	bool validate_property(GDExtensionPropertyInfo &p_property) const override;
	bool property_can_revert(const StringName &p_name) const override;
	bool property_get_revert(const StringName &p_name, Variant &r_ret) const override;
	Object *get_owner() override;
	void get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) override;
	const GDExtensionMethodInfo *get_method_list(uint32_t *r_count) const override;
	void free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const override;
	bool has_method(const StringName &p_method) const override;
	GDExtensionInt get_method_argument_count(const StringName &p_method, bool &r_valid) const override;
	Variant callp(const StringName &p_method, const Variant **p_args, int p_argcount, GDExtensionCallError &r_error) override;
	void notification(int p_notification, bool p_reversed) override;
	String to_string(bool *r_valid) override;
	void refcount_incremented() override;
	bool refcount_decremented() override;
	Ref<Script> get_script() const override;
	bool is_placeholder() const override;
	void property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) override;
	Variant property_get_fallback(const StringName &p_name, bool *r_valid) override;
	ScriptLanguage *_get_language() override;

	ELFScript *get_elf_script() const {
		return script.ptr();
	}

	ELFScriptInstance(Object *p_owner, const Ref<ELFScript> p_script);
	~ELFScriptInstance();
};

```

`src/elf/script_instance_helper.h`:

```h
#include "../register_types.h"
#include <godot_cpp/templates/local_vector.hpp>
#include <godot_cpp/templates/pair.hpp>

using namespace godot;

static int get_len_from_ptr(const void *p_ptr) {
	return *((int *)p_ptr - 1);
}

static void free_with_len(void *p_ptr) {
	memfree((int *)p_ptr - 1);
}

static void free_prop(const GDExtensionPropertyInfo &p_prop) {
	// smelly
	memdelete((StringName *)p_prop.name);
	memdelete((StringName *)p_prop.class_name);
	memdelete((String *)p_prop.hint_string);
}

static String *string_alloc(const String &p_str) {
	String *ptr = memnew(String);
	*ptr = p_str;

	return ptr;
}

static StringName *stringname_alloc(const String &p_str) {
	StringName *ptr = memnew(StringName);
	*ptr = p_str;

	return ptr;
}

static GDExtensionPropertyInfo create_property_type(const Dictionary &p_src) {
	GDExtensionPropertyInfo p_dst;
	p_dst.type = (GDExtensionVariantType) int(p_src["type"]);
	p_dst.name = stringname_alloc(p_src["name"]);
	p_dst.class_name = stringname_alloc(p_src["class_name"]);
	p_dst.hint = p_src["hint"];
	p_dst.hint_string = string_alloc(p_src["hint_string"]);
	p_dst.usage = p_src["usage"];
	return p_dst;
}

static GDExtensionMethodInfo create_method_info(const MethodInfo &method_info) {
	GDExtensionMethodInfo result{
	   .name = stringname_alloc(method_info.name),
	   .return_value = GDExtensionPropertyInfo{
			   .type = (GDExtensionVariantType)method_info.return_val.type,
			   .name = stringname_alloc(method_info.return_val.name),
			   .class_name = stringname_alloc(method_info.return_val.class_name),
			   .hint = method_info.return_val.hint,
			   .hint_string = stringname_alloc(method_info.return_val.hint_string),
			   .usage = method_info.return_val.usage },
	   .flags = method_info.flags,
	   .id = method_info.id,
	   .argument_count = (uint32_t)method_info.arguments.size(),
	   .arguments = nullptr,
	   .default_argument_count = 0,
	   .default_arguments = nullptr,
   };
   if (!method_info.arguments.empty()) {
	   result.arguments = memnew_arr(GDExtensionPropertyInfo, method_info.arguments.size());
	   for (int i = 0; i < method_info.arguments.size(); i++) {
		   const PropertyInfo &arg = method_info.arguments[i];
		   result.arguments[i] = GDExtensionPropertyInfo{
				   .type = (GDExtensionVariantType)arg.type,
				   .name = stringname_alloc(arg.name),
				   .class_name = stringname_alloc(arg.class_name),
				   .hint = arg.hint,
				   .hint_string = stringname_alloc(arg.hint_string),
				   .usage = arg.usage };
	   }
   }
   return result;
}

static void add_to_state(GDExtensionConstStringNamePtr p_name, GDExtensionConstVariantPtr p_value, void *p_userdata) {
	List<Pair<StringName, Variant>> *list = reinterpret_cast<List<Pair<StringName, Variant>> *>(p_userdata);
	list->push_back({ *(const StringName *)p_name, *(const Variant *)p_value });
}

static Dictionary prop_to_dict(const PropertyInfo &p_prop) {
	Dictionary d;
	d["name"] = p_prop.name;
	d["type"] = p_prop.type;
	d["class_name"] = p_prop.class_name;
	d["hint"] = p_prop.hint;
	d["hint_string"] = p_prop.hint_string;
	d["usage"] = p_prop.usage;
	return d;
}

static Dictionary method_to_dict(const MethodInfo &p_method) {
	Dictionary d;

	d["name"] = p_method.name;
	d["flags"] = p_method.flags;

	if (p_method.arguments.size() > 0) {
		Array args;
		for (const PropertyInfo &arg : p_method.arguments) {
			args.push_back(prop_to_dict(arg));
		}
		d["args"] = args;
	}

	if (p_method.default_arguments.size() > 0) {
		Array defaults;
		for (const Variant &value : p_method.default_arguments) {
			defaults.push_back(value);
		}
		d["default_args"] = defaults;
	}

	d["return"] = prop_to_dict(p_method.return_val);

	return d;
}

```

`src/elf/script_language_elf.cpp`:

```cpp
#include "script_language_elf.h"
#include "../script_language_common.h"
#include "script_elf.h"
#include <godot_cpp/classes/control.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/texture2d.hpp>
#include <godot_cpp/classes/theme.hpp>
static constexpr const char *icon_path = "res://addons/godot_sandbox/Sandbox.svg";

String ELFScriptLanguage::_get_name() const {
	return "ELF";
}
void ELFScriptLanguage::_init() {}
String ELFScriptLanguage::_get_type() const {
	return "ELFScript";
}
String ELFScriptLanguage::_get_extension() const {
	return "elf";
}
void ELFScriptLanguage::_finish() {}
PackedStringArray ELFScriptLanguage::_get_reserved_words() const {
	return PackedStringArray();
}
bool ELFScriptLanguage::_is_control_flow_keyword(const String &p_keyword) const {
	return false;
}
PackedStringArray ELFScriptLanguage::_get_comment_delimiters() const {
	PackedStringArray comment_delimiters;
	comment_delimiters.push_back("/* */");
	comment_delimiters.push_back("//");
	return comment_delimiters;
}
PackedStringArray ELFScriptLanguage::_get_doc_comment_delimiters() const {
	PackedStringArray doc_comment_delimiters;
	doc_comment_delimiters.push_back("///");
	doc_comment_delimiters.push_back("/** */");
	return doc_comment_delimiters;
}
PackedStringArray ELFScriptLanguage::_get_string_delimiters() const {
	PackedStringArray string_delimiters;
	string_delimiters.push_back("' '");
	string_delimiters.push_back("\" \"");
	return string_delimiters;
}
Ref<Script> ELFScriptLanguage::_make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const {
	ELFScript *elf_script = memnew(ELFScript);
	return Ref<Script>(elf_script);
}
TypedArray<Dictionary> ELFScriptLanguage::_get_built_in_templates(const StringName &p_object) const {
	return TypedArray<Dictionary>();
}
bool ELFScriptLanguage::_is_using_templates() {
	return false;
}
Dictionary ELFScriptLanguage::_validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const {
	return Dictionary();
}
String ELFScriptLanguage::_validate_path(const String &p_path) const {
	return String();
}
Object *ELFScriptLanguage::_create_script() const {
	ELFScript *script = memnew(ELFScript);
	return script;
}
bool ELFScriptLanguage::_has_named_classes() const {
	return true;
}
bool ELFScriptLanguage::_supports_builtin_mode() const {
	return true;
}
bool ELFScriptLanguage::_supports_documentation() const {
	return false;
}
bool ELFScriptLanguage::_can_inherit_from_file() const {
	return false;
}
bool ELFScriptLanguage::_can_make_function() const {
	return false;
}
int32_t ELFScriptLanguage::_find_function(const String &p_function, const String &p_code) const {
	return -1;
}
String ELFScriptLanguage::_make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const {
	return String();
}
Error ELFScriptLanguage::_open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) {
	return Error::OK;
}
bool ELFScriptLanguage::_overrides_external_editor() {
	return false;
}
Dictionary ELFScriptLanguage::_complete_code(const String &p_code, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
Dictionary ELFScriptLanguage::_lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
String ELFScriptLanguage::_auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const {
	return String();
}
void ELFScriptLanguage::_add_global_constant(const StringName &p_name, const Variant &p_value) {}
void ELFScriptLanguage::_add_named_global_constant(const StringName &p_name, const Variant &p_value) {}
void ELFScriptLanguage::_remove_named_global_constant(const StringName &p_name) {}
void ELFScriptLanguage::_thread_enter() {}
void ELFScriptLanguage::_thread_exit() {}
String ELFScriptLanguage::_debug_get_error() const {
	return String();
}
int32_t ELFScriptLanguage::_debug_get_stack_level_count() const {
	return 0;
}
int32_t ELFScriptLanguage::_debug_get_stack_level_line(int32_t p_level) const {
	return 0;
}
String ELFScriptLanguage::_debug_get_stack_level_function(int32_t p_level) const {
	return String();
}
Dictionary ELFScriptLanguage::_debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
Dictionary ELFScriptLanguage::_debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
void *ELFScriptLanguage::_debug_get_stack_level_instance(int32_t p_level) {
	return nullptr;
}
Dictionary ELFScriptLanguage::_debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
String ELFScriptLanguage::_debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) {
	return String();
}
TypedArray<Dictionary> ELFScriptLanguage::_debug_get_current_stack_info() {
	return TypedArray<Dictionary>();
}
void ELFScriptLanguage::_reload_all_scripts() {}
void ELFScriptLanguage::_reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) {}
PackedStringArray ELFScriptLanguage::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("elf");
	return array;
}
TypedArray<Dictionary> ELFScriptLanguage::_get_public_functions() const {
	return TypedArray<Dictionary>();
}
Dictionary ELFScriptLanguage::_get_public_constants() const {
	return Dictionary();
}
TypedArray<Dictionary> ELFScriptLanguage::_get_public_annotations() const {
	return TypedArray<Dictionary>();
}
void ELFScriptLanguage::_profiling_start() {}
void ELFScriptLanguage::_profiling_stop() {}
int32_t ELFScriptLanguage::_profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
int32_t ELFScriptLanguage::_profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
void ELFScriptLanguage::_frame() {
	static bool icon_registered = register_language_icons;
	if (!icon_registered && Engine::get_singleton()->is_editor_hint()) {
		icon_registered = true;
		// Manually register ELFScript icon
		load_icon();
		// Register theme callback
		EditorInterface::get_singleton()->get_base_control()->connect("theme_changed", callable_mp(this, &ELFScriptLanguage::load_icon));
	}
}
void ELFScriptLanguage::load_icon() {
	static bool reenter = false;
	if (reenter)
		return;
	reenter = true;
	if (Engine::get_singleton()->is_editor_hint() && FileAccess::file_exists(icon_path)) {
		Ref<Theme> editor_theme = EditorInterface::get_singleton()->get_editor_theme();
		if (editor_theme.is_valid() && !editor_theme->has_icon("ELFScript", "EditorIcons")) {
			ResourceLoader *resource_loader = ResourceLoader::get_singleton();
			Ref<Texture2D> tex = resource_loader->load(icon_path);
			editor_theme->set_icon("ELFScript", "EditorIcons", tex);
		}
	}
	reenter = false;
}
bool ELFScriptLanguage::_handles_global_class_type(const String &p_type) const {
	return p_type == "ELFScript" || p_type == "Sandbox";
}
Dictionary ELFScriptLanguage::_get_global_class_name(const String &p_path) const {
	Ref<Resource> resource = ResourceLoader::get_singleton()->load(p_path);
	Ref<ELFScript> elf_model = Object::cast_to<ELFScript>(resource.ptr());
	Dictionary dict;
	if (elf_model.is_valid()) {
		dict["name"] = elf_model->_get_global_name();
		dict["base_type"] = "Sandbox";
		dict["icon_path"] = String("res://addons/godot_sandbox/Sandbox.svg");
	}
	return dict;
}

```

`src/elf/script_language_elf.h`:

```h
#pragma once

#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>

using namespace godot;

class ELFScriptLanguage : public ScriptLanguageExtension {
	GDCLASS(ELFScriptLanguage, ScriptLanguageExtension);

protected:
	static void _bind_methods() {}
	String file;

public:
	virtual String _get_name() const override;
	virtual void _init() override;
	virtual String _get_type() const override;
	virtual String _get_extension() const override;
	virtual void _finish() override;
	virtual PackedStringArray _get_reserved_words() const override;
	virtual bool _is_control_flow_keyword(const String &p_keyword) const override;
	virtual PackedStringArray _get_comment_delimiters() const override;
	virtual PackedStringArray _get_doc_comment_delimiters() const override;
	virtual PackedStringArray _get_string_delimiters() const override;
	virtual Ref<Script> _make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const override;
	virtual TypedArray<Dictionary> _get_built_in_templates(const StringName &p_object) const override;
	virtual bool _is_using_templates() override;
	virtual Dictionary _validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const override;
	virtual String _validate_path(const String &p_path) const override;
	virtual Object *_create_script() const override;
	virtual bool _has_named_classes() const override;
	virtual bool _supports_builtin_mode() const override;
	virtual bool _supports_documentation() const override;
	virtual bool _can_inherit_from_file() const override;
	virtual bool _can_make_function() const override;
	virtual int32_t _find_function(const String &p_function, const String &p_code) const override;
	virtual String _make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const override;
	virtual Error _open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) override;
	virtual bool _overrides_external_editor() override;
	virtual Dictionary _complete_code(const String &p_code, const String &p_path, Object *p_owner) const override;
	virtual Dictionary _lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const override;
	virtual String _auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const override;
	virtual void _add_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _add_named_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _remove_named_global_constant(const StringName &p_name) override;
	virtual void _thread_enter() override;
	virtual void _thread_exit() override;
	virtual String _debug_get_error() const override;
	virtual int32_t _debug_get_stack_level_count() const override;
	virtual int32_t _debug_get_stack_level_line(int32_t p_level) const override;
	virtual String _debug_get_stack_level_function(int32_t p_level) const override;
	virtual Dictionary _debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual Dictionary _debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual void *_debug_get_stack_level_instance(int32_t p_level) override;
	virtual Dictionary _debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual String _debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual TypedArray<Dictionary> _debug_get_current_stack_info() override;
	virtual void _reload_all_scripts() override;
	virtual void _reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual TypedArray<Dictionary> _get_public_functions() const override;
	virtual Dictionary _get_public_constants() const override;
	virtual TypedArray<Dictionary> _get_public_annotations() const override;
	virtual void _profiling_start() override;
	virtual void _profiling_stop() override;
	virtual int32_t _profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual int32_t _profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual void _frame() override;
	virtual bool _handles_global_class_type(const String &p_type) const override;
	virtual Dictionary _get_global_class_name(const String &p_path) const override;
	void load_icon();

	ELFScriptLanguage() {}
	~ELFScriptLanguage() {}
};

```

`src/gdscript/compiler/CMakeLists.txt`:

```txt
# GDScript to RISC-V Compiler
cmake_minimum_required(VERSION 3.10)

project(gdscript_compiler)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Compiler sources
set(COMPILER_SOURCES
    compiler_exception.cpp
    token.cpp
    lexer.cpp
    parser.cpp
    ir.cpp
    ir_optimizer.cpp
    codegen.cpp
    riscv_codegen.cpp
    register_allocator.cpp
    elf_builder.cpp
    compiler.cpp
    ir_interpreter.cpp
)

# Build as library
add_library(gdscript_compiler STATIC ${COMPILER_SOURCES})
target_include_directories(gdscript_compiler PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# Build demo executable
add_executable(gdscript_compiler_test test_compiler.cpp)
target_link_libraries(gdscript_compiler_test gdscript_compiler)

function(add_gdscript_test test_name test_source)
	add_executable(${test_name} ${test_source})
	target_compile_options(${test_name} PUBLIC -fsanitize=address,undefined)
	target_link_libraries(${test_name} -fsanitize=address,undefined gdscript_compiler)
	add_test(NAME ${test_name} COMMAND ${test_name})
endfunction()

# Dump IR utility
add_executable(dump_ir dump_ir.cpp)
target_link_libraries(dump_ir -static gdscript_compiler)

# GDScript to RISC-V disassembly tool
add_executable(gdscript_to_riscv gdscript_to_riscv.cpp)
target_link_libraries(gdscript_to_riscv -static gdscript_compiler)

if (BUILD_TESTING)
	enable_testing()

	add_gdscript_test(test_lexer tests/test_lexer.cpp)
	add_gdscript_test(test_parser tests/test_parser.cpp)
	add_gdscript_test(test_codegen tests/test_codegen.cpp)
	add_gdscript_test(test_integration tests/test_integration.cpp)
	add_gdscript_test(test_primitives tests/test_primitives.cpp)
	add_gdscript_test(test_compilation tests/test_compilation.cpp)
	add_gdscript_test(test_constant_pool tests/test_constant_pool.cpp)
	add_gdscript_test(test_ir_optimizer tests/test_ir_optimizer.cpp)

	# Run all tests target
	add_custom_target(run_tests
		COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure
		DEPENDS test_lexer test_parser test_codegen test_integration test_primitives test_compilation test_constant_pool test_ir_optimizer
		COMMENT "Running all GDScript compiler tests"
	)

	# Install test targets (only when BUILD_TESTING is ON)
	install(TARGETS test_lexer test_parser test_codegen test_integration test_primitives test_compilation test_constant_pool test_ir_optimizer
	        RUNTIME DESTINATION bin)
endif()

# Install targets (always built)
install(TARGETS gdscript_compiler gdscript_compiler_test
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

```

`src/gdscript/compiler/OPTIMIZATIONS.md`:

```md
# GDScript Compiler IR Optimizations

This document describes the IR-level optimizations implemented in the GDScript-to-RISC-V compiler, along with planned future optimizations.

## Overview

The optimizer operates on the intermediate representation (IR) before RISC-V code generation. Multiple optimization passes run iteratively to reduce code size, eliminate redundancy, and improve runtime performance.

## Currently Implemented Optimizations

### 1. Constant Folding
**Status:** âœ… Implemented
**Safety:** Very Safe
**Impact:** Medium

Evaluates constant expressions at compile time instead of runtime.

**Example:**
```gdscript
var x = 5 + 10  # Compiled as: x = 15
var y = 2.0 * 3.0  # Compiled as: y = 6.0
```

**IR Transformation:**
```
Before:
  LOAD_IMM r1, 5
  LOAD_IMM r2, 10
  ADD r0, r1, r2

After:
  LOAD_IMM r0, 15
```

**Details:**
- Handles integer and float arithmetic
- Supports comparison operations
- Respects GDScript type promotion (int + float â†’ float)
- Avoids division by zero

### 2. Copy Propagation
**Status:** âœ… Implemented
**Safety:** Very Safe
**Impact:** Low-Medium

Eliminates redundant MOVE instructions after constant loads.

**IR Transformation:**
```
Before:
  LOAD_IMM r0, 5
  MOVE r1, r0
  # r0 never used again
  ADD r2, r1, r3

After:
  LOAD_IMM r1, 5
  ADD r2, r1, r3
```

### 3. Enhanced Copy Propagation
**Status:** âœ… Implemented (New!)
**Safety:** Very Safe
**Impact:** Medium

Advanced copy propagation that tracks copy chains and propagates sources through uses.

**Example:**
```gdscript
var a = x
var b = a
return b  # Can use x directly
```

**IR Transformation:**
```
Before:
  MOVE r1, r0
  CMP_LT r3, r1, r2  # Uses r1

After:
  MOVE r1, r0
  CMP_LT r3, r0, r2  # Uses r0 directly
```

**Details:**
- Follows copy chains to original source
- Verifies source register hasn't been modified
- Clears tracking at control flow boundaries
- Handles special case for BRANCH_ZERO/BRANCH_NOT_ZERO

### 4. Loop-Invariant Code Motion (LICM)
**Status:** âœ… Implemented (New!)
**Safety:** Safe
**Impact:** High (for simple loops)
**Limitation:** Currently disabled for functions with nested loops

Moves loop-invariant computations outside of loops to avoid redundant execution.

**Example:**
```gdscript
while i < 10:  # "10" is loop-invariant
    i = i + 1  # "1" is loop-invariant
```

**IR Transformation:**
```
Before:
  LABEL @loop
    LOAD_IMM r2, 10     # Executed every iteration
    CMP_LT r3, r1, r2
    BRANCH_ZERO r3, @end
    LOAD_IMM r5, 1      # Executed every iteration
    ADD r0, r0, r5
    JUMP @loop
  LABEL @end

After:
  LOAD_IMM r2, 10       # Hoisted out
  LOAD_IMM r5, 1        # Hoisted out
  LABEL @loop
    CMP_LT r3, r1, r2
    BRANCH_ZERO r3, @end
    ADD r0, r0, r5
    JUMP @loop
  LABEL @end
```

**Details:**
- Identifies loops via back edges (JUMP to earlier labels)
- Only hoists pure operations (LOAD_IMM, LOAD_FLOAT_IMM, LOAD_BOOL, LOAD_STRING, MOVE)
- Verifies destination register not read before definition
- Verifies source registers not modified anywhere in loop
- Iteratively finds transitive invariants
- **Skips entire function if any nested loops detected** (conservative approach to avoid hoisting past wrong loop headers)

### 5. Peephole Optimization
**Status:** âœ… Implemented
**Safety:** Very Safe
**Impact:** Medium

Pattern-based local optimizations on small instruction windows.

**Patterns:**
- Eliminate self-moves: `MOVE r0, r0` â†’ *removed*
- Collapse move chains around operations
- Remove redundant move pairs: `MOVE r1, r0; MOVE r0, r1` â†’ *removed*
- Optimize common patterns like `count = count + 1`

### 6. Redundant Store Elimination
**Status:** âœ… Implemented
**Safety:** Safe
**Impact:** Low-Medium

Removes dead stores and consecutive identical stores.

**Example:**
```
LOAD_IMM r0, 10
LOAD_IMM r0, 20  # First store is dead

â†’

LOAD_IMM r0, 20
```

### 7. Dead Code Elimination
**Status:** âœ… Implemented
**Safety:** Conservative (safe)
**Impact:** Low

Removes instructions that produce unused values.

**Details:**
- Only eliminates truly pure operations (LOAD_IMM, LOAD_BOOL)
- Conservative to avoid breaking control flow or side effects
- Tracks live registers through the function

## Planned Future Optimizations

### 8. Common Subexpression Elimination (CSE)
**Status:** ğŸ”œ Planned
**Safety:** Safe
**Impact:** Medium
**Priority:** High

Detect and reuse previously computed values.

**Example:**
```
ADD r1, r0, r2
...
ADD r3, r0, r2  # Same computation

â†’

ADD r1, r0, r2
...
MOVE r3, r1     # Reuse
```

**Implementation Notes:**
- Track available expressions with their result registers
- Invalidate on register writes
- Only for pure operations

### 9. Strength Reduction
**Status:** ğŸ”œ Planned
**Safety:** Moderate (requires type hints)
**Impact:** Medium
**Priority:** Medium

Replace expensive operations with cheaper equivalents.

**Examples:**
```
MUL r0, r1, 2   â†’  ADD r0, r1, r1    (for type-hinted ints)
DIV r0, r1, 4   â†’  SRA r0, r1, 2     (for type-hinted ints)
MUL r0, r1, 0   â†’  LOAD_IMM r0, 0
```

**Implementation Notes:**
- Only safe with proper type hints
- Must respect GDScript semantics (int vs float)
- Be careful with overflow/underflow

### 10. Algebraic Simplifications
**Status:** ğŸ”œ Planned
**Safety:** Very Safe
**Impact:** Low-Medium
**Priority:** Medium

Apply algebraic identities to simplify expressions.

**Examples:**
```
ADD r0, r1, 0    â†’  MOVE r0, r1
MUL r0, r1, 1    â†’  MOVE r0, r1
MUL r0, r1, 0    â†’  LOAD_IMM r0, 0
SUB r0, r1, 0    â†’  MOVE r0, r1
```

**Implementation Notes:**
- Very safe for integers
- Be careful with NaN/infinity for floats

### 11. Branch Simplification
**Status:** ğŸ”œ Planned
**Safety:** Safe
**Impact:** Low
**Priority:** Low

Simplify redundant branch patterns.

**Example:**
```
CMP_LT r0, r1, r2
BRANCH_ZERO r0, @skip
LOAD_BOOL r0, 1
JUMP @cont
LABEL @skip
LOAD_BOOL r0, 0
LABEL @cont

â†’

CMP_LT r0, r1, r2  # Already produces bool
```

### 12. Dead Label Elimination
**Status:** ğŸ”œ Planned
**Safety:** Very Safe
**Impact:** Low (code size only)
**Priority:** Low

Remove labels that are never jumped to.

**Implementation:**
- Scan all JUMP/BRANCH instructions for target labels
- Remove unreferenced labels

### 13. Type-Hint Propagation
**Status:** ğŸ”œ Planned
**Safety:** Safe
**Impact:** Medium (enables other opts)
**Priority:** High

Track and propagate type hints through the IR.

**Example:**
```
LOAD_IMM r0, 5        # Mark as INT
LOAD_IMM r1, 10       # Mark as INT
ADD r2, r0, r1        # Propagate INT type hint
```

**Benefits:**
- Enables strength reduction
- Allows specialized codegen for known types
- Can skip dynamic type checks in VEVAL

### 14. Safe Register Renumbering
**Status:** ğŸ”œ Planned
**Safety:** Moderate (must preserve ABI)
**Impact:** Low (reduces stack frame size)
**Priority:** Low

Compact virtual register numbering while preserving calling convention.

**Current Issue:**
The existing `reduce_register_pressure()` is disabled because it breaks the calling convention (parameters in r0-r6, return in r0).

**Implementation Plan:**
- Preserve r0-r6 for parameters and return value
- Only renumber temporary registers (r7+)
- Track register lifetime intervals
- Compact non-overlapping lifetimes

### 15. Induction Variable Optimization
**Status:** ğŸ”œ Planned
**Safety:** Moderate
**Impact:** High (for counted loops)
**Priority:** Medium

Optimize loop counter variables.

**Example:**
```gdscript
for i in range(10):
    array[i] = i * 2
```

**Optimizations:**
- Strength reduction: `i * 2` â†’ increment by 2
- Dead code elimination if induction variable unused after loop

### 16. Load/Store Coalescing
**Status:** ğŸ”œ Planned
**Safety:** Safe
**Impact:** Medium
**Priority:** Medium

Merge adjacent stack operations targeting the same Variant.

**Already partially implemented** in `eliminate_redundant_stores()` but could be enhanced.

## Optimization Pipeline Order

The optimizations run in this order (with iteration):

1. **Constant Folding** - Enables downstream optimizations
2. **Copy Propagation** - Basic cleanup
3. **Enhanced Copy Propagation** - Advanced cleanup
4. **Loop-Invariant Code Motion** - Hoist invariants
5. **Peephole Optimization** - Local patterns
6. **Peephole Optimization** - Second pass for new patterns
7. **Redundant Store Elimination** - Before dead code
8. **Peephole Optimization** - Final cleanup
9. **Dead Code Elimination** - Remove unused code

## Why Register Allocation Doesn't Help (Currently)

The compiler has a sophisticated register allocator that assigns 18 physical RISC-V registers (t0-t6, s1-s11) to virtual registers. However, **the RISC-V codegen is entirely stack-based and ignores these allocations**.

### Current Codegen Approach

All operations:
1. Load Variants from stack
2. Operate using only `t0` as scratch register
3. Store results back to stack

**Example from generated assembly:**
```asm
ld   t0, 24(sp)      # Load from stack
sd   t0, 48(sp)      # Store to stack
ld   t0, 32(sp)      # Load from stack
sd   t0, 56(sp)      # Store to stack
# ... only t0 is used!
```

### Why This Approach Was Chosen

The Variant ABI is complex:
- Variants are 24 bytes (type + padding + 16-byte data)
- Register passing would require unpacking/packing
- System calls operate on Variant pointers (stack addresses)
- Using `vmcallv()` keeps everything Variant-based

### Future: Register-Based Codegen

A future optimization could leverage register allocation for:
- **Type-hinted scalars**: Keep int/float in registers directly
- **Reference tracking**: Keep object IDs in registers
- **Specialized operations**: Fast paths for known types

This would require:
- Type hint propagation (planned optimization #13)
- Specialized IR opcodes for typed operations
- Codegen that generates different code for hinted vs dynamic paths

## Performance Notes

### Optimization Impact on Loop Performance

For a simple counting loop (`while i < 10: i = i + 1`):
- **LICM** reduces per-iteration instruction count by ~20%
- **Enhanced copy propagation** eliminates redundant MOVE instructions
- Combined: Significant reduction in loop overhead

### Current Bottleneck

The main bottleneck is the stack-based Variant codegen, not the IR optimizations. Future work should focus on:
1. Type-hint propagation
2. Specialized codegen for hinted types
3. Register-based fast paths

## Contributing

When adding new optimizations:

1. **Safety First**: Ensure the optimization preserves semantics
2. **Add Tests**: Both unit tests (CMake) and integration tests
3. **Document**: Update this file with examples and impact analysis
4. **Benchmark**: Measure actual performance impact
5. **Iterate**: Consider interaction with existing passes

## References

- Variant ABI: `program/cpp/docker/api/variant.hpp`
- IR Definition: `ir.h`
- Optimizer: `ir_optimizer.{h,cpp}`
- Codegen: `riscv_codegen.cpp`
- Register Allocator: `register_allocator.{h,cpp}` (currently unused by codegen)

```

`src/gdscript/compiler/ast.h`:

```h
#pragma once
#include <memory>
#include <vector>
#include <string>
#include <variant>

namespace gdscript {

// Forward declarations
struct Expr;
struct Stmt;

using ExprPtr = std::unique_ptr<Expr>;
using StmtPtr = std::unique_ptr<Stmt>;

// Expression base class
struct Expr {
	virtual ~Expr() = default;
	int line = 0;
	int column = 0;
};

// Literal expression: 42, 3.14, "hello", true, false, null
struct LiteralExpr : Expr {
	enum class Type { INTEGER, FLOAT, STRING, BOOL, NULL_VAL };
	Type lit_type;
	std::variant<int64_t, double, std::string, bool> value;

	LiteralExpr(int64_t v) : lit_type(Type::INTEGER), value(v) {}
	LiteralExpr(double v) : lit_type(Type::FLOAT), value(v) {}
	LiteralExpr(std::string v) : lit_type(Type::STRING), value(std::move(v)) {}
	LiteralExpr(bool v) : lit_type(Type::BOOL), value(v) {}
	static std::unique_ptr<LiteralExpr> null() {
		auto expr = std::make_unique<LiteralExpr>(false);
		expr->lit_type = Type::NULL_VAL;
		return expr;
	}
};

// Variable reference: x
struct VariableExpr : Expr {
	std::string name;
	explicit VariableExpr(std::string n) : name(std::move(n)) {}
};

// Binary operation: a + b, x * y
struct BinaryExpr : Expr {
	enum class Op {
		ADD, SUB, MUL, DIV, MOD,
		EQ, NEQ, LT, LTE, GT, GTE,
		AND, OR
	};

	ExprPtr left;
	Op op;
	ExprPtr right;

	BinaryExpr(ExprPtr l, Op o, ExprPtr r)
		: left(std::move(l)), op(o), right(std::move(r)) {}
};

// Unary operation: -x, not y
struct UnaryExpr : Expr {
	enum class Op { NEG, NOT };

	Op op;
	ExprPtr operand;

	UnaryExpr(Op o, ExprPtr e) : op(o), operand(std::move(e)) {}
};

// Function call: foo(1, 2, 3)
struct CallExpr : Expr {
	std::string function_name;
	std::vector<ExprPtr> arguments;

	CallExpr(std::string name, std::vector<ExprPtr> args)
		: function_name(std::move(name)), arguments(std::move(args)) {}
};

// Member access: obj.method(args) or obj.property
struct MemberCallExpr : Expr {
	ExprPtr object;
	std::string member_name;
	std::vector<ExprPtr> arguments; // Empty if property access
	bool is_method_call = false;    // true if this is obj.method(), false if obj.property

	MemberCallExpr(ExprPtr obj, std::string name, std::vector<ExprPtr> args = {}, bool is_method = false)
		: object(std::move(obj)), member_name(std::move(name)), arguments(std::move(args)), is_method_call(is_method) {}
};

// Array index: arr[0]
struct IndexExpr : Expr {
	ExprPtr object;
	ExprPtr index;

	IndexExpr(ExprPtr obj, ExprPtr idx)
		: object(std::move(obj)), index(std::move(idx)) {}
};

// Array literal: [1, 2, 3]
struct ArrayLiteralExpr : Expr {
	std::vector<ExprPtr> elements;

	explicit ArrayLiteralExpr(std::vector<ExprPtr> elems)
		: elements(std::move(elems)) {}
};

// Dictionary literal: {"key": "value", "num": 42}
struct DictionaryLiteralExpr : Expr {
	// Key-value pairs
	std::vector<std::pair<ExprPtr, ExprPtr>> elements;

	explicit DictionaryLiteralExpr(std::vector<std::pair<ExprPtr, ExprPtr>> elems)
		: elements(std::move(elems)) {}
};

// Statement base class
struct Stmt {
	virtual ~Stmt() = default;
	int line = 0;
	int column = 0;
};

// Expression statement: print("hello")
struct ExprStmt : Stmt {
	ExprPtr expression;
	explicit ExprStmt(ExprPtr e) : expression(std::move(e)) {}
};

// Variable declaration: var x = 10 or const x = 10
struct VarDeclStmt : Stmt {
	std::string name;
	std::string type_hint;  // Type annotation if present (e.g., "int", "float", "String")
	ExprPtr initializer; // Can be null
	bool is_const = false; // Whether this is a const declaration
	bool is_property = false; // Whether this is an exported property (@export)

	VarDeclStmt(std::string n, ExprPtr init = nullptr, bool const_flag = false)
		: name(std::move(n)), initializer(std::move(init)), is_const(const_flag) {}
};

// Assignment: x = 42 or arr[0] = 42
struct AssignStmt : Stmt {
	std::string name;        // For simple variable assignment
	ExprPtr target;          // For indexed assignment (IndexExpr)
	ExprPtr value;

	// Simple variable assignment
	AssignStmt(std::string n, ExprPtr v)
		: name(std::move(n)), target(nullptr), value(std::move(v)) {}

	// Indexed assignment (e.g., arr[0] = value)
	AssignStmt(ExprPtr t, ExprPtr v)
		: name(""), target(std::move(t)), value(std::move(v)) {}
};

// Return statement: return x
struct ReturnStmt : Stmt {
	ExprPtr value; // Can be null for bare return

	explicit ReturnStmt(ExprPtr v = nullptr) : value(std::move(v)) {}
};

// If statement
struct IfStmt : Stmt {
	ExprPtr condition;
	std::vector<StmtPtr> then_branch;
	std::vector<StmtPtr> else_branch; // Can be empty

	IfStmt(ExprPtr cond, std::vector<StmtPtr> then_b, std::vector<StmtPtr> else_b = {})
		: condition(std::move(cond)), then_branch(std::move(then_b)), else_branch(std::move(else_b)) {}
};

// While statement
struct WhileStmt : Stmt {
	ExprPtr condition;
	std::vector<StmtPtr> body;

	WhileStmt(ExprPtr cond, std::vector<StmtPtr> b)
		: condition(std::move(cond)), body(std::move(b)) {}
};

// For statement: for variable in iterable:
struct ForStmt : Stmt {
	std::string variable;  // Loop variable name
	ExprPtr iterable;      // Expression to iterate over (e.g., range(10))
	std::vector<StmtPtr> body;

	ForStmt(std::string var, ExprPtr iter, std::vector<StmtPtr> b)
		: variable(std::move(var)), iterable(std::move(iter)), body(std::move(b)) {}
};

// Break statement
struct BreakStmt : Stmt {};

// Continue statement
struct ContinueStmt : Stmt {};

// Pass statement (no-op)
struct PassStmt : Stmt {};

// Function parameter
struct Parameter {
	std::string name;
	std::string type_hint;  // Type annotation if present (e.g., "int", "float", "String")
};

// Function declaration
struct FunctionDecl {
	std::string name;
	std::vector<Parameter> parameters;
	std::string return_type;  // Return type annotation if present (e.g., "void", "int")
	std::vector<StmtPtr> body;
	int line = 0;
	int column = 0;
};

// Top-level program
struct Program {
	std::vector<VarDeclStmt> globals; // Global variable declarations
	std::vector<FunctionDecl> functions;
};

} // namespace gdscript

```

`src/gdscript/compiler/codegen.cpp`:

```cpp
#include "codegen.h"
#include "compiler_exception.h"
#include <stdexcept>
#include <sstream>
#include <cstring>

namespace gdscript {

// Helper function to convert type hint string to Variant::Type
static IRInstruction::TypeHint type_hint_from_string(const std::string& type_str) {
	// Basic types
	if (type_str == "int") {
		return Variant::INT;
	} else if (type_str == "float") {
		return Variant::FLOAT;
	} else if (type_str == "bool") {
		return Variant::BOOL;
	} else if (type_str == "String") {
		return Variant::STRING;
	} else if (type_str == "StringName") {
		return Variant::STRING_NAME;
	} else if (type_str == "NodePath") {
		return Variant::NODE_PATH;
	}

	// Math types
	else if (type_str == "Vector2") {
		return Variant::VECTOR2;
	} else if (type_str == "Vector2i") {
		return Variant::VECTOR2I;
	} else if (type_str == "Vector3") {
		return Variant::VECTOR3;
	} else if (type_str == "Vector3i") {
		return Variant::VECTOR3I;
	} else if (type_str == "Vector4") {
		return Variant::VECTOR4;
	} else if (type_str == "Vector4i") {
		return Variant::VECTOR4I;
	} else if (type_str == "Rect2") {
		return Variant::RECT2;
	} else if (type_str == "Rect2i") {
		return Variant::RECT2I;
	} else if (type_str == "Transform2D") {
		return Variant::TRANSFORM2D;
	} else if (type_str == "Transform3D") {
		return Variant::TRANSFORM3D;
	} else if (type_str == "Basis") {
		return Variant::BASIS;
	} else if (type_str == "Quaternion") {
		return Variant::QUATERNION;
	} else if (type_str == "Plane") {
		return Variant::PLANE;
	} else if (type_str == "AABB") {
		return Variant::AABB;
	} else if (type_str == "Projection") {
		return Variant::PROJECTION;
	} else if (type_str == "Color") {
		return Variant::COLOR;
	}

	// Collection types
	else if (type_str == "Array") {
		return Variant::ARRAY;
	} else if (type_str == "Dictionary") {
		return Variant::DICTIONARY;
	}

	// Packed array types
	else if (type_str == "PackedByteArray") {
		return Variant::PACKED_BYTE_ARRAY;
	} else if (type_str == "PackedInt32Array") {
		return Variant::PACKED_INT32_ARRAY;
	} else if (type_str == "PackedInt64Array") {
		return Variant::PACKED_INT64_ARRAY;
	} else if (type_str == "PackedFloat32Array") {
		return Variant::PACKED_FLOAT32_ARRAY;
	} else if (type_str == "PackedFloat64Array") {
		return Variant::PACKED_FLOAT64_ARRAY;
	} else if (type_str == "PackedStringArray") {
		return Variant::PACKED_STRING_ARRAY;
	} else if (type_str == "PackedVector2Array") {
		return Variant::PACKED_VECTOR2_ARRAY;
	} else if (type_str == "PackedVector3Array") {
		return Variant::PACKED_VECTOR3_ARRAY;
	} else if (type_str == "PackedColorArray") {
		return Variant::PACKED_COLOR_ARRAY;
	} else if (type_str == "PackedVector4Array") {
		return Variant::PACKED_VECTOR4_ARRAY;
	}

	// Special types
	else if (type_str == "RID") {
		return Variant::RID;
	} else if (type_str == "Callable") {
		return Variant::CALLABLE;
	} else if (type_str == "Signal") {
		return Variant::SIGNAL;
	}

	// Unknown type, return NONE
	return IRInstruction::TypeHint_NONE;
}

CodeGenerator::CodeGenerator() {}

IRProgram CodeGenerator::generate(const Program& program) {
	IRProgram ir_program;

	// Collect all locally defined function names
	m_local_functions.clear();
	for (const auto& func : program.functions) {
		m_local_functions.insert(func.name);
	}

	// Process global variables
	m_global_variables.clear();
	for (size_t i = 0; i < program.globals.size(); i++) {
		const auto& global = program.globals[i];
		m_global_variables[global.name] = i;

		// Convert AST global to IR global
		IRGlobalVar ir_global;
		ir_global.name = global.name;
		ir_global.is_const = global.is_const;
		ir_global.is_property = global.is_property;

		// Convert type hint
		if (!global.type_hint.empty()) {
			ir_global.type_hint = type_hint_from_string(global.type_hint);
		}

		// Validate that global variables have either a type hint or an initializer
		// This is necessary for complex types (String, Array, Dictionary, etc.) which
		// require VASSIGN for proper reference counting. Without type information, we
		// cannot determine at compile time whether VASSIGN is needed.
		if (global.type_hint.empty() && !global.initializer) {
			throw CompilerException(ErrorType::CODEGEN_ERROR,
				"Global variable '" + global.name + "' requires either a type hint or an initializer. " +
				"Please add ': type' (e.g., ': Array') or an initializer (e.g., '= []'). " +
				"This is required to ensure proper memory management for complex types.");
		}

		// Extract initializer value if it's a literal
		if (global.initializer) {
			if (auto* lit = dynamic_cast<const LiteralExpr*>(global.initializer.get())) {
				switch (lit->lit_type) {
					case LiteralExpr::Type::INTEGER:
						ir_global.init_type = IRGlobalVar::InitType::INT;
						ir_global.init_value = std::get<int64_t>(lit->value);
						break;
					case LiteralExpr::Type::FLOAT:
						ir_global.init_type = IRGlobalVar::InitType::FLOAT;
						ir_global.init_value = std::get<double>(lit->value);
						break;
					case LiteralExpr::Type::STRING:
						ir_global.init_type = IRGlobalVar::InitType::STRING;
						ir_global.init_value = std::get<std::string>(lit->value);
						break;
					case LiteralExpr::Type::BOOL:
						ir_global.init_type = IRGlobalVar::InitType::BOOL;
						ir_global.init_value = std::get<bool>(lit->value);
						break;
					case LiteralExpr::Type::NULL_VAL:
						ir_global.init_type = IRGlobalVar::InitType::NULL_VAL;
						break;
				}
			} else if (auto* array_lit = dynamic_cast<const ArrayLiteralExpr*>(global.initializer.get())) {
				// Support empty array literals as global initializers
				if (array_lit->elements.empty()) {
					ir_global.init_type = IRGlobalVar::InitType::EMPTY_ARRAY;
				} else {
					// Non-empty arrays would require complex initialization
					// For now, leave as NONE (NIL) - can be improved later
				}
			}
			// For other non-literal initializers, we'll need to generate initialization code
			// This would be done in a special initialization function or at first access
		}

		ir_program.globals.push_back(ir_global);
	}

	for (const auto& func : program.functions) {
		ir_program.functions.push_back(generate_function(func));
	}

	ir_program.string_constants = m_string_constants;
	return ir_program;
}

IRFunction CodeGenerator::generate_function(const FunctionDecl& func) {
	IRFunction ir_func;
	ir_func.name = func.name;

	// Reset state for new function
	m_scope_stack.clear();
	m_next_register = 0;
	m_loop_stack.clear();

	// Create root scope for function
	push_scope();

	// Parameters are passed in registers a0-a7 (RISC-V convention)
	// For simplicity, we'll store them as variables immediately
	for (size_t i = 0; i < func.parameters.size(); i++) {
		const auto& param = func.parameters[i];
		ir_func.parameters.push_back(param.name);

		int reg = alloc_register();
		// In real implementation, would load from parameter registers
		// For now, assume parameters are already in variables
		declare_variable(param.name, reg);

		// Track parameter type if type hint is present
		if (!param.type_hint.empty()) {
			IRInstruction::TypeHint type = type_hint_from_string(param.type_hint);
			if (type != IRInstruction::TypeHint_NONE) {
				set_register_type(reg, type);
			}
		}
	}

	// Generate code for function body
	for (const auto& stmt : func.body) {
		gen_stmt(stmt.get(), ir_func);
	}

	// Ensure function returns (add implicit return if needed)
	if (ir_func.instructions.empty() ||
	    ir_func.instructions.back().opcode != IROpcode::RETURN) {
		ir_func.instructions.emplace_back(IROpcode::RETURN);
	}

	ir_func.max_registers = m_next_register;

	// Pop root scope
	pop_scope();

	return ir_func;
}

void CodeGenerator::gen_stmt(const Stmt* stmt, IRFunction& func) {
	if (auto* var_decl = dynamic_cast<const VarDeclStmt*>(stmt)) {
		gen_var_decl(var_decl, func);
	} else if (auto* assign = dynamic_cast<const AssignStmt*>(stmt)) {
		gen_assign(assign, func);
	} else if (auto* ret = dynamic_cast<const ReturnStmt*>(stmt)) {
		gen_return(ret, func);
	} else if (auto* if_stmt = dynamic_cast<const IfStmt*>(stmt)) {
		gen_if(if_stmt, func);
	} else if (auto* while_stmt = dynamic_cast<const WhileStmt*>(stmt)) {
		gen_while(while_stmt, func);
	} else if (auto* for_stmt = dynamic_cast<const ForStmt*>(stmt)) {
		gen_for(for_stmt, func);
	} else if (dynamic_cast<const BreakStmt*>(stmt)) {
		gen_break(nullptr, func);
	} else if (dynamic_cast<const ContinueStmt*>(stmt)) {
		gen_continue(nullptr, func);
	} else if (dynamic_cast<const PassStmt*>(stmt)) {
		// No-op
	} else if (auto* expr_stmt = dynamic_cast<const ExprStmt*>(stmt)) {
		gen_expr_stmt(expr_stmt, func);
	} else {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Unknown statement type");
	}
}

void CodeGenerator::gen_var_decl(const VarDeclStmt* stmt, IRFunction& func) {
	int reg = -1;

	if (stmt->initializer) {
		reg = gen_expr(stmt->initializer.get(), func);
	} else {
		reg = alloc_register();
		// Initialize to null/0
		func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(reg), IRValue::imm(0));
	}

	// Track type hint if provided
	if (!stmt->type_hint.empty()) {
		IRInstruction::TypeHint type = type_hint_from_string(stmt->type_hint);
		if (type != IRInstruction::TypeHint_NONE) {
			set_register_type(reg, type);
		}
	} else if (stmt->initializer) {
		// Infer type from initializer
		IRInstruction::TypeHint init_type = get_register_type(reg);
		if (init_type != IRInstruction::TypeHint_NONE) {
			set_register_type(reg, init_type);
		}
	}

	declare_variable(stmt->name, reg, stmt->is_const);
}

void CodeGenerator::gen_assign(const AssignStmt* stmt, IRFunction& func) {
	int value_reg = gen_expr(stmt->value.get(), func);

	// Check if this is an indexed assignment (arr[0] = value) or property assignment (obj.prop = value)
	if (stmt->target) {
		// Check for indexed assignment: arr[idx] = value
		if (auto* index_expr = dynamic_cast<const IndexExpr*>(stmt->target.get())) {
			int obj_reg = gen_expr(index_expr->object.get(), func);
			int idx_reg = gen_expr(index_expr->index.get(), func);

			// Use VCALL to call .set(index, value)
			// Format: VCALL result_reg, obj_reg, method_name, arg_count, arg1_reg, arg2_reg
			int result_reg = alloc_register();
			IRInstruction vcall_instr(IROpcode::VCALL);
			vcall_instr.operands.push_back(IRValue::reg(result_reg));
			vcall_instr.operands.push_back(IRValue::reg(obj_reg));
			vcall_instr.operands.push_back(IRValue::str("set"));
			vcall_instr.operands.push_back(IRValue::imm(2)); // 2 arguments
			vcall_instr.operands.push_back(IRValue::reg(idx_reg));
			vcall_instr.operands.push_back(IRValue::reg(value_reg));
			func.instructions.push_back(vcall_instr);

			free_register(obj_reg);
			free_register(idx_reg);
			free_register(value_reg);
			free_register(result_reg);
			return;
		}

		// Check for property assignment: obj.prop = value
		if (auto* member_expr = dynamic_cast<const MemberCallExpr*>(stmt->target.get())) {
			// Verify this is a property access (not a method call)
			if (member_expr->is_method_call) {
				throw CompilerException(ErrorType::CODEGEN_ERROR, "Cannot assign to method call");
			}

			int obj_reg = gen_expr(member_expr->object.get(), func);

			// Property set: obj.prop = value
			// Use dedicated VSET instruction with ECALL_OBJ_PROP_SET syscall

			// Get string index for property name
			int str_idx = add_string_constant(member_expr->member_name);

			// Emit VSET instruction
			// Format: VSET obj_reg, string_idx, string_len, value_reg
			IRInstruction vset_instr(IROpcode::VSET);
			vset_instr.operands.push_back(IRValue::reg(obj_reg));
			vset_instr.operands.push_back(IRValue::imm(str_idx));
			vset_instr.operands.push_back(IRValue::imm(static_cast<int64_t>(member_expr->member_name.length())));
			vset_instr.operands.push_back(IRValue::reg(value_reg));
			func.instructions.push_back(vset_instr);

			free_register(obj_reg);
			free_register(value_reg);
			return;
		}

		throw CompilerException(ErrorType::CODEGEN_ERROR, "Invalid assignment target type");
	}

	// Simple variable assignment
	// Check if this is a global variable
	if (is_global_variable(stmt->name)) {
		size_t global_idx = m_global_variables.at(stmt->name);
		func.instructions.emplace_back(IROpcode::STORE_GLOBAL, IRValue::imm(global_idx), IRValue::reg(value_reg));
		free_register(value_reg);
		return;
	}

	Variable* var = find_variable(stmt->name);
	if (!var) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Undefined variable: " + stmt->name);
	}

	// Check if variable is const
	if (var->is_const) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Cannot assign to const variable: " + stmt->name);
	}

	// Store value into variable's register
	if (var->register_num != value_reg) {
		func.instructions.emplace_back(IROpcode::MOVE,
		                               IRValue::reg(var->register_num),
		                               IRValue::reg(value_reg));
	}

	free_register(value_reg);
}

void CodeGenerator::gen_return(const ReturnStmt* stmt, IRFunction& func) {
	if (stmt->value) {
		int reg = gen_expr(stmt->value.get(), func);
		// Move return value to register 0 (return register)
		// Skip if already in register 0
		if (reg != 0) {
			func.instructions.emplace_back(IROpcode::MOVE, IRValue::reg(0), IRValue::reg(reg));
		}
		free_register(reg);
	}

	func.instructions.emplace_back(IROpcode::RETURN);
}

void CodeGenerator::gen_if(const IfStmt* stmt, IRFunction& func) {
	std::string else_label = make_label("else");
	std::string end_label = make_label("endif");

	// Evaluate condition
	int cond_reg = gen_expr(stmt->condition.get(), func);

	// Branch to else if condition is zero (false)
	if (!stmt->else_branch.empty()) {
		func.instructions.emplace_back(IROpcode::BRANCH_ZERO, IRValue::reg(cond_reg), IRValue::label(else_label));
	} else {
		func.instructions.emplace_back(IROpcode::BRANCH_ZERO, IRValue::reg(cond_reg), IRValue::label(end_label));
	}

	free_register(cond_reg);

	// Then branch (new scope)
	push_scope();
	for (const auto& s : stmt->then_branch) {
		gen_stmt(s.get(), func);
	}
	pop_scope();

	if (!stmt->else_branch.empty()) {
		func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(end_label));

		// Else branch (new scope)
		func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(else_label));
		push_scope();
		for (const auto& s : stmt->else_branch) {
			gen_stmt(s.get(), func);
		}
		pop_scope();
	}

	func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(end_label));
}

void CodeGenerator::gen_while(const WhileStmt* stmt, IRFunction& func) {
	std::string loop_label = make_label("loop");
	std::string end_label = make_label("endloop");

	// Push loop context for break/continue
	m_loop_stack.push_back({end_label, loop_label});

	// Loop start
	func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(loop_label));

	// Evaluate condition
	int cond_reg = gen_expr(stmt->condition.get(), func);
	func.instructions.emplace_back(IROpcode::BRANCH_ZERO, IRValue::reg(cond_reg), IRValue::label(end_label));
	free_register(cond_reg);

	// Loop body (new scope)
	push_scope();
	for (const auto& s : stmt->body) {
		gen_stmt(s.get(), func);
	}
	pop_scope();

	// Jump back to loop start
	func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(loop_label));

	// Loop end
	func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(end_label));

	m_loop_stack.pop_back();
}

void CodeGenerator::gen_for(const ForStmt* stmt, IRFunction& func) {
	// Desugar: for variable in iterable: body
	// Support range() calls and array iteration
	// For range(): Convert to:
	//   var _iter = iterable  (evaluate range())
	//   var variable = 0
	//   while variable < _iter:
	//     body
	//     variable = variable + 1
	// For arrays: Convert to:
	//   var _array = iterable
	//   var _idx = 0
	//   while _idx < _array.size():
	//     var variable = _array[_idx]
	//     body
	//     _idx = _idx + 1

	// Check if iterable is a range() call
	auto* call_expr = dynamic_cast<const CallExpr*>(stmt->iterable.get());
	bool is_range = call_expr && call_expr->function_name == "range";

	// Check for obviously non-iterable types and give a proper error
	auto* literal = dynamic_cast<const LiteralExpr*>(stmt->iterable.get());
	if (literal) {
		if (literal->lit_type == LiteralExpr::Type::INTEGER ||
		    literal->lit_type == LiteralExpr::Type::FLOAT ||
		    literal->lit_type == LiteralExpr::Type::BOOL ||
		    literal->lit_type == LiteralExpr::Type::NULL_VAL) {
			throw CompilerException(ErrorType::CODEGEN_ERROR, "Cannot iterate over non-iterable type in 'for' loop. Did you mean 'for " +
			                         stmt->variable + " in range(" +
			                         (literal->lit_type == LiteralExpr::Type::INTEGER ?
			                          std::to_string(std::get<int64_t>(literal->value)) : "N") +
			                         "):'?");
		}
	}

	if (!is_range) {
		// Array iteration
		std::string loop_label = make_label("for_loop");
		std::string continue_label = make_label("for_continue");
		std::string end_label = make_label("for_end");

		// Push loop context for break/continue
		m_loop_stack.push_back({end_label, continue_label});

		// Create new scope for loop (includes loop variable)
		push_scope();

		int array_reg = gen_expr(stmt->iterable.get(), func);

		// Initialize index counter with 0
		int index_reg = alloc_register();
		auto& index_load = func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(index_reg), IRValue::imm(0));

		// Loop start
		func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(loop_label));

		// Call ECALL_ARRAY_SIZE to get the array size
		// ECALL_ARRAY_SIZE = GAME_API_BASE + 23 = 523
		int size_reg = alloc_register();
		IRInstruction size_syscall(IROpcode::CALL_SYSCALL);
		size_syscall.operands.push_back(IRValue::reg(size_reg));  // result register
		size_syscall.operands.push_back(IRValue::imm(523));         // ECALL_ARRAY_SIZE
		size_syscall.operands.push_back(IRValue::reg(array_reg));   // array register
		func.instructions.push_back(size_syscall);

		// Condition: index < size
		int cond_reg = alloc_register();
		auto& cmp_instr = func.instructions.emplace_back(IROpcode::CMP_LT, IRValue::reg(cond_reg),
		                               IRValue::reg(index_reg), IRValue::reg(size_reg));

		func.instructions.emplace_back(IROpcode::BRANCH_ZERO, IRValue::reg(cond_reg), IRValue::label(end_label));
		free_register(cond_reg);

		// Get element from array using ECALL_ARRAY_AT
		// ECALL_ARRAY_AT = GAME_API_BASE + 22 = 522
		int elem_reg = alloc_register();
		IRInstruction at_syscall(IROpcode::CALL_SYSCALL);
		at_syscall.operands.push_back(IRValue::reg(elem_reg));    // result register (element)
		at_syscall.operands.push_back(IRValue::imm(522));         // ECALL_ARRAY_AT
		at_syscall.operands.push_back(IRValue::reg(array_reg));   // array register
		at_syscall.operands.push_back(IRValue::reg(index_reg));   // index register
		func.instructions.push_back(at_syscall);

		// Assign the element to the loop variable
		declare_variable(stmt->variable, elem_reg);

		// Loop body (new scope for body, separate from loop variable scope)
		push_scope();
		for (const auto& s : stmt->body) {
			gen_stmt(s.get(), func);
		}
		pop_scope();

		// Continue label - where continue jumps to
		func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(continue_label));

		// Increment: index = index + 1
		int new_idx_reg = alloc_register();
		auto& add_instr = func.instructions.emplace_back(IROpcode::ADD, IRValue::reg(new_idx_reg),
		                               IRValue::reg(index_reg), IRValue::imm(1));
		auto& move_instr = func.instructions.emplace_back(IROpcode::MOVE, IRValue::reg(index_reg), IRValue::reg(new_idx_reg));
		free_register(new_idx_reg);

		// Jump back to loop start
		func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(loop_label));

		// Loop end
		func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(end_label));

		// Clean up
		pop_scope();
		m_loop_stack.pop_back();
		// Note: array_reg and size_reg are allocated inside the loop, so they're freed each iteration
		free_register(index_reg);
		free_register(elem_reg);
		return;
	}

	// Generate range() arguments
	// range(n) -> 0 to n-1
	// range(start, end) -> start to end-1
	// range(start, end, step) -> start to end-1 by step

	int start_reg = -1, end_reg = -1, step_reg = -1;

	if (call_expr->arguments.size() == 1) {
		// range(n): start=0, end=n, step=1
		start_reg = alloc_register();
		auto& start_instr = func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(start_reg), IRValue::imm(0));
		end_reg = gen_expr(call_expr->arguments[0].get(), func);
		step_reg = alloc_register();
		auto& step_instr = func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(step_reg), IRValue::imm(1));
	} else if (call_expr->arguments.size() == 2) {
		// range(start, end): step=1
		start_reg = gen_expr(call_expr->arguments[0].get(), func);
		end_reg = gen_expr(call_expr->arguments[1].get(), func);
		step_reg = alloc_register();
		auto& step_instr = func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(step_reg), IRValue::imm(1));
	} else if (call_expr->arguments.size() == 3) {
		// range(start, end, step)
		start_reg = gen_expr(call_expr->arguments[0].get(), func);
		end_reg = gen_expr(call_expr->arguments[1].get(), func);
		step_reg = gen_expr(call_expr->arguments[2].get(), func);
	} else {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "range() takes 1, 2, or 3 arguments");
	}

	std::string loop_label = make_label("for_loop");
	std::string continue_label = make_label("for_continue");
	std::string end_label = make_label("for_end");

	// Push loop context for break/continue
	// Continue should jump to the increment step, not the condition check
	m_loop_stack.push_back({end_label, continue_label});

	// Create new scope for loop (includes loop variable)
	push_scope();

	// Initialize loop variable with start value
	int loop_var_reg = alloc_register();
	auto& move_instr = func.instructions.emplace_back(IROpcode::MOVE, IRValue::reg(loop_var_reg), IRValue::reg(start_reg));
	declare_variable(stmt->variable, loop_var_reg);

	// Loop start
	func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(loop_label));

	// Condition depends on step direction:
	// - If step > 0: loop_var < end
	// - If step < 0: loop_var > end
	// - If step == 0: infinite loop (but that's a user error)
	//
	// For runtime step values, we need to check the sign dynamically.
	// For now, we'll check if step is a compile-time constant to optimize.

	int cond_reg = alloc_register();

	// Check if step is a constant value
	bool step_is_constant = false;
	int64_t step_value = 0;

	// Look back one instruction to see if step_reg was loaded with LOAD_IMM
	if (func.instructions.size() >= 3) {
		auto& prev_instr = func.instructions[func.instructions.size() - 3];
		if (prev_instr.opcode == IROpcode::LOAD_IMM &&
		    std::get<int>(prev_instr.operands[0].value) == step_reg) {
			step_is_constant = true;
			step_value = std::get<int64_t>(prev_instr.operands[1].value);
		}
	}

	if (step_is_constant) {
		// Optimize: use appropriate comparison based on constant step
		if (step_value >= 0) {
			// Forward iteration: loop_var < end
			auto& cmp_instr = func.instructions.emplace_back(IROpcode::CMP_LT, IRValue::reg(cond_reg),
			                               IRValue::reg(loop_var_reg), IRValue::reg(end_reg));
			cmp_instr.type_hint = Variant::INT; // range() always produces integers
		} else {
			// Backward iteration: loop_var > end
			auto& cmp_instr = func.instructions.emplace_back(IROpcode::CMP_GT, IRValue::reg(cond_reg),
			                               IRValue::reg(loop_var_reg), IRValue::reg(end_reg));
			cmp_instr.type_hint = Variant::INT; // range() always produces integers
		}
	} else {
		// Runtime step: check sign dynamically
		// if step >= 0: check loop_var < end
		// else: check loop_var > end
		std::string pos_step_label = make_label("for_pos_step");
		std::string check_cond_label = make_label("for_check_cond");

		int zero_reg = alloc_register();
		func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(zero_reg), IRValue::imm(0));

		int step_sign_reg = alloc_register();
		auto& step_cmp = func.instructions.emplace_back(IROpcode::CMP_GTE, IRValue::reg(step_sign_reg),
		                               IRValue::reg(step_reg), IRValue::reg(zero_reg));
		step_cmp.type_hint = Variant::INT; // range() always produces integers
		free_register(zero_reg);

		// If step >= 0, use loop_var < end
		func.instructions.emplace_back(IROpcode::BRANCH_NOT_ZERO, IRValue::reg(step_sign_reg),
		                               IRValue::label(pos_step_label));

		// Negative step: loop_var > end
		auto& neg_cmp = func.instructions.emplace_back(IROpcode::CMP_GT, IRValue::reg(cond_reg),
		                               IRValue::reg(loop_var_reg), IRValue::reg(end_reg));
		neg_cmp.type_hint = Variant::INT; // range() always produces integers
		func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(check_cond_label));

		// Positive step: loop_var < end
		func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(pos_step_label));
		auto& pos_cmp = func.instructions.emplace_back(IROpcode::CMP_LT, IRValue::reg(cond_reg),
		                               IRValue::reg(loop_var_reg), IRValue::reg(end_reg));
		pos_cmp.type_hint = Variant::INT; // range() always produces integers

		func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(check_cond_label));
		free_register(step_sign_reg);
	}

	func.instructions.emplace_back(IROpcode::BRANCH_ZERO, IRValue::reg(cond_reg), IRValue::label(end_label));
	free_register(cond_reg);

	// Loop body (new scope for body, separate from loop variable scope)
	push_scope();
	for (const auto& s : stmt->body) {
		gen_stmt(s.get(), func);
	}
	pop_scope();

	// Continue label - where continue jumps to
	func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(continue_label));

	// Increment: loop_var = loop_var + step
	int new_val_reg = alloc_register();
	auto& add_instr = func.instructions.emplace_back(IROpcode::ADD, IRValue::reg(new_val_reg),
	                               IRValue::reg(loop_var_reg), IRValue::reg(step_reg));
	add_instr.type_hint = Variant::INT; // range() always produces integers
	auto& move_instr2 = func.instructions.emplace_back(IROpcode::MOVE, IRValue::reg(loop_var_reg), IRValue::reg(new_val_reg));
	free_register(new_val_reg);

	// Jump back to loop start
	func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(loop_label));

	// Loop end
	func.instructions.emplace_back(IROpcode::LABEL, IRValue::label(end_label));

	// Clean up
	pop_scope();
	m_loop_stack.pop_back();
	free_register(start_reg);
	free_register(end_reg);
	free_register(step_reg);
}

void CodeGenerator::gen_break(const BreakStmt* stmt, IRFunction& func) {
	if (m_loop_stack.empty()) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "'break' outside of loop");
	}

	func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(m_loop_stack.back().break_label));
}

void CodeGenerator::gen_continue(const ContinueStmt* stmt, IRFunction& func) {
	if (m_loop_stack.empty()) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "'continue' outside of loop");
	}

	func.instructions.emplace_back(IROpcode::JUMP, IRValue::label(m_loop_stack.back().continue_label));
}

void CodeGenerator::gen_expr_stmt(const ExprStmt* stmt, IRFunction& func) {
	int reg = gen_expr(stmt->expression.get(), func);
	free_register(reg);
}

int CodeGenerator::gen_expr(const Expr* expr, IRFunction& func) {
	if (auto* lit = dynamic_cast<const LiteralExpr*>(expr)) {
		return gen_literal(lit, func);
	} else if (auto* var = dynamic_cast<const VariableExpr*>(expr)) {
		return gen_variable(var, func);
	} else if (auto* bin = dynamic_cast<const BinaryExpr*>(expr)) {
		return gen_binary(bin, func);
	} else if (auto* un = dynamic_cast<const UnaryExpr*>(expr)) {
		return gen_unary(un, func);
	} else if (auto* call = dynamic_cast<const CallExpr*>(expr)) {
		return gen_call(call, func);
	} else if (auto* member = dynamic_cast<const MemberCallExpr*>(expr)) {
		return gen_member_call(member, func);
	} else if (auto* index = dynamic_cast<const IndexExpr*>(expr)) {
		return gen_index(index, func);
	} else if (auto* array_lit = dynamic_cast<const ArrayLiteralExpr*>(expr)) {
		return gen_array_literal(array_lit, func);
	} else if (auto* dict_lit = dynamic_cast<const DictionaryLiteralExpr*>(expr)) {
		return gen_dictionary_literal(dict_lit, func);
	} else {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Unknown expression type");
	}
}

int CodeGenerator::gen_literal(const LiteralExpr* expr, IRFunction& func) {
	int reg = alloc_register();

	switch (expr->lit_type) {
		case LiteralExpr::Type::INTEGER: {
			IRInstruction instr(IROpcode::LOAD_IMM, IRValue::reg(reg),
			                    IRValue::imm(std::get<int64_t>(expr->value)));
			instr.type_hint = Variant::INT;
			func.instructions.push_back(instr);
			set_register_type(reg, Variant::INT);
			break;
		}

		case LiteralExpr::Type::FLOAT: {
			// Float literals are always 64-bit doubles in GDScript
			double d = std::get<double>(expr->value);
			IRInstruction instr(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(reg), IRValue::fimm(d));
			instr.type_hint = Variant::FLOAT;
			func.instructions.push_back(instr);
			set_register_type(reg, Variant::FLOAT);
			break;
		}

		case LiteralExpr::Type::BOOL: {
			IRInstruction instr(IROpcode::LOAD_BOOL, IRValue::reg(reg),
			                    IRValue::imm(std::get<bool>(expr->value) ? 1 : 0));
			instr.type_hint = Variant::BOOL;
			func.instructions.push_back(instr);
			set_register_type(reg, Variant::BOOL);
			break;
		}

		case LiteralExpr::Type::STRING: {
			int str_idx = add_string_constant(std::get<std::string>(expr->value));
			IRInstruction instr(IROpcode::LOAD_STRING, IRValue::reg(reg), IRValue::imm(str_idx));
			instr.type_hint = Variant::STRING;
			func.instructions.push_back(instr);
			set_register_type(reg, Variant::STRING);
			break;
		}

		case LiteralExpr::Type::NULL_VAL:
			func.instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(reg), IRValue::imm(0));
			break;
	}

	return reg;
}

int CodeGenerator::gen_variable(const VariableExpr* expr, IRFunction& func) {
	// Check if this is a global class reference
	if (is_global_class(expr->name)) {
		return gen_global_class_get(expr->name, func);
	}

	// Handle 'self' as an alias for get_node()
	if (expr->name == "self") {
		// Generate get_node() call
		int result_reg = alloc_register();

		// CALL_SYSCALL result_reg, ECALL_GET_NODE, 0
		IRInstruction instr(IROpcode::CALL_SYSCALL);
		instr.operands.push_back(IRValue::reg(result_reg));    // result register
		instr.operands.push_back(IRValue::imm(507));            // ECALL_GET_NODE
		instr.operands.push_back(IRValue::imm(0));              // addr = 0 (owner node)
		func.instructions.push_back(instr);

		return result_reg;
	}

	// Check if this is a global variable
	if (is_global_variable(expr->name)) {
		int result_reg = alloc_register();
		size_t global_idx = m_global_variables.at(expr->name);
		func.instructions.emplace_back(IROpcode::LOAD_GLOBAL, IRValue::reg(result_reg), IRValue::imm(global_idx));
		return result_reg;
	}

	Variable* var = find_variable(expr->name);
	if (!var) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Undefined variable: " + expr->name);
	}

	// Return a copy in a new register
	int new_reg = alloc_register();
	func.instructions.emplace_back(IROpcode::MOVE, IRValue::reg(new_reg), IRValue::reg(var->register_num));

	// Propagate type information from the variable to the new register
	IRInstruction::TypeHint var_type = get_register_type(var->register_num);
	if (var_type != IRInstruction::TypeHint_NONE) {
		set_register_type(new_reg, var_type);
	}

	return new_reg;
}

int CodeGenerator::gen_binary(const BinaryExpr* expr, IRFunction& func) {
	int left_reg = gen_expr(expr->left.get(), func);
	int right_reg = gen_expr(expr->right.get(), func);
	int result_reg = alloc_register();

	// Check type hints for operands to determine if result should be float
	IRInstruction::TypeHint left_type = get_register_type(left_reg);
	IRInstruction::TypeHint right_type = get_register_type(right_reg);

	// Determine if this is an arithmetic operation (vs comparison or logical)
	bool is_arithmetic = (expr->op == BinaryExpr::Op::ADD ||
	                      expr->op == BinaryExpr::Op::SUB ||
	                      expr->op == BinaryExpr::Op::MUL ||
	                      expr->op == BinaryExpr::Op::DIV ||
	                      expr->op == BinaryExpr::Op::MOD);
	bool is_comparison = (expr->op == BinaryExpr::Op::EQ ||
	                      expr->op == BinaryExpr::Op::NEQ ||
	                      expr->op == BinaryExpr::Op::LT ||
	                      expr->op == BinaryExpr::Op::LTE ||
	                      expr->op == BinaryExpr::Op::GT ||
	                      expr->op == BinaryExpr::Op::GTE);

	// For arithmetic operations and comparisons:
	// ONLY set type hint when BOTH operands have the SAME type
	// This enables native RISC-V codegen optimizations
	//
	// When types don't match (e.g. INT + FLOAT), we leave result_type as NONE
	// and fall back to VEVAL syscall which handles type coercion correctly
	IRInstruction::TypeHint result_type = IRInstruction::TypeHint_NONE;
	if (is_arithmetic || is_comparison) {
		if (left_type == Variant::INT && right_type == Variant::INT) {
			result_type = Variant::INT;
		} else if (left_type == Variant::FLOAT && right_type == Variant::FLOAT) {
			result_type = Variant::FLOAT;
		} else if (left_type != IRInstruction::TypeHint_NONE &&
		           right_type != IRInstruction::TypeHint_NONE &&
		           left_type == right_type &&
		           TypeHintUtils::is_vector(left_type)) {
			// Both operands are the same vector type
			result_type = left_type;
		}
		// Mixed types or unsupported types: leave as NONE for VEVAL fallback
	}

	IROpcode op;
	switch (expr->op) {
		case BinaryExpr::Op::ADD: op = IROpcode::ADD; break;
		case BinaryExpr::Op::SUB: op = IROpcode::SUB; break;
		case BinaryExpr::Op::MUL: op = IROpcode::MUL; break;
		case BinaryExpr::Op::DIV: op = IROpcode::DIV; break;
		case BinaryExpr::Op::MOD: op = IROpcode::MOD; break;
		case BinaryExpr::Op::EQ: op = IROpcode::CMP_EQ; break;
		case BinaryExpr::Op::NEQ: op = IROpcode::CMP_NEQ; break;
		case BinaryExpr::Op::LT: op = IROpcode::CMP_LT; break;
		case BinaryExpr::Op::LTE: op = IROpcode::CMP_LTE; break;
		case BinaryExpr::Op::GT: op = IROpcode::CMP_GT; break;
		case BinaryExpr::Op::GTE: op = IROpcode::CMP_GTE; break;
		case BinaryExpr::Op::AND: op = IROpcode::AND; break;
		case BinaryExpr::Op::OR: op = IROpcode::OR; break;
		default:
			throw CompilerException(ErrorType::CODEGEN_ERROR, "Unknown binary operator");
	}

	IRInstruction instr(op, IRValue::reg(result_reg), IRValue::reg(left_reg), IRValue::reg(right_reg));
	instr.type_hint = result_type;
	func.instructions.push_back(instr);

	if (result_type != IRInstruction::TypeHint_NONE) {
		set_register_type(result_reg, result_type);
	}

	free_register(left_reg);
	free_register(right_reg);

	return result_reg;
}

int CodeGenerator::gen_unary(const UnaryExpr* expr, IRFunction& func) {
	int operand_reg = gen_expr(expr->operand.get(), func);
	int result_reg = alloc_register();

	IROpcode op = (expr->op == UnaryExpr::Op::NEG) ? IROpcode::NEG : IROpcode::NOT;
	func.instructions.emplace_back(op, IRValue::reg(result_reg), IRValue::reg(operand_reg));

	free_register(operand_reg);
	return result_reg;
}

int CodeGenerator::gen_call(const CallExpr* expr, IRFunction& func) {
	// Generate code for arguments
	std::vector<int> arg_regs;
	for (const auto& arg : expr->arguments) {
		arg_regs.push_back(gen_expr(arg.get(), func));
	}

	// Check if this is an inline primitive constructor
	if (is_inline_primitive_constructor(expr->function_name)) {
		int result = gen_inline_constructor(expr->function_name, arg_regs, func);
		for (int reg : arg_regs) {
			free_register(reg);
		}
		return result;
	}

	// Handle get_node() as a special syscall
	if (expr->function_name == "get_node") {
		// get_node() takes 0 or 1 argument (node path)
		if (arg_regs.size() > 1) {
			throw CompilerException(ErrorType::CODEGEN_ERROR, "get_node() takes at most 1 argument");
		}

		int result_reg = alloc_register();

		if (arg_regs.empty()) {
			// get_node() with no args - get the owner node
			// CALL_SYSCALL result_reg, ECALL_GET_NODE, 0
			IRInstruction instr(IROpcode::CALL_SYSCALL);
			instr.operands.push_back(IRValue::reg(result_reg));    // result register
			instr.operands.push_back(IRValue::imm(507));            // ECALL_GET_NODE
			instr.operands.push_back(IRValue::imm(0));              // addr = 0 (owner node)
			func.instructions.push_back(instr);
		} else {
			// get_node(path) - will be handled in RISC-V codegen
			// For now, convert to CALL_SYSCALL with the path argument
			int path_reg = arg_regs[0];

			IRInstruction instr(IROpcode::CALL_SYSCALL);
			instr.operands.push_back(IRValue::reg(result_reg));    // result register
			instr.operands.push_back(IRValue::imm(507));            // ECALL_GET_NODE
			instr.operands.push_back(IRValue::imm(0));              // addr = 0 (owner node)
			instr.operands.push_back(IRValue::reg(path_reg));       // path register
			func.instructions.push_back(instr);
		}

		for (int reg : arg_regs) {
			free_register(reg);
		}

		return result_reg;
	}

	// Check if this is a call to a locally defined function
	if (is_local_function(expr->function_name)) {
		// Local function call - use regular CALL instruction
		int result_reg = alloc_register();

		// Generate CALL instruction with function name, result register, and argument registers
		// Format: CALL function_name, result_reg, arg_count, arg1_reg, arg2_reg, ...
		IRInstruction call_instr(IROpcode::CALL);
		call_instr.operands.push_back(IRValue::str(expr->function_name));
		call_instr.operands.push_back(IRValue::reg(result_reg));
		call_instr.operands.push_back(IRValue::imm(arg_regs.size()));
		for (int arg_reg : arg_regs) {
			call_instr.operands.push_back(IRValue::reg(arg_reg));
		}
		func.instructions.push_back(call_instr);

		for (int reg : arg_regs) {
			free_register(reg);
		}

		return result_reg;
	}

	// Treat all other freestanding function calls as self-calls
	// Convert foo(arg1, arg2) to self.foo(arg1, arg2)
	int self_reg = alloc_register();

	// Generate get_node() for self
	// CALL_SYSCALL self_reg, ECALL_GET_NODE, 0
	IRInstruction get_self_instr(IROpcode::CALL_SYSCALL);
	get_self_instr.operands.push_back(IRValue::reg(self_reg));     // result register
	get_self_instr.operands.push_back(IRValue::imm(507));            // ECALL_GET_NODE
	get_self_instr.operands.push_back(IRValue::imm(0));              // addr = 0 (owner node)
	func.instructions.push_back(get_self_instr);

	int result_reg = alloc_register();

	// Generate VCALL instruction for self.method call
	// Format: VCALL result_reg, self_reg, method_name, arg_count, arg1_reg, arg2_reg, ...
	IRInstruction vcall_instr(IROpcode::VCALL);
	vcall_instr.operands.push_back(IRValue::reg(result_reg));
	vcall_instr.operands.push_back(IRValue::reg(self_reg));
	vcall_instr.operands.push_back(IRValue::str(expr->function_name));
	vcall_instr.operands.push_back(IRValue::imm(arg_regs.size()));
	for (int arg_reg : arg_regs) {
		vcall_instr.operands.push_back(IRValue::reg(arg_reg));
	}
	func.instructions.push_back(vcall_instr);

	free_register(self_reg);
	for (int reg : arg_regs) {
		free_register(reg);
	}

	return result_reg;
}

int CodeGenerator::gen_member_call(const MemberCallExpr* expr, IRFunction& func) {
	int obj_reg = gen_expr(expr->object.get(), func);

	// Generate code for arguments
	std::vector<int> arg_regs;
	for (const auto& arg : expr->arguments) {
		arg_regs.push_back(gen_expr(arg.get(), func));
	}

	// Check if this is inline member access (x, y, z, r, g, b, a on vectors)
	if (!expr->is_method_call && arg_regs.empty()) {
		IRInstruction::TypeHint obj_type = get_register_type(obj_reg);
		if (is_inline_member_access(obj_type, expr->member_name)) {
			int result = gen_inline_member_get(obj_reg, obj_type, expr->member_name, func);
			free_register(obj_reg);
			return result;
		}

		// Property access: obj.property (no parentheses)
		// Use dedicated VGET instruction with ECALL_OBJ_PROP_GET syscall
		int result_reg = alloc_register();

		// Get string index for property name
		int str_idx = add_string_constant(expr->member_name);

		// Emit VGET instruction
		// Format: VGET result_reg, obj_reg, string_idx, string_len
		IRInstruction vget_instr(IROpcode::VGET);
		vget_instr.operands.push_back(IRValue::reg(result_reg));
		vget_instr.operands.push_back(IRValue::reg(obj_reg));
		vget_instr.operands.push_back(IRValue::imm(str_idx));
		vget_instr.operands.push_back(IRValue::imm(static_cast<int64_t>(expr->member_name.length())));
		func.instructions.push_back(vget_instr);

		free_register(obj_reg);
		return result_reg;
	}

	int result_reg = alloc_register();

	// Use VCALL for Variant method calls
	// Format: VCALL result_reg, obj_reg, method_name, arg_count, arg1_reg, arg2_reg, ...
	IRInstruction vcall_instr(IROpcode::VCALL);
	vcall_instr.operands.push_back(IRValue::reg(result_reg));
	vcall_instr.operands.push_back(IRValue::reg(obj_reg));
	vcall_instr.operands.push_back(IRValue::str(expr->member_name));
	vcall_instr.operands.push_back(IRValue::imm(arg_regs.size()));
	for (int arg_reg : arg_regs) {
		vcall_instr.operands.push_back(IRValue::reg(arg_reg));
	}
	func.instructions.push_back(vcall_instr);

	free_register(obj_reg);
	for (int reg : arg_regs) {
		free_register(reg);
	}

	return result_reg;
}

int CodeGenerator::gen_index(const IndexExpr* expr, IRFunction& func) {
	int obj_reg = gen_expr(expr->object.get(), func);
	int idx_reg = gen_expr(expr->index.get(), func);

	int result_reg = alloc_register();

	// Transform arr[x] to arr.get(x) using VCALL
	// Format: VCALL result_reg, obj_reg, method_name, arg_count, arg1_reg
	IRInstruction vcall_instr(IROpcode::VCALL);
	vcall_instr.operands.push_back(IRValue::reg(result_reg));
	vcall_instr.operands.push_back(IRValue::reg(obj_reg));
	vcall_instr.operands.push_back(IRValue::str("get"));
	vcall_instr.operands.push_back(IRValue::imm(1)); // 1 argument
	vcall_instr.operands.push_back(IRValue::reg(idx_reg));
	func.instructions.push_back(vcall_instr);

	free_register(obj_reg);
	free_register(idx_reg);

	return result_reg;
}

int CodeGenerator::gen_array_literal(const ArrayLiteralExpr* expr, IRFunction& func) {
	std::vector<int> elem_regs;

	// Generate code for each element
	for (const auto& elem : expr->elements) {
		int reg = gen_expr(elem.get(), func);
		elem_regs.push_back(reg);
	}

	int result_reg = alloc_register();

	// Create MAKE_ARRAY instruction
	// Format: MAKE_ARRAY result_reg, element_count, elem1_reg, elem2_reg, ...
	IRInstruction instr(IROpcode::MAKE_ARRAY);
	instr.operands.push_back(IRValue::reg(result_reg));
	instr.operands.push_back(IRValue::imm(static_cast<int>(elem_regs.size()))); // element count
	for (int reg : elem_regs) {
		instr.operands.push_back(IRValue::reg(reg));
	}

	func.instructions.push_back(instr);
	set_register_type(result_reg, Variant::ARRAY);

	// Free element registers
	for (int reg : elem_regs) {
		free_register(reg);
	}

	return result_reg;
}

int CodeGenerator::gen_dictionary_literal(const DictionaryLiteralExpr* expr, IRFunction& func) {
	std::vector<int> key_regs;
	std::vector<int> value_regs;

	// Generate code for each key-value pair
	for (const auto& [key, value] : expr->elements) {
		int key_reg = gen_expr(key.get(), func);
		int value_reg = gen_expr(value.get(), func);
		key_regs.push_back(key_reg);
		value_regs.push_back(value_reg);
	}

	int result_reg = alloc_register();

	// Create MAKE_DICTIONARY instruction
	// Format: MAKE_DICTIONARY result_reg, pair_count, key1_reg, val1_reg, key2_reg, val2_reg, ...
	IRInstruction instr(IROpcode::MAKE_DICTIONARY);
	instr.operands.push_back(IRValue::reg(result_reg));
	instr.operands.push_back(IRValue::imm(static_cast<int>(key_regs.size()))); // pair count

	// Interleave keys and values: key1, val1, key2, val2, ...
	for (size_t i = 0; i < key_regs.size(); i++) {
		instr.operands.push_back(IRValue::reg(key_regs[i]));
		instr.operands.push_back(IRValue::reg(value_regs[i]));
	}

	func.instructions.push_back(instr);
	set_register_type(result_reg, Variant::DICTIONARY);

	// Free key and value registers
	for (int reg : key_regs) {
		free_register(reg);
	}
	for (int reg : value_regs) {
		free_register(reg);
	}

	return result_reg;
}

int CodeGenerator::alloc_register() {
	return m_next_register++;
}

void CodeGenerator::free_register(int reg) {
	// In a more sophisticated version, would track free registers
	// For now, registers are never reused within a function
}

std::string CodeGenerator::make_label(const std::string& prefix) {
	return prefix + "_" + std::to_string(m_next_label++);
}

int CodeGenerator::add_string_constant(const std::string& str) {
	// Check if string already exists
	for (size_t i = 0; i < m_string_constants.size(); i++) {
		if (m_string_constants[i] == str) {
			return static_cast<int>(i);
		}
	}

	m_string_constants.push_back(str);
	return static_cast<int>(m_string_constants.size() - 1);
}

void CodeGenerator::push_scope() {
	Scope new_scope;
	if (m_scope_stack.empty()) {
		new_scope.parent_scope_idx = SIZE_MAX; // Root scope
	} else {
		new_scope.parent_scope_idx = m_scope_stack.size() - 1;
	}
	m_scope_stack.push_back(new_scope);
}

void CodeGenerator::pop_scope() {
	if (m_scope_stack.empty()) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Cannot pop scope: scope stack is empty");
	}
	m_scope_stack.pop_back();
}

CodeGenerator::Variable* CodeGenerator::find_variable(const std::string& name) {
	// Search from innermost to outermost scope
	for (int i = static_cast<int>(m_scope_stack.size()) - 1; i >= 0; i--) {
		auto it = m_scope_stack[i].variables.find(name);
		if (it != m_scope_stack[i].variables.end()) {
			return &it->second;
		}
	}
	return nullptr; // Not found
}

void CodeGenerator::declare_variable(const std::string& name, int register_num, bool is_const) {
	if (m_scope_stack.empty()) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Cannot declare variable: no scope active");
	}

	// Check if variable already exists in current scope (shadowing is allowed, but redeclaration in same scope is not)
	auto& current_scope = m_scope_stack.back();
	if (current_scope.variables.find(name) != current_scope.variables.end()) {
		throw CompilerException(ErrorType::CODEGEN_ERROR, "Variable '" + name + "' already declared in current scope");
	}

	current_scope.variables[name] = {name, register_num, IRInstruction::TypeHint_NONE, is_const};
}

// Type tracking helpers
void CodeGenerator::set_register_type(int reg, IRInstruction::TypeHint type) {
	m_register_types[reg] = type;
}

IRInstruction::TypeHint CodeGenerator::get_register_type(int reg) const {
	auto it = m_register_types.find(reg);
	if (it != m_register_types.end()) {
		return it->second;
	}
	return IRInstruction::TypeHint_NONE;
}

bool CodeGenerator::is_inline_primitive_constructor(const std::string& name) const {
	return name == "Vector2" || name == "Vector3" || name == "Vector4" ||
	       name == "Vector2i" || name == "Vector3i" || name == "Vector4i" ||
	       name == "Color" || name == "Rect2" || name == "Rect2i" || name == "Plane" ||
	       name == "Array" || name == "Dictionary" ||
	       name == "PackedByteArray" || name == "PackedInt32Array" ||
	       name == "PackedInt64Array" || name == "PackedFloat32Array" ||
	       name == "PackedFloat64Array" || name == "PackedStringArray" ||
	       name == "PackedVector2Array" || name == "PackedVector3Array" ||
	       name == "PackedColorArray" || name == "PackedVector4Array";
}

bool CodeGenerator::is_inline_member_access(IRInstruction::TypeHint type, const std::string& member) const {
	switch (type) {
		case Variant::VECTOR2:
		case Variant::VECTOR2I:
			return member == "x" || member == "y";

		case Variant::VECTOR3:
		case Variant::VECTOR3I:
			return member == "x" || member == "y" || member == "z";

		case Variant::VECTOR4:
		case Variant::VECTOR4I:
			return member == "x" || member == "y" || member == "z" || member == "w";

		case Variant::COLOR:
			return member == "r" || member == "g" || member == "b" || member == "a";

		case Variant::RECT2:
		case Variant::RECT2I:
			// Rect2 has position and size, which are Vector2/Vector2i
			// For now, don't optimize these - they're more complex
			return false;

		case Variant::PLANE:
			// Plane has normal (Vector3) and d (float)
			// For now, don't optimize these
			return false;

		default:
			return false;
	}
}

int CodeGenerator::gen_inline_constructor(const std::string& name, const std::vector<int>& arg_regs, IRFunction& func) {
	int result_reg = alloc_register();
	IRInstruction instr(IROpcode::CALL); // Default fallback
	IRInstruction::TypeHint result_type = IRInstruction::TypeHint_NONE;

	if (name == "Vector2" && arg_regs.size() == 2) {
		instr = IRInstruction(IROpcode::MAKE_VECTOR2);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::reg(arg_regs[0])); // x
		instr.operands.push_back(IRValue::reg(arg_regs[1])); // y
		result_type = Variant::VECTOR2;
	} else if (name == "Vector3" && arg_regs.size() == 3) {
		instr = IRInstruction(IROpcode::MAKE_VECTOR3);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::reg(arg_regs[0])); // x
		instr.operands.push_back(IRValue::reg(arg_regs[1])); // y
		instr.operands.push_back(IRValue::reg(arg_regs[2])); // z
		result_type = Variant::VECTOR3;
	} else if (name == "Vector4" && arg_regs.size() == 4) {
		instr = IRInstruction(IROpcode::MAKE_VECTOR4);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::reg(arg_regs[0])); // x
		instr.operands.push_back(IRValue::reg(arg_regs[1])); // y
		instr.operands.push_back(IRValue::reg(arg_regs[2])); // z
		instr.operands.push_back(IRValue::reg(arg_regs[3])); // w
		result_type = Variant::VECTOR4;
	} else if (name == "Vector2i" && arg_regs.size() == 2) {
		instr = IRInstruction(IROpcode::MAKE_VECTOR2I);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::reg(arg_regs[0])); // x
		instr.operands.push_back(IRValue::reg(arg_regs[1])); // y
		result_type = Variant::VECTOR2I;
	} else if (name == "Vector3i" && arg_regs.size() == 3) {
		instr = IRInstruction(IROpcode::MAKE_VECTOR3I);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::reg(arg_regs[0])); // x
		instr.operands.push_back(IRValue::reg(arg_regs[1])); // y
		instr.operands.push_back(IRValue::reg(arg_regs[2])); // z
		result_type = Variant::VECTOR3I;
	} else if (name == "Vector4i" && arg_regs.size() == 4) {
		instr = IRInstruction(IROpcode::MAKE_VECTOR4I);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::reg(arg_regs[0])); // x
		instr.operands.push_back(IRValue::reg(arg_regs[1])); // y
		instr.operands.push_back(IRValue::reg(arg_regs[2])); // z
		instr.operands.push_back(IRValue::reg(arg_regs[3])); // w
		result_type = Variant::VECTOR4I;
	} else if (name == "Color") {
		// Color() with 0 args: white (1, 1, 1, 1)
		// Color(r, g, b) with 3 args: default alpha to 1.0
		// Color(r, g, b, a) with 4 args: full specification
		if (arg_regs.size() == 0) {
			// Color() - white with alpha 1.0
			int r_reg = alloc_register();
			int g_reg = alloc_register();
			int b_reg = alloc_register();
			int a_reg = alloc_register();

			func.instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(r_reg), IRValue::fimm(1.0));
			func.instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(g_reg), IRValue::fimm(1.0));
			func.instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(b_reg), IRValue::fimm(1.0));
			func.instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(a_reg), IRValue::fimm(1.0));

			instr = IRInstruction(IROpcode::MAKE_COLOR);
			instr.operands.push_back(IRValue::reg(result_reg));
			instr.operands.push_back(IRValue::reg(r_reg));
			instr.operands.push_back(IRValue::reg(g_reg));
			instr.operands.push_back(IRValue::reg(b_reg));
			instr.operands.push_back(IRValue::reg(a_reg));
			result_type = Variant::COLOR;
		} else if (arg_regs.size() == 3) {
			// Color(r, g, b) - default alpha to 1.0
			int a_reg = alloc_register();
			func.instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(a_reg), IRValue::fimm(1.0));

			instr = IRInstruction(IROpcode::MAKE_COLOR);
			instr.operands.push_back(IRValue::reg(result_reg));
			instr.operands.push_back(IRValue::reg(arg_regs[0])); // r
			instr.operands.push_back(IRValue::reg(arg_regs[1])); // g
			instr.operands.push_back(IRValue::reg(arg_regs[2])); // b
			instr.operands.push_back(IRValue::reg(a_reg)); // a = 1.0
			result_type = Variant::COLOR;
		} else if (arg_regs.size() == 4) {
			instr = IRInstruction(IROpcode::MAKE_COLOR);
			instr.operands.push_back(IRValue::reg(result_reg));
			instr.operands.push_back(IRValue::reg(arg_regs[0])); // r
			instr.operands.push_back(IRValue::reg(arg_regs[1])); // g
			instr.operands.push_back(IRValue::reg(arg_regs[2])); // b
			instr.operands.push_back(IRValue::reg(arg_regs[3])); // a
			result_type = Variant::COLOR;
		} else {
			throw CompilerException(ErrorType::CODEGEN_ERROR, "Color constructor requires 0, 3, or 4 arguments");
		}
	} else if (name == "Array") {
		// Array() - empty array or with initial elements
		// For now, only support empty Array()
		instr = IRInstruction(IROpcode::MAKE_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::ARRAY;
	} else if (name == "PackedByteArray") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_BYTE_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_BYTE_ARRAY;
	} else if (name == "PackedInt32Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_INT32_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_INT32_ARRAY;
	} else if (name == "PackedInt64Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_INT64_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_INT64_ARRAY;
	} else if (name == "PackedFloat32Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_FLOAT32_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_FLOAT32_ARRAY;
	} else if (name == "PackedFloat64Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_FLOAT64_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_FLOAT64_ARRAY;
	} else if (name == "PackedStringArray") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_STRING_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_STRING_ARRAY;
	} else if (name == "PackedVector2Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_VECTOR2_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_VECTOR2_ARRAY;
	} else if (name == "PackedVector3Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_VECTOR3_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_VECTOR3_ARRAY;
	} else if (name == "PackedColorArray") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_COLOR_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_COLOR_ARRAY;
	} else if (name == "PackedVector4Array") {
		instr = IRInstruction(IROpcode::MAKE_PACKED_VECTOR4_ARRAY);
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(static_cast<int>(arg_regs.size()))); // element count
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
		result_type = Variant::PACKED_VECTOR4_ARRAY;
	} else if (name == "Dictionary") {
		// Dictionary() - empty dictionary
		instr = IRInstruction(IROpcode::MAKE_DICTIONARY);
		instr.operands.push_back(IRValue::reg(result_reg));
		result_type = Variant::DICTIONARY;
	} else {
		// Fallback to regular CALL for unsupported constructors or wrong arg counts
		instr.operands.push_back(IRValue::str(name));
		instr.operands.push_back(IRValue::reg(result_reg));
		instr.operands.push_back(IRValue::imm(arg_regs.size()));
		for (int arg_reg : arg_regs) {
			instr.operands.push_back(IRValue::reg(arg_reg));
		}
	}

	// Set the instruction's type hint
	if (result_type != IRInstruction::TypeHint_NONE) {
		instr.type_hint = result_type;
		set_register_type(result_reg, result_type);
	}

	func.instructions.push_back(instr);

	return result_reg;
}

int CodeGenerator::gen_inline_member_get(int obj_reg, IRInstruction::TypeHint obj_type, const std::string& member, IRFunction& func) {
	int result_reg = alloc_register();

	IRInstruction instr(IROpcode::VGET_INLINE);
	instr.operands.push_back(IRValue::reg(result_reg));
	instr.operands.push_back(IRValue::reg(obj_reg));
	instr.operands.push_back(IRValue::str(member));
	instr.operands.push_back(IRValue::imm(static_cast<int>(obj_type)));

	func.instructions.push_back(instr);

	// Result is always a float or int Variant
	bool is_int_vector = (obj_type == Variant::VECTOR2I ||
	                      obj_type == Variant::VECTOR3I ||
	                      obj_type == Variant::VECTOR4I);

	set_register_type(result_reg, is_int_vector ? Variant::INT : Variant::FLOAT);

	return result_reg;
}

std::unordered_set<std::string> CodeGenerator::get_global_classes() {
	// Common Godot global classes
	return {
		"AudioServer",
		"CameraServer",
		"DisplayServer",
		"NavigationServer2D",
		"NavigationServer3D",
		"PhysicsServer2D",
		"PhysicsServer3D",
		"TextServerManager",
		"ClassDB",
		"EditorInterface",
		"Engine",
		"EngineDebugger",
		"Geometry2D",
		"Geometry3D",
		"Input",
		"InputMap",
		"IP",
		"OS",
		"Performance",
		"ProjectSettings",
		"ResourceLoader",
		"ResourceSaver",
		"ThemeDB",
		"Time",
		"WorkerThreadPool",
	};
}

bool CodeGenerator::is_global_class(const std::string& name) const {
	static const auto global_classes = get_global_classes();
	return global_classes.find(name) != global_classes.end();
}

bool CodeGenerator::is_local_function(const std::string& name) const {
	return m_local_functions.find(name) != m_local_functions.end();
}

bool CodeGenerator::is_global_variable(const std::string& name) const {
	return m_global_variables.find(name) != m_global_variables.end();
}

int CodeGenerator::gen_global_class_get(const std::string& class_name, IRFunction& func) {
	// Generate a CALL_SYSCALL instruction to get the global class object
	// ECALL_GET_OBJ (504) takes: a0 = result pointer, a1 = class name pointer, a2 = class name length
	// Returns: a0 contains the object data

	int result_reg = alloc_register();

	// Add the class name as a string constant
	int str_idx = add_string_constant(class_name);

	// Generate CALL_SYSCALL instruction
	// Format: CALL_SYSCALL result_reg, syscall_number, string_index, string_length
	IRInstruction instr(IROpcode::CALL_SYSCALL);
	instr.operands.push_back(IRValue::reg(result_reg));              // result register
	instr.operands.push_back(IRValue::imm(504));                     // ECALL_GET_OBJ
	instr.operands.push_back(IRValue::imm(str_idx));                 // string constant index
	instr.operands.push_back(IRValue::imm(static_cast<int64_t>(class_name.length()))); // string length

	func.instructions.push_back(instr);

	// The result is an OBJECT Variant
	set_register_type(result_reg, IRInstruction::TypeHint_NONE); // Objects don't have a specific primitive type

	return result_reg;
}

} // namespace gdscript

```

`src/gdscript/compiler/codegen.h`:

```h
#pragma once
#include "ast.h"
#include "ir.h"
#include <unordered_map>
#include <unordered_set>
#include <string>

namespace gdscript {

class CodeGenerator {
public:
	CodeGenerator();

	IRProgram generate(const Program& program);

private:
	IRFunction generate_function(const FunctionDecl& func);

	// Statement code generation
	void gen_stmt(const Stmt* stmt, IRFunction& func);
	void gen_var_decl(const VarDeclStmt* stmt, IRFunction& func);
	void gen_assign(const AssignStmt* stmt, IRFunction& func);
	void gen_return(const ReturnStmt* stmt, IRFunction& func);
	void gen_if(const IfStmt* stmt, IRFunction& func);
	void gen_while(const WhileStmt* stmt, IRFunction& func);
	void gen_for(const ForStmt* stmt, IRFunction& func);
	void gen_break(const BreakStmt* stmt, IRFunction& func);
	void gen_continue(const ContinueStmt* stmt, IRFunction& func);
	void gen_expr_stmt(const ExprStmt* stmt, IRFunction& func);

	// Expression code generation (returns register containing result)
	int gen_expr(const Expr* expr, IRFunction& func);
	int gen_literal(const LiteralExpr* expr, IRFunction& func);
	int gen_variable(const VariableExpr* expr, IRFunction& func);
	int gen_binary(const BinaryExpr* expr, IRFunction& func);
	int gen_unary(const UnaryExpr* expr, IRFunction& func);
	int gen_call(const CallExpr* expr, IRFunction& func);
	int gen_member_call(const MemberCallExpr* expr, IRFunction& func);
	int gen_index(const IndexExpr* expr, IRFunction& func);
	int gen_array_literal(const ArrayLiteralExpr* expr, IRFunction& func);
	int gen_dictionary_literal(const DictionaryLiteralExpr* expr, IRFunction& func);

	// Utilities
	int alloc_register();
	void free_register(int reg);
	std::string make_label(const std::string& prefix);
	int add_string_constant(const std::string& str);

	// Variable management
	struct Variable {
		std::string name;
		int register_num; // Current register holding the value, or -1 if spilled
		IRInstruction::TypeHint type_hint = IRInstruction::TypeHint_NONE;
		bool is_const = false; // Whether this is a const variable
	};

	// Scope stack for nested blocks
	struct Scope {
		std::unordered_map<std::string, Variable> variables;
		size_t parent_scope_idx; // Index into m_scope_stack, SIZE_MAX for root
	};

	std::vector<Scope> m_scope_stack;
	int m_next_register = 0;
	int m_next_label = 0;
	std::vector<std::string> m_string_constants;

	// Type tracking for registers
	std::unordered_map<int, IRInstruction::TypeHint> m_register_types;

	// Scope management
	void push_scope();
	void pop_scope();
	Variable* find_variable(const std::string& name);
	void declare_variable(const std::string& name, int register_num, bool is_const = false);

	// Loop context for break/continue
	struct LoopContext {
		std::string break_label;
		std::string continue_label;
	};
	std::vector<LoopContext> m_loop_stack;

	// Type tracking helpers
	void set_register_type(int reg, IRInstruction::TypeHint type);
	IRInstruction::TypeHint get_register_type(int reg) const;
	bool is_inline_primitive_constructor(const std::string& name) const;
	bool is_inline_member_access(IRInstruction::TypeHint type, const std::string& member) const;
	int gen_inline_constructor(const std::string& name, const std::vector<int>& arg_regs, IRFunction& func);
	int gen_inline_member_get(int obj_reg, IRInstruction::TypeHint obj_type, const std::string& member, IRFunction& func);

	// Global class detection
	bool is_global_class(const std::string& name) const;
	int gen_global_class_get(const std::string& class_name, IRFunction& func);

	// Local function detection
	bool is_local_function(const std::string& name) const;

	// Set of global class names
	static std::unordered_set<std::string> get_global_classes();

	// Track locally defined functions
	std::unordered_set<std::string> m_local_functions;

	// Global variables
	std::unordered_map<std::string, size_t> m_global_variables; // Maps global name to index
	bool is_global_variable(const std::string& name) const;
};

} // namespace gdscript

```

`src/gdscript/compiler/compiler.cpp`:

```cpp
#include "compiler.h"
#include "lexer.h"
#include "parser.h"
#include "codegen.h"
#include "ir_optimizer.h"
#include "elf_builder.h"
#include <iostream>
#include <fstream>
#include <stdexcept>

namespace gdscript {

Compiler::Compiler() {}

std::vector<uint8_t> Compiler::compile(const std::string& source, const CompilerOptions& options) {
	try {
		// Step 1: Lexical analysis
		Lexer lexer(source);
		auto tokens = lexer.tokenize();

		if (options.dump_tokens) {
			std::cout << "=== TOKENS ===" << std::endl;
			for (const auto& token : tokens) {
				std::cout << token.to_string() << std::endl;
			}
			std::cout << std::endl;
		}

		// Step 2: Parsing
		Parser parser(tokens);
		Program program = parser.parse();

		if (options.dump_ast) {
			std::cout << "=== AST ===" << std::endl;
			std::cout << "Functions: " << program.functions.size() << std::endl;
			for (const auto& func : program.functions) {
				std::cout << "  func " << func.name << "(";
				for (size_t i = 0; i < func.parameters.size(); i++) {
					if (i > 0) std::cout << ", ";
					std::cout << func.parameters[i].name;
				}
				std::cout << "): " << func.body.size() << " statements" << std::endl;
			}
			std::cout << std::endl;
		}

		// Step 3: Code generation (AST -> IR)
		CodeGenerator codegen;
		IRProgram ir_program = codegen.generate(program);

		if (options.dump_ir) {
			std::cout << "=== IR (unoptimized) ===" << std::endl;
			for (const auto& func : ir_program.functions) {
				std::cout << "Function: " << func.name << std::endl;
				std::cout << "  Max registers: " << func.max_registers << std::endl;
				std::cout << "  Instructions:" << std::endl;
				for (const auto& instr : func.instructions) {
					std::cout << "    " << instr.to_string() << std::endl;
				}
				std::cout << std::endl;
			}

			std::cout << "String constants:" << std::endl;
			for (size_t i = 0; i < ir_program.string_constants.size(); i++) {
				std::cout << "  [" << i << "] \"" << ir_program.string_constants[i] << "\"" << std::endl;
			}
			std::cout << std::endl;
		}

		// Step 3.5: Optimize IR
		IROptimizer optimizer;
		optimizer.optimize(ir_program);

		if (options.dump_ir) {
			std::cout << "=== IR (optimized) ===" << std::endl;
			for (const auto& func : ir_program.functions) {
				std::cout << "Function: " << func.name << std::endl;
				std::cout << "  Max registers: " << func.max_registers << std::endl;
				std::cout << "  Instructions:" << std::endl;
				for (const auto& instr : func.instructions) {
					std::cout << "    " << instr.to_string() << std::endl;
				}
				std::cout << std::endl;
			}
		}

		// Step 4: RISC-V code generation (IR -> machine code)
		// For now, we'll create a minimal stub ELF
		std::vector<uint8_t> elf_data;

		if (options.output_elf) {
			ElfBuilder elf_builder;
			elf_data = elf_builder.build(ir_program);
		}

		m_error.clear();
		return elf_data;

	} catch (const std::exception& e) {
		m_error = e.what();
		return {};
	}
}

bool Compiler::compile_to_file(const std::string& source, const std::string& output_path, const CompilerOptions& options) {
	auto elf_data = compile(source, options);

	if (elf_data.empty()) {
		return false;
	}

	std::ofstream out(output_path, std::ios::binary);
	if (!out) {
		m_error = "Failed to open output file: " + output_path;
		return false;
	}

	out.write(reinterpret_cast<const char*>(elf_data.data()), elf_data.size());
	out.close();

	return out.good();
}

} // namespace gdscript

```

`src/gdscript/compiler/compiler.h`:

```h
#pragma once
#include <string>
#include <vector>
#include <cstdint>

namespace gdscript {

struct CompilerOptions {
	bool dump_tokens = false;
	bool dump_ast = false;
	bool dump_ir = false;
	bool output_elf = true;
	std::string output_path;
};

class Compiler {
public:
	Compiler();

	// Compile GDScript source to RISC-V ELF
	std::vector<uint8_t> compile(const std::string& source, const CompilerOptions& options = {});

	// Compile to file
	bool compile_to_file(const std::string& source, const std::string& output_path, const CompilerOptions& options = {});

	// Get last error message
	std::string get_error() const { return m_error; }

private:
	std::string m_error;
};

} // namespace gdscript

```

`src/gdscript/compiler/compiler_exception.cpp`:

```cpp
#include "compiler_exception.h"

namespace gdscript {

const char* error_type_to_string(ErrorType type) {
	switch (type) {
		case ErrorType::LEXER_ERROR:         return "Lexer Error";
		case ErrorType::PARSER_ERROR:        return "Parser Error";
		case ErrorType::SEMANTIC_ERROR:      return "Semantic Error";
		case ErrorType::CODEGEN_ERROR:       return "Code Generation Error";
		case ErrorType::RISCV_codegen_ERROR: return "RISC-V Code Generation Error";
		case ErrorType::OPTIMIZER_ERROR:     return "Optimizer Error";
		case ErrorType::ELF_ERROR:           return "ELF Error";
		case ErrorType::UNKNOWN_ERROR:       return "Unknown Error";
		default:                             return "Unknown Error";
	}
}

} // namespace gdscript

```

`src/gdscript/compiler/compiler_exception.h`:

```h
#pragma once

#include <string>
#include <optional>
#include <exception>
#include <sstream>

namespace gdscript {

/**
 * Categories of compilation errors.
 * Helps users understand what phase of compilation failed.
 */
enum class ErrorType {
	LEXER_ERROR,          // Tokenization errors
	PARSER_ERROR,         // Syntax errors
	SEMANTIC_ERROR,       // Type checking, variable validation, etc.
	CODEGEN_ERROR,        // IR generation errors
	RISCV_codegen_ERROR,  // RISC-V code generation errors
	OPTIMIZER_ERROR,      // IR optimization errors
	ELF_ERROR,            // ELF binary creation errors
	UNKNOWN_ERROR
};

/**
 * Converts ErrorType to a human-readable string.
 */
const char* error_type_to_string(ErrorType type);

/**
 * Rich exception class for GDScript compiler errors.
 *
 * Captures comprehensive context including:
 * - Error message
 * - Error type/category
 * - Source location (line, column)
 * - Function/method context
 * - Source code snippet (when available)
 * - Hints for fixing the error
 *
 * All information is preserved through the compilation pipeline
 * to provide end-users with actionable error messages.
 */
class CompilerException : public std::exception {
private:
	ErrorType m_error_type;
	std::string m_message;
	std::string m_file;          // Source file (if known)
	int m_line = 0;              // Line number (0 if unknown)
	int m_column = 0;            // Column number (0 if unknown)
	std::string m_function;      // Function name (empty if global scope)
	std::string m_source_line;   // The actual source line that caused the error
	std::string m_hint;          // Helpful hint for fixing the error
	mutable std::string m_what;  // Cached formatted message

public:
	/**
	 * Constructor with full context information.
	 *
	 * @param error_type  The category of error
	 * @param message     The primary error message
	 * @param line        Line number (optional, defaults to 0)
	 * @param column      Column number (optional, defaults to 0)
	 * @param function    Function name where error occurred (optional)
	 * @param file        Source file name (optional)
	 * @param source_line The actual source code line (optional)
	 * @param hint        Helpful hint for fixing the error (optional)
	 */
	CompilerException(
		ErrorType error_type,
		const std::string& message,
		int line = 0,
		int column = 0,
		const std::string& function = "",
		const std::string& file = "",
		const std::string& source_line = "",
		const std::string& hint = ""
	)
		: m_error_type(error_type)
		, m_message(message)
		, m_file(file)
		, m_line(line)
		, m_column(column)
		, m_function(function)
		, m_source_line(source_line)
		, m_hint(hint)
	{}

	// Getters

	ErrorType error_type() const { return m_error_type; }
	const char* error_type_string() const { return error_type_to_string(m_error_type); }

	const char* what() const noexcept override {
		if (m_what.empty()) {
			m_what = format_message();
		}
		return m_what.c_str();
	}

	const std::string& message() const { return m_message; }
	const std::string& file() const { return m_file; }
	int line() const { return m_line; }
	int column() const { return m_column; }
	const std::string& function() const { return m_function; }
	const std::string& source_line() const { return m_source_line; }
	const std::string& hint() const { return m_hint; }

	/**
	 * Setters for adding context after construction.
	 * Useful when building exceptions gradually through the pipeline.
	 */
	void set_function(const std::string& function) { m_function = function; m_what.clear(); }
	void set_file(const std::string& file) { m_file = file; m_what.clear(); }
	void set_source_line(const std::string& source_line) { m_source_line = source_line; m_what.clear(); }
	void set_hint(const std::string& hint) { m_hint = hint; m_what.clear(); }

	/**
	 * Formats the complete error message with all available context.
	 * This is what gets returned by what().
	 */
	std::string format_message() const {
		std::ostringstream oss;

		// Error type and primary message
		oss << "[" << error_type_string() << "] " << m_message;

		// Location information
		if (m_line > 0) {
			oss << " (line " << m_line;
			if (m_column > 0) {
				oss << ", column " << m_column;
			}
			oss << ")";
		}

		// Function context
		if (!m_function.empty()) {
			oss << "\n  in function: " << m_function;
		}

		// File information
		if (!m_file.empty()) {
			oss << "\n  in file: " << m_file;
		}

		// Source line snippet
		if (!m_source_line.empty()) {
			oss << "\n\n  " << m_source_line;
			if (m_column > 0) {
				// Add a pointer to the exact column
				oss << "\n  ";
				for (int i = 1; i < m_column; ++i) {
					// Handle tabs (assume tab width of 4 for simplicity)
					if (static_cast<size_t>(i - 1) < m_source_line.length() && m_source_line[i - 1] == '\t') {
						oss << "    ";
					} else {
						oss << " ";
					}
				}
				oss << "^";
			}
		}

		// Helpful hint
		if (!m_hint.empty()) {
			oss << "\n\n  Hint: " << m_hint;
		}

		return oss.str();
	}

	/**
	 * Returns a compact one-line error message.
	 * Useful for logging or when you don't need the full formatted output.
	 */
	std::string to_string() const {
		std::ostringstream oss;
		oss << "[" << error_type_string() << "] " << m_message;

		if (m_line > 0) {
			oss << " at line " << m_line;
			if (m_column > 0) {
				oss << ":" << m_column;
			}
		}

		if (!m_function.empty()) {
			oss << " in '" << m_function << "'";
		}

		return oss.str();
	}

	/**
	 * Helper factory methods for common error scenarios.
	 * These make it easier to throw exceptions with consistent formatting.
	 */

	static CompilerException lexer_error(const std::string& message, int line, int column) {
		return CompilerException(ErrorType::LEXER_ERROR, message, line, column);
	}

	static CompilerException parser_error(const std::string& message, int line, int column) {
		return CompilerException(ErrorType::PARSER_ERROR, message, line, column);
	}

	static CompilerException semantic_error(const std::string& message, int line, int column, const std::string& function = "") {
		return CompilerException(ErrorType::SEMANTIC_ERROR, message, line, column, function);
	}

	static CompilerException codegen_error(const std::string& message, const std::string& function = "") {
		return CompilerException(ErrorType::CODEGEN_ERROR, message, 0, 0, function);
	}

	static CompilerException riscv_codegen_error(const std::string& message, const std::string& function = "") {
		return CompilerException(ErrorType::RISCV_codegen_ERROR, message, 0, 0, function);
	}

	static CompilerException undefined_variable(const std::string& var_name, int line, int column, const std::string& function = "") {
		return CompilerException(
			ErrorType::SEMANTIC_ERROR,
			"Undefined variable: " + var_name,
			line,
			column,
			function,
			"",
			"",
			"Make sure '" + var_name + "' is declared before use"
		);
	}

	static CompilerException type_error(const std::string& message, int line, int column, const std::string& function = "") {
		return CompilerException(
			ErrorType::SEMANTIC_ERROR,
			"Type error: " + message,
			line,
			column,
			function
		);
	}

	static CompilerException syntax_error(const std::string& message, int line, int column) {
		return CompilerException(
			ErrorType::PARSER_ERROR,
			"Syntax error: " + message,
			line,
			column
		);
	}
};

/**
 * Helper macro to throw CompilerException with current file and line.
 * Useful for quick errors during development.
 */
#define THROW_COMPILER_ERROR(error_type, message) \
	throw gdscript::CompilerException((error_type), (message), __LINE__, 0, __func__, __FILE__)

} // namespace gdscript

```

`src/gdscript/compiler/dump_ir.cpp`:

```cpp
#include "lexer.h"
#include "parser.h"
#include "codegen.h"
#include "ir_optimizer.h"
#include "riscv_codegen.h"
#include <iostream>
#include <variant>
#include <iomanip>
#include <limits>
#include <sstream>
#include <set>

using namespace gdscript;

// RISC-V register names
const char* reg_name(uint8_t reg) {
	static const char* names[] = {
		"x0", "ra", "sp", "gp", "tp",
		"t0", "t1", "t2", "fp", "s1",
		"a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7",
		"s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11",
		"t3", "t4", "t5", "t6"
	};
	if (reg < 32) return names[reg];
	return "?";
}

// Helper to convert TypeHint to string
const char* type_hint_name(IRInstruction::TypeHint hint) {
	if (hint == IRInstruction::TypeHint_NONE) {
		return "NONE";
	}
	// Use Variant::Type enum values directly
	switch (hint) {
		case Variant::NIL: return "NIL";
		case Variant::BOOL: return "BOOL";
		case Variant::INT: return "INT";
		case Variant::FLOAT: return "FLOAT";
		case Variant::STRING: return "STRING";
		case Variant::STRING_NAME: return "STRING_NAME";
		case Variant::NODE_PATH: return "NODE_PATH";
		case Variant::VECTOR2: return "VECTOR2";
		case Variant::VECTOR2I: return "VECTOR2I";
		case Variant::VECTOR3: return "VECTOR3";
		case Variant::VECTOR3I: return "VECTOR3I";
		case Variant::VECTOR4: return "VECTOR4";
		case Variant::VECTOR4I: return "VECTOR4I";
		case Variant::COLOR: return "COLOR";
		case Variant::RECT2: return "RECT2";
		case Variant::RECT2I: return "RECT2I";
		case Variant::TRANSFORM2D: return "TRANSFORM2D";
		case Variant::TRANSFORM3D: return "TRANSFORM3D";
		case Variant::BASIS: return "BASIS";
		case Variant::QUATERNION: return "QUATERNION";
		case Variant::PLANE: return "PLANE";
		case Variant::AABB: return "AABB";
		case Variant::PROJECTION: return "PROJECTION";
		case Variant::ARRAY: return "ARRAY";
		case Variant::DICTIONARY: return "DICTIONARY";
		case Variant::RID: return "RID";
		case Variant::CALLABLE: return "CALLABLE";
		case Variant::SIGNAL: return "SIGNAL";
		case Variant::PACKED_BYTE_ARRAY: return "PACKED_BYTE_ARRAY";
		case Variant::PACKED_INT32_ARRAY: return "PACKED_INT32_ARRAY";
		case Variant::PACKED_INT64_ARRAY: return "PACKED_INT64_ARRAY";
		case Variant::PACKED_FLOAT32_ARRAY: return "PACKED_FLOAT32_ARRAY";
		case Variant::PACKED_FLOAT64_ARRAY: return "PACKED_FLOAT64_ARRAY";
		case Variant::PACKED_STRING_ARRAY: return "PACKED_STRING_ARRAY";
		case Variant::PACKED_VECTOR2_ARRAY: return "PACKED_VECTOR2_ARRAY";
		case Variant::PACKED_VECTOR3_ARRAY: return "PACKED_VECTOR3_ARRAY";
		case Variant::PACKED_COLOR_ARRAY: return "PACKED_COLOR_ARRAY";
		case Variant::PACKED_VECTOR4_ARRAY: return "PACKED_VECTOR4_ARRAY";
		default: return "UNKNOWN";
	}
}

// Helper to format operand with detailed type info
std::string format_operand_detailed(const IRValue& op) {
	std::ostringstream oss;

	switch (op.type) {
		case IRValue::Type::REGISTER:
			oss << "r" << std::get<int>(op.value);
			break;
		case IRValue::Type::IMMEDIATE: {
			int64_t val = std::get<int64_t>(op.value);
			oss << val << " (0x" << std::hex << val << std::dec << ")";
			break;
		}
		case IRValue::Type::FLOAT: {
			double val = std::get<double>(op.value);
			oss << std::setprecision(std::numeric_limits<double>::max_digits10) << val;
			break;
		}
		case IRValue::Type::LABEL:
			oss << "@" << std::get<std::string>(op.value);
			break;
		case IRValue::Type::VARIABLE:
			oss << "$" << std::get<std::string>(op.value);
			break;
		case IRValue::Type::STRING:
			oss << "\"" << std::get<std::string>(op.value) << "\"";
			break;
	}

	return oss.str();
}

int main(int argc, char** argv)
{
	std::string source;
	bool verbose = false;
	bool no_optimize = false;
	bool show_codegen = false;

	// Parse arguments
	for (int i = 1; i < argc; i++) {
		std::string arg = argv[i];
		if (arg == "-v" || arg == "--verbose") {
			verbose = true;
		} else if (arg == "--no-opt" || arg == "--no-optimize") {
			no_optimize = true;
		} else if (arg == "--codegen" || arg == "-c") {
			show_codegen = true;
		} else if (source.empty()) {
			source = arg;
		}
	}

	if (source.empty()) {
		// Read from stdin
		std::string line;
		while (std::getline(std::cin, line)) {
			source += line + "\n";
		}
	}

	try {
		Lexer lexer(source);
		auto tokens = lexer.tokenize();

		if (verbose) {
			std::cout << "=== TOKENS ===" << std::endl;
			for (const auto& tok : tokens) {
				std::cout << "  " << tok.lexeme << " [type=" << token_type_name(tok.type) << "]" << std::endl;
			}
			std::cout << std::endl;
		}

		Parser parser(tokens);
		Program program = parser.parse();

		if (verbose) {
			std::cout << "=== AST ===" << std::endl;
			std::cout << "  Functions: " << program.functions.size() << std::endl;
			for (const auto& func : program.functions) {
				std::cout << "    " << func.name << "(";
				for (size_t i = 0; i < func.parameters.size(); i++) {
					if (i > 0) std::cout << ", ";
					std::cout << func.parameters[i].name;
				}
				std::cout << ") - " << func.body.size() << " statement(s)" << std::endl;
			}
			std::cout << std::endl;
		}

		CodeGenerator codegen;
		IRProgram ir = codegen.generate(program);

		// Apply optimizations unless disabled
		if (!no_optimize) {
			IROptimizer optimizer;
			optimizer.optimize(ir);
		}

		// Print global variables
		if (!ir.globals.empty()) {
			std::cout << "=== GLOBAL VARIABLES ===" << std::endl;
			for (size_t i = 0; i < ir.globals.size(); i++) {
				const auto& global = ir.globals[i];
				std::cout << "  [" << i << "] " << global.name;

				if (global.is_property) {
					std::cout << " (@export)";
				}

				if (global.is_const) {
					std::cout << " (const)";
				}

				if (global.type_hint != IRInstruction::TypeHint_NONE) {
					std::cout << ": " << type_hint_name(global.type_hint);
				}

				if (global.init_type != IRGlobalVar::InitType::NONE) {
					std::cout << " = ";
					switch (global.init_type) {
						case IRGlobalVar::InitType::INT:
							std::cout << std::get<int64_t>(global.init_value);
							break;
						case IRGlobalVar::InitType::FLOAT:
							std::cout << std::get<double>(global.init_value);
							break;
						case IRGlobalVar::InitType::STRING:
							std::cout << "\"" << std::get<std::string>(global.init_value) << "\"";
							break;
						case IRGlobalVar::InitType::BOOL:
							std::cout << (std::get<bool>(global.init_value) ? "true" : "false");
							break;
						case IRGlobalVar::InitType::EMPTY_ARRAY:
							std::cout << "[]";
							break;
						case IRGlobalVar::InitType::EMPTY_DICT:
							std::cout << "{}";
							break;
						default:
							std::cout << "?";
							break;
					}
				}

				std::cout << std::endl;
			}
			std::cout << std::endl;
		}

		// Print string constants
		if (!ir.string_constants.empty()) {
			std::cout << "=== STRING CONSTANTS ===" << std::endl;
			for (size_t i = 0; i < ir.string_constants.size(); i++) {
				std::cout << "  [" << i << "] \"" << ir.string_constants[i] << "\"" << std::endl;
			}
			std::cout << std::endl;
		}

		// Print functions
		for (const auto& func : ir.functions) {
			std::cout << "=== Function: " << func.name << "(";
			for (size_t i = 0; i < func.parameters.size(); i++) {
				if (i > 0) std::cout << ", ";
				std::cout << func.parameters[i];
			}
			std::cout << ") ===" << std::endl;
			std::cout << "max_registers: " << func.max_registers << std::endl;
			std::cout << std::endl;

			// Initialize register allocator to simulate codegen
			RegisterAllocator allocator;
			allocator.init(func);

			// Track value types like codegen does
			enum class ValueType {
				UNKNOWN,
				VARIANT
			};
			std::unordered_map<int, ValueType> vreg_types;
			std::unordered_map<int, int> variant_offsets;
			int next_variant_slot = func.parameters.size();

			// Helper to get value type name
			auto value_type_name = [](ValueType t) -> const char* {
				switch (t) {
					case ValueType::VARIANT: return "VARIANT";
					default: return "UNKNOWN";
				}
			};

			// Simulate type inference from instructions
			for (size_t i = 0; i < func.instructions.size(); i++) {
				const auto& instr = func.instructions[i];

				// Collect all vregs used in this instruction
				std::set<int> used_vregs;
				for (const auto& op : instr.operands) {
					if (op.type == IRValue::Type::REGISTER) {
						used_vregs.insert(std::get<int>(op.value));
					}
				}

				// Infer types from instruction
				ValueType result_type = ValueType::UNKNOWN;

				switch (instr.opcode) {
					case IROpcode::LOAD_IMM:
					case IROpcode::LOAD_FLOAT_IMM:
					case IROpcode::LOAD_BOOL:
					case IROpcode::LOAD_STRING:
					case IROpcode::CALL_SYSCALL:
					case IROpcode::VCALL:
					case IROpcode::VGET:
					case IROpcode::VSET:
					case IROpcode::MAKE_ARRAY:
					case IROpcode::MAKE_PACKED_BYTE_ARRAY:
					case IROpcode::MAKE_PACKED_INT32_ARRAY:
					case IROpcode::MAKE_PACKED_INT64_ARRAY:
					case IROpcode::MAKE_PACKED_FLOAT32_ARRAY:
					case IROpcode::MAKE_PACKED_FLOAT64_ARRAY:
					case IROpcode::MAKE_PACKED_STRING_ARRAY:
					case IROpcode::MAKE_PACKED_VECTOR2_ARRAY:
					case IROpcode::MAKE_PACKED_VECTOR3_ARRAY:
					case IROpcode::MAKE_PACKED_COLOR_ARRAY:
					case IROpcode::MAKE_PACKED_VECTOR4_ARRAY:
					case IROpcode::MAKE_DICTIONARY:
					case IROpcode::ADD:
					case IROpcode::SUB:
					case IROpcode::MUL:
					case IROpcode::DIV:
					case IROpcode::MOD:
						result_type = ValueType::VARIANT;
						break;
					default:
						break;
				}

				// Mark result register
				if (result_type != ValueType::UNKNOWN && !instr.operands.empty() &&
				    instr.operands[0].type == IRValue::Type::REGISTER) {
					int result_vreg = std::get<int>(instr.operands[0].value);
					vreg_types[result_vreg] = result_type;
					if (result_type == ValueType::VARIANT) {
						variant_offsets[result_vreg] = next_variant_slot++;
					}
				}

				// Format instruction index
				std::cout << std::setw(4) << i << ": ";

				// Format opcode
				std::cout << std::setw(20) << std::left << ir_opcode_name(instr.opcode);

				// Format operands with register allocation info
				for (size_t j = 0; j < instr.operands.size(); j++) {
					if (j > 0) std::cout << ", ";
					if (verbose) {
						std::cout << format_operand_detailed(instr.operands[j]);
					} else {
						std::cout << instr.operands[j].to_string();
					}

					// Show register allocation if codegen mode
					if (show_codegen && instr.operands[j].type == IRValue::Type::REGISTER) {
						int vreg = std::get<int>(instr.operands[j].value);
						int preg = allocator.allocate_register(vreg, i);

						std::cout << "(";
						if (preg >= 0) {
							std::cout << reg_name(preg);
						} else {
							std::cout << "spilled";
						}
						std::cout << ")";

						// Show value type if known
						if (vreg_types.count(vreg)) {
							std::cout << "[" << value_type_name(vreg_types[vreg]) << "]";
							if (vreg_types[vreg] == ValueType::VARIANT && variant_offsets.count(vreg)) {
								std::cout << "[slot" << variant_offsets[vreg] << "]";
							}
						}
					}
				}

				// Show type hint if present
				if (instr.type_hint != IRInstruction::TypeHint_NONE) {
					std::cout << "  [type: " << type_hint_name(instr.type_hint) << "]";
				}

				// Add semantic comments for certain instructions
				if (!verbose) {
					switch (instr.opcode) {
						case IROpcode::MAKE_VECTOR2:
						case IROpcode::MAKE_VECTOR3:
						case IROpcode::MAKE_VECTOR4:
						case IROpcode::MAKE_VECTOR2I:
						case IROpcode::MAKE_VECTOR3I:
						case IROpcode::MAKE_VECTOR4I:
						case IROpcode::MAKE_COLOR:
							std::cout << "  ; Inline construction";
							break;
						case IROpcode::VGET_INLINE:
							if (instr.operands.size() >= 3) {
								std::cout << "  ; Get inline member";
							}
							break;
						case IROpcode::VSET_INLINE:
							if (instr.operands.size() >= 3) {
								std::cout << "  ; Set inline member";
							}
							break;
						case IROpcode::VGET:
							if (instr.operands.size() >= 3) {
								std::cout << "  ; Property get (sugar for obj.get)";
							}
							break;
						case IROpcode::VSET:
							if (instr.operands.size() >= 3) {
								std::cout << "  ; Property set (sugar for obj.set)";
							}
							break;
						default:
							break;
					}
				}

				std::cout << std::endl;
			}
			std::cout << std::endl;
		}

		return 0;
	} catch (const std::exception& e) {
		std::cerr << "Error: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/elf_builder.cpp`:

```cpp
#include "elf_builder.h"
#include "riscv_codegen.h"
#include <cstring>
#include <stdexcept>

namespace gdscript {

ElfBuilder::ElfBuilder() {}

std::vector<uint8_t> ElfBuilder::build(const IRProgram& program) {
	// Generate RISC-V machine code from IR
	RISCVCodeGen codegen;
	std::vector<uint8_t> code = codegen.generate(program);
	auto func_offsets = codegen.get_function_offsets();
	auto const_pool = codegen.get_constant_pool();
	auto global_data_size = codegen.get_global_data_size();

	// Build complete ELF file
	std::vector<uint8_t> elf_data;

	// Calculate offsets
	size_t ehdr_size = sizeof(Elf64_Ehdr);
	size_t phdr_size = sizeof(Elf64_Phdr);
	size_t shdr_size = sizeof(Elf64_Shdr);

	// Determine if we need separate .text and .data segments
	// If we have global variables, we need two PT_LOAD segments:
	// 1. .text segment (R+X) - code and constants
	// 2. .data segment (R+W) - global variables
	bool has_globals = global_data_size > 0;
	size_t num_phdrs = has_globals ? 2 : 1;

	// We'll have 5 or 6 sections depending on whether we have globals
	// NULL, .text, [.data], .symtab, .strtab, .shstrtab
	size_t num_sections = has_globals ? 6 : 5;

	// Calculate section sizes
	// The code vector includes: code + constant pool + global data (if any)
	// We need to split it if we have globals
	size_t text_size = code.size() - global_data_size;
	size_t data_size = global_data_size;

	// Build string tables
	std::vector<std::string> section_names;
	if (has_globals) {
		section_names = {"", ".text", ".data", ".symtab", ".strtab", ".shstrtab"};
	} else {
		section_names = {"", ".text", ".symtab", ".strtab", ".shstrtab"};
	}
	std::vector<uint8_t> shstrtab;
	shstrtab.reserve(1 + (1 + section_names.size()) * 10); // Rough estimate
	std::vector<size_t> section_name_offsets;
	section_name_offsets.reserve(section_names.size());

	for (const auto& name : section_names) {
		section_name_offsets.push_back(shstrtab.size());
		shstrtab.insert(shstrtab.end(), name.begin(), name.end());
		shstrtab.push_back(0);
	}

	// Build symbol string table
	std::vector<uint8_t> strtab;
	strtab.push_back(0); // First byte is always null

	std::vector<std::string> symbol_names;
	symbol_names.reserve(program.functions.size());
	std::vector<size_t> symbol_name_offsets;
	symbol_name_offsets.reserve(program.functions.size());

	for (const auto& func : program.functions) {
		symbol_names.push_back(func.name);
		symbol_name_offsets.push_back(strtab.size());
		strtab.insert(strtab.end(), func.name.begin(), func.name.end());
		strtab.push_back(0);
	}

	// Build symbol table
	// NOTE: Keep this struct defined here to avoid any issues with alignment/packing
	struct alignas(8) Elf64_Sym {
		uint32_t st_name;
		uint8_t st_info;
		uint8_t st_other;
		uint16_t st_shndx;
		uint64_t st_value;
		uint64_t st_size;
	};

	static_assert(sizeof(Elf64_Sym) == 24, "Elf64_Sym must be 24 bytes");

	std::vector<Elf64_Sym> symtab;
	symtab.reserve(1 + program.functions.size());

	// First symbol is always null
	Elf64_Sym null_sym = {};
	memset(&null_sym, 0, sizeof(null_sym));  // Ensure all bytes are zero
	symtab.push_back(null_sym);

	// Add function symbols
	for (size_t i = 0; i < program.functions.size(); i++) {
		const auto& func = program.functions[i];
		size_t func_offset = func_offsets.at(func.name);

		// Calculate function size (distance to next function or end of text section)
		size_t func_size = text_size - func_offset;
		if (i + 1 < program.functions.size()) {
			const auto& next_func = program.functions[i + 1];
			size_t next_offset = func_offsets.at(next_func.name);
			func_size = next_offset - func_offset;
		}

		Elf64_Sym sym = {};
		memset(&sym, 0, sizeof(sym));  // Ensure all bytes are zero
		sym.st_name = static_cast<uint32_t>(symbol_name_offsets[i]);
		sym.st_info = (1 << 4) | 2; // STB_GLOBAL (1) << 4 | STT_FUNC (2)
		sym.st_other = 0;
		sym.st_shndx = 1; // .text section
		sym.st_value = BASE_ADDR + func_offset; // Actual function address
		sym.st_size = func_size;
		symtab.push_back(sym);
	}

	size_t symtab_size = symtab.size() * sizeof(Elf64_Sym);

	// Calculate file layout
	size_t offset = 0;

	// ELF header
	size_t ehdr_offset = offset;
	offset += ehdr_size;

	// Program headers
	size_t phdr_offset = offset;
	offset += num_phdrs * phdr_size;

	// Align to page
	offset = (offset + 0xFFF) & ~0xFFF;

	// .text section (code + constant pool)
	size_t text_offset = offset;
	offset += text_size;

	// .data section (global variables) - only if we have globals
	size_t data_offset = 0;
	if (has_globals) {
		// Align to page boundary for separate PT_LOAD segment
		offset = (offset + 0xFFF) & ~0xFFF;
		data_offset = offset;
		offset += data_size;
	}

	// Align
	offset = (offset + 7) & ~7;

	// .symtab section
	size_t symtab_offset = offset;
	offset += symtab_size;

	// .strtab section
	size_t strtab_offset = offset;
	offset += strtab.size();

	// .shstrtab section
	size_t shstrtab_offset = offset;
	offset += shstrtab.size();

	// Align
	offset = (offset + 7) & ~7;

	// Section headers
	size_t shdr_offset = offset;

	// Now write everything

	// 1. ELF Header
	Elf64_Ehdr ehdr;
	memset(&ehdr, 0, sizeof(ehdr));

	ehdr.e_ident[0] = 0x7f;
	ehdr.e_ident[1] = 'E';
	ehdr.e_ident[2] = 'L';
	ehdr.e_ident[3] = 'F';
	ehdr.e_ident[4] = 2;      // 64-bit
	ehdr.e_ident[5] = 1;      // Little endian
	ehdr.e_ident[6] = 1;      // ELF version
	ehdr.e_ident[7] = 0;      // System V ABI

	ehdr.e_type = ET_EXEC;
	ehdr.e_machine = EM_RISCV;
	ehdr.e_version = EV_CURRENT;
	ehdr.e_entry = BASE_ADDR;
	ehdr.e_phoff = phdr_offset;
	ehdr.e_shoff = shdr_offset;
	ehdr.e_flags = 0x5; // RV64I + RV64M (multiply/divide)
	ehdr.e_ehsize = sizeof(Elf64_Ehdr);
	ehdr.e_phentsize = sizeof(Elf64_Phdr);
	ehdr.e_phnum = static_cast<uint16_t>(num_phdrs);
	ehdr.e_shentsize = sizeof(Elf64_Shdr);
	ehdr.e_shnum = static_cast<uint16_t>(num_sections);
	ehdr.e_shstrndx = has_globals ? 5 : 4; // .shstrtab is the last section

	write_value(elf_data, ehdr);

	// 2. Program Headers
	// First PT_LOAD: .text (R+X) - code and constants
	Elf64_Phdr phdr_text;
	memset(&phdr_text, 0, sizeof(phdr_text));

	phdr_text.p_type = 1; // PT_LOAD
	phdr_text.p_flags = 5; // PF_R | PF_X (readable + executable)
	phdr_text.p_offset = static_cast<uint64_t>(text_offset);
	phdr_text.p_vaddr = BASE_ADDR;
	phdr_text.p_paddr = BASE_ADDR;
	phdr_text.p_filesz = static_cast<uint64_t>(text_size);
	phdr_text.p_memsz = static_cast<uint64_t>(text_size);
	phdr_text.p_align = 0x1000;

	write_value(elf_data, phdr_text);

	// Second PT_LOAD: .data (R+W) - global variables (if any)
	if (has_globals) {
		// Calculate data virtual address (after text segment, aligned to page)
		uint64_t data_vaddr = BASE_ADDR + text_size;
		data_vaddr = (data_vaddr + 0xFFF) & ~0xFFFULL; // Align to 4KB page

		Elf64_Phdr phdr_data;
		memset(&phdr_data, 0, sizeof(phdr_data));

		phdr_data.p_type = 1; // PT_LOAD
		phdr_data.p_flags = 6; // PF_R | PF_W (readable + writable)
		phdr_data.p_offset = static_cast<uint64_t>(data_offset);
		phdr_data.p_vaddr = data_vaddr;
		phdr_data.p_paddr = data_vaddr;
		phdr_data.p_filesz = static_cast<uint64_t>(data_size);
		phdr_data.p_memsz = static_cast<uint64_t>(data_size);
		phdr_data.p_align = 0x1000;

		write_value(elf_data, phdr_data);
	}

	// Pad to text section
	while (elf_data.size() < text_offset) {
		elf_data.push_back(0);
	}

	// 3. .text section (code + constant pool, excluding global data)
	elf_data.insert(elf_data.end(), code.begin(), code.begin() + text_size);

	// 4. .data section (global variables) - only if we have globals
	if (has_globals) {
		// Pad to data section
		while (elf_data.size() < data_offset) {
			elf_data.push_back(0);
		}
		// Write global data
		elf_data.insert(elf_data.end(), code.begin() + text_size, code.end());
	}

	// Pad to symtab
	while (elf_data.size() < symtab_offset) {
		elf_data.push_back(0);
	}

	// 4. .symtab section
	for (const auto& sym : symtab) {
		write_value(elf_data, sym);
	}

	// 5. .strtab section
	elf_data.insert(elf_data.end(), strtab.begin(), strtab.end());

	// 6. .shstrtab section
	elf_data.insert(elf_data.end(), shstrtab.begin(), shstrtab.end());

	// Pad to section headers
	while (elf_data.size() < shdr_offset) {
		elf_data.push_back(0);
	}

	// 7. Section Headers

	// Section 0: NULL
	Elf64_Shdr shdr_null = {};
	write_value(elf_data, shdr_null);

	// Section 1: .text
	Elf64_Shdr shdr_text = {};
	shdr_text.sh_name = static_cast<uint32_t>(section_name_offsets[1]);
	shdr_text.sh_type = 1; // SHT_PROGBITS
	shdr_text.sh_flags = 6; // SHF_ALLOC | SHF_EXECINSTR
	shdr_text.sh_addr = BASE_ADDR;
	shdr_text.sh_offset = static_cast<uint64_t>(text_offset);
	shdr_text.sh_size = static_cast<uint64_t>(text_size);
	shdr_text.sh_addralign = 4;
	write_value(elf_data, shdr_text);

	// Section 2: .data (only if we have globals)
	if (has_globals) {
		// Calculate data virtual address (same as in PT_LOAD)
		uint64_t data_vaddr = BASE_ADDR + text_size;
		data_vaddr = (data_vaddr + 0xFFF) & ~0xFFFULL; // Align to 4KB page

		Elf64_Shdr shdr_data = {};
		shdr_data.sh_name = static_cast<uint32_t>(section_name_offsets[2]);
		shdr_data.sh_type = 1; // SHT_PROGBITS
		shdr_data.sh_flags = 3; // SHF_WRITE | SHF_ALLOC
		shdr_data.sh_addr = data_vaddr;
		shdr_data.sh_offset = static_cast<uint64_t>(data_offset);
		shdr_data.sh_size = static_cast<uint64_t>(data_size);
		shdr_data.sh_addralign = 8;
		write_value(elf_data, shdr_data);
	}

	// Section: .symtab (index 2 or 3 depending on has_globals)
	size_t symtab_idx = has_globals ? 3 : 2;
	size_t strtab_idx = has_globals ? 4 : 3;
	Elf64_Shdr shdr_symtab = {};
	shdr_symtab.sh_name = static_cast<uint32_t>(section_name_offsets[symtab_idx]);
	shdr_symtab.sh_type = 2; // SHT_SYMTAB
	shdr_symtab.sh_offset = static_cast<uint64_t>(symtab_offset);
	shdr_symtab.sh_size = static_cast<uint64_t>(symtab_size);
	shdr_symtab.sh_link = static_cast<uint32_t>(strtab_idx); // Link to .strtab
	shdr_symtab.sh_info = 1; // Index of first non-local symbol
	shdr_symtab.sh_addralign = 8;
	shdr_symtab.sh_entsize = sizeof(Elf64_Sym);
	write_value(elf_data, shdr_symtab);

	// Section: .strtab
	Elf64_Shdr shdr_strtab = {};
	shdr_strtab.sh_name = static_cast<uint32_t>(section_name_offsets[strtab_idx]);
	shdr_strtab.sh_type = 3; // SHT_STRTAB
	shdr_strtab.sh_offset = static_cast<uint64_t>(strtab_offset);
	shdr_strtab.sh_size = static_cast<uint64_t>(strtab.size());
	shdr_strtab.sh_addralign = 1;
	write_value(elf_data, shdr_strtab);

	// Section: .shstrtab
	size_t shstrtab_idx = has_globals ? 5 : 4;
	Elf64_Shdr shdr_shstrtab = {};
	shdr_shstrtab.sh_name = static_cast<uint32_t>(section_name_offsets[shstrtab_idx]);
	shdr_shstrtab.sh_type = 3; // SHT_STRTAB
	shdr_shstrtab.sh_offset = static_cast<uint64_t>(shstrtab_offset);
	shdr_shstrtab.sh_size = static_cast<uint64_t>(shstrtab.size());
	shdr_shstrtab.sh_addralign = 1;
	write_value(elf_data, shdr_shstrtab);

	return elf_data;
}

void ElfBuilder::write_elf_header(std::vector<uint8_t>& data, uint64_t entry_point) {
	// Deprecated - now handled in build()
}

std::vector<uint8_t> ElfBuilder::generate_minimal_code(const IRProgram& program) {
	// Deprecated - now using RISCVCodeGen
	return {};
}

} // namespace gdscript

```

`src/gdscript/compiler/elf_builder.h`:

```h
#pragma once
#include "ir.h"
#include <vector>
#include <cstdint>
#include <string>

namespace gdscript {

// ELF file format structures for RV64
class ElfBuilder {
public:
	ElfBuilder();

	// Build a complete ELF file from IR program
	std::vector<uint8_t> build(const IRProgram& program);

private:
	// ELF header structures
	struct Elf64_Ehdr {
		uint8_t e_ident[16];    // ELF identification
		uint16_t e_type;        // Object file type
		uint16_t e_machine;     // Machine type
		uint32_t e_version;     // Object file version
		uint64_t e_entry;       // Entry point address
		uint64_t e_phoff;       // Program header offset
		uint64_t e_shoff;       // Section header offset
		uint32_t e_flags;       // Processor-specific flags
		uint16_t e_ehsize;      // ELF header size
		uint16_t e_phentsize;   // Size of program header entry
		uint16_t e_phnum;       // Number of program header entries
		uint16_t e_shentsize;   // Size of section header entry
		uint16_t e_shnum;       // Number of section header entries
		uint16_t e_shstrndx;    // Section name string table index
	};

	struct Elf64_Phdr {
		uint32_t p_type;        // Segment type
		uint32_t p_flags;       // Segment flags
		uint64_t p_offset;      // Segment offset in file
		uint64_t p_vaddr;       // Virtual address
		uint64_t p_paddr;       // Physical address
		uint64_t p_filesz;      // Size in file
		uint64_t p_memsz;       // Size in memory
		uint64_t p_align;       // Alignment
	};

	struct Elf64_Shdr {
		uint32_t sh_name;       // Section name (string table index)
		uint32_t sh_type;       // Section type
		uint64_t sh_flags;      // Section flags
		uint64_t sh_addr;       // Address in memory
		uint64_t sh_offset;     // Offset in file
		uint64_t sh_size;       // Section size
		uint32_t sh_link;       // Link to other section
		uint32_t sh_info;       // Additional information
		uint64_t sh_addralign;  // Alignment
		uint64_t sh_entsize;    // Entry size for fixed-size entries
	};

	void write_elf_header(std::vector<uint8_t>& data, uint64_t entry_point);
	void write_program_headers(std::vector<uint8_t>& data);
	void write_section_headers(std::vector<uint8_t>& data);
	void write_code_section(std::vector<uint8_t>& data, const std::vector<uint8_t>& code);

	// Helper to write data
	template<typename T>
	void write_value(std::vector<uint8_t>& data, T value) {
		const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&value);
		data.insert(data.end(), bytes, bytes + sizeof(T));
	}

	// Generate minimal RISC-V code from IR (simplified version)
	std::vector<uint8_t> generate_minimal_code(const IRProgram& program);

	static constexpr uint16_t ET_EXEC = 2;
	static constexpr uint16_t EM_RISCV = 243;
	static constexpr uint32_t EV_CURRENT = 1;
	static constexpr uint64_t BASE_ADDR = 0x10000;
};

} // namespace gdscript

```

`src/gdscript/compiler/gdscript_to_riscv.cpp`:

```cpp
#include "compiler.h"
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <unistd.h>

using namespace gdscript;

// Helper to run a command and capture output
std::string run_command(const char* cmd) {
	FILE* pipe = popen(cmd, "r");
	if (!pipe) {
		return "Error: Failed to run command";
	}

	char buffer[4096];
	std::string result;
	try {
		while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
			result += buffer;
		}
	} catch (...) {
		pclose(pipe);
		throw;
	}
	pclose(pipe);
	return result;
}

int main(int argc, char** argv)
{
	std::string source;
	std::string output_function; // Function to disassemble
	std::string temp_elf = "/tmp/gdscript_temp_XXXXXX";
	bool no_optimize = false;
	bool show_program_headers = false;

	// Parse arguments
	for (int i = 1; i < argc; i++) {
		std::string arg = argv[i];
		if (arg == "--no-opt" || arg == "--no-optimize") {
			no_optimize = true;
		} else if (arg == "-f" || arg == "--function") {
			if (i + 1 < argc) {
				output_function = argv[++i];
			}
		} else if (arg == "-l" || arg == "--program-headers") {
			show_program_headers = true;
		} else if (source.empty()) {
			source = arg;
		}
	}

	if (source.empty()) {
		// Read from stdin
		std::string line;
		while (std::getline(std::cin, line)) {
			source += line + "\n";
		}
	}

	try {
		// Create temporary file for ELF
		mkstemp(temp_elf.data());

		// Parse and compile to ELF
		Compiler compiler;
		CompilerOptions options;
		options.output_elf = true;
		std::vector<uint8_t> elf = compiler.compile(source, options);

		// Write ELF to temp file
		{
			std::ofstream out(temp_elf, std::ios::binary);
			out.write(reinterpret_cast<const char*>(elf.data()), elf.size());
		}

		// If user requested program headers, show them and exit
		if (show_program_headers) {
			std::ostringstream cmd;
			cmd << "readelf -l " << temp_elf << " 2>&1";
			std::string output = run_command(cmd.str().c_str());
			std::cout << output;
			unlink(temp_elf.c_str());
			return 0;
		}

		// Run objdump to disassemble
		std::ostringstream cmd;
		cmd << "riscv64-linux-gnu-objdump -d " << temp_elf << " 2>&1";
		std::string disasm = run_command(cmd.str().c_str());

		// Find and print the relevant function
		std::istringstream stream(disasm);
		std::string line;
		bool function_found = output_function.empty(); // If no function specified, print all
		bool in_function = function_found;

		while (std::getline(stream, line)) {
			// Check for function start
			if (line.find("<" + output_function + ">") != std::string::npos ||
			    line.find("<" + output_function + ">") != std::string::npos) {
				in_function = true;
				function_found = true;
				std::cout << line << std::endl;
				continue;
			}

			// Print lines while in the function
			if (in_function) {
				// Stop at next function
				if (!output_function.empty() && !line.empty() && line[0] != ' ' && line.find("Disassembly") == std::string::npos) {
					in_function = false;
					break;
				}
				std::cout << line << std::endl;
			}
		}

		if (!function_found) {
			std::cerr << "Warning: Function '" << output_function << "' not found in disassembly." << std::endl;
			std::cerr << "Available functions:" << std::endl;

			// Extract all function names
			stream = std::istringstream(disasm);
			while (std::getline(stream, line)) {
				if (line.find("<") != std::string::npos && line.find(">:") != std::string::npos) {
					size_t start = line.find("<");
					size_t end = line.find(">:");
					if (start != std::string::npos && end != std::string::npos) {
						std::cerr << "  " << line.substr(start + 1, end - start - 1) << std::endl;
					}
				}
			}
		}

		// Cleanup temp file
		unlink(temp_elf.c_str());

		return function_found ? 0 : 1;
	} catch (const std::exception& e) {
		std::cerr << "Error: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/ir.cpp`:

```cpp
#include "ir.h"
#include <sstream>

namespace gdscript {

const char* ir_opcode_name(IROpcode op) {
	switch (op) {
		case IROpcode::LOAD_IMM: return "LOAD_IMM";
		case IROpcode::LOAD_FLOAT_IMM: return "LOAD_FLOAT_IMM";
		case IROpcode::LOAD_BOOL: return "LOAD_BOOL";
		case IROpcode::LOAD_STRING: return "LOAD_STRING";
		case IROpcode::LOAD_GLOBAL: return "LOAD_GLOBAL";
		case IROpcode::STORE_GLOBAL: return "STORE_GLOBAL";
		case IROpcode::MOVE: return "MOVE";
		case IROpcode::ADD: return "ADD";
		case IROpcode::SUB: return "SUB";
		case IROpcode::MUL: return "MUL";
		case IROpcode::DIV: return "DIV";
		case IROpcode::MOD: return "MOD";
		case IROpcode::NEG: return "NEG";
		case IROpcode::CMP_EQ: return "CMP_EQ";
		case IROpcode::CMP_NEQ: return "CMP_NEQ";
		case IROpcode::CMP_LT: return "CMP_LT";
		case IROpcode::CMP_LTE: return "CMP_LTE";
		case IROpcode::CMP_GT: return "CMP_GT";
		case IROpcode::CMP_GTE: return "CMP_GTE";
		case IROpcode::AND: return "AND";
		case IROpcode::OR: return "OR";
		case IROpcode::NOT: return "NOT";
		case IROpcode::LABEL: return "LABEL";
		case IROpcode::JUMP: return "JUMP";
		case IROpcode::BRANCH_ZERO: return "BRANCH_ZERO";
		case IROpcode::BRANCH_NOT_ZERO: return "BRANCH_NOT_ZERO";
		case IROpcode::BRANCH_EQ: return "BRANCH_EQ";
		case IROpcode::BRANCH_NEQ: return "BRANCH_NEQ";
		case IROpcode::BRANCH_LT: return "BRANCH_LT";
		case IROpcode::BRANCH_LTE: return "BRANCH_LTE";
		case IROpcode::BRANCH_GT: return "BRANCH_GT";
		case IROpcode::BRANCH_GTE: return "BRANCH_GTE";
		case IROpcode::CALL: return "CALL";
		case IROpcode::CALL_SYSCALL: return "CALL_SYSCALL";
		case IROpcode::RETURN: return "RETURN";
		case IROpcode::VCALL: return "VCALL";
		case IROpcode::VGET: return "VGET";
		case IROpcode::VSET: return "VSET";
		case IROpcode::MAKE_VECTOR2: return "MAKE_VECTOR2";
		case IROpcode::MAKE_VECTOR3: return "MAKE_VECTOR3";
		case IROpcode::MAKE_VECTOR4: return "MAKE_VECTOR4";
		case IROpcode::MAKE_VECTOR2I: return "MAKE_VECTOR2I";
		case IROpcode::MAKE_VECTOR3I: return "MAKE_VECTOR3I";
		case IROpcode::MAKE_VECTOR4I: return "MAKE_VECTOR4I";
		case IROpcode::MAKE_COLOR: return "MAKE_COLOR";
		case IROpcode::MAKE_RECT2: return "MAKE_RECT2";
		case IROpcode::MAKE_RECT2I: return "MAKE_RECT2I";
		case IROpcode::MAKE_PLANE: return "MAKE_PLANE";
		case IROpcode::MAKE_ARRAY: return "MAKE_ARRAY";
		case IROpcode::MAKE_DICTIONARY: return "MAKE_DICTIONARY";
		case IROpcode::MAKE_PACKED_BYTE_ARRAY: return "MAKE_PACKED_BYTE_ARRAY";
		case IROpcode::MAKE_PACKED_INT32_ARRAY: return "MAKE_PACKED_INT32_ARRAY";
		case IROpcode::MAKE_PACKED_INT64_ARRAY: return "MAKE_PACKED_INT64_ARRAY";
		case IROpcode::MAKE_PACKED_FLOAT32_ARRAY: return "MAKE_PACKED_FLOAT32_ARRAY";
		case IROpcode::MAKE_PACKED_FLOAT64_ARRAY: return "MAKE_PACKED_FLOAT64_ARRAY";
		case IROpcode::MAKE_PACKED_STRING_ARRAY: return "MAKE_PACKED_STRING_ARRAY";
		case IROpcode::MAKE_PACKED_VECTOR2_ARRAY: return "MAKE_PACKED_VECTOR2_ARRAY";
		case IROpcode::MAKE_PACKED_VECTOR3_ARRAY: return "MAKE_PACKED_VECTOR3_ARRAY";
		case IROpcode::MAKE_PACKED_COLOR_ARRAY: return "MAKE_PACKED_COLOR_ARRAY";
		case IROpcode::MAKE_PACKED_VECTOR4_ARRAY: return "MAKE_PACKED_VECTOR4_ARRAY";
		case IROpcode::VGET_INLINE: return "VGET_INLINE";
		case IROpcode::VSET_INLINE: return "VSET_INLINE";
		default: return "UNKNOWN";
	}
}

std::string IRValue::to_string() const {
	std::ostringstream oss;
	switch (type) {
		case Type::REGISTER:
			oss << "r" << std::get<int>(value);
			break;
		case Type::IMMEDIATE:
			oss << std::get<int64_t>(value);
			break;
		case Type::FLOAT:
			oss << std::get<double>(value);
			break;
		case Type::LABEL:
			oss << "@" << std::get<std::string>(value);
			break;
		case Type::VARIABLE:
			oss << "$" << std::get<std::string>(value);
			break;
		case Type::STRING:
			oss << "\"" << std::get<std::string>(value) << "\"";
			break;
	}
	return oss.str();
}

std::string IRInstruction::to_string() const {
	std::ostringstream oss;
	oss << ir_opcode_name(opcode);

	for (const auto& op : operands) {
		oss << " " << op.to_string();
	}

	return oss.str();
}

} // namespace gdscript

```

`src/gdscript/compiler/ir.h`:

```h
#pragma once
#include <vector>
#include <string>
#include <cstdint>
#include <variant>
#include <memory>
#include "variant_types.h"

namespace gdscript {

// Intermediate Representation for RISC-V code generation
// This represents a simplified, linear instruction stream that can be easily converted to RISC-V

enum class IROpcode {
	// Stack and register operations
	LOAD_IMM,        // Load immediate integer value into register
	LOAD_FLOAT_IMM,  // Load immediate float value into register
	LOAD_BOOL,       // Load immediate boolean value into register
	LOAD_STRING,     // Load immediate string value into register
	LOAD_GLOBAL,     // Load global variable into register
	STORE_GLOBAL,    // Store register into global variable
	MOVE,            // Move between registers

	// Arithmetic
	ADD,             // Add two registers
	SUB,             // Subtract
	MUL,             // Multiply
	DIV,             // Divide
	MOD,             // Modulo
	NEG,             // Negate

	// Comparison (sets register to 0 or 1)
	CMP_EQ,          // ==
	CMP_NEQ,         // !=
	CMP_LT,          // <
	CMP_LTE,         // <=
	CMP_GT,          // >
	CMP_GTE,         // >=

	// Logical
	AND,             // Logical AND
	OR,              // Logical OR
	NOT,             // Logical NOT

	// Control flow
	LABEL,           // Target for branches
	JUMP,            // Unconditional jump
	BRANCH_ZERO,     // Branch if register == 0
	BRANCH_NOT_ZERO, // Branch if register != 0
	BRANCH_EQ,       // Branch if reg1 == reg2 (fused comparison + branch)
	BRANCH_NEQ,      // Branch if reg1 != reg2 (fused comparison + branch)
	BRANCH_LT,       // Branch if reg1 < reg2 (fused comparison + branch)
	BRANCH_LTE,      // Branch if reg1 <= reg2 (fused comparison + branch)
	BRANCH_GT,       // Branch if reg1 > reg2 (fused comparison + branch)
	BRANCH_GTE,      // Branch if reg1 >= reg2 (fused comparison + branch)

	// Function calls
	CALL,            // Call local function
	CALL_SYSCALL,    // Call syscall (for Godot API)
	RETURN,          // Return from function

	// Variant operations (through syscalls)
	VCALL,           // Variant method call
	VGET,            // Get property from variant
	VSET,            // Set property on variant

	// Inline primitive construction (no syscalls)
	MAKE_VECTOR2,    // Construct Vector2 inline
	MAKE_VECTOR3,    // Construct Vector3 inline
	MAKE_VECTOR4,    // Construct Vector4 inline
	MAKE_VECTOR2I,   // Construct Vector2i inline
	MAKE_VECTOR3I,   // Construct Vector3i inline
	MAKE_VECTOR4I,   // Construct Vector4i inline
	MAKE_COLOR,      // Construct Color inline
	MAKE_RECT2,      // Construct Rect2 inline
	MAKE_RECT2I,     // Construct Rect2i inline
	MAKE_PLANE,      // Construct Plane inline

	// Array and Dictionary construction (via VCREATE syscall)
	MAKE_ARRAY,      // Construct Array (empty or with elements)
	MAKE_DICTIONARY, // Construct Dictionary (empty or with key-value pairs)

	// Packed array construction (via VCREATE syscall)
	MAKE_PACKED_BYTE_ARRAY,      // Construct PackedByteArray (empty or with elements)
	MAKE_PACKED_INT32_ARRAY,     // Construct PackedInt32Array (empty or with elements)
	MAKE_PACKED_INT64_ARRAY,     // Construct PackedInt64Array (empty or with elements)
	MAKE_PACKED_FLOAT32_ARRAY,   // Construct PackedFloat32Array (empty or with elements)
	MAKE_PACKED_FLOAT64_ARRAY,   // Construct PackedFloat64Array (empty or with elements)
	MAKE_PACKED_STRING_ARRAY,    // Construct PackedStringArray (empty or with elements)
	MAKE_PACKED_VECTOR2_ARRAY,   // Construct PackedVector2Array (empty or with elements)
	MAKE_PACKED_VECTOR3_ARRAY,   // Construct PackedVector3Array (empty or with elements)
	MAKE_PACKED_COLOR_ARRAY,     // Construct PackedColorArray (empty or with elements)
	MAKE_PACKED_VECTOR4_ARRAY,   // Construct PackedVector4Array (empty or with elements)

	// Inline member access (no syscalls)
	VGET_INLINE,     // Get inlined member from Variant (x, y, z, w, r, g, b, a)
	VSET_INLINE,     // Set inlined member on Variant
};

struct IRValue {
	enum class Type {
		REGISTER,    // Virtual register (will be mapped to RISC-V registers)
		IMMEDIATE,   // Immediate integer value
		FLOAT,       // Immediate float value (64-bit double)
		LABEL,       // Branch target label
		VARIABLE,    // Local variable name
		STRING       // String constant
	};

	Type type = Type::IMMEDIATE;
	std::variant<int, int64_t, double, std::string> value;

	static IRValue reg(int r) {
		IRValue v {};
		v.type = Type::REGISTER;
		v.value = r;
		return v;
	}

	static IRValue imm(int64_t i) {
		IRValue v {};
		v.type = Type::IMMEDIATE;
		v.value = i;
		return v;
	}

	static IRValue fimm(double d) {
		IRValue v {};
		v.type = Type::FLOAT;
		v.value = d;
		return v;
	}

	static IRValue label(const std::string& l) {
		IRValue v {};
		v.type = Type::LABEL;
		v.value = l;
		return v;
	}

	static IRValue var(const std::string& name) {
		IRValue v {};
		v.type = Type::VARIABLE;
		v.value = name;
		return v;
	}

	static IRValue str(const std::string& s) {
		IRValue v {};
		v.type = Type::STRING;
		v.value = s;
		return v;
	}

	std::string to_string() const;
};

struct IRInstruction {
	// Type hint is simply Variant::Type, with -1 (or a special value) for NONE
	// We use int32_t to match the Variant::Type enum
	static constexpr int32_t TypeHint_NONE = -1;
	using TypeHint = int32_t;

	IROpcode opcode {};
	std::vector<IRValue> operands;
	TypeHint type_hint = TypeHint_NONE; // Type hint for result (operand 0)

	IRInstruction(IROpcode op) : opcode(op) {}
	IRInstruction(IROpcode op, IRValue a) : opcode(op), operands{a} {}
	IRInstruction(IROpcode op, IRValue a, IRValue b) : opcode(op), operands{a, b} {}
	IRInstruction(IROpcode op, IRValue a, IRValue b, IRValue c) : opcode(op), operands{a, b, c} {}

	std::string to_string() const;
};

struct IRFunction {
	std::string name;
	std::vector<std::string> parameters;
	std::vector<IRInstruction> instructions;
	int max_registers = 0; // Number of virtual registers used
};

// Global variable declaration in IR
struct IRGlobalVar {
	std::string name;
	bool is_const = false;
	bool is_property = false; // Whether this is an exported property (@export)
	IRInstruction::TypeHint type_hint = IRInstruction::TypeHint_NONE;

	// Initialization value (if any)
	enum class InitType {
		NONE,           // No initialization (will be NIL)
		INT,            // Integer literal
		FLOAT,          // Float literal
		STRING,         // String literal
		BOOL,           // Bool literal
		NULL_VAL,       // Explicit null
		EMPTY_ARRAY,    // Empty array []
		EMPTY_DICT      // Empty dictionary {}
	};
	InitType init_type = InitType::NONE;
	std::variant<int64_t, double, std::string, bool> init_value;
};

struct IRProgram {
	std::vector<IRGlobalVar> globals;
	std::vector<IRFunction> functions;
	std::vector<std::string> string_constants;
};

const char* ir_opcode_name(IROpcode op);

// TypeHint helper functions - now using Variant::Type directly
namespace TypeHintUtils {
	// Check if TypeHint is a Variant type (not NONE)
	inline bool is_variant(IRInstruction::TypeHint hint) {
		return hint != IRInstruction::TypeHint_NONE;
	}

	// Check if TypeHint is a vector type
	inline bool is_vector(IRInstruction::TypeHint hint) {
		return hint == Variant::VECTOR2 ||
		       hint == Variant::VECTOR3 ||
		       hint == Variant::VECTOR4 ||
		       hint == Variant::VECTOR2I ||
		       hint == Variant::VECTOR3I ||
		       hint == Variant::VECTOR4I;
	}

	// Check if TypeHint is an integer vector type
	inline bool is_int_vector(IRInstruction::TypeHint hint) {
		return hint == Variant::VECTOR2I ||
		       hint == Variant::VECTOR3I ||
		       hint == Variant::VECTOR4I;
	}

	// Check if TypeHint is a float vector type
	inline bool is_float_vector(IRInstruction::TypeHint hint) {
		return hint == Variant::VECTOR2 ||
		       hint == Variant::VECTOR3 ||
		       hint == Variant::VECTOR4;
	}
} // namespace TypeHintUtils

} // namespace gdscript

```

`src/gdscript/compiler/ir_interpreter.cpp`:

```cpp
#include "ir_interpreter.h"
#include "compiler_exception.h"
#include <cmath>
#include <sstream>

namespace gdscript {

IRInterpreter::IRInterpreter(const IRProgram& program) : m_program(program) {
	// Build function map
	for (const auto& func : program.functions) {
		m_function_map[func.name] = &func;
	}
}

IRInterpreter::Value IRInterpreter::call(const std::string& function_name, const std::vector<Value>& args) {
	auto it = m_function_map.find(function_name);
	if (it == m_function_map.end()) {
		m_error = "Function not found: " + function_name;
		return int64_t(0);
	}

	const IRFunction* func = it->second;
	ExecutionContext ctx;

	// Set up parameters in registers (first N registers)
	for (size_t i = 0; i < args.size() && i < func->parameters.size(); i++) {
		ctx.registers[static_cast<int>(i)] = args[i];
	}

	// Build label map
	for (size_t i = 0; i < func->instructions.size(); i++) {
		const auto& instr = func->instructions[i];
		if (instr.opcode == IROpcode::LABEL && !instr.operands.empty()) {
			if (instr.operands[0].type == IRValue::Type::LABEL) {
				ctx.labels[std::get<std::string>(instr.operands[0].value)] = i;
			}
		}
	}

	// Execute
	execute_function(*func, ctx);

	if (ctx.returned) {
		return ctx.return_value;
	}

	return int64_t(0);
}

void IRInterpreter::execute_function(const IRFunction& func, ExecutionContext& ctx) {
	ctx.pc = 0;

	while (ctx.pc < func.instructions.size() && !ctx.returned) {
		execute_instruction(func.instructions[ctx.pc], ctx);
		if (!ctx.returned) {
			ctx.pc++;
		}
	}
}

IRInterpreter::Value IRInterpreter::get_register(ExecutionContext& ctx, int reg) {
	if (ctx.registers.find(reg) == ctx.registers.end()) {
		ctx.registers[reg] = int64_t(0);
	}
	return ctx.registers[reg];
}

void IRInterpreter::execute_instruction(const IRInstruction& instr, ExecutionContext& ctx) {
	switch (instr.opcode) {
		case IROpcode::LOAD_IMM: {
			int reg = std::get<int>(instr.operands[0].value);
			int64_t imm = std::get<int64_t>(instr.operands[1].value);
			ctx.registers[reg] = imm;
			break;
		}

		case IROpcode::MOVE: {
			int dst = std::get<int>(instr.operands[0].value);
			int src = std::get<int>(instr.operands[1].value);
			// Get src value first to avoid map iterator invalidation
			Value src_value = get_register(ctx, src);
			ctx.registers[dst] = src_value;
			break;
		}

		case IROpcode::ADD:
		case IROpcode::SUB:
		case IROpcode::MUL:
		case IROpcode::DIV:
		case IROpcode::MOD: {
			int dst = std::get<int>(instr.operands[0].value);
			int src1 = std::get<int>(instr.operands[1].value);
			int src2 = std::get<int>(instr.operands[2].value);
			// Get operands first to avoid map iterator invalidation
			Value val1 = get_register(ctx, src1);
			Value val2 = get_register(ctx, src2);
			ctx.registers[dst] = binary_op(val1, val2, instr.opcode);
			break;
		}

		case IROpcode::NEG: {
			int dst = std::get<int>(instr.operands[0].value);
			int src = std::get<int>(instr.operands[1].value);
			ctx.registers[dst] = unary_op(get_register(ctx, src), IROpcode::NEG);
			break;
		}

		case IROpcode::NOT: {
			int dst = std::get<int>(instr.operands[0].value);
			int src = std::get<int>(instr.operands[1].value);
			ctx.registers[dst] = unary_op(get_register(ctx, src), IROpcode::NOT);
			break;
		}

		case IROpcode::CMP_EQ:
		case IROpcode::CMP_NEQ:
		case IROpcode::CMP_LT:
		case IROpcode::CMP_LTE:
		case IROpcode::CMP_GT:
		case IROpcode::CMP_GTE: {
			int dst = std::get<int>(instr.operands[0].value);
			int src1 = std::get<int>(instr.operands[1].value);
			int src2 = std::get<int>(instr.operands[2].value);
			ctx.registers[dst] = compare_op(get_register(ctx, src1), get_register(ctx, src2), instr.opcode);
			break;
		}

		case IROpcode::AND: {
			int dst = std::get<int>(instr.operands[0].value);
			int src1 = std::get<int>(instr.operands[1].value);
			int src2 = std::get<int>(instr.operands[2].value);
			bool result = get_bool(get_register(ctx, src1)) && get_bool(get_register(ctx, src2));
			ctx.registers[dst] = result ? int64_t(1) : int64_t(0);
			break;
		}

		case IROpcode::OR: {
			int dst = std::get<int>(instr.operands[0].value);
			int src1 = std::get<int>(instr.operands[1].value);
			int src2 = std::get<int>(instr.operands[2].value);
			bool result = get_bool(get_register(ctx, src1)) || get_bool(get_register(ctx, src2));
			ctx.registers[dst] = result ? int64_t(1) : int64_t(0);
			break;
		}

		case IROpcode::LABEL:
			// No-op, handled during label resolution
			break;

		case IROpcode::JUMP: {
			std::string label = std::get<std::string>(instr.operands[0].value);
			auto it = ctx.labels.find(label);
			if (it != ctx.labels.end()) {
				ctx.pc = it->second;
			} else {
				throw CompilerException(ErrorType::OPTIMIZER_ERROR, "Label not found: " + label);
			}
			break;
		}

		case IROpcode::BRANCH_ZERO: {
			int reg = std::get<int>(instr.operands[0].value);
			std::string label = std::get<std::string>(instr.operands[1].value);

			if (!get_bool(get_register(ctx, reg))) {
				auto it = ctx.labels.find(label);
				if (it != ctx.labels.end()) {
					ctx.pc = it->second;
				}
			}
			break;
		}

		case IROpcode::BRANCH_NOT_ZERO: {
			int reg = std::get<int>(instr.operands[0].value);
			std::string label = std::get<std::string>(instr.operands[1].value);

			if (get_bool(get_register(ctx, reg))) {
				auto it = ctx.labels.find(label);
				if (it != ctx.labels.end()) {
					ctx.pc = it->second;
				}
			}
			break;
		}

		case IROpcode::CALL: {
			// CALL format: function_name, result_reg, arg_count, arg1_reg, arg2_reg, ...
			std::string func_name = std::get<std::string>(instr.operands[0].value);
			int result_reg = std::get<int>(instr.operands[1].value);
			int arg_count = static_cast<int>(std::get<int64_t>(instr.operands[2].value));

			// Collect arguments from registers
			std::vector<Value> args;
			for (int i = 0; i < arg_count; i++) {
				int arg_reg = std::get<int>(instr.operands[3 + i].value);
				args.push_back(get_register(ctx, arg_reg));
			}

			Value result = call(func_name, args);
			ctx.registers[result_reg] = result;
			break;
		}

		case IROpcode::RETURN:
			ctx.returned = true;
			// Return value is in register 0 by convention
			if (ctx.registers.find(0) != ctx.registers.end()) {
				ctx.return_value = ctx.registers[0];
			} else {
				ctx.return_value = int64_t(0);
			}
			break;

		default:
			throw CompilerException(ErrorType::OPTIMIZER_ERROR, "Unimplemented opcode in interpreter");
	}
}

int64_t IRInterpreter::get_int(const Value& v) const {
	if (std::holds_alternative<int64_t>(v)) {
		return std::get<int64_t>(v);
	} else if (std::holds_alternative<double>(v)) {
		return static_cast<int64_t>(std::get<double>(v));
	} else if (std::holds_alternative<bool>(v)) {
		return std::get<bool>(v) ? 1 : 0;
	}
	return 0;
}

double IRInterpreter::get_double(const Value& v) const {
	if (std::holds_alternative<double>(v)) {
		return std::get<double>(v);
	} else if (std::holds_alternative<int64_t>(v)) {
		return static_cast<double>(std::get<int64_t>(v));
	}
	return 0.0;
}

bool IRInterpreter::get_bool(const Value& v) const {
	if (std::holds_alternative<bool>(v)) {
		return std::get<bool>(v);
	} else if (std::holds_alternative<int64_t>(v)) {
		return std::get<int64_t>(v) != 0;
	} else if (std::holds_alternative<double>(v)) {
		return std::get<double>(v) != 0.0;
	}
	return false;
}

std::string IRInterpreter::get_string(const Value& v) const {
	if (std::holds_alternative<std::string>(v)) {
		return std::get<std::string>(v);
	}
	return "";
}

IRInterpreter::Value IRInterpreter::binary_op(const Value& left, const Value& right, IROpcode op) {
	// Try integer arithmetic first
	int64_t l = get_int(left);
	int64_t r = get_int(right);

	switch (op) {
		case IROpcode::ADD: return l + r;
		case IROpcode::SUB: return l - r;
		case IROpcode::MUL: return l * r;
		case IROpcode::DIV: return r != 0 ? l / r : int64_t(0);
		case IROpcode::MOD: return r != 0 ? l % r : int64_t(0);
		default: return int64_t(0);
	}
}

IRInterpreter::Value IRInterpreter::unary_op(const Value& operand, IROpcode op) {
	switch (op) {
		case IROpcode::NEG:
			return -get_int(operand);
		case IROpcode::NOT:
			return !get_bool(operand) ? int64_t(1) : int64_t(0);
		default:
			return int64_t(0);
	}
}

IRInterpreter::Value IRInterpreter::compare_op(const Value& left, const Value& right, IROpcode op) {
	int64_t l = get_int(left);
	int64_t r = get_int(right);

	bool result = false;
	switch (op) {
		case IROpcode::CMP_EQ: result = (l == r); break;
		case IROpcode::CMP_NEQ: result = (l != r); break;
		case IROpcode::CMP_LT: result = (l < r); break;
		case IROpcode::CMP_LTE: result = (l <= r); break;
		case IROpcode::CMP_GT: result = (l > r); break;
		case IROpcode::CMP_GTE: result = (l >= r); break;
		default: break;
	}

	return result ? int64_t(1) : int64_t(0);
}

} // namespace gdscript

```

`src/gdscript/compiler/ir_interpreter.h`:

```h
#pragma once
#include "ir.h"
#include <unordered_map>
#include <vector>
#include <variant>
#include <stdexcept>

namespace gdscript {

// Simple IR interpreter for testing without needing full RISC-V execution
class IRInterpreter {
public:
	using Value = std::variant<int64_t, double, std::string, bool>;

	IRInterpreter(const IRProgram& program);

	// Execute a function and return result
	Value call(const std::string& function_name, const std::vector<Value>& args = {});

	// Get last error
	std::string get_error() const { return m_error; }

private:
	struct ExecutionContext {
		std::unordered_map<int, Value> registers; // Virtual register -> value
		std::unordered_map<std::string, size_t> labels; // Label -> instruction index
		size_t pc = 0; // Program counter
		bool returned = false;
		Value return_value;
	};

	void execute_function(const IRFunction& func, ExecutionContext& ctx);
	void execute_instruction(const IRInstruction& instr, ExecutionContext& ctx);
	Value get_register(ExecutionContext& ctx, int reg);

	// Helper functions
	int64_t get_int(const Value& v) const;
	double get_double(const Value& v) const;
	bool get_bool(const Value& v) const;
	std::string get_string(const Value& v) const;

	Value binary_op(const Value& left, const Value& right, IROpcode op);
	Value unary_op(const Value& operand, IROpcode op);
	Value compare_op(const Value& left, const Value& right, IROpcode op);

	const IRProgram& m_program;
	std::unordered_map<std::string, const IRFunction*> m_function_map;
	std::string m_error;
};

} // namespace gdscript

```

`src/gdscript/compiler/ir_optimizer.cpp`:

```cpp
#include "ir_optimizer.h"
#include "compiler_exception.h"
#include <algorithm>
#include <cmath>
#include <iostream>

namespace gdscript {

IROptimizer::IROptimizer() {}

void IROptimizer::optimize(IRProgram& program) {
	for (auto& func : program.functions) {
		optimize_function(func);
	}
}

void IROptimizer::optimize_function(IRFunction& func) {
	// Multiple optimization passes
	// Run constant folding first as it can enable more optimizations
	constant_folding(func);

	// Copy propagation to eliminate redundant MOVEs after constant loads
	copy_propagation(func);

	// Enhanced copy propagation - eliminates more MOVE patterns
	enhanced_copy_propagation(func);

	// Loop-invariant code motion - hoist invariant code out of loops
	// Skips functions with nested loops to avoid complexity
	loop_invariant_code_motion(func);

	// Peephole optimization to remove redundant moves and operations
	peephole_optimization(func);

	// Run peephole again to catch patterns that emerged after previous optimizations
	peephole_optimization(func);

	// Eliminate redundant store operations (run before dead code elimination)
	eliminate_redundant_stores(func);

	// Run peephole once more after eliminate_redundant_stores to clean up remaining patterns
	peephole_optimization(func);

	// Eliminate dead code (unused registers and instructions)
	eliminate_dead_code(func);

	// NOTE: reduce_register_pressure() is disabled for now because it breaks
	// the calling convention. Parameters are in specific registers (r0-r6)
	// and return value must be in r0. We need to be more careful about
	// which registers we renumber.
	// reduce_register_pressure(func);

	// Recalculate max_registers after optimizations
	int max_reg = 0;
	for (const auto& instr : func.instructions) {
		for (const auto& op : instr.operands) {
			if (op.type == IRValue::Type::REGISTER) {
				int reg = std::get<int>(op.value);
				max_reg = std::max(max_reg, reg);
			}
		}
	}
	func.max_registers = max_reg + 1;
}

void IROptimizer::constant_folding(IRFunction& func) {
	m_constants.clear();
	std::vector<IRInstruction> new_instructions;
	new_instructions.reserve(func.instructions.size());

	for (const auto& instr : func.instructions) {
		bool folded = false;

		// Important: invalidate all constants when we encounter control flow targets
		// because we don't know what path we took to reach this point
		if (instr.opcode == IROpcode::LABEL) {
			m_constants.clear();
			new_instructions.push_back(instr);
			continue;
		}

		switch (instr.opcode) {
			case IROpcode::LOAD_IMM: {
				int reg = std::get<int>(instr.operands[0].value);
				int64_t val = std::get<int64_t>(instr.operands[1].value);
				ConstantValue cv;
				cv.type = ConstantValue::Type::INT;
				cv.int_value = val;
				set_register_constant(reg, cv);
				new_instructions.push_back(instr);
				break;
			}

			case IROpcode::LOAD_FLOAT_IMM: {
				int reg = std::get<int>(instr.operands[0].value);
				double val = std::get<double>(instr.operands[1].value);
				ConstantValue cv;
				cv.type = ConstantValue::Type::FLOAT;
				cv.float_value = val;
				set_register_constant(reg, cv);
				new_instructions.push_back(instr);
				break;
			}

			case IROpcode::LOAD_BOOL: {
				int reg = std::get<int>(instr.operands[0].value);
				int64_t val = std::get<int64_t>(instr.operands[1].value);
				ConstantValue cv;
				cv.type = ConstantValue::Type::BOOL;
				cv.bool_value = (val != 0);
				set_register_constant(reg, cv);
				new_instructions.push_back(instr);
				break;
			}

			case IROpcode::LOAD_STRING: {
				int reg = std::get<int>(instr.operands[0].value);
				invalidate_register(reg);
				new_instructions.push_back(instr);
				break;
			}

			case IROpcode::MOVE: {
				int dst = std::get<int>(instr.operands[0].value);
				int src = std::get<int>(instr.operands[1].value);

				// Propagate constant value
				if (m_constants.count(src)) {
					m_constants[dst] = m_constants[src];
				} else {
					invalidate_register(dst);
				}
				new_instructions.push_back(instr);
				break;
			}

			case IROpcode::ADD:
			case IROpcode::SUB:
			case IROpcode::MUL:
			case IROpcode::DIV:
			case IROpcode::MOD: {
				// Check that all operands are registers before attempting constant folding
				if (instr.operands.size() < 3 ||
				    instr.operands[0].type != IRValue::Type::REGISTER ||
				    instr.operands[1].type != IRValue::Type::REGISTER ||
				    instr.operands[2].type != IRValue::Type::REGISTER) {
					// Can't fold if operands aren't all registers
					// Invalidate destination if it's a register
					if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
						int dst = std::get<int>(instr.operands[0].value);
						invalidate_register(dst);
					}
					new_instructions.push_back(instr);
					break;
				}

				int dst = std::get<int>(instr.operands[0].value);
				int lhs_reg = std::get<int>(instr.operands[1].value);
				int rhs_reg = std::get<int>(instr.operands[2].value);

				// Try to fold arithmetic operations
				if (m_constants.count(lhs_reg) && m_constants.count(rhs_reg)) {
					ConstantValue result;
					if (try_fold_binary_op(instr.opcode, instr.type_hint, m_constants[lhs_reg], m_constants[rhs_reg], result)) {
						// Replace with appropriate load instruction based on result type
						if (result.type == ConstantValue::Type::FLOAT) {
							new_instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(dst), IRValue::fimm(result.float_value));
							new_instructions.back().type_hint = Variant::FLOAT;
						} else {
							new_instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(dst), IRValue::imm(result.int_value));
							if (instr.type_hint == Variant::INT) {
								new_instructions.back().type_hint = Variant::INT;
							}
						}
						set_register_constant(dst, result);
						folded = true;
					}
				}

				if (!folded) {
					invalidate_register(dst);
					new_instructions.push_back(instr);
				}
				break;
			}

			case IROpcode::CMP_EQ:
			case IROpcode::CMP_NEQ:
			case IROpcode::CMP_LT:
			case IROpcode::CMP_LTE:
			case IROpcode::CMP_GT:
			case IROpcode::CMP_GTE: {
				// Check that all operands are registers before attempting constant folding
				if (instr.operands.size() < 3 ||
				    instr.operands[0].type != IRValue::Type::REGISTER ||
				    instr.operands[1].type != IRValue::Type::REGISTER ||
				    instr.operands[2].type != IRValue::Type::REGISTER) {
					// Can't fold if operands aren't all registers
					if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
						int dst = std::get<int>(instr.operands[0].value);
						invalidate_register(dst);
					}
					new_instructions.push_back(instr);
					break;
				}

				int dst = std::get<int>(instr.operands[0].value);
				int lhs_reg = std::get<int>(instr.operands[1].value);
				int rhs_reg = std::get<int>(instr.operands[2].value);

				// Try to fold comparisons
				if (m_constants.count(lhs_reg) && m_constants.count(rhs_reg)) {
					ConstantValue result;
					if (try_fold_binary_op(instr.opcode, instr.type_hint, m_constants[lhs_reg], m_constants[rhs_reg], result)) {
						// Replace with LOAD_BOOL
						new_instructions.emplace_back(IROpcode::LOAD_BOOL, IRValue::reg(dst), IRValue::imm(result.bool_value ? 1 : 0));
						set_register_constant(dst, result);
						folded = true;
					}
				}

				if (!folded) {
					invalidate_register(dst);
					new_instructions.push_back(instr);
				}
				break;
			}

			case IROpcode::NEG: {
				int dst = std::get<int>(instr.operands[0].value);
				int src = std::get<int>(instr.operands[1].value);

				if (m_constants.count(src)) {
					const auto& cv = m_constants[src];
					ConstantValue result;

					if (cv.type == ConstantValue::Type::INT) {
						result.type = ConstantValue::Type::INT;
						result.int_value = -cv.int_value;
						new_instructions.emplace_back(IROpcode::LOAD_IMM, IRValue::reg(dst), IRValue::imm(result.int_value));
						set_register_constant(dst, result);
						folded = true;
					} else if (cv.type == ConstantValue::Type::FLOAT) {
						result.type = ConstantValue::Type::FLOAT;
						result.float_value = -cv.float_value;
						new_instructions.emplace_back(IROpcode::LOAD_FLOAT_IMM, IRValue::reg(dst), IRValue::fimm(result.float_value));
						new_instructions.back().type_hint = Variant::FLOAT;
						set_register_constant(dst, result);
						folded = true;
					}
				}

				if (!folded) {
					invalidate_register(dst);
					new_instructions.push_back(instr);
				}
				break;
			}

			case IROpcode::NOT: {
				int dst = std::get<int>(instr.operands[0].value);
				int src = std::get<int>(instr.operands[1].value);

				if (m_constants.count(src) && m_constants[src].type == ConstantValue::Type::BOOL) {
					ConstantValue result;
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = !m_constants[src].bool_value;
					new_instructions.emplace_back(IROpcode::LOAD_BOOL, IRValue::reg(dst), IRValue::imm(result.bool_value ? 1 : 0));
					set_register_constant(dst, result);
					folded = true;
				}

				if (!folded) {
					invalidate_register(dst);
					new_instructions.push_back(instr);
				}
				break;
			}

			case IROpcode::AND:
			case IROpcode::OR: {
				// Check that all operands are registers before attempting constant folding
				if (instr.operands.size() < 3 ||
				    instr.operands[0].type != IRValue::Type::REGISTER ||
				    instr.operands[1].type != IRValue::Type::REGISTER ||
				    instr.operands[2].type != IRValue::Type::REGISTER) {
					// Can't fold if operands aren't all registers
					if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
						int dst = std::get<int>(instr.operands[0].value);
						invalidate_register(dst);
					}
					new_instructions.push_back(instr);
					break;
				}

				int dst = std::get<int>(instr.operands[0].value);
				int lhs_reg = std::get<int>(instr.operands[1].value);
				int rhs_reg = std::get<int>(instr.operands[2].value);

				// Try to fold logical operations
				if (m_constants.count(lhs_reg) && m_constants.count(rhs_reg)) {
					const auto& lhs_cv = m_constants[lhs_reg];
					const auto& rhs_cv = m_constants[rhs_reg];

					// Only fold if both are boolean constants
					if (lhs_cv.type == ConstantValue::Type::BOOL && rhs_cv.type == ConstantValue::Type::BOOL) {
						ConstantValue result;
						result.type = ConstantValue::Type::BOOL;

						if (instr.opcode == IROpcode::AND) {
							result.bool_value = lhs_cv.bool_value && rhs_cv.bool_value;
						} else {
							result.bool_value = lhs_cv.bool_value || rhs_cv.bool_value;
						}

						new_instructions.emplace_back(IROpcode::LOAD_BOOL, IRValue::reg(dst), IRValue::imm(result.bool_value ? 1 : 0));
						set_register_constant(dst, result);
						folded = true;
					}
				}

				if (!folded) {
					invalidate_register(dst);
					new_instructions.push_back(instr);
				}
				break;
			}

			// System calls and variant operations - invalidate destination only
			case IROpcode::VCALL:
			case IROpcode::VGET:
			case IROpcode::VSET:
			case IROpcode::CALL_SYSCALL:
			case IROpcode::CALL:
				// These write to the first operand (destination register)
				// but we shouldn't invalidate the input operands
				if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
					invalidate_register(std::get<int>(instr.operands[0].value));
				}
				new_instructions.push_back(instr);
				break;

			default:
				// Clear constant tracking for any instruction that might modify registers
				for (const auto& op : instr.operands) {
					if (op.type == IRValue::Type::REGISTER) {
						int reg = std::get<int>(op.value);
						invalidate_register(reg);
					}
				}
				new_instructions.push_back(instr);
				break;
		}
	}

	func.instructions = std::move(new_instructions);
}

bool IROptimizer::try_fold_binary_op(IROpcode op, IRInstruction::TypeHint type_hint, const ConstantValue& lhs, const ConstantValue& rhs, ConstantValue& result) {
	// Handle float arithmetic - if type_hint is VARIANT_FLOAT or either operand is float,
	// we must perform float arithmetic (GDScript semantics)
	bool is_float_op = (type_hint == Variant::FLOAT ||
	                    lhs.type == ConstantValue::Type::FLOAT ||
	                    rhs.type == ConstantValue::Type::FLOAT);

	// For arithmetic operations, promote to float if needed
	if (is_float_op) {
		// Convert int operands to float for the operation
		double lhs_val = (lhs.type == ConstantValue::Type::FLOAT) ? lhs.float_value : static_cast<double>(lhs.int_value);
		double rhs_val = (rhs.type == ConstantValue::Type::FLOAT) ? rhs.float_value : static_cast<double>(rhs.int_value);

		switch (op) {
			case IROpcode::ADD:
				result.type = ConstantValue::Type::FLOAT;
				result.float_value = lhs_val + rhs_val;
				return true;

			case IROpcode::SUB:
				result.type = ConstantValue::Type::FLOAT;
				result.float_value = lhs_val - rhs_val;
				return true;

			case IROpcode::MUL:
				result.type = ConstantValue::Type::FLOAT;
				result.float_value = lhs_val * rhs_val;
				return true;

			case IROpcode::DIV:
				if (rhs_val == 0.0) return false; // Don't fold division by zero
				result.type = ConstantValue::Type::FLOAT;
				result.float_value = lhs_val / rhs_val;
				return true;

			case IROpcode::MOD:
				if (rhs_val == 0.0) return false; // Don't fold modulo by zero
				result.type = ConstantValue::Type::FLOAT;
				result.float_value = std::fmod(lhs_val, rhs_val);
				return true;

			default:
				break; // Fall through to comparison handling
		}
	}

	// Handle integer arithmetic (only when both operands are int and not a float operation)
	if (!is_float_op && lhs.type == ConstantValue::Type::INT && rhs.type == ConstantValue::Type::INT) {
		switch (op) {
			case IROpcode::ADD:
				result.type = ConstantValue::Type::INT;
				result.int_value = lhs.int_value + rhs.int_value;
				return true;

			case IROpcode::SUB:
				result.type = ConstantValue::Type::INT;
				result.int_value = lhs.int_value - rhs.int_value;
				return true;

			case IROpcode::MUL:
				result.type = ConstantValue::Type::INT;
				result.int_value = lhs.int_value * rhs.int_value;
				return true;

			case IROpcode::DIV:
				if (rhs.int_value == 0) return false; // Don't fold division by zero
				result.type = ConstantValue::Type::INT;
				result.int_value = lhs.int_value / rhs.int_value;
				return true;

			case IROpcode::MOD:
				if (rhs.int_value == 0) return false; // Don't fold modulo by zero
				result.type = ConstantValue::Type::INT;
				result.int_value = lhs.int_value % rhs.int_value;
				return true;

			default:
				break; // Fall through to comparison handling
		}
	}

	// Handle comparisons - work for both int and float
	bool comparable = (lhs.type == ConstantValue::Type::INT && rhs.type == ConstantValue::Type::INT) ||
	                  (lhs.type == ConstantValue::Type::FLOAT && rhs.type == ConstantValue::Type::FLOAT) ||
	                  (lhs.type == ConstantValue::Type::INT && rhs.type == ConstantValue::Type::FLOAT) ||
	                  (lhs.type == ConstantValue::Type::FLOAT && rhs.type == ConstantValue::Type::INT);

	if (comparable) {
		// Get comparable values
		bool lhs_is_float = (lhs.type == ConstantValue::Type::FLOAT);
		bool rhs_is_float = (rhs.type == ConstantValue::Type::FLOAT);

		if (lhs_is_float || rhs_is_float) {
			// Float comparison
			double lhs_val = lhs_is_float ? lhs.float_value : static_cast<double>(lhs.int_value);
			double rhs_val = rhs_is_float ? rhs.float_value : static_cast<double>(rhs.int_value);

			switch (op) {
				case IROpcode::CMP_EQ:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs_val == rhs_val);
					return true;

				case IROpcode::CMP_NEQ:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs_val != rhs_val);
					return true;

				case IROpcode::CMP_LT:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs_val < rhs_val);
					return true;

				case IROpcode::CMP_LTE:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs_val <= rhs_val);
					return true;

				case IROpcode::CMP_GT:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs_val > rhs_val);
					return true;

				case IROpcode::CMP_GTE:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs_val >= rhs_val);
					return true;

				default:
					return false;
			}
		} else {
			// Integer comparison
			switch (op) {
				case IROpcode::CMP_EQ:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs.int_value == rhs.int_value);
					return true;

				case IROpcode::CMP_NEQ:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs.int_value != rhs.int_value);
					return true;

				case IROpcode::CMP_LT:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs.int_value < rhs.int_value);
					return true;

				case IROpcode::CMP_LTE:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs.int_value <= rhs.int_value);
					return true;

				case IROpcode::CMP_GT:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs.int_value > rhs.int_value);
					return true;

				case IROpcode::CMP_GTE:
					result.type = ConstantValue::Type::BOOL;
					result.bool_value = (lhs.int_value >= rhs.int_value);
					return true;

				default:
					return false;
			}
		}
	}

	return false;
}

void IROptimizer::peephole_optimization(IRFunction& func) {
	std::vector<IRInstruction> new_instructions;
	new_instructions.reserve(func.instructions.size());

	size_t i = 0;
	while (i < func.instructions.size()) {
		const auto& instr = func.instructions[i];
		bool skip = false;
		bool handled = false;

		// Pattern 0: Fuse CMP + BRANCH -> BRANCH_CMP
		// Detect pattern: CMP_* dst, lhs, rhs; BRANCH_ZERO/NOT_ZERO dst, label
		// Transform to: BRANCH_CMP lhs, rhs, label (where CMP is the comparison type)
		// This eliminates the need to store and load the comparison result
		// XXX: This optimization is known to fail untyped recursive fibonacci(20)
		if (!skip && !handled && i + 1 < func.instructions.size()) {
			const auto& cmp_instr = func.instructions[i];
			const auto& branch_instr = func.instructions[i + 1];

			// Check if this is a comparison instruction
			bool is_cmp = (cmp_instr.opcode == IROpcode::CMP_EQ ||
			               cmp_instr.opcode == IROpcode::CMP_NEQ ||
			               cmp_instr.opcode == IROpcode::CMP_LT ||
			               cmp_instr.opcode == IROpcode::CMP_LTE ||
			               cmp_instr.opcode == IROpcode::CMP_GT ||
			               cmp_instr.opcode == IROpcode::CMP_GTE);

			// Check if next instruction branches on the comparison result
			bool is_branch_on_cmp = (branch_instr.opcode == IROpcode::BRANCH_ZERO ||
			                          branch_instr.opcode == IROpcode::BRANCH_NOT_ZERO);

			if (is_cmp && is_branch_on_cmp && cmp_instr.operands.size() >= 3 && branch_instr.operands.size() >= 2) {
				// Get comparison destination register
				int cmp_dst = std::get<int>(cmp_instr.operands[0].value);
				// Get branch condition register
				int branch_reg = std::get<int>(branch_instr.operands[0].value);

				// Check if branch uses the comparison result AND result is not used elsewhere
				// We check if it's used after the branch (i+2 onwards), not including the branch itself
				// Pass false for conservative_at_labels since comparison results don't persist across control flow
				bool reg_not_used_after = !is_reg_used_between_exclusive(func, cmp_dst, i + 1, func.instructions.size(), false);
				if (cmp_dst == branch_reg && reg_not_used_after) {
					// Fuse the instructions
					IROpcode fused_opcode;
					bool invert = (branch_instr.opcode == IROpcode::BRANCH_ZERO);

					// Map CMP + BRANCH_ZERO to direct branch (or invert for BRANCH_NOT_ZERO)
					if (invert) {
						// BRANCH_ZERO means branch when condition is false, so invert comparison
						switch (cmp_instr.opcode) {
							case IROpcode::CMP_EQ:  fused_opcode = IROpcode::BRANCH_NEQ; break;
							case IROpcode::CMP_NEQ: fused_opcode = IROpcode::BRANCH_EQ; break;
							case IROpcode::CMP_LT:  fused_opcode = IROpcode::BRANCH_GTE; break;
							case IROpcode::CMP_LTE: fused_opcode = IROpcode::BRANCH_GT; break;
							case IROpcode::CMP_GT:  fused_opcode = IROpcode::BRANCH_LTE; break;
							case IROpcode::CMP_GTE: fused_opcode = IROpcode::BRANCH_LT; break;
							default: throw CompilerException(ErrorType::OPTIMIZER_ERROR, "Unexpected comparison opcode in peephole optimization");
						}
					} else {
						// BRANCH_NOT_ZERO means branch when condition is true, use same comparison
						switch (cmp_instr.opcode) {
							case IROpcode::CMP_EQ:  fused_opcode = IROpcode::BRANCH_EQ; break;
							case IROpcode::CMP_NEQ: fused_opcode = IROpcode::BRANCH_NEQ; break;
							case IROpcode::CMP_LT:  fused_opcode = IROpcode::BRANCH_LT; break;
							case IROpcode::CMP_LTE: fused_opcode = IROpcode::BRANCH_LTE; break;
							case IROpcode::CMP_GT:  fused_opcode = IROpcode::BRANCH_GT; break;
							case IROpcode::CMP_GTE: fused_opcode = IROpcode::BRANCH_GTE; break;
							default: throw CompilerException(ErrorType::OPTIMIZER_ERROR, "Unexpected comparison opcode in peephole optimization");
						}
					}

					// Create fused instruction: BRANCH_CMP lhs, rhs, label
					IRInstruction fused(fused_opcode);
					fused.operands.push_back(cmp_instr.operands[1]); // lhs
					fused.operands.push_back(cmp_instr.operands[2]); // rhs
					fused.operands.push_back(branch_instr.operands[1]); // label
					fused.type_hint = cmp_instr.type_hint;

					new_instructions.push_back(fused);
					i += 2; // Skip both instructions
					skip = true;
					handled = true;
				}
			}
		}

		// Pattern 1: MOVE r0, r0 -> eliminate
		if (!skip && !handled && instr.opcode == IROpcode::MOVE) {
			int dst = std::get<int>(instr.operands[0].value);
			int src = std::get<int>(instr.operands[1].value);
			if (dst == src) {
				skip = true; // Eliminate self-move
				i++;
				continue;
			}

			// Pattern 2: Eliminate redundant MOVEs around arithmetic/logical operations
			// Pattern A: MOVE tmp1, src1; MOVE tmp2, src2; OP dst, tmp1, tmp2; MOVE result, dst
			//          -> OP result, src1, src2
			// Pattern B/C: MOVE tmp, src; OP dst, ..., tmp; MOVE result, dst
			//          -> OP result, ..., src
			//
			// Only apply if:
			// - The temporary registers (tmp1, tmp2, dst) are never used elsewhere
			// - No control flow boundaries between the instructions
			if (!skip && !handled && i + 3 < func.instructions.size()) {
				const auto& move1 = func.instructions[i];
				const auto& move2 = func.instructions[i + 1];
				const auto& op = func.instructions[i + 2];
				const auto& move3 = func.instructions[i + 3];

				// Check for Pattern A: MOVE; MOVE; OP; MOVE
				if (move2.opcode == IROpcode::MOVE &&
				    is_arithmetic_op(op.opcode) &&
				    move3.opcode == IROpcode::MOVE &&
				    op.operands.size() >= 3) {

					int move1_dst = std::get<int>(move1.operands[0].value);
					int move1_src = std::get<int>(move1.operands[1].value);
					int move2_dst = std::get<int>(move2.operands[0].value);
					int move2_src = std::get<int>(move2.operands[1].value);
					int op_dst = std::get<int>(op.operands[0].value);
					int move3_dst = std::get<int>(move3.operands[0].value);
					int move3_src = std::get<int>(move3.operands[1].value);

					// Check if operands match the pattern
					if (op.operands[1].type == IRValue::Type::REGISTER &&
					    op.operands[2].type == IRValue::Type::REGISTER) {
						int op_lhs = std::get<int>(op.operands[1].value);
						int op_rhs = std::get<int>(op.operands[2].value);

						// Pattern A: tmp1=move1_dst, tmp2=move2_dst, result=move3_dst
						if (move1_dst == op_lhs && move2_dst == op_rhs &&
						    move3_src == op_dst) {
							// Check that temps are not used elsewhere
							// tmp1 (move1_dst) should only be used by the OP at i+2
							// tmp2 (move2_dst) should only be used by the OP at i+2
							// dst (op_dst) should only be used by the MOVE at i+3
							bool tmp1_safe = !is_reg_used_between_exclusive(func, move1_dst, i, i + 2);
							bool tmp2_safe = !is_reg_used_between_exclusive(func, move2_dst, i + 1, i + 2);
							bool dst_safe = !is_reg_used_between_exclusive(func, op_dst, i + 2, i + 3);

							if (tmp1_safe && tmp2_safe && dst_safe) {
								// Emit optimized instruction
								IRInstruction new_op = op;
								new_op.operands[0] = IRValue::reg(move3_dst);
								new_op.operands[1] = IRValue::reg(move1_src);
								new_op.operands[2] = IRValue::reg(move2_src);
								new_instructions.push_back(new_op);

								i += 4;
								skip = true;
								handled = true;
							}
						}
					}
				}
			}

			// Pattern B/C: MOVE; OP; MOVE (only one move before op)
			if (!skip && !handled && i + 2 < func.instructions.size()) {
				const auto& move1 = func.instructions[i];
				const auto& op = func.instructions[i + 1];
				const auto& move2 = func.instructions[i + 2];

				if (is_arithmetic_op(op.opcode) &&
				    move2.opcode == IROpcode::MOVE &&
				    op.operands.size() >= 3) {

					int move1_dst = std::get<int>(move1.operands[0].value);
					int move1_src = std::get<int>(move1.operands[1].value);
					int op_dst = std::get<int>(op.operands[0].value);
					int move2_dst = std::get<int>(move2.operands[0].value);
					int move2_src = std::get<int>(move2.operands[1].value);

					// Check for Pattern B: tmp is first operand
					if (op.operands[1].type == IRValue::Type::REGISTER) {
						int op_lhs = std::get<int>(op.operands[1].value);

						if (move1_dst == op_lhs && move2_src == op_dst &&
						    !is_reg_used_between_exclusive(func, move1_dst, i, i + 1) &&
						    !is_reg_used_between_exclusive(func, op_dst, i + 1, i + 2)) {

							// Emit optimized instruction
							IRInstruction new_op = op;
							new_op.operands[0] = IRValue::reg(move2_dst);
							new_op.operands[1] = IRValue::reg(move1_src);
							// operand 2 stays the same
							new_instructions.push_back(new_op);

							i += 3;
							skip = true;
							handled = true;
						}
					}

					// Check for Pattern C: tmp is second operand
					if (!handled && op.operands[2].type == IRValue::Type::REGISTER) {
						int op_rhs = std::get<int>(op.operands[2].value);

						if (move1_dst == op_rhs && move2_src == op_dst &&
						    !is_reg_used_between_exclusive(func, move1_dst, i, i + 1) &&
						    !is_reg_used_between_exclusive(func, op_dst, i + 1, i + 2)) {

							// Emit optimized instruction
							IRInstruction new_op = op;
							new_op.operands[0] = IRValue::reg(move2_dst);
							// operand 1 stays the same
							new_op.operands[2] = IRValue::reg(move1_src);
							new_instructions.push_back(new_op);

							i += 3;
							skip = true;
							handled = true;
						}
					}
				}
			}

			// Pattern E: MOVE tmp, var; LOAD_IMM/LOAD_FLOAT_IMM const; OP dst, tmp, const; MOVE var, dst
			//          -> OP var, var, const
			// This handles the common "count = count + 1" pattern efficiently
			if (!skip && !handled && i + 3 < func.instructions.size()) {
				const auto& move1 = func.instructions[i];
				const auto& load = func.instructions[i + 1];
				const auto& op = func.instructions[i + 2];
				const auto& move2 = func.instructions[i + 3];

				if (move1.opcode == IROpcode::MOVE &&
				    (load.opcode == IROpcode::LOAD_IMM || load.opcode == IROpcode::LOAD_FLOAT_IMM) &&
				    is_arithmetic_op(op.opcode) &&
				    move2.opcode == IROpcode::MOVE &&
				    op.operands.size() >= 3) {

					int move1_dst = std::get<int>(move1.operands[0].value);
					int move1_src = std::get<int>(move1.operands[1].value);
					int load_dst = std::get<int>(load.operands[0].value);
					int op_dst = std::get<int>(op.operands[0].value);
					int move2_dst = std::get<int>(move2.operands[0].value);
					int move2_src = std::get<int>(move2.operands[1].value);

					// Check if operands match the pattern: MOVE tmp, var; LOAD const; OP dst, tmp, const; MOVE var, dst
					if (op.operands[1].type == IRValue::Type::REGISTER &&
					    op.operands[2].type == IRValue::Type::REGISTER) {
						int op_lhs = std::get<int>(op.operands[1].value);
						int op_rhs = std::get<int>(op.operands[2].value);

						// Pattern E requires: tmp=move1_dst=op_lhs, const=load_dst=op_rhs, var=move1_src=move2_dst, dst=op_dst=move2_src
						if (move1_dst == op_lhs && load_dst == op_rhs &&
						    move1_src == move2_dst && move2_src == op_dst) {
							// Check that temps are not used elsewhere (excluding the OP instruction at i+2)
							// tmp1 (move1_dst) should only be used by OP at i+2 - check before OP
							bool tmp1_safe = !is_reg_used_between_exclusive(func, move1_dst, i, i + 2);
							// const (load_dst) should only be used by OP at i+2 - check before and after (excluding OP)
							bool tmp2_safe = !is_reg_used_between_exclusive(func, load_dst, i + 1, i + 2) &&
							                 !is_reg_used_between_exclusive(func, load_dst, i + 2, i + 3);
							// dst (op_dst) should only be used by MOVE at i+3 - check between OP and MOVE
							bool dst_safe = !is_reg_used_between_exclusive(func, op_dst, i + 2, i + 3);

							if (tmp1_safe && tmp2_safe && dst_safe) {
								// Emit the LOAD_IMM instruction first (we still need the constant)
								new_instructions.push_back(load);

								// Emit optimized instruction: OP var, var, const
								IRInstruction new_op = op;
								new_op.operands[0] = IRValue::reg(move2_dst);  // var as destination
								new_op.operands[1] = IRValue::reg(move1_src);  // var as first operand
								// operand 2 (const) stays the same (load_dst)
								new_instructions.push_back(new_op);

								i += 4;
								skip = true;
								handled = true;
							}
						}
					}
				}
			}
		}

		// Pattern F: Handle MOVE r10, r0; MOVE r0, r10 -> eliminate (redundant pair)
		if (!skip && !handled && i + 1 < func.instructions.size()) {
			if (func.instructions[i].opcode == IROpcode::MOVE &&
			    func.instructions[i + 1].opcode == IROpcode::MOVE) {
				const auto& move1 = func.instructions[i];
				const auto& move2 = func.instructions[i + 1];

				int move1_dst = std::get<int>(move1.operands[0].value);
				int move1_src = std::get<int>(move1.operands[1].value);
				int move2_dst = std::get<int>(move2.operands[0].value);
				int move2_src = std::get<int>(move2.operands[1].value);

				// Check for: MOVE tmp, src; MOVE src, tmp
				// This is a redundant swap pattern - just eliminate both
				if (move1_dst == move2_src && move1_src == move2_dst && move1_dst != move1_src) {
					// Both moves are redundant - eliminate them
					i += 2;
					skip = true;
					handled = true;
					continue;
				}
			}
		}

		// Pattern D: OP dst, ...; MOVE result, dst (without preceding MOVE)
		if (!skip && !handled && i + 1 < func.instructions.size()) {
			if (is_arithmetic_op(func.instructions[i].opcode) &&
			    func.instructions[i + 1].opcode == IROpcode::MOVE) {

				const auto& op = func.instructions[i];
				const auto& move = func.instructions[i + 1];

				if (op.operands.size() >= 1 && move.operands.size() >= 2) {
					int op_dst = std::get<int>(op.operands[0].value);
					int move_dst = std::get<int>(move.operands[0].value);
					int move_src = std::get<int>(move.operands[1].value);

					if (move_src == op_dst &&
					    !is_reg_used_between_exclusive(func, op_dst, i, i + 2)) {

						// Emit optimized instruction
						IRInstruction new_op = op;
						new_op.operands[0] = IRValue::reg(move_dst);
						new_instructions.push_back(new_op);

						i += 2;
						skip = true;
						handled = true;
					}
				}
			}
		}

		if (!skip && !handled) {
			new_instructions.push_back(instr);
			i++;
		}
	}

	func.instructions = std::move(new_instructions);
}

void IROptimizer::copy_propagation(IRFunction& func) {
	// This optimization eliminates redundant MOVE instructions after constant loads.
	// Pattern: LOAD_IMM r0, 5; MOVE r1, r0; ... (r0 never used again)
	// Optimize to: LOAD_IMM r1, 5

	// Track constant values in registers
	struct ConstantInfo {
		IROpcode opcode;
		IRValue value;  // The actual constant value
	};

	std::unordered_map<int, ConstantInfo> constant_regs;
	std::vector<IRInstruction> new_instructions;
	new_instructions.reserve(func.instructions.size());

	for (size_t i = 0; i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];

		// Clear constant tracking at labels (control flow boundaries)
		if (instr.opcode == IROpcode::LABEL) {
			constant_regs.clear();
		}

		// Mark the destination register as "killed" - it's no longer a constant we can propagate
		if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
			int dst = std::get<int>(instr.operands[0].value);
			constant_regs.erase(dst);
		}

		// Track constant loads
		if (instr.opcode == IROpcode::LOAD_IMM || instr.opcode == IROpcode::LOAD_FLOAT_IMM) {
			if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER &&
			    instr.operands.size() >= 2) {
				int dst = std::get<int>(instr.operands[0].value);
				constant_regs[dst] = {instr.opcode, instr.operands[1]};
			}
		}

		// Try to optimize MOVE instructions
		if (instr.opcode == IROpcode::MOVE) {
			int dst = std::get<int>(instr.operands[0].value);
			int src = std::get<int>(instr.operands[1].value);

			// Check if source is a constant we just loaded
			if (constant_regs.count(src)) {
				// Replace MOVE with the appropriate constant load
				const auto& info = constant_regs[src];
				new_instructions.emplace_back(info.opcode, IRValue::reg(dst), info.value);
				// The new constant is now in dst
				constant_regs[dst] = info;
			} else {
				// Keep the original MOVE
				new_instructions.push_back(instr);
			}
		} else {
			new_instructions.push_back(instr);
		}
	}

	func.instructions = std::move(new_instructions);
}

void IROptimizer::eliminate_dead_code(IRFunction& func) {
	// Find all live registers (used after definition)
	auto live_regs = find_live_registers(func);

	std::vector<IRInstruction> new_instructions;
	new_instructions.reserve(func.instructions.size());

	for (size_t i = 0; i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];
		bool keep = true;

		// Check if instruction produces a dead register
		// BUT: be conservative - only eliminate truly "pure" operations
		// Do NOT eliminate operations that might have side effects or are
		// part of control flow setup
		switch (instr.opcode) {
			case IROpcode::LOAD_IMM:
			case IROpcode::LOAD_BOOL: {
				// These are pure and can be safely eliminated if unused
				int dst = std::get<int>(instr.operands[0].value);
				if (live_regs.find(dst) == live_regs.end()) {
					keep = false; // Dead code
				}
				break;
			}

			// DO NOT eliminate these even if result appears unused:
			// - MOVE: might be part of calling convention
			// - Arithmetic ops: the input registers might have side effects
			// - Comparisons: often used for control flow
			// - LOAD_STRING: might be needed for vcall
			// Better to keep them than to break the program

			default:
				// Keep all other instructions
				break;
		}

		if (keep) {
			new_instructions.push_back(instr);
		}
	}

	func.instructions = std::move(new_instructions);
}

std::unordered_set<int> IROptimizer::find_live_registers(const IRFunction& func) {
	std::unordered_set<int> live;

	// Mark all read registers as live
	for (const auto& instr : func.instructions) {
		// Handle all branch instructions
		if (is_branch_op(instr.opcode)) {
			// BRANCH_ZERO/NOT_ZERO: first operand is the register to check
			// Fused branches (EQ/NEQ/LT/etc): first TWO operands are registers to compare
			size_t num_reg_operands = (instr.opcode == IROpcode::BRANCH_ZERO ||
			                             instr.opcode == IROpcode::BRANCH_NOT_ZERO) ? 1 : 2;
			for (size_t i = 0; i < num_reg_operands && i < instr.operands.size(); i++) {
				if (instr.operands[i].type == IRValue::Type::REGISTER) {
					live.insert(std::get<int>(instr.operands[i].value));
				}
			}
			continue;
		}

		switch (instr.opcode) {

			// Instructions that read from operands (not just write)
			case IROpcode::MOVE:
			case IROpcode::ADD:
			case IROpcode::SUB:
			case IROpcode::MUL:
			case IROpcode::DIV:
			case IROpcode::MOD:
			case IROpcode::NEG:
			case IROpcode::NOT:
			case IROpcode::AND:     // Logical AND reads operands
			case IROpcode::OR:      // Logical OR reads operands
			case IROpcode::CMP_EQ:
			case IROpcode::CMP_NEQ:
			case IROpcode::CMP_LT:
			case IROpcode::CMP_LTE:
			case IROpcode::CMP_GT:
			case IROpcode::CMP_GTE:
			case IROpcode::VCALL:
			case IROpcode::VGET:
			case IROpcode::VSET:
			case IROpcode::CALL:
			case IROpcode::CALL_SYSCALL:
			// Inline primitive construction - these read from their argument registers
			case IROpcode::MAKE_VECTOR2:
			case IROpcode::MAKE_VECTOR3:
			case IROpcode::MAKE_VECTOR4:
			case IROpcode::MAKE_VECTOR2I:
			case IROpcode::MAKE_VECTOR3I:
			case IROpcode::MAKE_VECTOR4I:
			case IROpcode::MAKE_COLOR:
			case IROpcode::MAKE_RECT2:
			case IROpcode::MAKE_RECT2I:
			case IROpcode::MAKE_PLANE:
			case IROpcode::MAKE_ARRAY:
			case IROpcode::MAKE_DICTIONARY:
			// Inline member access - these read from the object register
			case IROpcode::VGET_INLINE:
			case IROpcode::VSET_INLINE:
				// Mark all register operands (except first for most ops) as live
				for (size_t i = 1; i < instr.operands.size(); i++) {
					if (instr.operands[i].type == IRValue::Type::REGISTER) {
						live.insert(std::get<int>(instr.operands[i].value));
					}
				}
				break;

			case IROpcode::RETURN:
				// Return reads from register 0
				if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
					live.insert(std::get<int>(instr.operands[0].value));
				} else {
					// Implicit return of r0
					live.insert(0);
				}
				break;

			default:
				break;
		}
	}

	return live;
}

bool IROptimizer::is_register_used_after(const IRFunction& func, int reg, size_t instr_idx) {
	for (size_t i = instr_idx; i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];

		// Check if register is read
		for (size_t j = 0; j < instr.operands.size(); j++) {
			if (instr.operands[j].type == IRValue::Type::REGISTER) {
				int r = std::get<int>(instr.operands[j].value);
				if (r == reg) {
					// For most instructions, first operand is destination, rest are sources
					// Exception: BRANCH_ZERO, BRANCH_NOT_ZERO read first operand
					if (j > 0 || instr.opcode == IROpcode::BRANCH_ZERO || instr.opcode == IROpcode::BRANCH_NOT_ZERO) {
						return true;
					}
				}
			}
		}

		// Check if register is written (kills liveness)
		switch (instr.opcode) {
			case IROpcode::LOAD_IMM:
			case IROpcode::LOAD_BOOL:
			case IROpcode::LOAD_STRING:
			case IROpcode::MOVE:
			case IROpcode::ADD:
			case IROpcode::SUB:
			case IROpcode::MUL:
			case IROpcode::DIV:
			case IROpcode::MOD:
			case IROpcode::NEG:
			case IROpcode::NOT:
			case IROpcode::CMP_EQ:
			case IROpcode::CMP_NEQ:
			case IROpcode::CMP_LT:
			case IROpcode::CMP_LTE:
			case IROpcode::CMP_GT:
			case IROpcode::CMP_GTE:
				if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
					int dst = std::get<int>(instr.operands[0].value);
					if (dst == reg) {
						return false; // Register is overwritten before use
					}
				}
				break;

			default:
				break;
		}
	}

	return false;
}

void IROptimizer::reduce_register_pressure(IRFunction& func) {
	// Build a mapping of old register numbers to new (compacted) register numbers
	std::unordered_map<int, int> reg_map;
	int next_reg = 0;

	// First pass: identify all used registers and assign new numbers
	for (const auto& instr : func.instructions) {
		for (const auto& op : instr.operands) {
			if (op.type == IRValue::Type::REGISTER) {
				int old_reg = std::get<int>(op.value);
				if (reg_map.find(old_reg) == reg_map.end()) {
					reg_map[old_reg] = next_reg++;
				}
			}
		}
	}

	// Second pass: rewrite all register references
	for (auto& instr : func.instructions) {
		for (auto& op : instr.operands) {
			if (op.type == IRValue::Type::REGISTER) {
				int old_reg = std::get<int>(op.value);
				op.value = reg_map[old_reg];
			}
		}
	}
}

void IROptimizer::set_register_constant(int reg, const ConstantValue& value) {
	m_constants[reg] = value;
}

void IROptimizer::invalidate_register(int reg) {
	m_constants.erase(reg);
}

IROptimizer::ConstantValue IROptimizer::get_constant(const IRValue& val) {
	ConstantValue cv;
	if (val.type == IRValue::Type::IMMEDIATE) {
		cv.type = ConstantValue::Type::INT;
		cv.int_value = std::get<int64_t>(val.value);
	}
	return cv;
}

bool IROptimizer::is_arithmetic_op(IROpcode op) {
	switch (op) {
		case IROpcode::ADD:
		case IROpcode::SUB:
		case IROpcode::MUL:
		case IROpcode::DIV:
		case IROpcode::MOD:
		case IROpcode::NEG:
		case IROpcode::AND:
		case IROpcode::OR:
		case IROpcode::CMP_EQ:
		case IROpcode::CMP_NEQ:
		case IROpcode::CMP_LT:
		case IROpcode::CMP_LTE:
		case IROpcode::CMP_GT:
		case IROpcode::CMP_GTE:
			return true;
		default:
			return false;
	}
}

bool IROptimizer::is_branch_op(IROpcode op) {
	switch (op) {
		case IROpcode::BRANCH_ZERO:
		case IROpcode::BRANCH_NOT_ZERO:
		case IROpcode::BRANCH_EQ:
		case IROpcode::BRANCH_NEQ:
		case IROpcode::BRANCH_LT:
		case IROpcode::BRANCH_LTE:
		case IROpcode::BRANCH_GT:
		case IROpcode::BRANCH_GTE:
			return true;
		default:
			return false;
	}
}

bool IROptimizer::is_reg_used_between_exclusive(const IRFunction& func, int reg, size_t start_idx, size_t end_idx, bool conservative_at_labels) {
	// Check if register is used in the instruction range (start_idx, end_idx)
	// Exclusive of both boundaries
	end_idx = std::min(end_idx, func.instructions.size());

	for (size_t i = start_idx + 1; i < end_idx; i++) {
		const auto& instr = func.instructions[i];

		// LABEL is a control flow boundary - be conservative (unless told otherwise)
		if (instr.opcode == IROpcode::LABEL) {
			return conservative_at_labels;
		}

		// Fused branch instructions read both operands 0 and 1 as source operands (not destinations)
		bool is_fused_branch = (instr.opcode == IROpcode::BRANCH_EQ ||
		                         instr.opcode == IROpcode::BRANCH_NEQ ||
		                         instr.opcode == IROpcode::BRANCH_LT ||
		                         instr.opcode == IROpcode::BRANCH_LTE ||
		                         instr.opcode == IROpcode::BRANCH_GT ||
		                         instr.opcode == IROpcode::BRANCH_GTE);

		// For fused branches, check operands 0 and 1 (both are source operands)
		// For other instructions, skip operand 0 (it's the destination)
		size_t start_operand = is_fused_branch ? 0 : 1;

		// Check if register is read (used as source operand)
		for (size_t j = start_operand; j < instr.operands.size(); j++) {
			if (instr.operands[j].type == IRValue::Type::REGISTER) {
				int r = std::get<int>(instr.operands[j].value);
				if (r == reg) {
					return true;
				}
			}
		}

		// Special case: BRANCH_ZERO and BRANCH_NOT_ZERO read first operand
		if ((instr.opcode == IROpcode::BRANCH_ZERO || instr.opcode == IROpcode::BRANCH_NOT_ZERO) &&
		    instr.operands.size() >= 1 && instr.operands[0].type == IRValue::Type::REGISTER) {
			int r = std::get<int>(instr.operands[0].value);
			if (r == reg) {
				return true;
			}
		}
	}

	return false;
}

static void flush_pending(std::vector<IRInstruction>& new_instructions,
	std::unordered_map<int, size_t>& pending_stores, const IRFunction& func)
{
	if (!pending_stores.empty()) {
		// Sort by original instruction index to maintain order
		std::vector<std::pair<int, size_t>> sorted(pending_stores.begin(), pending_stores.end());
		std::sort(sorted.begin(), sorted.end(),
		         [](const auto& a, const auto& b) { return a.second < b.second; });

		for (const auto& [reg, idx] : sorted) {
			new_instructions.push_back(func.instructions[idx]);
		}
		pending_stores.clear();
	}
}
static bool reads_pending_store(const IRInstruction& instr,
	const std::unordered_map<int, size_t>& pending_stores)
{
	for (size_t i = 1; i < instr.operands.size(); i++) {
		const auto& op = instr.operands[i];
		if (op.type == IRValue::Type::REGISTER) {
			int reg = std::get<int>(op.value);
			if (pending_stores.count(reg)) {
				return true;
			}
		}
	}
	// Special case: BRANCH_ZERO and BRANCH_NOT_ZERO read the first operand
	if ((instr.opcode == IROpcode::BRANCH_ZERO || instr.opcode == IROpcode::BRANCH_NOT_ZERO) &&
		!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
		int reg = std::get<int>(instr.operands[0].value);
		if (pending_stores.count(reg)) {
			return true;
		}
	}
	return false;
}

void IROptimizer::eliminate_redundant_stores(IRFunction& func) {
	// This pass eliminates redundant store operations:
	// 1. Dead stores: Store to a register that is immediately overwritten
	//    Example: LOAD_IMM r0, 10; LOAD_IMM r0, 20  -> first instruction is dead
	// 2. Consecutive identical stores: Same value stored to same register
	//    Example: LOAD_IMM r0, 10; LOAD_IMM r0, 10  -> second is redundant
	//
	// This is done by delaying the emission of store instructions until we're sure
	// they're not dead (overwritten without being read) or redundant (same value).

	if (func.instructions.empty()) {
		return;
	}

	std::vector<IRInstruction> new_instructions;
	new_instructions.reserve(func.instructions.size());

	// Track pending stores that haven't been emitted yet
	std::unordered_map<int, size_t> pending_stores;  // reg -> instruction index

	for (size_t i = 0; i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];

		// Control flow boundaries - flush all pending stores
		if (instr.opcode == IROpcode::LABEL ||
		    instr.opcode == IROpcode::JUMP ||
		    is_branch_op(instr.opcode) ||
		    instr.opcode == IROpcode::CALL ||
		    instr.opcode == IROpcode::VCALL ||
		    instr.opcode == IROpcode::CALL_SYSCALL ||
		    instr.opcode == IROpcode::RETURN) {
			flush_pending(new_instructions, pending_stores, func);
			new_instructions.push_back(instr);
			continue;
		}

		// Check if this instruction reads from a register with a pending store
		if (reads_pending_store(instr, pending_stores)) {
			flush_pending(new_instructions, pending_stores, func);
		}

		// Check if this is a pure load/store operation to a register
		if (is_pure_load_op(instr.opcode) && !instr.operands.empty() &&
		    instr.operands[0].type == IRValue::Type::REGISTER) {
			int dst = std::get<int>(instr.operands[0].value);

			// Check if we have a previous pending store to the same register
			if (pending_stores.count(dst)) {
				size_t prev_idx = pending_stores[dst];
				const auto& prev_instr = func.instructions[prev_idx];

				// Check if stores are identical (same opcode and value)
				bool is_identical = (prev_instr.opcode == instr.opcode &&
				                     prev_instr.operands.size() == instr.operands.size());

				if (is_identical && instr.operands.size() >= 2) {
					const auto& curr_val = instr.operands[1];
					const auto& prev_val = prev_instr.operands[1];

					if (curr_val.type != prev_val.type) {
						is_identical = false;
					} else if (curr_val.type == IRValue::Type::IMMEDIATE) {
						is_identical = (std::get<int64_t>(curr_val.value) ==
						                std::get<int64_t>(prev_val.value));
					} else if (curr_val.type == IRValue::Type::FLOAT) {
						is_identical = (std::get<double>(curr_val.value) ==
						                std::get<double>(prev_val.value));
					} else if (curr_val.type == IRValue::Type::REGISTER) {
						// For MOVE: compare source register
						is_identical = (std::get<int>(curr_val.value) ==
						                std::get<int>(prev_val.value));
					} else {
						is_identical = false;
					}
				}

				if (is_identical) {
					// Consecutive identical stores - skip current one
					continue;
				}

				// Different store to same register - replace previous with this one
				pending_stores[dst] = i;
				continue;
			}

			// First store to this register - track it as pending
			pending_stores[dst] = i;
			continue;
		}

		// Not a store operation - add it directly
		new_instructions.push_back(instr);
	}

	// Flush any remaining pending stores
	flush_pending(new_instructions, pending_stores, func);

	func.instructions = std::move(new_instructions);
}

bool IROptimizer::is_pure_load_op(IROpcode op) {
	switch (op) {
		case IROpcode::LOAD_IMM:
		case IROpcode::LOAD_FLOAT_IMM:
		case IROpcode::LOAD_BOOL:
		case IROpcode::LOAD_STRING:
		case IROpcode::MOVE:
			return true;
		default:
			return false;
	}
}

// ============================================================================
// Loop-Invariant Code Motion (LICM)
// ============================================================================

std::vector<IROptimizer::LoopInfo> IROptimizer::identify_loops(const IRFunction& func) {
	std::vector<LoopInfo> loops;

	// Map label names to instruction indices
	std::unordered_map<std::string, size_t> label_positions;
	for (size_t i = 0; i < func.instructions.size(); i++) {
		if (func.instructions[i].opcode == IROpcode::LABEL) {
			std::string label = std::get<std::string>(func.instructions[i].operands[0].value);
			label_positions[label] = i;
		}
	}

	// Find all loops by detecting back edges (JUMP to earlier label)
	// Also find loop exit labels
	std::unordered_map<std::string, std::string> loop_to_exit;  // header -> exit label

	for (size_t i = 0; i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];

		// Look for JUMP instructions
		if (instr.opcode == IROpcode::JUMP && !instr.operands.empty() &&
		    instr.operands[0].type == IRValue::Type::LABEL) {
			std::string target_label = std::get<std::string>(instr.operands[0].value);

			// Check if this is a back edge (jumping to earlier instruction)
			auto it = label_positions.find(target_label);
			if (it != label_positions.end() && it->second <= i) {
				size_t header_idx = it->second;

				// Try to find the loop exit label
				// Look for branch instructions between header and back edge
				std::string exit_label;
				for (size_t j = header_idx; j < i; j++) {
					const auto& loop_instr = func.instructions[j];
					if (is_branch_op(loop_instr.opcode)) {
						// Find the label operand (last operand for all branch types)
						size_t label_idx = loop_instr.operands.size() - 1;
						if (label_idx < loop_instr.operands.size() &&
						    loop_instr.operands[label_idx].type == IRValue::Type::LABEL) {
							exit_label = std::get<std::string>(loop_instr.operands[label_idx].value);
							break;
						}
					}
				}

				// Find the exit label position
				size_t exit_idx = i + 1;  // Default to after back edge
				if (!exit_label.empty()) {
					auto exit_it = label_positions.find(exit_label);
					if (exit_it != label_positions.end()) {
						exit_idx = exit_it->second;
					}
				}

				// Check if we already have this loop
				bool found = false;
				for (auto& loop : loops) {
					if (loop.header_idx == header_idx) {
						loop.back_edges.push_back(i);
						found = true;
						break;
					}
				}

				if (!found) {
					LoopInfo loop;
					loop.header_idx = header_idx;
					loop.end_idx = exit_idx;
					loop.header_label = target_label;
					loop.end_label = exit_label;
					loop.back_edges.push_back(i);
					loops.push_back(loop);
				}
			}
		}
	}

	return loops;
}

bool IROptimizer::is_loop_invariant(const IRInstruction& instr, const LoopInfo& loop,
                                    const IRFunction& func, const std::unordered_set<int>& invariant_regs) {
	// Only consider pure operations
	if (!is_pure_load_op(instr.opcode)) {
		return false;
	}

	// LOAD_IMM, LOAD_FLOAT_IMM, LOAD_BOOL are always invariant (no register operands)
	if (instr.opcode == IROpcode::LOAD_IMM ||
	    instr.opcode == IROpcode::LOAD_FLOAT_IMM ||
	    instr.opcode == IROpcode::LOAD_BOOL ||
	    instr.opcode == IROpcode::LOAD_STRING) {
		return true;
	}

	// MOVE is invariant if source register is invariant
	if (instr.opcode == IROpcode::MOVE && instr.operands.size() >= 2 &&
	    instr.operands[1].type == IRValue::Type::REGISTER) {
		int src_reg = std::get<int>(instr.operands[1].value);
		return invariant_regs.count(src_reg) > 0;
	}

	return false;
}

bool IROptimizer::can_safely_hoist(const IRInstruction& instr, size_t instr_idx, const LoopInfo& loop, const IRFunction& func) {
	// Check that:
	// 1. The destination register is not used before being defined in the loop
	// 2. Source registers are not modified anywhere in the loop (loop-invariant)

	if (instr.operands.empty() || instr.operands[0].type != IRValue::Type::REGISTER) {
		return false;
	}

	int dst_reg = std::get<int>(instr.operands[0].value);

	// Collect source registers from this instruction
	std::unordered_set<int> src_regs;
	for (size_t j = 1; j < instr.operands.size(); j++) {
		if (instr.operands[j].type == IRValue::Type::REGISTER) {
			src_regs.insert(std::get<int>(instr.operands[j].value));
		}
	}

	// Check the entire loop body (from header to all back edges)
	for (size_t i = loop.header_idx; i < loop.end_idx && i < func.instructions.size(); i++) {
		const auto& loop_instr = func.instructions[i];

		// Skip the instruction we're trying to hoist
		if (i == instr_idx) {
			continue;
		}

		// Check if any source register is modified in the loop
		if (!loop_instr.operands.empty() && loop_instr.operands[0].type == IRValue::Type::REGISTER) {
			int modified_reg = std::get<int>(loop_instr.operands[0].value);
			if (src_regs.count(modified_reg)) {
				return false;  // Can't hoist - source register is modified in loop
			}
		}

		// Check if dst_reg is read before being written (only before this instruction)
		if (i < instr_idx) {
			for (size_t j = 1; j < loop_instr.operands.size(); j++) {
				if (loop_instr.operands[j].type == IRValue::Type::REGISTER) {
					int reg = std::get<int>(loop_instr.operands[j].value);
					if (reg == dst_reg) {
						return false;  // Can't hoist - dst is read before being written
					}
				}
			}
		}
	}

	return true;
}

void IROptimizer::loop_invariant_code_motion(IRFunction& func) {
	auto loops = identify_loops(func);

	if (loops.empty()) {
		return;  // No loops to optimize
	}

	// Check for nested loops - if any loop is nested, skip LICM entirely
	// A loop is nested if its header is between another loop's header and end
	for (const auto& loop : loops) {
		for (const auto& other : loops) {
			if (&loop == &other) continue;
			// Check if this loop is inside the other loop
			if (loop.header_idx > other.header_idx && loop.header_idx < other.end_idx) {
				// Found nested loops - skip LICM to avoid complexity
				return;
			}
		}
	}

	// No nested loops - safe to optimize
	// Process each loop
	for (const auto& loop : loops) {
			// Build set of invariant registers
			// Start with registers defined outside the loop
			std::unordered_set<int> invariant_regs;

			for (size_t i = 0; i < loop.header_idx; i++) {
				const auto& instr = func.instructions[i];
				if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
					invariant_regs.insert(std::get<int>(instr.operands[0].value));
				}
			}

			// Iteratively find invariant instructions within the loop
			std::unordered_set<size_t> invariant_instrs;
			bool loop_changed = true;

			while (loop_changed) {
				loop_changed = false;

				for (size_t i = loop.header_idx + 1; i < loop.end_idx && i < func.instructions.size(); i++) {
					if (invariant_instrs.count(i)) {
						continue;  // Already marked as invariant
					}

					const auto& instr = func.instructions[i];

					// Skip labels and control flow
					if (instr.opcode == IROpcode::LABEL ||
					    instr.opcode == IROpcode::JUMP ||
					    is_branch_op(instr.opcode)) {
						continue;
					}

					if (is_loop_invariant(instr, loop, func, invariant_regs) &&
					    can_safely_hoist(instr, i, loop, func)) {
						invariant_instrs.insert(i);

						// Add destination register to invariant set
						if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
							invariant_regs.insert(std::get<int>(instr.operands[0].value));
						}

						loop_changed = true;
					}
				}
			}

		// Hoist invariant instructions
		if (!invariant_instrs.empty()) {
			std::vector<IRInstruction> hoisted;
			std::vector<IRInstruction> remaining;

			for (size_t i = 0; i < func.instructions.size(); i++) {
				if (i >= loop.header_idx && i < loop.end_idx && invariant_instrs.count(i)) {
					// This instruction will be hoisted
					hoisted.push_back(func.instructions[i]);
				} else {
					remaining.push_back(func.instructions[i]);
				}
			}

			// Rebuild function with hoisted instructions inserted before loop header
			std::vector<IRInstruction> new_instructions;
			for (size_t i = 0; i < remaining.size(); i++) {
				if (remaining[i].opcode == IROpcode::LABEL && i < remaining.size() &&
				    std::get<std::string>(remaining[i].operands[0].value) == loop.header_label) {
					// Insert hoisted instructions before loop header
					new_instructions.insert(new_instructions.end(), hoisted.begin(), hoisted.end());
				}
				new_instructions.push_back(remaining[i]);
			}

			func.instructions = std::move(new_instructions);
		}
	}
}

// ============================================================================
// Enhanced Copy Propagation
// ============================================================================

bool IROptimizer::register_unmodified_between(const IRFunction& func, int reg,
                                              size_t start_idx, size_t end_idx) {
	for (size_t i = start_idx + 1; i < end_idx && i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];

		// Check if this instruction writes to the register
		if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
			int dst = std::get<int>(instr.operands[0].value);
			if (dst == reg) {
				return false;  // Register is modified
			}
		}

		// Control flow boundaries - be conservative
		if (instr.opcode == IROpcode::LABEL) {
			return false;
		}
	}

	return true;
}

void IROptimizer::enhanced_copy_propagation(IRFunction& func) {
	// Track copies: register -> source register
	std::unordered_map<int, CopyInfo> copies;
	std::vector<IRInstruction> new_instructions;
	new_instructions.reserve(func.instructions.size());

	for (size_t i = 0; i < func.instructions.size(); i++) {
		auto instr = func.instructions[i];  // Make a copy we can modify

		// Clear copy tracking at control flow boundaries
		if (instr.opcode == IROpcode::LABEL ||
		    instr.opcode == IROpcode::JUMP ||
		    is_branch_op(instr.opcode) ||
		    instr.opcode == IROpcode::CALL ||
		    instr.opcode == IROpcode::VCALL ||
		    instr.opcode == IROpcode::CALL_SYSCALL) {
			copies.clear();
		}

		// Track MOVE instructions
		if (instr.opcode == IROpcode::MOVE && instr.operands.size() >= 2 &&
		    instr.operands[0].type == IRValue::Type::REGISTER &&
		    instr.operands[1].type == IRValue::Type::REGISTER) {
			int dst = std::get<int>(instr.operands[0].value);
			int src = std::get<int>(instr.operands[1].value);

			// Follow the copy chain: if src is itself a copy, use the original source
			while (copies.count(src)) {
				src = copies[src].source_reg;
			}

			copies[dst] = {src, i};
		}

		// Propagate copies in operands (skip first operand which is usually destination)
		bool modified = false;
		for (size_t j = 1; j < instr.operands.size(); j++) {
			if (instr.operands[j].type == IRValue::Type::REGISTER) {
				int reg = std::get<int>(instr.operands[j].value);

				// Check if we can propagate this copy
				if (copies.count(reg)) {
					const auto& copy_info = copies[reg];

					// Verify the source register hasn't been modified
					if (register_unmodified_between(func, copy_info.source_reg, copy_info.def_idx, i)) {
						instr.operands[j].value = copy_info.source_reg;
						modified = true;
					}
				}
			}
		}

		// Special case: BRANCH_ZERO and BRANCH_NOT_ZERO read first operand
		if ((instr.opcode == IROpcode::BRANCH_ZERO || instr.opcode == IROpcode::BRANCH_NOT_ZERO) &&
		    !instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
			int reg = std::get<int>(instr.operands[0].value);

			if (copies.count(reg)) {
				const auto& copy_info = copies[reg];
				if (register_unmodified_between(func, copy_info.source_reg, copy_info.def_idx, i)) {
					instr.operands[0].value = copy_info.source_reg;
					modified = true;
				}
			}
		}

		// Invalidate copies when destination register is written
		if (!instr.operands.empty() && instr.operands[0].type == IRValue::Type::REGISTER) {
			int dst = std::get<int>(instr.operands[0].value);

			// Remove any copies of this register
			copies.erase(dst);

			// Remove any copies that use this register as source
			for (auto it = copies.begin(); it != copies.end(); ) {
				if (it->second.source_reg == dst) {
					it = copies.erase(it);
				} else {
					++it;
				}
			}
		}

		new_instructions.push_back(instr);
	}

	func.instructions = std::move(new_instructions);
}

} // namespace gdscript

```

`src/gdscript/compiler/ir_optimizer.h`:

```h
#pragma once
#include "ir.h"
#include <unordered_map>
#include <unordered_set>

namespace gdscript {

// IR-level optimizations to reduce stack usage and improve performance
class IROptimizer {
public:
	IROptimizer();

	// Optimize an entire IR program
	void optimize(IRProgram& program);

	// Optimize a single function
	void optimize_function(IRFunction& func);

private:
	// Optimization passes
	void constant_folding(IRFunction& func);
	void eliminate_dead_code(IRFunction& func);
	void peephole_optimization(IRFunction& func);
	void copy_propagation(IRFunction& func);
	void eliminate_redundant_stores(IRFunction& func);
	void reduce_register_pressure(IRFunction& func);
	void loop_invariant_code_motion(IRFunction& func);
	void enhanced_copy_propagation(IRFunction& func);

	// Helper for constant folding
	struct ConstantValue {
		enum class Type { NONE, INT, FLOAT, BOOL, STRING };
		Type type = Type::NONE;
		int64_t int_value = 0;
		double float_value = 0.0;
		bool bool_value = false;
		std::string string_value;

		bool is_constant() const { return type != Type::NONE; }
	};

	// Track known constant values for registers
	std::unordered_map<int, ConstantValue> m_constants;

	// Helper methods
	ConstantValue get_constant(const IRValue& val);
	bool try_fold_binary_op(IROpcode op, IRInstruction::TypeHint type_hint, const ConstantValue& lhs, const ConstantValue& rhs, ConstantValue& result);
	void set_register_constant(int reg, const ConstantValue& value);
	void invalidate_register(int reg);

	// Dead code elimination helpers
	std::unordered_set<int> find_live_registers(const IRFunction& func);
	bool is_register_used_after(const IRFunction& func, int reg, size_t instr_idx);

	// Peephole optimization helpers
	static bool is_arithmetic_op(IROpcode op);
	static bool is_branch_op(IROpcode op);
	static bool is_reg_used_between_exclusive(const IRFunction& func, int reg, size_t start_idx, size_t end_idx, bool conservative_at_labels = true);
	static bool is_pure_load_op(IROpcode op);

	// LICM helpers
	struct LoopInfo {
		size_t header_idx;      // Index of loop header LABEL
		size_t end_idx;         // Index of loop end LABEL
		std::string header_label;
		std::string end_label;
		std::vector<size_t> back_edges;  // Indices of JUMP instructions to header
	};
	std::vector<LoopInfo> identify_loops(const IRFunction& func);
	bool is_loop_invariant(const IRInstruction& instr, const LoopInfo& loop,
	                       const IRFunction& func, const std::unordered_set<int>& invariant_regs);
	bool can_safely_hoist(const IRInstruction& instr, size_t instr_idx, const LoopInfo& loop, const IRFunction& func);

	// Enhanced copy propagation helpers
	struct CopyInfo {
		int source_reg;
		size_t def_idx;
	};
	bool register_unmodified_between(const IRFunction& func, int reg, size_t start_idx, size_t end_idx);
};

} // namespace gdscript

```

`src/gdscript/compiler/lexer.cpp`:

```cpp
#include "lexer.h"
#include "compiler_exception.h"
#include <cctype>
#include <stdexcept>

namespace gdscript {

const std::unordered_map<std::string, TokenType> Lexer::keywords = {
	{"func", TokenType::FUNC},
	{"var", TokenType::VAR},
	{"const", TokenType::CONST},
	{"return", TokenType::RETURN},
	{"if", TokenType::IF},
	{"else", TokenType::ELSE},
	{"elif", TokenType::ELIF},
	{"for", TokenType::FOR},
	{"in", TokenType::IN},
	{"while", TokenType::WHILE},
	{"break", TokenType::BREAK},
	{"continue", TokenType::CONTINUE},
	{"pass", TokenType::PASS},
	{"extends", TokenType::EXTENDS},
	{"true", TokenType::TRUE},
	{"false", TokenType::FALSE},
	{"null", TokenType::NULL_VAL},
	{"and", TokenType::AND},
	{"or", TokenType::OR},
	{"not", TokenType::NOT},
};

Lexer::Lexer(std::string source) : m_source(std::move(source)) {
	m_indent_stack.push_back(0); // Start with zero indentation
}

std::vector<Token> Lexer::tokenize() {
	while (!is_at_end()) {
		m_start = m_current;
		scan_token();
	}

	// Add remaining dedents at end of file
	while (m_indent_stack.size() > 1) {
		m_indent_stack.pop_back();
		add_token(TokenType::DEDENT);
	}

	add_token(TokenType::EOF_TOKEN);
	return m_tokens;
}

void Lexer::scan_token() {
	// Handle indentation at line start
	if (m_at_line_start) {
		handle_indent();
		return;
	}

	char c = advance();

	switch (c) {
		case ' ':
		case '\r':
		case '\t':
			// Skip whitespace (except at line start)
			break;

		case '\n':
			add_token(TokenType::NEWLINE);
			m_line++;
			m_column = 1;
			m_at_line_start = true;
			break;

		case '#':
			// Comment - skip to end of line
			while (peek() != '\n' && !is_at_end()) advance();
			break;

		case '(': add_token(TokenType::LPAREN); break;
		case ')': add_token(TokenType::RPAREN); break;
		case '[': add_token(TokenType::LBRACKET); break;
		case ']': add_token(TokenType::RBRACKET); break;
		case '{': add_token(TokenType::LBRACE); break;
		case '}': add_token(TokenType::RBRACE); break;
		case ':': add_token(TokenType::COLON); break;
		case ',': add_token(TokenType::COMMA); break;
		case '.': add_token(TokenType::DOT); break;
		case '@': add_token(TokenType::AT); break;
		case '+': add_token(match('=') ? TokenType::PLUS_ASSIGN : TokenType::PLUS); break;
		case '-': add_token(match('=') ? TokenType::MINUS_ASSIGN : TokenType::MINUS); break;
		case '*': add_token(match('=') ? TokenType::MULTIPLY_ASSIGN : TokenType::MULTIPLY); break;
		case '/': add_token(match('=') ? TokenType::DIVIDE_ASSIGN : TokenType::DIVIDE); break;
		case '%': add_token(match('=') ? TokenType::MODULO_ASSIGN : TokenType::MODULO); break;

		case '=':
			add_token(match('=') ? TokenType::EQUAL : TokenType::ASSIGN);
			break;

		case '!':
			if (match('=')) {
				add_token(TokenType::NOT_EQUAL);
			} else {
				error("Unexpected character '!'");
			}
			break;

		case '<':
			add_token(match('=') ? TokenType::LESS_EQUAL : TokenType::LESS);
			break;

		case '>':
			add_token(match('=') ? TokenType::GREATER_EQUAL : TokenType::GREATER);
			break;

		case '"':
		case '\'':
			scan_string();
			break;

		default:
			if (is_digit(c)) {
				scan_number();
			} else if (is_alpha(c)) {
				scan_identifier();
			} else {
				error("Unexpected character");
			}
			break;
	}
}

void Lexer::handle_indent() {
	int indent_level = 0;

	while (!is_at_end() && (peek() == ' ' || peek() == '\t')) {
		if (peek() == '\t') {
			indent_level += 4; // Tab counts as 4 spaces
		} else {
			indent_level += 1;
		}
		advance();
	}

	// Skip blank lines and comments
	if (is_at_end() || peek() == '\n' || peek() == '#') {
		m_at_line_start = false;
		return;
	}

	m_at_line_start = false;

	int current_indent = m_indent_stack.back();

	if (indent_level > current_indent) {
		m_indent_stack.push_back(indent_level);
		add_token(TokenType::INDENT);
	} else if (indent_level < current_indent) {
		while (m_indent_stack.size() > 1 && m_indent_stack.back() > indent_level) {
			m_indent_stack.pop_back();
			add_token(TokenType::DEDENT);
		}

		if (m_indent_stack.back() != indent_level) {
			error("Inconsistent indentation");
		}
	}
}

void Lexer::scan_string() {
	char quote = m_source[m_current - 1];
	std::string value;

	while (!is_at_end() && peek() != quote) {
		if (peek() == '\n') {
			m_line++;
			m_column = 0;
		} else if (peek() == '\\') {
			advance();
			if (!is_at_end()) {
				char escaped = advance();
				switch (escaped) {
					case 'n': value += '\n'; break;
					case 't': value += '\t'; break;
					case 'r': value += '\r'; break;
					case '\\': value += '\\'; break;
					case '"': value += '"'; break;
					case '\'': value += '\''; break;
					default: value += escaped; break;
				}
				continue;
			}
		}
		value += advance();
	}

	if (is_at_end()) {
		error("Unterminated string");
		return;
	}

	advance(); // Closing quote
	add_token(TokenType::STRING, value);
}

void Lexer::scan_number() {
	while (is_digit(peek())) advance();

	bool is_float = false;

	// Look for decimal point
	if (peek() == '.' && is_digit(peek_next())) {
		is_float = true;
		advance(); // Consume '.'
		while (is_digit(peek())) advance();
	}

	std::string num_str = m_source.substr(m_start, m_current - m_start);

	if (is_float) {
		double d = std::stod(num_str);
		add_token(TokenType::FLOAT, d);
	} else {
		int64_t i = std::stoll(num_str);
		add_token(TokenType::INTEGER, i);
	}
}

void Lexer::scan_identifier() {
	while (is_alphanumeric(peek())) advance();

	std::string text = m_source.substr(m_start, m_current - m_start);

	auto it = keywords.find(text);
	TokenType type = (it != keywords.end()) ? it->second : TokenType::IDENTIFIER;

	add_token(type);
}

char Lexer::advance() {
	m_column++;
	return m_source[m_current++];
}

char Lexer::peek() const {
	if (is_at_end()) return '\0';
	return m_source[m_current];
}

char Lexer::peek_next() const {
	if (m_current + 1 >= m_source.length()) return '\0';
	return m_source[m_current + 1];
}

bool Lexer::match(char expected) {
	if (is_at_end()) return false;
	if (m_source[m_current] != expected) return false;

	m_current++;
	m_column++;
	return true;
}

bool Lexer::is_at_end() const {
	return m_current >= m_source.length();
}

bool Lexer::is_digit(char c) const {
	return c >= '0' && c <= '9';
}

bool Lexer::is_alpha(char c) const {
	return (c >= 'a' && c <= 'z') ||
	       (c >= 'A' && c <= 'Z') ||
	       c == '_';
}

bool Lexer::is_alphanumeric(char c) const {
	return is_alpha(c) || is_digit(c);
}

void Lexer::add_token(TokenType type) {
	std::string text = m_source.substr(m_start, m_current - m_start);
	m_tokens.emplace_back(type, text, m_line, m_column);
}

void Lexer::add_token(TokenType type, int64_t value) {
	std::string text = m_source.substr(m_start, m_current - m_start);
	Token token(type, text, m_line, m_column);
	token.value = value;
	m_tokens.push_back(token);
}

void Lexer::add_token(TokenType type, double value) {
	std::string text = m_source.substr(m_start, m_current - m_start);
	Token token(type, text, m_line, m_column);
	token.value = value;
	m_tokens.push_back(token);
}

void Lexer::add_token(TokenType type, const std::string& value) {
	std::string text = m_source.substr(m_start, m_current - m_start);
	Token token(type, text, m_line, m_column);
	token.value = value;
	m_tokens.push_back(token);
}

void Lexer::error(const std::string& message) {
	throw CompilerException(ErrorType::LEXER_ERROR, message, m_line, m_column);
}

} // namespace gdscript

```

`src/gdscript/compiler/lexer.h`:

```h
#pragma once
#include "token.h"
#include <vector>
#include <string>
#include <unordered_map>

namespace gdscript {

class Lexer {
public:
	explicit Lexer(std::string source);

	std::vector<Token> tokenize();

private:
	void scan_token();
	void scan_string();
	void scan_number();
	void scan_identifier();
	void handle_indent();

	char advance();
	char peek() const;
	char peek_next() const;
	bool match(char expected);
	bool is_at_end() const;
	bool is_digit(char c) const;
	bool is_alpha(char c) const;
	bool is_alphanumeric(char c) const;

	void add_token(TokenType type);
	void add_token(TokenType type, int64_t value);
	void add_token(TokenType type, double value);
	void add_token(TokenType type, const std::string& value);

	void error(const std::string& message);

	std::string m_source;
	std::vector<Token> m_tokens;
	std::vector<int> m_indent_stack; // Track indentation levels

	size_t m_start = 0;
	size_t m_current = 0;
	int m_line = 1;
	int m_column = 1;
	bool m_at_line_start = true;

	static const std::unordered_map<std::string, TokenType> keywords;
};

} // namespace gdscript

```

`src/gdscript/compiler/parser.cpp`:

```cpp
#include "parser.h"
#include "compiler_exception.h"
#include <stdexcept>
#include <sstream>

namespace gdscript {

Parser::Parser(std::vector<Token> tokens) : m_tokens(std::move(tokens)) {}

Program Parser::parse() {
	Program program;

	skip_newlines();

	while (!is_at_end()) {
		if (check(TokenType::EXTENDS)) {
			// Parse and ignore extends statement
			advance(); // consume 'extends'
			consume(TokenType::IDENTIFIER, "Expected class name after 'extends'");
			// Skip any newlines after extends
			skip_newlines();
		} else if (check(TokenType::AT)) {
			// Parse attribute (e.g., @export)
			bool is_export = parse_attribute();

			// Skip newlines after attribute
			skip_newlines();

			// After attribute, we expect a var declaration
			if (check(TokenType::VAR)) {
				advance(); // consume 'var'
				auto var_decl = parse_var_decl(false);
				if (auto* decl = dynamic_cast<VarDeclStmt*>(var_decl.get())) {
					VarDeclStmt global_decl(decl->name, std::move(decl->initializer), decl->is_const);
					global_decl.type_hint = decl->type_hint;
					global_decl.is_property = is_export;
					program.globals.push_back(std::move(global_decl));
				}
			} else {
				error("Expected variable declaration after attribute");
				synchronize();
			}
		} else if (check(TokenType::VAR)) {
			// Parse global var declaration
			advance(); // consume 'var'
			auto var_decl = parse_var_decl(false);
			if (auto* decl = dynamic_cast<VarDeclStmt*>(var_decl.get())) {
				VarDeclStmt global_decl(decl->name, std::move(decl->initializer), decl->is_const);
				global_decl.type_hint = decl->type_hint;
				program.globals.push_back(std::move(global_decl));
			}
		} else if (check(TokenType::CONST)) {
			// Parse global const declaration
			advance(); // consume 'const'
			auto const_decl = parse_var_decl(true);
			if (auto* decl = dynamic_cast<VarDeclStmt*>(const_decl.get())) {
				VarDeclStmt global_decl(decl->name, std::move(decl->initializer), decl->is_const);
				global_decl.type_hint = decl->type_hint;
				program.globals.push_back(std::move(global_decl));
			}
		} else if (check(TokenType::FUNC)) {
			program.functions.push_back(parse_function());
		} else {
			error("Expected function or variable declaration");
			synchronize();
		}
		skip_newlines();
	}

	return program;
}

FunctionDecl Parser::parse_function() {
	FunctionDecl func;
	Token func_token = consume(TokenType::FUNC, "Expected 'func'");
	func.line = func_token.line;
	func.column = func_token.column;

	Token name = consume(TokenType::IDENTIFIER, "Expected function name");
	func.name = name.lexeme;

	consume(TokenType::LPAREN, "Expected '(' after function name");
	func.parameters = parse_parameters();
	consume(TokenType::RPAREN, "Expected ')' after parameters");

	// Parse optional return type (e.g., "-> void")
	func.return_type = parse_return_type();

	consume(TokenType::COLON, "Expected ':' after function signature");
	consume(TokenType::NEWLINE, "Expected newline after function signature");

	func.body = parse_block();

	return func;
}

std::vector<Parameter> Parser::parse_parameters() {
	std::vector<Parameter> params;

	if (check(TokenType::RPAREN)) {
		return params;
	}

	do {
		Token param_name = consume(TokenType::IDENTIFIER, "Expected parameter name");
		Parameter param;
		param.name = param_name.lexeme;

		// Parse optional type hint (e.g., ": int")
		param.type_hint = parse_type_hint();

		params.push_back(param);

		if (!check(TokenType::RPAREN)) {
			if (!match(TokenType::COMMA)) {
				break;
			}
		}
	} while (!check(TokenType::RPAREN));

	return params;
}

std::vector<StmtPtr> Parser::parse_block() {
	std::vector<StmtPtr> statements;

	skip_newlines();
	consume(TokenType::INDENT, "Expected indented block");

	while (!check(TokenType::DEDENT) && !is_at_end()) {
		skip_newlines();
		if (!check(TokenType::DEDENT) && !is_at_end()) {
			statements.push_back(parse_statement());
		}
	}

	consume(TokenType::DEDENT, "Expected dedent after block");

	return statements;
}

StmtPtr Parser::parse_statement() {
	skip_newlines();

	if (match(TokenType::VAR)) {
		return parse_var_decl(false);
	}
	if (match(TokenType::CONST)) {
		return parse_var_decl(true);
	}
	if (match(TokenType::IF)) {
		return parse_if_stmt();
	}
	if (match(TokenType::WHILE)) {
		return parse_while_stmt();
	}
	if (match(TokenType::FOR)) {
		return parse_for_stmt();
	}
	if (match(TokenType::RETURN)) {
		return parse_return_stmt();
	}
	if (match(TokenType::BREAK)) {
		auto stmt = std::make_unique<BreakStmt>();
		consume(TokenType::NEWLINE, "Expected newline after 'break'");
		return stmt;
	}
	if (match(TokenType::CONTINUE)) {
		auto stmt = std::make_unique<ContinueStmt>();
		consume(TokenType::NEWLINE, "Expected newline after 'continue'");
		return stmt;
	}
	if (match(TokenType::PASS)) {
		auto stmt = std::make_unique<PassStmt>();
		consume(TokenType::NEWLINE, "Expected newline after 'pass'");
		return stmt;
	}

	return parse_expr_or_assign_stmt();
}

StmtPtr Parser::parse_var_decl(bool is_const) {
	Token name = consume(TokenType::IDENTIFIER, "Expected variable name");

	// Parse optional type hint (e.g., ": int")
	std::string type_hint = parse_type_hint();

	ExprPtr initializer = nullptr;
	if (match(TokenType::ASSIGN)) {
		initializer = parse_expression();
	} else if (is_const) {
		error("Const variables must have an initializer");
	}

	consume(TokenType::NEWLINE, "Expected newline after variable declaration");
	auto stmt = std::make_unique<VarDeclStmt>(name.lexeme, std::move(initializer), is_const);
	stmt->type_hint = type_hint;
	return stmt;
}

StmtPtr Parser::parse_if_stmt() {
	ExprPtr condition = parse_expression();
	consume(TokenType::COLON, "Expected ':' after if condition");
	consume(TokenType::NEWLINE, "Expected newline after ':'");

	std::vector<StmtPtr> then_branch = parse_block();
	std::vector<StmtPtr> else_branch;

	skip_newlines();

	// Handle elif as else { if }
	if (match(TokenType::ELIF)) {
		auto elif_stmt = parse_if_stmt();
		else_branch.push_back(std::move(elif_stmt));
	} else if (match(TokenType::ELSE)) {
		consume(TokenType::COLON, "Expected ':' after else");
		consume(TokenType::NEWLINE, "Expected newline after ':'");
		else_branch = parse_block();
	}

	return std::make_unique<IfStmt>(std::move(condition), std::move(then_branch), std::move(else_branch));
}

StmtPtr Parser::parse_while_stmt() {
	ExprPtr condition = parse_expression();
	consume(TokenType::COLON, "Expected ':' after while condition");
	consume(TokenType::NEWLINE, "Expected newline after ':'");

	std::vector<StmtPtr> body = parse_block();

	return std::make_unique<WhileStmt>(std::move(condition), std::move(body));
}

StmtPtr Parser::parse_for_stmt() {
	// for variable in iterable:
	Token var_name = consume(TokenType::IDENTIFIER, "Expected variable name in for loop");
	consume(TokenType::IN, "Expected 'in' after for loop variable");
	ExprPtr iterable = parse_expression();
	consume(TokenType::COLON, "Expected ':' after for loop iterable");
	consume(TokenType::NEWLINE, "Expected newline after ':'");

	std::vector<StmtPtr> body = parse_block();

	return std::make_unique<ForStmt>(var_name.lexeme, std::move(iterable), std::move(body));
}

StmtPtr Parser::parse_return_stmt() {
	ExprPtr value = nullptr;

	if (!check(TokenType::NEWLINE)) {
		value = parse_expression();
	}

	consume(TokenType::NEWLINE, "Expected newline after return statement");
	return std::make_unique<ReturnStmt>(std::move(value));
}

StmtPtr Parser::parse_expr_or_assign_stmt() {
	// Parse a postfix expression (which can be identifier or indexed expression)
	size_t saved_pos = m_current;
	ExprPtr lhs = parse_call();

	// Check if it's an assignment
	if (match(TokenType::ASSIGN)) {
		ExprPtr value = parse_expression();
		consume(TokenType::NEWLINE, "Expected newline after assignment");

		// Check if lhs is a simple variable, indexed expression, or property access
		if (auto* var_expr = dynamic_cast<VariableExpr*>(lhs.get())) {
			// Simple variable assignment: x = value
			return std::make_unique<AssignStmt>(var_expr->name, std::move(value));
		} else if (dynamic_cast<IndexExpr*>(lhs.get())) {
			// Indexed assignment: arr[0] = value
			return std::make_unique<AssignStmt>(std::move(lhs), std::move(value));
		} else if (auto* member_expr = dynamic_cast<MemberCallExpr*>(lhs.get())) {
			// Property assignment: obj.prop = value
			// Verify it's a property access (not a method call)
			if (member_expr->is_method_call) {
				throw CompilerException::parser_error("Cannot assign to method call", lhs->line, lhs->column);
			}
			return std::make_unique<AssignStmt>(std::move(lhs), std::move(value));
		} else {
			throw CompilerException::parser_error("Invalid assignment target", lhs->line, lhs->column);
		}
	}

	// Handle compound assignments for simple variables only
	if (auto* var_expr = dynamic_cast<VariableExpr*>(lhs.get())) {
		std::string name = var_expr->name;

		if (match(TokenType::PLUS_ASSIGN)) {
			ExprPtr var_ref = std::make_unique<VariableExpr>(name);
			ExprPtr rhs = parse_expression();
			ExprPtr add_expr = std::make_unique<BinaryExpr>(std::move(var_ref), BinaryExpr::Op::ADD, std::move(rhs));
			consume(TokenType::NEWLINE, "Expected newline after assignment");
			return std::make_unique<AssignStmt>(name, std::move(add_expr));
		}

		if (match(TokenType::MINUS_ASSIGN)) {
			ExprPtr var_ref = std::make_unique<VariableExpr>(name);
			ExprPtr rhs = parse_expression();
			ExprPtr sub_expr = std::make_unique<BinaryExpr>(std::move(var_ref), BinaryExpr::Op::SUB, std::move(rhs));
			consume(TokenType::NEWLINE, "Expected newline after assignment");
			return std::make_unique<AssignStmt>(name, std::move(sub_expr));
		}

		if (match(TokenType::MULTIPLY_ASSIGN)) {
			ExprPtr var_ref = std::make_unique<VariableExpr>(name);
			ExprPtr rhs = parse_expression();
			ExprPtr mul_expr = std::make_unique<BinaryExpr>(std::move(var_ref), BinaryExpr::Op::MUL, std::move(rhs));
			consume(TokenType::NEWLINE, "Expected newline after assignment");
			return std::make_unique<AssignStmt>(name, std::move(mul_expr));
		}

		if (match(TokenType::DIVIDE_ASSIGN)) {
			ExprPtr var_ref = std::make_unique<VariableExpr>(name);
			ExprPtr rhs = parse_expression();
			ExprPtr div_expr = std::make_unique<BinaryExpr>(std::move(var_ref), BinaryExpr::Op::DIV, std::move(rhs));
			consume(TokenType::NEWLINE, "Expected newline after assignment");
			return std::make_unique<AssignStmt>(name, std::move(div_expr));
		}

		if (match(TokenType::MODULO_ASSIGN)) {
			ExprPtr var_ref = std::make_unique<VariableExpr>(name);
			ExprPtr rhs = parse_expression();
			ExprPtr mod_expr = std::make_unique<BinaryExpr>(std::move(var_ref), BinaryExpr::Op::MOD, std::move(rhs));
			consume(TokenType::NEWLINE, "Expected newline after assignment");
			return std::make_unique<AssignStmt>(name, std::move(mod_expr));
		}
	}

	// Not an assignment, treat as expression statement
	consume(TokenType::NEWLINE, "Expected newline after expression");
	return std::make_unique<ExprStmt>(std::move(lhs));
}

ExprPtr Parser::parse_expression() {
	return parse_or_expression();
}

ExprPtr Parser::parse_or_expression() {
	ExprPtr left = parse_and_expression();

	while (match(TokenType::OR)) {
		ExprPtr right = parse_and_expression();
		left = std::make_unique<BinaryExpr>(std::move(left), BinaryExpr::Op::OR, std::move(right));
	}

	return left;
}

ExprPtr Parser::parse_and_expression() {
	ExprPtr left = parse_equality();

	while (match(TokenType::AND)) {
		ExprPtr right = parse_equality();
		left = std::make_unique<BinaryExpr>(std::move(left), BinaryExpr::Op::AND, std::move(right));
	}

	return left;
}

ExprPtr Parser::parse_equality() {
	ExprPtr left = parse_comparison();

	while (match_one_of({TokenType::EQUAL, TokenType::NOT_EQUAL})) {
		Token op = previous();
		ExprPtr right = parse_comparison();

		BinaryExpr::Op bin_op = (op.type == TokenType::EQUAL) ? BinaryExpr::Op::EQ : BinaryExpr::Op::NEQ;
		left = std::make_unique<BinaryExpr>(std::move(left), bin_op, std::move(right));
	}

	return left;
}

ExprPtr Parser::parse_comparison() {
	ExprPtr left = parse_term();

	while (match_one_of({TokenType::LESS, TokenType::LESS_EQUAL, TokenType::GREATER, TokenType::GREATER_EQUAL})) {
		Token op = previous();
		ExprPtr right = parse_term();

		BinaryExpr::Op bin_op;
		switch (op.type) {
			case TokenType::LESS: bin_op = BinaryExpr::Op::LT; break;
			case TokenType::LESS_EQUAL: bin_op = BinaryExpr::Op::LTE; break;
			case TokenType::GREATER: bin_op = BinaryExpr::Op::GT; break;
			case TokenType::GREATER_EQUAL: bin_op = BinaryExpr::Op::GTE; break;
			default: throw CompilerException::parser_error("Invalid comparison operator", op.line, op.column);
		}

		left = std::make_unique<BinaryExpr>(std::move(left), bin_op, std::move(right));
	}

	return left;
}

ExprPtr Parser::parse_term() {
	ExprPtr left = parse_factor();

	while (match_one_of({TokenType::PLUS, TokenType::MINUS})) {
		Token op = previous();
		ExprPtr right = parse_factor();

		BinaryExpr::Op bin_op = (op.type == TokenType::PLUS) ? BinaryExpr::Op::ADD : BinaryExpr::Op::SUB;
		left = std::make_unique<BinaryExpr>(std::move(left), bin_op, std::move(right));
	}

	return left;
}

ExprPtr Parser::parse_factor() {
	ExprPtr left = parse_unary();

	while (match_one_of({TokenType::MULTIPLY, TokenType::DIVIDE, TokenType::MODULO})) {
		Token op = previous();
		ExprPtr right = parse_unary();

		BinaryExpr::Op bin_op;
		switch (op.type) {
			case TokenType::MULTIPLY: bin_op = BinaryExpr::Op::MUL; break;
			case TokenType::DIVIDE: bin_op = BinaryExpr::Op::DIV; break;
			case TokenType::MODULO: bin_op = BinaryExpr::Op::MOD; break;
			default: throw CompilerException::parser_error("Invalid factor operator", op.line, op.column);
		}

		left = std::make_unique<BinaryExpr>(std::move(left), bin_op, std::move(right));
	}

	return left;
}

ExprPtr Parser::parse_unary() {
	if (match_one_of({TokenType::MINUS, TokenType::NOT})) {
		Token op = previous();
		ExprPtr operand = parse_unary();

		UnaryExpr::Op un_op = (op.type == TokenType::MINUS) ? UnaryExpr::Op::NEG : UnaryExpr::Op::NOT;
		return std::make_unique<UnaryExpr>(un_op, std::move(operand));
	}

	return parse_call();
}

ExprPtr Parser::parse_call() {
	ExprPtr expr = parse_primary();

	while (true) {
		if (match(TokenType::LPAREN)) {
			// Function call
			std::vector<ExprPtr> arguments;

			if (!check(TokenType::RPAREN)) {
				do {
					arguments.push_back(parse_expression());
				} while (match(TokenType::COMMA));
			}

			consume(TokenType::RPAREN, "Expected ')' after arguments");

			// Check if this is a method call
			if (auto* var_expr = dynamic_cast<VariableExpr*>(expr.get())) {
				// Local function call
				std::string func_name = var_expr->name;
				expr = std::make_unique<CallExpr>(func_name, std::move(arguments));
			} else {
				error("Invalid call expression");
			}
		} else if (match(TokenType::DOT)) {
			// Member access
			Token member = consume(TokenType::IDENTIFIER, "Expected property or method name after '.'");

			if (match(TokenType::LPAREN)) {
				// Method call (including argument-less methods like obj.method())
				std::vector<ExprPtr> arguments;

				if (!check(TokenType::RPAREN)) {
					do {
						arguments.push_back(parse_expression());
					} while (match(TokenType::COMMA));
				}

				consume(TokenType::RPAREN, "Expected ')' after arguments");
				expr = std::make_unique<MemberCallExpr>(std::move(expr), member.lexeme, std::move(arguments), true);
			} else {
				// Property access (no parentheses)
				expr = std::unique_ptr<MemberCallExpr>(new MemberCallExpr(std::move(expr), member.lexeme, {}, false));
			}
		} else if (match(TokenType::LBRACKET)) {
			// Array indexing
			ExprPtr index = parse_expression();
			consume(TokenType::RBRACKET, "Expected ']' after index");
			expr = std::make_unique<IndexExpr>(std::move(expr), std::move(index));
		} else {
			break;
		}
	}

	return expr;
}

ExprPtr Parser::parse_primary() {
	if (match(TokenType::TRUE)) {
		return std::make_unique<LiteralExpr>(true);
	}
	if (match(TokenType::FALSE)) {
		return std::make_unique<LiteralExpr>(false);
	}
	if (match(TokenType::NULL_VAL)) {
		return LiteralExpr::null();
	}

	if (match(TokenType::INTEGER)) {
		Token num = previous();
		return std::make_unique<LiteralExpr>(std::get<int64_t>(num.value));
	}

	if (match(TokenType::FLOAT)) {
		Token num = previous();
		return std::make_unique<LiteralExpr>(std::get<double>(num.value));
	}

	if (match(TokenType::STRING)) {
		Token str = previous();
		return std::make_unique<LiteralExpr>(std::get<std::string>(str.value));
	}

	if (match(TokenType::IDENTIFIER)) {
		Token name = previous();
		return std::make_unique<VariableExpr>(name.lexeme);
	}

	if (match(TokenType::LPAREN)) {
		ExprPtr expr = parse_expression();
		consume(TokenType::RPAREN, "Expected ')' after expression");
		return expr;
	}

	if (match(TokenType::LBRACKET)) {
		// Array literal: [1, 2, 3]
		std::vector<ExprPtr> elements;

		if (!check(TokenType::RBRACKET)) {
			do {
				elements.push_back(parse_expression());
			} while (match(TokenType::COMMA));
		}

		consume(TokenType::RBRACKET, "Expected ']' after array elements");
		return std::make_unique<ArrayLiteralExpr>(std::move(elements));
	}

	if (match(TokenType::LBRACE)) {
		// Dictionary literal: {"key": "value", "num": 42} or {key: "value", num: 42}
		std::vector<std::pair<ExprPtr, ExprPtr>> elements;

		if (!check(TokenType::RBRACE)) {
			do {
				// Check if the key is an identifier (for shorthand {name: value} syntax)
				ExprPtr key;
				if (match(TokenType::IDENTIFIER)) {
					// Convert identifier to string literal
					Token identifier = previous();
					key = std::make_unique<LiteralExpr>(identifier.lexeme);
				} else {
					// Otherwise parse as a normal expression
					key = parse_expression();
				}

				consume(TokenType::COLON, "Expected ':' after dictionary key");
				ExprPtr value = parse_expression();
				elements.push_back({std::move(key), std::move(value)});
			} while (match(TokenType::COMMA));
		}

		consume(TokenType::RBRACE, "Expected '}' after dictionary elements");
		return std::make_unique<DictionaryLiteralExpr>(std::move(elements));
	}

	error("Expected expression");
	return nullptr;
}

bool Parser::match(TokenType type) {
	if (check(type)) {
		advance();
		return true;
	}
	return false;
}

bool Parser::match_one_of(std::initializer_list<TokenType> types) {
	for (TokenType type : types) {
		if (match(type)) {
			return true;
		}
	}
	return false;
}

bool Parser::check(TokenType type) const {
	if (is_at_end()) return false;
	return peek().type == type;
}

Token Parser::advance() {
	if (!is_at_end()) m_current++;
	return previous();
}

Token Parser::peek() const {
	return m_tokens[m_current];
}

Token Parser::previous() const {
	return m_tokens[m_current - 1];
}

bool Parser::is_at_end() const {
	return peek().type == TokenType::EOF_TOKEN;
}

Token Parser::consume(TokenType type, const std::string& message) {
	if (check(type)) return advance();

	error(message + " but got " + peek().to_string());
	return peek();
}

void Parser::synchronize() {
	advance();

	while (!is_at_end()) {
		if (previous().type == TokenType::NEWLINE) return;

		switch (peek().type) {
			case TokenType::FUNC:
			case TokenType::VAR:
			case TokenType::IF:
			case TokenType::WHILE:
			case TokenType::RETURN:
				return;
			default:
				advance();
		}
	}
}

void Parser::error(const std::string& message) {
	Token token = peek();
	throw CompilerException(ErrorType::PARSER_ERROR, message, token.line, token.column);
}

void Parser::skip_newlines() {
	while (match(TokenType::NEWLINE)) {
		// Skip
	}
}

std::string Parser::parse_type_hint() {
	// Type hints are optional and follow the pattern ": type"
	// We just consume the colon and the following identifier/type
	if (match(TokenType::COLON)) {
		// Look ahead to see if there's a type name
		// For now, we just capture whatever comes after the colon
		// This could be a simple identifier like "int" or a more complex type like "Array[int]"
		if (check(TokenType::IDENTIFIER)) {
			Token type_token = consume(TokenType::IDENTIFIER, "Expected type name");
			return type_token.lexeme;
		}
		// If there's no identifier immediately after, return empty
		// This allows for things like "var x:" which we'll just treat as no type hint
	}
	return "";
}

std::string Parser::parse_return_type() {
	// Return types are optional and follow the pattern "-> type"
	// We need to check for the arrow token (which would be MINUS + GREATER)
	// For now, let's check if we have MINUS followed by GREATER
	size_t saved_pos = m_current;

	if (match(TokenType::MINUS)) {
		if (match(TokenType::GREATER)) {
			// We found ->, now parse the type
			if (check(TokenType::IDENTIFIER)) {
				Token type_token = consume(TokenType::IDENTIFIER, "Expected return type");
				return type_token.lexeme;
			}
			return "";  // Found -> but no type
		}
		// Not a return type, rewind
		m_current = saved_pos;
	}

	return "";
}

bool Parser::parse_attribute() {
	// Parse attribute annotations like @export
	// Currently only @export is supported
	consume(TokenType::AT, "Expected '@' for attribute");

	if (match(TokenType::IDENTIFIER)) {
		Token attr_name = previous();
		if (attr_name.lexeme == "export") {
			return true; // This is an @export attribute
		} else {
			error("Unknown attribute: @" + attr_name.lexeme);
		}
	} else {
		error("Expected identifier after '@'");
	}

	return false;
}

} // namespace gdscript

```

`src/gdscript/compiler/parser.h`:

```h
#pragma once
#include "token.h"
#include "ast.h"
#include <vector>
#include <memory>

namespace gdscript {

class Parser {
public:
	explicit Parser(std::vector<Token> tokens);

	Program parse();

private:
	// Function parsing
	FunctionDecl parse_function();
	std::vector<Parameter> parse_parameters();

	// Statement parsing
	StmtPtr parse_statement();
	StmtPtr parse_var_decl(bool is_const);
	StmtPtr parse_if_stmt();
	StmtPtr parse_while_stmt();
	StmtPtr parse_for_stmt();
	StmtPtr parse_return_stmt();
	StmtPtr parse_expr_or_assign_stmt();
	std::vector<StmtPtr> parse_block();

	// Expression parsing (precedence climbing)
	ExprPtr parse_expression();
	ExprPtr parse_or_expression();
	ExprPtr parse_and_expression();
	ExprPtr parse_equality();
	ExprPtr parse_comparison();
	ExprPtr parse_term();
	ExprPtr parse_factor();
	ExprPtr parse_unary();
	ExprPtr parse_call();
	ExprPtr parse_primary();

	// Utilities
	bool match(TokenType type);
	bool match_one_of(std::initializer_list<TokenType> types);
	bool check(TokenType type) const;
	Token advance();
	Token peek() const;
	Token previous() const;
	bool is_at_end() const;
	Token consume(TokenType type, const std::string& message);
	void synchronize();
	void error(const std::string& message);
	void skip_newlines();

	// Type hint parsing
	std::string parse_type_hint();  // Parse optional type hint (e.g., ": int", ": String")
	std::string parse_return_type();  // Parse optional return type (e.g., "-> void")

	// Attribute parsing
	bool parse_attribute();  // Parse attribute (e.g., @export), returns true if @export

	std::vector<Token> m_tokens;
	size_t m_current = 0;
};

} // namespace gdscript

```

`src/gdscript/compiler/register_allocator.cpp`:

```cpp
#include "register_allocator.h"
#include <algorithm>

namespace gdscript {

RegisterAllocator::RegisterAllocator() {
	init_free_registers();
}

void RegisterAllocator::init_free_registers() {
	m_free_registers = {
		REG_T0, REG_T1, REG_T2,
		REG_S1, REG_S2, REG_S3, REG_S4, REG_S5, REG_S6, REG_S7,
		REG_S8, REG_S9, REG_S10, REG_S11,
		REG_T3, REG_T4, REG_T5, REG_T6
	};
}

void RegisterAllocator::init(const IRFunction& func) {
	m_vreg_to_preg.clear();
	m_preg_to_vreg.clear();
	m_vreg_all_uses.clear();
	init_free_registers();
	compute_next_use(func);
}

void RegisterAllocator::compute_next_use(const IRFunction& func) {
	m_vreg_all_uses.clear();
	
	for (size_t i = 0; i < func.instructions.size(); i++) {
		const IRInstruction& instr = func.instructions[i];
		int instr_idx = static_cast<int>(i);
		
		for (const IRValue& operand : instr.operands) {
			if (operand.type == IRValue::Type::REGISTER) {
				int vreg = std::get<int>(operand.value);
				m_vreg_all_uses[vreg].push_back(instr_idx);
			}
		}
	}
	
	for (std::pair<const int, std::vector<int>>& pair : m_vreg_all_uses) {
		std::sort(pair.second.begin(), pair.second.end());
		pair.second.erase(
			std::unique(pair.second.begin(), pair.second.end()),
			pair.second.end()
		);
	}
}

int RegisterAllocator::allocate_register(int vreg, int current_instr_idx) {
	std::unordered_map<int, uint8_t>::iterator it = m_vreg_to_preg.find(vreg);
	if (it != m_vreg_to_preg.end()) {
		return static_cast<int>(it->second);
	}

	// No register allocated yet, try to allocate one
	if (m_free_registers.empty()) {
		int spill_candidate = find_spill_candidate(current_instr_idx);
		if (spill_candidate != -1) {
			spill_register(spill_candidate);
		}
	}

	if (m_free_registers.empty()) {
		// No register available, vreg will need to be on stack
		return -1;
	}

	uint8_t preg = m_free_registers.back();
	m_free_registers.pop_back();
	m_vreg_to_preg[vreg] = preg;
	m_preg_to_vreg[preg] = vreg;

	return static_cast<int>(preg);
}

int RegisterAllocator::get_physical_register(int vreg) const {
	std::unordered_map<int, uint8_t>::const_iterator it = m_vreg_to_preg.find(vreg);
	if (it != m_vreg_to_preg.end()) {
		return static_cast<int>(it->second);
	}
	return -1;
}

int RegisterAllocator::get_stack_offset(int vreg) const {
	// The register allocator no longer manages stack offsets.
	// Stack slots are pre-allocated by the codegen in m_variant_offsets.
	// This function is kept for API compatibility but always returns -1.
	return -1;
}

void RegisterAllocator::spill_register(int vreg) {
	// Spill a virtual register by freeing its physical register.
	// Note: This does NOT write the value to stack. The codegen is responsible
	// for materializing values to stack before they can be spilled.
	std::unordered_map<int, uint8_t>::iterator it = m_vreg_to_preg.find(vreg);
	if (it == m_vreg_to_preg.end()) {
		return;
	}

	uint8_t preg = it->second;
	m_free_registers.push_back(preg);
	m_preg_to_vreg.erase(preg);
	m_vreg_to_preg.erase(vreg);
}

std::vector<std::pair<uint8_t, uint8_t>> RegisterAllocator::handle_syscall_clobbering(
	const std::vector<uint8_t>& clobbered_regs,
	int current_instr_idx
) {
	std::vector<std::pair<uint8_t, uint8_t>> moves;
	
	for (uint8_t clobbered_preg : clobbered_regs) {
		std::unordered_map<uint8_t, int>::iterator it = m_preg_to_vreg.find(clobbered_preg);
		if (it != m_preg_to_vreg.end()) {
			int vreg = it->second;
			
			if (!m_free_registers.empty()) {
				uint8_t new_preg = m_free_registers.back();
				m_free_registers.pop_back();
				
				m_vreg_to_preg[vreg] = new_preg;
				m_preg_to_vreg.erase(clobbered_preg);
				m_preg_to_vreg[new_preg] = vreg;
				
				moves.push_back({clobbered_preg, new_preg});
			} else {
				spill_register(vreg);
			}
		}
	}
	
	return moves;
}

void RegisterAllocator::free_register(int vreg) {
	std::unordered_map<int, uint8_t>::iterator it = m_vreg_to_preg.find(vreg);
	if (it != m_vreg_to_preg.end()) {
		uint8_t preg = it->second;
		m_free_registers.push_back(preg);
		m_preg_to_vreg.erase(preg);
		m_vreg_to_preg.erase(vreg);
	}
}

void RegisterAllocator::invalidate_register(int vreg) {
	// Same as free_register - removes the vreg->preg mapping and frees the physical register
	// This is necessary when the value is updated on the stack through variant operations,
	// to prevent stale physical register values from being used
	std::unordered_map<int, uint8_t>::iterator it = m_vreg_to_preg.find(vreg);
	if (it != m_vreg_to_preg.end()) {
		uint8_t preg = it->second;
		m_free_registers.push_back(preg);
		m_preg_to_vreg.erase(preg);
		m_vreg_to_preg.erase(vreg);
	}
}

void RegisterAllocator::force_register_mapping(int vreg, uint8_t preg) {
	// Force a virtual register to be mapped to a specific physical register
	// This is used for RELOAD instructions where we need to ensure a value is in a register

	// If preg is currently mapped to another vreg, invalidate that mapping
	std::unordered_map<uint8_t, int>::iterator it = m_preg_to_vreg.find(preg);
	if (it != m_preg_to_vreg.end() && it->second != vreg) {
		int other_vreg = it->second;
		// Remove the other vreg's mapping
		m_vreg_to_preg.erase(other_vreg);
	}

	// If vreg is currently mapped to a different preg, remove that mapping
	std::unordered_map<int, uint8_t>::iterator vreg_it = m_vreg_to_preg.find(vreg);
	if (vreg_it != m_vreg_to_preg.end() && vreg_it->second != preg) {
		uint8_t old_preg = vreg_it->second;
		m_preg_to_vreg.erase(old_preg);
		// Add the old register back to the free pool
		m_free_registers.push_back(old_preg);
	}

	// Remove preg from the free pool if it's there
	std::vector<uint8_t>::iterator free_it = std::find(m_free_registers.begin(), m_free_registers.end(), preg);
	if (free_it != m_free_registers.end()) {
		m_free_registers.erase(free_it);
	}

	// Set the new mapping
	m_vreg_to_preg[vreg] = preg;
	m_preg_to_vreg[preg] = vreg;
}

int RegisterAllocator::get_vreg_for_preg(uint8_t preg) const {
	// Get the virtual register mapped to a physical register
	std::unordered_map<uint8_t, int>::const_iterator it = m_preg_to_vreg.find(preg);
	if (it != m_preg_to_vreg.end()) {
		return it->second;
	}
	return -1;
}

bool RegisterAllocator::is_register_available(uint8_t preg) const {
	return std::find(m_free_registers.begin(), m_free_registers.end(), preg) != m_free_registers.end();
}

int RegisterAllocator::get_next_use(int vreg, int current_instr_idx) const {
	std::unordered_map<int, std::vector<int>>::const_iterator uses_it = m_vreg_all_uses.find(vreg);
	if (uses_it == m_vreg_all_uses.end()) {
		return -1;
	}
	
	const std::vector<int>& uses = uses_it->second;
	std::vector<int>::const_iterator it = std::lower_bound(uses.begin(), uses.end(), current_instr_idx + 1);
	
	if (it != uses.end()) {
		return *it;
	}
	
	return -1;
}

int RegisterAllocator::find_spill_candidate(int current_instr_idx) const {
	if (m_vreg_to_preg.empty()) {
		return -1;
	}
	
	int best_vreg = -1;
	int best_next_use = -1;
	
	for (const std::pair<const int, uint8_t>& pair : m_vreg_to_preg) {
		int vreg = pair.first;
		int next_use = get_next_use(vreg, current_instr_idx);
		
		if (next_use == -1) {
			return vreg;
		}
		
		if (next_use > best_next_use) {
			best_next_use = next_use;
			best_vreg = vreg;
		}
	}
	
	return best_vreg;
}

} // namespace gdscript


```

`src/gdscript/compiler/register_allocator.h`:

```h
#pragma once
#include "ir.h"
#include <unordered_map>
#include <vector>
#include <cstdint>

namespace gdscript {

/**
 * @brief Simple Greedy Register Allocator with Furthest Next Use heuristic
 * 
 * Maintains a pool of 18 free physical registers (t0-t6, s1-s11, excluding s0/fp)
 * and maps virtual registers to physical RISC-V registers using hash maps.
 * 
 * Algorithm:
 * - When allocating a register for a virtual register, checks if already allocated
 *   (return it), spilled to stack (load it), or new (take from free pool).
 * - If the free pool is empty, uses the "Furthest Next Use" heuristic to select
 *   a spill candidate: picks the virtual register whose next use is furthest away
 *   (or unknown/never used again).
 * - This keeps values needed soon in registers and spills values not needed soon,
 *   improving code quality with minimal complexity.
 * 
 * The allocator tracks all uses of each virtual register in sorted lists, allowing
 * efficient binary search to find the next use after any given instruction.
 * 
 * @note Spills to stack only when necessary (no free registers available)
 */
class RegisterAllocator {
public:
	/**
	 * @brief Construct a new Register Allocator
	 * 
	 * Initializes the free register pool with 18 available physical registers.
	 */
	RegisterAllocator();
	
	/**
	 * @brief Initialize for a new function
	 * 
	 * Clears all state and computes next use positions for all virtual registers
	 * in the function. Must be called before allocating registers for a function.
	 * 
	 * @param func The IR function to analyze for register allocation
	 */
	void init(const IRFunction& func);
	
	/**
	 * @brief Get physical register for virtual register
	 * 
	 * Implements the Simple Greedy algorithm:
	 * 1. If already allocated to a physical register, return it
	 * 2. If spilled to stack, load it into a register (spill another if needed)
	 * 3. If new, allocate from free pool (spill another if needed)
	 * 
	 * Uses Furthest Next Use heuristic when spilling: picks the vreg with
	 * furthest next use (or unknown/never used again) as the spill candidate.
	 * 
	 * @param vreg Virtual register number to allocate
	 * @param current_instr_idx Current instruction index (used for next use computation)
	 * @return Physical register number (0-31), or -1 if spilled to stack
	 */
	int allocate_register(int vreg, int current_instr_idx);
	
	/**
	 * @brief Get current physical register for vreg
	 * 
	 * @param vreg Virtual register number
	 * @return Physical register number (0-31), or -1 if spilled or not allocated
	 */
	int get_physical_register(int vreg) const;
	
	/**
	 * @brief Get stack offset for spilled vreg
	 * 
	 * @param vreg Virtual register number
	 * @return Stack offset in bytes, or -1 if in register or not allocated
	 */
	int get_stack_offset(int vreg) const;
	
	/**
	 * @brief Spill a virtual register to stack, freeing its physical register
	 * 
	 * Called by allocate_register() when the free pool is empty.
	 * The vreg to spill is selected by find_spill_candidate() using
	 * the Furthest Next Use heuristic.
	 * 
	 * @param vreg Virtual register to spill
	 */
	void spill_register(int vreg);
	
	/**
	 * @brief Handle syscall register clobbering
	 * 
	 * Moves live values from clobbered registers (e.g., a0-a3 for VEVAL,
	 * a0-a5 for VCALL) to other available registers. Only spills to stack
	 * if no other registers are available.
	 * 
	 * @param clobbered_regs List of physical registers that will be clobbered
	 * @param current_instr_idx Current instruction index (unused, for future use)
	 * @return List of register moves needed: (src_preg, dst_preg) pairs
	 *         The caller should emit move instructions for these pairs
	 */
	std::vector<std::pair<uint8_t, uint8_t>> handle_syscall_clobbering(
		const std::vector<uint8_t>& clobbered_regs, 
		int current_instr_idx
	);
	
	/**
	 * @brief Free a register when vreg dies
	 * 
	 * Optional optimization: can be called when a virtual register is no longer
	 * needed to free its physical register earlier. Currently not used but
	 * available for future optimizations.
	 * 
	 * @param vreg Virtual register to free
	 */
	void free_register(int vreg);

	/**
	 * @brief Invalidate physical register for a virtual register
	 *
	 * Removes the mapping from vreg to physical register and frees the physical register.
	 * This is necessary when the value is updated on the stack through variant operations,
	 * to prevent stale physical register values from being used.
	 *
	 * @param vreg Virtual register to invalidate
	 */
	void invalidate_register(int vreg);

	/**
	 * @brief Force a virtual register to be mapped to a specific physical register
	 *
	 * This is used for RELOAD instructions where we need to ensure a value is in a
	 * specific register (e.g., REG_T0) regardless of the allocator's state.
	 * This bypasses normal allocation and should only be used in special cases.
	 *
	 * @param vreg Virtual register to map
	 * @param preg Physical register to map to
	 */
	void force_register_mapping(int vreg, uint8_t preg);

	/**
	 * @brief Get the virtual register mapped to a physical register
	 *
	 * @param preg Physical register number
	 * @return Virtual register number, or -1 if not mapped
	 */
	int get_vreg_for_preg(uint8_t preg) const;

	/**
	 * @brief Check if a physical register is available
	 *
	 * @param preg Physical register number (0-31)
	 * @return true if the register is in the free pool, false otherwise
	 */
	bool is_register_available(uint8_t preg) const;
	
	/**
	 * @brief Get all available physical registers
	 * 
	 * @return Reference to the vector of free physical register numbers
	 */
	const std::vector<uint8_t>& get_available_registers() const { return m_free_registers; }
	
	/**
	 * @brief Get next use position for a vreg from current instruction
	 * 
	 * Part of the Furthest Next Use heuristic. Uses binary search on the
	 * sorted use list to efficiently find the next instruction where the
	 * virtual register is used.
	 * 
	 * @param vreg Virtual register number
	 * @param current_instr_idx Current instruction index
	 * @return Next instruction index where vreg is used, or -1 if no next use
	 *         (vreg is never used again - best candidate for spilling)
	 */
	int get_next_use(int vreg, int current_instr_idx) const;
	
	/**
	 * @brief Compute next use positions for all vregs in function
	 * 
	 * Scans all instructions to collect all uses of each virtual register,
	 * then sorts the use lists for efficient binary search. This builds
	 * m_vreg_all_uses which is used by get_next_use() to find the next
	 * use after any given instruction.
	 * 
	 * @param func The IR function to analyze
	 */
	void compute_next_use(const IRFunction& func);

private:
	/**
	 * @brief Available physical registers (t0-t6, s1-s11, excluding s0/fp)
	 * 
	 * Total: 18 registers available for allocation
	 * Note: REG_S0 (x8) is excluded as it's used as frame pointer
	 */
	static constexpr uint8_t REG_T0 = 5;
	static constexpr uint8_t REG_T1 = 6;
	static constexpr uint8_t REG_T2 = 7;
	static constexpr uint8_t REG_S0 = 8;  // x8 (fp) - excluded, used as frame pointer
	static constexpr uint8_t REG_S1 = 9;
	static constexpr uint8_t REG_S2 = 18;
	static constexpr uint8_t REG_S3 = 19;
	static constexpr uint8_t REG_S4 = 20;
	static constexpr uint8_t REG_S5 = 21;
	static constexpr uint8_t REG_S6 = 22;
	static constexpr uint8_t REG_S7 = 23;
	static constexpr uint8_t REG_S8 = 24;
	static constexpr uint8_t REG_S9 = 25;
	static constexpr uint8_t REG_S10 = 26;
	static constexpr uint8_t REG_S11 = 27;
	static constexpr uint8_t REG_T3 = 28;
	static constexpr uint8_t REG_T4 = 29;
	static constexpr uint8_t REG_T5 = 30;
	static constexpr uint8_t REG_T6 = 31;
	
	/**
	 * @brief Maps virtual register â†’ physical register
	 *
	 * Tracks which physical register each virtual register is currently in.
	 */
	std::unordered_map<int, uint8_t> m_vreg_to_preg;

	/**
	 * @brief Reverse map: physical register â†’ virtual register
	 *
	 * Allows quick lookup of which virtual register is in a given physical register.
	 */
	std::unordered_map<uint8_t, int> m_preg_to_vreg;

	/**
	 * @brief Available physical registers (free pool)
	 *
	 * Vector of physical register numbers that are currently free and available
	 * for allocation. Initially contains 18 registers (t0-t6, s1-s11).
	 */
	std::vector<uint8_t> m_free_registers;

	/**
	 * @brief All uses of each virtual register (for computing next use dynamically)
	 *
	 * Maps vreg â†’ sorted list of instruction indices where it's used.
	 * Used by get_next_use() to efficiently find the next use after a given
	 * instruction using binary search.
	 */
	std::unordered_map<int, std::vector<int>> m_vreg_all_uses;
	
	/**
	 * @brief Size of Variant struct in bytes
	 * 
	 * Used to calculate stack offsets when spilling registers.
	 */
	static constexpr int VARIANT_SIZE = 24;
	
	/**
	 * @brief Find spill candidate register using Furthest Next Use heuristic
	 * 
	 * Selects the virtual register with the furthest next use (or unknown/never
	 * used again) from the current instruction. This is the core of the
	 * "Furthest Next Use" improvement over simple "first allocated = first spilled".
	 * 
	 * @param current_instr_idx Current instruction index
	 * @return Virtual register number to spill, or -1 if no registers allocated
	 */
	int find_spill_candidate(int current_instr_idx) const;
	
	/**
	 * @brief Initialize free register pool
	 * 
	 * Populates m_free_registers with the 18 available physical registers
	 * (t0-t6, s1-s11, excluding s0/fp).
	 */
	void init_free_registers();
};

} // namespace gdscript


```

`src/gdscript/compiler/riscv_codegen.cpp`:

```cpp
#include "riscv_codegen.h"
#include "compiler_exception.h"
#include "variant_types.h"
#include <stdexcept>
#include <cstring>

namespace gdscript {

RISCVCodeGen::RISCVCodeGen() {}

size_t RISCVCodeGen::add_constant(int64_t value) {
	// Check if constant already exists in pool
	auto it = m_constant_pool_map.find(value);
	if (it != m_constant_pool_map.end()) {
		return it->second;
	}

	// Add new constant
	size_t index = m_constant_pool.size();
	m_constant_pool.push_back(value);
	m_constant_pool_map[value] = index;
	return index;
}

std::string RISCVCodeGen::gen_local_label(const std::string& prefix) {
	return prefix + std::to_string(m_label_counter++);
}

void RISCVCodeGen::emit_variant_component_to_float(int comp_offset, int result_offset, int store_offset, bool normalize_by_255) {
	// Convert a Variant component (at comp_offset) to float and store to result_offset + store_offset
	// Handles both INT (type=2) and FLOAT (type=3) Variants
	// If normalize_by_255 is true, divides INTEGER values by 255.0 (for Color components)
	std::string label_float = gen_local_label(".float");
	std::string label_cont = gen_local_label(".cont");

	// Load the component's type field
	emit_lwu(REG_T0, REG_SP, comp_offset); // Load type (4 bytes, zero-extended)

	// Check if type is INT (2) or FLOAT (3)
	// Branch if INT (subtract 2, so 0 means INT, non-zero means FLOAT)
	emit_addi(REG_T1, REG_T0, -2);
	mark_label_use(label_float, m_code.size());
	emit_bne(REG_T1, REG_ZERO, 0); // Branch if not INT (i.e., if FLOAT)

	// INT case: Load integer and convert to float
	emit_ld(REG_T0, REG_SP, comp_offset + 8); // Load int64_t
	emit_fcvt_d_l(REG_FA0, REG_T0); // Convert int64 to double

	if (normalize_by_255) {
		// For Color, normalize integer values by dividing by 255.0
		// Load 255.0 from constant pool
		size_t const_idx = add_constant(0x406FC00000000000LL); // 255.0 as double
		std::string label_255 = ".LC" + std::to_string(const_idx);
		emit_la(REG_T0, label_255);
		emit_fld(REG_FA1, REG_T0, 0); // Load 255.0 into FA1
		emit_fdiv_d(REG_FA0, REG_FA0, REG_FA1); // Divide by 255.0
	}

	emit_fcvt_s_d(REG_FA0, REG_FA0); // Convert double to float
	mark_label_use(label_cont, m_code.size());
	emit_jal(REG_ZERO, 0); // Skip to end

	// FLOAT case: Load double and convert to float
	define_label(label_float);
	emit_fld(REG_FA0, REG_SP, comp_offset + 8); // Load double
	// Note: We do NOT normalize float values - they're already in the correct range
	emit_fcvt_s_d(REG_FA0, REG_FA0); // Convert double to float
	define_label(label_cont);

	emit_fsw(REG_FA0, REG_SP, result_offset + store_offset); // Store float
}

std::vector<uint8_t> RISCVCodeGen::generate(const IRProgram& program) {
	m_code.clear();
	m_labels.clear();
	m_label_uses.clear();
	m_functions.clear();
	m_variant_offsets.clear();
	m_constant_pool.clear();
	m_constant_pool_map.clear();
	m_string_constants = &program.string_constants;

	// Entry point: Initialize global variables, then STOP
	// Store globals info early so we can reference it during init
	m_global_count = program.globals.size();
	m_globals = program.globals;

	// Generate initialization code for globals at entry point
	// We'll calculate the .globals virtual address when we define it later
	// For now, emit placeholder that will be resolved during label resolution
	for (size_t i = 0; i < program.globals.size(); i++) {
		const auto& global = program.globals[i];

		// Only initialize globals with explicit initial values (skip NONE)
		if (global.init_type == IRGlobalVar::InitType::NONE) {
			continue;
		}

		// Load address of global variable into t0
		// Address = .globals + (i * 24)
		emit_la(REG_T0, ".globals");
		if (i > 0) {
			int offset = i * VARIANT_SIZE;
			emit_addi(REG_T0, REG_T0, offset);
		}

		// Initialize based on type
		if (global.init_type == IRGlobalVar::InitType::INT) {
			// Write type field: m_type = 2 (INT)
			emit_li(REG_T1, Variant::INT);
			emit_sw(REG_T1, REG_T0, 0);

			// Write value: v.i at offset 8
			int64_t value = std::get<int64_t>(global.init_value);
			emit_li(REG_T1, value);
			emit_sd(REG_T1, REG_T0, 8);
		} else if (global.init_type == IRGlobalVar::InitType::FLOAT) {
			// Write type field: m_type = 3 (FLOAT)
			emit_li(REG_T1, Variant::FLOAT);
			emit_sw(REG_T1, REG_T0, 0);

			// Write value: v.f (64-bit double) at offset 8
			double value = std::get<double>(global.init_value);
			int64_t bits;
			memcpy(&bits, &value, sizeof(double));
			emit_li(REG_T1, bits);
			emit_sd(REG_T1, REG_T0, 8);
		} else if (global.init_type == IRGlobalVar::InitType::BOOL) {
			// Write type field: m_type = 1 (BOOL)
			emit_li(REG_T1, Variant::BOOL);
			emit_sw(REG_T1, REG_T0, 0);

			// Write value: v.b at offset 8
			bool value = std::get<bool>(global.init_value);
			emit_li(REG_T1, value ? 1 : 0);
			emit_sd(REG_T1, REG_T0, 8);
		} else if (global.init_type == IRGlobalVar::InitType::STRING) {
			// String initialization using VCREATE
			std::string str_value = std::get<std::string>(global.init_value);
			int str_len = static_cast<int>(str_value.length());

			// Allocate stack space for: string data + struct { char*, size_t }
			int str_space = ((str_len + 1) + 7) & ~7; // String + null terminator, aligned to 8 bytes
			int struct_space = 16; // Two 8-byte fields
			int total_space = str_space + struct_space;
			total_space = (total_space + 15) & ~15; // Align to 16 bytes

			// Adjust stack pointer
			if (total_space < 2048) {
				emit_i_type(0x13, REG_SP, 0, REG_SP, -total_space);
			} else {
				emit_li(REG_T2, -total_space);
				emit_add(REG_SP, REG_SP, REG_T2);
			}

			// Store string data on stack
			for (size_t j = 0; j < str_value.length(); j++) {
				emit_li(REG_T2, static_cast<unsigned char>(str_value[j]));
				emit_sb(REG_T2, REG_SP, j);
			}
			// Store null terminator
			emit_sb(REG_ZERO, REG_SP, str_len);

			// Create struct at sp + str_space
			// struct.str = sp (pointer to string data)
			if (str_space < 2048) {
				emit_i_type(0x13, REG_T2, 0, REG_SP, 0); // T2 = SP + 0 (pointer to string)
			} else {
				emit_mv(REG_T2, REG_SP);
			}
			emit_sd(REG_T2, REG_SP, str_space); // Store pointer

			// struct.length = str_len
			emit_li(REG_T2, str_len);
			emit_sd(REG_T2, REG_SP, str_space + 8); // Store length

			// Prepare data pointer in T1 for VCREATE
			if (str_space < 2048) {
				emit_i_type(0x13, REG_T1, 0, REG_SP, str_space);
			} else {
				emit_li(REG_T1, str_space);
				emit_add(REG_T1, REG_SP, REG_T1);
			}

			// Calculate the offset to the global Variant after stack adjustment
			// T0 still points to the global Variant (loaded with la before stack adjustment)
			// We need the offset from current SP to pass to emit_vcreate_syscall
			// Since T0 is an absolute address, we can't use it directly with emit_vcreate_syscall
			// We need to use VCREATE directly here

			// a0 = T0 (pointer to destination Variant - already calculated)
			emit_mv(REG_A0, REG_T0);

			// a1 = Variant::STRING
			emit_li(REG_A1, Variant::STRING);

			// a2 = method (1 for const char* + size_t)
			emit_li(REG_A2, 1);

			// a3 = pointer to struct (T1)
			emit_mv(REG_A3, REG_T1);

			// a7 = ECALL_VCREATE (517)
			emit_li(REG_A7, 517);
			emit_ecall();

			// Restore stack pointer
			if (total_space < 2048) {
				emit_i_type(0x13, REG_SP, 0, REG_SP, total_space);
			} else {
				emit_li(REG_T2, total_space);
				emit_add(REG_SP, REG_SP, REG_T2);
			}
		} else if (global.init_type == IRGlobalVar::InitType::EMPTY_ARRAY) {
			// Empty Array initialization using VCREATE
			// a0 = pointer to destination Variant (T0 already points to it)
			emit_mv(REG_A0, REG_T0);

			// a1 = Variant::ARRAY
			emit_li(REG_A1, Variant::ARRAY);

			// a2 = method (0 for empty)
			emit_li(REG_A2, 0);

			// a3 = nullptr (0)
			emit_li(REG_A3, 0);

			// a7 = ECALL_VCREATE (517)
			emit_li(REG_A7, 517);
			emit_ecall();
		} else if (global.init_type == IRGlobalVar::InitType::EMPTY_DICT) {
			// Empty Dictionary initialization using VCREATE
			// a0 = pointer to destination Variant (T0 already points to it)
			emit_mv(REG_A0, REG_T0);

			// a1 = Variant::DICTIONARY
			emit_li(REG_A1, Variant::DICTIONARY);

			// a2 = method (0 for empty)
			emit_li(REG_A2, 0);

			// a3 = nullptr (0)
			emit_li(REG_A3, 0);

			// a7 = ECALL_VCREATE (517)
			emit_li(REG_A7, 517);
			emit_ecall();
		} else if (global.init_type == IRGlobalVar::InitType::NULL_VAL) {
			// Write type field: m_type = 0 (NIL)
			emit_li(REG_T1, Variant::NIL);
			emit_sw(REG_T1, REG_T0, 0);
		} else {
			// Unknown initialization type
			throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Global variable '" + global.name + "': Unknown initialization type.");
		}

		// If this is a property (@export), register it using ECALL_SANDBOX_ADD
		if (global.is_property) {
			// ECALL_SANDBOX_ADD (547)
			// A0 = 0 (add property)
			// A1 = name pointer
			// A2 = name length
			// A3 = Variant type
			// A4 = 0
			// A5 = 0
			// A6 = Variant pointer (T0 still has the address)

			// Store the property name for later emission into the code section
			const std::string name_label = ".LPROP" + std::to_string(i);
			m_property_name_strings.push_back({global.name, name_label});

			// A0 = 0 (add property)
			emit_li(REG_A0, 0);

			// A1 = pointer to variable name string
			emit_la(REG_A1, name_label);

			// A2 = name length
			emit_li(REG_A2, static_cast<int64_t>(global.name.length()));

			// A3 = Variant type (from type hint or init type)
			int32_t variant_type = Variant::NIL;
			if (global.type_hint != IRInstruction::TypeHint_NONE) {
				variant_type = global.type_hint;
			} else {
				// Derive type from init_type
				switch (global.init_type) {
					case IRGlobalVar::InitType::INT: variant_type = Variant::INT; break;
					case IRGlobalVar::InitType::FLOAT: variant_type = Variant::FLOAT; break;
					case IRGlobalVar::InitType::BOOL: variant_type = Variant::BOOL; break;
					case IRGlobalVar::InitType::STRING: variant_type = Variant::STRING; break;
					case IRGlobalVar::InitType::EMPTY_ARRAY: variant_type = Variant::ARRAY; break;
					case IRGlobalVar::InitType::EMPTY_DICT: variant_type = Variant::DICTIONARY; break;
					default: throw CompilerException(ErrorType::RISCV_codegen_ERROR,
						"Global variable '" + global.name + "': Could not derive Variant type from initializer.");
				}
			}
			emit_li(REG_A3, variant_type);
			emit_li(REG_A4, 0); // A4 = 0
			emit_li(REG_A5, 0); // A5 = 0
			// A6 = Variant pointer (T0 still has the address)
			emit_mv(REG_A6, REG_T0);

			// A7 = ECALL_SANDBOX_ADD (547)
			emit_li(REG_A7, 547);

			// Make the syscall
			emit_ecall();
		}
	}

	// Emit STOP instruction after initialization
	// STOP is encoded as: SYSTEM instruction (I-type) with imm[11:0] = 0x7ff
	// SYSTEM opcode = 0x73, funct3 = 0, rs1 = 0, rd = 0, imm = 0x7ff
	emit_i_type(0x73, 0, 0, 0, 0x7ff);

	// Generate code for each function
	for (const auto& func : program.functions) {
		m_functions[func.name] = m_code.size();
		// Also register function name as a label for CALL instructions
		m_labels[func.name] = m_code.size();
		gen_function(func);
	}

	// Define constant pool labels at the end of code
	// Constants are appended after the code section
	size_t const_pool_base = m_code.size();
	for (size_t i = 0; i < m_constant_pool.size(); i++) {
		std::string label = ".LC" + std::to_string(i);
		m_labels[label] = const_pool_base + (i * 8);
	}

	// Append constant pool data to code
	for (int64_t constant : m_constant_pool) {
		for (int i = 0; i < 8; i++) {
			m_code.push_back(static_cast<uint8_t>((constant >> (i * 8)) & 0xFF));
		}
	}

	// Emit property name strings for @export globals
	for (const auto& [str, label] : m_property_name_strings) {
		// Align to 1-byte (strings are byte sequences)
		m_labels[label] = m_code.size();

		// Emit string bytes
		for (char c : str) {
			m_code.push_back(static_cast<uint8_t>(c));
		}

		// Null terminator
		m_code.push_back(0);
	}

	// Calculate global data size (m_global_count and m_globals already set earlier)
	m_global_data_size = m_global_count * VARIANT_SIZE;

	// Define .globals label and allocate global data area
	// This will be placed in a separate R+W PT_LOAD segment by the ELF builder
	if (m_global_count > 0) {
		// Align to 8-byte boundary for proper Variant alignment
		while (m_code.size() % 8 != 0) {
			m_code.push_back(0);
		}

		// Calculate the virtual address for the .data segment
		// The .data segment will be loaded at: BASE_ADDR + text_size, aligned to 4KB
		size_t text_size = m_code.size();  // Current code size (before globals)
		size_t globals_vaddr = 0x10000 + text_size;
		globals_vaddr = (globals_vaddr + 0xFFF) & ~0xFFF;  // Align to 4KB page

		// For label resolution, we need to store this as if it were a code offset
		// Since BASE_ADDR (0x10000) is added during resolution, we store: vaddr - BASE_ADDR
		m_labels[".globals"] = globals_vaddr - 0x10000;

		// Allocate and initialize global variables to zero (NIL Variants)
		// Each Variant is 24 bytes: [type:4][padding:4][data:16]
		for (size_t i = 0; i < m_global_count; i++) {
			// Write NIL Variant (type = 0, all other bytes = 0)
			for (int j = 0; j < VARIANT_SIZE; j++) {
				m_code.push_back(0);
			}
		}
	}

	// Resolve all label references
	resolve_labels();

	return m_code;
}

void RISCVCodeGen::gen_function(const IRFunction& func) {
	// Godot Sandbox calling convention with Variants:
	// a0 = pointer to return Variant (pre-allocated by caller)
	// a1-a7 = pointers to argument Variants
	m_variant_offsets.clear();
	m_num_params = func.parameters.size();
	m_next_variant_slot = 0;
	m_stack_frame_size = 0;
	m_current_instr_idx = 0;

	// Initialize register allocator
	m_allocator.init(func);

	// Calculate stack frame size
	// Need space for: saved registers (24 bytes) + space for Variants
	int saved_reg_space = 24; // Save ra, fp, and a0 (return pointer)

	// Pre-allocate stack offsets for ALL virtual registers in order
	// Assign offsets deterministically based on virtual register number,
	// not based on the order instructions are visited.
	// Otherwise, optimizations that reorder or eliminate instructions will
	// cause different virtual registers to get different offsets, breaking the code.
	int max_variants = func.max_registers;
	int variant_space = max_variants * VARIANT_SIZE;

	// Pre-assign all virtual register offsets
	for (int vreg = 0; vreg < max_variants; vreg++) {
		int offset = saved_reg_space + (vreg * VARIANT_SIZE);
		m_variant_offsets[vreg] = offset;
	}
	m_next_variant_slot = max_variants;

	m_stack_frame_size = saved_reg_space + variant_space;

	// Align to 16 bytes (RISC-V ABI requirement)
	m_stack_frame_size = (m_stack_frame_size + 15) & ~15;

	// Function prologue - allocate stack frame
	// addi sp, sp, -frame_size
	if (m_stack_frame_size > 0) {
		if (m_stack_frame_size < 2048) {
			emit_i_type(0x13, REG_SP, 0, REG_SP, -m_stack_frame_size);
		} else {
			emit_li(REG_T0, -m_stack_frame_size);
			emit_add(REG_SP, REG_SP, REG_T0);
		}
	}

	// Save return address: sd ra, 0(sp)
	emit_sd(REG_RA, REG_SP, 0); // SD

	// Save frame pointer: sd fp, 8(sp)
	emit_sd(REG_FP, REG_SP, 8); // SD

	// Save a0 (return Variant pointer): sd a0, 16(sp)
	emit_sd(REG_A0, REG_SP, 16); // SD

	// Set frame pointer: addi fp, sp, frame_size
	if (m_stack_frame_size < 2048) {
		emit_i_type(0x13, REG_FP, 0, REG_SP, m_stack_frame_size);
	} else {
		emit_li(REG_T0, m_stack_frame_size);
		emit_add(REG_FP, REG_SP, REG_T0);
	}

	// Copy parameter Variants from argument registers to stack
	// Parameters come in a1-a7 as POINTERS to Variants
	for (size_t i = 0; i < m_num_params && i < 7; i++) {
		int param_vreg = static_cast<int>(i); // Parameters map to virtual registers 0-6
		int dst_offset = get_variant_stack_offset(param_vreg);
		uint8_t arg_reg = REG_A1 + static_cast<uint8_t>(i);

		// Copy 24 bytes from pointer in arg_reg to stack
		for (int j = 0; j < 3; j++) {
			emit_ld(REG_T0, arg_reg, j * 8); // LD t0, j*8(arg_reg)
			emit_sd(REG_T0, REG_SP, dst_offset + j * 8); // SD t0, offset(sp)
		}
	}

	// Process each IR instruction
	for (const auto& instr : func.instructions) {
		m_current_instr_idx++;

		switch (instr.opcode) {
			case IROpcode::LABEL:
				define_label(std::get<std::string>(instr.operands[0].value));
				break;

			case IROpcode::LOAD_IMM: {
				int vreg = std::get<int>(instr.operands[0].value);
				int64_t value = std::get<int64_t>(instr.operands[1].value);
				int stack_offset = get_variant_stack_offset(vreg);
				emit_variant_create_int(stack_offset, value);
				break;
			}

			case IROpcode::LOAD_FLOAT_IMM: {
				int vreg = std::get<int>(instr.operands[0].value);
				double value = std::get<double>(instr.operands[1].value);

				// Convert double to bit pattern for storage
				int64_t bits;
				memcpy(&bits, &value, sizeof(double));

				int stack_offset = get_variant_stack_offset(vreg);

				// Create float Variant on stack
				emit_li(REG_T0, 3); // FLOAT type
				emit_sw(REG_T0, REG_SP, stack_offset);
				emit_li(REG_T0, bits);
				emit_sd(REG_T0, REG_SP, stack_offset + 8);
				break;
			}

			case IROpcode::LOAD_BOOL: {
				int vreg = std::get<int>(instr.operands[0].value);
				int64_t value = std::get<int64_t>(instr.operands[1].value);
				int stack_offset = get_variant_stack_offset(vreg);
				emit_variant_create_bool(stack_offset, value != 0);
				break;
			}

			case IROpcode::LOAD_STRING: {
				int vreg = std::get<int>(instr.operands[0].value);
				int64_t string_idx = std::get<int64_t>(instr.operands[1].value);
				int stack_offset = get_variant_stack_offset(vreg);
				emit_variant_create_string(stack_offset, static_cast<int>(string_idx));
				break;
			}

			case IROpcode::MOVE: {
				int dst_vreg = std::get<int>(instr.operands[0].value);
				int src_vreg = std::get<int>(instr.operands[1].value);

				// Skip no-op moves
				if (dst_vreg == src_vreg) {
					break;
				}

				int dst_offset = get_variant_stack_offset(dst_vreg);
				int src_offset = get_variant_stack_offset(src_vreg);

				// Skip if source and destination are at same stack location
				if (dst_offset == src_offset) {
					break;
				}

				// Copy Variant (24 bytes)
				emit_variant_copy(dst_offset, src_offset);
				break;
			}

			case IROpcode::LOAD_GLOBAL: {
				// LOAD_GLOBAL dst_reg, global_index
				// Loads a global variable (Variant) from the global data area into a virtual register
				int dst_vreg = std::get<int>(instr.operands[0].value);
				int64_t global_idx = std::get<int64_t>(instr.operands[1].value);
				int dst_offset = get_variant_stack_offset(dst_vreg);

				// Load address of global variable: gp + (global_idx * 24)
				// GP register points to the start of global data area
				int global_offset = global_idx * VARIANT_SIZE;

				// Load global base address into t0
				// For now, we'll use a label to mark the global data section
				std::string global_label = ".globals";
				emit_la(REG_T0, global_label);

				// Add offset for specific global
				if (global_offset > 0) {
					emit_addi(REG_T0, REG_T0, global_offset);
				}

				// Load destination address into t1
				emit_load_stack_offset(REG_T1, dst_offset);

				// Copy 24 bytes (3 8-byte loads/stores) from global to stack
				for (int i = 0; i < 3; i++) {
					emit_ld(REG_T2, REG_T0, i * 8);
					emit_sd(REG_T2, REG_T1, i * 8);
				}
				break;
			}

			case IROpcode::STORE_GLOBAL: {
				// STORE_GLOBAL global_index, src_reg
				// Stores a virtual register (Variant) into a global variable
				int64_t global_idx = std::get<int64_t>(instr.operands[0].value);
				int src_vreg = std::get<int>(instr.operands[1].value);
				int src_offset = get_variant_stack_offset(src_vreg);

				// Get the global's type information
				const IRGlobalVar& global = m_globals[global_idx];

				// Determine if this is a complex type that needs VASSIGN
				// Complex types: STRING, STRING_NAME, NODE_PATH, RID, OBJECT, CALLABLE,
				//                SIGNAL, DICTIONARY, ARRAY, and all PACKED_*_ARRAY types
				bool needs_vassign = false;

				if (global.type_hint != IRInstruction::TypeHint_NONE) {
					// Use type hint if available
					int32_t type = global.type_hint;
					needs_vassign = (type == 3) || (type >= 17); // STRING or complex types
				} else if (global.init_type == IRGlobalVar::InitType::STRING ||
						   global.init_type == IRGlobalVar::InitType::EMPTY_ARRAY ||
						   global.init_type == IRGlobalVar::InitType::EMPTY_DICT) {
					// Infer from initialization type
					needs_vassign = true;
				} else {
					// Fallback: Assume simple type (INT, FLOAT, BOOL, NIL)
					/// XXX: Throw error or warning here?
				}

				// Load address of global variable
				int global_offset = global_idx * VARIANT_SIZE;
				std::string global_label = ".globals";
				emit_la(REG_T0, global_label);
				if (global_offset > 0) {
					emit_addi(REG_T0, REG_T0, global_offset);
				}

				// Load source address
				emit_load_stack_offset(REG_T1, src_offset);

				if (needs_vassign) {
					// Complex type: Use VASSIGN to handle permanent indices
					// VASSIGN takes: a0 = dest_index, a1 = src_index
					// Returns: a0 = resulting index
					std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A7};
					auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

					for (const auto& move : moves) {
						emit_mv(move.second, move.first);
					}

					// Load indices (v.i at offset 8)
					emit_lw(REG_A0, REG_T0, 8); // dest index
					emit_lw(REG_A1, REG_T1, 8); // src index

					// Call VASSIGN (syscall 503)
					emit_li(REG_A7, 503);
					emit_ecall();

					// VASSIGN returns the new index in A0
					// Store it back to the global's v.i field (offset 8)
					emit_sd(REG_A0, REG_T0, 8);
				} else {
					// Simple type: Just copy 24 bytes
					for (int i = 0; i < 3; i++) {
						emit_ld(REG_T2, REG_T1, i * 8);
						emit_sd(REG_T2, REG_T0, i * 8);
					}
				}
				break;
			}


			case IROpcode::ADD:
			case IROpcode::SUB:
			case IROpcode::MUL:
			case IROpcode::DIV:
			case IROpcode::MOD: {
				// Check that all operands are valid before processing
				if (instr.operands.size() < 3 ||
					instr.operands[0].type != IRValue::Type::REGISTER) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Arithmetic operations require at least 3 operands with first being REGISTER");
				}

				int dst_vreg = std::get<int>(instr.operands[0].value);
				int dst_offset = get_variant_stack_offset(dst_vreg);

				// Check if operands are registers
				bool lhs_is_reg = instr.operands[1].type == IRValue::Type::REGISTER;
				bool rhs_is_reg = instr.operands.size() > 2 && instr.operands[2].type == IRValue::Type::REGISTER;

				// Use optimized typed path if:
				// 1. Instruction has a type hint (INT, FLOAT, or vector type)
				// 2. Both operands are registers (not immediates)
				// This is the common case for type-hinted arithmetic
				//
				// IMPORTANT: We ONLY optimize Variants with type hints.
				// Untyped Variants fall back to VEVAL syscall, which also acts as
				// deoptimization to find bugs (unknown types are unpredictable).
				if (instr.type_hint != IRInstruction::TypeHint_NONE && lhs_is_reg && rhs_is_reg) {
					int lhs_vreg_local = std::get<int>(instr.operands[1].value);
					int rhs_vreg_local = std::get<int>(instr.operands[2].value);
					int lhs_offset = get_variant_stack_offset(lhs_vreg_local);
					int rhs_offset = get_variant_stack_offset(rhs_vreg_local);

					// Dispatch based on type hint
					if (instr.type_hint == Variant::INT) {
						// Scalar int: optimized 64-bit integer arithmetic
						emit_typed_int_binary_op(dst_offset, lhs_offset, rhs_offset, instr.opcode);
						break;
					} else if (instr.type_hint == Variant::FLOAT) {
						// Scalar float: optimized 64-bit double arithmetic
						emit_typed_float_binary_op(dst_offset, lhs_offset, rhs_offset, instr.opcode);
						break;
					} else if (TypeHintUtils::is_vector(instr.type_hint)) {
						// Vector types: element-wise arithmetic (2, 3, or 4 components)
						emit_typed_vector_binary_op(dst_offset, lhs_offset, rhs_offset, instr.opcode, instr.type_hint);
						break;
					}
					// Other type hints (if any) fall through to VEVAL
				}

				// Fall back to generic Variant evaluation for:
				// - Untyped operations (no type hint)
				// - Unsupported type hints
				// - Operations with immediate operands (handled via temporary Variants)

				// Map IR opcode to Variant::Operator
				int variant_op;
				switch (instr.opcode) {
					case IROpcode::ADD: variant_op = 6; break;  // OP_ADD
					case IROpcode::SUB: variant_op = 7; break;  // OP_SUBTRACT
					case IROpcode::MUL: variant_op = 8; break;  // OP_MULTIPLY
					case IROpcode::DIV: variant_op = 9; break;  // OP_DIVIDE
					case IROpcode::MOD: variant_op = 12; break; // OP_MODULE
					default: variant_op = 6; break;
				}

				if (lhs_is_reg && rhs_is_reg) {
					int lhs_vreg_local = std::get<int>(instr.operands[1].value);
					int rhs_vreg_local = std::get<int>(instr.operands[2].value);
					int lhs_offset = get_variant_stack_offset(lhs_vreg_local);
					int rhs_offset = get_variant_stack_offset(rhs_vreg_local);
					emit_variant_eval(dst_offset, lhs_offset, rhs_offset, variant_op);
				} else if (lhs_is_reg && !rhs_is_reg && instr.operands[2].type == IRValue::Type::IMMEDIATE) {
					// Left operand is register, right is immediate
					int lhs_vreg_local = std::get<int>(instr.operands[1].value);
					int64_t imm_val = std::get<int64_t>(instr.operands[2].value);
					int lhs_offset = get_variant_stack_offset(lhs_vreg_local);

					// Create a temporary Variant for the immediate value
					int imm_vreg = m_next_variant_slot++;
					int imm_offset = get_variant_stack_offset(imm_vreg);
					emit_variant_create_int(imm_offset, static_cast<int>(imm_val));
					emit_variant_eval(dst_offset, lhs_offset, imm_offset, variant_op);
				} else if (!lhs_is_reg && rhs_is_reg && instr.operands[1].type == IRValue::Type::IMMEDIATE) {
					// Left operand is immediate, right is register
					int64_t imm_val = std::get<int64_t>(instr.operands[1].value);
					int rhs_vreg_local = std::get<int>(instr.operands[2].value);
					int rhs_offset = get_variant_stack_offset(rhs_vreg_local);

					// Create a temporary Variant for the immediate value
					int imm_vreg = m_next_variant_slot++;
					int imm_offset = get_variant_stack_offset(imm_vreg);
					emit_variant_create_int(imm_offset, static_cast<int>(imm_val));
					emit_variant_eval(dst_offset, imm_offset, rhs_offset, variant_op);
				} else {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported operand types for arithmetic operation");
				}
				break;
			}

			case IROpcode::NEG: {
				int dst_vreg = std::get<int>(instr.operands[0].value);
				int src_vreg = std::get<int>(instr.operands[1].value);

				int dst_offset = get_variant_stack_offset(dst_vreg);
				int src_offset = get_variant_stack_offset(src_vreg);

				// Use OP_NEGATE (unary operation - use veval with same operand twice)
				// Actually for unary, we need a different approach - create a zero Variant
				// For now, use subtract: 0 - src
				// TODO: Add proper unary operation support
				int zero_vreg = m_next_variant_slot++;
				int zero_offset = get_variant_stack_offset(zero_vreg);
				emit_variant_create_int(zero_offset, 0);
				emit_variant_eval(dst_offset, zero_offset, src_offset, 7); // OP_SUBTRACT
				break;
			}

			case IROpcode::CMP_EQ:
			case IROpcode::CMP_NEQ:
			case IROpcode::CMP_LT:
			case IROpcode::CMP_LTE:
			case IROpcode::CMP_GT:
			case IROpcode::CMP_GTE: {
				// Check that all operands are valid
				if (instr.operands.size() < 3 ||
					instr.operands[0].type != IRValue::Type::REGISTER) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Comparison operations require at least 3 operands with first being REGISTER");
				}

				int dst_vreg = std::get<int>(instr.operands[0].value);
				int dst_offset = get_variant_stack_offset(dst_vreg);

				// Check if operands are registers
				bool lhs_is_reg = instr.operands[1].type == IRValue::Type::REGISTER;
				bool rhs_is_reg = instr.operands.size() > 2 && instr.operands[2].type == IRValue::Type::REGISTER;

				// Use optimized typed path for INT comparisons with register operands
				// This is very common in loops: for i: int in range(N)
				if (instr.type_hint == Variant::INT && lhs_is_reg && rhs_is_reg) {
					int lhs_vreg = std::get<int>(instr.operands[1].value);
					int rhs_vreg = std::get<int>(instr.operands[2].value);
					int lhs_offset = get_variant_stack_offset(lhs_vreg);
					int rhs_offset = get_variant_stack_offset(rhs_vreg);

					// Use native RISC-V comparison instead of syscall
					emit_typed_int_comparison(dst_offset, lhs_offset, rhs_offset, instr.opcode);
					break;
				}

				// Fall back to generic Variant evaluation for untyped or non-INT comparisons

				// Map IR opcode to Variant::Operator
				int variant_op;
				switch (instr.opcode) {
					case IROpcode::CMP_EQ:  variant_op = 0; break; // OP_EQUAL
					case IROpcode::CMP_NEQ: variant_op = 1; break; // OP_NOT_EQUAL
					case IROpcode::CMP_LT:  variant_op = 2; break; // OP_LESS
					case IROpcode::CMP_LTE: variant_op = 3; break; // OP_LESS_EQUAL
					case IROpcode::CMP_GT:  variant_op = 4; break; // OP_GREATER
					case IROpcode::CMP_GTE: variant_op = 5; break; // OP_GREATER_EQUAL
					default: variant_op = 0; break;
				}

				if (lhs_is_reg && rhs_is_reg) {
					int lhs_vreg = std::get<int>(instr.operands[1].value);
					int rhs_vreg = std::get<int>(instr.operands[2].value);
					int lhs_offset = get_variant_stack_offset(lhs_vreg);
					int rhs_offset = get_variant_stack_offset(rhs_vreg);
					emit_variant_eval(dst_offset, lhs_offset, rhs_offset, variant_op);
				} else if (lhs_is_reg && !rhs_is_reg && instr.operands[2].type == IRValue::Type::IMMEDIATE) {
					// Left is register, right is immediate integer
					int lhs_vreg = std::get<int>(instr.operands[1].value);
					int lhs_offset = get_variant_stack_offset(lhs_vreg);
					int64_t imm_val = std::get<int64_t>(instr.operands[2].value);

					int imm_offset = m_next_variant_slot++;
					emit_variant_create_int(imm_offset, static_cast<int>(imm_val));
					emit_variant_eval(dst_offset, lhs_offset, imm_offset, variant_op);
				} else if (!lhs_is_reg && rhs_is_reg && instr.operands[1].type == IRValue::Type::IMMEDIATE) {
					// Left is immediate integer, right is register
					int rhs_vreg = std::get<int>(instr.operands[2].value);
					int rhs_offset = get_variant_stack_offset(rhs_vreg);
					int64_t imm_val = std::get<int64_t>(instr.operands[1].value);

					int imm_offset = m_next_variant_slot++;
					emit_variant_create_int(imm_offset, static_cast<int>(imm_val));
					emit_variant_eval(dst_offset, imm_offset, rhs_offset, variant_op);
				} else {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported operand types for comparison");
				}
				break;
			}

			case IROpcode::AND: {
				int dst_vreg = std::get<int>(instr.operands[0].value);
				int lhs_vreg = std::get<int>(instr.operands[1].value);
				int rhs_vreg = std::get<int>(instr.operands[2].value);

				int dst_offset = get_variant_stack_offset(dst_vreg);
				int lhs_offset = get_variant_stack_offset(lhs_vreg);
				int rhs_offset = get_variant_stack_offset(rhs_vreg);

				emit_variant_eval(dst_offset, lhs_offset, rhs_offset, 20); // OP_AND
				break;
			}

			case IROpcode::OR: {
				int dst_vreg = std::get<int>(instr.operands[0].value);
				int lhs_vreg = std::get<int>(instr.operands[1].value);
				int rhs_vreg = std::get<int>(instr.operands[2].value);

				int dst_offset = get_variant_stack_offset(dst_vreg);
				int lhs_offset = get_variant_stack_offset(lhs_vreg);
				int rhs_offset = get_variant_stack_offset(rhs_vreg);

				emit_variant_eval(dst_offset, lhs_offset, rhs_offset, 21); // OP_OR
				break;
			}

			case IROpcode::NOT: {
				int dst_vreg = std::get<int>(instr.operands[0].value);
				int src_vreg = std::get<int>(instr.operands[1].value);

				int dst_offset = get_variant_stack_offset(dst_vreg);
				int src_offset = get_variant_stack_offset(src_vreg);

				// OP_NOT - use veval (unary operations need special handling)
				// For now, use the same operand for both sides
				emit_variant_eval(dst_offset, src_offset, src_offset, 23); // OP_NOT
				break;
			}

			case IROpcode::BRANCH_ZERO: {
				int vreg = std::get<int>(instr.operands[0].value);
				int offset = get_variant_stack_offset(vreg);
				emit_load_variant_bool(REG_T0, REG_SP, offset);
				mark_label_use(std::get<std::string>(instr.operands[1].value), m_code.size());
				emit_beq(REG_T0, REG_ZERO, 0);
				break;
			}

			case IROpcode::BRANCH_NOT_ZERO: {
				int vreg = std::get<int>(instr.operands[0].value);
				int offset = get_variant_stack_offset(vreg);
				emit_load_variant_bool(REG_T0, REG_SP, offset);
				mark_label_use(std::get<std::string>(instr.operands[1].value), m_code.size());
				emit_bne(REG_T0, REG_ZERO, 0);
				break;
			}

			case IROpcode::BRANCH_EQ:
			case IROpcode::BRANCH_NEQ:
			case IROpcode::BRANCH_LT:
			case IROpcode::BRANCH_LTE:
			case IROpcode::BRANCH_GT:
			case IROpcode::BRANCH_GTE: {
				// Fused comparison + branch instructions
				// Format: BRANCH_* lhs, rhs, label
				// These directly emit BEQ/BNE/BLT/BGE without storing result
				if (instr.operands.size() < 3) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Fused branch requires 3 operands: lhs, rhs, label");
				}

				// Check if operands are registers
				bool lhs_is_reg = instr.operands[0].type == IRValue::Type::REGISTER;
				bool rhs_is_reg = instr.operands[1].type == IRValue::Type::REGISTER;

				// For now, only support register operands (can be extended later for immediates)
				if (!lhs_is_reg || !rhs_is_reg) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Fused branch requires register operands");
				}

				int lhs_vreg = std::get<int>(instr.operands[0].value);
				int rhs_vreg = std::get<int>(instr.operands[1].value);
				std::string label = std::get<std::string>(instr.operands[2].value);

				// Use optimized path for type-hinted INT comparisons
				if (instr.type_hint == Variant::INT) {
					int lhs_offset = get_variant_stack_offset(lhs_vreg);
					int rhs_offset = get_variant_stack_offset(rhs_vreg);

					// Load both int64 values
					emit_load_variant_int(REG_T0, REG_SP, lhs_offset);
					emit_load_variant_int(REG_T1, REG_SP, rhs_offset);

					// Emit direct branch based on comparison type
					mark_label_use(label, m_code.size());
					switch (instr.opcode) {
						case IROpcode::BRANCH_EQ:
							emit_beq(REG_T0, REG_T1, 0);
							break;
						case IROpcode::BRANCH_NEQ:
							emit_bne(REG_T0, REG_T1, 0);
							break;
						case IROpcode::BRANCH_LT:
							emit_blt(REG_T0, REG_T1, 0);
							break;
						case IROpcode::BRANCH_LTE:
							// t0 <= t1 is !(t0 > t1), which is !(t1 < t0)
							// So we branch if NOT (t1 < t0), i.e., t1 >= t0
							emit_bge(REG_T1, REG_T0, 0);
							break;
						case IROpcode::BRANCH_GT:
							// t0 > t1 is t1 < t0
							emit_blt(REG_T1, REG_T0, 0);
							break;
						case IROpcode::BRANCH_GTE:
							emit_bge(REG_T0, REG_T1, 0);
							break;
						default:
							throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unknown fused branch opcode");
					}
				} else {
					// Fall back to comparison + branch for non-INT types
					// This is less optimal but maintains correctness
					int lhs_offset = get_variant_stack_offset(lhs_vreg);
					int rhs_offset = get_variant_stack_offset(rhs_vreg);
					int tmp_vreg = m_next_variant_slot++;
					int tmp_offset = get_variant_stack_offset(tmp_vreg);

					// Map IR opcode to Variant::Operator
					int variant_op;
					switch (instr.opcode) {
						case IROpcode::BRANCH_EQ:  variant_op = 0; break; // OP_EQUAL
						case IROpcode::BRANCH_NEQ: variant_op = 1; break; // OP_NOT_EQUAL
						case IROpcode::BRANCH_LT:  variant_op = 2; break; // OP_LESS
						case IROpcode::BRANCH_LTE: variant_op = 3; break; // OP_LESS_EQUAL
						case IROpcode::BRANCH_GT:  variant_op = 4; break; // OP_GREATER
						case IROpcode::BRANCH_GTE: variant_op = 5; break; // OP_GREATER_EQUAL
						default: variant_op = 0; break;
					}

					// Perform comparison via syscall
					emit_variant_eval(tmp_offset, lhs_offset, rhs_offset, variant_op);

					// Load result and branch
					emit_load_variant_bool(REG_T0, REG_SP, tmp_offset);
					mark_label_use(label, m_code.size());
					emit_bne(REG_T0, REG_ZERO, 0);
				}
				break;
			}

			case IROpcode::JUMP:
				mark_label_use(std::get<std::string>(instr.operands[0].value), m_code.size());
				emit_jal(REG_ZERO, 0);
				break;

			case IROpcode::RETURN: {
				// Godot Sandbox calling convention with Variants:
				// a0 points to pre-allocated Variant for return value
				// Copy the return Variant (virtual register 0) to *a0

				// First, restore a0 from stack (it may have been clobbered by syscalls)
				emit_ld(REG_A0, REG_SP, 16); // LD a0, 16(sp)

				if (m_variant_offsets.find(0) != m_variant_offsets.end()) {
					int src_offset = get_variant_stack_offset(0);

					// Copy 24 bytes from stack to *a0
					// Load address of source Variant: addi t0, sp, src_offset
					if (src_offset < 2048) {
						emit_i_type(0x13, REG_T0, 0, REG_SP, src_offset);
					} else {
						emit_li(REG_T0, src_offset);
						emit_add(REG_T0, REG_SP, REG_T0);
					}

					// Copy 24 bytes (3 8-byte loads/stores)
					for (int i = 0; i < 3; i++) {
						emit_ld(REG_T1, REG_T0, i * 8); // LD t1, i*8(t0)
						emit_sd(REG_T1, REG_A0, i * 8); // SD t1, i*8(a0)
					}
				}

				// Function epilogue - restore registers and deallocate stack
				// Restore return address: ld ra, 0(sp)
				emit_ld(REG_RA, REG_SP, 0); // LD

				// Restore frame pointer: ld fp, 8(sp)
				emit_ld(REG_FP, REG_SP, 8); // LD

				// Deallocate stack: addi sp, sp, frame_size
				if (m_stack_frame_size > 0) {
					if (m_stack_frame_size < 2048) {
						emit_i_type(0x13, REG_SP, 0, REG_SP, m_stack_frame_size);
					} else {
						emit_li(REG_T0, m_stack_frame_size);
						emit_add(REG_SP, REG_SP, REG_T0);
					}
				}

				emit_ret();
				break;
			}

			case IROpcode::VCALL: {
				// VCALL format: result_reg, obj_reg, method_name, arg_count, arg1_reg, arg2_reg, ...
				if (instr.operands.size() < 4) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "VCALL requires at least 4 operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int obj_vreg = std::get<int>(instr.operands[1].value);
				std::string method_name = std::get<std::string>(instr.operands[2].value);
				int arg_count = static_cast<int>(std::get<int64_t>(instr.operands[3].value));

				if (instr.operands.size() != static_cast<size_t>(4 + arg_count)) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "VCALL argument count mismatch");
				}

				int result_offset = get_variant_stack_offset(result_vreg);
				int obj_offset = get_variant_stack_offset(obj_vreg);

				// VCALL clobbers a0-a7, handle register clobbering
				std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3, REG_A4, REG_A5, REG_A6, REG_A7};
				auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

				for (const auto& move : moves) {
					emit_mv(move.second, move.first);
				}

				// If we have arguments, allocate stack space for argument array
				int args_stack_offset = 0;
				if (arg_count > 0) {
					args_stack_offset = m_stack_frame_size - (arg_count * VARIANT_SIZE);
					// Expand stack if needed
					int additional_space = arg_count * VARIANT_SIZE;
					additional_space = (additional_space + 15) & ~15; // Align to 16 bytes

					// Adjust stack pointer
					emit_stack_adjust(-additional_space);

					// Copy argument Variants to the new stack space
					for (int i = 0; i < arg_count; i++) {
						int arg_vreg = std::get<int>(instr.operands[4 + i].value);
						int arg_src_offset = get_variant_stack_offset(arg_vreg) + additional_space; // Adjust for moved stack
						int arg_dst_offset = i * VARIANT_SIZE;

						// Copy 24 bytes from src to dst (3 8-byte loads/stores)
						for (int j = 0; j < 3; j++) {
							// Load from source
							emit_ld(REG_T0, REG_SP, arg_src_offset + j * 8); // LD

							// Store to destination
							emit_sd(REG_T0, REG_SP, arg_dst_offset + j * 8); // SD
						}
					}

					// a3 = pointer to arguments array (sp + 0)
					emit_mv(REG_A3, REG_SP);
				} else {
					// No arguments, a3 = 0
					emit_mv(REG_A3, REG_ZERO);
				}

				// a0 = pointer to object Variant (sp + obj_offset + additional_space if we allocated stack)
				int adjusted_obj_offset = obj_offset;
				if (arg_count > 0) {
					int additional_space = arg_count * VARIANT_SIZE;
					additional_space = (additional_space + 15) & ~15;
					adjusted_obj_offset += additional_space;
				}

				emit_load_stack_offset(REG_A0, adjusted_obj_offset);

				// a1 = pointer to method name string (need to store in .rodata section)
				// For now, we'll use a temporary approach: store the string on stack
				// TODO: Better approach would be to use .rodata section
				int method_len = method_name.length();
				int str_space = ((method_len + 1) + 7) & ~7; // Align to 8 bytes, +1 for null terminator

				// Allocate more stack space for the string
				emit_stack_adjust(-str_space);

				// Store method name on stack
				for (size_t i = 0; i < method_name.length(); i++) {
					emit_li(REG_T0, static_cast<unsigned char>(method_name[i]));
					emit_sb(REG_T0, REG_SP, i); // SB (store byte)
				}
				// Store null terminator
				emit_sb(REG_ZERO, REG_SP, method_len); // SB

				// a1 = pointer to method name (sp)
				emit_mv(REG_A1, REG_SP);

				// a2 = method length
				emit_li(REG_A2, method_len);

				// a4 = argument count
				emit_li(REG_A4, arg_count);

				// a5 = pointer to result Variant
				int adjusted_result_offset = result_offset;
				if (arg_count > 0) {
					int additional_space = arg_count * VARIANT_SIZE;
					additional_space = (additional_space + 15) & ~15;
					adjusted_result_offset += additional_space;
				}
				adjusted_result_offset += str_space;

				emit_load_stack_offset(REG_A5, adjusted_result_offset);

				// a7 = ECALL_VCALL (501)
				emit_li(REG_A7, 501);
				emit_ecall();

				// Restore stack pointer
				int total_stack_adjust = str_space;
				if (arg_count > 0) {
					int additional_space = arg_count * VARIANT_SIZE;
					additional_space = (additional_space + 15) & ~15;
					total_stack_adjust += additional_space;
				}

				emit_stack_adjust(total_stack_adjust);

				// VCALL always writes the result as a full Variant on stack (via a5 pointer)
				break;
			}

			case IROpcode::CALL: {
				// CALL format: function_name, result_reg, arg_count, arg1_reg, arg2_reg, ...
				if (instr.operands.size() < 3) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "CALL requires at least 3 operands");
				}

				std::string func_name = std::get<std::string>(instr.operands[0].value);
				int result_vreg = std::get<int>(instr.operands[1].value);
				int arg_count = static_cast<int>(std::get<int64_t>(instr.operands[2].value));

				if (instr.operands.size() != static_cast<size_t>(3 + arg_count)) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "CALL argument count mismatch");
				}

				// Handle register clobbering (calls clobber a0-a7, ra, and temporaries)
				std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3, REG_A4, REG_A5, REG_A6, REG_A7, REG_RA};
				auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

				for (const auto& move : moves) {
					emit_mv(move.second, move.first);
				}

				// Allocate stack space for return value Variant
				int return_var_offset = get_variant_stack_offset(result_vreg);

				// Set up arguments: a1-a7 point to Variant arguments on stack
				// a0 points to return Variant
				for (int i = 0; i < arg_count && i < 7; i++) {
					int arg_vreg = std::get<int>(instr.operands[3 + i].value);
					int arg_offset = get_variant_stack_offset(arg_vreg);
					uint8_t arg_reg = REG_A1 + static_cast<uint8_t>(i);

					// Load address of argument Variant: addi arg_reg, sp, arg_offset
					if (arg_offset < 2048) {
						emit_i_type(0x13, arg_reg, 0, REG_SP, arg_offset);
					} else {
						emit_li(REG_T0, arg_offset);
						emit_add(arg_reg, REG_SP, REG_T0);
					}
				}

				// a0 = pointer to return Variant
				if (return_var_offset < 2048) {
					emit_i_type(0x13, REG_A0, 0, REG_SP, return_var_offset);
				} else {
					emit_li(REG_A0, return_var_offset);
					emit_add(REG_A0, REG_SP, REG_A0);
				}

				// Call the function using JAL with label
				// We'll use the function name as a label that will be resolved later
				mark_label_use(func_name, m_code.size());
				emit_jal(REG_RA, 0); // JAL ra, func_name

				// Return value is already in the Variant at result_vreg
				break;
			}

			// Inline primitive construction (no syscalls!)
			case IROpcode::MAKE_VECTOR2:
			case IROpcode::MAKE_VECTOR3:
			case IROpcode::MAKE_VECTOR4: {
				// Format: MAKE_VECTORn result_reg, x_reg, y_reg, [z_reg], [w_reg]
				int num_components = (instr.opcode == IROpcode::MAKE_VECTOR2) ? 2 :
									 (instr.opcode == IROpcode::MAKE_VECTOR3) ? 3 : 4;

				if (instr.operands.size() != static_cast<size_t>(1 + num_components)) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "MAKE_VECTOR requires correct number of operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int result_offset = get_variant_stack_offset(result_vreg);

				// Set m_type field (offset 0)
				int variant_type = (instr.opcode == IROpcode::MAKE_VECTOR2) ? Variant::VECTOR2 :
								   (instr.opcode == IROpcode::MAKE_VECTOR3) ? Variant::VECTOR3 : Variant::VECTOR4;
				emit_li(REG_T0, variant_type);
				emit_sw(REG_T0, REG_SP, result_offset); // Store type at offset 0

				// Store each component at offset 8, 12, 16, 20 (4 bytes per component as real_t=float)
				for (int i = 0; i < num_components; i++) {
					int comp_vreg = std::get<int>(instr.operands[1 + i].value);
					int comp_offset = get_variant_stack_offset(comp_vreg);
					emit_variant_component_to_float(comp_offset, result_offset, 8 + i * 4);
				}

				break;
			}

			case IROpcode::MAKE_VECTOR2I:
			case IROpcode::MAKE_VECTOR3I:
			case IROpcode::MAKE_VECTOR4I: {
				// Format: MAKE_VECTORnI result_reg, x_reg, y_reg, [z_reg], [w_reg]
				int num_components = (instr.opcode == IROpcode::MAKE_VECTOR2I) ? 2 :
									 (instr.opcode == IROpcode::MAKE_VECTOR3I) ? 3 : 4;

				if (instr.operands.size() != static_cast<size_t>(1 + num_components)) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "MAKE_VECTORnI requires correct number of operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int result_offset = get_variant_stack_offset(result_vreg);

				// Set m_type field (offset 0)
				int variant_type = (instr.opcode == IROpcode::MAKE_VECTOR2I) ? Variant::VECTOR2I :
								   (instr.opcode == IROpcode::MAKE_VECTOR3I) ? Variant::VECTOR3I : Variant::VECTOR4I;
				emit_li(REG_T0, variant_type);
				emit_sw(REG_T0, REG_SP, result_offset); // Store type at offset 0

				// Store each component in v.v4i[] at offset 8, 12, 16, 20
				for (int i = 0; i < num_components; i++) {
					int comp_vreg = std::get<int>(instr.operands[1 + i].value);
					int comp_offset = get_variant_stack_offset(comp_vreg);

					// Load from stack Variant
					emit_lw(REG_T0, REG_SP, comp_offset + 8);
					emit_sw(REG_T0, REG_SP, result_offset + 8 + i * 4);
				}

				break;
			}

			case IROpcode::MAKE_COLOR: {
				// Format: MAKE_COLOR result_reg, r_reg, g_reg, b_reg, a_reg
				if (instr.operands.size() != 5) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "MAKE_COLOR requires 5 operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int result_offset = get_variant_stack_offset(result_vreg);

				// Set m_type field to COLOR
				emit_li(REG_T0, Variant::COLOR);
				emit_sw(REG_T0, REG_SP, result_offset);

				// Store each component (r, g, b, a) as 32-bit floats (real_t)
				// Color components need to be normalized (0-255 integers -> 0.0-1.0 floats)
				for (int i = 0; i < 4; i++) {
					int comp_vreg = std::get<int>(instr.operands[1 + i].value);
					int comp_offset = get_variant_stack_offset(comp_vreg);
					emit_variant_component_to_float(comp_offset, result_offset, 8 + i * 4, true); // normalize_by_255 = true
				}

				break;
			}

			case IROpcode::MAKE_ARRAY: {
				// Format: MAKE_ARRAY result_reg, element_count, [element_reg1, element_reg2, ...]
				// For empty arrays: element_count = 0, no element regs
				if (instr.operands.size() < 2) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "MAKE_ARRAY requires at least 2 operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int element_count = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				int result_offset = get_variant_stack_offset(result_vreg);

				// Handle register clobbering (VCREATE uses a0-a3)
				std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
				auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);
				for (const auto& move : moves) {
					emit_mv(move.second, move.first);
				}

				if (element_count == 0) {
					// Empty Array: use the abstraction
					emit_variant_create_empty_array(result_offset);
				} else {
					// Array with elements: sys_vcreate(&v, ARRAY, size, data_pointer)
					// GuestVariant is 24 bytes (4-byte type + 4-byte padding + 16-byte data)
					// We need to copy the full Variant structures to stack
					constexpr int VARIANT_SIZE = 24;
					int args_space = element_count * VARIANT_SIZE;
					args_space = (args_space + 15) & ~15; // Align to 16 bytes

					// Adjust stack pointer
					if (args_space < 2048) {
						emit_i_type(0x13, REG_SP, 0, REG_SP, -args_space);
					} else {
						emit_li(REG_T0, -args_space);
						emit_add(REG_SP, REG_SP, REG_T0);
					}

					// Copy full GuestVariant structures (24 bytes each) to stack
					for (int i = 0; i < element_count; i++) {
						int elem_vreg = std::get<int>(instr.operands[2 + i].value);
						int elem_offset = get_variant_stack_offset(elem_vreg);

						// Destination address for this element
						int dst_offset = i * VARIANT_SIZE;

						// The element Variant is at elem_offset from the ORIGINAL stack frame
						// After SP -= args_space, it's now at elem_offset + args_space from NEW SP
						// So we load from (elem_offset + args_space) and store to dst_offset

						// Copy 24 bytes: 8 + 8 + 8 = three 64-bit loads/stores
						// First 8 bytes (type + padding)
						emit_ld(REG_T0, REG_SP, elem_offset + args_space);
						emit_sd(REG_T0, REG_SP, dst_offset);

						// Second 8 bytes (data part 1)
						emit_ld(REG_T0, REG_SP, elem_offset + args_space + 8);
						emit_sd(REG_T0, REG_SP, dst_offset + 8);

						// Third 8 bytes (data part 2)
						emit_ld(REG_T0, REG_SP, elem_offset + args_space + 16);
						emit_sd(REG_T0, REG_SP, dst_offset + 16);
					}

					// a0 = pointer to destination Variant
					// The result Variant is at result_offset from the ORIGINAL stack frame
					// After SP -= args_space, it's now at result_offset + args_space from NEW SP
					int adjusted_dst_offset = result_offset + args_space;
					if (adjusted_dst_offset < 2048) {
						emit_i_type(0x13, REG_A0, 0, REG_SP, adjusted_dst_offset);
					} else {
						emit_li(REG_A0, adjusted_dst_offset);
						emit_add(REG_A0, REG_SP, REG_A0);
					}

					// a1 = Variant::ARRAY
					emit_li(REG_A1, Variant::ARRAY);

					// a2 = size (element_count)
					emit_li(REG_A2, element_count);

					// a3 = pointer to element array (sp + 0)
					emit_mv(REG_A3, REG_SP);

					// a7 = ECALL_VCREATE (517)
					emit_li(REG_A7, 517);
					emit_ecall();

					// Restore stack pointer
					if (args_space < 2048) {
						emit_i_type(0x13, REG_SP, 0, REG_SP, args_space);
					} else {
						emit_li(REG_T0, args_space);
						emit_add(REG_SP, REG_SP, REG_T0);
					}
				}

				break;
			}

			case IROpcode::MAKE_DICTIONARY: {
				// Format: MAKE_DICTIONARY result_reg, pair_count, [key1_reg, val1_reg, key2_reg, val2_reg, ...]
				// For empty dictionaries via Dictionary() constructor: MAKE_DICTIONARY result_reg
				// For empty dictionaries via literal {}: MAKE_DICTIONARY result_reg, 0
				// For dictionaries with elements: pair_count > 0 with key/value regs
				if (instr.operands.size() < 1) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "MAKE_DICTIONARY requires at least 1 operand");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int result_offset = get_variant_stack_offset(result_vreg);

				// Check if this is the old Dictionary() constructor format (only 1 operand)
				// or the new dictionary literal format (2+ operands)
				bool is_constructor_format = (instr.operands.size() == 1);
				int pair_count = is_constructor_format ? 0 : static_cast<int>(std::get<int64_t>(instr.operands[1].value));

				// Handle register clobbering (VCREATE uses a0-a3)
				std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
				auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);
				for (const auto& move : moves) {
					emit_mv(move.second, move.first);
				}

				if (pair_count == 0) {
					// Empty Dictionary: use the abstraction
					emit_variant_create_empty_dictionary(result_offset);
				} else {
					// Dictionary with elements: sys_vcreate(&v, DICTIONARY, size, data_pointer)
					// GuestVariant is 24 bytes (4-byte type + 4-byte padding + 16-byte data)
					// We need to copy the full Variant structures to stack
					constexpr int VARIANT_SIZE = 24;
					int total_variants = pair_count * 2; // Each pair has 2 variants (key and value)
					int args_space = total_variants * VARIANT_SIZE;
					args_space = (args_space + 15) & ~15; // Align to 16 bytes

					// Adjust stack pointer
					if (args_space < 2048) {
						emit_i_type(0x13, REG_SP, 0, REG_SP, -args_space);
					} else {
						emit_li(REG_T0, -args_space);
						emit_add(REG_SP, REG_SP, REG_T0);
					}

					// Copy full GuestVariant structures (24 bytes each) to stack
					// Operands are interleaved: key1, val1, key2, val2, ...
					for (int i = 0; i < total_variants; i++) {
						int variant_vreg = std::get<int>(instr.operands[2 + i].value);
						int variant_offset = get_variant_stack_offset(variant_vreg);

						// Destination address for this variant
						int dst_offset = i * VARIANT_SIZE;

						// The variant Variant is at variant_offset from the ORIGINAL stack frame
						// After SP -= args_space, it's now at variant_offset + args_space from NEW SP
						// So we load from (variant_offset + args_space) and store to dst_offset

						// Copy 24 bytes: 8 + 8 + 8 = three 64-bit loads/stores
						// First 8 bytes (type + padding)
						emit_ld(REG_T0, REG_SP, variant_offset + args_space);
						emit_sd(REG_T0, REG_SP, dst_offset);

						// Second 8 bytes (data part 1)
						emit_ld(REG_T0, REG_SP, variant_offset + args_space + 8);
						emit_sd(REG_T0, REG_SP, dst_offset + 8);

						// Third 8 bytes (data part 2)
						emit_ld(REG_T0, REG_SP, variant_offset + args_space + 16);
						emit_sd(REG_T0, REG_SP, dst_offset + 16);
					}

					// a0 = pointer to destination Variant
					// The result Variant is at result_offset from the ORIGINAL stack frame
					// After SP -= args_space, it's now at result_offset + args_space from NEW SP
					int adjusted_dst_offset = result_offset + args_space;
					if (adjusted_dst_offset < 2048) {
						emit_i_type(0x13, REG_A0, 0, REG_SP, adjusted_dst_offset);
					} else {
						emit_li(REG_A0, adjusted_dst_offset);
						emit_add(REG_A0, REG_SP, REG_A0);
					}

					// a1 = Variant::DICTIONARY
					emit_li(REG_A1, Variant::DICTIONARY);

					// a2 = size (pair_count * 2 = total number of variants)
					emit_li(REG_A2, total_variants);

					// a3 = pointer to variant array (sp + 0)
					emit_mv(REG_A3, REG_SP);

					// a7 = ECALL_VCREATE (517)
					emit_li(REG_A7, 517);
					emit_ecall();

					// Restore stack pointer
					if (args_space < 2048) {
						emit_i_type(0x13, REG_SP, 0, REG_SP, args_space);
					} else {
						emit_li(REG_T0, args_space);
						emit_add(REG_SP, REG_SP, REG_T0);
					}
				}

				break;
			}

			case IROpcode::MAKE_PACKED_BYTE_ARRAY:
			case IROpcode::MAKE_PACKED_INT32_ARRAY:
			case IROpcode::MAKE_PACKED_INT64_ARRAY:
			case IROpcode::MAKE_PACKED_FLOAT32_ARRAY:
			case IROpcode::MAKE_PACKED_FLOAT64_ARRAY:
			case IROpcode::MAKE_PACKED_STRING_ARRAY:
			case IROpcode::MAKE_PACKED_VECTOR2_ARRAY:
			case IROpcode::MAKE_PACKED_VECTOR3_ARRAY:
			case IROpcode::MAKE_PACKED_COLOR_ARRAY:
			case IROpcode::MAKE_PACKED_VECTOR4_ARRAY: {
				// Format: MAKE_PACKED_*_ARRAY result_reg, element_count, [element_reg1, element_reg2, ...]
				// Works identically to MAKE_ARRAY but with different Variant type
				if (instr.operands.size() < 2) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Packed array constructor requires at least 2 operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int element_count = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				int result_offset = get_variant_stack_offset(result_vreg);

				// Determine the Variant type based on opcode
				int variant_type;
				switch (instr.opcode) {
					case IROpcode::MAKE_PACKED_BYTE_ARRAY:
						variant_type = Variant::PACKED_BYTE_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_INT32_ARRAY:
						variant_type = Variant::PACKED_INT32_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_INT64_ARRAY:
						variant_type = Variant::PACKED_INT64_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_FLOAT32_ARRAY:
						variant_type = Variant::PACKED_FLOAT32_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_FLOAT64_ARRAY:
						variant_type = Variant::PACKED_FLOAT64_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_STRING_ARRAY:
						variant_type = Variant::PACKED_STRING_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_VECTOR2_ARRAY:
						variant_type = Variant::PACKED_VECTOR2_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_VECTOR3_ARRAY:
						variant_type = Variant::PACKED_VECTOR3_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_COLOR_ARRAY:
						variant_type = Variant::PACKED_COLOR_ARRAY;
						break;
					case IROpcode::MAKE_PACKED_VECTOR4_ARRAY:
						variant_type = Variant::PACKED_VECTOR4_ARRAY;
						break;
					default:
						variant_type = Variant::ARRAY; // Should not happen
						break;
				}

				if (element_count == 0) {
					// Empty packed array: sys_vcreate(&v, TYPE, 0, nullptr)
					// a0 = pointer to destination Variant
					if (result_offset < 2048) {
						emit_i_type(0x13, REG_A0, 0, REG_SP, result_offset);
					} else {
						emit_li(REG_A0, result_offset);
						emit_add(REG_A0, REG_SP, REG_A0);
					}

					// a1 = Variant type
					emit_li(REG_A1, variant_type);

					// a2 = method (0 for empty)
					emit_li(REG_A2, 0);

					// a3 = nullptr (0)
					emit_li(REG_A3, 0);

					// a7 = ECALL_VCREATE (517)
					emit_li(REG_A7, 517);
					emit_ecall();
				} else {
					// Packed array with elements: Use ECALL_PACKED_ARRAY_OPS (548)
					// Signature: a0=op(type), a1=result_ptr, a2=array_ptr, a3=array_size
					// The syscall converts an Array of Variants to a PackedArray
					constexpr int VARIANT_SIZE = 24;
					int args_space = element_count * VARIANT_SIZE;
					args_space = (args_space + 15) & ~15; // Align to 16 bytes

					// Allocate stack space
					if (args_space < 2048) {
						emit_addi(REG_SP, REG_SP, -args_space);
					} else {
						emit_li(REG_T0, -args_space);
						emit_add(REG_SP, REG_SP, REG_T0);
					}

					// Copy each element variant to the stack (as GuestVariant array)
					for (int i = 0; i < element_count; i++) {
						int elem_vreg = std::get<int>(instr.operands[2 + i].value);
						int elem_offset = get_variant_stack_offset(elem_vreg);
						int dst_offset = i * VARIANT_SIZE;

						// Copy 24 bytes from source to destination
						for (int j = 0; j < 24; j += 8) {
							emit_ld(REG_T0, REG_SP, args_space + elem_offset + j);
							emit_sd(REG_T0, REG_SP, dst_offset + j);
						}
					}

					// a0 = op (the packed array type, which also indicates CREATE_FROM_ARRAY)
					emit_li(REG_A0, variant_type);

					// a1 = pointer to destination Variant
					// After SP -= args_space, it's now at result_offset + args_space from NEW SP
					int adjusted_dst_offset = result_offset + args_space;
					if (adjusted_dst_offset < 2048) {
						emit_i_type(0x13, REG_A1, 0, REG_SP, adjusted_dst_offset);
					} else {
						emit_li(REG_A1, adjusted_dst_offset);
						emit_add(REG_A1, REG_SP, REG_A1);
					}

					// a2 = pointer to element array (sp + 0)
					emit_mv(REG_A2, REG_SP);

					// a3 = element_count
					emit_li(REG_A3, element_count);

					// a7 = ECALL_PACKED_ARRAY_OPS (548)
					emit_li(REG_A7, 548);
					emit_ecall();

					// Restore stack pointer
					if (args_space < 2048) {
						emit_i_type(0x13, REG_SP, 0, REG_SP, args_space);
					} else {
						emit_li(REG_T0, args_space);
						emit_add(REG_SP, REG_SP, REG_T0);
					}
				}

				break;
			}

			case IROpcode::VGET_INLINE: {
				// Format: VGET_INLINE result_reg, obj_reg, member_name, obj_type_hint
				if (instr.operands.size() != 4) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "VGET_INLINE requires 4 operands");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int obj_vreg = std::get<int>(instr.operands[1].value);
				std::string member = std::get<std::string>(instr.operands[2].value);
				int obj_type_hint = static_cast<int>(std::get<int64_t>(instr.operands[3].value));

				int result_offset = get_variant_stack_offset(result_vreg);
				int obj_offset = get_variant_stack_offset(obj_vreg);

				// Determine the offset within the object Variant
				// Vector types with float components (real_t=float=4 bytes): offsets at 8, 12, 16, 20
				// Vector types with int components (int32_t=4 bytes): offsets at 8, 12, 16, 20
				int member_offset = 8; // Base offset
				bool is_int_type = false;

				// Map member name to array index
				int component_idx = 0;
				if (member == "x" || member == "r") component_idx = 0;
				else if (member == "y" || member == "g") component_idx = 1;
				else if (member == "z" || member == "b") component_idx = 2;
				else if (member == "w" || member == "a") component_idx = 3;

				// Check if it's an integer vector type using helper function
				IRInstruction::TypeHint hint = static_cast<IRInstruction::TypeHint>(obj_type_hint);
				is_int_type = TypeHintUtils::is_int_vector(hint);

				// All vector components are stored as 4-byte values
				member_offset += component_idx * 4;

				if (is_int_type) {
					// Load 32-bit integer from object
					emit_lw(REG_T0, REG_SP, obj_offset + member_offset);

					// Create result Variant with INT type (2)
					emit_li(REG_T1, 2);
					emit_sw(REG_T1, REG_SP, result_offset); // m_type = INT

					// Sign-extend to 64-bit and store in v.i
					emit_sext_w(REG_T0, REG_T0);
					emit_sd(REG_T0, REG_SP, result_offset + 8);
				} else {
					// For float components from Vector types:
					// Use FP instructions to convert 4-byte float to 8-byte double
					// FLW loads 32-bit float, FCVT.D.S converts to double

					// Load 4-byte float component to FP register
					emit_flw(REG_FA0, REG_SP, obj_offset + member_offset);

					// Convert float (32-bit) to double (64-bit)
					emit_fcvt_d_s(REG_FA0, REG_FA0);

					// Set result Variant type to FLOAT
					emit_li(REG_T0, Variant::FLOAT);
					emit_sw(REG_T0, REG_SP, result_offset); // m_type = FLOAT

					// Store 8-byte double to v.f field
					emit_fsd(REG_FA0, REG_SP, result_offset + 8);
				}

				break;
			}

			case IROpcode::VGET: {
				// VGET format: result_reg, obj_reg, string_idx, string_len
				// Uses ECALL_OBJ_PROP_GET (545)
				// Calling convention:
				//   A0 = object address (v.i from object Variant)
				//   A1 = property name pointer
				//   A2 = property name length
				//   A3 = pointer to result Variant

				if (instr.operands.size() != 4) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "VGET requires 4 operands (result_reg, obj_reg, string_idx, string_len)");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int obj_vreg = std::get<int>(instr.operands[1].value);
				int string_idx = static_cast<int>(std::get<int64_t>(instr.operands[2].value));
				int string_len = static_cast<int>(std::get<int64_t>(instr.operands[3].value));

				// Get the string constant
				if (string_idx < 0 || static_cast<size_t>(string_idx) >= m_string_constants->size()) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "String constant index out of range");
				}
				const std::string& str = (*m_string_constants)[string_idx];

				int result_offset = get_variant_stack_offset(result_vreg);
				int obj_offset = get_variant_stack_offset(obj_vreg);

				// ECALL_OBJ_PROP_GET clobbers a0-a3
				std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
				auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

				for (const auto& move : moves) {
					emit_mv(move.second, move.first);
				}

				// A0 = object address (load from Variant's v.i field at offset 8)
				// IMPORTANT: Load this BEFORE adjusting the stack, so obj_offset is correct
				emit_ld(REG_A0, REG_SP, obj_offset + 8);

				// Allocate stack space for the string
				int str_space = ((string_len + 1) + 7) & ~7; // Align to 8 bytes, +1 for null terminator

				emit_stack_adjust(-str_space);

				// Store string on stack
				for (size_t i = 0; i < str.length(); i++) {
					emit_li(REG_T0, static_cast<unsigned char>(str[i]));
					emit_sb(REG_T0, REG_SP, i); // SB (store byte)
				}
				// Store null terminator
				emit_sb(REG_ZERO, REG_SP, string_len); // SB

				// A1 = pointer to property name string (sp)
				emit_mv(REG_A1, REG_SP);

				// A2 = string length
				emit_li(REG_A2, string_len);

				// A3 = pointer to result Variant
				// IMPORTANT: Account for str_space since SP was adjusted
				emit_load_stack_offset(REG_A3, result_offset + str_space);

				// A7 = syscall number (545 for ECALL_OBJ_PROP_GET)
				emit_li(REG_A7, 545);
				emit_ecall();

				// Restore stack pointer
				emit_stack_adjust(str_space);

				break;
			}

			case IROpcode::VSET: {
				// VSET format: obj_reg, string_idx, string_len, value_reg
				// Uses ECALL_OBJ_PROP_SET (546)
				// Calling convention:
				//   A0 = object address (v.i from object Variant)
				//   A1 = property name pointer
				//   A2 = property name length
				//   A3 = pointer to value Variant

				if (instr.operands.size() != 4) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "VSET requires 4 operands (obj_reg, string_idx, string_len, value_reg)");
				}

				int obj_vreg = std::get<int>(instr.operands[0].value);
				int string_idx = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				int string_len = static_cast<int>(std::get<int64_t>(instr.operands[2].value));
				int value_vreg = std::get<int>(instr.operands[3].value);

				// Get the string constant
				if (string_idx < 0 || static_cast<size_t>(string_idx) >= m_string_constants->size()) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "String constant index out of range");
				}
				const std::string& str = (*m_string_constants)[string_idx];

				int obj_offset = get_variant_stack_offset(obj_vreg);
				int value_offset = get_variant_stack_offset(value_vreg);

				// ECALL_OBJ_PROP_SET clobbers a0-a3
				std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
				auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

				for (const auto& move : moves) {
					emit_mv(move.second, move.first);
				}

				// A0 = object address (load from Variant's v.i field at offset 8)
				// IMPORTANT: Load this BEFORE adjusting the stack, so obj_offset is correct
				emit_ld(REG_A0, REG_SP, obj_offset + 8);

				// Allocate stack space for the string
				int str_space = ((string_len + 1) + 7) & ~7; // Align to 8 bytes, +1 for null terminator

				emit_stack_adjust(-str_space);

				// Store string on stack
				for (size_t i = 0; i < str.length(); i++) {
					emit_li(REG_T0, static_cast<unsigned char>(str[i]));
					emit_sb(REG_T0, REG_SP, i); // SB (store byte)
				}
				// Store null terminator
				emit_sb(REG_ZERO, REG_SP, string_len); // SB

				// A1 = pointer to property name string (sp)
				emit_mv(REG_A1, REG_SP);

				// A2 = string length
				emit_li(REG_A2, string_len);

				// A3 = pointer to value Variant
				// IMPORTANT: Calculate this AFTER adjusting the stack, and account for str_space
				// emit_load_stack_offset does: addi a3, sp, offset, so we get the correct address directly
				emit_load_stack_offset(REG_A3, value_offset + str_space);

				// A7 = syscall number (546 for ECALL_OBJ_PROP_SET)
				emit_li(REG_A7, 546);
				emit_ecall();

				// Restore stack pointer
				emit_stack_adjust(str_space);

				break;
			}

			// Not implementing these for now
			case IROpcode::MAKE_RECT2:
			case IROpcode::MAKE_RECT2I:
			case IROpcode::MAKE_PLANE:
			case IROpcode::VSET_INLINE:
				throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Opcode not yet implemented in RISC-V codegen");

			case IROpcode::CALL_SYSCALL: {
				// CALL_SYSCALL format: result_reg, syscall_number, arg1, arg2, ...
				// Different syscalls have different calling conventions:
				// ECALL_GET_OBJ (504): result_reg, 504, string_index, string_length
				// ECALL_ARRAY_SIZE (523): result_reg, 523, array_vreg
				// ECALL_ARRAY_AT (522): result_reg, 522, array_vreg, index_vreg

				if (instr.operands.size() < 2) {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "CALL_SYSCALL requires at least 2 operands (result_reg, syscall_num)");
				}

				int result_vreg = std::get<int>(instr.operands[0].value);
				int syscall_num = static_cast<int>(std::get<int64_t>(instr.operands[1].value));

				// Handle different syscalls based on their calling conventions
				if (syscall_num == 504) {
					// ECALL_GET_OBJ: result_reg, 504, string_index, string_length
					if (instr.operands.size() != 4) {
						throw CompilerException(ErrorType::RISCV_codegen_ERROR, "ECALL_GET_OBJ requires 4 operands");
					}

					int string_idx = static_cast<int>(std::get<int64_t>(instr.operands[2].value));
					int string_len = static_cast<int>(std::get<int64_t>(instr.operands[3].value));

					// Get the string constant
					if (string_idx < 0 || static_cast<size_t>(string_idx) >= m_string_constants->size()) {
						throw CompilerException(ErrorType::RISCV_codegen_ERROR, "String constant index out of range");
					}
					const std::string& str = (*m_string_constants)[string_idx];

					int result_offset = get_variant_stack_offset(result_vreg);

					// ECALL_GET_OBJ clobbers a0 and a1
					std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1};
					auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

					for (const auto& move : moves) {
						emit_mv(move.second, move.first);
					}

					// Allocate stack space for the string
					int str_space = ((string_len + 1) + 7) & ~7; // Align to 8 bytes, +1 for null terminator

					emit_stack_adjust(-str_space);

					// Store string on stack
					for (size_t i = 0; i < str.length(); i++) {
						emit_li(REG_T0, static_cast<unsigned char>(str[i]));
						emit_sb(REG_T0, REG_SP, i); // SB (store byte)
					}
					// Store null terminator
					emit_sb(REG_ZERO, REG_SP, string_len); // SB

					// a0 = pointer to class name string (sp) - FIRST ARGUMENT
					emit_mv(REG_A0, REG_SP);

					// a1 = string length - SECOND ARGUMENT
					emit_li(REG_A1, string_len);

					// a7 = syscall number (504 for ECALL_GET_OBJ)
					emit_li(REG_A7, syscall_num);
					emit_ecall();

					// After ecall, a0 contains the object reference (32-bit int)
					// First, restore stack pointer (before storing result)
					emit_stack_adjust(str_space);

					// Store syscall result
					emit_syscall_result(result_vreg, REG_A0, result_offset, 24); // GDOBJECT type = 24

				} else if (syscall_num == 523) {
					// ECALL_ARRAY_SIZE: result_reg, 523, array_vreg
					// Takes: a0 = array variant index (unsigned)
					// Returns: a0 = array size (int)
					if (instr.operands.size() != 3) {
						throw CompilerException(ErrorType::RISCV_codegen_ERROR, "ECALL_ARRAY_SIZE requires 3 operands");
					}

					int array_vreg = static_cast<int>(std::get<int>(instr.operands[2].value));

					// Ensure result variant has a stack slot BEFORE handling clobbering
					// This prevents the allocator from moving it during syscall setup
					int result_offset = get_variant_stack_offset(result_vreg);
					int array_offset = get_variant_stack_offset(array_vreg);

					// ECALL_ARRAY_SIZE clobbers a0
					std::vector<uint8_t> clobbered_regs = {REG_A0};
					auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

					for (const auto& move : moves) {
						emit_mv(move.second, move.first);
					}

					// Load the array variant index from offset 8 of the array Variant
					emit_lw(REG_A0, REG_SP, array_offset + 8); // Load 32-bit variant index

					// a7 = syscall number (523 for ECALL_ARRAY_SIZE)
					emit_li(REG_A7, syscall_num);
					emit_ecall();

					// After ecall, a0 contains the size (64-bit int)
					// Store syscall result
					emit_syscall_result(result_vreg, REG_A0, result_offset, 2); // INT type = 2

				} else if (syscall_num == 522) {
					// ECALL_ARRAY_AT: result_reg, 522, array_vreg, index_vreg
					// Takes: a0 = array variant index (unsigned), a1 = index (int), a2 = result GuestVariant pointer
					// Returns: result variant is filled with the element
					if (instr.operands.size() != 4) {
						throw CompilerException(ErrorType::RISCV_codegen_ERROR, "ECALL_ARRAY_AT requires 4 operands");
					}

					int array_vreg = static_cast<int>(std::get<int>(instr.operands[2].value));
					int index_vreg = static_cast<int>(std::get<int>(instr.operands[3].value));

					// Ensure all variants have stack slots BEFORE handling clobbering
					// This prevents the allocator from moving them during syscall setup
					int result_offset = get_variant_stack_offset(result_vreg);
					int array_offset = get_variant_stack_offset(array_vreg);
					int index_offset = get_variant_stack_offset(index_vreg);

					// ECALL_ARRAY_AT clobbers a0, a1, a2
					std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2};
					auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

					for (const auto& move : moves) {
						emit_mv(move.second, move.first);
					}

					// a0 = array variant index (load from offset 8 of array Variant)
					emit_lw(REG_A0, REG_SP, array_offset + 8); // Load 32-bit variant index

					// a1 = index (load from index_vreg)
					// The index is stored as a Variant, we need to extract the integer value
					// NOTE: Use emit_ld (64-bit) because integer Variants store 64-bit values, not 32-bit!
					emit_ld(REG_A1, REG_SP, index_offset + 8); // Load 64-bit integer from offset 8

					// a2 = pointer to result GuestVariant
					emit_i_type(0x13, REG_A2, 0, REG_SP, result_offset); // addi a2, sp, result_offset

					// a7 = syscall number (522 for ECALL_ARRAY_AT)
					emit_li(REG_A7, syscall_num);
					emit_ecall();

				} else if (syscall_num == 507) {
					// ECALL_GET_NODE: result_reg, 507, addr, [path_vreg]
					// Takes: a0 = base node address (0 for owner), a1 = path string pointer, a2 = path length
					// Returns: a0 = node object reference
					if (instr.operands.size() < 3) {
						throw CompilerException(ErrorType::RISCV_codegen_ERROR, "ECALL_GET_NODE requires at least 3 operands");
					}

					int base_addr = static_cast<int>(std::get<int64_t>(instr.operands[2].value));
					bool has_path = instr.operands.size() >= 4;

					// Ensure result variant has a stack slot BEFORE handling clobbering
					int result_offset = get_variant_stack_offset(result_vreg);

					// ECALL_GET_NODE clobbers a0, a1, a2
					std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2};
					auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

					for (const auto& move : moves) {
						emit_mv(move.second, move.first);
					}

					if (has_path) {
						// get_node(path) - load path from variant register
						int path_vreg = static_cast<int>(std::get<int>(instr.operands[3].value));
						int path_offset = get_variant_stack_offset(path_vreg);

						// Load the String variant from path_vreg
						// String variant structure: type(4) + padding(4) + data(16)
						// For strings, we need to extract the pointer and length

						// a0 = base node address (0 for owner)
						emit_li(REG_A0, base_addr);

						// Load string pointer from offset 8 of the String variant
						emit_ld(REG_A1, REG_SP, path_offset + 8); // Load 64-bit pointer

						// Load string length from offset 16 (assuming it's stored there)
						// For now, we'll use a fixed approach - this may need adjustment
						// String length might be at offset 16 or we may need to query it
						emit_ld(REG_A2, REG_SP, path_offset + 16); // Load 64-bit length
					} else {
						// get_node() - no path argument, get the current node using "."
						// Allocate space for the "." string (2 bytes: '.' + null terminator)
						int dot_str_space = 8; // Align to 8 bytes
						emit_stack_adjust(-dot_str_space);

						// Store "." string on stack
						emit_li(REG_T0, static_cast<uint8_t>('.'));
						emit_sb(REG_T0, REG_SP, 0); // Store '.'
						emit_sb(REG_ZERO, REG_SP, 1); // Store null terminator

						// a0 = base node address (0 for owner)
						emit_li(REG_A0, base_addr);

						// a1 = pointer to "." string
						emit_mv(REG_A1, REG_SP);

						// a2 = string length (1)
						emit_li(REG_A2, 1);
					}

					// a7 = syscall number (507 for ECALL_GET_NODE)
					emit_li(REG_A7, syscall_num);
					emit_ecall();

					// After ecall, a0 contains the node object reference
					// Restore stack if we allocated space for the "."
					if (!has_path) {
						emit_stack_adjust(8); // Restore the stack space for "."
					}

					// Store syscall result
					emit_syscall_result(result_vreg, REG_A0, result_offset, 24); // OBJECT type = 24

				} else {
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unknown syscall number: " + std::to_string(syscall_num));
				}

				break;
			}

			default:
				throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unknown IR opcode");
		}
	}
}

// Instruction encoding helpers
void RISCVCodeGen::emit_word(uint32_t word) {
	m_code.push_back(word & 0xFF);
	m_code.push_back((word >> 8) & 0xFF);
	m_code.push_back((word >> 16) & 0xFF);
	m_code.push_back((word >> 24) & 0xFF);
}

void RISCVCodeGen::emit_r_type(uint8_t opcode, uint8_t rd, uint8_t funct3, uint8_t rs1, uint8_t rs2, uint8_t funct7) {
	uint32_t instr = opcode | (rd << 7) | (funct3 << 12) | (rs1 << 15) | (rs2 << 20) | (funct7 << 25);
	emit_word(instr);
}

void RISCVCodeGen::emit_i_type(uint8_t opcode, uint8_t rd, uint8_t funct3, uint8_t rs1, int32_t imm) {
	uint32_t instr = opcode | (rd << 7) | (funct3 << 12) | (rs1 << 15) | ((imm & 0xFFF) << 20);
	emit_word(instr);
}

void RISCVCodeGen::emit_s_type(uint8_t opcode, uint8_t funct3, uint8_t rs1, uint8_t rs2, int32_t imm) {
	uint32_t imm_lo = imm & 0x1F;
	uint32_t imm_hi = (imm >> 5) & 0x7F;
	uint32_t instr = opcode | (imm_lo << 7) | (funct3 << 12) | (rs1 << 15) | (rs2 << 20) | (imm_hi << 25);
	m_code.push_back(instr & 0xFF);
	m_code.push_back((instr >> 8) & 0xFF);
	m_code.push_back((instr >> 16) & 0xFF);
	m_code.push_back((instr >> 24) & 0xFF);
}

void RISCVCodeGen::emit_b_type(uint8_t opcode, uint8_t funct3, uint8_t rs1, uint8_t rs2, int32_t imm) {
	// B-type immediate encoding (weird layout)
	uint32_t imm12 = (imm >> 12) & 1;
	uint32_t imm10_5 = (imm >> 5) & 0x3F;
	uint32_t imm4_1 = (imm >> 1) & 0xF;
	uint32_t imm11 = (imm >> 11) & 1;

	uint32_t instr = opcode | (imm11 << 7) | (imm4_1 << 8) | (funct3 << 12) | (rs1 << 15) | (rs2 << 20) | (imm10_5 << 25) | (imm12 << 31);
	m_code.push_back(instr & 0xFF);
	m_code.push_back((instr >> 8) & 0xFF);
	m_code.push_back((instr >> 16) & 0xFF);
	m_code.push_back((instr >> 24) & 0xFF);
}

void RISCVCodeGen::emit_u_type(uint8_t opcode, uint8_t rd, uint32_t imm) {
	uint32_t instr = opcode | (rd << 7) | (imm & 0xFFFFF000);
	m_code.push_back(instr & 0xFF);
	m_code.push_back((instr >> 8) & 0xFF);
	m_code.push_back((instr >> 16) & 0xFF);
	m_code.push_back((instr >> 24) & 0xFF);
}

void RISCVCodeGen::emit_j_type(uint8_t opcode, uint8_t rd, int32_t imm) {
	// J-type immediate encoding
	uint32_t imm20 = (imm >> 20) & 1;
	uint32_t imm10_1 = (imm >> 1) & 0x3FF;
	uint32_t imm11 = (imm >> 11) & 1;
	uint32_t imm19_12 = (imm >> 12) & 0xFF;

	uint32_t instr = opcode | (rd << 7) | (imm19_12 << 12) | (imm11 << 20) | (imm10_1 << 21) | (imm20 << 31);
	m_code.push_back(instr & 0xFF);
	m_code.push_back((instr >> 8) & 0xFF);
	m_code.push_back((instr >> 16) & 0xFF);
	m_code.push_back((instr >> 24) & 0xFF);
}

void RISCVCodeGen::emit_r4_type(uint8_t opcode, uint8_t rd, uint8_t funct3, uint8_t rs1, uint8_t rs2, uint8_t rs3, uint8_t funct2)
{
	union {
		struct {
			uint32_t opcode : 7;
			uint32_t rd     : 5;
			uint32_t funct3 : 3;
			uint32_t rs1    : 5;
			uint32_t rs2    : 5;
			uint32_t funct2 : 2;
			uint32_t rs3    : 5;
		} R4type;
		uint32_t value;
	} r4;
	r4.R4type.opcode = opcode;
	r4.R4type.rd = rd;
	r4.R4type.funct3 = funct3;
	r4.R4type.rs1 = rs1;
	r4.R4type.rs2 = rs2;
	r4.R4type.funct2 = funct2;
	r4.R4type.rs3 = rs3;
	emit_word(r4.value);
}

// Higher-level instructions
void RISCVCodeGen::emit_li(uint8_t rd, int64_t imm) {
	// Load immediate - handles 64-bit values
	// For small values, use addi; for larger, build up the value
	if (imm >= -2048 && imm < 2048) {
		// Small immediate: addi rd, x0, imm
		emit_i_type(0x13, rd, 0, REG_ZERO, static_cast<int32_t>(imm));
	} else if (imm >= INT32_MIN && imm <= INT32_MAX) {
		// 32-bit immediate: lui + addi
		int32_t imm32 = static_cast<int32_t>(imm);
		int32_t upper = (imm32 + 0x800) >> 12; // Add 0x800 for rounding
		emit_u_type(0x37, rd, upper << 12);

		int32_t lower = imm32 & 0xFFF;
		if (lower != 0 || upper == 0) {
			emit_i_type(0x13, rd, 0, rd, lower);
		}
	} else {
		// Full 64-bit immediate: load from constant pool appended to .text
		// This avoids using temporary registers and generates cleaner code
		size_t const_index = add_constant(imm);

		// We'll use a label to refer to the constant pool entry
		// The constant will be located at: code_end + (const_index * 8)
		// We use AUIPC to get PC-relative address, then LD to load the value
		std::string label = ".LC" + std::to_string(const_index);

		// Mark this as a use of the constant label
		// Only mark AUIPC since we'll patch both AUIPC and LD together
		size_t auipc_offset = m_code.size();
		mark_label_use(label, auipc_offset);
		emit_u_type(0x17, rd, 0);  // auipc rd, 0 (will be patched)

		// Emit LD instruction (offset will be patched when AUIPC is resolved)
		emit_ld(rd, rd, 0);  // ld rd, 0(rd) (offset will be patched)
	}
}

void RISCVCodeGen::emit_mv(uint8_t rd, uint8_t rs) {
	// mv rd, rs = addi rd, rs, 0
	emit_i_type(0x13, rd, 0, rs, 0);
}

void RISCVCodeGen::emit_addi(uint8_t rd, uint8_t rs1, int32_t imm) {
	emit_i_type(0x13, rd, 0, rs1, imm);
}

void RISCVCodeGen::emit_la(uint8_t rd, const std::string& label) {
	// Load address using AUIPC + ADDI
	// auipc rd, 0  # Load PC-relative upper bits
	// addi rd, rd, offset  # Add lower bits (will be patched)

	size_t auipc_offset = m_code.size();
	mark_label_use(label, auipc_offset);
	emit_u_type(0x17, rd, 0);  // auipc rd, 0 (will be patched)

	// Emit ADDI instruction (offset will be patched when AUIPC is resolved)
	emit_i_type(0x13, rd, 0, rd, 0);  // addi rd, rd, 0 (will be patched)
}

void RISCVCodeGen::emit_add(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 0, rs1, rs2, 0);
}

void RISCVCodeGen::emit_sub(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 0, rs1, rs2, 0x20);
}

void RISCVCodeGen::emit_mul(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 0, rs1, rs2, 1); // RV64M extension
}

void RISCVCodeGen::emit_div(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 4, rs1, rs2, 1); // RV64M extension - div
}

void RISCVCodeGen::emit_rem(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 6, rs1, rs2, 1); // RV64M extension - rem
}

void RISCVCodeGen::emit_and(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 7, rs1, rs2, 0);
}

void RISCVCodeGen::emit_or(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 6, rs1, rs2, 0);
}

void RISCVCodeGen::emit_xor(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 4, rs1, rs2, 0);
}

void RISCVCodeGen::emit_slt(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	emit_r_type(0x33, rd, 2, rs1, rs2, 0);
}

void RISCVCodeGen::emit_xori(uint8_t rd, uint8_t rs, int32_t imm) {
	emit_i_type(0x13, rd, 4, rs, imm); // XORI
}

void RISCVCodeGen::emit_seqz(uint8_t rd, uint8_t rs) {
	// seqz rd, rs is pseudo-instruction for sltiu rd, rs, 1
	emit_i_type(0x13, rd, 3, rs, 1); // SLTIU rd, rs, 1
}

void RISCVCodeGen::emit_snez(uint8_t rd, uint8_t rs) {
	// snez rd, rs is pseudo-instruction for sltu rd, x0, rs
	emit_r_type(0x33, rd, 3, REG_ZERO, rs, 0); // SLTU rd, x0, rs
}

void RISCVCodeGen::emit_beq(uint8_t rs1, uint8_t rs2, int32_t offset) {
	emit_b_type(0x63, 0, rs1, rs2, offset);
}

void RISCVCodeGen::emit_bne(uint8_t rs1, uint8_t rs2, int32_t offset) {
	emit_b_type(0x63, 1, rs1, rs2, offset);
}

void RISCVCodeGen::emit_blt(uint8_t rs1, uint8_t rs2, int32_t offset) {
	emit_b_type(0x63, 4, rs1, rs2, offset);
}

void RISCVCodeGen::emit_bge(uint8_t rs1, uint8_t rs2, int32_t offset) {
	emit_b_type(0x63, 5, rs1, rs2, offset);
}

void RISCVCodeGen::emit_bltu(uint8_t rs1, uint8_t rs2, int32_t offset) {
	emit_b_type(0x63, 6, rs1, rs2, offset);
}

void RISCVCodeGen::emit_bgeu(uint8_t rs1, uint8_t rs2, int32_t offset) {
	emit_b_type(0x63, 7, rs1, rs2, offset);
}

void RISCVCodeGen::emit_jal(uint8_t rd, int32_t offset) {
	emit_j_type(0x6F, rd, offset);
}

void RISCVCodeGen::emit_jalr(uint8_t rd, uint8_t rs1, int32_t offset) {
	emit_i_type(0x67, rd, 0, rs1, offset);
}

void RISCVCodeGen::emit_ecall() {
	// ecall instruction: opcode = 0x73, funct3 = 0, rs1 = 0, rd = 0, imm = 0
	emit_i_type(0x73, 0, 0, 0, 0);
}

void RISCVCodeGen::emit_ret() {
	// ret = jalr x0, x1, 0
	emit_jalr(REG_ZERO, REG_RA, 0);
}

// Label management
void RISCVCodeGen::define_label(const std::string& label) {
	m_labels[label] = m_code.size();
}

void RISCVCodeGen::mark_label_use(const std::string& label, size_t code_offset) {
	m_label_uses.push_back({label, code_offset});
}

void RISCVCodeGen::resolve_labels() {
	for (const auto& use : m_label_uses) {
		const std::string& label = use.first;
		size_t use_offset = use.second;

		auto it = m_labels.find(label);
		if (it == m_labels.end()) {
			throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Undefined label: " + label);
		}

		size_t target_offset = it->second;
		int32_t offset = static_cast<int32_t>(target_offset - use_offset);

		// Patch the instruction at use_offset with the correct offset
		uint32_t instr;
		memcpy(&instr, &m_code[use_offset], 4);

		uint8_t opcode = instr & 0x7F;

		if (opcode == 0x63) { // B-type (branch)
			// Re-encode with correct offset
			uint8_t funct3 = (instr >> 12) & 0x7;
			uint8_t rs1 = (instr >> 15) & 0x1F;
			uint8_t rs2 = (instr >> 20) & 0x1F;

			uint32_t imm12 = (offset >> 12) & 1;
			uint32_t imm10_5 = (offset >> 5) & 0x3F;
			uint32_t imm4_1 = (offset >> 1) & 0xF;
			uint32_t imm11 = (offset >> 11) & 1;

			instr = opcode | (imm11 << 7) | (imm4_1 << 8) | (funct3 << 12) | (rs1 << 15) | (rs2 << 20) | (imm10_5 << 25) | (imm12 << 31);
		} else if (opcode == 0x6F) { // J-type (jal)
			uint8_t rd = (instr >> 7) & 0x1F;

			uint32_t imm20 = (offset >> 20) & 1;
			uint32_t imm10_1 = (offset >> 1) & 0x3FF;
			uint32_t imm11 = (offset >> 11) & 1;
			uint32_t imm19_12 = (offset >> 12) & 0xFF;

			instr = opcode | (rd << 7) | (imm19_12 << 12) | (imm11 << 20) | (imm10_1 << 21) | (imm20 << 31);
		} else if (opcode == 0x17) { // U-type (AUIPC) - for constant pool or address loading
			uint8_t rd = (instr >> 7) & 0x1F;

			// Check if the next instruction is LD (for constant pool) or ADDI (for address)
			uint32_t next_instr;
			memcpy(&next_instr, &m_code[use_offset + 4], 4);
			uint8_t next_opcode = next_instr & 0x7F;

			if (next_opcode == 0x03) { // LD instruction (for constant pool access)
				// Calculate PC-relative offset
				// Split into upper 20 bits (for AUIPC) and lower 12 bits (for LD)
				int32_t upper = (offset + 0x800) >> 12; // Add 0x800 for sign extension
				int32_t lower = offset & 0xFFF;

				// Patch AUIPC with upper 20 bits
				instr = opcode | (rd << 7) | ((upper & 0xFFFFF) << 12);
				memcpy(&m_code[use_offset], &instr, 4);

				// Patch the following LD instruction with lower 12 bits
				// LD is at use_offset + 4
				uint8_t ld_rd = (next_instr >> 7) & 0x1F;
				uint8_t ld_rs1 = (next_instr >> 15) & 0x1F;
				uint8_t ld_funct3 = (next_instr >> 12) & 0x7;
				next_instr = 0x03 | (ld_rd << 7) | (ld_funct3 << 12) | (ld_rs1 << 15) | ((lower & 0xFFF) << 20);
				memcpy(&m_code[use_offset + 4], &next_instr, 4);

				// Skip the next use since we processed both AUIPC and LD together
				continue;
			} else if (next_opcode == 0x13) { // ADDI instruction (for load address)
				// AUIPC + ADDI pattern for load address (emit_la)
				uint8_t addi_funct3 = (next_instr >> 12) & 0x7;
				uint8_t addi_rs1 = (next_instr >> 15) & 0x1F;

				// For AUIPC+ADDI, the offset is the full 32-bit value
				// Split into upper 20 bits (for AUIPC) and lower 12 bits (for ADDI)
				int32_t upper = (offset + 0x800) >> 12; // Add 0x800 for sign extension
				int32_t lower = offset & 0xFFF;

				// Verify ADDI is using the same register as rd (rs1 == rd)
				// This is required for AUIPC+ADDI pattern
				if (addi_rs1 == rd && addi_funct3 == 0) {
					// Patch AUIPC with upper 20 bits
					instr = opcode | (rd << 7) | ((upper & 0xFFFFF) << 12);
					memcpy(&m_code[use_offset], &instr, 4);

					// Patch the following ADDI instruction with lower 12 bits
					uint8_t addi_rd = (next_instr >> 7) & 0x1F;
					next_instr = 0x13 | (addi_rd << 7) | (addi_funct3 << 12) | (addi_rs1 << 15) | ((lower & 0xFFF) << 20);
					memcpy(&m_code[use_offset + 4], &next_instr, 4);

					// Skip the next use since we processed both AUIPC and ADDI together
					continue;
				}
			}
		}

		memcpy(&m_code[use_offset], &instr, 4);
	}
}

int RISCVCodeGen::get_variant_stack_offset(int virtual_reg) {
	auto it = m_variant_offsets.find(virtual_reg);
	if (it != m_variant_offsets.end()) {
		return it->second;
	}

	// Allocate new stack slot for this Variant
	// Stack layout: [saved ra (8)] [saved fp (8)] [saved a0 (8)] [Variants...]
	int offset = 24 + (m_next_variant_slot * VARIANT_SIZE);
	m_variant_offsets[virtual_reg] = offset;
	m_next_variant_slot++;

	return offset;
}

void RISCVCodeGen::emit_variant_create_int(int stack_offset, int64_t value) {
	// Create an integer Variant on the stack
	// Variant layout: [uint32_t m_type (4 bytes)] [padding (4 bytes)] [int64_t v.i (8 bytes)]

	// Store m_type = INT (2) at stack_offset
	emit_li(REG_T0, 2); // INT type
	emit_store_variant_type(REG_T0, REG_SP, stack_offset);

	// Store value
	emit_li(REG_T0, value);
	emit_store_variant_int(REG_T0, REG_SP, stack_offset);
}

void RISCVCodeGen::emit_variant_create_bool(int stack_offset, bool value) {
	// Similar to create_int but with BOOL type (1)
	emit_li(REG_T0, 1); // BOOL type
	emit_store_variant_type(REG_T0, REG_SP, stack_offset);

	emit_li(REG_T0, value ? 1 : 0);
	emit_store_variant_bool(REG_T0, REG_SP, stack_offset);
}

void RISCVCodeGen::emit_variant_create_string(int stack_offset, int string_idx) {
	// Create a string Variant using VCREATE syscall
	// VCREATE signature: void vcreate(Variant* dst, Variant::Type type, int method, void* data)
	// For strings with method==1: data = struct { const char* str; size_t length; }

	if (!m_string_constants || string_idx < 0 || string_idx >= static_cast<int>(m_string_constants->size())) {
		throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Invalid string constant index: " + std::to_string(string_idx));
	}

	const std::string& str = (*m_string_constants)[string_idx];
	int str_len = static_cast<int>(str.length());

	// Handle register clobbering (VCREATE uses a0-a3)
	std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
	auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);
	for (const auto& move : moves) {
		emit_mv(move.second, move.first);
	}

	// Allocate stack space for: string data + struct { char*, size_t }
	int str_space = ((str_len + 1) + 7) & ~7; // String + null terminator, aligned to 8 bytes
	int struct_space = 16; // Two 8-byte fields
	int total_space = str_space + struct_space;
	total_space = (total_space + 15) & ~15; // Align to 16 bytes

	// Adjust stack pointer
	if (total_space < 2048) {
		emit_i_type(0x13, REG_SP, 0, REG_SP, -total_space);
	} else {
		emit_li(REG_T0, -total_space);
		emit_add(REG_SP, REG_SP, REG_T0);
	}

	// Store string data on stack
	for (size_t i = 0; i < str.length(); i++) {
		emit_li(REG_T0, static_cast<unsigned char>(str[i]));
		emit_sb(REG_T0, REG_SP, i); // SB (store byte)
	}
	// Store null terminator
	emit_sb(REG_ZERO, REG_SP, str_len); // SB

	// Create struct at sp + str_space
	// struct.str = sp (pointer to string data)
	if (str_space < 2048) {
		emit_i_type(0x13, REG_T0, 0, REG_SP, 0); // T0 = SP + 0 (pointer to string)
	} else {
		emit_mv(REG_T0, REG_SP);
	}
	emit_sd(REG_T0, REG_SP, str_space); // SD (store pointer at sp + str_space)

	// struct.length = str_len
	emit_li(REG_T0, str_len);
	emit_sd(REG_T0, REG_SP, str_space + 8); // SD (store length)

	// Call VCREATE
	// a0 = pointer to destination Variant (stack_offset + total_space)
	int adjusted_dst_offset = stack_offset + total_space;
	if (adjusted_dst_offset < 2048) {
		emit_i_type(0x13, REG_A0, 0, REG_SP, adjusted_dst_offset);
	} else {
		emit_li(REG_A0, adjusted_dst_offset);
		emit_add(REG_A0, REG_SP, REG_A0);
	}

	// a1 = Variant::STRING
	emit_li(REG_A1, Variant::STRING);

	// a2 = method (1 for const char* + size_t)
	emit_li(REG_A2, 1);

	// a3 = pointer to struct (sp + str_space)
	if (str_space < 2048) {
		emit_i_type(0x13, REG_A3, 0, REG_SP, str_space);
	} else {
		emit_li(REG_A3, str_space);
		emit_add(REG_A3, REG_SP, REG_A3);
	}

	// a7 = ECALL_VCREATE (517)
	emit_li(REG_A7, 517);
	emit_ecall();

	// Restore stack pointer
	if (total_space < 2048) {
		emit_i_type(0x13, REG_SP, 0, REG_SP, total_space);
	} else {
		emit_li(REG_T0, total_space);
		emit_add(REG_SP, REG_SP, REG_T0);
	}
}

void RISCVCodeGen::emit_vcreate_syscall(int variant_type, int method, uint8_t data_ptr_reg, int result_offset) {
	// Generic VCREATE syscall emission
	// VCREATE signature: void vcreate(Variant* dst, Variant::Type type, int method, void* data)
	// This handles register clobbering for a0-a3

	// Handle register clobbering (VCREATE uses a0-a3)
	std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
	auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);
	for (const auto& move : moves) {
		emit_mv(move.second, move.first);
	}

	// a0 = pointer to destination Variant (result_offset from SP)
	if (result_offset < 2048) {
		emit_i_type(0x13, REG_A0, 0, REG_SP, result_offset);
	} else {
		emit_li(REG_A0, result_offset);
		emit_add(REG_A0, REG_SP, REG_A0);
	}

	// a1 = Variant::Type
	emit_li(REG_A1, variant_type);

	// a2 = method
	emit_li(REG_A2, method);

	// a3 = data pointer (already in data_ptr_reg, or REG_ZERO for null)
	if (data_ptr_reg != REG_A3) {
		emit_mv(REG_A3, data_ptr_reg);
	}

	// a7 = ECALL_VCREATE (517)
	emit_li(REG_A7, 517);
	emit_ecall();
}

void RISCVCodeGen::emit_variant_create_empty_array(int stack_offset) {
	// Create empty Array using VCREATE syscall
	// sys_vcreate(&v, ARRAY, 0, nullptr)
	emit_vcreate_syscall(Variant::ARRAY, 0, REG_ZERO, stack_offset);
}

void RISCVCodeGen::emit_variant_create_empty_dictionary(int stack_offset) {
	// Create empty Dictionary using VCREATE syscall
	// sys_vcreate(&v, DICTIONARY, 0, nullptr)
	emit_vcreate_syscall(Variant::DICTIONARY, 0, REG_ZERO, stack_offset);
}

void RISCVCodeGen::emit_variant_copy(int dst_offset, int src_offset) {
	// Copy 24 bytes from src to dst
	for (int i = 0; i < 3; i++) {
		// Load from source
		emit_ld(REG_T0, REG_SP, src_offset + i * 8); // LD

		// Store to destination
		emit_sd(REG_T0, REG_SP, dst_offset + i * 8); // SD
	}
}

void RISCVCodeGen::emit_variant_eval(int result_offset, int lhs_offset, int rhs_offset, int op) {
	// Call sys_veval(op, &lhs, &rhs, &result)
	// Signature: bool sys_veval(int op, const Variant* a, const Variant* b, Variant* result)

	// VEVAL clobbers a0-a3, so handle register clobbering first
	std::vector<uint8_t> clobbered_regs = {REG_A0, REG_A1, REG_A2, REG_A3};
	auto moves = m_allocator.handle_syscall_clobbering(clobbered_regs, m_current_instr_idx);

	// Emit moves to save live values from clobbered registers
	for (const auto& move : moves) {
		emit_mv(move.second, move.first); // Move from clobbered reg to new reg
	}

	// Load operator into a0
	emit_li(REG_A0, op);

	// Load address of lhs Variant into a1: addi a1, sp, lhs_offset
	if (lhs_offset < 2048) {
		emit_i_type(0x13, REG_A1, 0, REG_SP, lhs_offset);
	} else {
		emit_li(REG_A1, lhs_offset);
		emit_add(REG_A1, REG_SP, REG_A1);
	}

	// Load address of rhs Variant into a2: addi a2, sp, rhs_offset
	if (rhs_offset < 2048) {
		emit_i_type(0x13, REG_A2, 0, REG_SP, rhs_offset);
	} else {
		emit_li(REG_A2, rhs_offset);
		emit_add(REG_A2, REG_SP, REG_A2);
	}

	// Load address of result Variant into a3: addi a3, sp, result_offset
	if (result_offset < 2048) {
		emit_i_type(0x13, REG_A3, 0, REG_SP, result_offset);
	} else {
		emit_li(REG_A3, result_offset);
		emit_add(REG_A3, REG_SP, REG_A3);
	}

	// Make the ecall to sys_veval (ECALL_VEVAL = 502)
	emit_li(REG_A7, 502); // ECALL_VEVAL
	emit_ecall();
}

void RISCVCodeGen::emit_typed_int_binary_op(int result_offset, int lhs_offset, int rhs_offset, IROpcode op) {
	// Optimized path for type-hinted integer arithmetic
	// Instead of calling VEVAL syscall, we:
	// 1. Load int64 values from Variants directly (from v.i field at offset +8)
	// 2. Perform native RISC-V arithmetic in registers
	// 3. Store result back as an INT Variant
	//
	// This is safe because:
	// - Type hints are verified by the parser
	// - Variant int64 field is well-defined at VARIANT_DATA_OFFSET
	// - We maintain Variant structure for ABI compatibility

	// Load lhs int64 value: ld t0, lhs_offset+8(sp)
	emit_load_variant_int(REG_T0, REG_SP, lhs_offset);

	// Load rhs int64 value: ld t1, rhs_offset+8(sp)
	emit_load_variant_int(REG_T1, REG_SP, rhs_offset);

	// Perform the operation in REG_T2
	switch (op) {
		case IROpcode::ADD:
			emit_add(REG_T2, REG_T0, REG_T1);
			break;
		case IROpcode::SUB:
			emit_sub(REG_T2, REG_T0, REG_T1);
			break;
		case IROpcode::MUL:
			emit_mul(REG_T2, REG_T0, REG_T1);
			break;
		case IROpcode::DIV:
			// Note: RISC-V div by zero produces -1 (all bits set) for positive dividend
			// This matches Variant behavior which should be checked at runtime
			emit_div(REG_T2, REG_T0, REG_T1);
			break;
		case IROpcode::MOD:
			emit_rem(REG_T2, REG_T0, REG_T1);
			break;
		default:
			throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported typed int binary op");
	}

	// Store result as INT Variant
	// Set type to INT (2)
	emit_li(REG_T0, Variant::INT);
	emit_store_variant_type(REG_T0, REG_SP, result_offset);

	// Store computed value to v.i field
	emit_store_variant_int(REG_T2, REG_SP, result_offset);
}

void RISCVCodeGen::emit_typed_int_comparison(int result_offset, int lhs_offset, int rhs_offset, IROpcode cmp_op) {
	// Optimized path for type-hinted integer comparisons
	// Common in loops: for i: int in range(N)
	//
	// Process:
	// 1. Load int64 values from Variants
	// 2. Perform RISC-V comparison
	// 3. Store result as BOOL Variant (0 or 1)

	// Load lhs and rhs int64 values
	emit_load_variant_int(REG_T0, REG_SP, lhs_offset);
	emit_load_variant_int(REG_T1, REG_SP, rhs_offset);

	// Perform comparison and set REG_T2 to 0 or 1
	switch (cmp_op) {
		case IROpcode::CMP_EQ:
			// xor t2, t0, t1; seqz t2, t2  (set if equal to zero)
			emit_xor(REG_T2, REG_T0, REG_T1);
			emit_seqz(REG_T2, REG_T2);
			break;

		case IROpcode::CMP_NEQ:
			// xor t2, t0, t1; snez t2, t2  (set if not equal to zero)
			emit_xor(REG_T2, REG_T0, REG_T1);
			emit_snez(REG_T2, REG_T2);
			break;

		case IROpcode::CMP_LT:
			// slt t2, t0, t1  (set if t0 < t1, signed)
			emit_slt(REG_T2, REG_T0, REG_T1);
			break;

		case IROpcode::CMP_LTE:
			// t0 <= t1  is equivalent to  !(t1 < t0)
			// slt t2, t1, t0; xori t2, t2, 1
			emit_slt(REG_T2, REG_T1, REG_T0);
			emit_xori(REG_T2, REG_T2, 1);
			break;

		case IROpcode::CMP_GT:
			// t0 > t1  is equivalent to  t1 < t0
			emit_slt(REG_T2, REG_T1, REG_T0);
			break;

		case IROpcode::CMP_GTE:
			// t0 >= t1  is equivalent to  !(t0 < t1)
			// slt t2, t0, t1; xori t2, t2, 1
			emit_slt(REG_T2, REG_T0, REG_T1);
			emit_xori(REG_T2, REG_T2, 1);
			break;

		default:
			throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported typed int comparison");
	}

	// Store result as BOOL Variant
	emit_li(REG_T0, Variant::BOOL);
	emit_store_variant_type(REG_T0, REG_SP, result_offset);
	emit_store_variant_bool(REG_T2, REG_SP, result_offset);
}

void RISCVCodeGen::emit_typed_float_binary_op(int result_offset, int lhs_offset, int rhs_offset, IROpcode op) {
	// Optimized path for type-hinted float (double) arithmetic
	// IMPORTANT: Variant v.f is ALWAYS 64-bit double, not real_t
	//
	// Process:
	// 1. Load double values from Variants (at offset +8)
	// 2. Perform native RISC-V double-precision FP arithmetic
	// 3. Store result back as a FLOAT Variant
	//
	// This avoids VEVAL syscall overhead for typed float operations

	// Load lhs double value: fld fa0, lhs_offset+8(sp)
	emit_fld(REG_FA0, REG_SP, lhs_offset + VARIANT_DATA_OFFSET);

	// Load rhs double value: fld fa1, rhs_offset+8(sp)
	emit_fld(REG_FA1, REG_SP, rhs_offset + VARIANT_DATA_OFFSET);

	// Perform the double-precision FP operation in REG_FA2
	switch (op) {
		case IROpcode::ADD:
			emit_fadd_d(REG_FA2, REG_FA0, REG_FA1);
			break;
		case IROpcode::SUB:
			emit_fsub_d(REG_FA2, REG_FA0, REG_FA1);
			break;
		case IROpcode::MUL:
			emit_fmul_d(REG_FA2, REG_FA0, REG_FA1);
			break;
		case IROpcode::DIV:
			emit_fdiv_d(REG_FA2, REG_FA0, REG_FA1);
			break;
		default:
			throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported typed float binary op");
	}

	// Store result as FLOAT Variant
	// Set type to FLOAT (3)
	emit_li(REG_T0, Variant::FLOAT);
	emit_store_variant_type(REG_T0, REG_SP, result_offset);

	// Store computed double value to v.f field
	emit_fsd(REG_FA2, REG_SP, result_offset + VARIANT_DATA_OFFSET);
}

void RISCVCodeGen::emit_typed_vector_binary_op(int result_offset, int lhs_offset, int rhs_offset, IROpcode op, IRInstruction::TypeHint type_hint) {
	// Optimized path for type-hinted vector arithmetic
	// Vectors are stored inline in Variant's data union:
	// - VECTOR2/3/4: real_t v4[4] (32-bit float by default)
	// - VECTOR2I/3I/4I: int32_t v4i[4]
	//
	// Process:
	// 1. Determine element count (2, 3, or 4) and type (int32 vs real_t)
	// 2. Loop over components, performing element-wise arithmetic
	// 3. Store result back with proper Variant type
	//
	// This is game math - Vector3 * Vector3 means component-wise multiplication

	// Determine vector properties
	int elem_count = 0;
	bool is_int = false;

	switch (type_hint) {
		case Variant::VECTOR2:
			elem_count = 2;
			is_int = false;
			break;
		case Variant::VECTOR2I:
			elem_count = 2;
			is_int = true;
			break;
		case Variant::VECTOR3:
			elem_count = 3;
			is_int = false;
			break;
		case Variant::VECTOR3I:
			elem_count = 3;
			is_int = true;
			break;
		case Variant::VECTOR4:
		case Variant::COLOR:  // Color is also 4 real_t components
			elem_count = 4;
			is_int = false;
			break;
		case Variant::VECTOR4I:
			elem_count = 4;
			is_int = true;
			break;
		default:
			throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Invalid vector type hint");
	}

	// Perform element-wise operations
	for (int i = 0; i < elem_count; i++) {
		// Component offset: VARIANT_DATA_OFFSET + i * 4 bytes
		// (both int32_t and real_t are 4 bytes in default config)
		int component_offset = VARIANT_DATA_OFFSET + i * 4;

		if (is_int) {
			// Integer vector: use lw/sw and integer ALU
			emit_lw(REG_T0, REG_SP, lhs_offset + component_offset);
			emit_lw(REG_T1, REG_SP, rhs_offset + component_offset);

			// Perform integer operation
			switch (op) {
				case IROpcode::ADD:
					emit_add(REG_T2, REG_T0, REG_T1);
					break;
				case IROpcode::SUB:
					emit_sub(REG_T2, REG_T0, REG_T1);
					break;
				case IROpcode::MUL:
					emit_mul(REG_T2, REG_T0, REG_T1);
					break;
				case IROpcode::DIV:
					emit_div(REG_T2, REG_T0, REG_T1);
					break;
				case IROpcode::MOD:
					emit_rem(REG_T2, REG_T0, REG_T1);
					break;
				default:
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported vector int operation");
			}

			// Store result component
			emit_sw(REG_T2, REG_SP, result_offset + component_offset);
		} else {
			// Float vector: use flw/fsw and FP ALU (real_t = 32-bit float)
			emit_flw(REG_FA0, REG_SP, lhs_offset + component_offset);
			emit_flw(REG_FA1, REG_SP, rhs_offset + component_offset);

			// Perform single-precision FP operation
			switch (op) {
				case IROpcode::ADD:
					emit_fadd_s(REG_FA2, REG_FA0, REG_FA1);
					break;
				case IROpcode::SUB:
					emit_fsub_s(REG_FA2, REG_FA0, REG_FA1);
					break;
				case IROpcode::MUL:
					emit_fmul_s(REG_FA2, REG_FA0, REG_FA1);
					break;
				case IROpcode::DIV:
					emit_fdiv_s(REG_FA2, REG_FA0, REG_FA1);
					break;
				default:
					throw CompilerException(ErrorType::RISCV_codegen_ERROR, "Unsupported vector float operation");
			}

			// Store result component
			emit_fsw(REG_FA2, REG_SP, result_offset + component_offset);
		}
	}

	// Set result Variant type
	emit_li(REG_T0, type_hint);
	emit_store_variant_type(REG_T0, REG_SP, result_offset);
}

// Variant field access helpers
void RISCVCodeGen::emit_load_variant_type(uint8_t rd, uint8_t base_reg, int32_t variant_offset) {
	// Load m_type field (4 bytes at variant_offset + 0)
	emit_lw(rd, base_reg, variant_offset + VARIANT_TYPE_OFFSET);
}

void RISCVCodeGen::emit_store_variant_type(uint8_t rs, uint8_t base_reg, int32_t variant_offset) {
	// Store m_type field (4 bytes at variant_offset + 0)
	emit_sw(rs, base_reg, variant_offset + VARIANT_TYPE_OFFSET);
}

void RISCVCodeGen::emit_load_variant_bool(uint8_t rd, uint8_t base_reg, int32_t variant_offset) {
	// Load boolean value (1 byte at variant_offset + 8)
	// Use unsigned load to ensure proper zero-extension
	emit_lbu(rd, base_reg, variant_offset + VARIANT_DATA_OFFSET);
}

void RISCVCodeGen::emit_store_variant_bool(uint8_t rs, uint8_t base_reg, int32_t variant_offset) {
	// Store boolean value (1 byte at variant_offset + 8)
	// Note: storing 8 bytes is fine too since bool is in a union, but byte is more precise
	emit_sb(rs, base_reg, variant_offset + VARIANT_DATA_OFFSET);
}

void RISCVCodeGen::emit_load_variant_int(uint8_t rd, uint8_t base_reg, int32_t variant_offset) {
	// Load int64 value (8 bytes at variant_offset + 8)
	emit_ld(rd, base_reg, variant_offset + VARIANT_DATA_OFFSET);
}

void RISCVCodeGen::emit_store_variant_int(uint8_t rs, uint8_t base_reg, int32_t variant_offset) {
	// Store int64 value (8 bytes at variant_offset + 8)
	emit_sd(rs, base_reg, variant_offset + VARIANT_DATA_OFFSET);
}

// Load/Store helpers with automatic large offset handling
void RISCVCodeGen::emit_ld(uint8_t rd, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x03, rd, 3, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x03, rd, 3, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_lw(uint8_t rd, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x03, rd, 2, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x03, rd, 2, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_lwu(uint8_t rd, uint8_t rs1, int32_t offset) {
	// LWU (Load Word Unsigned) - RV64I specific, zero-extends to 64 bits
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x03, rd, 4, rs1, offset);  // funct3=4 for LWU
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x03, rd, 4, REG_T2, 0);  // funct3=4 for LWU
	}
}

void RISCVCodeGen::emit_lh(uint8_t rd, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x03, rd, 1, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x03, rd, 1, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_lb(uint8_t rd, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x03, rd, 0, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x03, rd, 0, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_lbu(uint8_t rd, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x03, rd, 4, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x03, rd, 4, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_sd(uint8_t rs2, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_s_type(0x23, 3, rs1, rs2, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_s_type(0x23, 3, REG_T2, rs2, 0);
	}
}

void RISCVCodeGen::emit_sw(uint8_t rs2, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_s_type(0x23, 2, rs1, rs2, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_s_type(0x23, 2, REG_T2, rs2, 0);
	}
}

void RISCVCodeGen::emit_sh(uint8_t rs2, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_s_type(0x23, 1, rs1, rs2, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_s_type(0x23, 1, REG_T2, rs2, 0);
	}
}

void RISCVCodeGen::emit_sb(uint8_t rs2, uint8_t rs1, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_s_type(0x23, 0, rs1, rs2, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_s_type(0x23, 0, REG_T2, rs2, 0);
	}
}

// Floating-point load/store (RV64D extension)
void RISCVCodeGen::emit_fld(uint8_t rd, uint8_t rs1, int32_t offset) {
	// FLD: opcode=0x07, funct3=3
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x07, rd, 3, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x07, rd, 3, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_fsd(uint8_t rs2, uint8_t rs1, int32_t offset) {
	// FSD: opcode=0x27, funct3=3
	if (offset >= -2048 && offset < 2048) {
		emit_s_type(0x27, 3, rs1, rs2, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_s_type(0x27, 3, REG_T2, rs2, 0);
	}
}

void RISCVCodeGen::emit_flw(uint8_t rd, uint8_t rs1, int32_t offset) {
	// FLW: opcode=0x07, funct3=2 (RV32F/RV64F)
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x07, rd, 2, rs1, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_i_type(0x07, rd, 2, REG_T2, 0);
	}
}

void RISCVCodeGen::emit_fsw(uint8_t rs2, uint8_t rs1, int32_t offset) {
	// FSW: opcode=0x27, funct3=2 (RV32F/RV64F)
	if (offset >= -2048 && offset < 2048) {
		emit_s_type(0x27, 2, rs1, rs2, offset);
	} else {
		emit_li(REG_T2, offset);
		emit_add(REG_T2, rs1, REG_T2);
		emit_s_type(0x27, 2, REG_T2, rs2, 0);
	}
}

void RISCVCodeGen::emit_fcvt_d_s(uint8_t rd, uint8_t rs1) {
	// FCVT.D.S: Convert float (32-bit) to double (64-bit)
	emit_r4_type(0b1010011, rd, 0, rs1, 0, 0b01000, 1);
}

void RISCVCodeGen::emit_fcvt_s_d(uint8_t rd, uint8_t rs1) {
	// FCVT.S.D: Convert double (64-bit) to float (32-bit)
	emit_r4_type(0b1010011, rd, 0, rs1, 1, 0b01000, 0);
}

void RISCVCodeGen::emit_fcvt_d_l(uint8_t rd, uint8_t rs1) {
	// FCVT.D.L: Convert signed 64-bit integer to double
	emit_r4_type(0b1010011, rd, 0, rs1, 2, 0b11010, 1);
}

void RISCVCodeGen::emit_fadd_d(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FADD.D: Double-precision FP add
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x01);
}

void RISCVCodeGen::emit_fsub_d(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FSUB.D: Double-precision FP subtract
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x05);
}

void RISCVCodeGen::emit_fmul_d(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FMUL.D: Double-precision FP multiply
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x09);
}

void RISCVCodeGen::emit_fdiv_d(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FDIV.D: Double-precision FP divide
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x0D);
}

void RISCVCodeGen::emit_fmv_d(uint8_t rd, uint8_t rs) {
	// FMV.D: Double-precision FP move
	// FSGNJ.D with rs1=rs2 implements move
	emit_r4_type(0x53, rd, 0x0, rs, rs, 0b00100, 1);
}

void RISCVCodeGen::emit_fadd_s(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FADD.S: Single-precision FP add
	// funct7=0x00 for single-precision (vs 0x01 for double)
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x00);
}

void RISCVCodeGen::emit_fsub_s(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FSUB.S: Single-precision FP subtract
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x04);
}

void RISCVCodeGen::emit_fmul_s(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FMUL.S: Single-precision FP multiply
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x08);
}

void RISCVCodeGen::emit_fdiv_s(uint8_t rd, uint8_t rs1, uint8_t rs2) {
	// FDIV.S: Single-precision FP divide
	emit_r_type(0x53, rd, 0, rs1, rs2, 0x0C);
}

// Sign-extend word to doubleword (addiw rd, rs, 0)
void RISCVCodeGen::emit_sext_w(uint8_t rd, uint8_t rs) {
	// ADDIW: opcode=0x1b, funct3=0
	emit_i_type(0x1b, rd, 0, rs, 0);
}

void RISCVCodeGen::emit_syscall_result(int result_vreg, uint8_t result_reg, int result_offset, int variant_type) {
	// Always store to stack as Variant
	emit_li(REG_T0, variant_type);
	emit_sw(REG_T0, REG_SP, result_offset); // Store 4-byte type
	emit_sd(result_reg, REG_SP, result_offset + 8); // Store 8-byte integer at offset 8
}

void RISCVCodeGen::emit_stack_adjust(int32_t amount) {
	if (amount >= -2048 && amount < 2048) {
		emit_i_type(0x13, REG_SP, 0, REG_SP, amount);
	} else {
		emit_li(REG_T0, amount);
		emit_add(REG_SP, REG_SP, REG_T0);
	}
}

void RISCVCodeGen::emit_load_stack_offset(uint8_t rd, int32_t offset) {
	if (offset >= -2048 && offset < 2048) {
		emit_i_type(0x13, rd, 0, REG_SP, offset);
	} else {
		emit_li(REG_T0, offset);
		emit_add(rd, REG_SP, REG_T0);
	}
}

bool RISCVCodeGen::is_complex_variant_type(int variant_type) {
	// Simple/inline types that DON'T need permanent storage:
	// NIL, BOOL, INT, FLOAT, Vector2/3/4, Vector2/3/4i, Color, Rect2/2i, Plane
	// Everything else (String, Array, Dictionary, Object, packed arrays, etc.) needs permanent storage
	switch (variant_type) {
		case Variant::NIL:
		case Variant::BOOL:
		case Variant::INT:
		case Variant::FLOAT:
		case Variant::VECTOR2:
		case Variant::VECTOR2I:
		case Variant::VECTOR3:
		case Variant::VECTOR3I:
		case Variant::VECTOR4:
		case Variant::VECTOR4I:
		case Variant::RECT2:
		case Variant::RECT2I:
		case Variant::PLANE:
		case Variant::COLOR:
			return false; // These are simple inline types
		default:
			return true; // Everything else is complex and needs permanent storage
	}
}

} // namespace gdscript

```

`src/gdscript/compiler/riscv_codegen.h`:

```h
#pragma once
#include "ir.h"
#include "register_allocator.h"
#include <unordered_set>
#include <cstdint>

namespace gdscript {

// RISC-V instruction encoder
class RISCVCodeGen {
public:
	RISCVCodeGen();

	// Generate RISC-V machine code from IR
	std::vector<uint8_t> generate(const IRProgram& program);

	// Get function offsets (name -> offset in code)
	const std::unordered_map<std::string, size_t>& get_function_offsets() const { return m_functions; }

	// Get register allocator (for testing)
	const RegisterAllocator& get_allocator() const { return m_allocator; }

	// Get constant pool (for ELF builder to create .rodata section)
	const std::vector<int64_t>& get_constant_pool() const { return m_constant_pool; }

	// Get global variables information
	const std::vector<IRGlobalVar>& get_globals() const { return m_globals; }
	size_t get_global_data_size() const { return m_global_data_size; }

private:
	struct Function {
		std::string name;
		size_t offset; // Offset in code section
	};

	// Generate code for a single function
	void gen_function(const IRFunction& func);

	// Instruction emission
	void emit_word(uint32_t word);  // Emit raw 32-bit word
	void emit_r_type(uint8_t opcode, uint8_t rd, uint8_t funct3, uint8_t rs1, uint8_t rs2, uint8_t funct7);
	void emit_i_type(uint8_t opcode, uint8_t rd, uint8_t funct3, uint8_t rs1, int32_t imm);
	void emit_s_type(uint8_t opcode, uint8_t funct3, uint8_t rs1, uint8_t rs2, int32_t imm);
	void emit_b_type(uint8_t opcode, uint8_t funct3, uint8_t rs1, uint8_t rs2, int32_t imm);
	void emit_u_type(uint8_t opcode, uint8_t rd, uint32_t imm);
	void emit_j_type(uint8_t opcode, uint8_t rd, int32_t imm);
	void emit_r4_type(uint8_t opcode, uint8_t rd, uint8_t funct3, uint8_t rs1, uint8_t rs2, uint8_t rs3, uint8_t funct2);

	// Higher-level RISC-V instructions
	void emit_li(uint8_t rd, int64_t imm);      // Load immediate
	void emit_la(uint8_t rd, const std::string& label); // Load address (pseudo: auipc + addi)
	void emit_mv(uint8_t rd, uint8_t rs);       // Move
	void emit_addi(uint8_t rd, uint8_t rs1, int32_t imm); // Add immediate
	void emit_add(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_sub(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_mul(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_div(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_rem(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_and(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_or(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_xor(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_xori(uint8_t rd, uint8_t rs, int32_t imm);  // XOR immediate
	void emit_slt(uint8_t rd, uint8_t rs1, uint8_t rs2);
	void emit_seqz(uint8_t rd, uint8_t rs);   // Set if equal to zero (pseudo: sltiu rd, rs, 1)
	void emit_snez(uint8_t rd, uint8_t rs);   // Set if not equal to zero (pseudo: sltu rd, x0, rs)
	void emit_beq(uint8_t rs1, uint8_t rs2, int32_t offset);
	void emit_bne(uint8_t rs1, uint8_t rs2, int32_t offset);
	void emit_blt(uint8_t rs1, uint8_t rs2, int32_t offset);
	void emit_bge(uint8_t rs1, uint8_t rs2, int32_t offset);
	void emit_bltu(uint8_t rs1, uint8_t rs2, int32_t offset);
	void emit_bgeu(uint8_t rs1, uint8_t rs2, int32_t offset);
	void emit_jal(uint8_t rd, int32_t offset);
	void emit_jalr(uint8_t rd, uint8_t rs1, int32_t offset);
	void emit_ecall();
	void emit_ret();

	// Load/Store instructions (with automatic large offset handling)
	void emit_ld(uint8_t rd, uint8_t rs1, int32_t offset);   // Load doubleword (64-bit)
	void emit_lw(uint8_t rd, uint8_t rs1, int32_t offset);   // Load word (32-bit)
	void emit_lwu(uint8_t rd, uint8_t rs1, int32_t offset);  // Load word unsigned (32-bit, zero-extended to 64-bit)
	void emit_lh(uint8_t rd, uint8_t rs1, int32_t offset);   // Load halfword (16-bit)
	void emit_lb(uint8_t rd, uint8_t rs1, int32_t offset);   // Load byte (8-bit signed)
	void emit_lbu(uint8_t rd, uint8_t rs1, int32_t offset);  // Load byte unsigned (8-bit)
	void emit_sd(uint8_t rs2, uint8_t rs1, int32_t offset);  // Store doubleword (64-bit)
	void emit_sw(uint8_t rs2, uint8_t rs1, int32_t offset);  // Store word (32-bit)
	void emit_sh(uint8_t rs2, uint8_t rs1, int32_t offset);  // Store halfword (16-bit)
	void emit_sb(uint8_t rs2, uint8_t rs1, int32_t offset);  // Store byte (8-bit)

	// Floating-point load/store (RV64D extension)
	void emit_fld(uint8_t rd, uint8_t rs1, int32_t offset);  // Load double (64-bit FP)
	void emit_fsd(uint8_t rs2, uint8_t rs1, int32_t offset); // Store double (64-bit FP)
	void emit_flw(uint8_t rd, uint8_t rs1, int32_t offset);  // Load float (32-bit FP)
	void emit_fsw(uint8_t rs2, uint8_t rs1, int32_t offset); // Store float (32-bit FP)
	void emit_fcvt_d_s(uint8_t rd, uint8_t rs1);             // Convert float to double
	void emit_fcvt_s_d(uint8_t rd, uint8_t rs1);             // Convert double to float
	void emit_fcvt_d_l(uint8_t rd, uint8_t rs1);             // Convert signed 64-bit int to double

	// FP arithmetic instructions (RV64D extension - double precision)
	void emit_fadd_d(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Double-precision FP add
	void emit_fsub_d(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Double-precision FP sub
	void emit_fmul_d(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Double-precision FP mul
	void emit_fdiv_d(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Double-precision FP div
	void emit_fmv_d(uint8_t rd, uint8_t rs);                // Double-precision FP move

	// FP arithmetic instructions (RV32F extension - single precision)
	void emit_fadd_s(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Single-precision FP add
	void emit_fsub_s(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Single-precision FP sub
	void emit_fmul_s(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Single-precision FP mul
	void emit_fdiv_s(uint8_t rd, uint8_t rs1, uint8_t rs2);  // Single-precision FP div

	// Additional integer instructions
	void emit_sext_w(uint8_t rd, uint8_t rs);  // Sign-extend word to doubleword (addiw rd, rs, 0)

	// Pseudo-instructions
	void emit_call(const std::string& func_name);
	void emit_jump(const std::string& label);

	// Label management
	void define_label(const std::string& label);
	void mark_label_use(const std::string& label, size_t code_offset);
	void resolve_labels();

	// Variant field access helpers
	// Load/store Variant fields with proper types and offsets
	void emit_load_variant_type(uint8_t rd, uint8_t base_reg, int32_t variant_offset);
	void emit_store_variant_type(uint8_t rs, uint8_t base_reg, int32_t variant_offset);
	void emit_load_variant_bool(uint8_t rd, uint8_t base_reg, int32_t variant_offset);
	void emit_store_variant_bool(uint8_t rs, uint8_t base_reg, int32_t variant_offset);
	void emit_load_variant_int(uint8_t rd, uint8_t base_reg, int32_t variant_offset);
	void emit_store_variant_int(uint8_t rs, uint8_t base_reg, int32_t variant_offset);

	// Variant management
	void emit_variant_create_int(int stack_offset, int64_t value);
	void emit_variant_create_bool(int stack_offset, bool value);
	void emit_variant_create_string(int stack_offset, int string_idx);
	void emit_variant_copy(int dst_offset, int src_offset);
	void emit_variant_eval(int result_offset, int lhs_offset, int rhs_offset, int op);

	// VCREATE syscall abstraction
	// Generic VCREATE emission that handles register clobbering and stack management
	// variant_type: Variant::Type enum value (e.g., Variant::STRING, Variant::ARRAY)
	// method: Constructor method number (type-specific)
	// data_ptr_reg: Register containing pointer to data (or REG_ZERO for nullptr)
	// result_offset: Stack offset where to create the Variant
	// Note: Caller is responsible for setting up data_ptr_reg before calling
	void emit_vcreate_syscall(int variant_type, int method, uint8_t data_ptr_reg, int result_offset);

	// High-level variant constructors using VCREATE
	// These handle all the setup including data preparation
	void emit_variant_create_empty_array(int stack_offset);
	void emit_variant_create_empty_dictionary(int stack_offset);

	// Typed operations (optimized paths when type hints are available)
	// These emit native RISC-V instructions instead of syscalls
	void emit_typed_int_binary_op(int result_offset, int lhs_offset, int rhs_offset, IROpcode op);
	void emit_typed_int_comparison(int result_offset, int lhs_offset, int rhs_offset, IROpcode cmp_op);
	void emit_typed_float_binary_op(int result_offset, int lhs_offset, int rhs_offset, IROpcode op);
	void emit_typed_vector_binary_op(int result_offset, int lhs_offset, int rhs_offset, IROpcode op, IRInstruction::TypeHint type_hint);

	// Get stack offset for a virtual register (in bytes)
	int get_variant_stack_offset(int virtual_reg);

	// Syscall result handling helpers
	// Store syscall result from register to Variant, with optional register allocation
	// result_vreg: virtual register for the result
	// result_reg: physical register containing the result (e.g., REG_A0 after syscall)
	// result_offset: stack offset for the Variant
	// variant_type: Variant type value (e.g., 2 for INT, 24 for GDOBJECT)
	void emit_syscall_result(int result_vreg, uint8_t result_reg, int result_offset, int variant_type);

	// Stack manipulation helpers
	// Adjust stack pointer by a constant amount (positive or negative)
	// Handles both small immediates (< 2048) and large values
	void emit_stack_adjust(int32_t amount);

	// Load stack pointer offset into a register
	// If offset < 2048, uses addi; otherwise loads into temp register and adds
	void emit_load_stack_offset(uint8_t rd, int32_t offset);

	// Check if a Variant type needs permanent storage (refcounted/complex types)
	static bool is_complex_variant_type(int variant_type);

	// Output buffer
	std::vector<uint8_t> m_code;
	std::unordered_map<std::string, size_t> m_labels;
	std::vector<std::pair<std::string, size_t>> m_label_uses;
	std::unordered_map<std::string, size_t> m_functions;

	// Register allocator
	RegisterAllocator m_allocator;

	// For VARIANT values: virtual_reg -> stack offset
	std::unordered_map<int, int> m_variant_offsets;

	size_t m_num_params = 0; // Number of parameters in current function
	int m_stack_frame_size = 0; // Total stack frame size in bytes
	int m_next_variant_slot = 0; // Next Variant slot to allocate
	int m_current_instr_idx = 0; // Current instruction index for register allocation

	// Variant structure layout constants
	// Variant layout: [uint32_t m_type (4)] [padding (4)] [union data (16)]
	static constexpr int VARIANT_SIZE = 24;           // Total size of Variant struct
	static constexpr int VARIANT_TYPE_OFFSET = 0;     // Offset to m_type field (4 bytes)
	static constexpr int VARIANT_DATA_OFFSET = 8;     // Offset to union data (bool/int64/etc)

	// String constants from IR
	const std::vector<std::string>* m_string_constants = nullptr;

	// Constant pool for large immediates (64-bit values that can't be encoded in instructions)
	std::vector<int64_t> m_constant_pool;
	std::unordered_map<int64_t, size_t> m_constant_pool_map; // value -> index

	// Add a constant to the pool and return its index
	size_t add_constant(int64_t value);

	// Generate a unique local label for internal use
	std::string gen_local_label(const std::string& prefix);

	// Convert a Variant component (at comp_offset) to float and store to dest_offset + store_offset
	// Handles both INT and FLOAT Variants
	// If normalize_by_255 is true, divides integers by 255.0 (for Color components)
	void emit_variant_component_to_float(int comp_offset, int result_offset, int store_offset, bool normalize_by_255 = false);

	// Label counter for generating unique local labels
	int m_label_counter = 0;

	// Global variables
	std::vector<IRGlobalVar> m_globals;
	size_t m_global_count = 0;
	size_t m_global_data_size = 0;

	// Property name strings for @export globals
	// These are stored as: vector of {string_data, label_name}
	std::vector<std::pair<std::string, std::string>> m_property_name_strings;

	// RISC-V RV64I register definitions
	static constexpr uint8_t REG_ZERO = 0;  // x0 - always zero
	static constexpr uint8_t REG_RA = 1;    // x1 - return address
	static constexpr uint8_t REG_SP = 2;    // x2 - stack pointer
	static constexpr uint8_t REG_GP = 3;    // x3 - global pointer
	static constexpr uint8_t REG_TP = 4;    // x4 - thread pointer
	static constexpr uint8_t REG_T0 = 5;    // x5-x7 - temporaries
	static constexpr uint8_t REG_T1 = 6;
	static constexpr uint8_t REG_T2 = 7;
	// x8-x9 are s0-s1 (saved registers)
	// x10-x17 are a0-a7 (argument registers)
	// x18-x27 are s2-s11 (saved registers)
	static constexpr uint8_t REG_T3 = 28;   // x28-x31 - temporaries
	static constexpr uint8_t REG_T4 = 29;
	static constexpr uint8_t REG_T5 = 30;
	static constexpr uint8_t REG_T6 = 31;
	static constexpr uint8_t REG_FP = 8;    // x8 - frame pointer
	static constexpr uint8_t REG_S1 = 9;    // x9 - saved register
	static constexpr uint8_t REG_A0 = 10;   // x10-x17 - arguments/return values
	static constexpr uint8_t REG_A1 = 11;
	static constexpr uint8_t REG_A2 = 12;
	static constexpr uint8_t REG_A3 = 13;
	static constexpr uint8_t REG_A4 = 14;
	static constexpr uint8_t REG_A5 = 15;
	static constexpr uint8_t REG_A6 = 16;
	static constexpr uint8_t REG_A7 = 17;

	static constexpr uint8_t REG_FA0 = 0;  // f0-f1 - floating-point return values
	static constexpr uint8_t REG_FA1 = 1;  // f0-f7 - floating-point arguments
	static constexpr uint8_t REG_FA2 = 2;
	static constexpr uint8_t REG_FA3 = 3;
	static constexpr uint8_t REG_FA4 = 4;
	static constexpr uint8_t REG_FA5 = 5;
	static constexpr uint8_t REG_FA6 = 6;
	static constexpr uint8_t REG_FA7 = 7;
};

} // namespace gdscript

```

`src/gdscript/compiler/test_compiler.cpp`:

```cpp
#include "compiler.h"
#include <iostream>
#include <fstream>
#include <string>

using namespace gdscript;

int main(int argc, char** argv) {
	std::cout << "GDScript to RISC-V Compiler Test" << std::endl;
	std::cout << "=================================" << std::endl << std::endl;

	// Test program: simple function that adds two numbers
	std::string test_source = R"(
func add(a, b):
	return a + b

func test():
	return 123

func sum_to_n(n):
	return n

func main():
	var x = 10
	var y = 20
	return x + y
)";

	std::cout << "Source code:" << std::endl;
	std::cout << test_source << std::endl << std::endl;

	// Compile with all debug output
	CompilerOptions options;
	options.dump_tokens = true;
	options.dump_ast = true;
	options.dump_ir = true;
	options.output_elf = true;
	options.output_path = "test_output.elf";

	Compiler compiler;
	auto elf_data = compiler.compile(test_source, options);

	if (elf_data.empty()) {
		std::cerr << "Compilation failed: " << compiler.get_error() << std::endl;
		return 1;
	}

	std::cout << "=== COMPILATION SUCCESS ===" << std::endl;
	std::cout << "Generated ELF size: " << elf_data.size() << " bytes" << std::endl;

	// Write to file
	if (compiler.compile_to_file(test_source, options.output_path, options)) {
		std::cout << "Output written to: " << options.output_path << std::endl;
	} else {
		std::cerr << "Failed to write output: " << compiler.get_error() << std::endl;
		return 1;
	}

	return 0;
}

```

`src/gdscript/compiler/tests/test_codegen.cpp`:

```cpp
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include "../riscv_codegen.h"
#include "../ir_optimizer.h"
#include "../compiler_exception.h"
#include <cassert>
#include <iostream>

using namespace gdscript;

void test_simple_arithmetic() {
	std::cout << "Testing simple arithmetic..." << std::endl;

	std::string source = R"(func add(a, b):
	return a + b
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);
	assert(ir.functions[0].name == "add");
	assert(ir.functions[0].parameters.size() == 2);
	assert(ir.functions[0].instructions.size() > 0);

	// Should have ADD instruction
	bool has_add = false;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::ADD) {
			has_add = true;
			break;
		}
	}
	assert(has_add);

	std::cout << "  âœ“ Simple arithmetic test passed" << std::endl;
}

void test_variable_operations() {
	std::cout << "Testing variable operations..." << std::endl;

	std::string source = R"(func test():
	var x = 10
	var y = 20
	var sum = x + y
	return sum
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions[0].instructions.size() > 0);

	// Should have LOAD_IMM for constants
	int load_imm_count = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_IMM) {
			load_imm_count++;
		}
	}
	assert(load_imm_count >= 2); // At least for 10 and 20

	std::cout << "  âœ“ Variable operations test passed" << std::endl;
}

void test_control_flow() {
	std::cout << "Testing control flow..." << std::endl;

	std::string source = R"(func abs(x):
	if x < 0:
		return -x
	else:
		return x
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have labels and branches
	bool has_label = false;
	bool has_branch = false;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LABEL) has_label = true;
		if (instr.opcode == IROpcode::BRANCH_ZERO) has_branch = true;
	}

	assert(has_label);
	assert(has_branch);

	std::cout << "  âœ“ Control flow test passed" << std::endl;
}

void test_loop_generation() {
	std::cout << "Testing loop generation..." << std::endl;

	std::string source = R"(func count(n):
	var i = 0
	while i < n:
		i = i + 1
	return i
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have loop label and jump back
	bool has_jump = false;
	int label_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::JUMP) has_jump = true;
		if (instr.opcode == IROpcode::LABEL) label_count++;
	}

	assert(has_jump);
	assert(label_count >= 2); // loop start and end labels

	std::cout << "  âœ“ Loop generation test passed" << std::endl;
}

void test_function_calls() {
	std::cout << "Testing function calls..." << std::endl;

	std::string source = R"(func helper(x):
	return x * 2

func main():
	var result = helper(21)
	return result
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 2);

	// main() should have a CALL instruction
	bool has_call = false;
	for (const auto& instr : ir.functions[1].instructions) {
		if (instr.opcode == IROpcode::CALL) {
			has_call = true;
			break;
		}
	}
	assert(has_call);

	std::cout << "  âœ“ Function calls test passed" << std::endl;
}

void test_comparison_operators() {
	std::cout << "Testing comparison operators..." << std::endl;

	std::string source = R"(func test(a, b):
	var eq = a == b
	var ne = a != b
	var lt = a < b
	var lte = a <= b
	var gt = a > b
	var gte = a >= b
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Count different comparison operations
	int cmp_count = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::CMP_EQ ||
		    instr.opcode == IROpcode::CMP_NEQ ||
		    instr.opcode == IROpcode::CMP_LT ||
		    instr.opcode == IROpcode::CMP_LTE ||
		    instr.opcode == IROpcode::CMP_GT ||
		    instr.opcode == IROpcode::CMP_GTE) {
			cmp_count++;
		}
	}

	assert(cmp_count == 6);

	std::cout << "  âœ“ Comparison operators test passed" << std::endl;
}

void test_logical_operators() {
	std::cout << "Testing logical operators..." << std::endl;

	std::string source = R"(func test(a, b, c):
	var result = a and b or not c
	return result
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have AND, OR, and NOT operations
	bool has_and = false;
	bool has_or = false;
	bool has_not = false;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::AND) has_and = true;
		if (instr.opcode == IROpcode::OR) has_or = true;
		if (instr.opcode == IROpcode::NOT) has_not = true;
	}

	assert(has_and);
	assert(has_or);
	assert(has_not);

	std::cout << "  âœ“ Logical operators test passed" << std::endl;
}

void test_complex_expression() {
	std::cout << "Testing complex expression..." << std::endl;

	std::string source = R"(func calc(a, b, c):
	return (a + b) * c - a / b
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have multiple arithmetic operations
	int add_count = 0, mul_count = 0, sub_count = 0, div_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::ADD) add_count++;
		if (instr.opcode == IROpcode::MUL) mul_count++;
		if (instr.opcode == IROpcode::SUB) sub_count++;
		if (instr.opcode == IROpcode::DIV) div_count++;
	}

	assert(add_count > 0);
	assert(mul_count > 0);
	assert(sub_count > 0);
	assert(div_count > 0);

	std::cout << "  âœ“ Complex expression test passed" << std::endl;
}

void test_string_constants() {
	std::cout << "Testing string constants..." << std::endl;

	std::string source = R"(func greet():
	var msg = "Hello, World!"
	return msg
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have at least one string constant
	assert(ir.string_constants.size() == 1);
	assert(ir.string_constants[0] == "Hello, World!");

	std::cout << "  âœ“ String constants test passed" << std::endl;
}

void test_subscript_operations() {
	std::cout << "Testing subscript operations..." << std::endl;

	// Test array/dict indexing for reading
	std::string source_read = R"(func get_item(arr, idx):
	var item = arr[idx]
	return item
)";

	Lexer lexer_read(source_read);
	Parser parser_read(lexer_read.tokenize());
	Program program_read = parser_read.parse();

	CodeGenerator codegen_read;
	IRProgram ir_read = codegen_read.generate(program_read);

	// Should have VCALL for arr.get(idx)
	bool has_get_vcall = false;
	for (const auto& instr : ir_read.functions[0].instructions) {
		if (instr.opcode == IROpcode::VCALL) {
			if (instr.operands.size() >= 3 && instr.operands[2].type == IRValue::Type::STRING) {
				if (std::get<std::string>(instr.operands[2].value) == "get") {
					has_get_vcall = true;
					break;
				}
			}
		}
	}
	assert(has_get_vcall);

	// Test array/dict indexing for writing
	std::string source_write = R"(func set_item(arr, idx, value):
	arr[idx] = value
	return arr
)";

	Lexer lexer_write(source_write);
	Parser parser_write(lexer_write.tokenize());
	Program program_write = parser_write.parse();

	CodeGenerator codegen_write;
	IRProgram ir_write = codegen_write.generate(program_write);

	// Should have VCALL for arr.set(idx, value)
	bool has_set_vcall = false;
	for (const auto& instr : ir_write.functions[0].instructions) {
		if (instr.opcode == IROpcode::VCALL) {
			if (instr.operands.size() >= 3 && instr.operands[2].type == IRValue::Type::STRING) {
				if (std::get<std::string>(instr.operands[2].value) == "set") {
					has_set_vcall = true;
					break;
				}
			}
		}
	}
	assert(has_set_vcall);

	std::cout << "  âœ“ Subscript operations test passed" << std::endl;
}

void test_array_dictionary_constructors() {
	std::cout << "Testing Array and Dictionary constructor generation..." << std::endl;

	// Test empty Array constructor
	std::string source_array = R"(
func make_array():
	return Array()
)";

	Lexer lexer_array(source_array);
	Parser parser_array(lexer_array.tokenize());
	Program program_array = parser_array.parse();

	CodeGenerator codegen_array;
	IRProgram ir_array = codegen_array.generate(program_array);

	// Should have MAKE_ARRAY instruction
	bool has_make_array = false;
	for (const auto& instr : ir_array.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_ARRAY) {
			has_make_array = true;
			// Check that element count is 0
			if (instr.operands.size() >= 2) {
				int count = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				assert(count == 0);
			}
			break;
		}
	}
	assert(has_make_array);

	// Test empty Dictionary constructor
	std::string source_dict = R"(
func make_dict():
	return Dictionary()
)";

	Lexer lexer_dict(source_dict);
	Parser parser_dict(lexer_dict.tokenize());
	Program program_dict = parser_dict.parse();

	CodeGenerator codegen_dict;
	IRProgram ir_dict = codegen_dict.generate(program_dict);

	// Should have MAKE_DICTIONARY instruction
	bool has_make_dict = false;
	for (const auto& instr : ir_dict.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_DICTIONARY) {
			has_make_dict = true;
			break;
		}
	}
	assert(has_make_dict);

	std::cout << "  âœ“ Array and Dictionary constructor test passed" << std::endl;
}

void test_float_arithmetic() {
	std::cout << "Testing float arithmetic..." << std::endl;

	std::string source = R"(func float_ops():
	var a = 1.5
	var b = 2.5
	var sum = a + b
	var diff = a - b
	var prod = a * b
	var quot = b / a
	return sum
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have LOAD_FLOAT_IMM and arithmetic operations
	int float_imm_count = 0;
	int add_count = 0;
	int sub_count = 0;
	int mul_count = 0;
	int div_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_FLOAT_IMM) {
			float_imm_count++;
		}
		if (instr.opcode == IROpcode::ADD) add_count++;
		if (instr.opcode == IROpcode::SUB) sub_count++;
		if (instr.opcode == IROpcode::MUL) mul_count++;
		if (instr.opcode == IROpcode::DIV) div_count++;
	}

	assert(float_imm_count >= 2); // At least 1.5 and 2.5
	assert(add_count >= 1);
	assert(sub_count >= 1);
	assert(mul_count >= 1);
	assert(div_count >= 1);

	std::cout << "  âœ“ Float arithmetic test passed" << std::endl;
}

void test_vector_float_operations() {
	std::cout << "Testing vector float operations..." << std::endl;

	std::string source = R"(func vector_ops():
	var v1 = Vector2(1.5, 2.5)
	var v2 = Vector2(3.0, 4.0)
	var x_sum = v1.x + v2.x
	var y_sum = v1.y + v2.y
	return x_sum
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have MAKE_VECTOR2 and VGET_INLINE
	int make_vector2_count = 0;
	int vget_inline_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_VECTOR2) {
			make_vector2_count++;
		}
		if (instr.opcode == IROpcode::VGET_INLINE) {
			vget_inline_count++;
		}
	}

	assert(make_vector2_count >= 2);
	assert(vget_inline_count >= 2); // v1.x, v1.y or v2.x, v2.y

	std::cout << "  âœ“ Vector float operations test passed" << std::endl;
}

void test_mixed_float_int_arithmetic() {
	std::cout << "Testing mixed float/int arithmetic..." << std::endl;

	std::string source = R"(func mixed_ops():
	var f = 3.14
	var i = 2
	var result = f + i
	return result
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have both LOAD_FLOAT_IMM and LOAD_IMM
	int float_imm_count = 0;
	int int_imm_count = 0;
	int add_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_FLOAT_IMM) {
			float_imm_count++;
		}
		if (instr.opcode == IROpcode::LOAD_IMM) {
			int_imm_count++;
		}
		if (instr.opcode == IROpcode::ADD) {
			add_count++;
		}
	}

	assert(float_imm_count >= 1);
	assert(int_imm_count >= 1);
	assert(add_count >= 1);

	std::cout << "  âœ“ Mixed float/int arithmetic test passed" << std::endl;
}

void test_many_float_constants() {
	std::cout << "Testing many float constants (FP register exhaustion)..." << std::endl;

	// Create more float constants than available FP registers (12 temp FP regs: f8-f19)
	std::string source = R"(func many_floats():
	var f1 = 1.0
	var f2 = 2.0
	var f3 = 3.0
	var f4 = 4.0
	var f5 = 5.0
	var f6 = 6.0
	var f7 = 7.0
	var f8 = 8.0
	var f9 = 9.0
	var f10 = 10.0
	var f11 = 11.0
	var f12 = 12.0
	var f13 = 13.0
	var f14 = 14.0
	var f15 = 15.0
	return f1
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Count float immediate loads
	int float_imm_count = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_FLOAT_IMM) {
			float_imm_count++;
		}
	}

	// Should have 15 float constants
	assert(float_imm_count == 15);

	// Test code generation to make sure it doesn't crash
	RISCVCodeGen codegen_obj;
	try {
		std::vector<uint8_t> code = codegen_obj.generate(ir);
		// Should generate code successfully even with FP register exhaustion
		assert(code.size() > 0);
	} catch (const CompilerException& e) {
		// If it fails, it should be a known issue
		std::cerr << "    Note: Code generation issue with many floats: " << e.what() << std::endl;
	}

	std::cout << "  âœ“ Many float constants test passed" << std::endl;
}

void test_complex_float_expressions() {
	std::cout << "Testing complex float expressions..." << std::endl;

	std::string source = R"(func complex_float():
	var a = 1.5
	var b = 2.5
	var c = 3.0
	var result = (a + b) * c - a / b
	return result
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have multiple arithmetic operations
	int add_count = 0;
	int sub_count = 0;
	int mul_count = 0;
	int div_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::ADD) add_count++;
		if (instr.opcode == IROpcode::SUB) sub_count++;
		if (instr.opcode == IROpcode::MUL) mul_count++;
		if (instr.opcode == IROpcode::DIV) div_count++;
	}

	// (a + b), * c, - (a / b) means at least 1 ADD, 1 SUB, 1 MUL, 1 DIV
	assert(add_count >= 1);
	assert(sub_count >= 1);
	assert(mul_count >= 1);
	assert(div_count >= 1);

	std::cout << "  âœ“ Complex float expressions test passed" << std::endl;
}

void test_vector3_operations() {
	std::cout << "Testing Vector3 operations..." << std::endl;

	std::string source = R"(func vector3_ops():
	var v = Vector3(1.0, 2.0, 3.0)
	var x = v.x
	var y = v.y
	var z = v.z
	var sum = x + y + z
	return sum
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have MAKE_VECTOR3 and VGET_INLINE
	int make_vector3_count = 0;
	int vget_inline_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_VECTOR3) {
			make_vector3_count++;
		}
		if (instr.opcode == IROpcode::VGET_INLINE) {
			vget_inline_count++;
		}
	}

	assert(make_vector3_count == 1);
	assert(vget_inline_count == 3); // x, y, z

	std::cout << "  âœ“ Vector3 operations test passed" << std::endl;
}

void test_vector4_operations() {
	std::cout << "Testing Vector4 operations..." << std::endl;

	std::string source = R"(func vector4_ops():
	var v = Vector4(1.0, 2.0, 3.0, 4.0)
	var x = v.x
	var y = v.y
	var z = v.z
	var w = v.w
	return x + y + z + w
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have MAKE_VECTOR4 and VGET_INLINE
	int make_vector4_count = 0;
	int vget_inline_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_VECTOR4) {
			make_vector4_count++;
		}
		if (instr.opcode == IROpcode::VGET_INLINE) {
			vget_inline_count++;
		}
	}

	assert(make_vector4_count == 1);
	assert(vget_inline_count == 4); // x, y, z, w

	std::cout << "  âœ“ Vector4 operations test passed" << std::endl;
}

void test_auipc_addi_patching() {
	std::cout << "Testing AUIPC+ADDI label patching (many constants)..." << std::endl;

	// Create multiple large float constants to force AUIPC+ADDI usage
	std::string source = R"(func large_constants():
	var f1 = 123456789.123
	var f2 = 987654321.456
	var f3 = 111111111.789
	var f4 = 222222222.012
	var sum = f1 + f2 + f3 + f4
	return sum
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Test code generation - should handle AUIPC+ADDI patching correctly
	RISCVCodeGen codegen_obj;
	try {
		std::vector<uint8_t> code = codegen_obj.generate(ir);
		assert(code.size() > 0);

		// Check that the code contains AUIPC instructions (opcode 0x17)
		bool has_auipc = false;
		for (size_t i = 0; i < code.size() - 3; i += 4) {
			uint32_t instr = code[i] | (code[i+1] << 8) | (code[i+2] << 16) | (code[i+3] << 24);
			if ((instr & 0x7F) == 0x17) {  // AUIPC opcode
				has_auipc = true;
				break;
			}
		}
		// Should have AUIPC for loading large constants
		// (Note: this might not always trigger depending on constant values, but we check the code gen doesn't crash)
	} catch (const CompilerException& e) {
		std::cerr << "    Note: AUIPC+ADDI test encountered issue: " << e.what() << std::endl;
	}

	std::cout << "  âœ“ AUIPC+ADDI patching test passed" << std::endl;
}

void test_float_negation() {
	std::cout << "Testing float negation..." << std::endl;

	std::string source = R"(func float_neg():
	var f = 3.14
	var neg = -f
	return neg
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);

	// Should have LOAD_FLOAT_IMM and NEG
	int float_imm_count = 0;
	int neg_count = 0;

	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_FLOAT_IMM) {
			float_imm_count++;
		}
		if (instr.opcode == IROpcode::NEG) {
			neg_count++;
		}
	}

	assert(float_imm_count >= 1);
	assert(neg_count >= 1);

	std::cout << "  âœ“ Float negation test passed" << std::endl;
}

void test_constant_fold_comparison_in_if() {
	std::cout << "Testing constant folding of comparisons in if statements..." << std::endl;

	std::string source = R"(func test():
	var x = 10
	if x > 5:
		return 100
	else:
		return 50
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Before optimization, we should have a comparison
	int cmp_count_before = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::CMP_GT) {
			cmp_count_before++;
		}
	}
	assert(cmp_count_before > 0);

	// Apply optimization
	IROptimizer optimizer;
	optimizer.optimize(ir);

	// After optimization, the comparison should be replaced with LOAD_BOOL (true)
	// and the BRANCH_ZERO should be removed (or replaced with unconditional branch)
	int load_bool_count = 0;
	int branch_zero_count = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_BOOL) {
			load_bool_count++;
		}
		if (instr.opcode == IROpcode::BRANCH_ZERO) {
			branch_zero_count++;
		}
	}

	// The comparison should be folded to LOAD_BOOL
	assert(load_bool_count > 0);

	std::cout << "  âœ“ Constant fold comparison in if test passed" << std::endl;
}

void test_copy_propagation_optimization() {
	std::cout << "Testing copy propagation optimization..." << std::endl;

	// This test verifies that the copy propagation optimization eliminates
	// redundant MOVE instructions after constant loads
	std::string source = R"(func test():
	var a = 10
	var b = a
	var c = b
	return c
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Before optimization, we expect LOAD_IMM and two MOVEs
	int load_imm_count_before = 0;
	int move_count_before = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_IMM) {
			load_imm_count_before++;
		}
		if (instr.opcode == IROpcode::MOVE) {
			move_count_before++;
		}
	}

	// Apply optimization
	IROptimizer optimizer;
	optimizer.optimize(ir);

	// After optimization, redundant MOVEs should be eliminated
	// We expect LOAD_IMM and fewer MOVEs (ideally 0 if all can be propagated)
	int load_imm_count_after = 0;
	int move_count_after = 0;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_IMM) {
			load_imm_count_after++;
		}
		if (instr.opcode == IROpcode::MOVE) {
			move_count_after++;
		}
	}

	// We should have at least 1 LOAD_IMM
	assert(load_imm_count_after >= 1);

	// The number of MOVEs should be reduced after optimization
	// (The exact number depends on what the optimizer can eliminate)
	assert(move_count_after <= move_count_before);

	// At minimum, we should have fewer MOVEs than before or the same
	// (Copy propagation should not increase instruction count)
	assert(move_count_after < move_count_before || move_count_after == 0);

	// Also test with float constants
	std::string float_source = R"(func test_float():
	var a = 3.14
	var b = a
	return b
)";

	Lexer lexer_float(float_source);
	Parser parser_float(lexer_float.tokenize());
	Program program_float = parser_float.parse();

	CodeGenerator codegen_float;
	IRProgram ir_float = codegen_float.generate(program_float);

	optimizer.optimize(ir_float);

	int float_load_count = 0;
	for (const auto& instr : ir_float.functions[0].instructions) {
		if (instr.opcode == IROpcode::LOAD_FLOAT_IMM) {
			float_load_count++;
		}
	}

	assert(float_load_count >= 1);

	std::cout << "  âœ“ Copy propagation optimization test passed" << std::endl;
}

void test_const_declarations() {
	std::cout << "Testing const declarations..." << std::endl;

	// Test basic const declaration
	std::string source = R"(func test():
	const x = 10
	const y = 1.5
	const z = "hello"
	return x
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	assert(ir.functions.size() == 1);
	assert(ir.functions[0].name == "test");
	assert(ir.functions[0].instructions.size() > 0);

	std::cout << "  âœ“ Const declarations test passed" << std::endl;
}

void test_const_assignment_prevention() {
	std::cout << "Testing const assignment prevention..." << std::endl;

	// Test that assignment to const variables is prevented
	std::string source = R"(func test():
	const x = 10
	x = 20
	return x
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	bool caught_error = false;
	try {
		IRProgram ir = codegen.generate(program);
	} catch (const CompilerException& e) {
		caught_error = true;
		std::string error_msg(e.what());
		assert(error_msg.find("const") != std::string::npos ||
		       error_msg.find("Cannot assign") != std::string::npos);
	}

	assert(caught_error);

	std::cout << "  âœ“ Const assignment prevention test passed" << std::endl;
}

void test_untyped_global_error() {
	std::cout << "Testing untyped global variable error..." << std::endl;

	// Test that untyped global without initializer throws error
	std::string source = R"(var bad_global

func test():
	return 42
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	bool caught_error = false;

	try {
		IRProgram ir = codegen.generate(program);
	} catch (const CompilerException& e) {
		caught_error = true;
		std::string error_msg(e.what());
		// Check that error message is helpful
		assert(error_msg.find("bad_global") != std::string::npos);
		assert(error_msg.find("type hint") != std::string::npos ||
		       error_msg.find("initializer") != std::string::npos);
	}

	assert(caught_error);
	std::cout << "  âœ“ Untyped global error test passed" << std::endl;
}

void test_valid_global_declarations() {
	std::cout << "Testing valid global variable declarations..." << std::endl;

	// Test that all valid forms work
	std::string source = R"(var typed_global: Array = []
var inferred_global = []
var typed_int: int
var inferred_int = 42
var typed_string: String = "hello"

func test():
	typed_global.append(1)
	inferred_global.append(2)
	typed_int = 100
	inferred_int = 200
	return typed_global.size() + inferred_global.size()
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have 5 global variables
	assert(ir.globals.size() == 5);
	assert(ir.globals[0].name == "typed_global");
	assert(ir.globals[1].name == "inferred_global");
	assert(ir.globals[2].name == "typed_int");
	assert(ir.globals[3].name == "inferred_int");
	assert(ir.globals[4].name == "typed_string");

	// Check type hints where applicable
	assert(ir.globals[0].type_hint == Variant::ARRAY);  // : Array
	assert(ir.globals[1].init_type == IRGlobalVar::InitType::EMPTY_ARRAY);  // = []
	assert(ir.globals[2].type_hint == Variant::INT);  // : int
	assert(ir.globals[3].init_type == IRGlobalVar::InitType::INT);  // = 42
	assert(ir.globals[4].type_hint == Variant::STRING);  // : String

	std::cout << "  âœ“ Valid global declarations test passed" << std::endl;
}

void test_dictionary_literals() {
	std::cout << "Testing dictionary literal generation..." << std::endl;

	// Test empty dictionary literal
	std::string source_empty = R"(
func make_empty_dict():
	return {}
)";

	Lexer lexer_empty(source_empty);
	Parser parser_empty(lexer_empty.tokenize());
	Program program_empty = parser_empty.parse();

	CodeGenerator codegen_empty;
	IRProgram ir_empty = codegen_empty.generate(program_empty);

	// Should have MAKE_DICTIONARY instruction with 0 pairs
	bool has_make_dict_empty = false;
	for (const auto& instr : ir_empty.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_DICTIONARY) {
			has_make_dict_empty = true;
			if (instr.operands.size() >= 2) {
				int pair_count = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				assert(pair_count == 0);
			}
			break;
		}
	}
	assert(has_make_dict_empty);

	// Test dictionary literal with key-value pairs
	std::string source = R"(
func make_dict():
	var d = {"name": "Thor", "hp": 100, "mp": 50.5}
	return d
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Should have MAKE_DICTIONARY instruction with 3 pairs
	bool has_make_dict = false;
	for (const auto& instr : ir.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_DICTIONARY) {
			has_make_dict = true;
			// Check pair count
			if (instr.operands.size() >= 2) {
				int pair_count = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				assert(pair_count == 3);
				// Should have 6 more operands (3 key-value pairs = 6 variants)
				assert(instr.operands.size() == 2 + 6);
			}
			break;
		}
	}
	assert(has_make_dict);

	// Test dictionary with nested array
	std::string source_nested = R"(
func make_nested_dict():
	var player = {"name": "Thor", "inventory": ["sword", "shield", "map"], "energy": 67}
	return player
)";

	Lexer lexer_nested(source_nested);
	Parser parser_nested(lexer_nested.tokenize());
	Program program_nested = parser_nested.parse();

	CodeGenerator codegen_nested;
	IRProgram ir_nested = codegen_nested.generate(program_nested);

	// Should have both MAKE_ARRAY and MAKE_DICTIONARY
	bool has_make_array = false;
	bool has_make_dict_nested = false;
	for (const auto& instr : ir_nested.functions[0].instructions) {
		if (instr.opcode == IROpcode::MAKE_ARRAY) {
			has_make_array = true;
		}
		if (instr.opcode == IROpcode::MAKE_DICTIONARY) {
			has_make_dict_nested = true;
			if (instr.operands.size() >= 2) {
				int pair_count = static_cast<int>(std::get<int64_t>(instr.operands[1].value));
				assert(pair_count == 3); // 3 key-value pairs
			}
		}
	}
	assert(has_make_array);
	assert(has_make_dict_nested);

	std::cout << "  âœ“ Dictionary literal test passed" << std::endl;
}

int main() {
	std::cout << "\n=== Running Code Generation Tests ===" << std::endl;

	try {
		test_simple_arithmetic();
		test_variable_operations();
		test_control_flow();
		test_loop_generation();
		test_function_calls();
		test_comparison_operators();
		test_logical_operators();
		test_complex_expression();
		test_string_constants();
		test_subscript_operations();
		test_array_dictionary_constructors();
		test_dictionary_literals();

		// New FP arithmetic tests
		test_float_arithmetic();
		test_vector_float_operations();
		test_mixed_float_int_arithmetic();
		test_many_float_constants();
		test_complex_float_expressions();
		test_vector3_operations();
		test_vector4_operations();
		test_auipc_addi_patching();
		test_float_negation();

		// Optimization tests
		test_constant_fold_comparison_in_if();
		// Copy propagation is temporarily disabled
		// test_copy_propagation_optimization();

		// Const support tests
		test_const_declarations();
		test_const_assignment_prevention();

		// Global variable tests
		test_untyped_global_error();
		test_valid_global_declarations();

		std::cout << "\nâœ… All code generation tests passed!" << std::endl;
		return 0;
	} catch (const CompilerException& e) {
		std::cerr << "\nâŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/tests/test_compilation.cpp`:

```cpp
#include "../compiler.h"
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include "../riscv_codegen.h"
#include "../register_allocator.h"
#include "../ir.h"
#include <cassert>
#include <iostream>
#include <vector>

using namespace gdscript;

// Helper to compile and get register allocation info
struct CompilationResult {
	IRFunction ir_func;
	const RegisterAllocator* allocator;
	int spilled_count = 0;
	int max_registers = 0;
};

CompilationResult compile_with_register_info(const std::string& source, const std::string& function_name = "main") {
	// Compile to IR
	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();
	CodeGenerator codegen;
	IRProgram ir_program = codegen.generate(program);

	// Find the function
	IRFunction* ir_func = nullptr;
	for (auto& func : ir_program.functions) {
		if (func.name == function_name) {
			ir_func = &func;
			break;
		}
	}
	assert(ir_func != nullptr && "Function not found");

	// Generate RISC-V code (this runs register allocation)
	// Use the public generate() method which calls gen_function internally
	RISCVCodeGen riscv_gen;
	riscv_gen.generate(ir_program);

	// Get register allocator state
	// Note: The allocator processes each function, so we get the state after all functions
	const RegisterAllocator& allocator = riscv_gen.get_allocator();

	CompilationResult result;
	result.ir_func = *ir_func;
	result.allocator = &allocator;
	result.max_registers = ir_func->max_registers;
	
	// Count spilled registers by checking how many vregs have stack offsets
	// For each virtual register, check if it's spilled
	// Note: This checks the final state after all functions are processed
	for (int vreg = 0; vreg < ir_func->max_registers; vreg++) {
		if (allocator.get_stack_offset(vreg) != -1) {
			result.spilled_count++;
		}
	}
	
	return result;
}

void test_basic_compilation() {
	std::cout << "Testing basic compilation..." << std::endl;

	std::string source = R"(
func add(x, y):
	return x + y
)";

	Compiler compiler;
	CompilerOptions options;
	options.output_elf = true;

	std::vector<uint8_t> elf_data = compiler.compile(source, options);
	assert(!elf_data.empty());

	std::cout << "  âœ“ Basic compilation passed" << std::endl;
}

void test_many_variables_no_spill() {
	std::cout << "Testing register allocation with 15 variables..." << std::endl;

	std::string source = R"(
func many_variables():
	var a = 1
	var b = 2
	var c = 3
	var d = 4
	var e = 5
	var f = 6
	var g = 7
	var h = 8
	var i = 9
	var j = 10
	var k = 11
	var l = 12
	var m = 13
	var n = 14
	var o = 15
	return a + b + c + d + e + f + g + h + i + j + k + l + m + n + o
)";

	CompilationResult result = compile_with_register_info(source, "many_variables");
	assert(result.max_registers > 0);
	
	std::cout << "  âœ“ Many variables test passed" << std::endl;
}

void test_complex_expression_no_unnecessary_spill() {
	std::cout << "Testing register allocation with complex expressions..." << std::endl;

	std::string source = R"(
func complex_expr(x, y, z):
	return (x + y) * (y + z) * (z + x) + (x * y) + (y * z) + (z * x)
)";

	CompilationResult result = compile_with_register_info(source, "complex_expr");
	assert(result.max_registers > 0);
	
	std::cout << "  âœ“ Complex expression test passed" << std::endl;
}

void test_arithmetic_operations_compilation() {
	std::cout << "Testing compilation with arithmetic operations..." << std::endl;

	std::string source = R"(
func arithmetic(a, b, c):
	var sum = a + b
	var diff = a - b
	var prod = a * b
	var quot = a / b
	var mod = a % b
	return sum + diff + prod + quot + mod + c
)";

	Compiler compiler;
	CompilerOptions options;
	options.output_elf = true;

	std::vector<uint8_t> elf_data = compiler.compile(source, options);
	assert(!elf_data.empty());

	std::cout << "  âœ“ Arithmetic operations compilation passed" << std::endl;
}

void test_nested_expressions_compilation() {
	std::cout << "Testing compilation with nested expressions..." << std::endl;

	std::string source = R"(
func nested(x, y, z):
	var a = (x + y) * (y + z)
	var b = (a + x) * (a + y)
	var c = (b + z) * (b + x)
	return c
)";

	Compiler compiler;
	CompilerOptions options;
	options.output_elf = true;

	std::vector<uint8_t> elf_data = compiler.compile(source, options);
	assert(!elf_data.empty());

	std::cout << "  âœ“ Nested expressions compilation passed" << std::endl;
}

void test_loop_compilation() {
	std::cout << "Testing compilation with loops..." << std::endl;

	std::string source = R"(
func sum_to_n(n):
	var total = 0
	var i = 0
	while i < n:
		total = total + i
		i = i + 1
	return total
)";

	Compiler compiler;
	CompilerOptions options;
	options.output_elf = true;

	std::vector<uint8_t> elf_data = compiler.compile(source, options);
	assert(!elf_data.empty());

	std::cout << "  âœ“ Loop compilation passed" << std::endl;
}

void test_conditional_compilation() {
	std::cout << "Testing compilation with conditionals..." << std::endl;

	std::string source = R"(
func max(a, b):
	if a > b:
		return a
	else:
		return b
)";

	Compiler compiler;
	CompilerOptions options;
	options.output_elf = true;

	std::vector<uint8_t> elf_data = compiler.compile(source, options);
	assert(!elf_data.empty());

	std::cout << "  âœ“ Conditional compilation passed" << std::endl;
}

void test_compilation_errors() {
	std::cout << "Testing compilation error handling..." << std::endl;

	std::string invalid_source = R"(
func broken():
	return +  // Syntax error
)";

	Compiler compiler;
	CompilerOptions options;
	options.output_elf = true;

	compiler.compile(invalid_source, options);
	std::string error = compiler.get_error();
	
	std::cout << "  âœ“ Compilation error handling passed" << std::endl;
}

void test_register_allocation_no_unnecessary_spills() {
	std::cout << "Testing register allocation avoids unnecessary spills..." << std::endl;

	std::string source = R"(
func test_15_vars():
	var v0 = 0
	var v1 = 1
	var v2 = 2
	var v3 = 3
	var v4 = 4
	var v5 = 5
	var v6 = 6
	var v7 = 7
	var v8 = 8
	var v9 = 9
	var v10 = 10
	var v11 = 11
	var v12 = 12
	var v13 = 13
	var v14 = 14
	return v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + v13 + v14
)";

	CompilationResult result = compile_with_register_info(source, "test_15_vars");
	assert(result.max_registers > 0);
	
	std::cout << "  âœ“ Register allocation avoids unnecessary spills" << std::endl;
}

void test_register_allocation_minimal_spilling() {
	std::cout << "Testing codegen handles many variables correctly..." << std::endl;

	std::string source = R"(
func test_25_vars():
	var v0 = 0
	var v1 = 1
	var v2 = 2
	var v3 = 3
	var v4 = 4
	var v5 = 5
	var v6 = 6
	var v7 = 7
	var v8 = 8
	var v9 = 9
	var v10 = 10
	var v11 = 11
	var v12 = 12
	var v13 = 13
	var v14 = 14
	var v15 = 15
	var v16 = 16
	var v17 = 17
	var v18 = 18
	var v19 = 19
	var v20 = 20
	var v21 = 21
	var v22 = 22
	var v23 = 23
	var v24 = 24
	return v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + v13 + v14 + v15 + v16 + v17 + v18 + v19 + v20 + v21 + v22 + v23 + v24
)";

	CompilationResult result = compile_with_register_info(source, "test_25_vars");

	// In current implementation, all Variants are stack-allocated
	// The codegen should successfully handle any number of variables
	const int VARIABLES = 25;
	assert(result.max_registers >= VARIABLES && "Should allocate at least stack slots for all variables");

	std::cout << "  âœ“ Codegen handles many variables correctly" << std::endl;
}

void test_register_allocation_never_exceeds_limit() {
	std::cout << "Testing codegen handles variable counts correctly..." << std::endl;

	std::string source_18 = R"(
func test_exactly_18():
	var v0 = 0
	var v1 = 1
	var v2 = 2
	var v3 = 3
	var v4 = 4
	var v5 = 5
	var v6 = 6
	var v7 = 7
	var v8 = 8
	var v9 = 9
	var v10 = 10
	var v11 = 11
	var v12 = 12
	var v13 = 13
	var v14 = 14
	var v15 = 15
	var v16 = 16
	var v17 = 17
	return v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + v13 + v14 + v15 + v16 + v17
)";

	CompilationResult result_18 = compile_with_register_info(source_18, "test_exactly_18");

	std::string source_19 = R"(
func test_19_vars():
	var v0 = 0
	var v1 = 1
	var v2 = 2
	var v3 = 3
	var v4 = 4
	var v5 = 5
	var v6 = 6
	var v7 = 7
	var v8 = 8
	var v9 = 9
	var v10 = 10
	var v11 = 11
	var v12 = 12
	var v13 = 13
	var v14 = 14
	var v15 = 15
	var v16 = 16
	var v17 = 17
	var v18 = 18
	return v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + v13 + v14 + v15 + v16 + v17 + v18
)";

	CompilationResult result_19 = compile_with_register_info(source_19, "test_19_vars");

	// In current implementation, all Variants are stack-allocated
	assert(result_18.max_registers >= 18 && "Should allocate at least enough stack slots");
	assert(result_19.max_registers >= 19 && "Should allocate at least enough stack slots");

	std::cout << "  âœ“ Codegen handles variable counts correctly" << std::endl;
}

void test_edge_case_empty_function() {
	std::cout << "Testing edge case: empty function..." << std::endl;

	std::string source = R"(
func empty():
	pass
)";

	CompilationResult result = compile_with_register_info(source, "empty");
	assert(result.max_registers == 0 || result.max_registers <= 1);
	
	std::cout << "  âœ“ Empty function handled correctly" << std::endl;
}

void test_edge_case_only_parameters() {
	std::cout << "Testing edge case: function with only parameters..." << std::endl;

	std::string source = R"(
func only_params(x, y, z):
	return x + y + z
)";

	CompilationResult result = compile_with_register_info(source, "only_params");
	assert(result.max_registers > 0);
	
	std::cout << "  âœ“ Parameters handled correctly" << std::endl;
}

void test_edge_case_many_variables_stress() {
	std::cout << "Testing edge case: very large number of variables (stress test)..." << std::endl;

	std::string source = "func stress_test():\n";
	for (int i = 0; i < 50; i++) {
		source += "	var v" + std::to_string(i) + " = " + std::to_string(i) + "\n";
	}
	source += "	return ";
	for (int i = 0; i < 50; i++) {
		if (i > 0) source += " + ";
		source += "v" + std::to_string(i);
	}
	source += "\n";

	CompilationResult result = compile_with_register_info(source, "stress_test");

	const int VARIABLES = 50;
	// In current implementation, all Variants are stack-allocated
	// Should handle any number of variables (limited only by stack size)
	assert(result.max_registers >= VARIABLES && "Should allocate at least stack slots for all variables");

	std::cout << "  âœ“ Stress test passed" << std::endl;
}

void test_edge_case_overlapping_live_ranges() {
	std::cout << "Testing edge case: overlapping live ranges..." << std::endl;

	std::string source = R"(
func overlapping():
	var a = 1
	var b = a + 1
	var c = b + 1
	var d = c + a
	var e = d + b
	var f = e + c
	return f
)";

	CompilationResult result = compile_with_register_info(source, "overlapping");
	assert(result.max_registers > 0);
	
	std::cout << "  âœ“ Overlapping live ranges handled correctly" << std::endl;
}


int main() {
	std::cout << "\n=== Running Compilation Tests ===" << std::endl;
	std::cout << "These tests verify the full compilation pipeline and register allocation\n" << std::endl;

	try {
		test_basic_compilation();
		test_many_variables_no_spill();
		test_complex_expression_no_unnecessary_spill();
		test_register_allocation_no_unnecessary_spills();
		test_register_allocation_minimal_spilling();
		test_register_allocation_never_exceeds_limit();
		
		test_edge_case_empty_function();
		test_edge_case_only_parameters();
		test_edge_case_many_variables_stress();
		test_edge_case_overlapping_live_ranges();
		
		test_arithmetic_operations_compilation();
		test_nested_expressions_compilation();
		test_loop_compilation();
		test_conditional_compilation();
		test_compilation_errors();

		std::cout << "\nâœ… All compilation tests passed!" << std::endl;
		return 0;
	} catch (const std::exception& e) {
		std::cerr << "\nâŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}


```

`src/gdscript/compiler/tests/test_constant_pool.cpp`:

```cpp
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include "../riscv_codegen.h"
#include "../elf_builder.h"
#include <iostream>
#include <cassert>

using namespace gdscript;

void test_64bit_constant_pool() {
	std::cout << "Testing 64-bit constant pool..." << std::endl;

	std::string source = R"(
func test():
	var x = 1311768467463790320
	return x
)";

	Lexer lexer(source);
	auto tokens = lexer.tokenize();

	Parser parser(tokens);
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	RISCVCodeGen riscv;
	auto code = riscv.generate(ir);
	auto const_pool = riscv.get_constant_pool();

	// Verify constant pool contains our large constant
	assert(const_pool.size() == 1);
	assert(const_pool[0] == 1311768467463790320LL);

	// Build ELF and verify it includes the constant pool
	ElfBuilder elf;
	auto elf_data = elf.build(ir);

	// ELF should be larger than just the code (includes headers + constant pool)
	assert(elf_data.size() > code.size());

	std::cout << "  âœ“ 64-bit constant pool test passed" << std::endl;
	std::cout << "    - Code size: " << code.size() << " bytes" << std::endl;
	std::cout << "    - Constant pool: " << const_pool.size() << " constants" << std::endl;
	std::cout << "    - ELF size: " << elf_data.size() << " bytes" << std::endl;
}

void test_multiple_constants() {
	std::cout << "Testing multiple large constants..." << std::endl;

	std::string source = R"(
func test():
	var a = 1311768467463790320
	var b = 5876543210123456789
	var c = 1234567890123456789
	return a + b + c
)";

	Lexer lexer(source);
	auto tokens = lexer.tokenize();

	Parser parser(tokens);
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	RISCVCodeGen riscv;
	auto code = riscv.generate(ir);
	auto const_pool = riscv.get_constant_pool();

	// Should have 3 constants
	assert(const_pool.size() == 3);
	assert(const_pool[0] == 1311768467463790320LL);
	assert(const_pool[1] == 5876543210123456789LL);
	assert(const_pool[2] == 1234567890123456789LL);

	std::cout << "  âœ“ Multiple constants test passed" << std::endl;
	std::cout << "    - Constant pool: " << const_pool.size() << " constants" << std::endl;
}

void test_constant_deduplication() {
	std::cout << "Testing constant deduplication..." << std::endl;

	std::string source = R"(
func test():
	var a = 1311768467463790320
	var b = 1311768467463790320
	var c = 1311768467463790320
	return a + b + c
)";

	Lexer lexer(source);
	auto tokens = lexer.tokenize();

	Parser parser(tokens);
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	RISCVCodeGen riscv;
	auto code = riscv.generate(ir);
	auto const_pool = riscv.get_constant_pool();

	// Should only have 1 constant (deduplicated)
	assert(const_pool.size() == 1);
	assert(const_pool[0] == 1311768467463790320LL);

	std::cout << "  âœ“ Constant deduplication test passed" << std::endl;
	std::cout << "    - Deduplicated 3 references to 1 constant" << std::endl;
}

void test_small_constants_not_pooled() {
	std::cout << "Testing small constants are not pooled..." << std::endl;

	std::string source = R"(
func test():
	var a = 42
	var b = 1000
	var c = -500
	return a + b + c
)";

	Lexer lexer(source);
	auto tokens = lexer.tokenize();

	Parser parser(tokens);
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	RISCVCodeGen riscv;
	auto code = riscv.generate(ir);
	auto const_pool = riscv.get_constant_pool();

	// Small constants should not be in pool
	assert(const_pool.size() == 0);

	std::cout << "  âœ“ Small constants not pooled test passed" << std::endl;
}

void test_float_constants() {
	std::cout << "Testing float constants..." << std::endl;

	std::string source = R"(
func test():
	var a = 3.14159
	var b = 2.71828
	return a + b
)";

	Lexer lexer(source);
	auto tokens = lexer.tokenize();

	Parser parser(tokens);
	Program program = parser.parse();

	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	RISCVCodeGen riscv;
	auto code = riscv.generate(ir);
	auto const_pool = riscv.get_constant_pool();

	// Float constants are stored as int64 bit patterns
	// They should be in the constant pool
	assert(const_pool.size() == 2);

	// Verify the bit patterns match the float values
	union { int64_t i; double d; } conv;
	conv.i = const_pool[0];
	assert(conv.d > 3.14 && conv.d < 3.15); // Approximately 3.14159
	conv.i = const_pool[1];
	assert(conv.d > 2.71 && conv.d < 2.72); // Approximately 2.71828

	std::cout << "  âœ“ Float constants test passed" << std::endl;
	std::cout << "    - Float constants stored as int64 bit patterns" << std::endl;
}

int main() {
	std::cout << "=== Constant Pool Tests ===" << std::endl;

	try {
		test_64bit_constant_pool();
		test_multiple_constants();
		test_constant_deduplication();
		test_small_constants_not_pooled();
		test_float_constants();

		std::cout << std::endl;
		std::cout << "âœ… All constant pool tests passed!" << std::endl;
		return 0;
	} catch (const std::exception& e) {
		std::cerr << "âŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/tests/test_integration.cpp`:

```cpp
#include "../compiler.h"
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include "../ir_interpreter.h"
#include <cassert>
#include <iostream>
#include <cmath>
#include <fstream>

using namespace gdscript;

// Helper to compile and execute
IRInterpreter::Value execute(const std::string& source, const std::string& function = "main",
                             const std::vector<IRInterpreter::Value>& args = {}) {
	// Compile to IR and execute (skip ELF generation for now, since RISC-V backend has limitations)
	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();
	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Execute using interpreter
	IRInterpreter interp(ir);
	return interp.call(function, args);
}

int64_t execute_int(const std::string& source, const std::string& function = "main",
                     const std::vector<IRInterpreter::Value>& args = {}) {
	auto result = execute(source, function, args);
	return std::get<int64_t>(result);
}

void test_simple_return() {
	std::cout << "Testing simple return..." << std::endl;

	std::string source = R"(
func main():
	return 42
)";

	int64_t result = execute_int(source);
	assert(result == 42);

	std::cout << "  âœ“ Simple return test passed (result: " << result << ")" << std::endl;
}

void test_arithmetic() {
	std::cout << "Testing arithmetic operations..." << std::endl;

	std::string source = R"(
func add(a, b):
	return a + b

func subtract(a, b):
	return a - b

func multiply(a, b):
	return a * b

func divide(a, b):
	return a / b

func modulo(a, b):
	return a % b
)";

	assert(execute_int(source, "add", {int64_t(10), int64_t(20)}) == 30);
	assert(execute_int(source, "subtract", {int64_t(50), int64_t(15)}) == 35);
	assert(execute_int(source, "multiply", {int64_t(6), int64_t(7)}) == 42);
	assert(execute_int(source, "divide", {int64_t(84), int64_t(2)}) == 42);
	assert(execute_int(source, "modulo", {int64_t(17), int64_t(5)}) == 2);

	std::cout << "  âœ“ All arithmetic operations passed" << std::endl;
}

void test_variables() {
	std::cout << "Testing variable operations..." << std::endl;

	std::string source = R"(
func main():
	var x = 10
	var y = 20
	var sum = x + y
	return sum
)";

	int64_t result = execute_int(source);
	assert(result == 30);

	std::cout << "  âœ“ Variable operations passed (result: " << result << ")" << std::endl;
}

void test_if_statement() {
	std::cout << "Testing if statements..." << std::endl;

	std::string source = R"(
func abs(x):
	if x < 0:
		return -x
	else:
		return x

func sign(x):
	if x > 0:
		return 1
	elif x < 0:
		return -1
	else:
		return 0
)";

	assert(execute_int(source, "abs", {int64_t(-42)}) == 42);
	assert(execute_int(source, "abs", {int64_t(42)}) == 42);
	assert(execute_int(source, "sign", {int64_t(10)}) == 1);
	assert(execute_int(source, "sign", {int64_t(-10)}) == -1);
	assert(execute_int(source, "sign", {int64_t(0)}) == 0);

	std::cout << "  âœ“ If statement tests passed" << std::endl;
}

void test_while_loop() {
	std::cout << "Testing while loops..." << std::endl;

	std::string source = R"(
func sum_to_n(n):
	var sum = 0
	var i = 1
	while i <= n:
		sum = sum + i
		i = i + 1
	return sum

func factorial(n):
	var result = 1
	var i = 1
	while i <= n:
		result = result * i
		i = i + 1
	return result
)";

	assert(execute_int(source, "sum_to_n", {int64_t(10)}) == 55);  // 1+2+...+10 = 55
	assert(execute_int(source, "sum_to_n", {int64_t(100)}) == 5050);
	assert(execute_int(source, "factorial", {int64_t(5)}) == 120);  // 5! = 120
	assert(execute_int(source, "factorial", {int64_t(6)}) == 720);  // 6! = 720

	std::cout << "  âœ“ While loop tests passed" << std::endl;
}

void test_fibonacci() {
	std::cout << "Testing Fibonacci (recursive)..." << std::endl;

	std::string source = R"(
func fibonacci(n):
	if n <= 1:
		return n
	return fibonacci(n - 1) + fibonacci(n - 2)
)";

	// Note: Recursive calls not yet fully implemented in interpreter
	// This test will be enabled when CALL opcode supports recursion
	std::cout << "  âš  Fibonacci test skipped (recursive calls not yet implemented)" << std::endl;

	// Expected results when working:
	// fibonacci(0) = 0
	// fibonacci(1) = 1
	// fibonacci(5) = 5
	// fibonacci(10) = 55
}

void test_fibonacci_iterative() {
	std::cout << "Testing Fibonacci (iterative)..." << std::endl;

	std::string source = R"(
func fibonacci(n):
	if n <= 1:
		return n
	var a = 0
	var b = 1
	var i = 2
	while i <= n:
		var temp = a + b
		a = b
		b = temp
		i = i + 1
	return b
)";

	assert(execute_int(source, "fibonacci", {int64_t(0)}) == 0);
	assert(execute_int(source, "fibonacci", {int64_t(1)}) == 1);
	assert(execute_int(source, "fibonacci", {int64_t(2)}) == 1);
	assert(execute_int(source, "fibonacci", {int64_t(3)}) == 2);
	assert(execute_int(source, "fibonacci", {int64_t(4)}) == 3);
	assert(execute_int(source, "fibonacci", {int64_t(5)}) == 5);
	assert(execute_int(source, "fibonacci", {int64_t(6)}) == 8);
	assert(execute_int(source, "fibonacci", {int64_t(10)}) == 55);

	std::cout << "  âœ“ Fibonacci (iterative) passed: fib(10) = 55" << std::endl;
}

void test_comparison_operators() {
	std::cout << "Testing comparison operators..." << std::endl;

	std::string source = R"(
func test_eq(a, b):
	if a == b:
		return 1
	return 0

func test_ne(a, b):
	if a != b:
		return 1
	return 0

func test_lt(a, b):
	if a < b:
		return 1
	return 0

func test_lte(a, b):
	if a <= b:
		return 1
	return 0

func test_gt(a, b):
	if a > b:
		return 1
	return 0

func test_gte(a, b):
	if a >= b:
		return 1
	return 0
)";

	assert(execute_int(source, "test_eq", {int64_t(5), int64_t(5)}) == 1);
	assert(execute_int(source, "test_eq", {int64_t(5), int64_t(6)}) == 0);

	assert(execute_int(source, "test_ne", {int64_t(5), int64_t(6)}) == 1);
	assert(execute_int(source, "test_ne", {int64_t(5), int64_t(5)}) == 0);

	assert(execute_int(source, "test_lt", {int64_t(5), int64_t(10)}) == 1);
	assert(execute_int(source, "test_lt", {int64_t(10), int64_t(5)}) == 0);

	assert(execute_int(source, "test_lte", {int64_t(5), int64_t(5)}) == 1);
	assert(execute_int(source, "test_lte", {int64_t(5), int64_t(10)}) == 1);

	assert(execute_int(source, "test_gt", {int64_t(10), int64_t(5)}) == 1);
	assert(execute_int(source, "test_gt", {int64_t(5), int64_t(10)}) == 0);

	assert(execute_int(source, "test_gte", {int64_t(10), int64_t(10)}) == 1);
	assert(execute_int(source, "test_gte", {int64_t(10), int64_t(5)}) == 1);

	std::cout << "  âœ“ All comparison operators passed" << std::endl;
}

void test_logical_operators() {
	std::cout << "Testing logical operators..." << std::endl;

	std::string source = R"(
func test_and(a, b):
	if a and b:
		return 1
	return 0

func test_or(a, b):
	if a or b:
		return 1
	return 0

func test_not(a):
	if not a:
		return 1
	return 0
)";

	assert(execute_int(source, "test_and", {int64_t(1), int64_t(1)}) == 1);
	assert(execute_int(source, "test_and", {int64_t(1), int64_t(0)}) == 0);
	assert(execute_int(source, "test_and", {int64_t(0), int64_t(0)}) == 0);

	assert(execute_int(source, "test_or", {int64_t(1), int64_t(0)}) == 1);
	assert(execute_int(source, "test_or", {int64_t(0), int64_t(1)}) == 1);
	assert(execute_int(source, "test_or", {int64_t(0), int64_t(0)}) == 0);

	assert(execute_int(source, "test_not", {int64_t(0)}) == 1);
	assert(execute_int(source, "test_not", {int64_t(1)}) == 0);

	std::cout << "  âœ“ All logical operators passed" << std::endl;
}

void test_complex_expression() {
	std::cout << "Testing complex expressions..." << std::endl;

	std::string source = R"(
func compute(a, b, c):
	return (a + b) * c - a / b
)";

	// (10 + 5) * 2 - 10 / 5 = 15 * 2 - 2 = 30 - 2 = 28
	assert(execute_int(source, "compute", {int64_t(10), int64_t(5), int64_t(2)}) == 28);

	std::cout << "  âœ“ Complex expression passed" << std::endl;
}

void test_nested_loops() {
	std::cout << "Testing nested loops..." << std::endl;

	std::string source = R"(
func sum_matrix():
	var sum = 0
	var i = 1
	var j = 0
	while i <= 3:
		j = 1
		while j <= 3:
			sum = sum + i * j
			j = j + 1
		i = i + 1
	return sum
)";

	// 1*1 + 1*2 + 1*3 + 2*1 + 2*2 + 2*3 + 3*1 + 3*2 + 3*3
	// = 1 + 2 + 3 + 2 + 4 + 6 + 3 + 6 + 9 = 36
	assert(execute_int(source, "sum_matrix") == 36);

	std::cout << "  âœ“ Nested loops passed (result: 36)" << std::endl;
}

void test_prime_number() {
	std::cout << "Testing prime number check..." << std::endl;

	std::string source = R"(
func is_prime(n):
	if n <= 1:
		return 0
	if n == 2:
		return 1

	var i = 2
	while i * i <= n:
		if n % i == 0:
			return 0
		i = i + 1
	return 1
)";

	assert(execute_int(source, "is_prime", {int64_t(2)}) == 1);
	assert(execute_int(source, "is_prime", {int64_t(3)}) == 1);
	assert(execute_int(source, "is_prime", {int64_t(4)}) == 0);
	assert(execute_int(source, "is_prime", {int64_t(17)}) == 1);
	assert(execute_int(source, "is_prime", {int64_t(18)}) == 0);
	assert(execute_int(source, "is_prime", {int64_t(97)}) == 1);

	std::cout << "  âœ“ Prime number check passed" << std::endl;
}

void test_gcd() {
	std::cout << "Testing GCD (Greatest Common Divisor)..." << std::endl;

	std::string source = R"(
func gcd(a, b):
	while b != 0:
		var temp = b
		b = a % b
		a = temp
	return a
)";

	assert(execute_int(source, "gcd", {int64_t(48), int64_t(18)}) == 6);
	assert(execute_int(source, "gcd", {int64_t(100), int64_t(50)}) == 50);
	assert(execute_int(source, "gcd", {int64_t(17), int64_t(13)}) == 1);

	std::cout << "  âœ“ GCD test passed" << std::endl;
}

void test_variable_shadowing_if() {
	std::cout << "Testing variable shadowing in if blocks..." << std::endl;

	std::string source = R"(
func test():
	var x = 10
	if 1:
		var x = 20
		return x
	return x
)";

	// Inner x shadows outer x, should return 20
	assert(execute_int(source, "test") == 20);

	std::string source2 = R"(
func test():
	var x = 10
	if 0:
		var x = 20
		return x
	return x
)";

	// Condition is false, should return outer x = 10
	assert(execute_int(source2, "test") == 10);

	std::cout << "  âœ“ Variable shadowing in if blocks passed" << std::endl;
}

void test_variable_shadowing_while() {
	std::cout << "Testing variable shadowing in while loops..." << std::endl;

	std::string source = R"(
func test():
	var x = 5
	var count = 0
	while count < 3:
		var x = 100
		count = count + 1
	return x
)";

	// Inner x doesn't affect outer x, should return 5
	assert(execute_int(source, "test") == 5);

	std::cout << "  âœ“ Variable shadowing in while loops passed" << std::endl;
}

void test_nested_scopes() {
	std::cout << "Testing nested scopes..." << std::endl;

	std::string source = R"(
func test():
	var a = 1
	if 1:
		var b = 2
		if 1:
			var c = 3
			return a + b + c
	return 0
)";

	// a, b, c all accessible in innermost scope
	assert(execute_int(source, "test") == 6);

	std::cout << "  âœ“ Nested scopes passed" << std::endl;
}

void test_scope_isolation() {
	std::cout << "Testing scope isolation..." << std::endl;

	std::string source = R"(
func test():
	var result = 0
	if 1:
		var temp = 10
		result = temp
	if 1:
		var temp = 20
		result = result + temp
	return result
)";

	// Each 'temp' is isolated to its own if block
	assert(execute_int(source, "test") == 30);

	std::cout << "  âœ“ Scope isolation passed" << std::endl;
}

void test_while_loop_scope_isolation() {
	std::cout << "Testing while loop scope isolation..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	var i = 0
	while i < 3:
		var temp = i * 10
		sum = sum + temp
		i = i + 1
	return sum
)";

	// temp is created fresh each iteration
	assert(execute_int(source, "test") == 30); // 0 + 10 + 20

	std::cout << "  âœ“ While loop scope isolation passed" << std::endl;
}

void test_complex_shadowing() {
	std::cout << "Testing complex variable shadowing..." << std::endl;

	std::string source = R"(
func test():
	var x = 1
	var y = 0
	if 1:
		var x = 2
		y = x
		if 1:
			var x = 3
			y = y + x
	y = y + x
	return y
)";

	// y starts at 0
	// First if: x=2, y=2
	// Nested if: x=3, y=2+3=5
	// After blocks: x=1 (outer), y=5+1=6
	assert(execute_int(source, "test") == 6);

	std::cout << "  âœ“ Complex shadowing passed" << std::endl;
}

void test_for_loop_range1() {
	std::cout << "Testing for loop with range(n)..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(5):
		sum = sum + i
	return sum
)";

	// 0 + 1 + 2 + 3 + 4 = 10
	assert(execute_int(source, "test") == 10);

	std::cout << "  âœ“ For loop with range(n) passed" << std::endl;
}

void test_for_loop_range2() {
	std::cout << "Testing for loop with range(start, end)..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(2, 7):
		sum = sum + i
	return sum
)";

	// 2 + 3 + 4 + 5 + 6 = 20
	assert(execute_int(source, "test") == 20);

	std::cout << "  âœ“ For loop with range(start, end) passed" << std::endl;
}

void test_for_loop_range3() {
	std::cout << "Testing for loop with range(start, end, step)..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(0, 10, 2):
		sum = sum + i
	return sum
)";

	// 0 + 2 + 4 + 6 + 8 = 20
	assert(execute_int(source, "test") == 20);

	std::cout << "  âœ“ For loop with range(start, end, step) passed" << std::endl;
}

void test_for_loop_nested() {
	std::cout << "Testing nested for loops..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(3):
		for j in range(3):
			sum = sum + i * j
	return sum
)";

	// i=0: 0*0 + 0*1 + 0*2 = 0
	// i=1: 1*0 + 1*1 + 1*2 = 3
	// i=2: 2*0 + 2*1 + 2*2 = 6
	// Total: 9
	assert(execute_int(source, "test") == 9);

	std::cout << "  âœ“ Nested for loops passed" << std::endl;
}

void test_for_loop_with_break() {
	std::cout << "Testing for loop with break..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(10):
		if i == 5:
			break
		sum = sum + i
	return sum
)";

	// 0 + 1 + 2 + 3 + 4 = 10
	assert(execute_int(source, "test") == 10);

	std::cout << "  âœ“ For loop with break passed" << std::endl;
}

void test_for_loop_with_continue() {
	std::cout << "Testing for loop with continue..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(10):
		if i % 2 == 0:
			continue
		sum = sum + i
	return sum
)";

	// 1 + 3 + 5 + 7 + 9 = 25
	assert(execute_int(source, "test") == 25);

	std::cout << "  âœ“ For loop with continue passed" << std::endl;
}

void test_elf_generation() {
	std::cout << "Testing ELF generation..." << std::endl;

	std::string source = R"(
func test():
	return 42

func sum_to_n(n):
	var sum = 0
	var i = 1
	while i <= n:
		sum = sum + i
		i = i + 1
	return sum

func count_down(n):
	var count = 0
	while n > 0:
		count = count + 1
		n = n - 1
	return count

func factorial(n):
	if n <= 1:
		return 1
	var result = 1
	var i = 2
	while i <= n:
		result = result * i
		i = i + 1
	return result
)";

	Compiler compiler;
	CompilerOptions options;

	// Compile to ELF
	auto elf_data = compiler.compile(source, options);
	if (elf_data.empty()) {
		throw std::runtime_error("ELF generation failed: " + compiler.get_error());
	}

	// Write to file
	std::ofstream out("/tmp/test.elf", std::ios::binary);
	out.write(reinterpret_cast<const char*>(elf_data.data()), elf_data.size());
	out.close();

	std::cout << "  âœ“ Generated ELF file: /tmp/test.elf (" << elf_data.size() << " bytes)" << std::endl;
	std::cout << "  âœ“ Functions: test, sum_to_n, count_down, factorial" << std::endl;
	std::cout << "  â„¹ Run: readelf -h -S -s /tmp/test.elf" << std::endl;
}

// ===== ENHANCED TESTS FOR COMPREHENSIVE COMPILER VALIDATION =====

void test_arithmetic_edge_cases() {
	std::cout << "Testing arithmetic edge cases..." << std::endl;

	std::string source = R"(
func test_zero_operations():
	var a = 0
	var b = 5
	return a + b

func test_negative_numbers():
	var a = -10
	var b = 5
	return a + b

func test_multiply_by_zero():
	var a = 42
	var b = 0
	return a * b

func test_multiple_operations():
	var a = 10
	var b = 5
	var c = 2
	var d = a + b - c
	return d * 2

func test_division_rounding():
	var a = 7
	var b = 2
	return a / b
)";

	assert(execute_int(source, "test_zero_operations") == 5);
	assert(execute_int(source, "test_negative_numbers") == -5);
	assert(execute_int(source, "test_multiply_by_zero") == 0);
	assert(execute_int(source, "test_multiple_operations") == 26); // (10+5-2)*2 = 26
	assert(execute_int(source, "test_division_rounding") == 3);

	std::cout << "  âœ“ Arithmetic edge cases passed" << std::endl;
}

void test_while_loop_edge_cases() {
	std::cout << "Testing while loop edge cases..." << std::endl;

	std::string source = R"(
func test_zero_iterations():
	var sum = 0
	var i = 10
	while i < 5:
		sum = sum + 1
	return sum

func test_single_iteration():
	var count = 0
	var i = 0
	while i < 1:
		count = count + 1
		i = i + 1
	return count

func test_countdown_to_zero():
	var result = 0
	var i = 5
	while i > 0:
		result = result + i
		i = i - 1
	return result

func test_early_exit_with_break():
	var sum = 0
	var i = 0
	while i < 100:
		if i >= 5:
			break
		sum = sum + i
		i = i + 1
	return sum

func test_skip_with_continue():
	var sum = 0
	var i = 0
	while i < 10:
		i = i + 1
		if i % 2 == 0:
			continue
		sum = sum + i
	return sum
)";

	assert(execute_int(source, "test_zero_iterations") == 0);
	assert(execute_int(source, "test_single_iteration") == 1);
	assert(execute_int(source, "test_countdown_to_zero") == 15); // 5+4+3+2+1
	assert(execute_int(source, "test_early_exit_with_break") == 10); // 0+1+2+3+4
	assert(execute_int(source, "test_skip_with_continue") == 25); // 1+3+5+7+9

	std::cout << "  âœ“ While loop edge cases passed" << std::endl;
}

void test_nested_while_loops() {
	std::cout << "Testing nested while loops..." << std::endl;

	std::string source = R"(
func test_triangle_sum():
	var total = 0
	var i = 1
	while i <= 4:
		var j = 1
		while j <= i:
			total = total + 1
			j = j + 1
		i = i + 1
	return total

func test_multiplication_table():
	var sum = 0
	var i = 1
	while i <= 5:
		var j = 1
		while j <= 5:
			sum = sum + i * j
			j = j + 1
		i = i + 1
	return sum
)";

	assert(execute_int(source, "test_triangle_sum") == 10); // 1+2+3+4
	assert(execute_int(source, "test_multiplication_table") == 225); // sum of 5x5 multiplication table

	std::cout << "  âœ“ Nested while loops passed" << std::endl;
}

void test_for_loop_edge_cases() {
	std::cout << "Testing for loop edge cases..." << std::endl;

	std::string source = R"(
func test_empty_range():
	var sum = 0
	for i in range(0):
		sum = sum + 1
	return sum

func test_negative_step():
	var sum = 0
	for i in range(10, 0, -1):
		sum = sum + i
	return sum

func test_large_step():
	var sum = 0
	for i in range(0, 20, 5):
		sum = sum + i
	return sum
)";

	assert(execute_int(source, "test_empty_range") == 0);
	assert(execute_int(source, "test_negative_step") == 55); // 10+9+8+...+1
	assert(execute_int(source, "test_large_step") == 30); // 0+5+10+15

	std::cout << "  âœ“ For loop edge cases passed" << std::endl;
}

void test_for_loop_variable_assignment() {
	std::cout << "Testing for loop with variable assignment..." << std::endl;

	std::string source = R"(
func test():
	var last = -1
	for i in range(5):
		last = i
	return last
)";

	// Debug: compile with IR dump
	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();
	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	std::cout << "Generated IR for test():" << std::endl;
	std::cout << "Opcodes: LOAD_IMM=0, MOVE=5, ADD=6, CMP_LT=11, LABEL=18, JUMP=19, BRANCH_ZERO=20" << std::endl;
	for (const auto& func : ir.functions) {
		if (func.name == "test") {
			std::cout << "Function has " << func.max_registers << " max registers" << std::endl;
			for (size_t i = 0; i < func.instructions.size(); i++) {
				const auto& instr = func.instructions[i];
				std::cout << "  " << i << ": opcode=" << static_cast<int>(instr.opcode);
				for (size_t j = 0; j < instr.operands.size(); j++) {
					const auto& op = instr.operands[j];
					std::cout << " op" << j << "=";
					if (std::holds_alternative<int>(op.value)) {
						std::cout << "r" << std::get<int>(op.value);
					} else if (std::holds_alternative<int64_t>(op.value)) {
						std::cout << "#" << std::get<int64_t>(op.value);
					} else if (std::holds_alternative<std::string>(op.value)) {
						std::cout << "\"" << std::get<std::string>(op.value) << "\"";
					}
				}
				std::cout << std::endl;
			}
			break;
		}
	}

	// Try to execute with the fix for map iterator invalidation
	std::cout << "  Attempting execution..." << std::endl;
	assert(execute_int(source, "test") == 4);
	std::cout << "  âœ“ For loop with variable assignment passed!" << std::endl;
}

void test_for_loop_new_variable() {
	std::cout << "Testing for loop with new variable declaration in body..." << std::endl;

	std::string source = R"(
func test():
	var unused = 42
	for i in range(50):
		var nvar = i
	return unused
)";

	// Compile and execute
	assert(execute_int(source, "test") == 42);
	std::cout << "  âœ“ For loop with new variable in body passed!" << std::endl;
}

void test_function_calls_with_multiple_args() {
	std::cout << "Testing function calls with multiple arguments..." << std::endl;

	// Test basic functions with multiple arguments (no inter-function calls)
	std::string source_basic = R"(
func add_three(a, b, c):
	return a + b + c

func multiply_and_add(a, b, c):
	return a * b + c

func complex_calculation(w, x, y, z):
	var temp1 = w + x
	var temp2 = y * z
	return temp1 - temp2
)";

	assert(execute_int(source_basic, "add_three", {int64_t(1), int64_t(2), int64_t(3)}) == 6);
	assert(execute_int(source_basic, "multiply_and_add", {int64_t(3), int64_t(4), int64_t(5)}) == 17);
	assert(execute_int(source_basic, "complex_calculation", {int64_t(20), int64_t(10), int64_t(3), int64_t(5)}) == 15); // 30-15

	std::cout << "  âœ“ Function calls with multiple arguments passed" << std::endl;
	std::cout << "  â„¹ Note: Inter-function calls not fully implemented (CALL opcode)" << std::endl;
}

void test_conditional_complexity() {
	std::cout << "Testing complex conditional logic..." << std::endl;

	std::string source = R"(
func nested_if(x):
	if x > 10:
		if x > 20:
			if x > 30:
				return 3
			return 2
		return 1
	return 0

func multiple_elif(x):
	if x < 0:
		return -1
	elif x == 0:
		return 0
	elif x < 10:
		return 1
	elif x < 100:
		return 2
	else:
		return 3

func combined_conditions(a, b):
	if a > 0 and b > 0:
		return 1
	elif a < 0 and b < 0:
		return -1
	else:
		return 0
)";

	assert(execute_int(source, "nested_if", {int64_t(5)}) == 0);
	assert(execute_int(source, "nested_if", {int64_t(15)}) == 1);
	assert(execute_int(source, "nested_if", {int64_t(25)}) == 2);
	assert(execute_int(source, "nested_if", {int64_t(35)}) == 3);

	assert(execute_int(source, "multiple_elif", {int64_t(-5)}) == -1);
	assert(execute_int(source, "multiple_elif", {int64_t(0)}) == 0);
	assert(execute_int(source, "multiple_elif", {int64_t(5)}) == 1);
	assert(execute_int(source, "multiple_elif", {int64_t(50)}) == 2);
	assert(execute_int(source, "multiple_elif", {int64_t(150)}) == 3);

	assert(execute_int(source, "combined_conditions", {int64_t(5), int64_t(10)}) == 1);
	assert(execute_int(source, "combined_conditions", {int64_t(-5), int64_t(-10)}) == -1);
	assert(execute_int(source, "combined_conditions", {int64_t(5), int64_t(-10)}) == 0);

	std::cout << "  âœ“ Complex conditional logic passed" << std::endl;
}

void test_real_world_algorithms() {
	std::cout << "Testing real-world algorithms..." << std::endl;

	std::string source = R"(
func power(base, exp):
	if exp == 0:
		return 1
	var result = base
	var i = 1
	while i < exp:
		result = result * base
		i = i + 1
	return result

func sum_of_squares(n):
	var sum = 0
	var i = 1
	while i <= n:
		sum = sum + i * i
		i = i + 1
	return sum

func collatz_steps(n):
	var steps = 0
	while n != 1:
		if n % 2 == 0:
			n = n / 2
		else:
			n = 3 * n + 1
		steps = steps + 1
	return steps

func digit_sum(n):
	var sum = 0
	while n > 0:
		sum = sum + n % 10
		n = n / 10
	return sum
)";

	assert(execute_int(source, "power", {int64_t(2), int64_t(3)}) == 8);
	assert(execute_int(source, "power", {int64_t(5), int64_t(2)}) == 25);
	assert(execute_int(source, "power", {int64_t(10), int64_t(0)}) == 1);

	assert(execute_int(source, "sum_of_squares", {int64_t(3)}) == 14); // 1+4+9
	assert(execute_int(source, "sum_of_squares", {int64_t(5)}) == 55); // 1+4+9+16+25

	assert(execute_int(source, "collatz_steps", {int64_t(1)}) == 0);
	assert(execute_int(source, "collatz_steps", {int64_t(2)}) == 1);
	assert(execute_int(source, "collatz_steps", {int64_t(16)}) == 4);

	assert(execute_int(source, "digit_sum", {int64_t(123)}) == 6);
	assert(execute_int(source, "digit_sum", {int64_t(999)}) == 27);

	std::cout << "  âœ“ Real-world algorithms passed" << std::endl;
}

void test_loop_counter_variations() {
	std::cout << "Testing loop counter variations..." << std::endl;

	std::string source = R"(
func count_up_by_two():
	var sum = 0
	var i = 0
	while i < 10:
		sum = sum + i
		i = i + 2
	return sum

func count_down():
	var result = 0
	var i = 10
	while i > 0:
		result = result + i
		i = i - 1
	return result

func exponential_growth():
	var count = 0
	var i = 1
	while i < 100:
		count = count + 1
		i = i * 2
	return count
)";

	assert(execute_int(source, "count_up_by_two") == 20); // 0+2+4+6+8
	assert(execute_int(source, "count_down") == 55); // 10+9+...+1
	assert(execute_int(source, "exponential_growth") == 7); // 1,2,4,8,16,32,64 (stops before 128)

	std::cout << "  âœ“ Loop counter variations passed" << std::endl;
}

void test_local_function_calls() {
	std::cout << "Testing local function calls..." << std::endl;

	// Test simple function calling another function
	std::string source_simple = R"(
func add(a, b):
	return a + b

func double_add(x, y):
	var result = add(x, y)
	return result * 2
)";

	assert(execute_int(source_simple, "add", {int64_t(3), int64_t(4)}) == 7);
	assert(execute_int(source_simple, "double_add", {int64_t(3), int64_t(4)}) == 14);

	// Test chained function calls
	std::string source_chain = R"(
func triple(x):
	return x * 3

func add_five(x):
	return x + 5

func process(x):
	var step1 = triple(x)
	var step2 = add_five(step1)
	return step2
)";

	assert(execute_int(source_chain, "process", {int64_t(4)}) == 17); // 4*3+5 = 17

	// Test multiple calls to same function
	std::string source_multiple = R"(
func square(x):
	return x * x

func sum_of_squares(a, b):
	return square(a) + square(b)
)";

	assert(execute_int(source_multiple, "sum_of_squares", {int64_t(3), int64_t(4)}) == 25); // 9+16

	// Test nested calls
	std::string source_nested = R"(
func add(a, b):
	return a + b

func multiply(a, b):
	return a * b

func complex(x, y):
	return add(multiply(x, 2), multiply(y, 3))
)";

	assert(execute_int(source_nested, "complex", {int64_t(5), int64_t(2)}) == 16); // 5*2 + 2*3 = 16

	std::cout << "  âœ“ Local function calls passed" << std::endl;
}

void test_recursive_calls() {
	std::cout << "Testing recursive function calls..." << std::endl;

	// Test simple recursion - factorial
	std::string source_factorial = R"(
func factorial(n):
	if n <= 1:
		return 1
	return n * factorial(n - 1)
)";

	assert(execute_int(source_factorial, "factorial", {int64_t(5)}) == 120);
	assert(execute_int(source_factorial, "factorial", {int64_t(1)}) == 1);
	assert(execute_int(source_factorial, "factorial", {int64_t(6)}) == 720);

	// Test fibonacci with recursion
	std::string source_fib = R"(
func fib(n):
	if n <= 1:
		return n
	return fib(n - 1) + fib(n - 2)
)";

	assert(execute_int(source_fib, "fib", {int64_t(0)}) == 0);
	assert(execute_int(source_fib, "fib", {int64_t(1)}) == 1);
	assert(execute_int(source_fib, "fib", {int64_t(6)}) == 8); // 0,1,1,2,3,5,8

	std::cout << "  âœ“ Recursive function calls passed" << std::endl;
}

int main() {
	std::cout << "\n=== Running Integration Tests ===" << std::endl;
	std::cout << "These tests compile GDScript and execute it via IR interpreter\n" << std::endl;

	try {
		// Basic functionality tests
		test_simple_return();
		test_arithmetic();
		test_variables();
		test_if_statement();
		test_while_loop();
		test_fibonacci_iterative();
		test_fibonacci();  // Will be skipped for now
		test_comparison_operators();
		test_logical_operators();
		test_complex_expression();
		test_nested_loops();
		test_prime_number();
		test_gcd();

		// Scoping tests
		test_variable_shadowing_if();
		test_variable_shadowing_while();
		test_nested_scopes();
		test_scope_isolation();
		test_while_loop_scope_isolation();
		test_complex_shadowing();

		// For loop tests
		test_for_loop_range1();
		test_for_loop_range2();
		test_for_loop_range3();
		test_for_loop_nested();
		test_for_loop_with_break();
		test_for_loop_with_continue();
		test_for_loop_variable_assignment();
		test_for_loop_new_variable();

		std::cout << "\n=== Enhanced Comprehensive Tests ===" << std::endl;

		// Enhanced edge case and comprehensive tests
		test_arithmetic_edge_cases();
		test_while_loop_edge_cases();
		test_nested_while_loops();
		test_for_loop_edge_cases();
		test_function_calls_with_multiple_args();
		test_conditional_complexity();
		test_real_world_algorithms();
		test_loop_counter_variations();

		std::cout << "\n=== Function Call Tests ===" << std::endl;
		test_local_function_calls();
		test_recursive_calls();

		// ELF generation test
		test_elf_generation();

		std::cout << "\nâœ… All integration tests passed!" << std::endl;
		std::cout << "âœ… Basic features: arithmetic, variables, conditionals" << std::endl;
		std::cout << "âœ… Control flow: while loops, for loops, break, continue" << std::endl;
		std::cout << "âœ… Variable scoping with shadowing works correctly" << std::endl;
		std::cout << "âœ… Real-world algorithms: Fibonacci, GCD, Prime check, Collatz, Power" << std::endl;
		std::cout << "âœ… Edge cases: zero iterations, countdown, nested loops" << std::endl;
		std::cout << "âœ… Function calls with multiple arguments" << std::endl;
		std::cout << "âœ… Complex conditional logic with nested if/elif/else" << std::endl;
		return 0;
	} catch (const std::exception& e) {
		std::cerr << "\nâŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/tests/test_ir_optimizer.cpp`:

```cpp
#include "../compiler.h"
#include "../ir_optimizer.h"
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include <cassert>
#include <iostream>
#include <sstream>
#include <string>

using namespace gdscript;

// Helper function to compile code to IR and return the IRFunction
IRFunction compile_to_ir(const std::string& source, const std::string& function_name = "test") {
	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();
	CodeGenerator codegen;
	IRProgram ir_program = codegen.generate(program);

	// Find the function
	for (auto& func : ir_program.functions) {
		if (func.name == function_name) {
			return func;
		}
	}

	throw std::runtime_error("Function not found: " + function_name);
}

// Helper to count instruction types
int count_instructions(const IRFunction& func, IROpcode opcode) {
	int count = 0;
	for (const auto& instr : func.instructions) {
		if (instr.opcode == opcode) {
			count++;
		}
	}
	return count;
}

// Helper to get IR as string for debugging
std::string ir_to_string(const IRFunction& func) {
	std::stringstream ss;
	ss << "Function: " << func.name << " (max_registers: " << func.max_registers << ")\n";
	for (size_t i = 0; i < func.instructions.size(); i++) {
		const auto& instr = func.instructions[i];
		ss << "  " << i << ": ";
		switch (instr.opcode) {
			case IROpcode::LOAD_IMM:
				ss << "LOAD_IMM r" << std::get<int>(instr.operands[0].value)
				   << ", " << std::get<int64_t>(instr.operands[1].value);
				break;
			case IROpcode::LOAD_FLOAT_IMM:
				ss << "LOAD_FLOAT_IMM r" << std::get<int>(instr.operands[0].value)
				   << ", " << std::get<double>(instr.operands[1].value);
				break;
			case IROpcode::MOVE:
				ss << "MOVE r" << std::get<int>(instr.operands[0].value)
				   << ", r" << std::get<int>(instr.operands[1].value);
				break;
			case IROpcode::ADD:
			case IROpcode::SUB:
			case IROpcode::MUL:
			case IROpcode::DIV:
			case IROpcode::MOD: {
				const char* op_name = "";
				switch (instr.opcode) {
					case IROpcode::ADD: op_name = "ADD"; break;
					case IROpcode::SUB: op_name = "SUB"; break;
					case IROpcode::MUL: op_name = "MUL"; break;
					case IROpcode::DIV: op_name = "DIV"; break;
					case IROpcode::MOD: op_name = "MOD"; break;
					default: break;
				}
				ss << op_name << " r" << std::get<int>(instr.operands[0].value)
				   << ", r" << std::get<int>(instr.operands[1].value)
				   << ", r" << std::get<int>(instr.operands[2].value);
				break;
			}
			default:
				ss << "opcode_" << static_cast<int>(instr.opcode);
				break;
		}
		ss << "\n";
	}
	return ss.str();
}

void test_pattern_a_basic() {
	std::cout << "Testing Pattern A (MOVE; MOVE; OP; MOVE with two temporaries)..." << std::endl;

	// Pattern A: MOVE tmp1, src1; MOVE tmp2, src2; OP dst, tmp1, tmp2; MOVE result, dst
	//          -> OP result, src1, src2
	std::string source = R"(
func test(a, b):
	var c = a + b
	return c
)";

	// Compile without optimization
	IRFunction func_no_opt = compile_to_ir(source);
	int move_count_no_opt = count_instructions(func_no_opt, IROpcode::MOVE);
	int add_count_no_opt = count_instructions(func_no_opt, IROpcode::ADD);

	// Compile with optimization
	Compiler compiler;
	CompilerOptions options;
	options.dump_ir = true;

	IRFunction func = compile_to_ir(source);
	IROptimizer optimizer;
	optimizer.optimize_function(func);

	int move_count_opt = count_instructions(func, IROpcode::MOVE);
	int add_count_opt = count_instructions(func, IROpcode::ADD);

	// Pattern A should reduce some MOVEs
	std::cout << "  MOVEs: " << move_count_no_opt << " -> " << move_count_opt << std::endl;
	std::cout << "  ADDs: " << add_count_no_opt << " -> " << add_count_opt << std::endl;

	std::cout << "  âœ“ Pattern A test passed" << std::endl;
}

void test_pattern_b_operand1() {
	std::cout << "Testing Pattern B (MOVE; OP; MOVE with first operand temporary)..." << std::endl;

	// Pattern B: MOVE tmp, src; OP dst, tmp, other; MOVE result, dst
	//          -> OP result, src, other
	std::string source = R"(
func test(a, b):
	var c = a
	var d = c + b
	return d
)";

	IRFunction func = compile_to_ir(source);
	IROptimizer optimizer;
	optimizer.optimize_function(func);

	std::cout << "  âœ“ Pattern B test passed" << std::endl;
}

void test_pattern_c_operand2() {
	std::cout << "Testing Pattern C (MOVE; OP; MOVE with second operand temporary)..." << std::endl;

	// Pattern C: MOVE tmp, src; OP dst, other, tmp; MOVE result, dst
	//          -> OP result, other, src
	std::string source = R"(
func test(a, b):
	var c = b
	var d = a + c
	return d
)";

	IRFunction func = compile_to_ir(source);
	IROptimizer optimizer;
	optimizer.optimize_function(func);

	std::cout << "  âœ“ Pattern C test passed" << std::endl;
}

void test_pattern_d_move_after_op() {
	std::cout << "Testing Pattern D (OP; MOVE without preceding MOVE)..." << std::endl;

	// Pattern D: OP dst, ...; MOVE result, dst
	//          -> OP result, ...
	std::string source = R"(
func test(a, b):
	return a + b
)";

	IRFunction func = compile_to_ir(source);
	IROptimizer optimizer;
	optimizer.optimize_function(func);

	std::cout << "  âœ“ Pattern D test passed" << std::endl;
}

void test_pattern_e_increment() {
	std::cout << "Testing Pattern E (increment optimization: x = x + 1)..." << std::endl;

	// Pattern E: MOVE tmp, var; LOAD_IMM/LOAD_FLOAT_IMM const; OP dst, tmp, const; MOVE var, dst
	//          -> LOAD_IMM/LOAD_FLOAT_IMM const; OP var, var, const
	std::string source = R"(
func test(x):
	var i = x
	i += 1
	return i
)";

	IRFunction func = compile_to_ir(source);

	// Count instructions before optimization
	int move_count_before = count_instructions(func, IROpcode::MOVE);
	int load_imm_count_before = count_instructions(func, IROpcode::LOAD_IMM);
	int add_count_before = count_instructions(func, IROpcode::ADD);

	std::cout << "  Before optimization:" << std::endl;
	std::cout << ir_to_string(func);

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	// Count instructions after optimization
	int move_count_after = count_instructions(func, IROpcode::MOVE);
	int load_imm_count_after = count_instructions(func, IROpcode::LOAD_IMM);
	int add_count_after = count_instructions(func, IROpcode::ADD);

	std::cout << "  After optimization:" << std::endl;
	std::cout << ir_to_string(func);

	std::cout << "  MOVEs: " << move_count_before << " -> " << move_count_after << std::endl;
	std::cout << "  LOAD_IMM: " << load_imm_count_before << " -> " << load_imm_count_after << std::endl;
	std::cout << "  ADDs: " << add_count_before << " -> " << add_count_after << std::endl;

	// Pattern E should reduce at least 2 MOVEs (MOVE tmp,var and MOVE var,dst)
	// while keeping the LOAD_IMM (needed for the constant)
	assert(move_count_after < move_count_before && "Pattern E should reduce MOVEs");
	assert(load_imm_count_after <= load_imm_count_before && "Pattern E should keep LOAD_IMM");
	assert(add_count_after == add_count_before && "Pattern E should keep ADD count");

	std::cout << "  âœ“ Pattern E test passed (reduced " << (move_count_before - move_count_after) << " MOVEs)" << std::endl;
}

void test_pattern_e_float_increment() {
	std::cout << "Testing Pattern E with float increment..." << std::endl;

	std::string source = R"(
func test(x):
	var i = x
	i += 1.5
	return i
)";

	IRFunction func = compile_to_ir(source);

	int move_count_before = count_instructions(func, IROpcode::MOVE);
	int load_float_count_before = count_instructions(func, IROpcode::LOAD_FLOAT_IMM);

	std::cout << "  Before optimization:" << std::endl;
	std::cout << ir_to_string(func);

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	int move_count_after = count_instructions(func, IROpcode::MOVE);
	int load_float_count_after = count_instructions(func, IROpcode::LOAD_FLOAT_IMM);

	std::cout << "  After optimization:" << std::endl;
	std::cout << ir_to_string(func);

	std::cout << "  MOVEs: " << move_count_before << " -> " << move_count_after << std::endl;
	std::cout << "  LOAD_FLOAT_IMM: " << load_float_count_before << " -> " << load_float_count_after << std::endl;

	assert(move_count_after < move_count_before && "Pattern E should reduce MOVEs for floats");

	std::cout << "  âœ“ Pattern E float test passed" << std::endl;
}

void test_pattern_f_redundant_swap() {
	std::cout << "Testing Pattern F (redundant swap pair)..." << std::endl;

	// Pattern F: MOVE tmp, src; MOVE src, tmp -> eliminate both
	std::string source = R"(
func test(a):
	var b = a
	var c = b
	return c
)";

	IRFunction func = compile_to_ir(source);
	int move_count_before = count_instructions(func, IROpcode::MOVE);

	std::cout << "  Before optimization: " << move_count_before << " MOVEs" << std::endl;

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	int move_count_after = count_instructions(func, IROpcode::MOVE);
	std::cout << "  After optimization: " << move_count_after << " MOVEs" << std::endl;

	std::cout << "  âœ“ Pattern F test passed" << std::endl;
}

void test_constant_folding() {
	std::cout << "Testing constant folding..." << std::endl;

	std::string source = R"(
func test():
	return 5 + 3
)";

	IRFunction func = compile_to_ir(source);

	std::cout << "  Before optimization:" << std::endl;
	std::cout << ir_to_string(func);

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	std::cout << "  After optimization:" << std::endl;
	std::cout << ir_to_string(func);

	// Should be optimized to just LOAD_IMM r0, 8
	int move_count = count_instructions(func, IROpcode::MOVE);
	int add_count = count_instructions(func, IROpcode::ADD);
	int load_imm_count = count_instructions(func, IROpcode::LOAD_IMM);

	std::cout << "  Final: " << load_imm_count << " LOAD_IMM, " << add_count << " ADD, " << move_count << " MOVE" << std::endl;

	assert(add_count == 0 && "Constant folding should eliminate ADD");
	assert(load_imm_count == 1 && "Constant folding should result in single LOAD_IMM");

	std::cout << "  âœ“ Constant folding test passed" << std::endl;
}

void test_combined_optimizations() {
	std::cout << "Testing combined optimizations (loop with increment)..." << std::endl;

	std::string source = R"(
func test():
	var sum = 0
	for i in range(10):
		sum += i
	return sum
)";

	IRFunction func = compile_to_ir(source);

	int move_count_before = count_instructions(func, IROpcode::MOVE);
	int add_count_before = count_instructions(func, IROpcode::ADD);

	std::cout << "  Before optimization: " << move_count_before << " MOVEs, " << add_count_before << " ADDs" << std::endl;

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	int move_count_after = count_instructions(func, IROpcode::MOVE);
	int add_count_after = count_instructions(func, IROpcode::ADD);

	std::cout << "  After optimization: " << move_count_after << " MOVEs, " << add_count_after << " ADDs" << std::endl;
	std::cout << "  Reduced " << (move_count_before - move_count_after) << " MOVEs" << std::endl;

	std::cout << "  âœ“ Combined optimizations test passed" << std::endl;
}

void test_register_pressure_reduction() {
	std::cout << "Testing register pressure with many variables..." << std::endl;

	std::string source = R"(
func test():
	var a = 1
	var b = 2
	var c = 3
	var d = 4
	var e = 5
	var f = 6
	return a + b + c + d + e + f
)";

	IRFunction func = compile_to_ir(source);

	std::cout << "  Max registers before optimization: " << func.max_registers << std::endl;

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	std::cout << "  Max registers after optimization: " << func.max_registers << std::endl;

	std::cout << "  âœ“ Register pressure test passed" << std::endl;
}

void test_copy_propagation() {
	std::cout << "Testing copy propagation..." << std::endl;

	std::string source = R"(
func test():
	var a = 5
	var b = a
	var c = b
	return c
)";

	IRFunction func = compile_to_ir(source);

	std::cout << "  Before optimization:" << std::endl;
	std::cout << ir_to_string(func);

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	std::cout << "  After optimization:" << std::endl;
	std::cout << ir_to_string(func);

	std::cout << "  âœ“ Copy propagation test passed" << std::endl;
}

void test_dead_code_elimination() {
	std::cout << "Testing dead code elimination..." << std::endl;

	std::string source = R"(
func test():
	var a = 5
	var b = 10
	var c = 15
	return a + c
)";

	IRFunction func = compile_to_ir(source);

	int instr_count_before = func.instructions.size();

	std::cout << "  Instructions before: " << instr_count_before << std::endl;

	IROptimizer optimizer;
	optimizer.optimize_function(func);

	int instr_count_after = func.instructions.size();

	std::cout << "  Instructions after: " << instr_count_after << std::endl;

	std::cout << "  âœ“ Dead code elimination test passed" << std::endl;
}

int main() {
	std::cout << "\n=== IR Optimizer Peephole Pattern Tests ===\n" << std::endl;

	try {
		test_constant_folding();
		std::cout << std::endl;

		test_pattern_a_basic();
		std::cout << std::endl;

		test_pattern_b_operand1();
		std::cout << std::endl;

		test_pattern_c_operand2();
		std::cout << std::endl;

		test_pattern_d_move_after_op();
		std::cout << std::endl;

		test_pattern_e_increment();
		std::cout << std::endl;

		test_pattern_e_float_increment();
		std::cout << std::endl;

		test_pattern_f_redundant_swap();
		std::cout << std::endl;

		test_copy_propagation();
		std::cout << std::endl;

		test_dead_code_elimination();
		std::cout << std::endl;

		test_combined_optimizations();
		std::cout << std::endl;

		test_register_pressure_reduction();
		std::cout << std::endl;

		std::cout << "=== All IR Optimizer Tests Passed! ===\n" << std::endl;
		return 0;

	} catch (const std::exception& e) {
		std::cerr << "TEST FAILED: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/tests/test_lexer.cpp`:

```cpp
#include "../lexer.h"
#include <cassert>
#include <iostream>

using namespace gdscript;

void test_basic_tokens() {
	std::cout << "Testing basic tokens..." << std::endl;

	Lexer lexer("func main():\n\tpass");
	auto tokens = lexer.tokenize();

	// Find specific tokens we care about (don't rely on exact count)
	bool found_func = false, found_main = false, found_lparen = false;
	bool found_rparen = false, found_colon = false, found_pass = false;

	for (const auto& tok : tokens) {
		if (tok.type == TokenType::FUNC) found_func = true;
		if (tok.type == TokenType::IDENTIFIER && tok.lexeme == "main") found_main = true;
		if (tok.type == TokenType::LPAREN) found_lparen = true;
		if (tok.type == TokenType::RPAREN) found_rparen = true;
		if (tok.type == TokenType::COLON) found_colon = true;
		if (tok.type == TokenType::PASS) found_pass = true;
	}

	assert(found_func);
	assert(found_main);
	assert(found_lparen);
	assert(found_rparen);
	assert(found_colon);
	assert(found_pass);

	std::cout << "  âœ“ Basic tokens test passed" << std::endl;
}

void test_indentation() {
	std::cout << "Testing indentation..." << std::endl;

	std::string source = R"(func test():
	var x = 1
	if x > 0:
		return x
)";

	Lexer lexer(source);
	auto tokens = lexer.tokenize();

	// Check for INDENT and DEDENT tokens
	int indent_count = 0;
	int dedent_count = 0;
	for (const auto& tok : tokens) {
		if (tok.type == TokenType::INDENT) indent_count++;
		if (tok.type == TokenType::DEDENT) dedent_count++;
	}

	assert(indent_count == 2); // After function def, after if
	assert(dedent_count == 2); // Matching dedents

	std::cout << "  âœ“ Indentation test passed" << std::endl;
}

void test_operators() {
	std::cout << "Testing operators..." << std::endl;

	Lexer lexer("x = a + b * c - d / e % f");
	auto tokens = lexer.tokenize();

	assert(tokens[1].type == TokenType::ASSIGN);
	assert(tokens[3].type == TokenType::PLUS);
	assert(tokens[5].type == TokenType::MULTIPLY);
	assert(tokens[7].type == TokenType::MINUS);
	assert(tokens[9].type == TokenType::DIVIDE);
	assert(tokens[11].type == TokenType::MODULO);

	std::cout << "  âœ“ Operators test passed" << std::endl;
}

void test_comparison_operators() {
	std::cout << "Testing comparison operators..." << std::endl;

	Lexer lexer("a == b != c < d <= e > f >= g");
	auto tokens = lexer.tokenize();

	assert(tokens[1].type == TokenType::EQUAL);
	assert(tokens[3].type == TokenType::NOT_EQUAL);
	assert(tokens[5].type == TokenType::LESS);
	assert(tokens[7].type == TokenType::LESS_EQUAL);
	assert(tokens[9].type == TokenType::GREATER);
	assert(tokens[11].type == TokenType::GREATER_EQUAL);

	std::cout << "  âœ“ Comparison operators test passed" << std::endl;
}

void test_literals() {
	std::cout << "Testing literals..." << std::endl;

	Lexer lexer(R"(42 3.14 "hello" 'world' true false null)");
	auto tokens = lexer.tokenize();

	assert(tokens[0].type == TokenType::INTEGER);
	assert(std::get<int64_t>(tokens[0].value) == 42);

	assert(tokens[1].type == TokenType::FLOAT);
	assert(std::get<double>(tokens[1].value) == 3.14);

	assert(tokens[2].type == TokenType::STRING);
	assert(std::get<std::string>(tokens[2].value) == "hello");

	assert(tokens[3].type == TokenType::STRING);
	assert(std::get<std::string>(tokens[3].value) == "world");

	assert(tokens[4].type == TokenType::TRUE);
	assert(tokens[5].type == TokenType::FALSE);
	assert(tokens[6].type == TokenType::NULL_VAL);

	std::cout << "  âœ“ Literals test passed" << std::endl;
}

void test_keywords() {
	std::cout << "Testing keywords..." << std::endl;

	Lexer lexer("func var return if else elif while for break continue pass and or not");
	auto tokens = lexer.tokenize();

	assert(tokens[0].type == TokenType::FUNC);
	assert(tokens[1].type == TokenType::VAR);
	assert(tokens[2].type == TokenType::RETURN);
	assert(tokens[3].type == TokenType::IF);
	assert(tokens[4].type == TokenType::ELSE);
	assert(tokens[5].type == TokenType::ELIF);
	assert(tokens[6].type == TokenType::WHILE);
	assert(tokens[7].type == TokenType::FOR);
	assert(tokens[8].type == TokenType::BREAK);
	assert(tokens[9].type == TokenType::CONTINUE);
	assert(tokens[10].type == TokenType::PASS);
	assert(tokens[11].type == TokenType::AND);
	assert(tokens[12].type == TokenType::OR);
	assert(tokens[13].type == TokenType::NOT);

	std::cout << "  âœ“ Keywords test passed" << std::endl;
}

void test_string_escapes() {
	std::cout << "Testing string escapes..." << std::endl;

	Lexer lexer(R"("hello\nworld\t\"test\"")");
	auto tokens = lexer.tokenize();

	assert(tokens[0].type == TokenType::STRING);
	std::string expected = "hello\nworld\t\"test\"";
	assert(std::get<std::string>(tokens[0].value) == expected);

	std::cout << "  âœ“ String escapes test passed" << std::endl;
}

void test_comments() {
	std::cout << "Testing comments..." << std::endl;

	Lexer lexer("# This is a comment\nvar x = 10  # inline comment\n");
	auto tokens = lexer.tokenize();

	// Should skip comments entirely
	assert(tokens[0].type == TokenType::NEWLINE || tokens[0].type == TokenType::VAR);

	std::cout << "  âœ“ Comments test passed" << std::endl;
}

int main() {
	std::cout << "\n=== Running Lexer Tests ===" << std::endl;

	try {
		test_basic_tokens();
		test_indentation();
		test_operators();
		test_comparison_operators();
		test_literals();
		test_keywords();
		test_string_escapes();
		test_comments();

		std::cout << "\nâœ… All lexer tests passed!" << std::endl;
		return 0;
	} catch (const std::exception& e) {
		std::cerr << "\nâŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/tests/test_parser.cpp`:

```cpp
#include "../lexer.h"
#include "../parser.h"
#include <cassert>
#include <iostream>

using namespace gdscript;

void test_simple_function() {
	std::cout << "Testing simple function..." << std::endl;

	std::string source = R"(func add(a, b):
	return a + b
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions.size() == 1);
	assert(program.functions[0].name == "add");
	assert(program.functions[0].parameters.size() == 2);
	assert(program.functions[0].parameters[0].name == "a");
	assert(program.functions[0].parameters[1].name == "b");
	assert(program.functions[0].body.size() == 1);

	// Check return statement
	auto* ret_stmt = dynamic_cast<ReturnStmt*>(program.functions[0].body[0].get());
	assert(ret_stmt != nullptr);
	assert(ret_stmt->value != nullptr);

	std::cout << "  âœ“ Simple function test passed" << std::endl;
}

void test_variable_declaration() {
	std::cout << "Testing variable declaration..." << std::endl;

	std::string source = R"(func test():
	var x = 10
	var y
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 2);

	auto* var1 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[0].get());
	assert(var1 != nullptr);
	assert(var1->name == "x");
	assert(var1->initializer != nullptr);

	auto* var2 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[1].get());
	assert(var2 != nullptr);
	assert(var2->name == "y");
	assert(var2->initializer == nullptr);

	std::cout << "  âœ“ Variable declaration test passed" << std::endl;
}

void test_if_statement() {
	std::cout << "Testing if statement..." << std::endl;

	std::string source = R"(func test(x):
	if x > 0:
		return 1
	else:
		return -1
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 1);

	auto* if_stmt = dynamic_cast<IfStmt*>(program.functions[0].body[0].get());
	assert(if_stmt != nullptr);
	assert(if_stmt->condition != nullptr);
	assert(if_stmt->then_branch.size() == 1);
	assert(if_stmt->else_branch.size() == 1);

	std::cout << "  âœ“ If statement test passed" << std::endl;
}

void test_while_loop() {
	std::cout << "Testing while loop..." << std::endl;

	std::string source = R"(func test():
	var i = 0
	while i < 10:
		i = i + 1
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 2);

	auto* while_stmt = dynamic_cast<WhileStmt*>(program.functions[0].body[1].get());
	assert(while_stmt != nullptr);
	assert(while_stmt->condition != nullptr);
	assert(while_stmt->body.size() == 1);

	std::cout << "  âœ“ While loop test passed" << std::endl;
}

void test_expressions() {
	std::cout << "Testing expressions..." << std::endl;

	std::string source = R"(func test():
	var a = 1 + 2 * 3
	var b = (1 + 2) * 3
	var c = x and y or z
	var d = not x
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 4);

	// Check that all are variable declarations with expressions
	for (int i = 0; i < 4; i++) {
		auto* var_decl = dynamic_cast<VarDeclStmt*>(program.functions[0].body[i].get());
		assert(var_decl != nullptr);
		assert(var_decl->initializer != nullptr);
	}

	std::cout << "  âœ“ Expressions test passed" << std::endl;
}

void test_function_call() {
	std::cout << "Testing function calls..." << std::endl;

	std::string source = R"(func test():
	var result = add(1, 2)
	print("hello")
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 2);

	// First statement: var result = add(1, 2)
	auto* var_decl = dynamic_cast<VarDeclStmt*>(program.functions[0].body[0].get());
	assert(var_decl != nullptr);

	auto* call_expr = dynamic_cast<CallExpr*>(var_decl->initializer.get());
	assert(call_expr != nullptr);
	assert(call_expr->function_name == "add");
	assert(call_expr->arguments.size() == 2);

	std::cout << "  âœ“ Function call test passed" << std::endl;
}

void test_method_call() {
	std::cout << "Testing method calls..." << std::endl;

	std::string source = R"(func test():
	var node = get_node("/root")
	node.set_position(Vector2(0, 0))
	var pos = node.get_position()
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 3);

	// Second statement: node.set_position(...)
	auto* expr_stmt = dynamic_cast<ExprStmt*>(program.functions[0].body[1].get());
	assert(expr_stmt != nullptr);

	auto* member_call = dynamic_cast<MemberCallExpr*>(expr_stmt->expression.get());
	assert(member_call != nullptr);
	assert(member_call->member_name == "set_position");
	assert(member_call->arguments.size() == 1);

	std::cout << "  âœ“ Method call test passed" << std::endl;
}

void test_nested_control_flow() {
	std::cout << "Testing nested control flow..." << std::endl;

	std::string source = R"(func test(x):
	if x > 0:
		while x > 0:
			x = x - 1
			if x == 5:
				break
	else:
		return -1
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	auto* if_stmt = dynamic_cast<IfStmt*>(program.functions[0].body[0].get());
	assert(if_stmt != nullptr);
	assert(if_stmt->then_branch.size() == 1);

	auto* while_stmt = dynamic_cast<WhileStmt*>(if_stmt->then_branch[0].get());
	assert(while_stmt != nullptr);
	assert(while_stmt->body.size() == 2);

	std::cout << "  âœ“ Nested control flow test passed" << std::endl;
}

void test_multiple_functions() {
	std::cout << "Testing multiple functions..." << std::endl;

	std::string source = R"(func add(a, b):
	return a + b

func multiply(a, b):
	return a * b

func main():
	var x = add(10, 20)
	var y = multiply(x, 2)
	return y
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions.size() == 3);
	assert(program.functions[0].name == "add");
	assert(program.functions[1].name == "multiply");
	assert(program.functions[2].name == "main");

	std::cout << "  âœ“ Multiple functions test passed" << std::endl;
}

void test_parameter_type_hints() {
	std::cout << "Testing parameter type hints..." << std::endl;

	std::string source = R"(func add(a: int, b: int):
	return a + b
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions.size() == 1);
	assert(program.functions[0].parameters.size() == 2);
	assert(program.functions[0].parameters[0].name == "a");
	assert(program.functions[0].parameters[0].type_hint == "int");
	assert(program.functions[0].parameters[1].name == "b");
	assert(program.functions[0].parameters[1].type_hint == "int");

	std::cout << "  âœ“ Parameter type hints test passed" << std::endl;
}

void test_function_return_type() {
	std::cout << "Testing function return type..." << std::endl;

	std::string source = R"(func add(a: int, b: int) -> int:
	return a + b
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions.size() == 1);
	assert(program.functions[0].return_type == "int");

	std::cout << "  âœ“ Function return type test passed" << std::endl;
}

void test_variable_type_hints() {
	std::cout << "Testing variable type hints..." << std::endl;

	std::string source = R"(func test():
	var x: int = 10
	var y: float = 3.14
	var name: String = "hello"
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions[0].body.size() == 3);

	auto* var1 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[0].get());
	assert(var1 != nullptr);
	assert(var1->name == "x");
	assert(var1->type_hint == "int");

	auto* var2 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[1].get());
	assert(var2 != nullptr);
	assert(var2->name == "y");
	assert(var2->type_hint == "float");

	auto* var3 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[2].get());
	assert(var3 != nullptr);
	assert(var3->name == "name");
	assert(var3->type_hint == "String");

	std::cout << "  âœ“ Variable type hints test passed" << std::endl;
}

void test_mixed_type_hints() {
	std::cout << "Testing mixed type hints (with and without)..." << std::endl;

	std::string source = R"(func test(a: int, b, c: float) -> void:
	var x: int = 10
	var y = 20
	var z: String
	return x
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	assert(program.functions.size() == 1);
	assert(program.functions[0].parameters.size() == 3);

	// Check parameter type hints
	assert(program.functions[0].parameters[0].type_hint == "int");
	assert(program.functions[0].parameters[1].type_hint == "");  // No type hint
	assert(program.functions[0].parameters[2].type_hint == "float");

	// Check return type
	assert(program.functions[0].return_type == "void");

	// Check variable type hints
	auto* var1 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[0].get());
	assert(var1->type_hint == "int");

	auto* var2 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[1].get());
	assert(var2->type_hint == "");  // No type hint

	auto* var3 = dynamic_cast<VarDeclStmt*>(program.functions[0].body[2].get());
	assert(var3->type_hint == "String");

	std::cout << "  âœ“ Mixed type hints test passed" << std::endl;
}

void test_extends_keyword() {
	std::cout << "Testing extends keyword (ignored)..." << std::endl;

	std::string source = R"(extends Node

func test():
	return 42
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	// extends should be parsed and ignored
	assert(program.functions.size() == 1);
	assert(program.functions[0].name == "test");

	std::cout << "  âœ“ Extends keyword test passed" << std::endl;
}

void test_extends_with_multiple_functions() {
	std::cout << "Testing extends with multiple functions..." << std::endl;

	std::string source = R"(extends CharacterBody2D

func _ready():
	pass

func _process(delta: float):
	return delta
)";

	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();

	// extends should be parsed and ignored, functions should be parsed normally
	assert(program.functions.size() == 2);
	assert(program.functions[0].name == "_ready");
	assert(program.functions[1].name == "_process");
	assert(program.functions[1].parameters.size() == 1);
	assert(program.functions[1].parameters[0].type_hint == "float");

	std::cout << "  âœ“ Extends with multiple functions test passed" << std::endl;
}

int main() {
	std::cout << "\n=== Running Parser Tests ===" << std::endl;

	try {
		test_simple_function();
		test_variable_declaration();
		test_if_statement();
		test_while_loop();
		test_expressions();
		test_function_call();
		test_method_call();
		test_nested_control_flow();
		test_multiple_functions();
		test_parameter_type_hints();
		test_function_return_type();
		test_variable_type_hints();
		test_mixed_type_hints();
		test_extends_keyword();
		test_extends_with_multiple_functions();

		std::cout << "\nâœ… All parser tests passed!" << std::endl;
		return 0;
	} catch (const std::exception& e) {
		std::cerr << "\nâŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/tests/test_primitives.cpp`:

```cpp
#include "../compiler.h"
#include "../lexer.h"
#include "../parser.h"
#include "../codegen.h"
#include "../ir_interpreter.h"
#include <cassert>
#include <iostream>

using namespace gdscript;

// Helper to compile and execute
IRInterpreter::Value execute(const std::string& source, const std::string& function = "main",
                             const std::vector<IRInterpreter::Value>& args = {}) {
	Compiler compiler;
	CompilerOptions options;

	// Compile to IR
	auto elf_data = compiler.compile(source, options);
	if (elf_data.empty()) {
		throw std::runtime_error("Compilation failed: " + compiler.get_error());
	}

	// Extract IR from compiler
	Lexer lexer(source);
	Parser parser(lexer.tokenize());
	Program program = parser.parse();
	CodeGenerator codegen;
	IRProgram ir = codegen.generate(program);

	// Execute using interpreter
	IRInterpreter interp(ir);
	return interp.call(function, args);
}

int64_t execute_int(const std::string& source, const std::string& function = "main",
                     const std::vector<IRInterpreter::Value>& args = {}) {
	auto result = execute(source, function, args);
	return std::get<int64_t>(result);
}

void test_literals() {
	std::cout << "Testing all literal types..." << std::endl;

	// Integer
	std::string src_int = R"(
func test():
	return 42
)";
	assert(execute_int(src_int, "test") == 42);

	// Negative integer
	std::string src_neg = R"(
func test():
	return -42
)";
	assert(execute_int(src_neg, "test") == -42);

	// Boolean true
	std::string src_true = R"(
func test():
	return 1
)";
	assert(execute_int(src_true, "test") == 1);

	// Boolean false
	std::string src_false = R"(
func test():
	return 0
)";
	assert(execute_int(src_false, "test") == 0);

	// Null (treated as 0 in integer context)
	std::string src_null = R"(
func test():
	var x = null
	return 0
)";
	assert(execute_int(src_null, "test") == 0);

	std::cout << "  âœ“ All literal types work" << std::endl;
}

void test_all_operators() {
	std::cout << "Testing all operators..." << std::endl;

	// Arithmetic - all need proper indentation
	assert(execute_int("func test():\n\treturn 10 + 5\n", "test") == 15);
	assert(execute_int("func test():\n\treturn 10 - 5\n", "test") == 5);
	assert(execute_int("func test():\n\treturn 10 * 5\n", "test") == 50);
	assert(execute_int("func test():\n\treturn 10 / 5\n", "test") == 2);
	assert(execute_int("func test():\n\treturn 10 % 3\n", "test") == 1);

	// Comparison
	assert(execute_int("func test():\n\treturn 5 == 5\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 5 != 3\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 3 < 5\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 5 <= 5\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 5 > 3\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 5 >= 5\n", "test") == 1);

	// Logical
	assert(execute_int("func test():\n\treturn 1 and 1\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 1 and 0\n", "test") == 0);
	assert(execute_int("func test():\n\treturn 0 or 1\n", "test") == 1);
	assert(execute_int("func test():\n\treturn 0 or 0\n", "test") == 0);
	assert(execute_int("func test():\n\treturn not 0\n", "test") == 1);
	assert(execute_int("func test():\n\treturn not 1\n", "test") == 0);

	// Unary
	assert(execute_int("func test():\n\treturn -5\n", "test") == -5);

	std::cout << "  âœ“ All operators work" << std::endl;
}

void test_control_flow() {
	std::cout << "Testing all control flow statements..." << std::endl;

	// If
	std::string src_if = R"(
func test():
	if 1:
		return 10
	return 20
)";
	assert(execute_int(src_if, "test") == 10);

	// If-else
	std::string src_if_else = R"(
func test():
	if 0:
		return 10
	else:
		return 20
)";
	assert(execute_int(src_if_else, "test") == 20);

	// If-elif-else
	std::string src_elif = R"(
func test():
	var x = 2
	if x == 1:
		return 10
	elif x == 2:
		return 20
	else:
		return 30
)";
	assert(execute_int(src_elif, "test") == 20);

	// While
	std::string src_while = R"(
func test():
	var i = 0
	var sum = 0
	while i < 5:
		sum = sum + i
		i = i + 1
	return sum
)";
	assert(execute_int(src_while, "test") == 10); // 0+1+2+3+4

	// Break
	std::string src_break = R"(
func test():
	var i = 0
	while 1:
		if i == 5:
			break
		i = i + 1
	return i
)";
	assert(execute_int(src_break, "test") == 5);

	// Continue
	std::string src_continue = R"(
func test():
	var i = 0
	var sum = 0
	while i < 10:
		i = i + 1
		if i % 2 == 0:
			continue
		sum = sum + i
	return sum
)";
	assert(execute_int(src_continue, "test") == 25); // 1+3+5+7+9

	// Pass
	std::string src_pass = R"(
func test():
	if 1:
		pass
	return 42
)";
	assert(execute_int(src_pass, "test") == 42);

	std::cout << "  âœ“ All control flow statements work" << std::endl;
}

void test_variables() {
	std::cout << "Testing variable operations..." << std::endl;

	// Variable declaration with initializer
	std::string src_init = R"(
func test():
	var x = 10
	return x
)";
	assert(execute_int(src_init, "test") == 10);

	// Variable declaration without initializer
	std::string src_no_init = R"(
func test():
	var x
	x = 5
	return x
)";
	assert(execute_int(src_no_init, "test") == 5);

	// Variable assignment
	std::string src_assign = R"(
func test():
	var x = 10
	x = 20
	return x
)";
	assert(execute_int(src_assign, "test") == 20);

	// Multiple variables
	std::string src_multi = R"(
func test():
	var a = 1
	var b = 2
	var c = 3
	return a + b + c
)";
	assert(execute_int(src_multi, "test") == 6);

	std::cout << "  âœ“ Variable operations work" << std::endl;
}

void test_functions() {
	std::cout << "Testing function features..." << std::endl;

	// Function with parameters
	std::string src_params = R"(
func add(a, b):
	return a + b
)";
	assert(execute_int(src_params, "add", {int64_t(3), int64_t(4)}) == 7);

	// Multiple parameters
	std::string src_multi = R"(
func sum(a, b, c, d):
	return a + b + c + d
)";
	assert(execute_int(src_multi, "sum", {int64_t(1), int64_t(2), int64_t(3), int64_t(4)}) == 10);

	// Function without return (implicit return)
	std::string src_no_ret = R"(
func test():
	var x = 10
)";
	execute_int(src_no_ret, "test"); // Should not crash

	// Bare return
	std::string src_bare_ret = R"(
func test():
	var x = 10
	return
)";
	execute_int(src_bare_ret, "test"); // Should not crash

	std::cout << "  âœ“ Function features work" << std::endl;
}

void test_expressions() {
	std::cout << "Testing complex expressions..." << std::endl;

	// Operator precedence
	std::string src_prec = R"(
func test():
	return 2 + 3 * 4
)";
	assert(execute_int(src_prec, "test") == 14); // Not 20

	// Parentheses
	std::string src_paren = R"(
func test():
	return (2 + 3) * 4
)";
	assert(execute_int(src_paren, "test") == 20);

	// Nested expressions
	std::string src_nested = R"(
func test():
	return ((5 + 3) * 2) - (4 / 2)
)";
	assert(execute_int(src_nested, "test") == 14); // (8*2) - 2 = 14

	// Mixed logical and arithmetic
	std::string src_mixed = R"(
func test():
	return (5 > 3) and (2 < 4)
)";
	assert(execute_int(src_mixed, "test") == 1);

	std::cout << "  âœ“ Complex expressions work" << std::endl;
}

void test_edge_cases() {
	std::cout << "Testing edge cases..." << std::endl;

	// Zero
	assert(execute_int("func test():\n\treturn 0\n", "test") == 0);

	// Large numbers
	assert(execute_int("func test():\n\treturn 1000000\n", "test") == 1000000);

	// Division by zero behavior (implementation defined)
	// We skip this as it may crash or return undefined

	// Deeply nested scopes
	std::string src_deep = R"(
func test():
	var x = 1
	if 1:
		var y = 2
		if 1:
			var z = 3
			if 1:
				var w = 4
				return x + y + z + w
	return 0
)";
	assert(execute_int(src_deep, "test") == 10);

	// Empty function body with implicit return
	std::string src_empty = R"(
func test():
	pass
)";
	execute_int(src_empty, "test"); // Should not crash

	std::cout << "  âœ“ Edge cases handled" << std::endl;
}

int main() {
	std::cout << "\n=== Testing All GDScript Primitives ===" << std::endl;
	std::cout << "Verifying that all basic language features work correctly\n" << std::endl;

	try {
		test_literals();
		test_all_operators();
		test_control_flow();
		test_variables();
		test_functions();
		test_expressions();
		test_edge_cases();

		std::cout << "\nâœ… All primitive tests passed!" << std::endl;
		std::cout << "âœ… All basic GDScript features are implemented and working!" << std::endl;
		return 0;
	} catch (const std::exception& e) {
		std::cerr << "\nâŒ Test failed: " << e.what() << std::endl;
		return 1;
	}
}

```

`src/gdscript/compiler/token.cpp`:

```cpp
#include "token.h"
#include <sstream>

namespace gdscript {

const char* token_type_name(TokenType type) {
	switch (type) {
		case TokenType::IDENTIFIER: return "IDENTIFIER";
		case TokenType::INTEGER: return "INTEGER";
		case TokenType::FLOAT: return "FLOAT";
		case TokenType::STRING: return "STRING";
		case TokenType::FUNC: return "FUNC";
		case TokenType::VAR: return "VAR";
		case TokenType::RETURN: return "RETURN";
		case TokenType::IF: return "IF";
		case TokenType::ELSE: return "ELSE";
		case TokenType::ELIF: return "ELIF";
		case TokenType::FOR: return "FOR";
		case TokenType::IN: return "IN";
		case TokenType::WHILE: return "WHILE";
		case TokenType::BREAK: return "BREAK";
		case TokenType::CONTINUE: return "CONTINUE";
		case TokenType::PASS: return "PASS";
		case TokenType::EXTENDS: return "EXTENDS";
		case TokenType::TRUE: return "TRUE";
		case TokenType::FALSE: return "FALSE";
		case TokenType::NULL_VAL: return "NULL";
		case TokenType::PLUS: return "PLUS";
		case TokenType::MINUS: return "MINUS";
		case TokenType::MULTIPLY: return "MULTIPLY";
		case TokenType::DIVIDE: return "DIVIDE";
		case TokenType::MODULO: return "MODULO";
		case TokenType::ASSIGN: return "ASSIGN";
		case TokenType::PLUS_ASSIGN: return "PLUS_ASSIGN";
		case TokenType::MINUS_ASSIGN: return "MINUS_ASSIGN";
		case TokenType::MULTIPLY_ASSIGN: return "MULTIPLY_ASSIGN";
		case TokenType::DIVIDE_ASSIGN: return "DIVIDE_ASSIGN";
		case TokenType::MODULO_ASSIGN: return "MODULO_ASSIGN";
		case TokenType::EQUAL: return "EQUAL";
		case TokenType::NOT_EQUAL: return "NOT_EQUAL";
		case TokenType::LESS: return "LESS";
		case TokenType::LESS_EQUAL: return "LESS_EQUAL";
		case TokenType::GREATER: return "GREATER";
		case TokenType::GREATER_EQUAL: return "GREATER_EQUAL";
		case TokenType::AND: return "AND";
		case TokenType::OR: return "OR";
		case TokenType::NOT: return "NOT";
		case TokenType::LPAREN: return "LPAREN";
		case TokenType::RPAREN: return "RPAREN";
		case TokenType::LBRACKET: return "LBRACKET";
		case TokenType::RBRACKET: return "RBRACKET";
		case TokenType::LBRACE: return "LBRACE";
		case TokenType::RBRACE: return "RBRACE";
		case TokenType::COLON: return "COLON";
		case TokenType::COMMA: return "COMMA";
		case TokenType::DOT: return "DOT";
		case TokenType::AT: return "AT";
		case TokenType::NEWLINE: return "NEWLINE";
		case TokenType::INDENT: return "INDENT";
		case TokenType::DEDENT: return "DEDENT";
		case TokenType::EOF_TOKEN: return "EOF";
		case TokenType::INVALID: return "INVALID";
		default: return "UNKNOWN";
	}
}

std::string Token::to_string() const {
	std::ostringstream oss;
	oss << token_type_name(type) << " '" << lexeme << "' at " << line << ":" << column;
	return oss.str();
}

} // namespace gdscript

```

`src/gdscript/compiler/token.h`:

```h
#pragma once
#include <string>
#include <variant>

namespace gdscript {

enum class TokenType {
	// Literals
	IDENTIFIER,
	INTEGER,
	FLOAT,
	STRING,

	// Keywords
	FUNC,
	VAR,
	CONST,
	RETURN,
	IF,
	ELSE,
	ELIF,
	FOR,
	IN,
	WHILE,
	BREAK,
	CONTINUE,
	PASS,
	EXTENDS,
	TRUE,
	FALSE,
	NULL_VAL,

	// Operators
	PLUS,        // +
	MINUS,       // -
	MULTIPLY,    // *
	DIVIDE,      // /
	MODULO,      // %
	ASSIGN,      // =
	PLUS_ASSIGN,    // +=
	MINUS_ASSIGN,   // -=
	MULTIPLY_ASSIGN, // *=
	DIVIDE_ASSIGN,  // /=
	MODULO_ASSIGN,  // %=
	EQUAL,       // ==
	NOT_EQUAL,   // !=
	LESS,        // <
	LESS_EQUAL,  // <=
	GREATER,     // >
	GREATER_EQUAL, // >=
	AND,         // and
	OR,          // or
	NOT,         // not

	// Delimiters
	LPAREN,      // (
	RPAREN,      // )
	LBRACKET,    // [
	RBRACKET,    // ]
	LBRACE,      // {
	RBRACE,      // }
	COLON,       // :
	COMMA,       // ,
	DOT,         // .
	AT,          // @
	NEWLINE,
	INDENT,
	DEDENT,

	// Special
	EOF_TOKEN,
	INVALID
};

struct Token {
	TokenType type;
	std::string lexeme;
	std::variant<int64_t, double, std::string> value;
	int line;
	int column;

	Token() : type(TokenType::INVALID), line(0), column(0) {}
	Token(TokenType t, std::string lex, int l, int c)
		: type(t), lexeme(std::move(lex)), line(l), column(c) {}

	bool is_type(TokenType t) const { return type == t; }
	bool is_one_of(TokenType t1, TokenType t2) const { return type == t1 || type == t2; }

	template<typename... Types>
	bool is_one_of(TokenType first, Types... rest) const {
		return type == first || is_one_of(rest...);
	}

	std::string to_string() const;
};

const char* token_type_name(TokenType type);

} // namespace gdscript

```

`src/gdscript/compiler/variant_types.h`:

```h
#pragma once

#include <cstdint>

namespace Variant {

enum Type : uint32_t {
	NIL = 0,

	// atomic types
	BOOL = 1,
	INT = 2,
	FLOAT = 3,
	STRING = 4,

	// math types
	VECTOR2 = 5,
	VECTOR2I = 6,
	RECT2 = 7,
	RECT2I = 8,
	VECTOR3 = 9,
	VECTOR3I = 10,
	TRANSFORM2D = 11,
	VECTOR4 = 12,
	VECTOR4I = 13,
	PLANE = 14,
	QUATERNION = 15,
	AABB = 16,
	BASIS = 17,
	TRANSFORM3D = 18,
	PROJECTION = 19,

	// misc types
	COLOR = 20,
	STRING_NAME = 21,
	NODE_PATH = 22,
	RID = 23,
	OBJECT = 24,
	CALLABLE = 25,
	SIGNAL = 26,
	DICTIONARY = 27,
	ARRAY = 28,

	// typed arrays
	PACKED_BYTE_ARRAY = 29,
	PACKED_INT32_ARRAY = 30,
	PACKED_INT64_ARRAY = 31,
	PACKED_FLOAT32_ARRAY = 32,
	PACKED_FLOAT64_ARRAY = 33,
	PACKED_STRING_ARRAY = 34,
	PACKED_VECTOR2_ARRAY = 35,
	PACKED_VECTOR3_ARRAY = 36,
	PACKED_COLOR_ARRAY = 37,
	PACKED_VECTOR4_ARRAY = 38,

	VARIANT_MAX
};

} // namespace Variant

```

`src/godot/script_instance.cpp`:

```cpp
/*************************************************************************/
/* Copyright (c) 2023 David Snopek                                       */
/*                                                                       */
/* Permission is hereby granted, free of charge, to any person obtaining */
/* a copy of this software and associated documentation files (the       */
/* "Software"), to deal in the Software without restriction, including   */
/* without limitation the rights to use, copy, modify, merge, publish,   */
/* distribute, sublicense, and/or sell copies of the Software, and to    */
/* permit persons to whom the Software is furnished to do so, subject to */
/* the following conditions:                                             */
/*                                                                       */
/* The above copyright notice and this permission notice shall be        */
/* included in all copies or substantial portions of the Software.       */
/*                                                                       */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
/*************************************************************************/

#include "script_instance.h"

#include <godot_cpp/templates/local_vector.hpp>

static GDExtensionBool gdextension_script_instance_set(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionConstVariantPtr p_value) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);
	const Variant *value = reinterpret_cast<const Variant *>(p_value);

	return instance->set(*name, *value);
}

static GDExtensionBool gdextension_script_instance_get(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);
	Variant *ret = reinterpret_cast<Variant *>(r_ret);

	return instance->get(*name, *ret);
}

static const GDExtensionPropertyInfo *gdextension_script_instance_get_property_list(GDExtensionScriptInstanceDataPtr p_instance, uint32_t *r_count) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);

	return instance->get_property_list(r_count);
}

static void gdextension_script_instance_free_property_list(GDExtensionScriptInstanceDataPtr p_instance, const GDExtensionPropertyInfo *p_list, uint32_t p_count) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	instance->free_property_list(p_list, p_count);
}

static GDExtensionBool gdextension_script_instance_get_class_category(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionPropertyInfo *r_class_category) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->get_class_category(*r_class_category);
}

static GDExtensionVariantType gdextension_script_instance_get_property_type(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionBool *r_is_valid) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);

	bool is_valid;
	GDExtensionVariantType ret = (GDExtensionVariantType)instance->get_property_type(*name, &is_valid);
	*r_is_valid = is_valid;

	return ret;
}

static GDExtensionBool gdextension_script_instance_validate_property(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionPropertyInfo *p_property) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->validate_property(*p_property);
}

static GDExtensionBool gdextension_script_instance_property_can_revert(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);

	return instance->property_can_revert(*name);
}

static GDExtensionBool gdextension_script_instance_property_get_revert(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);
	Variant *ret = reinterpret_cast<Variant *>(r_ret);

	return instance->property_get_revert(*name, *ret);
}

static GDExtensionObjectPtr gdextension_script_instance_get_owner(GDExtensionScriptInstanceDataPtr p_instance) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);

	Object *ret = instance->get_owner();
	return ret->_owner;
}

static void gdextension_script_instance_get_property_state(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	instance->get_property_state(p_add_func, p_userdata);
}

static const GDExtensionMethodInfo *gdextension_script_instance_get_method_list(GDExtensionScriptInstanceDataPtr p_instance, uint32_t *r_count) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->get_method_list(r_count);
}

static void gdextension_script_instance_free_method_list(GDExtensionScriptInstanceDataPtr p_instance, const GDExtensionMethodInfo *p_list, uint32_t p_count) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->free_method_list(p_list, p_count);
}

static GDExtensionBool gdextension_script_instance_has_method(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);

	return instance->has_method(*name);
}

static GDExtensionInt gdextension_script_instance_get_method_argument_count(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionBool *r_is_valid) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);
	bool *is_valid = reinterpret_cast<bool *>(r_is_valid);

	return instance->get_method_argument_count(*name, *is_valid);
}

static void gdextension_script_instance_call(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_method, const GDExtensionConstVariantPtr *p_args, GDExtensionInt p_argument_count, GDExtensionVariantPtr r_return, GDExtensionCallError *r_error) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *method = reinterpret_cast<const StringName *>(p_method);
	const Variant **args = reinterpret_cast<const Variant **>(const_cast<const void **>(p_args));
	Variant *ret = reinterpret_cast<Variant *>(r_return);

	*ret = instance->callp(*method, args, p_argument_count, *r_error);
}

static void gdextension_script_instance_notification(GDExtensionScriptInstanceDataPtr p_instance, int32_t p_what, GDExtensionBool p_reversed) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	instance->notification(p_what, p_reversed);
}

static void gdextension_script_instance_to_string(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionBool *r_is_valid, GDExtensionStringPtr r_out) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	String *out = reinterpret_cast<String *>(r_out);

	bool is_valid = false;
	*out = instance->to_string(&is_valid);
	*r_is_valid = is_valid;
}

static void gdextension_script_instance_refcount_incremented(GDExtensionScriptInstanceDataPtr p_instance) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	instance->refcount_incremented();
}

static GDExtensionBool gdextension_script_instance_refcount_decremented(GDExtensionScriptInstanceDataPtr p_instance) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->refcount_decremented();
}

static GDExtensionObjectPtr gdextension_script_instance_get_script(GDExtensionScriptInstanceDataPtr p_instance) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->get_script()->_owner;
}

static GDExtensionBool gdextension_script_instance_is_placeholder(GDExtensionScriptInstanceDataPtr p_instance) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->is_placeholder();
}

static GDExtensionBool gdextension_script_instance_set_fallback(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionConstVariantPtr p_value) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);
	const Variant *value = reinterpret_cast<const Variant *>(p_value);

	bool is_valid = false;
	instance->property_set_fallback(*name, *value, &is_valid);
	return is_valid;
}

static GDExtensionBool gdextension_script_instance_get_fallback(GDExtensionScriptInstanceDataPtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	const StringName *name = reinterpret_cast<const StringName *>(p_name);
	Variant *ret = reinterpret_cast<Variant *>(r_ret);

	bool is_valid = false;
	instance->property_get_fallback(*name, &is_valid);
	return is_valid;
}

static GDExtensionScriptLanguagePtr gdextension_script_instance_get_language(GDExtensionScriptInstanceDataPtr p_instance) {
	ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
	return instance->_get_language()->_owner;
}

static void gdextension_script_instance_free(GDExtensionScriptInstanceDataPtr p_instance) {
	if (p_instance) {
		ScriptInstanceExtension *instance = reinterpret_cast<ScriptInstanceExtension *>(p_instance);
		memdelete(instance);
	}
}

GDExtensionScriptInstanceInfo3 ScriptInstanceExtension::script_instance_info = {
	&gdextension_script_instance_set,
	&gdextension_script_instance_get,
	&gdextension_script_instance_get_property_list,
	&gdextension_script_instance_free_property_list,
	nullptr, //&gdextension_script_instance_get_class_category,
	&gdextension_script_instance_property_can_revert,
	&gdextension_script_instance_property_get_revert,
	&gdextension_script_instance_get_owner,
	&gdextension_script_instance_get_property_state,
	&gdextension_script_instance_get_method_list,
	&gdextension_script_instance_free_method_list,
	&gdextension_script_instance_get_property_type,
	&gdextension_script_instance_validate_property,
	&gdextension_script_instance_has_method,
	&gdextension_script_instance_get_method_argument_count,
	&gdextension_script_instance_call,
	&gdextension_script_instance_notification,
	&gdextension_script_instance_to_string,
	&gdextension_script_instance_refcount_incremented,
	&gdextension_script_instance_refcount_decremented,
	&gdextension_script_instance_get_script,
	&gdextension_script_instance_is_placeholder,
	&gdextension_script_instance_set_fallback,
	&gdextension_script_instance_get_fallback,
	&gdextension_script_instance_get_language,
	&gdextension_script_instance_free,
};

bool ScriptInstanceExtension::get_class_category(GDExtensionPropertyInfo &r_class_category) const {
	Ref<Script> script = get_script();
	if (script.is_valid()) {
		StringName name = script->get_name();
		String path = script->get_path();
		r_class_category.type = GDEXTENSION_VARIANT_TYPE_NIL;
		r_class_category.name = &name;
		r_class_category.hint = PROPERTY_HINT_NONE;
		r_class_category.hint_string = &path;
		r_class_category.usage = PROPERTY_USAGE_CATEGORY;
		return true;
	}
	return false;
}

```

`src/godot/script_instance.h`:

```h
/*************************************************************************/
/* Copyright (c) 2023 David Snopek                                       */
/*                                                                       */
/* Permission is hereby granted, free of charge, to any person obtaining */
/* a copy of this software and associated documentation files (the       */
/* "Software"), to deal in the Software without restriction, including   */
/* without limitation the rights to use, copy, modify, merge, publish,   */
/* distribute, sublicense, and/or sell copies of the Software, and to    */
/* permit persons to whom the Software is furnished to do so, subject to */
/* the following conditions:                                             */
/*                                                                       */
/* The above copyright notice and this permission notice shall be        */
/* included in all copies or substantial portions of the Software.       */
/*                                                                       */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
/*************************************************************************/

#pragma once

#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_language.hpp>
#include <godot_cpp/templates/list.hpp>
#include <godot_cpp/templates/pair.hpp>
#include <godot_cpp/variant/string_name.hpp>
#include <godot_cpp/variant/variant.hpp>

using namespace godot;

namespace godot {

class ScriptInstanceExtension {
	static GDExtensionScriptInstanceInfo3 script_instance_info;

public:
	static GDExtensionScriptInstancePtr create_native_instance(ScriptInstanceExtension *p_instance) {
		return internal::gdextension_interface_script_instance_create3(&script_instance_info, p_instance);
	}

	virtual bool set(const StringName &p_name, const Variant &p_value) = 0;
	virtual bool get(const StringName &p_name, Variant &r_ret) const = 0;
	virtual const GDExtensionPropertyInfo *get_property_list(uint32_t *r_count) const = 0;
	virtual void free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const = 0;
	virtual Variant::Type get_property_type(const StringName &p_name, bool *r_is_valid) const = 0;
	virtual bool validate_property(GDExtensionPropertyInfo &p_property) const = 0;
	virtual bool get_class_category(GDExtensionPropertyInfo &r_class_category) const;
	virtual bool property_can_revert(const StringName &p_name) const = 0;
	virtual bool property_get_revert(const StringName &p_name, Variant &r_ret) const = 0;
	virtual Object *get_owner() = 0;
	virtual void get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) = 0;
	virtual const GDExtensionMethodInfo *get_method_list(uint32_t *r_count) const = 0;
	virtual void free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const = 0;
	virtual bool has_method(const StringName &p_method) const = 0;
	virtual GDExtensionInt get_method_argument_count(const StringName &p_method, bool &r_valid) const = 0;
	// @todo Should godot-cpp have a Callable::CallError?
	virtual Variant callp(const StringName &p_method, const Variant **p_args, int p_argcount, GDExtensionCallError &r_error) = 0;
	virtual void notification(int p_notification, bool p_reversed) = 0;
	virtual String to_string(bool *r_valid) = 0;
	virtual void refcount_incremented() = 0;
	virtual bool refcount_decremented() = 0;
	virtual Ref<Script> get_script() const = 0;
	virtual bool is_placeholder() const = 0;
	virtual void property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) = 0;
	virtual Variant property_get_fallback(const StringName &p_name, bool *r_valid) = 0;
	virtual ScriptLanguage *_get_language() = 0;

	virtual ~ScriptInstanceExtension() {};
};

}; // namespace godot

```

`src/guest_datatypes.h`:

```h
#include "sandbox.h"

#include <libriscv/native_heap.hpp>

// -= Fast-path Variant Arguments =-

struct GDNativeVariant {
	uint8_t type;
	uint8_t padding[7];
	union {
		struct {
			double flt;
			uint64_t flt_padding1;
		};
		struct {
			uint64_t value;
			uint64_t i64_padding;
		};
		struct {
			real_t vec2_flt[2];
		};
		struct {
			int32_t ivec2_int[2];
		};
		struct {
			real_t vec3_flt[3];
		};
		struct {
			int32_t ivec3_int[3];
		};
		struct {
			real_t vec4_flt[4];
		};
		struct {
			int32_t ivec4_int[4];
		};
		struct {
			float color_flt[4];
		};
		struct {
			uint64_t object_id;
			GodotObject *object_ptr;
		};
	};

	godot::Object *to_object() const {
		if (object_ptr == nullptr)
			return nullptr;
		return internal::get_object_instance_binding(object_ptr);
	}

} __attribute__((packed));

// -= Guest Data Types =-
struct GuestStdU32String {
	gaddr_t ptr;
	gaddr_t size;
	gaddr_t capacity;

	char32_t *to_array(const machine_t &machine) const {
		return machine.memory.memarray<char32_t>(ptr, size);
	}
	std::u32string to_u32string(const machine_t &machine, std::size_t max_len = 4UL << 20) const {
		if (size > max_len)
			throw std::runtime_error("Guest std::u32string too large (size > 4MB)");
		// Copy the string from guest memory
		const std::u32string_view view{ to_array(machine), size_t(size) };
		return std::u32string(view.begin(), view.end());
	}

	String to_godot_string(const machine_t &machine, std::size_t max_len = 1UL << 20) const {
		if (size > max_len)
			throw std::runtime_error("Guest std::u32string too large (size > 4MB)");
		// Get a view of the string from guest memory, including the null terminator
		const std::u32string_view view{ to_array(machine), size_t(size + 1) };
		if (view.back() == U'\0') {
			// Convert the string to a godot String directly
			return String(view.data());
		} else {
			// Use a temporary std::u32string to convert the string to a godot String
			std::u32string str(view.begin(), view.end() - 1);
			return String(str.c_str());
		}
	}

	void set_string(machine_t &machine, gaddr_t self, const char32_t *str, std::size_t len) {
		// Allocate memory for the string
		this->ptr = machine.arena().malloc(len * sizeof(char32_t));
		this->size = len;
		this->capacity = len;
		// Copy the string to guest memory
		char32_t *guest_ptr = machine.memory.memarray<char32_t>(this->ptr, len);
		std::memcpy(guest_ptr, str, len * sizeof(char32_t));
	}

	void free(machine_t &machine) {
		if (ptr != 0x0)
			machine.arena().free(ptr);
	}
};

struct GuestVariant {
	/**
	 * @brief Creates a new godot Variant from a GuestVariant that comes from a sandbox.
	 *
	 * @param emu The sandbox that the GuestVariant comes from.
	 * @return Variant The new godot Variant.
	 **/
	Variant toVariant(const Sandbox &emu) const;

	/**
	 * @brief Returns a pointer to a Variant that comes from a sandbox. This Variant must be
	 * already stored in the sandbox's state. This usually means it's a complex Variant that is
	 * never copied to the guest memory. Most complex types are stored in the call state and are
	 * referenced by their index.
	 *
	 * @param emu The sandbox that the GuestVariant comes from.
	 * @return const Variant* The pointer to the Variant.
	 **/
	const Variant *toVariantPtr(const Sandbox &emu) const;

	/**
	 * @brief Sets the value of the GuestVariant from a godot Variant.
	 *
	 * @param emu The sandbox that the GuestVariant comes from.
	 * @param value The godot Variant.
	 * @param implicit_trust If true, creating a complex type will not throw an error.
	 * @throw std::runtime_error If the type is not supported.
	 * @throw std::runtime_error If the type is complex and implicit_trust is false.
	 **/
	void set(Sandbox &emu, const Variant &value, bool implicit_trust = false);

	/**
	 * @brief Sets the value of the GuestVariant to a godot Object. The object is added to the
	 * scoped objects list and the GuestVariant stores the untranslated address to the object.
	 * @warning The object is implicitly trusted, treated as allowed.
	 *
	 * @param emu The sandbox that the GuestVariant comes from.
	 * @param obj The godot Object.
	 **/
	void set_object(Sandbox &emu, godot::Object *obj);

	/**
	 * @brief Creates a new GuestVariant from a godot Variant. Trust is implicit for complex types.
	 * The variant is constructed directly into the call state, and the GuestVariant is an index
	 * to it. For objects, the object is added to the scoped objects list and the GuestVariant
	 * stores the untranslated address to the object.
	 *
	 * @param emu The sandbox that the GuestVariant comes from.
	 * @param value The godot Variant.
	 * @throw std::runtime_error If the type is not supported.
	 **/
	void create(Sandbox &emu, Variant &&value);

	/**
	 * @brief Check if the GuestVariant is implemented using an index to a scoped Variant.
	 *
	 * @return true If the type of the GuestVariant is implemented using an index to a scoped Variant.
	 */
	bool is_scoped_variant() const noexcept;

	Variant::Type type = Variant::NIL;
	union alignas(8) {
		int64_t i = 0;
		bool b;
		double f;
		std::array<real_t, 2> v2f;
		std::array<real_t, 3> v3f;
		std::array<real_t, 4> v4f;
		std::array<int32_t, 2> v2i;
		std::array<int32_t, 3> v3i;
		std::array<int32_t, 4> v4i;
	} v;

	void free(Sandbox &emu);

	static const char *type_name(int type);
	static const char *type_name(Variant::Type type) { return type_name(int(type)); }
};

inline bool GuestVariant::is_scoped_variant() const noexcept {
	switch (type) {
		case Variant::STRING:
		case Variant::TRANSFORM2D:
		case Variant::QUATERNION:
		case Variant::AABB:
		case Variant::BASIS:
		case Variant::TRANSFORM3D:
		case Variant::PROJECTION:
		case Variant::DICTIONARY:
		case Variant::ARRAY:
		case Variant::CALLABLE:
		case Variant::STRING_NAME:
		case Variant::NODE_PATH:
		case Variant::RID:
		case Variant::PACKED_BYTE_ARRAY:
		case Variant::PACKED_FLOAT32_ARRAY:
		case Variant::PACKED_FLOAT64_ARRAY:
		case Variant::PACKED_INT32_ARRAY:
		case Variant::PACKED_INT64_ARRAY:
		case Variant::PACKED_VECTOR2_ARRAY:
		case Variant::PACKED_VECTOR3_ARRAY:
		case Variant::PACKED_VECTOR4_ARRAY:
		case Variant::PACKED_COLOR_ARRAY:
		case Variant::PACKED_STRING_ARRAY: {
			return true;
		}
		case Variant::OBJECT: // Objects are raw pointers.
		default:
			return false;
	}
}

static inline void hash_combine(gaddr_t &seed, gaddr_t hash) {
	hash += 0x9e3779b9 + (seed << 6) + (seed >> 2);
	seed ^= hash;
}

#include "syscalls_helpers.hpp"

inline String to_godot_string(const riscv::CppString *string, machine_t &machine, std::size_t max_len = 4UL << 20) {
	std::string_view view = string->to_view(machine, max_len);
	return String::utf8(view.data(), view.size());
}
inline PackedByteArray to_godot_packed_byte_array(const riscv::CppString *string, machine_t &machine, std::size_t max_len = 4UL << 20) {
	std::string_view view = string->to_view(machine, max_len);
	PackedByteArray arr;
	arr.resize(view.size());
	std::memcpy(arr.ptrw(), view.data(), view.size());
	return arr;
}

```

`src/guest_variant.cpp`:

```cpp
#include "guest_datatypes.h"

#include <godot_cpp/variant/utility_functions.hpp>
#include <libriscv/util/crc32.hpp>

namespace riscv {
extern godot::Object *get_object_from_address(const Sandbox &emu, uint64_t addr);
} //namespace riscv

Variant GuestVariant::toVariant(const Sandbox &emu) const {
	switch (type) {
		case Variant::NIL:
			return Variant();
		case Variant::BOOL:
			return v.b;
		case Variant::INT:
			return v.i;
		case Variant::FLOAT:
			return v.f;

		case Variant::VECTOR2:
			return Variant{ godot::Vector2(v.v2f[0], v.v2f[1]) };
		case Variant::VECTOR2I:
			return Variant{ godot::Vector2i(v.v2i[0], v.v2i[1]) };
		case Variant::RECT2:
			return Variant{ godot::Rect2(v.v4f[0], v.v4f[1], v.v4f[2], v.v4f[3]) };
		case Variant::RECT2I:
			return Variant{ godot::Rect2i(v.v4i[0], v.v4i[1], v.v4i[2], v.v4i[3]) };
		case Variant::VECTOR3:
			return Variant{ godot::Vector3(v.v3f[0], v.v3f[1], v.v3f[2]) };
		case Variant::VECTOR3I:
			return Variant{ godot::Vector3i(v.v3i[0], v.v3i[1], v.v3i[2]) };
		case Variant::VECTOR4:
			return Variant{ godot::Vector4(v.v4f[0], v.v4f[1], v.v4f[2], v.v4f[3]) };
		case Variant::VECTOR4I:
			return Variant{ godot::Vector4i(v.v4i[0], v.v4i[1], v.v4i[2], v.v4i[3]) };
		case Variant::COLOR:
			return Variant{ godot::Color(v.v4f[0], v.v4f[1], v.v4f[2], v.v4f[3]) };
		case Variant::PLANE:
			return Variant{ godot::Plane(godot::Vector3(v.v4f[0], v.v4f[1], v.v4f[2]), v.v4f[3]) };

		case Variant::OBJECT: {
			godot::Object *obj = riscv::get_object_from_address(emu, v.i);
			return Variant{ obj };
		}

		default:
			if (std::optional<const Variant *> v = emu.get_scoped_variant(this->v.i)) {
				const Variant *var = *v;
				return *var;
			} else {
				char buffer[128];
				snprintf(buffer, sizeof(buffer), "GuestVariant::toVariant(): %u (%s) is not known/scoped",
						type, GuestVariant::type_name(type));
				throw std::runtime_error(buffer);
			}
	}
}

const Variant *GuestVariant::toVariantPtr(const Sandbox &emu) const {
	if (std::optional<const Variant *> v = emu.get_scoped_variant(this->v.i))
		return v.value();

	char buffer[128];
	snprintf(buffer, sizeof(buffer), "GuestVariant::toVariantPtr(): %u (%s) is not known/scoped",
			type, GuestVariant::type_name(type));
	throw std::runtime_error(buffer);
}

void GuestVariant::set_object(Sandbox &emu, godot::Object *obj) {
	emu.add_scoped_object(obj);
	this->type = Variant::OBJECT;
	this->v.i = (uintptr_t)obj;
}

void GuestVariant::set(Sandbox &emu, const Variant &value, bool implicit_trust) {
	this->type = value.get_type();

	switch (this->type) {
		case Variant::NIL:
			break;
		case Variant::BOOL:
			this->v.b = value;
			break;
		case Variant::INT:
			this->v.i = value;
			break;
		case Variant::FLOAT:
			this->v.f = value;
			break;

		case Variant::VECTOR2: {
			godot::Vector2 vec = value.operator godot::Vector2();
			this->v.v2f[0] = vec.x;
			this->v.v2f[1] = vec.y;
			break;
		}
		case Variant::VECTOR2I: {
			godot::Vector2i vec = value.operator godot::Vector2i();
			this->v.v2i[0] = vec.x;
			this->v.v2i[1] = vec.y;
			break;
		}
		case Variant::RECT2: {
			Rect2 rect = value.operator godot::Rect2();
			this->v.v4f[0] = rect.position[0];
			this->v.v4f[1] = rect.position[1];
			this->v.v4f[2] = rect.size[0];
			this->v.v4f[3] = rect.size[1];
			break;
		}
		case Variant::RECT2I: {
			Rect2i rect = value.operator godot::Rect2i();
			this->v.v4i[0] = rect.position[0];
			this->v.v4i[1] = rect.position[1];
			this->v.v4i[2] = rect.size[0];
			this->v.v4i[3] = rect.size[1];
			break;
		}
		case Variant::VECTOR3: {
			godot::Vector3 vec = value.operator godot::Vector3();
			this->v.v3f[0] = vec.x;
			this->v.v3f[1] = vec.y;
			this->v.v3f[2] = vec.z;
			break;
		}
		case Variant::VECTOR3I: {
			godot::Vector3i vec = value.operator godot::Vector3i();
			this->v.v3i[0] = vec.x;
			this->v.v3i[1] = vec.y;
			this->v.v3i[2] = vec.z;
			break;
		}
		case Variant::VECTOR4: {
			godot::Vector4 vec = value.operator godot::Vector4();
			this->v.v4f[0] = vec.x;
			this->v.v4f[1] = vec.y;
			this->v.v4f[2] = vec.z;
			this->v.v4f[3] = vec.w;
			break;
		}
		case Variant::VECTOR4I: {
			godot::Vector4i vec = value.operator godot::Vector4i();
			this->v.v4i[0] = vec.x;
			this->v.v4i[1] = vec.y;
			this->v.v4i[2] = vec.z;
			this->v.v4i[3] = vec.w;
			break;
		}
		case Variant::COLOR: {
			godot::Color color = value.operator godot::Color();
			this->v.v4f[0] = color.r;
			this->v.v4f[1] = color.g;
			this->v.v4f[2] = color.b;
			this->v.v4f[3] = color.a;
			break;
		}
		case Variant::PLANE: {
			godot::Plane plane = value.operator godot::Plane();
			this->v.v4f[0] = plane.normal.x;
			this->v.v4f[1] = plane.normal.y;
			this->v.v4f[2] = plane.normal.z;
			this->v.v4f[3] = plane.d;
			break;
		}

		case Variant::OBJECT: { // Objects are represented as uintptr_t
			if (!implicit_trust)
				throw std::runtime_error("GuestVariant::set(): Cannot set OBJECT type without implicit trust");
			// TODO: Check if the object is already scoped?
			godot::Object *obj = value.operator godot::Object *();
			if (!emu.is_allowed_object(obj))
				throw std::runtime_error("GuestVariant::set(): Object is not allowed");
			emu.add_scoped_object(obj);
			this->v.i = (uintptr_t)obj;
			break;
		}

		default: {
			if (!implicit_trust)
				throw std::runtime_error("GuestVariant::set(): Cannot set complex type without implicit trust");
			this->v.i = emu.add_scoped_variant(&value);
		}
	}
}

void GuestVariant::create(Sandbox &emu, Variant &&value) {
	this->type = value.get_type();

	switch (this->type) {
		case Variant::NIL:
		case Variant::BOOL:
		case Variant::INT:
		case Variant::FLOAT:

		case Variant::VECTOR2:
		case Variant::VECTOR2I:
		case Variant::RECT2:
		case Variant::RECT2I:
		case Variant::VECTOR3:
		case Variant::VECTOR3I:
		case Variant::VECTOR4:
		case Variant::VECTOR4I:
		case Variant::COLOR:
		case Variant::PLANE:
			this->set(emu, value, true); // Trust the value
			break;

		case Variant::OBJECT: {
			godot::Object *obj = value.operator godot::Object *();
			if (!emu.is_allowed_object(obj))
				throw std::runtime_error("GuestVariant::create(): Object is not allowed");
			emu.add_scoped_object(obj);
			this->v.i = (uintptr_t)obj;
			break;
		}

		default: {
			// Store the variant in the current state
			unsigned int idx = emu.create_scoped_variant(std::move(value));
			this->v.i = idx;
		}
	}
}

void GuestVariant::free(Sandbox &emu) {
	throw std::runtime_error("GuestVariant::free(): Not implemented");
}

static const char *variant_type_names[] = {
	"Nil",

	"Bool", // 1
	"Int",
	"Float",
	"String",

	"Vector2", // 5
	"Vector2i",
	"Rect2",
	"Rect2i",
	"Vector3",
	"Vector3i",
	"Transform2D",
	"Vector4",
	"Vector4i",
	"Plane",
	"Quaternion",
	"AABB",
	"Basis",
	"Transform3D",
	"Projection",

	"Color", // 20
	"StringName",
	"NodePath",
	"RID",
	"Object",
	"Callable",
	"Signal",
	"Dictionary",
	"Array",

	"PackedByteArray", // 29
	"PackedInt32Array",
	"PackedInt64Array",
	"PackedFloat32Array",
	"PackedFloat64Array",
	"PackedStringArray",
	"PackedVector2Array",
	"PackedVector3Array",
	"PackedColorArray",
	"PackedVector4Array",

	"Max",
};

const char *GuestVariant::type_name(int type) {
	if (type < 0 || type >= Variant::Type::VARIANT_MAX) {
		return "Unknown";
	}
	return variant_type_names[type];
}

```

`src/libriscv_settings.h`:

```h
#ifndef LIBRISCV_SETTINGS_H
#define LIBRISCV_SETTINGS_H

/*
 * These values are automatically set according to their cmake variables.
 */
/* #undef RISCV_DEBUG */
#define RISCV_EXT_A
#define RISCV_EXT_C
/* #undef RISCV_EXT_V */
/* #undef RISCV_32I */
#define RISCV_64I
/* #undef RISCV_128I */
/* #undef RISCV_FCSR */
/* #undef RISCV_EXPERIMENTAL */
/* #undef RISCV_MEMORY_TRAPS */
/* #undef RISCV_MULTIPROCESS */
#define RISCV_BINARY_TRANSLATION
#define RISCV_FLAT_RW_ARENA
/* #undef RISCV_ENCOMPASSING_ARENA */
#define RISCV_THREADED
/* #undef RISCV_TAILCALL_DISPATCH */
/* #undef RISCV_LIBTCC */

#endif /* LIBRISCV_SETTINGS_H */

```

`src/override_libriscv.cpp`:

```cpp
#include <libriscv/machine.hpp>

namespace riscv {

template <int W>
void add_socket_syscalls(Machine<W>& machine) {
}

#ifdef RISCV_32I
template void add_socket_syscalls<4>(Machine<4> &);
#endif
#ifdef RISCV_64I
template void add_socket_syscalls<8>(Machine<8> &);
#endif
} // namespace riscv

```

`src/register_types.cpp`:

```cpp
#include "register_types.h"

#include <gdextension_interface.h>

#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/core/class_db.hpp>
#include <godot_cpp/core/defs.hpp>
#include <godot_cpp/godot.hpp>
#include <godot_cpp/core/error_macros.hpp>

#include "elf/resource_loader_elf.h"
#include "elf/resource_saver_elf.h"
#include "elf/script_elf.h"
#include "elf/script_language_elf.h"
#include "sandbox.h"
#include "sandbox_project_settings.h"
#include "cpp/resource_loader_cpp.h"
#include "cpp/resource_saver_cpp.h"
#include "cpp/script_cpp.h"
#include "cpp/script_language_cpp.h"
#include "safegdscript/script_safegdscript.h"
#include "safegdscript/script_language_safegdscript.h"
#include "safegdscript/resource_loader_safegdscript.h"
#include "safegdscript/resource_saver_safegdscript.h"
#ifdef PLATFORM_HAS_EDITOR
#include "rust/resource_loader_rust.h"
#include "rust/resource_saver_rust.h"
#include "rust/script_language_rust.h"
#include "rust/script_rust.h"
#include "zig/resource_loader_zig.h"
#include "zig/resource_saver_zig.h"
#include "zig/script_language_zig.h"
#include "zig/script_zig.h"
#endif

using namespace godot;

static Ref<ResourceFormatLoaderELF> elf_loader;
static Ref<ResourceFormatSaverELF> elf_saver;

static ELFScriptLanguage *elf_language;

ScriptLanguage *get_elf_language() {
	return elf_language;
}

static void initialize_riscv_module(ModuleInitializationLevel p_level) {
	if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
		return;
	}
	ClassDB::register_class<Sandbox>();
	ClassDB::register_class<ELFScript>();
	ClassDB::register_class<ELFScriptLanguage>();
	ClassDB::register_class<ResourceFormatLoaderELF>();
	ClassDB::register_class<ResourceFormatSaverELF>();
	ClassDB::register_class<CPPScript>();
	ClassDB::register_class<CPPScriptLanguage>();
	ClassDB::register_class<ResourceFormatLoaderCPP>();
	ClassDB::register_class<ResourceFormatSaverCPP>();
	ClassDB::register_class<SafeGDScript>();
	ClassDB::register_class<SafeGDScriptLanguage>();
	ClassDB::register_class<ResourceFormatLoaderSafeGDScript>();
	ClassDB::register_class<ResourceFormatSaverSafeGDScript>();
#ifdef PLATFORM_HAS_EDITOR
	ClassDB::register_class<RustScript>();
	ClassDB::register_class<RustScriptLanguage>();
	ClassDB::register_class<ResourceFormatLoaderRust>();
	ClassDB::register_class<ResourceFormatSaverRust>();
	ClassDB::register_class<ZigScript>();
	ClassDB::register_class<ZigScriptLanguage>();
	ClassDB::register_class<ResourceFormatLoaderZig>();
	ClassDB::register_class<ResourceFormatSaverZig>();
#endif
	elf_loader.instantiate();
	elf_saver.instantiate();
	ResourceLoader::get_singleton()->add_resource_format_loader(elf_loader, true);
	ResourceSaver::get_singleton()->add_resource_format_saver(elf_saver);
	elf_language = memnew(ELFScriptLanguage);
	Engine::get_singleton()->register_script_language(elf_language);
	ResourceFormatLoaderCPP::init();
	ResourceFormatSaverCPP::init();
	CPPScriptLanguage::init();
	SafeGDScriptLanguage::init();
	ResourceFormatLoaderSafeGDScript::init();
	ResourceFormatSaverSafeGDScript::init();
#ifdef PLATFORM_HAS_EDITOR
	ResourceFormatLoaderRust::init();
	ResourceFormatSaverRust::init();
	RustScriptLanguage::init();
	ResourceFormatLoaderZig::init();
	ResourceFormatSaverZig::init();
	ZigScriptLanguage::init();
#endif
	SandboxProjectSettings::register_settings();
	// Initialize the Sandbox node.
	Sandbox::Initialize();
}

static void uninitialize_riscv_module(ModuleInitializationLevel p_level) {
	if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
		return;
	}
	Engine *engine = Engine::get_singleton();
	CPPScriptLanguage::deinit();
	SafeGDScriptLanguage::deinit();
#ifdef PLATFORM_HAS_EDITOR
	RustScriptLanguage::deinit();
	ZigScriptLanguage::deinit();
#endif
	if (elf_language) {
		engine->unregister_script_language(elf_language);
		memdelete(elf_language);
		elf_language = nullptr;
	}

	ResourceLoader::get_singleton()->remove_resource_format_loader(elf_loader);
	ResourceSaver::get_singleton()->remove_resource_format_saver(elf_saver);
	elf_loader.unref();
	elf_saver.unref();
	ResourceFormatLoaderCPP::deinit();
	ResourceFormatSaverCPP::deinit();
	ResourceFormatLoaderSafeGDScript::deinit();
	ResourceFormatSaverSafeGDScript::deinit();
#ifdef PLATFORM_HAS_EDITOR
	ResourceFormatLoaderRust::deinit();
	ResourceFormatSaverRust::deinit();
	ResourceFormatLoaderZig::deinit();
	ResourceFormatSaverZig::deinit();
#endif
}

extern "C" {
// Initialization.
GDExtensionBool GDE_EXPORT riscv_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
	godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);

	init_obj.register_initializer(initialize_riscv_module);
	init_obj.register_terminator(uninitialize_riscv_module);
	init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

	return init_obj.init();
}
}

```

`src/register_types.h`:

```h
#pragma once
#include <godot_cpp/classes/script_language.hpp>

godot::ScriptLanguage *get_elf_language();

#if defined(__wasm__) || defined(__ios__) || defined(__ANDROID__)
#define EDITORLESS_PLATFORM
#else
#define PLATFORM_HAS_EDITOR
#endif

```

`src/rust/resource_loader_rust.cpp`:

```cpp
#include "resource_loader_rust.h"
#include "script_rust.h"
#include <godot_cpp/classes/file_access.hpp>

static Ref<ResourceFormatLoaderRust> rust_loader;

void ResourceFormatLoaderRust::init() {
	rust_loader.instantiate();
	ResourceLoader::get_singleton()->add_resource_format_loader(rust_loader);
}

void ResourceFormatLoaderRust::deinit() {
	ResourceLoader::get_singleton()->remove_resource_format_loader(rust_loader);
	rust_loader.unref();
}

Variant ResourceFormatLoaderRust::_load(const String &p_path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const {
	Ref<RustScript> model = memnew(RustScript);
	model->_set_source_code(FileAccess::get_file_as_string(p_path));
	return model;
}
PackedStringArray ResourceFormatLoaderRust::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("rs");
	return array;
}
bool ResourceFormatLoaderRust::_handles_type(const StringName &type) const {
	String type_str = type;
	return type_str == "RustScript" || type_str == "Script";
}
String ResourceFormatLoaderRust::_get_resource_type(const String &p_path) const {
	String el = p_path.get_extension().to_lower();
	if (el == "rs") {
		return "RustScript";
	}
	return "";
}

```

`src/rust/resource_loader_rust.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_loader.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

using namespace godot;

class ResourceFormatLoaderRust : public ResourceFormatLoader {
	GDCLASS(ResourceFormatLoaderRust, ResourceFormatLoader);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Variant _load(const String &path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual bool _handles_type(const StringName &type) const override;
	virtual String _get_resource_type(const String &p_path) const override;
};

```

`src/rust/resource_saver_rust.cpp`:

```cpp
#include "resource_saver_rust.h"
#include "../elf/script_elf.h"
#include "../elf/script_language_elf.h"
#include "../register_types.h"
#include "../sandbox_project_settings.h"
#include "script_rust.h"
#include <godot_cpp/classes/editor_file_system.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/editor_settings.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/os.hpp>
#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_editor.hpp>
#include <godot_cpp/classes/script_editor_base.hpp>
#include <godot_cpp/variant/utility_functions.hpp>

static Ref<ResourceFormatSaverRust> rust_saver;
static constexpr bool VERBOSE_CMD = false;

void ResourceFormatSaverRust::init() {
	rust_saver.instantiate();
	ResourceSaver::get_singleton()->add_resource_format_saver(rust_saver);
}

void ResourceFormatSaverRust::deinit() {
	ResourceSaver::get_singleton()->remove_resource_format_saver(rust_saver);
	rust_saver.unref();
}

Error ResourceFormatSaverRust::_save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) {
	RustScript *script = Object::cast_to<RustScript>(p_resource.ptr());
	if (script != nullptr) {
		Ref<FileAccess> handle = FileAccess::open(p_path, FileAccess::ModeFlags::WRITE);
		if (handle.is_valid()) {
			handle->store_string(script->_get_source_code());
			handle->close();
			// Get the absolute path without the file name
			String path = handle->get_path().get_base_dir().replace("res://", "") + "/";
			String inpname = path + "*.rs";
			String foldername = Docker::GetFolderName(handle->get_path().get_base_dir());
			String outname = path + foldername + String(".elf");

			// Lazily start the docker container
			RustScript::DockerContainerStart();

			auto builder = [inpname = std::move(inpname), outname = std::move(outname)] {
				// Invoke docker to compile the file
				Array output;
				RustScript::DockerContainerExecute({ "/usr/project/build.sh", "-o", outname, inpname }, output);
				if (!output.is_empty() && !output[0].operator String().is_empty()) {
					for (int i = 0; i < output.size(); i++) {
						String line = output[i].operator String();
						if constexpr (VERBOSE_CMD)
							ERR_PRINT(line);
						// Remove (most) console color codes
						line = line.replace("\033[0;31m", "");
						line = line.replace("\033[0;32m", "");
						line = line.replace("\033[0;33m", "");
						line = line.replace("\033[0;34m", "");
						line = line.replace("\033[0;35m", "");
						line = line.replace("\033[0;36m", "");
						line = line.replace("\033[0;37m", "");
						line = line.replace("\033[01;31m", "");
						line = line.replace("\033[01;32m", "");
						line = line.replace("\033[01;33m", "");
						line = line.replace("\033[01;34m", "");
						line = line.replace("\033[01;35m", "");
						line = line.replace("\033[01;36m", "");
						line = line.replace("\033[01;37m", "");
						line = line.replace("\033[m", "");
						line = line.replace("\033[0m", "");
						line = line.replace("\033[01m", "");
						line = line.replace("[K", "");
						line = line.replace("[1m", "");
						line = line.replace("[38;5;14m", "");
						line = line.replace("[38;5;12m", "");
						line = line.replace("[38;5;10m", "");
						line = line.replace("[38;5;9m", "");
						line = line.replace("[32m", "");
						line = line.replace("[33m", "");
						WARN_PRINT(line);
					}
				}
			};
			builder();
			// EditorInterface::get_singleton()->get_editor_settings()->set("text_editor/behavior/files/auto_reload_scripts_on_external_change", true);
			EditorInterface::get_singleton()->get_resource_filesystem()->scan();
			TypedArray<Script> open_scripts = EditorInterface::get_singleton()->get_script_editor()->get_open_scripts();
			for (int i = 0; i < open_scripts.size(); i++) {
				ELFScript *elf_script = Object::cast_to<ELFScript>(open_scripts[i]);
				if (elf_script) {
					elf_script->reload(false);
					elf_script->emit_changed();
				}
			}
			return Error::OK;
		} else {
			return Error::ERR_FILE_CANT_OPEN;
		}
	}
	return Error::ERR_SCRIPT_FAILED;
}
Error ResourceFormatSaverRust::_set_uid(const String &p_path, int64_t p_uid) {
	return Error::OK;
}
bool ResourceFormatSaverRust::_recognize(const Ref<Resource> &p_resource) const {
	return Object::cast_to<RustScript>(p_resource.ptr()) != nullptr;
}
PackedStringArray ResourceFormatSaverRust::_get_recognized_extensions(const Ref<Resource> &p_resource) const {
	PackedStringArray array;
	if (Object::cast_to<RustScript>(p_resource.ptr()) == nullptr)
		return array;
	array.push_back("rs");
	return array;
}
bool ResourceFormatSaverRust::_recognize_path(const Ref<Resource> &p_resource, const String &p_path) const {
	return Object::cast_to<RustScript>(p_resource.ptr()) != nullptr;
}

```

`src/rust/resource_saver_rust.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_saver.hpp>
#include <godot_cpp/classes/resource_saver.hpp>

using namespace godot;

class ResourceFormatSaverRust : public ResourceFormatSaver {
	GDCLASS(ResourceFormatSaverRust, ResourceFormatSaver);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Error _save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) override;
	virtual Error _set_uid(const String &p_path, int64_t p_uid) override;
	virtual bool _recognize(const Ref<Resource> &p_resource) const override;
	virtual PackedStringArray _get_recognized_extensions(const Ref<Resource> &p_resource) const override;
	virtual bool _recognize_path(const Ref<Resource> &p_resource, const String &p_path) const override;
};

```

`src/rust/script_language_rust.cpp`:

```cpp
#include "script_language_rust.h"
#include "../script_language_common.h"
#include "script_rust.h"
#include <godot_cpp/classes/control.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/texture2d.hpp>
#include <godot_cpp/classes/theme.hpp>
#include <string>
#include <unordered_set>
static constexpr const char *icon_path = "res://addons/godot_sandbox/RustScript.svg";

static RustScriptLanguage *rust_language;

void RustScriptLanguage::init() {
	rust_language = memnew(RustScriptLanguage);
	Engine::get_singleton()->register_script_language(rust_language);
}
void RustScriptLanguage::deinit() {
	if (rust_language) {
		Engine::get_singleton()->unregister_script_language(rust_language);
		memdelete(rust_language);
		rust_language = nullptr;
	}
}

RustScriptLanguage *RustScriptLanguage::get_singleton() {
	return rust_language;
}

String RustScriptLanguage::_get_name() const {
	return "RustScript";
}
void RustScriptLanguage::_init() {}
String RustScriptLanguage::_get_type() const {
	return "RustScript";
}
String RustScriptLanguage::_get_extension() const {
	return "rs";
}
void RustScriptLanguage::_finish() {}
PackedStringArray RustScriptLanguage::_get_reserved_words() const {
	static const PackedStringArray reserved_words{
		"as",
		"use",
		"extern crate",
		"break",
		"const",
		"continue",
		"crate",
		"else",
		"if",
		"if let",
		"enum",
		"extern",
		"false",
		"fn",
		"for",
		"if",
		"impl",
		"in",
		"for",
		"let",
		"loop",
		"match",
		"mod",
		"move",
		"mut",
		"pub",
		"impl",
		"ref",
		"return",
		"Self",
		"self",
		"static",
		"struct",
		"super",
		"trait",
		"true",
		"type",
		"unsafe",
		"use",
		"where",
		"while",
		"abstract",
		"alignof",
		"become",
		"box",
		"do",
		"final",
		"macro",
		"offsetof",
		"override",
		"priv",
		"proc",
		"pure",
		"sizeof",
		"typeof",
		"unsized",
		"virtual",
		"yield"
		// Integers, floats, and strings are not reserved words in Rust, but we want the highlighting to be consistent
		"i8", "i16", "i32", "i64", "i128", "isize",
		"u8", "u16", "u32", "u64", "u128", "usize",
		"f32", "f64",
		"GodotString", "Variant"
	};
	return reserved_words;
}
bool RustScriptLanguage::_is_control_flow_keyword(const String &p_keyword) const {
	static const std::unordered_set<std::string> control_flow_keywords{
		"if", "else", "switch", "case", "default", "while", "loop", "for", "break", "continue", "return", "goto"
	};
	return control_flow_keywords.find(p_keyword.utf8().get_data()) != control_flow_keywords.end();
}
PackedStringArray RustScriptLanguage::_get_comment_delimiters() const {
	PackedStringArray comment_delimiters;
	comment_delimiters.push_back("/* */");
	comment_delimiters.push_back("//");
	return comment_delimiters;
}
PackedStringArray RustScriptLanguage::_get_doc_comment_delimiters() const {
	PackedStringArray doc_comment_delimiters;
	doc_comment_delimiters.push_back("///");
	doc_comment_delimiters.push_back("/** */");
	return doc_comment_delimiters;
}
PackedStringArray RustScriptLanguage::_get_string_delimiters() const {
	PackedStringArray string_delimiters;
	string_delimiters.push_back("' '");
	string_delimiters.push_back("\" \"");
	return string_delimiters;
}
Ref<Script> RustScriptLanguage::_make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const {
	RustScript *script = memnew(RustScript);
	return Ref<Script>(script);
}
TypedArray<Dictionary> RustScriptLanguage::_get_built_in_templates(const StringName &p_object) const {
	return TypedArray<Dictionary>();
}
bool RustScriptLanguage::_is_using_templates() {
	return false;
}
Dictionary RustScriptLanguage::_validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const {
	return Dictionary();
}
String RustScriptLanguage::_validate_path(const String &p_path) const {
	return String();
}
Object *RustScriptLanguage::_create_script() const {
	RustScript *script = memnew(RustScript);
	return script;
}
bool RustScriptLanguage::_has_named_classes() const {
	return false;
}
bool RustScriptLanguage::_supports_builtin_mode() const {
	return false;
}
bool RustScriptLanguage::_supports_documentation() const {
	return false;
}
bool RustScriptLanguage::_can_inherit_from_file() const {
	return false;
}
int32_t RustScriptLanguage::_find_function(const String &p_function, const String &p_code) const {
	return -1;
}
String RustScriptLanguage::_make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const {
	return String();
}
Error RustScriptLanguage::_open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) {
	return Error::OK;
}
bool RustScriptLanguage::_overrides_external_editor() {
	return false;
}
Dictionary RustScriptLanguage::_complete_code(const String &p_code, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
Dictionary RustScriptLanguage::_lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
String RustScriptLanguage::_auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const {
	return String();
}
void RustScriptLanguage::_add_global_constant(const StringName &p_name, const Variant &p_value) {}
void RustScriptLanguage::_add_named_global_constant(const StringName &p_name, const Variant &p_value) {}
void RustScriptLanguage::_remove_named_global_constant(const StringName &p_name) {}
void RustScriptLanguage::_thread_enter() {}
void RustScriptLanguage::_thread_exit() {}
String RustScriptLanguage::_debug_get_error() const {
	return String();
}
int32_t RustScriptLanguage::_debug_get_stack_level_count() const {
	return 0;
}
int32_t RustScriptLanguage::_debug_get_stack_level_line(int32_t p_level) const {
	return 0;
}
String RustScriptLanguage::_debug_get_stack_level_function(int32_t p_level) const {
	return String();
}
Dictionary RustScriptLanguage::_debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
Dictionary RustScriptLanguage::_debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
void *RustScriptLanguage::_debug_get_stack_level_instance(int32_t p_level) {
	return nullptr;
}
Dictionary RustScriptLanguage::_debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
String RustScriptLanguage::_debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) {
	return String();
}
TypedArray<Dictionary> RustScriptLanguage::_debug_get_current_stack_info() {
	return TypedArray<Dictionary>();
}
void RustScriptLanguage::_reload_all_scripts() {}
void RustScriptLanguage::_reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) {}
PackedStringArray RustScriptLanguage::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("rs");
	return array;
}
TypedArray<Dictionary> RustScriptLanguage::_get_public_functions() const {
	return TypedArray<Dictionary>();
}
Dictionary RustScriptLanguage::_get_public_constants() const {
	return Dictionary();
}
TypedArray<Dictionary> RustScriptLanguage::_get_public_annotations() const {
	return TypedArray<Dictionary>();
}
void RustScriptLanguage::_profiling_start() {}
void RustScriptLanguage::_profiling_stop() {}
int32_t RustScriptLanguage::_profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
int32_t RustScriptLanguage::_profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
void RustScriptLanguage::_frame() {
	static bool icon_registered = register_language_icons;
	if (!icon_registered && Engine::get_singleton()->is_editor_hint()) {
		icon_registered = true;
		// Manually register language icon
		load_icon();
		// Register theme callback
		EditorInterface::get_singleton()->get_base_control()->connect("theme_changed", callable_mp(this, &RustScriptLanguage::load_icon));
	}
}
void RustScriptLanguage::load_icon() {
	static bool reenter = false;
	if (reenter)
		return;
	reenter = true;
	if (Engine::get_singleton()->is_editor_hint() && FileAccess::file_exists(icon_path)) {
		Ref<Theme> editor_theme = EditorInterface::get_singleton()->get_editor_theme();
		if (editor_theme.is_valid() && !editor_theme->has_icon("RustScript", "EditorIcons")) {
			ResourceLoader *resource_loader = ResourceLoader::get_singleton();
			Ref<Texture2D> tex = resource_loader->load(icon_path);
			editor_theme->set_icon("RustScript", "EditorIcons", tex);
		}
	}
	reenter = false;
}
bool RustScriptLanguage::_handles_global_class_type(const String &p_type) const {
	return p_type == "RustScript";
}
Dictionary RustScriptLanguage::_get_global_class_name(const String &p_path) const {
	return Dictionary();
}

```

`src/rust/script_language_rust.h`:

```h
#pragma once

#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>

using namespace godot;

class RustScriptLanguage : public ScriptLanguageExtension {
	GDCLASS(RustScriptLanguage, ScriptLanguageExtension);

protected:
	static void _bind_methods() {}
	String file;

public:
	static void init();
	static void deinit();
	static RustScriptLanguage *get_singleton();

	virtual String _get_name() const override;
	virtual void _init() override;
	virtual String _get_type() const override;
	virtual String _get_extension() const override;
	virtual void _finish() override;
	virtual PackedStringArray _get_reserved_words() const override;
	virtual bool _is_control_flow_keyword(const String &p_keyword) const override;
	virtual PackedStringArray _get_comment_delimiters() const override;
	virtual PackedStringArray _get_doc_comment_delimiters() const override;
	virtual PackedStringArray _get_string_delimiters() const override;
	virtual Ref<Script> _make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const override;
	virtual TypedArray<Dictionary> _get_built_in_templates(const StringName &p_object) const override;
	virtual bool _is_using_templates() override;
	virtual Dictionary _validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const override;
	virtual String _validate_path(const String &p_path) const override;
	virtual Object *_create_script() const override;
	virtual bool _has_named_classes() const override;
	virtual bool _supports_builtin_mode() const override;
	virtual bool _supports_documentation() const override;
	virtual bool _can_inherit_from_file() const override;
	virtual int32_t _find_function(const String &p_function, const String &p_code) const override;
	virtual String _make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const override;
	virtual Error _open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) override;
	virtual bool _overrides_external_editor() override;
	virtual Dictionary _complete_code(const String &p_code, const String &p_path, Object *p_owner) const override;
	virtual Dictionary _lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const override;
	virtual String _auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const override;
	virtual void _add_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _add_named_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _remove_named_global_constant(const StringName &p_name) override;
	virtual void _thread_enter() override;
	virtual void _thread_exit() override;
	virtual String _debug_get_error() const override;
	virtual int32_t _debug_get_stack_level_count() const override;
	virtual int32_t _debug_get_stack_level_line(int32_t p_level) const override;
	virtual String _debug_get_stack_level_function(int32_t p_level) const override;
	virtual Dictionary _debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual Dictionary _debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual void *_debug_get_stack_level_instance(int32_t p_level) override;
	virtual Dictionary _debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual String _debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual TypedArray<Dictionary> _debug_get_current_stack_info() override;
	virtual void _reload_all_scripts() override;
	virtual void _reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual TypedArray<Dictionary> _get_public_functions() const override;
	virtual Dictionary _get_public_constants() const override;
	virtual TypedArray<Dictionary> _get_public_annotations() const override;
	virtual void _profiling_start() override;
	virtual void _profiling_stop() override;
	virtual int32_t _profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual int32_t _profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual void _frame() override;
	virtual bool _handles_global_class_type(const String &p_type) const override;
	virtual Dictionary _get_global_class_name(const String &p_path) const override;
	void load_icon();

	RustScriptLanguage() {}
	~RustScriptLanguage() {}
};

```

`src/rust/script_rust.cpp`:

```cpp
#include "script_rust.h"

#include "script_language_rust.h"
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

bool RustScript::_editor_can_reload_from_file() {
	return true;
}
void RustScript::_placeholder_erased(void *p_placeholder) {}
bool RustScript::_can_instantiate() const {
	return false;
}
Ref<Script> RustScript::_get_base_script() const {
	return Ref<Script>();
}
StringName RustScript::_get_global_name() const {
	return StringName();
}
bool RustScript::_inherits_script(const Ref<Script> &p_script) const {
	return false;
}
StringName RustScript::_get_instance_base_type() const {
	return StringName();
}
void *RustScript::_instance_create(Object *p_for_object) const {
	return nullptr;
}
void *RustScript::_placeholder_instance_create(Object *p_for_object) const {
	return nullptr;
}
bool RustScript::_instance_has(Object *p_object) const {
	return false;
}
bool RustScript::_has_source_code() const {
	return true;
}
String RustScript::_get_source_code() const {
	return source_code;
}
void RustScript::_set_source_code(const String &p_code) {
	source_code = p_code;
}
Error RustScript::_reload(bool p_keep_state) {
	return Error::OK;
}
TypedArray<Dictionary> RustScript::_get_documentation() const {
	return TypedArray<Dictionary>();
}
String RustScript::_get_class_icon_path() const {
	return String("res://addons/godot_sandbox/RustScript.svg");
}
bool RustScript::_has_method(const StringName &p_method) const {
	return false;
}
bool RustScript::_has_static_method(const StringName &p_method) const {
	return false;
}
Dictionary RustScript::_get_method_info(const StringName &p_method) const {
	return Dictionary();
}
bool RustScript::_is_tool() const {
	return true;
}
bool RustScript::_is_valid() const {
	return true;
}
bool RustScript::_is_abstract() const {
	return true;
}
ScriptLanguage *RustScript::_get_language() const {
	return RustScriptLanguage::get_singleton();
}
bool RustScript::_has_script_signal(const StringName &p_signal) const {
	return false;
}
TypedArray<Dictionary> RustScript::_get_script_signal_list() const {
	return TypedArray<Dictionary>();
}
bool RustScript::_has_property_default_value(const StringName &p_property) const {
	return false;
}
Variant RustScript::_get_property_default_value(const StringName &p_property) const {
	return Variant();
}
void RustScript::_update_exports() {}
TypedArray<Dictionary> RustScript::_get_script_method_list() const {
	return TypedArray<Dictionary>();
}
TypedArray<Dictionary> RustScript::_get_script_property_list() const {
	return TypedArray<Dictionary>();
}
int32_t RustScript::_get_member_line(const StringName &p_member) const {
	return 0;
}
Dictionary RustScript::_get_constants() const {
	return Dictionary();
}
TypedArray<StringName> RustScript::_get_members() const {
	return TypedArray<StringName>();
}
bool RustScript::_is_placeholder_fallback_enabled() const {
	return false;
}
Variant RustScript::_get_rpc_config() const {
	return Variant();
}

RustScript::RustScript() {
	source_code = R"C0D3(mod godot;
use godot::variant::*;

pub fn main() {
}

#[no_mangle]
pub fn public_function() -> Variant {
	let v1 = Variant::new_integer(42);
	let v2 = Variant::new_float(3.14);
	let v3 = Variant::new_string("Hello from Rust!");
	print(&[v1, v2, v3]);

	return Variant::new_string("Rust in Godot");
}
)C0D3";
}

```

`src/rust/script_rust.h`:

```h
#pragma once

#include "../docker.h"
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language.hpp>

using namespace godot;

class RustScript : public ScriptExtension {
	GDCLASS(RustScript, ScriptExtension);

protected:
	static void _bind_methods() {}
	String source_code;

public:
	virtual bool _editor_can_reload_from_file() override;
	virtual void _placeholder_erased(void *p_placeholder) override;
	virtual bool _can_instantiate() const override;
	virtual Ref<Script> _get_base_script() const override;
	virtual StringName _get_global_name() const override;
	virtual bool _inherits_script(const Ref<Script> &p_script) const override;
	virtual StringName _get_instance_base_type() const override;
	virtual void *_instance_create(Object *p_for_object) const override;
	virtual void *_placeholder_instance_create(Object *p_for_object) const override;
	virtual bool _instance_has(Object *p_object) const override;
	virtual bool _has_source_code() const override;
	virtual String _get_source_code() const override;
	virtual void _set_source_code(const String &p_code) override;
	virtual Error _reload(bool p_keep_state) override;
	virtual TypedArray<Dictionary> _get_documentation() const override;
	virtual String _get_class_icon_path() const override;
	virtual bool _has_method(const StringName &p_method) const override;
	virtual bool _has_static_method(const StringName &p_method) const override;
	virtual Dictionary _get_method_info(const StringName &p_method) const override;
	virtual bool _is_tool() const override;
	virtual bool _is_valid() const override;
	virtual bool _is_abstract() const override;
	virtual ScriptLanguage *_get_language() const override;
	virtual bool _has_script_signal(const StringName &p_signal) const override;
	virtual TypedArray<Dictionary> _get_script_signal_list() const override;
	virtual bool _has_property_default_value(const StringName &p_property) const override;
	virtual Variant _get_property_default_value(const StringName &p_property) const override;
	virtual void _update_exports() override;
	virtual TypedArray<Dictionary> _get_script_method_list() const override;
	virtual TypedArray<Dictionary> _get_script_property_list() const override;
	virtual int32_t _get_member_line(const StringName &p_member) const override;
	virtual Dictionary _get_constants() const override;
	virtual TypedArray<StringName> _get_members() const override;
	virtual bool _is_placeholder_fallback_enabled() const override;
	virtual Variant _get_rpc_config() const override;

	static void DockerContainerStart() {
		if (!docker_container_started) {
			Array output;
			if (Docker::ContainerStart(docker_container_name, docker_image_name, output))
				docker_container_started = true;
			else {
				UtilityFunctions::print(output);
				ERR_PRINT("Failed to start Docker container");
			}
		}
	}
	static void DockerContainerStop() {
		if (docker_container_started) {
			Docker::ContainerStop(docker_container_name);
			docker_container_started = false;
		}
	}
	static int DockerContainerVersion() {
		DockerContainerStart();
		if (docker_container_version == 0)
			docker_container_version =
					Docker::ContainerVersion(docker_container_name, { "/usr/project/build.sh", "--version" });
		return docker_container_version;
	}
	static bool DockerContainerExecute(const PackedStringArray &p_arguments, Array &output) {
		return Docker::ContainerExecute(docker_container_name, p_arguments, output);
	}

	RustScript();
	~RustScript() {}

private:
	static inline bool docker_container_started = false;
	static inline int docker_container_version = 0;
	static inline const char *docker_container_name = "godot-rust-compiler";
	static inline const char *docker_image_name = "ghcr.io/libriscv/rust_compiler";
};

```

`src/safegdscript/resource_loader_safegdscript.cpp`:

```cpp
#include "resource_loader_safegdscript.h"
#include "script_safegdscript.h"
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

static Ref<ResourceFormatLoaderSafeGDScript> loader;

void ResourceFormatLoaderSafeGDScript::init() {
	loader.instantiate();
	ResourceLoader::get_singleton()->add_resource_format_loader(loader, true);
}

void ResourceFormatLoaderSafeGDScript::deinit() {
	if (loader.is_valid()) {
		ResourceLoader::get_singleton()->remove_resource_format_loader(loader);
		loader.unref();
	}
}

Variant ResourceFormatLoaderSafeGDScript::_load(const String &p_path, const String &p_original_path, bool p_use_sub_threads, int32_t p_cache_mode) const {
	Ref<SafeGDScript> script;
	script.instantiate();
	script->set_path(p_path);
	return script;
}

PackedStringArray ResourceFormatLoaderSafeGDScript::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("sgd");
	array.push_back("safegd");
	return array;
}

bool ResourceFormatLoaderSafeGDScript::_handles_type(const StringName &p_type) const {
	return p_type == StringName("SafeGDScript") || p_type == StringName("Script");
}

String ResourceFormatLoaderSafeGDScript::_get_resource_type(const String &p_path) const {
	String el = p_path.get_extension().to_lower();
	if (el == "sgd" || el == "safegd") {
		return "SafeGDScript";
	}
	return "";
}

```

`src/safegdscript/resource_loader_safegdscript.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_loader.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

using namespace godot;

class ResourceFormatLoaderSafeGDScript : public ResourceFormatLoader {
	GDCLASS(ResourceFormatLoaderSafeGDScript, ResourceFormatLoader);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Variant _load(const String &path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual bool _handles_type(const StringName &type) const override;
	virtual String _get_resource_type(const String &p_path) const override;
};

```

`src/safegdscript/resource_saver_safegdscript.cpp`:

```cpp
#include "resource_saver_safegdscript.h"
#include "script_safegdscript.h"
#include <godot_cpp/classes/file_access.hpp>

static Ref<ResourceFormatSaverSafeGDScript> saver;

void ResourceFormatSaverSafeGDScript::init() {
	saver.instantiate();
	ResourceSaver::get_singleton()->add_resource_format_saver(saver, true);
}

void ResourceFormatSaverSafeGDScript::deinit() {
	if (saver.is_valid()) {
		ResourceSaver::get_singleton()->remove_resource_format_saver(saver);
		saver.unref();
	}
}

Error ResourceFormatSaverSafeGDScript::_save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) {
	SafeGDScript *script = Object::cast_to<SafeGDScript>(p_resource.ptr());
	if (script == nullptr) {
		ERR_PRINT("ResourceFormatSaverSafeGDScript::_save: Resource is not a SafeGDScript.");
		return ERR_FILE_CANT_WRITE;
	}

	Ref<FileAccess> file = FileAccess::open(p_path, FileAccess::ModeFlags::WRITE);
	if (file.is_null()) {
		ERR_PRINT("ResourceFormatSaverSafeGDScript::_save: Failed to open file for writing: " + p_path);
		return ERR_FILE_CANT_OPEN;
	}

	file->store_string(script->_get_source_code());
	return Error::OK;
}

Error ResourceFormatSaverSafeGDScript::_set_uid(const String &p_path, int64_t p_uid) {
	return Error::OK;
}

bool ResourceFormatSaverSafeGDScript::_recognize(const Ref<Resource> &p_resource) const {
	return Object::cast_to<SafeGDScript>(p_resource.ptr()) != nullptr;
}

PackedStringArray ResourceFormatSaverSafeGDScript::_get_recognized_extensions(const Ref<Resource> &p_resource) const {
	PackedStringArray array;
	if (Object::cast_to<SafeGDScript>(p_resource.ptr()) == nullptr)
		return array;
	array.push_back("sgd");
	return array;
}

bool ResourceFormatSaverSafeGDScript::_recognize_path(const Ref<Resource> &p_resource, const String &p_path) const {
	return Object::cast_to<SafeGDScript>(p_resource.ptr()) != nullptr;
}

```

`src/safegdscript/resource_saver_safegdscript.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_saver.hpp>
#include <godot_cpp/classes/resource_saver.hpp>

using namespace godot;

class ResourceFormatSaverSafeGDScript : public ResourceFormatSaver {
	GDCLASS(ResourceFormatSaverSafeGDScript, ResourceFormatSaver);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();

	virtual Error _save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) override;
	virtual Error _set_uid(const String &p_path, int64_t p_uid) override;
	virtual bool _recognize(const Ref<Resource> &p_resource) const override;
	virtual PackedStringArray _get_recognized_extensions(const Ref<Resource> &p_resource) const override;
	virtual bool _recognize_path(const Ref<Resource> &p_resource, const String &p_path) const override;
};

```

`src/safegdscript/script_instance_safegdscript.cpp`:

```cpp
#include "script_instance_safegdscript.h"

#include "../elf/script_elf.h"
#include "../elf/script_instance.h"
#include "../elf/script_instance_helper.h"
#include "../sandbox.h"
#include "../scoped_tree_base.h"
#include "script_safegdscript.h"
#include "script_language_safegdscript.h"
#include <godot_cpp/core/object.hpp>
#include <godot_cpp/templates/local_vector.hpp>
static constexpr bool VERBOSE_LOGGING = false;

bool SafeGDScriptInstance::set(const StringName &p_name, const Variant &p_value) {
	static const StringName s_script("script");
	static const StringName s_program("program");
	if (p_name == s_script || p_name == s_program) {
		return false;
	}

	Sandbox *sandbox = current_sandbox;
	ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
	if (sandbox->set_property(p_name, p_value)) {
		return true;
	}
	return false;
}

bool SafeGDScriptInstance::get(const StringName &p_name, Variant &r_ret) const {
	static const StringName s_script("script");
	if (p_name == s_script) {
		r_ret = this->script;
		return true;
	}
	Sandbox *sandbox = current_sandbox;
	ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
	if (sandbox->get_property(p_name, r_ret)) {
		return true;
	}
	return false;
}

godot::String SafeGDScriptInstance::to_string(bool *r_is_valid) {
	return "<SafeGDScript>";
}

void SafeGDScriptInstance::notification(int32_t p_what, bool p_reversed) {
}

Variant SafeGDScriptInstance::callp(
		const StringName &p_method,
		const Variant **p_args, const int p_argument_count,
		GDExtensionCallError &r_error)
{
	Sandbox *sandbox = current_sandbox;
	const auto address = sandbox->cached_address_of(p_method.hash(), p_method);
	if (address == 0) {
		const bool found = sandbox->is_sandbox_function(p_method);
		if (!found) {
			r_error.error = GDEXTENSION_CALL_ERROR_INVALID_METHOD;
			return Variant();
		}
		Array args;
		for (int i = 0; i < p_argument_count; i++) {
			args.push_back(*p_args[i]);
		}
		r_error.error = GDEXTENSION_CALL_OK;
		return sandbox->callv(p_method, args);
	}
	//WARN_PRINT("SafeGDScriptInstance::callp: Calling method " + p_method + " at address " + itos(address) + " with " + itos(p_argument_count) + " arguments.");
	ScopedTreeBase stb(sandbox, godot::Object::cast_to<Node>(this->owner));
	return sandbox->vmcall_address(address, p_args, p_argument_count, r_error);
}

const GDExtensionMethodInfo *SafeGDScriptInstance::get_method_list(uint32_t *r_count) const {
	const int size = script->methods_info.size();
	GDExtensionMethodInfo *list = memnew_arr(GDExtensionMethodInfo, size);
	int i = 0;
	for (const godot::MethodInfo &method_info : script->methods_info) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("ELFScriptInstance::get_method_list: method " + String(method_info.name));
		}
		list[i] = create_method_info(method_info);
		i++;
	}
	*r_count = size;

	return list;
}

static void set_property_info(
		GDExtensionPropertyInfo &p_info,
		const StringName &p_name,
		const StringName &p_class_name,
		GDExtensionVariantType p_type,
		uint32_t p_hint,
		const String &p_hint_string,
		uint32_t p_usage)
{
	p_info.name = stringname_alloc(p_name);
	p_info.class_name = stringname_alloc(p_class_name);
	p_info.type = p_type;
	p_info.hint = p_hint;
	p_info.hint_string = string_alloc(p_hint_string);
	p_info.usage = p_usage;
}

const GDExtensionPropertyInfo *SafeGDScriptInstance::get_property_list(uint32_t *r_count) const {
	Sandbox *sandbox = current_sandbox;
	std::vector<PropertyInfo> prop_list = sandbox->create_sandbox_property_list();

	// Sandboxed properties
	const std::vector<SandboxProperty> &properties = sandbox->get_properties();

	*r_count = properties.size() + prop_list.size();
	GDExtensionPropertyInfo *list = memnew_arr(GDExtensionPropertyInfo, *r_count + 2);
	const GDExtensionPropertyInfo *list_ptr = list;

	for (const SandboxProperty &property : properties) {
		if constexpr (VERBOSE_LOGGING) {
			printf("SafeGDScriptInstance::get_property_list %s\n", String(property.name()).utf8().ptr());
			fflush(stdout);
		}
		list->name = stringname_alloc(property.name());
		list->class_name = stringname_alloc("Variant");
		list->type = (GDExtensionVariantType)property.type();
		list->hint = 0;
		list->hint_string = string_alloc("");
		list->usage = PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_STORAGE | PROPERTY_USAGE_SCRIPT_VARIABLE | PROPERTY_USAGE_NIL_IS_VARIANT;
		list++;
	}
	for (int i = 0; i < prop_list.size(); i++) {
		const PropertyInfo &prop = prop_list[i];
		if constexpr (VERBOSE_LOGGING) {
			printf("SafeGDScriptInstance::get_property_list %s\n", String(prop.name).utf8().ptr());
			fflush(stdout);
		}
		if (prop.name == StringName("program")) {
			*r_count -= 1;
			continue;
		}
		list->name = stringname_alloc(prop.name);
		list->class_name = stringname_alloc(prop.class_name);
		list->type = (GDExtensionVariantType) int(prop.type);
		list->hint = prop.hint;
		list->hint_string = string_alloc(prop.hint_string);
		list->usage = prop.usage;
		list++;
	}
	return list_ptr;
}
void SafeGDScriptInstance::free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const {
	if (p_list) {
		memdelete_arr(p_list);
	}
}

Variant::Type SafeGDScriptInstance::get_property_type(const StringName &p_name, bool *r_is_valid) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScriptInstance::get_property_type " + p_name);
	}
	Sandbox *sandbox = current_sandbox;
	if (const SandboxProperty *prop = sandbox->find_property_or_null(p_name)) {
		*r_is_valid = true;
		return prop->type();
	}
	*r_is_valid = false;
	return Variant::NIL;
}

void SafeGDScriptInstance::get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) {
}

bool SafeGDScriptInstance::validate_property(GDExtensionPropertyInfo &p_property) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScriptInstance::validate_property");
	}
	return true;
}

GDExtensionInt SafeGDScriptInstance::get_method_argument_count(const StringName &p_method, bool &r_valid) const {
	r_valid = false;
	return 0;
}

bool SafeGDScriptInstance::has_method(const StringName &p_name) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScriptInstance::has_method " + p_name);
	}
	for (const godot::MethodInfo &method_info : script->methods_info) {
		if (method_info.name == p_name) {
			return true;
		}
	}
	return false;
}

void SafeGDScriptInstance::free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const {
	if (p_list) {
		for (uint32_t i = 0; i < p_count; i++) {
			const GDExtensionMethodInfo &method_info = p_list[i];
			if (method_info.arguments) {
				memdelete_arr(method_info.arguments);
			}
		}
		memdelete_arr(p_list);
	}
}

bool SafeGDScriptInstance::property_can_revert(const StringName &p_name) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScriptInstance::property_can_revert " + p_name);
	}
	return false;
}

bool SafeGDScriptInstance::property_get_revert(const StringName &p_name, Variant &r_ret) const {
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScriptInstance::property_get_revert " + p_name);
	}
	r_ret = Variant();
	return false;
}

void SafeGDScriptInstance::refcount_incremented() {
}

bool SafeGDScriptInstance::refcount_decremented() {
	return false;
}

Object *SafeGDScriptInstance::get_owner() {
	return owner;
}

Ref<Script> SafeGDScriptInstance::get_script() const {
	return script;
}

bool SafeGDScriptInstance::is_placeholder() const {
	return false;
}

void SafeGDScriptInstance::property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) {
	*r_valid = false;
}

Variant SafeGDScriptInstance::property_get_fallback(const StringName &p_name, bool *r_valid) {
	*r_valid = false;
	return Variant::NIL;
}

ScriptLanguage *SafeGDScriptInstance::_get_language() {
	return SafeGDScriptLanguage::get_singleton();
}

void SafeGDScriptInstance::reset_to(const PackedByteArray &p_elf_data) {
	Sandbox *sandbox = current_sandbox;
	sandbox->load_buffer(p_elf_data);
}

struct SandboxAndCount {
	Sandbox *sandbox = nullptr;
	unsigned count = 0;
};
static std::unordered_map<SafeGDScript *, SandboxAndCount> sandbox_instances;

static Sandbox *create_sandbox(Object *p_owner, const Ref<SafeGDScript> &p_script) {
	auto it = sandbox_instances.find(p_script.ptr());
	if (it != sandbox_instances.end()) {
		it->second.count++;
		return it->second.sandbox;
	}

	Sandbox *sandbox_ptr = memnew(Sandbox());
	sandbox_ptr->set_tree_base(Object::cast_to<Node>(p_owner));
	sandbox_ptr->set_unboxed_arguments(false);
	sandbox_ptr->load_buffer(p_script->get_content());
	sandbox_instances.insert_or_assign(p_script.ptr(), SandboxAndCount{sandbox_ptr, 1});

	return sandbox_ptr;
}

SafeGDScriptInstance::SafeGDScriptInstance(Object *p_owner, const Ref<SafeGDScript> p_script) :
		owner(p_owner), script(p_script)
{
	this->current_sandbox = create_sandbox(p_owner, p_script);
	this->current_sandbox->set_tree_base(godot::Object::cast_to<godot::Node>(owner));
}

SafeGDScriptInstance::~SafeGDScriptInstance() {
	auto it = sandbox_instances.find(script.ptr());
	if (it != sandbox_instances.end()) {
		it->second.count--;
		if (it->second.count == 0) {
			it->second.sandbox->queue_free();
			sandbox_instances.erase(it);
		}
	}
	this->current_sandbox = nullptr;
	script->remove_instance(this);
}

```

`src/safegdscript/script_instance_safegdscript.h`:

```h
#pragma once

#include <gdextension_interface.h>
#include <godot_cpp/classes/global_constants.hpp>
#include <godot_cpp/classes/mutex.hpp>
#include <godot_cpp/classes/ref.hpp>
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>
#include <godot_cpp/core/type_info.hpp>
#include <godot_cpp/variant/dictionary.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/typed_array.hpp>
#include <godot_cpp/variant/variant.hpp>

#include "../godot/script_instance.h"
using namespace godot;

class Sandbox;
class SafeGDScript;

class SafeGDScriptInstance : public ScriptInstanceExtension {
	Object *owner;
	Ref<SafeGDScript> script;
	Sandbox *current_sandbox = nullptr;

	friend class SafeGDScript;

public:
	bool set(const StringName &p_name, const Variant &p_value) override;
	bool get(const StringName &p_name, Variant &r_ret) const override;
	const GDExtensionPropertyInfo *get_property_list(uint32_t *r_count) const override;
	void free_property_list(const GDExtensionPropertyInfo *p_list, uint32_t p_count) const override;
	Variant::Type get_property_type(const StringName &p_name, bool *r_is_valid) const override;
	bool validate_property(GDExtensionPropertyInfo &p_property) const override;
	bool property_can_revert(const StringName &p_name) const override;
	bool property_get_revert(const StringName &p_name, Variant &r_ret) const override;
	Object *get_owner() override;
	void get_property_state(GDExtensionScriptInstancePropertyStateAdd p_add_func, void *p_userdata) override;
	const GDExtensionMethodInfo *get_method_list(uint32_t *r_count) const override;
	void free_method_list(const GDExtensionMethodInfo *p_list, uint32_t p_count) const override;
	bool has_method(const StringName &p_method) const override;
	GDExtensionInt get_method_argument_count(const StringName &p_method, bool &r_valid) const override;
	Variant callp(const StringName &p_method, const Variant **p_args, int p_argcount, GDExtensionCallError &r_error) override;
	void notification(int p_notification, bool p_reversed) override;
	String to_string(bool *r_valid) override;
	void refcount_incremented() override;
	bool refcount_decremented() override;
	Ref<Script> get_script() const override;
	bool is_placeholder() const override;
	void property_set_fallback(const StringName &p_name, const Variant &p_value, bool *r_valid) override;
	Variant property_get_fallback(const StringName &p_name, bool *r_valid) override;
	ScriptLanguage *_get_language() override;

	void reset_to(const PackedByteArray &p_elf_data);
	SafeGDScriptInstance(Object *p_owner, const Ref<SafeGDScript> p_script);
	~SafeGDScriptInstance();
};

```

`src/safegdscript/script_language_safegdscript.cpp`:

```cpp
#include "script_language_safegdscript.h"
#include "../script_language_common.h"
#include "script_safegdscript.h"
#include <godot_cpp/classes/control.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/texture2d.hpp>
#include <godot_cpp/classes/theme.hpp>
#include <string>
#include <unordered_set>
static constexpr const char *icon_path = "res://addons/godot_sandbox/SafeGDScript.svg";

static SafeGDScriptLanguage *safegdscript_language;

void SafeGDScriptLanguage::init() {
	safegdscript_language = memnew(SafeGDScriptLanguage);
	Engine::get_singleton()->register_script_language(safegdscript_language);
}
void SafeGDScriptLanguage::deinit() {
	if (safegdscript_language) {
		Engine::get_singleton()->unregister_script_language(safegdscript_language);
		memdelete(safegdscript_language);
		safegdscript_language = nullptr;
	}
}

SafeGDScriptLanguage *SafeGDScriptLanguage::get_singleton() {
	return safegdscript_language;
}

String SafeGDScriptLanguage::_get_name() const {
	return "SafeGD";
}
void SafeGDScriptLanguage::_init() {}
String SafeGDScriptLanguage::_get_type() const {
	return "SafeGDScript";
}
String SafeGDScriptLanguage::_get_extension() const {
	return "sgd";
}
void SafeGDScriptLanguage::_finish() {}
PackedStringArray SafeGDScriptLanguage::_get_reserved_words() const {
	static const PackedStringArray reserved_words{
		"if",
		"elif",
		"else",
		"for",
		"while",
		"match",
		"break",
		"continue",
		"return",
		"pass",
		"func",
		"class",
		"class_name",
		"extends",
		"is",
		"in",
		"as",
		"and",
		"or",
		"not",
		"var",
		"const",
		"static",
		"enum",
		"signal",
		"super",
		"self",
		"true",
		"false",
		"null",
		"void",
		"bool",
		"int",
		"float",
		"String",
		"Vector2",
		"Vector2i",
		"Vector3",
		"Vector3i",
		"Vector4",
		"Vector4i",
		"Color",
		"Array",
		"Dictionary",
		"PackedByteArray",
		"PackedInt32Array",
		"PackedInt64Array",
		"PackedFloat32Array",
		"PackedFloat64Array",
		"PackedStringArray",
		"PackedVector2Array",
		"PackedVector3Array",
		"PackedColorArray",
		"Node",
		"RefCounted",
		"Resource",
		"void",
		"assert",
		"await",
		"yield",
	};
	return reserved_words;
}
bool SafeGDScriptLanguage::_is_control_flow_keyword(const String &p_keyword) const {
	static const std::unordered_set<std::string> control_flow_keywords{
		"if", "elif", "else", "for", "while", "match", "break", "continue", "return", "pass", "assert"
	};
	return control_flow_keywords.find(p_keyword.utf8().get_data()) != control_flow_keywords.end();
}
PackedStringArray SafeGDScriptLanguage::_get_comment_delimiters() const {
	PackedStringArray comment_delimiters;
	comment_delimiters.push_back("#");
	return comment_delimiters;
}
PackedStringArray SafeGDScriptLanguage::_get_doc_comment_delimiters() const {
	PackedStringArray doc_comment_delimiters;
	doc_comment_delimiters.push_back("##");
	return doc_comment_delimiters;
}
PackedStringArray SafeGDScriptLanguage::_get_string_delimiters() const {
	PackedStringArray string_delimiters;
	string_delimiters.push_back("\" \"");
	string_delimiters.push_back("' '");
	string_delimiters.push_back("\"\"\" \"\"\"");
	return string_delimiters;
}
Ref<Script> SafeGDScriptLanguage::_make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const {
	SafeGDScript *script = memnew(SafeGDScript);
	return Ref<Script>(script);
}
TypedArray<Dictionary> SafeGDScriptLanguage::_get_built_in_templates(const StringName &p_object) const {
	return TypedArray<Dictionary>();
}
bool SafeGDScriptLanguage::_is_using_templates() {
	return false;
}
Dictionary SafeGDScriptLanguage::_validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const {
	return Dictionary();
}
String SafeGDScriptLanguage::_validate_path(const String &p_path) const {
	return String();
}
Object *SafeGDScriptLanguage::_create_script() const {
	SafeGDScript *script = memnew(SafeGDScript);
	return script;
}
bool SafeGDScriptLanguage::_has_named_classes() const {
	return false;
}
bool SafeGDScriptLanguage::_supports_builtin_mode() const {
	return true;
}
bool SafeGDScriptLanguage::_supports_documentation() const {
	return false;
}
bool SafeGDScriptLanguage::_can_inherit_from_file() const {
	return false;
}
bool SafeGDScriptLanguage::_can_make_function() const {
	return false;
}
int32_t SafeGDScriptLanguage::_find_function(const String &p_function, const String &p_code) const {
	return -1;
}
String SafeGDScriptLanguage::_make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const {
	return String();
}
Error SafeGDScriptLanguage::_open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) {
	return Error::OK;
}
bool SafeGDScriptLanguage::_overrides_external_editor() {
	return false;
}
Dictionary SafeGDScriptLanguage::_complete_code(const String &p_code, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
Dictionary SafeGDScriptLanguage::_lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
String SafeGDScriptLanguage::_auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const {
	return String();
}
void SafeGDScriptLanguage::_add_global_constant(const StringName &p_name, const Variant &p_value) {}
void SafeGDScriptLanguage::_add_named_global_constant(const StringName &p_name, const Variant &p_value) {}
void SafeGDScriptLanguage::_remove_named_global_constant(const StringName &p_name) {}
void SafeGDScriptLanguage::_thread_enter() {}
void SafeGDScriptLanguage::_thread_exit() {}
String SafeGDScriptLanguage::_debug_get_error() const {
	return String();
}
int32_t SafeGDScriptLanguage::_debug_get_stack_level_count() const {
	return 0;
}
int32_t SafeGDScriptLanguage::_debug_get_stack_level_line(int32_t p_level) const {
	return 0;
}
String SafeGDScriptLanguage::_debug_get_stack_level_function(int32_t p_level) const {
	return String();
}
Dictionary SafeGDScriptLanguage::_debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
Dictionary SafeGDScriptLanguage::_debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
void *SafeGDScriptLanguage::_debug_get_stack_level_instance(int32_t p_level) {
	return nullptr;
}
Dictionary SafeGDScriptLanguage::_debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
String SafeGDScriptLanguage::_debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) {
	return String();
}
TypedArray<Dictionary> SafeGDScriptLanguage::_debug_get_current_stack_info() {
	return TypedArray<Dictionary>();
}
void SafeGDScriptLanguage::_reload_all_scripts() {}
void SafeGDScriptLanguage::_reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) {}
PackedStringArray SafeGDScriptLanguage::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("sgd");
	return array;
}
TypedArray<Dictionary> SafeGDScriptLanguage::_get_public_functions() const {
	return TypedArray<Dictionary>();
}
Dictionary SafeGDScriptLanguage::_get_public_constants() const {
	return Dictionary();
}
TypedArray<Dictionary> SafeGDScriptLanguage::_get_public_annotations() const {
	return TypedArray<Dictionary>();
}
void SafeGDScriptLanguage::_profiling_start() {}
void SafeGDScriptLanguage::_profiling_stop() {}
int32_t SafeGDScriptLanguage::_profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
int32_t SafeGDScriptLanguage::_profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
void SafeGDScriptLanguage::_frame() {
	static bool icon_registered = register_language_icons;
	if (!icon_registered && Engine::get_singleton()->is_editor_hint()) {
		icon_registered = true;
		load_icon();
		EditorInterface::get_singleton()->get_base_control()->connect("theme_changed", callable_mp(this, &SafeGDScriptLanguage::load_icon));
	}
}
void SafeGDScriptLanguage::load_icon() {
	static bool reenter = false;
	if (reenter)
		return;
	reenter = true;
	if (Engine::get_singleton()->is_editor_hint() && FileAccess::file_exists(icon_path)) {
		Ref<Theme> editor_theme = EditorInterface::get_singleton()->get_editor_theme();
		if (editor_theme.is_valid() && !editor_theme->has_icon("SafeGDScript", "EditorIcons"))
		{
			ResourceLoader *resource_loader = ResourceLoader::get_singleton();
			Ref<Texture2D> tex = resource_loader->load(icon_path);
			editor_theme->set_icon("SafeGDScript", "EditorIcons", tex);
		}
	}
	reenter = false;
}
bool SafeGDScriptLanguage::_handles_global_class_type(const String &p_type) const {
	return p_type == "SafeGDScript" || p_type == "Sandbox";
}
Dictionary SafeGDScriptLanguage::_get_global_class_name(const String &p_path) const {
	Dictionary dict;
	if (!p_path.is_empty()) {
		dict["name"] = SafeGDScript::PathToGlobalName(p_path);
		dict["base_type"] = "Sandbox";
		dict["icon_path"] = String(icon_path);
	}
	return dict;
}

```

`src/safegdscript/script_language_safegdscript.h`:

```h
#pragma once

#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>

using namespace godot;

class SafeGDScriptLanguage : public ScriptLanguageExtension {
	GDCLASS(SafeGDScriptLanguage, ScriptLanguageExtension);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	static SafeGDScriptLanguage *get_singleton();

	virtual String _get_name() const override;
	virtual void _init() override;
	virtual String _get_type() const override;
	virtual String _get_extension() const override;
	virtual void _finish() override;
	virtual PackedStringArray _get_reserved_words() const override;
	virtual bool _is_control_flow_keyword(const String &p_keyword) const override;
	virtual PackedStringArray _get_comment_delimiters() const override;
	virtual PackedStringArray _get_doc_comment_delimiters() const override;
	virtual PackedStringArray _get_string_delimiters() const override;
	virtual Ref<Script> _make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const override;
	virtual TypedArray<Dictionary> _get_built_in_templates(const StringName &p_object) const override;
	virtual bool _is_using_templates() override;
	virtual Dictionary _validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const override;
	virtual String _validate_path(const String &p_path) const override;
	virtual Object *_create_script() const override;
	virtual bool _has_named_classes() const override;
	virtual bool _supports_builtin_mode() const override;
	virtual bool _supports_documentation() const override;
	virtual bool _can_inherit_from_file() const override;
	virtual bool _can_make_function() const override;
	virtual int32_t _find_function(const String &p_function, const String &p_code) const override;
	virtual String _make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const override;
	virtual Error _open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) override;
	virtual bool _overrides_external_editor() override;
	virtual Dictionary _complete_code(const String &p_code, const String &p_path, Object *p_owner) const override;
	virtual Dictionary _lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const override;
	virtual String _auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const override;
	virtual void _add_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _add_named_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _remove_named_global_constant(const StringName &p_name) override;
	virtual void _thread_enter() override;
	virtual void _thread_exit() override;
	virtual String _debug_get_error() const override;
	virtual int32_t _debug_get_stack_level_count() const override;
	virtual int32_t _debug_get_stack_level_line(int32_t p_level) const override;
	virtual String _debug_get_stack_level_function(int32_t p_level) const override;
	virtual Dictionary _debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual Dictionary _debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual void *_debug_get_stack_level_instance(int32_t p_level) override;
	virtual Dictionary _debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual String _debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual TypedArray<Dictionary> _debug_get_current_stack_info() override;
	virtual void _reload_all_scripts() override;
	virtual void _reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual TypedArray<Dictionary> _get_public_functions() const override;
	virtual Dictionary _get_public_constants() const override;
	virtual TypedArray<Dictionary> _get_public_annotations() const override;
	virtual void _profiling_start() override;
	virtual void _profiling_stop() override;
	virtual int32_t _profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual int32_t _profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual void _frame() override;
	virtual bool _handles_global_class_type(const String &p_type) const override;
	virtual Dictionary _get_global_class_name(const String &p_path) const override;
	void load_icon();

	SafeGDScriptLanguage() {}
	~SafeGDScriptLanguage() {}
};

```

`src/safegdscript/script_safegdscript.cpp`:

```cpp
#include "script_safegdscript.h"

#include "../elf/script_elf.h"
#include "../elf/script_instance.h"
#include "script_instance_safegdscript.h"
#include "script_language_safegdscript.h"
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/core/class_db.hpp>
#include "../sandbox.h"
static constexpr bool VERBOSE_LOGGING = false;
static Sandbox* compiler = nullptr;

bool SafeGDScript::_editor_can_reload_from_file() {
	return true;
}
void SafeGDScript::_placeholder_erased(void *p_placeholder) {}
bool SafeGDScript::_can_instantiate() const {
	return true;
}
Ref<Script> SafeGDScript::_get_base_script() const {
	return Ref<Script>();
}
StringName SafeGDScript::_get_global_name() const {
	return PathToGlobalName(this->path);
}
bool SafeGDScript::_inherits_script(const Ref<Script> &p_script) const {
	return false;
}
StringName SafeGDScript::_get_instance_base_type() const {
	return StringName("Sandbox");
}
void *SafeGDScript::_instance_create(Object *p_for_object) const {
	SafeGDScriptInstance *instance = memnew(SafeGDScriptInstance(p_for_object, Ref<SafeGDScript>(this)));
	instances.insert(instance);
	return ScriptInstanceExtension::create_native_instance(instance);
}
void *SafeGDScript::_placeholder_instance_create(Object *p_for_object) const {
	return _instance_create(p_for_object);
}
bool SafeGDScript::_instance_has(Object *p_object) const {
	return false;
}
bool SafeGDScript::_has_source_code() const {
	return true;
}
String SafeGDScript::_get_source_code() const {
	return source_code;
}
void SafeGDScript::_set_source_code(const String &p_code) {
	source_code = p_code;
	compile_source_to_elf();
}
Error SafeGDScript::_reload(bool p_keep_state) {
	compile_source_to_elf();
	return Error::OK;
}
TypedArray<Dictionary> SafeGDScript::_get_documentation() const {
	return TypedArray<Dictionary>();
}
String SafeGDScript::_get_class_icon_path() const {
	return String("res://addons/godot_sandbox/SafeGDScript.svg");
}
bool SafeGDScript::_has_method(const StringName &p_method) const {
	if (p_method == StringName("_init"))
		return true;
	for (const godot::MethodInfo &method_info : methods_info) {
		if (method_info.name == p_method) {
			//WARN_PRINT("SafeGDScript::_has_method: found method " + p_method);
			return true;
		}
	}
	return false;
}
bool SafeGDScript::_has_static_method(const StringName &p_method) const {
	return false;
}
Dictionary SafeGDScript::_get_method_info(const StringName &p_method) const {
	Dictionary method_dict;
	for (const godot::MethodInfo &method_info : methods_info) {
		if (method_info.name == p_method) {
			method_dict["name"] = method_info.name;
			method_dict["flags"] = method_info.flags;
			method_dict["return_type"] = method_info.return_val.type;
			TypedArray<Dictionary> args;
			for (const godot::PropertyInfo &arg_info : method_info.arguments) {
				Dictionary arg_dict;
				arg_dict["name"] = arg_info.name;
				arg_dict["type"] = arg_info.type;
				arg_dict["usage"] = arg_info.usage;
				args.append(arg_dict);
			}
			method_dict["arguments"] = args;
			return method_dict;
		}
	}
	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScript::_get_method_info: Method " + String(p_method) + " not found.");
	}
	return Dictionary();
}
bool SafeGDScript::_is_tool() const {
	return true;
}
bool SafeGDScript::_is_valid() const {
	return !elf_data.is_empty();
}
bool SafeGDScript::_is_abstract() const {
	return false;
}
ScriptLanguage *SafeGDScript::_get_language() const {
	return SafeGDScriptLanguage::get_singleton();
}
bool SafeGDScript::_has_script_signal(const StringName &p_signal) const {
	return false;
}
TypedArray<Dictionary> SafeGDScript::_get_script_signal_list() const {
	return TypedArray<Dictionary>();
}
bool SafeGDScript::_has_property_default_value(const StringName &p_property) const {
	return false;
}
Variant SafeGDScript::_get_property_default_value(const StringName &p_property) const {
	return Variant();
}
void SafeGDScript::_update_exports() {}
TypedArray<Dictionary> SafeGDScript::_get_script_method_list() const {
	TypedArray<Dictionary> functions_array;
	for (const godot::MethodInfo &method_info : methods_info) {
		Dictionary method;
		method["name"] = method_info.name;
		method["args"] = Array();
		method["default_args"] = Array();
		Dictionary type;
		type["name"] = "type";
		type["type"] = Variant::Type::NIL;
		//type["class_name"] = "class";
		type["hint"] = PropertyHint::PROPERTY_HINT_NONE;
		type["hint_string"] = String();
		type["usage"] = PROPERTY_USAGE_DEFAULT | PROPERTY_USAGE_NIL_IS_VARIANT;
		method["return"] = type;
		method["flags"] = METHOD_FLAG_VARARG;
		functions_array.push_back(method);
	}
	return functions_array;
}
TypedArray<Dictionary> SafeGDScript::_get_script_property_list() const {
	if (instances.is_empty()) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("SafeGDScript::_get_script_property_list: No instances available.");
		}
		return {};
	}
	SafeGDScriptInstance *instance = *instances.begin();
	if (instance == nullptr) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("SafeGDScript::_get_script_property_list: Instance is null.");
		}
		return {};
	}
	return {};
}
int32_t SafeGDScript::_get_member_line(const StringName &p_member) const {
	return 0;
}
Dictionary SafeGDScript::_get_constants() const {
	return Dictionary();
}
TypedArray<StringName> SafeGDScript::_get_members() const {
	return TypedArray<StringName>();
}
bool SafeGDScript::_is_placeholder_fallback_enabled() const {
	return false;
}
Variant SafeGDScript::_get_rpc_config() const {
	return Variant();
}

SafeGDScript::SafeGDScript() {
	source_code = R"GDScript(# SafeGDScript example

func somefunction():
	var counter = 0
	while counter < 10:
		counter += 1
	return counter

)GDScript";
}
SafeGDScript::~SafeGDScript() {
}

void SafeGDScript::set_path(const String &p_path) {
	if (p_path.is_empty()) {
		WARN_PRINT("SafeGDScript::set_path: Empty resource path.");
		return;
	}
	this->path = p_path;
	if (!this->path.is_empty()) {
		this->source_code = FileAccess::get_file_as_string(p_path);
	}
	this->compile_source_to_elf();
}

bool SafeGDScript::compile_source_to_elf() {
	if (this->source_code.is_empty()) {
		if constexpr (VERBOSE_LOGGING) {
			ERR_PRINT("SafeGDScript::compile_source_to_elf: No source code to compile.");
		}
		return false;
	}

	if (compiler == nullptr) {
		// Check if "gdscript.elf" exists in the addons/godot_sandbox/ directory
		String compiler_path = "res://addons/godot_sandbox/gdscript.elf";
		if (!FileAccess::file_exists(compiler_path)) {
			ERR_PRINT("SafeGDScript::compile_source_to_elf: GDScript compiler ELF not found at " + compiler_path);
			return false;
		}
		compiler = memnew(Sandbox);
		Ref<ELFScript> compiler_script = ResourceLoader::get_singleton()->load(compiler_path);
		if (!compiler_script.is_valid()) {
			ERR_PRINT("SafeGDScript::compile_source_to_elf: Failed to load GDScript compiler ELF resource.");
			memdelete(compiler);
			compiler = nullptr;
			return false;
		}
		compiler->set_program(compiler_script);
		if (!compiler->has_program_loaded()) {
			ERR_PRINT("SafeGDScript::compile_source_to_elf: Failed to initialize GDScript compiler sandbox.");
			memdelete(compiler);
			compiler = nullptr;
			return false;
		}
	}

	// Compile the source code to ELF using the compiler sandbox
	GDExtensionCallError error;
	Variant src_code_var = this->source_code;
	const Variant* args[] = { &src_code_var };
	Variant result = compiler->vmcall_fn("compile", args, 1, error);
	if (error.error != GDExtensionCallErrorType::GDEXTENSION_CALL_OK) {
		ERR_PRINT("SafeGDScript::compile_source_to_elf: Compilation failed with error code " + itos(static_cast<int>(error.error)));
		return false;
	}
	// Expecting the result to be a PackedByteArray containing the ELF binary
	if (result.get_type() != Variant::Type::PACKED_BYTE_ARRAY) {
		ERR_PRINT("SafeGDScript::compile_source_to_elf: Compilation did not return a PackedByteArray.");
		return false;
	}

	this->elf_data = result;
	if (elf_data.is_empty()) {
		ERR_PRINT("SafeGDScript::compile_source_to_elf: Compilation returned empty ELF data.");
		return false;
	}

	this->update_methods_info();

	for (SafeGDScriptInstance *instance : instances) {
		instance->reset_to(this->elf_data);
	}

	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScript::compile_source_to_elf: Successfully compiled " + this->path + " to ELF (" + itos(this->elf_data.size()) + " bytes)");
	}

	return true;
}

void SafeGDScript::remove_instance(SafeGDScriptInstance *p_instance) {
	instances.erase(p_instance);
}

void SafeGDScript::update_methods_info() {
	Sandbox::BinaryInfo info = Sandbox::get_program_info_from_binary(this->elf_data);
	this->methods_info.clear();
	for (const String &func_name : info.functions) {
		//WARN_PRINT("Found function: " + func_name);
		methods_info.push_back(MethodInfo(func_name));
	}

	if constexpr (VERBOSE_LOGGING) {
		ERR_PRINT("SafeGDScript::update_methods_info: Updated methods info with " + itos(methods_info.size()) + " methods.");
	}
}

```

`src/safegdscript/script_safegdscript.h`:

```h
#pragma once

#include "../docker.h"
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language.hpp>
#include <godot_cpp/templates/hash_set.hpp>

using namespace godot;
class Sandbox;
class SafeGDScriptInstance;
class ELFScript;

class SafeGDScript : public ScriptExtension {
	GDCLASS(SafeGDScript, ScriptExtension);

protected:
	static void _bind_methods() {}
	String source_code;

public:
	virtual bool _editor_can_reload_from_file() override;
	virtual void _placeholder_erased(void *p_placeholder) override;
	virtual bool _can_instantiate() const override;
	virtual Ref<Script> _get_base_script() const override;
	virtual StringName _get_global_name() const override;
	virtual bool _inherits_script(const Ref<Script> &p_script) const override;
	virtual StringName _get_instance_base_type() const override;
	virtual void *_instance_create(Object *p_for_object) const override;
	virtual void *_placeholder_instance_create(Object *p_for_object) const override;
	virtual bool _instance_has(Object *p_object) const override;
	virtual bool _has_source_code() const override;
	virtual String _get_source_code() const override;
	virtual void _set_source_code(const String &p_code) override;
	virtual Error _reload(bool p_keep_state) override;
	virtual TypedArray<Dictionary> _get_documentation() const override;
	virtual String _get_class_icon_path() const override;
	virtual bool _has_method(const StringName &p_method) const override;
	virtual bool _has_static_method(const StringName &p_method) const override;
	virtual Dictionary _get_method_info(const StringName &p_method) const override;
	virtual bool _is_tool() const override;
	virtual bool _is_valid() const override;
	virtual bool _is_abstract() const override;
	virtual ScriptLanguage *_get_language() const override;
	virtual bool _has_script_signal(const StringName &p_signal) const override;
	virtual TypedArray<Dictionary> _get_script_signal_list() const override;
	virtual bool _has_property_default_value(const StringName &p_property) const override;
	virtual Variant _get_property_default_value(const StringName &p_property) const override;
	virtual void _update_exports() override;
	virtual TypedArray<Dictionary> _get_script_method_list() const override;
	virtual TypedArray<Dictionary> _get_script_property_list() const override;
	virtual int32_t _get_member_line(const StringName &p_member) const override;
	virtual Dictionary _get_constants() const override;
	virtual TypedArray<StringName> _get_members() const override;
	virtual bool _is_placeholder_fallback_enabled() const override;
	virtual Variant _get_rpc_config() const override;

	void set_path(const String &p_path);
	SafeGDScriptInstance *get_safegdscript_script_instance() const;
	const String &get_path() const { return path; }
	const PackedByteArray &get_content() const { return elf_data; }
	bool compile_source_to_elf();
	void remove_instance(SafeGDScriptInstance *p_instance);

	static String PathToGlobalName(const String &p_path) {
		return "SafeGDScript_" + p_path.get_basename().replace("res://", "").replace("/", "_").replace("-", "_").capitalize().replace(" ", "");
	}

	SafeGDScript();
	~SafeGDScript();

private:
	void update_methods_info();

	String path;
	mutable HashSet<SafeGDScriptInstance *> instances;
	PackedByteArray elf_data;
	std::vector<godot::MethodInfo> methods_info;
	friend class SafeGDScriptInstance;
};

```

`src/sandbox.cpp`:

```cpp
#include "sandbox.h"

#include "guest_datatypes.h"
#include "sandbox_project_settings.h"
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/time.hpp>
#include <godot_cpp/core/class_db.hpp>
#include <godot_cpp/variant/utility_functions.hpp>
#if defined(RISCV_BINARY_TRANSLATION) && defined(RISCV_LIBTCC)
#include <future>
#endif

using namespace godot;

static constexpr bool VERBOSE_PROPERTIES = false;
static const int HEAP_SYSCALLS_BASE = 480;
static const int MEMORY_SYSCALLS_BASE = 485;
static const std::vector<std::string> program_arguments = { "program" };
static riscv::Machine<RISCV_ARCH> dummy_machine;
enum SandboxPropertyNameIndex : int {
	PROP_REFERENCES_MAX,
	PROP_MEMORY_MAX,
	PROP_EXECUTION_TIMEOUT,
	PROP_ALLOCATIONS_MAX,
	PROP_UNBOXED_ARGUMENTS,
	PROP_PRECISE_SIMULATION,
#ifdef RISCV_LIBTCC
	PROP_BINTR_NBIT_AS,
	PROP_BINTR_REG_CACHE,
#endif // RISCV_LIBTCC
	PROP_PROFILING,
	PROP_RESTRICTIONS,
	PROP_PROGRAM,
	PROP_MONITOR_HEAP_USAGE,
	PROP_MONITOR_HEAP_CHUNK_COUNT,
	PROP_MONITOR_HEAP_ALLOCATION_COUNTER,
	PROP_MONITOR_HEAP_DEALLOCATION_COUNTER,
	PROP_MONITOR_EXCEPTIONS,
	PROP_MONITOR_EXECUTION_TIMEOUTS,
	PROP_MONITOR_CALLS_MADE,
	PROP_MONITOR_BINARY_TRANSLATED,
	PROP_GLOBAL_CALLS_MADE,
	PROP_GLOBAL_EXCEPTIONS,
	PROP_GLOBAL_TIMEOUTS,
	PROP_MONITOR_ACCUMULATED_STARTUP_TIME,
	PROP_MONITOR_GLOBAL_INSTANCE_COUNT,
};
static std::vector<StringName> property_names;

void Sandbox::Initialize()
{
	Sandbox::initialize_syscalls();

	property_names = {
		"references_max",
		"memory_max",
		"execution_timeout",
		"allocations_max",
		"unboxed_arguments",
		"precise_simulation",
#ifdef RISCV_LIBTCC
		"binary_translation_nbit_as",
		"binary_translation_register_caching",
#endif // RISCV_LIBTCC
		"profiling",
		"restrictions",
		"program",
		"monitor_heap_usage",
		"monitor_heap_chunk_count",
		"monitor_heap_allocation_counter",
		"monitor_heap_deallocation_counter",
		"monitor_exceptions",
		"monitor_execution_timeouts",
		"monitor_calls_made",
		"monitor_binary_translated",
		"global_calls_made",
		"global_exceptions",
		"global_timeouts",
		"monitor_accumulated_startup_time",
		"monitor_global_instance_count",
	};
}

String Sandbox::_to_string() const {
	return "[ GDExtension::Sandbox <--> Instance ID:" + uitos(get_instance_id()) + " ]";
}

void Sandbox::_bind_methods() {
	// Constructors.
	ClassDB::bind_static_method("Sandbox", D_METHOD("FromBuffer", "buffer"), &Sandbox::FromBuffer);
	ClassDB::bind_static_method("Sandbox", D_METHOD("FromProgram", "program"), &Sandbox::FromProgram);
	// Methods.
	ClassDB::bind_method(D_METHOD("load_buffer", "buffer"), &Sandbox::load_buffer);
	ClassDB::bind_method(D_METHOD("reset", "unload"), &Sandbox::reset, DEFVAL(false));
	{
		MethodInfo mi;
		//mi.arguments.push_back(PropertyInfo(Variant::STRING, "function"));
		mi.name = "vmcall";
		mi.return_val = PropertyInfo(Variant::OBJECT, "result");
		ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "vmcall", &Sandbox::vmcall, mi, DEFVAL(std::vector<Variant>{}));
		ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "vmcallv", &Sandbox::vmcallv, mi, DEFVAL(std::vector<Variant>{}));
	}
	ClassDB::bind_method(D_METHOD("vmcallable", "function", "args"), &Sandbox::vmcallable, DEFVAL(Array{}));
	ClassDB::bind_method(D_METHOD("vmcallable_address", "address", "args"), &Sandbox::vmcallable_address, DEFVAL(Array{}));

	// Sandbox restrictions.
	ClassDB::bind_method(D_METHOD("set_restrictions", "restrictions"), &Sandbox::set_restrictions);
	ClassDB::bind_method(D_METHOD("get_restrictions"), &Sandbox::get_restrictions);
	ClassDB::bind_method(D_METHOD("add_allowed_object", "instance"), &Sandbox::add_allowed_object);
	ClassDB::bind_method(D_METHOD("remove_allowed_object", "instance"), &Sandbox::remove_allowed_object);
	ClassDB::bind_method(D_METHOD("clear_allowed_objects"), &Sandbox::clear_allowed_objects);
	ClassDB::bind_method(D_METHOD("set_class_allowed_callback", "instance"), &Sandbox::set_class_allowed_callback);
	ClassDB::bind_method(D_METHOD("set_object_allowed_callback", "instance"), &Sandbox::set_object_allowed_callback);
	ClassDB::bind_method(D_METHOD("set_method_allowed_callback", "instance"), &Sandbox::set_method_allowed_callback);
	ClassDB::bind_method(D_METHOD("set_property_allowed_callback", "instance"), &Sandbox::set_property_allowed_callback);
	ClassDB::bind_method(D_METHOD("set_resource_allowed_callback", "instance"), &Sandbox::set_resource_allowed_callback);
	ClassDB::bind_method(D_METHOD("is_allowed_class", "name"), &Sandbox::is_allowed_class);
	ClassDB::bind_method(D_METHOD("is_allowed_object", "instance"), &Sandbox::is_allowed_object);
	ClassDB::bind_method(D_METHOD("is_allowed_method", "instance", "method"), &Sandbox::is_allowed_method);
	ClassDB::bind_method(D_METHOD("is_allowed_property", "instance", "property", "is_set"), &Sandbox::is_allowed_property, DEFVAL(true));
	ClassDB::bind_method(D_METHOD("is_allowed_resource", "res"), &Sandbox::is_allowed_resource);
	ClassDB::bind_static_method("Sandbox", D_METHOD("restrictive_callback_function", "arg"), &Sandbox::restrictive_callback_function);

	// Internal testing, debugging and introspection.
	ClassDB::bind_method(D_METHOD("set_redirect_stdout", "callback"), &Sandbox::set_redirect_stdout);
	ClassDB::bind_method(D_METHOD("get_general_registers"), &Sandbox::get_general_registers);
	ClassDB::bind_method(D_METHOD("get_floating_point_registers"), &Sandbox::get_floating_point_registers);
	ClassDB::bind_method(D_METHOD("set_argument_registers", "args"), &Sandbox::set_argument_registers);
	ClassDB::bind_method(D_METHOD("get_current_instruction"), &Sandbox::get_current_instruction);
	ClassDB::bind_method(D_METHOD("make_resumable"), &Sandbox::make_resumable);
	ClassDB::bind_method(D_METHOD("resume", "max_instructions"), &Sandbox::resume);

	ClassDB::bind_method(D_METHOD("assault", "test", "iterations"), &Sandbox::assault);
	ClassDB::bind_method(D_METHOD("has_function", "function"), &Sandbox::has_function);
	ClassDB::bind_method(D_METHOD("address_of", "symbol"), &Sandbox::address_of);
	ClassDB::bind_method(D_METHOD("lookup_address", "address"), &Sandbox::lookup_address);
	ClassDB::bind_static_method("Sandbox", D_METHOD("generate_api", "language", "header_extra", "use_argument_names"), &Sandbox::generate_api, DEFVAL("cpp"), DEFVAL(""), DEFVAL(false));
	ClassDB::bind_static_method("Sandbox", D_METHOD("download_program", "program_name"), &Sandbox::download_program, DEFVAL("hello_world"));

	// Shared memory.
	ClassDB::bind_method(D_METHOD("share_byte_array", "allow_write", "array"), &Sandbox::share_byte_array);
	ClassDB::bind_method(D_METHOD("share_float32_array", "allow_write", "array"), &Sandbox::share_float32_array);
	ClassDB::bind_method(D_METHOD("share_float64_array", "allow_write", "array"), &Sandbox::share_float64_array);
	ClassDB::bind_method(D_METHOD("share_int32_array", "allow_write", "array"), &Sandbox::share_int32_array);
	ClassDB::bind_method(D_METHOD("share_int64_array", "allow_write", "array"), &Sandbox::share_int64_array);
	ClassDB::bind_method(D_METHOD("share_vec2_array", "allow_write", "array"), &Sandbox::share_vec2_array);
	ClassDB::bind_method(D_METHOD("share_vec3_array", "allow_write", "array"), &Sandbox::share_vec3_array);
	ClassDB::bind_method(D_METHOD("share_vec4_array", "allow_write", "array"), &Sandbox::share_vec4_array);
	ClassDB::bind_method(D_METHOD("unshare_array", "address"), &Sandbox::unshare_array);

	// Profiling.
	ClassDB::bind_static_method("Sandbox", D_METHOD("get_hotspots", "total", "callable"), &Sandbox::get_hotspots, DEFVAL(6), DEFVAL(Callable()));
	ClassDB::bind_static_method("Sandbox", D_METHOD("clear_hotspots"), &Sandbox::clear_hotspots);

	// Binary translation.
	ClassDB::bind_method(D_METHOD("emit_binary_translation", "ignore_instruction_limit", "automatic_nbit_address_space"), &Sandbox::emit_binary_translation, DEFVAL(false), DEFVAL(false));
	ClassDB::bind_static_method("Sandbox", D_METHOD("load_binary_translation", "shared_library_path", "allow_insecure"), &Sandbox::load_binary_translation, DEFVAL("res://bintr.so"), DEFVAL(false));
	ClassDB::bind_method(D_METHOD("try_compile_binary_translation", "shared_library_path", "compiler", "extra_cflags", "ignore_instruction_limit", "automatic_nbit_as"), &Sandbox::try_compile_binary_translation, DEFVAL("res://bintr"), DEFVAL("cc"), DEFVAL(""), DEFVAL(false), DEFVAL(false));
	ClassDB::bind_method(D_METHOD("is_binary_translated"), &Sandbox::is_binary_translated);
	ClassDB::bind_method(D_METHOD("is_jit"), &Sandbox::is_jit);
	ClassDB::bind_static_method("Sandbox", D_METHOD("set_jit_enabled", "enable"), &Sandbox::set_jit_enabled);
	ClassDB::bind_static_method("Sandbox", D_METHOD("is_jit_enabled"), &Sandbox::is_jit_enabled);
	ClassDB::bind_static_method("Sandbox", D_METHOD("has_feature_jit"), &Sandbox::has_feature_jit);

	// Properties.
	ClassDB::bind_method(D_METHOD("set", "name", "value"), &Sandbox::set);
	ClassDB::bind_method(D_METHOD("get", "name"), &Sandbox::get);
	ClassDB::bind_method(D_METHOD("get_property_list"), &Sandbox::get_property_list);

	ClassDB::bind_method(D_METHOD("set_max_refs", "max"), &Sandbox::set_max_refs, DEFVAL(MAX_REFS));
	ClassDB::bind_method(D_METHOD("get_max_refs"), &Sandbox::get_max_refs);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "references_max", PROPERTY_HINT_NONE, "Maximum objects and variants referenced by a sandbox call"), "set_max_refs", "get_max_refs");

	ClassDB::bind_method(D_METHOD("set_memory_max", "max"), &Sandbox::set_memory_max, DEFVAL(MAX_VMEM));
	ClassDB::bind_method(D_METHOD("get_memory_max"), &Sandbox::get_memory_max);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "memory_max", PROPERTY_HINT_NONE, "Maximum memory (in MiB) used by the sandboxed program"), "set_memory_max", "get_memory_max");

	ClassDB::bind_method(D_METHOD("set_instructions_max", "max"), &Sandbox::set_instructions_max, DEFVAL(MAX_INSTRUCTIONS));
	ClassDB::bind_method(D_METHOD("get_instructions_max"), &Sandbox::get_instructions_max);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "execution_timeout", PROPERTY_HINT_NONE, "Maximum millions of instructions executed before cancelling execution"), "set_instructions_max", "get_instructions_max");

	ClassDB::bind_method(D_METHOD("set_allocations_max", "max"), &Sandbox::set_allocations_max, DEFVAL(MAX_HEAP_ALLOCS));
	ClassDB::bind_method(D_METHOD("get_allocations_max"), &Sandbox::get_allocations_max);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "allocations_max", PROPERTY_HINT_NONE, "Maximum number of allocations allowed"), "set_allocations_max", "get_allocations_max");

	ClassDB::bind_method(D_METHOD("set_unboxed_arguments", "unboxed_arguments"), &Sandbox::set_unboxed_arguments);
	ClassDB::bind_method(D_METHOD("get_unboxed_arguments"), &Sandbox::get_unboxed_arguments);
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "unboxed_arguments", PROPERTY_HINT_NONE, "Use unboxed arguments for VM function calls"), "set_unboxed_arguments", "get_unboxed_arguments");

	ClassDB::bind_method(D_METHOD("set_precise_simulation", "precise_simulation"), &Sandbox::set_precise_simulation);
	ClassDB::bind_method(D_METHOD("get_precise_simulation"), &Sandbox::get_precise_simulation);
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "precise_simulation", PROPERTY_HINT_NONE, "Use precise simulation for VM execution"), "set_precise_simulation", "get_precise_simulation");

	ClassDB::bind_method(D_METHOD("set_binary_translation_nbit_as", "use_nbit_as"), &Sandbox::set_binary_translation_automatic_nbit_as);
	ClassDB::bind_method(D_METHOD("get_binary_translation_nbit_as"), &Sandbox::get_binary_translation_automatic_nbit_as);
#ifdef RISCV_LIBTCC
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "binary_translation_nbit_as", PROPERTY_HINT_NONE, "Use n-bit address space for binary translation"), "set_binary_translation_nbit_as", "get_binary_translation_nbit_as");
#endif // RISCV_LIBTCC

	ClassDB::bind_method(D_METHOD("set_binary_translation_register_caching", "register_caching"), &Sandbox::set_binary_translation_register_caching);
	ClassDB::bind_method(D_METHOD("get_binary_translation_register_caching"), &Sandbox::get_binary_translation_register_caching);
#ifdef RISCV_LIBTCC
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "binary_translation_register_caching", PROPERTY_HINT_NONE, "Use register caching for binary translation"), "set_binary_translation_register_caching", "get_binary_translation_register_caching");
#endif // RISCV_LIBTCC

	ClassDB::bind_method(D_METHOD("set_binary_translation_bg_compilation", "bg_compilation"), &Sandbox::set_binary_translation_bg_compilation);
	ClassDB::bind_method(D_METHOD("get_binary_translation_bg_compilation"), &Sandbox::get_binary_translation_bg_compilation);

	ClassDB::bind_method(D_METHOD("set_profiling", "enable"), &Sandbox::set_profiling, DEFVAL(false));
	ClassDB::bind_method(D_METHOD("get_profiling"), &Sandbox::get_profiling);
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "profiling", PROPERTY_HINT_NONE, "Enable profiling of VM calls"), "set_profiling", "get_profiling");

	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "restrictions", PROPERTY_HINT_NONE, "Enable sandbox restrictions"), "set_restrictions", "get_restrictions");

	ClassDB::bind_method(D_METHOD("set_program", "program"), &Sandbox::set_program);
	ClassDB::bind_method(D_METHOD("get_program"), &Sandbox::get_program);
	ClassDB::bind_method(D_METHOD("has_program_loaded"), &Sandbox::has_program_loaded);
	ADD_PROPERTY(PropertyInfo(Variant::OBJECT, "program", PROPERTY_HINT_RESOURCE_TYPE, "ELFScript"), "set_program", "get_program");

	// Group for monitored Sandbox health.
	ADD_GROUP("Sandbox Monitoring", "monitor_");

	ClassDB::bind_method(D_METHOD("get_heap_usage"), &Sandbox::get_heap_usage);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_heap_usage", PROPERTY_HINT_NONE, "Current memory arena usage", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_heap_usage");

	ClassDB::bind_method(D_METHOD("get_heap_chunk_count"), &Sandbox::get_heap_chunk_count);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_heap_chunk_count", PROPERTY_HINT_NONE, "Number of memory chunks allocated", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_heap_chunk_count");

	ClassDB::bind_method(D_METHOD("get_heap_allocation_counter"), &Sandbox::get_heap_allocation_counter);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_heap_allocation_counter", PROPERTY_HINT_NONE, "Number of heap allocations", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_heap_allocation_counter");

	ClassDB::bind_method(D_METHOD("get_heap_deallocation_counter"), &Sandbox::get_heap_deallocation_counter);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_heap_deallocation_counter", PROPERTY_HINT_NONE, "Number of heap deallocations", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_heap_deallocation_counter");

	ClassDB::bind_method(D_METHOD("get_exceptions"), &Sandbox::get_exceptions);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_exceptions", PROPERTY_HINT_NONE, "Number of exceptions thrown", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_exceptions");

	ClassDB::bind_method(D_METHOD("get_timeouts"), &Sandbox::get_timeouts);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_execution_timeouts", PROPERTY_HINT_NONE, "Number of execution timeouts", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_timeouts");

	ClassDB::bind_method(D_METHOD("get_calls_made"), &Sandbox::get_calls_made);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_calls_made", PROPERTY_HINT_NONE, "Number of calls made", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_calls_made");

	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "monitor_binary_translated", PROPERTY_HINT_NONE, "Number of calls made", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "is_binary_translated");

	ClassDB::bind_static_method("Sandbox", D_METHOD("get_global_calls_made"), &Sandbox::get_global_calls_made);
	ClassDB::bind_static_method("Sandbox", D_METHOD("get_global_exceptions"), &Sandbox::get_global_exceptions);
	ClassDB::bind_static_method("Sandbox", D_METHOD("get_global_timeouts"), &Sandbox::get_global_timeouts);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_global_calls_made", PROPERTY_HINT_NONE, "Number of calls made", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_global_calls_made");
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_global_exceptions", PROPERTY_HINT_NONE, "Number of exceptions thrown", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_global_exceptions");
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_global_execution_timeouts", PROPERTY_HINT_NONE, "Number of execution timeouts", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_global_timeouts");

	ClassDB::bind_static_method("Sandbox", D_METHOD("get_global_instance_count"), &Sandbox::get_global_instance_count);
	ClassDB::bind_static_method("Sandbox", D_METHOD("get_accumulated_startup_time"), &Sandbox::get_accumulated_startup_time);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "monitor_global_instance_count", PROPERTY_HINT_NONE, "Number of active sandbox instances", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_global_instance_count");
	ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "monitor_accumulated_startup_time", PROPERTY_HINT_NONE, "Accumulated startup time of all sandbox instantiations", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY), "", "get_accumulated_startup_time");

	// Group for sandboxed properties.
	ADD_GROUP("Sandboxed Properties", "custom_");
}

std::vector<PropertyInfo> Sandbox::create_sandbox_property_list() {
	std::vector<PropertyInfo> list;
	// Create a list of properties for the Sandbox class only.
	// This is used to expose the basic properties to the editor.

	// Group for sandbox restrictions.
	list.push_back(PropertyInfo(Variant::INT, "references_max", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::INT, "memory_max", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::INT, "execution_timeout", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::INT, "allocations_max", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::BOOL, "unboxed_arguments", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::BOOL, "precise_simulation", PROPERTY_HINT_NONE));
#ifdef RISCV_LIBTCC
	list.push_back(PropertyInfo(Variant::BOOL, "binary_translation_nbit_as", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::BOOL, "binary_translation_register_caching", PROPERTY_HINT_NONE));
#endif // RISCV_LIBTCC
	list.push_back(PropertyInfo(Variant::BOOL, "profiling", PROPERTY_HINT_NONE));
	list.push_back(PropertyInfo(Variant::BOOL, "restrictions", PROPERTY_HINT_NONE));

	// Group for sandbox properties.
	list.push_back(PropertyInfo(Variant::OBJECT, "program", PROPERTY_HINT_RESOURCE_TYPE, "ELFScript"));

	// Group for monitored Sandbox health.
	// Add the group name to the property name to group them in the editor.
	list.push_back(PropertyInfo(Variant::NIL, "Monitoring", PROPERTY_HINT_NONE, "monitor_", PROPERTY_USAGE_GROUP));
	list.push_back(PropertyInfo(Variant::INT, "monitor_heap_usage", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::INT, "monitor_heap_chunk_count", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::INT, "monitor_heap_allocation_counter", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::INT, "monitor_heap_deallocation_counter", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::INT, "monitor_exceptions", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::INT, "monitor_execution_timeouts", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::INT, "monitor_calls_made", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));
	list.push_back(PropertyInfo(Variant::BOOL, "monitor_binary_translated", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_READ_ONLY));

	return list;
}

void Sandbox::constructor_initialize() {
	this->m_current_state = &this->m_states[0];
	this->m_use_unboxed_arguments = SandboxProjectSettings::use_native_types();
	// For each call state, reset the state
	for (size_t i = 0; i < this->m_states.size(); i++) {
		this->m_states[i].reinitialize(i, this->m_max_refs);
	}
}
void Sandbox::reset_machine() {
	try {
		if (this->m_machine != &dummy_machine) {
			delete this->m_machine;
			this->m_machine = &dummy_machine;
		}
	} catch (const std::exception &e) {
		ERR_PRINT(("Sandbox exception: " + std::string(e.what())).c_str());
	}
}
void Sandbox::full_reset() {
	this->reset_machine();
	const bool unboxed_arguments = this->get_unboxed_arguments();
	this->constructor_initialize();
	this->set_unboxed_arguments(unboxed_arguments);

	this->m_properties.clear();
	this->m_lookup.clear();
	this->m_allowed_objects.clear();
}
Sandbox::Sandbox() {
	this->constructor_initialize();
	this->m_tree_base = this;
	this->m_global_instances_current += 1;
	this->m_global_instances_seen += 1;
	// In order to reduce checks we guarantee that this
	// class is well-formed at all times.
	this->reset_machine();
}
Sandbox::Sandbox(const PackedByteArray &buffer) : Sandbox() {
	this->load_buffer(buffer);
}
Sandbox::Sandbox(Ref<ELFScript> program) : Sandbox() {
	this->set_program(program);
}

Sandbox::~Sandbox() {
	if (this->is_in_vmcall()) {
		ERR_PRINT("Sandbox instance destroyed while a VM call is in progress.");
	}
	this->m_global_instances_current -= 1;
	this->set_program_data_internal(nullptr);
	try {
		if (this->m_machine != &dummy_machine)
			delete this->m_machine;
	} catch (const std::exception &e) {
		ERR_PRINT(("Sandbox exception: " + std::string(e.what())).c_str());
	}
}

void Sandbox::set_memory_max(uint32_t max) {
	m_memory_max = max;
	if (this->has_program_loaded() && !this->is_in_vmcall()) {
		// Reset the machine if the memory limit is changed
		const gaddr_t current_arena = machine().memory.memory_arena_size();
		const gaddr_t new_arena_size = uint64_t(max) << 20;
		if (new_arena_size > current_arena) {
			this->reset();
		}
	}
}

void Sandbox::set_program(Ref<ELFScript> program) {
	// Check if a call is being made from the VM already,
	// which could spell trouble when we now reset the machine.
	if (this->is_in_vmcall()) {
		ERR_PRINT("Cannot load a new program while a VM call is in progress.");
		return;
	}

	// Avoid reloading the same program
	if (program.is_valid() && this->m_program_data == program) {
		if (this->m_source_version == program->get_source_version()) {
			return;
		}
	} else {
		this->m_source_version = -1;
	}

	// Try to retain Sandboxed properties
	std::vector<Variant> property_values;
	property_values.reserve(this->m_properties.size());
	for (const SandboxProperty &prop : this->m_properties) {
		Variant value;
		if (this->get_property(prop.name(), value)) {
			property_values.push_back(value);
		} else {
			property_values.push_back(Variant());
		}
	}
	// Move the properties to a temporary vector (reset coming up)
	std::vector<SandboxProperty> properties = std::move(this->m_properties);

	this->set_program_data_internal(program);
	this->m_program_bytes = {};

	// Unload program and reset the machine
	this->full_reset();

	if (this->m_program_data.is_null())
		return;

	if (this->load(&m_program_data->get_content())) {
		this->m_source_version = m_program_data->get_source_version();
	}

	// Restore Sandboxed properties by comparing the new program's properties
	// with the old ones, then comparing the type. If the property is found,
	// try to set the property with the old value.
	for (const SandboxProperty &old_prop : properties) {
		const Variant *value = nullptr;
		for (const SandboxProperty &new_prop : this->m_properties) {
			if (new_prop.name() == old_prop.name() && new_prop.type() == old_prop.type()) {
				value = &property_values[&old_prop - &properties[0]];
				break;
			}
		}
		if (value) {
			this->set_property(old_prop.name(), *value);
		}
	}
}
void Sandbox::set_program_data_internal(Ref<ELFScript> program) {
	if (this->m_program_data.is_valid()) {
		//printf("Sandbox %p: Program *unset* from %s\n", this, this->m_program_data->get_path().utf8().ptr());
		this->m_program_data->unregister_instance(this);
	}
	this->m_program_data = program;
	if (this->m_program_data.is_valid()) {
		//printf("Sandbox %p: Program set to %s\n", this, this->m_program_data->get_path().utf8().ptr());
		this->m_program_data->register_instance(this);
	}
}
Ref<ELFScript> Sandbox::get_program() {
	return m_program_data;
}
void Sandbox::load_buffer(const PackedByteArray &buffer) {
	// Check if a call is being made from the VM already,
	// which could spell trouble when we now reset the machine.
	if (this->is_in_vmcall()) {
		ERR_PRINT("Cannot load a new program while a VM call is in progress.");
		return;
	}

	this->set_program_data_internal(nullptr);
	this->m_program_bytes = buffer;

	// Reset the machine
	this->full_reset();

	this->load(&this->m_program_bytes);
}
void Sandbox::reset(bool unload) {
	// Check if a call is being made from the VM already,
	// which could spell trouble when we now reset the machine.
	if (this->is_in_vmcall()) {
		ERR_PRINT("Cannot reset the sandbox while a VM call is in progress.");
		return;
	}

	// Allow the program to be reloaded
	this->m_source_version = -1;
	if (unload) {
		this->set_program_data_internal(nullptr);
		this->m_program_bytes = {};
		this->full_reset();
	} else {
		// Reset the machine
		if (this->m_program_data.is_valid()) {
			this->set_program(this->m_program_data);
		} else if (!this->m_program_bytes.is_empty()) {
			this->load_buffer(this->m_program_bytes);
		}
	}
}
bool Sandbox::has_program_loaded() const {
	return !machine().memory.binary().empty();
}
bool Sandbox::load(const PackedByteArray *buffer, const std::vector<std::string> *argv_ptr) {
	if (buffer == nullptr || buffer->is_empty()) {
		ERR_PRINT("Empty binary, cannot load program.");
		this->reset_machine();
		return false;
	}
	const std::string_view binary_view = std::string_view{ (const char *)buffer->ptr(), static_cast<size_t>(buffer->size()) };

	// Get t0 for the startup time
	const uint64_t startup_t0 = Time::get_singleton()->get_ticks_usec();

	/** We can't handle exceptions until the Machine is fully constructed. Two steps.  */
	try {
		// Reset the machine
		if (this->m_machine != &dummy_machine)
			delete this->m_machine;

		auto options = std::make_shared<riscv::MachineOptions<RISCV_ARCH>>(riscv::MachineOptions<RISCV_ARCH>{
				.memory_max = uint64_t(get_memory_max()) << 20, // in MiB
				//.verbose_loader = true,
#ifdef RISCV_BINARY_TRANSLATION
				.translate_enabled = riscv::libtcc_enabled && m_bintr_jit,
				.translate_enable_embedded = true,
				.translate_future_segments = false,
				.translate_invoke_compiler = riscv::libtcc_enabled && m_bintr_jit,
				//.translate_trace = true,
				//.translate_timing = true,
#  ifdef RISCV_LIBTCC
				.translate_ignore_instruction_limit = get_instructions_max() <= 0,
				.translate_use_register_caching = this->m_bintr_register_caching,
				.translate_automatic_nbit_address_space = this->m_bintr_automatic_nbit_as,
				.translate_live_patching = false, // Don't meddle with instruction stream
#  endif // RISCV_LIBTCC
#endif
		});
#if defined(RISCV_BINARY_TRANSLATION) && defined(RISCV_LIBTCC)
		// Background compilation, if enabled, will run the compilation in a separate thread
		// and live-patch the results into the decoder cache after the compilation is done.
		if (this->m_bintr_bg_compilation) {
			options->translate_background_callback = [](std::function<void()>& callback) {
				// This is called from inside the binary translator in the main thread,
				// and the goal is to run the callback in a separate thread, to avoid
				// blocking the main thread while the compilation step is running.
				std::thread([callback = std::move(callback)]() {
					// Run the callback in a separate thread
					// This is useful for long-running compilation tasks
					// that should not block the main thread.
					// The callback will be called when the compilation is done.
					// Note: This is a no-op if the callback is empty.
					try {
						if (callback)
							callback();
					} catch (const std::exception &e) {
						String what = e.what();
						ERR_PRINT(("Binary translation background compilation exception: " + what));
					}
				}).detach();
			};
		}
#endif

		this->m_machine = new machine_t{ binary_view, *options };
		this->m_machine->set_options(std::move(options));
	} catch (const std::exception &e) {
		ERR_PRINT(("Sandbox construction exception: " + std::string(e.what())).c_str());
		this->m_machine = &dummy_machine;
		return false;
	}

	/** Now we can process symbols, backtraces etc. */
	try {
		this->m_is_initialization = true;
		machine_t &m = machine();

		m.set_userdata(this);
		m.set_printer([](const machine_t &m, const char *str, size_t len) {
			Sandbox *sandbox = m.get_userdata<Sandbox>();
			sandbox->print(String::utf8(str, len));
		});

		this->initialize_syscalls_runtime();

		const gaddr_t heap_size = gaddr_t(machine().memory.memory_arena_size() * 0.8) & ~0xFFFLL;
		const gaddr_t heap_area = machine().memory.mmap_allocate(heap_size);

		// Add native system call interfaces
		machine().setup_native_heap(HEAP_SYSCALLS_BASE, heap_area, heap_size);
		machine().setup_native_memory(MEMORY_SYSCALLS_BASE);
		machine().arena().set_max_chunks(get_allocations_max());

		// Set up a Linux environment for the program
		const std::vector<std::string> *argv = argv_ptr ? argv_ptr : &program_arguments;
		m.setup_linux(*argv, { "LC_CTYPE=C", "LC_ALL=C", "TZ=UTC", "LD_LIBRARY_PATH=" });

		// Run the program through to its main() function
		if (!this->m_resumable_mode) {
			if (!this->get_precise_simulation()) {
				if (get_instructions_max() <= 0) {
					m.cpu.simulate_inaccurate(m.cpu.pc());
				} else {
					m.simulate(get_instructions_max() << 20);
				}
			} else {
				// Precise simulation can help discover bugs in the program,
				// as the exact PC address will be known when an exception occurs.
				uint64_t max_instr = get_instructions_max() << 20;
				m.set_max_instructions(max_instr ? max_instr : ~0ULL);
				m.cpu.simulate_precise();
				if (m.instruction_limit_reached()) {
					throw riscv::MachineTimeoutException(riscv::MAX_INSTRUCTIONS_REACHED,
						"Instruction count limit reached", max_instr);
				}
			}
		}
		this->m_is_initialization = false;
	} catch (const std::exception &e) {
		ERR_PRINT(("Sandbox exception: " + std::string(e.what())).c_str());
		this->m_is_initialization = false;
		this->handle_exception(machine().cpu.pc());
	}

	// Read the program's custom properties, if any
	this->read_program_properties(true);

	// Attempt to read the public API functions when an ELF program is loaded
	if (this->m_program_data.is_valid()) {
		// We can't read them without having loaded the program first
		// If the functions Array in the ELFScript object is empty, we will look for the API functions
		if (!this->m_program_data->functions.is_empty()) {
			// Cache the public API functions from the ELFScript object
			for (int i = 0; i < this->m_program_data->functions.size(); i++) {
				const Dictionary func = this->m_program_data->functions[i];
				String name = func["name"];
				const gaddr_t address = func.get("address", 0x0);
				this->m_lookup.insert_or_assign(name.hash(), LookupEntry{ std::move(name), address });
			}
			this->m_program_data->update_public_api_functions();
		}
	}

	// Accumulate startup time
	const uint64_t startup_t1 = Time::get_singleton()->get_ticks_usec();
	double startup_time = (startup_t1 - startup_t0) / 1e6;
	m_accumulated_startup_time += startup_time;
	//fprintf(stderr, "Sandbox startup time: %.3f seconds\n", startup_time);
	return true;
}

Variant Sandbox::vmcall_address(gaddr_t address, const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error) {
	error.error = GDEXTENSION_CALL_OK;
	return this->vmcall_internal(address, args, arg_count);
}
Variant Sandbox::vmcall(const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error) {
	if (arg_count < 1) {
		error.error = GDEXTENSION_CALL_ERROR_TOO_FEW_ARGUMENTS;
		error.argument = -1;
		return Variant();
	}

	const Variant &function = *args[0];
	args += 1;
	arg_count -= 1;
	const String function_name = function.operator String();
	const gaddr_t address = cached_address_of(function_name.hash(), function_name);
	if (address == 0) {
		ERR_PRINT("Function not found: " + function_name + " (Added to the public API?)");
		error.error = GDEXTENSION_CALL_ERROR_INVALID_METHOD;
		error.argument = 0;
		return Variant();
	}

	error.error = GDEXTENSION_CALL_OK;
	return this->vmcall_internal(address, args, arg_count);
}
Variant Sandbox::vmcallv(const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error) {
	if (arg_count < 1) {
		error.error = GDEXTENSION_CALL_ERROR_TOO_FEW_ARGUMENTS;
		error.argument = -1;
		return Variant();
	}

	const Variant &function = *args[0];
	args += 1;
	arg_count -= 1;
	const String function_name = function.operator String();
	const gaddr_t address = cached_address_of(function_name.hash(), function_name);
	if (address == 0) {
		ERR_PRINT("Function not found: " + function_name + " (Added to the public API?)");
		error.error = GDEXTENSION_CALL_ERROR_INVALID_METHOD;
		error.argument = 0;
		return Variant();
	}

	// Store unboxed_arguments state and restore it after the call
	Variant result;
	auto old_unboxed_arguments = this->get_unboxed_arguments();
	this->set_unboxed_arguments(false);
	result = this->vmcall_internal(address, args, arg_count);
	this->set_unboxed_arguments(old_unboxed_arguments);

	error.error = GDEXTENSION_CALL_OK;
	return result;
}
Variant Sandbox::vmcall_fn(const StringName &function_name, const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error) {
	if (this->m_throttled > 0) {
		this->m_throttled--;
		return Variant();
	}
	// Sandbox.call() is a special case that allows calling functions by name
	if (function_name == StringName("call")) {
		// Redirect to vmcall() with the first argument as the function name
		return this->vmcall(args, arg_count, error);
	}
	const gaddr_t address = cached_address_of(function_name.hash(), function_name);
	if (address == 0) {
		ERR_PRINT("Function not found: " + function_name + " (Added to the public API?)");
		error.error = GDEXTENSION_CALL_ERROR_INVALID_METHOD;
		return Variant();
	}

	Variant result = this->vmcall_internal(address, args, arg_count);
	error.error = GDEXTENSION_CALL_OK;
	return result;
}
void Sandbox::setup_arguments_native(gaddr_t arrayDataPtr, GuestVariant *v, const Variant **args, int argc) {
	// In this mode we will try to use registers when possible
	// The stack is already set up from setup_arguments(), so we just need to set up the registers
	machine_t &machine = this->machine();
	int index = 11;
	int flindex = 10;

	for (size_t i = 0; i < argc; i++) {
		const Variant &arg = *args[i];
		const GDNativeVariant *inner = (const GDNativeVariant *)arg._native_ptr();

		// Incoming arguments are implicitly trusted, as they are provided by the host
		// They also have have the guaranteed lifetime of the function call
		switch (arg.get_type()) {
			case Variant::Type::BOOL:
				machine.cpu.reg(index++) = inner->value;
				break;
			case Variant::Type::INT:
				//printf("Type: %u Value: %ld\n", inner->type, inner->value);
				machine.cpu.reg(index++) = inner->value;
				break;
			case Variant::Type::FLOAT: // Variant floats are always 64-bit
				//printf("Type: %u Value: %f\n", inner->type, inner->flt);
				machine.cpu.registers().getfl(flindex++).set_double(inner->flt);
				break;
			case Variant::VECTOR2: { // 8- or 16-byte structs can be passed in registers
				machine.cpu.registers().getfl(flindex++).set_float(inner->vec2_flt[0]);
				machine.cpu.registers().getfl(flindex++).set_float(inner->vec2_flt[1]);
				break;
			}
			case Variant::VECTOR2I: { // 8- or 16-byte structs can be passed in registers
				machine.cpu.reg(index++) = inner->value; // 64-bit packed integers
				break;
			}
			case Variant::VECTOR3: {
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->vec3_flt[0];
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->vec3_flt[2];
				break;
			}
			case Variant::VECTOR3I: {
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->ivec3_int[0];
				machine.cpu.reg(index++) = inner->ivec3_int[2];
				break;
			}
			case Variant::VECTOR4: {
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->vec4_flt[0];
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->vec4_flt[2];
				break;
			}
			case Variant::VECTOR4I: {
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->ivec4_int[0];
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->ivec4_int[2];
				break;
			}
			case Variant::COLOR: { // 16-byte struct (must use integer registers)
				// RVG calling convention:
				// Unions and arrays containing floats are passed in integer registers
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->color_flt[0];
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->color_flt[2];
				break;
			}
			case Variant::PLANE: {
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->vec4_flt[0];
				machine.cpu.reg(index++) = *(gaddr_t *)&inner->vec4_flt[2];
				break;
			}
			case Variant::OBJECT: { // Objects are represented as uintptr_t
				godot::Object *obj = inner->to_object();
				this->add_scoped_object(obj);
				machine.cpu.reg(index++) = uintptr_t(obj); // Fits in a single register
				break;
			}
			case Variant::ARRAY:
			case Variant::DICTIONARY:
			case Variant::STRING:
			case Variant::STRING_NAME:
			case Variant::NODE_PATH:
			case Variant::RID:
			case Variant::CALLABLE:
			case Variant::TRANSFORM2D:
			case Variant::BASIS:
			case Variant::TRANSFORM3D:
			case Variant::QUATERNION:
			case Variant::PACKED_BYTE_ARRAY:
			case Variant::PACKED_FLOAT32_ARRAY:
			case Variant::PACKED_FLOAT64_ARRAY:
			case Variant::PACKED_INT32_ARRAY:
			case Variant::PACKED_INT64_ARRAY:
			case Variant::PACKED_VECTOR2_ARRAY:
			case Variant::PACKED_VECTOR3_ARRAY:
			case Variant::PACKED_VECTOR4_ARRAY:
			case Variant::PACKED_COLOR_ARRAY:
			case Variant::PACKED_STRING_ARRAY: { // Uses Variant index to reference the object
				unsigned idx = this->add_scoped_variant(&arg);
				machine.cpu.reg(index++) = idx;
				break;
			}
			default: { // Complex types are passed byref, pushed onto the stack as GuestVariant
				GuestVariant &g_arg = v[i + 1];
				g_arg.set(*this, arg, true);
				machine.cpu.reg(index++) = arrayDataPtr + (i + 1) * sizeof(GuestVariant);
			}
		}
	}

	if (UNLIKELY(index > 18 || flindex > 18)) {
		throw std::runtime_error("Sandbox: Too many arguments for VM function call (register overflow)");
	}
}
GuestVariant *Sandbox::setup_arguments(gaddr_t &sp, const Variant **args, int argc) {
	if (this->get_unboxed_arguments()) {
		sp -= sizeof(GuestVariant) * (argc + 1);
		sp &= ~gaddr_t(0xF); // re-align stack pointer
		const gaddr_t arrayDataPtr = sp;
		const int arrayElements = argc + 1;

		GuestVariant *v = m_machine->memory.memarray<GuestVariant>(arrayDataPtr, arrayElements);

		// Set up first argument (return value, also a Variant)
		m_machine->cpu.reg(10) = arrayDataPtr;

		if (argc > 11)
			throw std::runtime_error("Sandbox: Too many arguments for VM function call");
		setup_arguments_native(arrayDataPtr, v, args, argc);
		// A0 is the return value (Variant) of the function
		return &v[0];
	}

	// We will support up to 16 arguments, with the first argument being the return value
	if (argc > 16)
		throw std::runtime_error("Sandbox: Too many arguments for VM function call");

	// The offset to where the first Variant is stored
	// The first argument is the return value, so we start at 1
	// The rest are overflow arguments, which are pushed onto the stack
	const int overflow_args = argc > 7 ? argc - 7 : 0;

	sp -= sizeof(GuestVariant) * (argc + 1) + sizeof(gaddr_t) * overflow_args;
	sp &= ~gaddr_t(0xF); // re-align stack pointer
	const gaddr_t arrayDataPtr = sp + sizeof(gaddr_t) * overflow_args;
	const int arrayElements = argc + 1;

	GuestVariant *v = m_machine->memory.memarray<GuestVariant>(arrayDataPtr, arrayElements);
	gaddr_t *overflow = nullptr;
	if (overflow_args > 0)
		overflow = m_machine->memory.memarray<gaddr_t>(sp, overflow_args);

	// Set up first argument (return value, also a Variant)
	m_machine->cpu.reg(10) = arrayDataPtr + overflow_args * sizeof(GuestVariant);

	for (size_t i = 0; i < argc; i++) {
		const Variant &arg = *args[i];
		GuestVariant &g_arg = v[1 + i];
		// Fast-path for simple types
		GDNativeVariant *inner = (GDNativeVariant *)arg._native_ptr();
		// Incoming arguments are implicitly trusted, as they are provided by the host
		// They also have have the guaranteed lifetime of the function call
		switch (arg.get_type()) {
			case Variant::Type::NIL:
				g_arg.type = Variant::Type::NIL;
				break;
			case Variant::Type::BOOL:
				g_arg.type = Variant::Type::BOOL;
				g_arg.v.b = inner->value;
				break;
			case Variant::Type::INT:
				g_arg.type = Variant::Type::INT;
				g_arg.v.i = inner->value;
				break;
			case Variant::Type::FLOAT:
				g_arg.type = Variant::Type::FLOAT;
				g_arg.v.f = inner->flt;
				break;
			case Variant::OBJECT: {
				godot::Object *obj = inner->to_object();
				// Objects passed directly as arguments are implicitly trusted/allowed
				g_arg.set_object(*this, obj);
				break;
			}
			default:
				g_arg.set(*this, *args[i], true);
		}
		if (i < 7) {
			m_machine->cpu.reg(11 + i) = arrayDataPtr + (1 + i) * sizeof(GuestVariant);
		} else {
			overflow[i - 7] = arrayDataPtr + (1 + i) * sizeof(GuestVariant);
		}
	}
	// A0 is the return value (Variant) of the function
	return &v[overflow_args];
}
Variant Sandbox::vmcall_internal(gaddr_t address, const Variant **args, int argc) {
	this->m_current_state += 1;
	const auto *beginptr = this->m_states.data();
	const auto *endptr = this->m_states.data() + this->m_states.size();
	if (UNLIKELY(this->m_current_state >= endptr)) {
		ERR_PRINT("Too many VM calls in progress");
		this->m_exceptions++;
		this->m_global_exceptions++;
		this->m_current_state -= 1;
		return Variant();
	}

	CurrentState &state = *this->m_current_state;
	const bool is_reentrant_call = (this->m_current_state - beginptr) > 1;
	state.reset();

	// Call statistics
	this->m_calls_made++;
	Sandbox::m_global_calls_made++;

	try {
		GuestVariant *retvar = nullptr;
		riscv::CPU<RISCV_ARCH> &cpu = m_machine->cpu;
		auto &sp = cpu.reg(riscv::REG_SP);
		// execute guest function
		if (!is_reentrant_call) {
			cpu.reg(riscv::REG_RA) = m_machine->memory.exit_address();
			// reset the stack pointer to its initial location
			sp = m_machine->memory.stack_initial();
			// set up each argument, and return value
			retvar = this->setup_arguments(sp, args, argc);
			// execute!
			if (UNLIKELY(this->m_precise_simulation)) {
				m_machine->set_instruction_counter(0);
				uint64_t max_instr = get_instructions_max() << 20;
				m_machine->set_max_instructions(max_instr ? max_instr : ~0ULL);
				m_machine->cpu.jump(address);
				m_machine->cpu.simulate_precise();
				if (m_machine->instruction_limit_reached()) {
					throw riscv::MachineTimeoutException(riscv::MAX_INSTRUCTIONS_REACHED,
						"Instruction count limit reached", max_instr);
				}
			} else if (UNLIKELY(this->get_profiling())) {
				LocalProfilingData &profdata = *this->m_local_profiling_data;
				m_machine->cpu.jump(address);
				do {
					const int32_t next = std::max(int32_t(1), int32_t(profdata.profiling_interval) - int32_t(profdata.profiler_icounter_accumulator));
					m_machine->simulate<false>(next, 0u);
					if (m_machine->instruction_limit_reached()) {
						profdata.profiler_icounter_accumulator = 0;
						profdata.visited.push_back(m_machine->cpu.pc());
					}
				} while (m_machine->instruction_limit_reached());
				// update the accumulator with the remaining instructions
				profdata.profiler_icounter_accumulator += m_machine->instruction_counter();
				if (profdata.profiler_icounter_accumulator >= profdata.profiling_interval) {
					profdata.profiler_icounter_accumulator = 0;
				}
				if (!profdata.visited.empty()) {
					ProfilingData &gprofdata = *this->m_profiling_data;
					// Determine ELF path
					std::string_view path = "";
					if (this->m_program_data.is_valid()) {
						path = this->m_program_data->get_std_path();
					}
					// Update the global profiler
					{
						std::scoped_lock lock(profiling_mutex);
						ProfilingState &gprofstate = gprofdata.state[path];
						// Add all the local known functions to the global state,
						// to aid lookup in the profiler later on
						if (gprofstate.lookup.size() < this->m_lookup.size()) {
							gprofstate.lookup.clear();
							for (const auto [hash, entry] : this->m_lookup) {
								gprofstate.lookup.push_back(entry);
							}
						}
						// Update the global visited map
						std::unordered_map<gaddr_t, int> &hotspots = gprofstate.hotspots;
						for (const gaddr_t address : profdata.visited) {
							hotspots[address]++;
						}
					}
					profdata.visited.clear();
				}
			} else if (get_instructions_max() <= 0) {
				m_machine->cpu.simulate_inaccurate(address);
			} else {
				m_machine->simulate_with(get_instructions_max() << 20, 0u, address);
			}
		} else {
			riscv::Registers<RISCV_ARCH> regs;
			regs = cpu.registers();
			// we are in a recursive call, so wait before setting exit address
			cpu.reg(riscv::REG_RA) = m_machine->memory.exit_address();
			// we need to make some stack room
			sp -= 16u;
			// set up each argument, and return value
			retvar = this->setup_arguments(sp, args, argc);
			// execute preemption! (precise simulation not supported)
			uint64_t max_instr = get_instructions_max() << 20;
			cpu.preempt_internal(regs, true, true, address, max_instr ? max_instr : ~0ULL);
		}

		// Treat return value as pointer to Variant
		Variant result = retvar->toVariant(*this);
		// Restore the previous state
		this->m_current_state -= 1;
		return result;

	} catch (const std::exception &e) {
		if (Engine::get_singleton()->is_editor_hint()) {
			// Throttle exceptions in the sandbox when calling from the editor
			this->m_throttled += EDITOR_THROTTLE;
		}
		this->handle_exception(address);
		// TODO: Free the function arguments and return value? Will help keep guest memory clean

		this->m_current_state -= 1;
		return Variant();
	}
}
Variant Sandbox::vmcallable(String function, Array args) {
	const gaddr_t address = cached_address_of(function.hash(), function);
	if (address == 0x0) {
		ERR_PRINT("Function not found in the guest: " + function);
		return Variant();
	}

	RiscvCallable *call = memnew(RiscvCallable);
	call->init(this, address, std::move(args));
	return Callable(call);
}
Variant Sandbox::vmcallable_address(gaddr_t address, Array args) {
	RiscvCallable *call = memnew(RiscvCallable);
	call->init(this, address, std::move(args));
	return Callable(call);
}
void RiscvCallable::call(const Variant **p_arguments, int p_argcount, Variant &r_return_value, GDExtensionCallError &r_call_error) const {
	if (m_varargs_base_count > 0) {
		// We may be receiving extra arguments, so we will fill at the end of m_varargs_ptrs array
		const int total_args = m_varargs_base_count + p_argcount;
		if (size_t(total_args) > m_varargs_ptrs.size()) {
			ERR_PRINT("Too many arguments for VM function call");
			r_call_error.error = GDEXTENSION_CALL_ERROR_INVALID_ARGUMENT;
			r_call_error.argument = p_argcount;
			return;
		}

		for (int i = 0; i < p_argcount; i++) {
			m_varargs_ptrs[m_varargs_base_count + i] = p_arguments[i];
		}
		r_return_value = self->vmcall_internal(address, m_varargs_ptrs.data(), total_args);
	} else {
		r_return_value = self->vmcall_internal(address, p_arguments, p_argcount);
	}
	r_call_error.error = GDEXTENSION_CALL_OK;
}

gaddr_t Sandbox::cached_address_of(int64_t hash, const String &function) const {
	gaddr_t address = 0x0;
	auto it = m_lookup.find(hash);
	if (it != m_lookup.end()) {
		return it->second.address;
	} else if (m_machine != &dummy_machine) {
		const CharString ascii = function.ascii();
		const std::string_view str{ ascii.get_data(), (size_t)ascii.length() };
		address = machine().address_of(str);
		// Cache the address and symbol name
		LookupEntry entry{ function, address };
		m_lookup.insert_or_assign(hash, std::move(entry));
	}
	return address;
}

gaddr_t Sandbox::address_of(const String &symbol) const {
	const int64_t hash = symbol.hash();
	return cached_address_of(hash, symbol);
}

String Sandbox::lookup_address(gaddr_t address) const {
	for (const auto &entry : m_lookup) {
		if (entry.second.address == address) {
			return entry.second.name;
		}
	}
	riscv::Memory<RISCV_ARCH>::Callsite callsite = machine().memory.lookup(address);
	return String::utf8(callsite.name.c_str(), callsite.name.size());
}

bool Sandbox::has_function(const StringName &p_function) const {
	const gaddr_t address = cached_address_of(p_function.hash(), p_function);
	return address != 0x0;
}

void Sandbox::add_cached_address(const String &name, gaddr_t address) const {
	m_lookup.insert_or_assign(name.hash(), LookupEntry{ name, address });
}

//-- Scoped objects and variants --//

unsigned Sandbox::add_scoped_variant(const Variant *value) const {
	CurrentState &st = this->state();
	if (st.scoped_variants.size() >= st.variants.capacity()) {
		ERR_PRINT("Maximum number of scoped variants reached.");
		throw std::runtime_error("Maximum number of scoped variants reached.");
	}
	st.scoped_variants.push_back(value);
	if (&st != &this->m_states[0])
		return int32_t(st.scoped_variants.size()) - 1;
	else
		return -int32_t(st.scoped_variants.size());
}
unsigned Sandbox::create_scoped_variant(Variant &&value) const {
	CurrentState &st = this->state();
	if (st.scoped_variants.size() >= st.variants.capacity()) {
		ERR_PRINT("Maximum number of scoped variants reached.");
		throw std::runtime_error("Maximum number of scoped variants reached.");
	}
	st.append(std::move(value));
	if (&st != &this->m_states[0])
		return int32_t(st.scoped_variants.size()) - 1;
	else
		return -int32_t(st.scoped_variants.size());
}
std::optional<const Variant *> Sandbox::get_scoped_variant(int32_t index) const noexcept {
	if (index >= 0 && index < state().scoped_variants.size()) {
		return state().scoped_variants[index];
	} else if (index < 0) {
		// Negative index is access into initialization state
		index = -index - 1;
		auto &init_state = this->m_states[0];
		if (index < init_state.scoped_variants.size()) {
			return init_state.scoped_variants[index];
		}
		ERR_PRINT("Invalid permanent variant index: " + itos(index));
		return std::nullopt;
	}
	ERR_PRINT("Invalid scoped variant index: " + itos(index));
	return std::nullopt;
}
Variant &Sandbox::get_mutable_scoped_variant(int32_t index) {
	std::optional<const Variant *> var_opt = get_scoped_variant(index);
	if (!var_opt.has_value()) {
		ERR_PRINT("Invalid scoped variant index.");
		throw std::runtime_error("Invalid scoped variant index.");
	}
	const Variant *var = var_opt.value();
	// Find the variant in the variants list
	auto it = std::find_if(state().variants.begin(), state().variants.end(), [var](const Variant &v) {
		return &v == var;
	});
	if (it == state().variants.end()) {
		// Create a new variant in the list using the existing one, and return it
		if (state().variants.size() >= state().variants.capacity()) {
			ERR_PRINT("Maximum number of scoped variants reached.");
			throw std::runtime_error("Maximum number of scoped variants reached.");
		}
		state().append(Variant(*var));
		return state().variants.back();
	}
	return *it;
}
unsigned Sandbox::create_permanent_variant(unsigned idx) {
	if (int32_t(idx) < 0) {
		// It's already a permanent variant
		return idx;
	}
	std::optional<const Variant *> var_opt = get_scoped_variant(idx);
	if (!var_opt.has_value()) {
		ERR_PRINT("create_permanent_variant(): Invalid scoped variant index " + itos(idx));
		throw std::runtime_error("Could not make permanent: Invalid scoped variant index " + std::to_string(idx));
	}
	const Variant *var = var_opt.value();
	// Find the variant in the variants list
	auto it = std::find_if(state().variants.begin(), state().variants.end(), [var](const Variant &v) {
		return &v == var;
	});

	CurrentState &perm_state = this->m_states[0];
	if (perm_state.variants.size() >= perm_state.variants.capacity()) {
		ERR_PRINT("Maximum number of scoped variants in permanent state reached.");
		// Just return the old scoped variant
		return idx;
	}

	if (it == state().variants.end()) {
		// Create a new variant in the permanent list
		perm_state.append(var->duplicate());
	} else {
		// Move the variant to the permanent list, leave the old one in the scoped list
		perm_state.append(std::move(*it));
	}
	unsigned perm_idx = perm_state.variants.size() - 1;
	// Return the index of the new permanent variant converted to negative
	return -int32_t(perm_idx) - 1;
}
void Sandbox::assign_permanent_variant(int32_t idx, Variant &&val) {
	if (idx < 0) {
		// It's a permanent variant, verify the index
		idx = -idx - 1;
		if (idx < this->m_states[0].variants.size()) {
			this->m_states[0].variants[idx] = std::move(val);
			return;
		}
	}
	// It's either a scoped (temporary) variant, or invalid
	ERR_PRINT("Invalid permanent variant index.");
	throw std::runtime_error("Invalid permanent variant index: " + std::to_string(idx));
}
unsigned Sandbox::try_reuse_assign_variant(int32_t src_idx, const Variant &src_var, int32_t assign_to_idx, const Variant &new_value) {
	if (this->is_permanent_variant(assign_to_idx)) {
		// The Variant is permanent, so we need to assign it directly.
		// Permanent Variants are scarce and should not be duplicated.
		this->assign_permanent_variant(assign_to_idx, Variant(new_value));
		return assign_to_idx;
	} else if (assign_to_idx == src_idx && this->state().is_mutable_variant(src_var)) {
		// They are the same, and the Variant belongs to the current state, so we can modify it directly.
		const_cast<Variant &>(src_var) = new_value;
		return assign_to_idx;
	} else {
		// The Variant is either temporary or invalid, so we can replace it directly.
		return this->create_scoped_variant(Variant(new_value));
	}
}

void Sandbox::add_scoped_object(const void *ptr) {
	if (state().scoped_objects.size() >= this->m_max_refs) {
		ERR_PRINT("Maximum number of scoped objects reached.");
		throw std::runtime_error("Maximum number of scoped objects reached.");
	}
	state().scoped_objects.push_back(reinterpret_cast<uintptr_t>(ptr));
}

//-- Properties --//

void Sandbox::read_program_properties(bool editor) const {
	gaddr_t prop_addr = 0x0;
	try {
		// Properties is an array named properties, that ends with an invalid property
		prop_addr = machine().address_of("properties");
		if (prop_addr == 0x0)
			return;
	} catch (...) {
		return;
	}
	try {
		struct GuestProperty {
			gaddr_t g_name;
			unsigned size;
			Variant::Type type;
			gaddr_t getter;
			gaddr_t setter;
			GuestVariant def_val;
		};
		auto *props = machine().memory.memarray<GuestProperty>(prop_addr, MAX_PROPERTIES);

		for (int i = 0; i < MAX_PROPERTIES; i++) {
			const GuestProperty *prop = &props[i];
			// Invalid property: stop reading
			if (prop->g_name == 0)
				break;
			// Check if the property is valid by checking its size
			if (prop->size != sizeof(GuestProperty)) {
				//ERR_PRINT("Sandbox: Invalid property size");
				break;
			}
			const std::string c_name = machine().memory.memstring(prop->g_name);
			Variant def_val = prop->def_val.toVariant(*this);

			this->add_property(String::utf8(c_name.c_str(), c_name.size()), prop->type, prop->setter, prop->getter, def_val);
		}
	} catch (const std::exception &e) {
		ERR_PRINT("Sandbox exception in " + get_name() + " while reading properties: " + String(e.what()));
	}
}

void Sandbox::add_property(const String &name, Variant::Type vtype, uint64_t setter, uint64_t getter, const Variant &def) const {
	if (setter == 0 || getter == 0) {
		ERR_PRINT("Sandbox: Setter and getter not found for property: " + name);
		return;
	} else if (m_properties.size() >= MAX_PROPERTIES) {
		ERR_PRINT("Sandbox: Maximum number of properties reached");
		return;
	}
	for (const String &builtin_name : property_names) {
		if (name.begins_with(builtin_name)) {
			ERR_PRINT("Sandbox: Property name conflicts with built-in property: " + name);
			return;
		}
	}
	for (const SandboxProperty &prop : m_properties) {
		if (prop.name() == name) {
			// TODO: Allow overriding properties?
			//ERR_PRINT("Sandbox: Property already exists: " + name);
			return;
		}
	}
	m_properties.emplace_back(name, vtype, setter, getter, def);

	// Make the property getter/setter functions visible to address_of and profiling
	this->add_cached_address("set_" + name, getter);
	this->add_cached_address("get_" + name, setter);
}
void Sandbox::add_property(const String &name, Variant::Type vtype, gaddr_t address, const Variant &def) const
{
	if (address == 0) {
		ERR_PRINT("Sandbox: Address not found for property: " + name);
		return;
	} else if (m_properties.size() >= MAX_PROPERTIES) {
		ERR_PRINT("Sandbox: Maximum number of properties reached");
		return;
	}
	for (const String &builtin_name : property_names) {
		if (name.begins_with(builtin_name)) {
			ERR_PRINT("Sandbox: Property name conflicts with built-in property: " + name);
			return;
		}
	}
	for (const SandboxProperty &prop : m_properties) {
		if (prop.name() == name) {
			ERR_PRINT("Sandbox: Property already exists: " + name);
			return;
		}
	}
	m_properties.emplace_back(name, vtype, address, def);
}

bool Sandbox::set_property(const StringName &name, const Variant &value) {
	for (SandboxProperty &prop : m_properties) {
		if (prop.name() == name) {
			prop.set(*this, value);
			//ERR_PRINT("Sandbox: SetProperty *found*: " + name);
			return true;
		}
	}
	// Not the most efficient way to do this, but it's (currently) a small list
	if (name == property_names[PROP_REFERENCES_MAX]) {
		set_max_refs(value);
		return true;
	} else if (name == property_names[PROP_MEMORY_MAX]) {
		set_memory_max(value);
		return true;
	} else if (name == property_names[PROP_EXECUTION_TIMEOUT]) {
		set_instructions_max(value);
		return true;
	} else if (name == property_names[PROP_ALLOCATIONS_MAX]) {
		set_allocations_max(value);
		return true;
	} else if (name == property_names[PROP_UNBOXED_ARGUMENTS]) {
		set_unboxed_arguments(value);
		return true;
	} else if (name == property_names[PROP_PRECISE_SIMULATION]) {
		set_precise_simulation(value);
		return true;
#ifdef RISCV_LIBTCC
	} else if (name == property_names[PROP_BINTR_NBIT_AS]) {
		set_binary_translation_automatic_nbit_as(value);
		return true;
	} else if (name == property_names[PROP_BINTR_REG_CACHE]) {
		set_binary_translation_register_caching(value);
		return true;
#endif // RISCV_LIBTCC
	} else if (name == property_names[PROP_PROFILING]) {
		set_profiling(value);
		return true;
	} else if (name == property_names[PROP_RESTRICTIONS]) {
		set_restrictions(value);
		return true;
	} else if (name == property_names[PROP_PROGRAM]) {
		set_program(value);
		return true;
	}
	if constexpr (VERBOSE_PROPERTIES) {
		printf("Sandbox: SetProperty *not found*: %s\n", String(name).utf8().get_data());
	}
	return false;
}

bool Sandbox::get_property(const StringName &name, Variant &r_ret) {
	for (const SandboxProperty &prop : m_properties) {
		if (prop.name() == name) {
			r_ret = prop.get(*this);
			//ERR_PRINT("Sandbox: GetProperty *found*: " + name);
			return true;
		}
	}
	// Not the most efficient way to do this, but it's (currently) a small list
	if (name == property_names[PROP_REFERENCES_MAX]) {
		r_ret = get_max_refs();
		return true;
	} else if (name == property_names[PROP_MEMORY_MAX]) {
		r_ret = get_memory_max();
		return true;
	} else if (name == property_names[PROP_EXECUTION_TIMEOUT]) {
		r_ret = get_instructions_max();
		return true;
	} else if (name == property_names[PROP_ALLOCATIONS_MAX]) {
		r_ret = get_allocations_max();
		return true;
	} else if (name == property_names[PROP_UNBOXED_ARGUMENTS]) {
		r_ret = get_unboxed_arguments();
		return true;
	} else if (name == property_names[PROP_PRECISE_SIMULATION]) {
		r_ret = get_precise_simulation();
		return true;
#ifdef RISCV_LIBTCC
	} else if (name == property_names[PROP_BINTR_NBIT_AS]) {
		r_ret = this->m_bintr_automatic_nbit_as;
		return true;
	} else if (name == property_names[PROP_BINTR_REG_CACHE]) {
		r_ret = this->m_bintr_register_caching;
		return true;
#endif // RISCV_LIBTCC
	} else if (name == property_names[PROP_PROFILING]) {
		r_ret = get_profiling();
		return true;
	} else if (name == property_names[PROP_RESTRICTIONS]) {
		r_ret = get_restrictions();
		return true;
	} else if (name == property_names[PROP_PROGRAM]) {
		r_ret = get_program();
		return true;
	} else if (name == property_names[PROP_MONITOR_HEAP_USAGE]) {
		r_ret = get_heap_usage();
		return true;
	} else if (name == property_names[PROP_MONITOR_HEAP_CHUNK_COUNT]) {
		r_ret = get_heap_chunk_count();
		return true;
	} else if (name == property_names[PROP_MONITOR_HEAP_ALLOCATION_COUNTER]) {
		r_ret = get_heap_allocation_counter();
		return true;
	} else if (name == property_names[PROP_MONITOR_HEAP_DEALLOCATION_COUNTER]) {
		r_ret = get_heap_deallocation_counter();
		return true;
	} else if (name == property_names[PROP_MONITOR_EXCEPTIONS]) {
		r_ret = get_exceptions();
		return true;
	} else if (name == property_names[PROP_MONITOR_EXECUTION_TIMEOUTS]) {
		r_ret = get_timeouts();
		return true;
	} else if (name == property_names[PROP_MONITOR_CALLS_MADE]) {
		r_ret = get_calls_made();
		return true;
	} else if (name == property_names[PROP_MONITOR_BINARY_TRANSLATED]) {
		r_ret = is_binary_translated();
		return true;
	} else if (name == property_names[PROP_GLOBAL_CALLS_MADE]) {
		r_ret = get_global_calls_made();
		return true;
	} else if (name == property_names[PROP_GLOBAL_EXCEPTIONS]) {
		r_ret = get_global_exceptions();
		return true;
	} else if (name == property_names[PROP_GLOBAL_TIMEOUTS]) {
		r_ret = get_global_timeouts();
		return true;
	} else if (name == property_names[PROP_MONITOR_ACCUMULATED_STARTUP_TIME]) {
		r_ret = get_accumulated_startup_time();
		return true;
	} else if (name == property_names[PROP_MONITOR_GLOBAL_INSTANCE_COUNT]) {
		r_ret = get_global_instance_count();
		return true;
	}
	if constexpr (VERBOSE_PROPERTIES) {
		printf("Sandbox: GetProperty *not found*: %s\n", String(name).utf8().get_data());
	}
	return false;
}

const SandboxProperty *Sandbox::find_property_or_null(const StringName &name) const {
	for (const SandboxProperty &prop : m_properties) {
		if (prop.name() == name) {
			return &prop;
		}
	}
	return nullptr;
}

Variant Sandbox::get(const StringName &name) {
	Variant result;
	if (get_property(name, result)) {
		return result;
	}
	// Get as if it's on the underlying Node object
	return Node::get(name);
}

void Sandbox::set(const StringName &name, const Variant &value) {
	if (!set_property(name, value)) {
		// Set as if it's on the underlying Node object
		Node::set(name, value);
	}
}

Array Sandbox::get_property_list() const {
	Array arr;
	// Sandboxed properties
	for (const SandboxProperty &prop : m_properties) {
		Dictionary d;
		d["name"] = prop.name();
		d["type"] = prop.type();
		d["usage"] = PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_STORAGE | PROPERTY_USAGE_SCRIPT_VARIABLE;
		arr.push_back(d);
	}
	// Our properties
	for (const PropertyInfo &prop : this->create_sandbox_property_list()) {
		Dictionary d;
		d["name"] = prop.name;
		d["type"] = prop.type;
		d["usage"] = PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_STORAGE | PROPERTY_USAGE_SCRIPT_VARIABLE;
		arr.push_back(d);
	}
	// Node properties
	arr.append_array(Node::get_property_list());
	return arr;
}

void SandboxProperty::set(Sandbox &sandbox, const Variant &value) {
	if (m_setter_address == 0) {
		if (m_address != 0) {
			// Direct property access
			GuestVariant *g_prop = sandbox.machine().memory.memarray<GuestVariant>(m_address, 1);
			g_prop->create(sandbox, Variant(value));
			return;
		}
		ERR_PRINT("Sandbox: Setter was invalid for property: " + m_name);
		return;
	}
	const Variant *args[] = { &value };
	// Store unboxed_arguments state and restore it after the call
	// It's much more convenient to use Variant arguments for properties
	auto old_unboxed_arguments = sandbox.get_unboxed_arguments();
	sandbox.set_unboxed_arguments(false);
	sandbox.vmcall_internal(m_setter_address, args, 1);
	sandbox.set_unboxed_arguments(old_unboxed_arguments);
}

Variant SandboxProperty::get(const Sandbox &sandbox) const {
	if (m_getter_address == 0) {
		if (m_address != 0) {
			// Direct property access
			GuestVariant *g_prop = sandbox.machine().memory.memarray<GuestVariant>(m_address, 1);
			return g_prop->toVariant(sandbox);
		}
		ERR_PRINT("Sandbox: Getter was invalid for property: " + m_name);
		return Variant();
	}
	return const_cast<Sandbox &>(sandbox).vmcall_internal(m_getter_address, nullptr, 0);
}

void Sandbox::CurrentState::initialize(unsigned level, unsigned max_refs) {
	(void)level;
	this->variants.reserve(max_refs);
}
void Sandbox::CurrentState::reinitialize(unsigned level, unsigned max_refs) {
	(void)level;
	this->variants.reserve(max_refs);
	this->variants.clear();
	this->scoped_objects.clear();
	this->scoped_variants.clear();
}
bool Sandbox::CurrentState::is_mutable_variant(const Variant &var) const {
	// Check if the address of the variant is within the range of the current state std::vector
	const Variant *ptr = &var;
	return ptr >= &variants[0] && ptr < &variants[0] + variants.size();
}

void Sandbox::set_max_refs(uint32_t max) {
	this->m_max_refs = max;
	// If we are not in a call, reset the states
	if (!this->is_in_vmcall()) {
		for (size_t i = 0; i < this->m_states.size(); i++) {
			this->m_states[i].initialize(i, max);
		}
	} else {
		ERR_PRINT("Sandbox: Cannot change max references during a Sandbox call.");
	}
}

void Sandbox::set_allocations_max(int64_t max) {
	this->m_allocations_max = max;
	if (machine().has_arena()) {
		machine().arena().set_max_chunks(max);
	}
}

int64_t Sandbox::get_heap_usage() const {
	if (machine().has_arena()) {
		return machine().arena().bytes_used();
	}
	return 0;
}

int64_t Sandbox::get_heap_chunk_count() const {
	if (machine().has_arena()) {
		return machine().arena().chunks_used();
	}
	return 0;
}

int64_t Sandbox::get_heap_allocation_counter() const {
	if (machine().has_arena()) {
		return machine().arena().allocation_counter();
	}
	return 0;
}

int64_t Sandbox::get_heap_deallocation_counter() const {
	if (machine().has_arena()) {
		return machine().arena().deallocation_counter();
	}
	return 0;
}

void Sandbox::print(const Variant &v) {
	static bool already_been_here = false;
	if (already_been_here) {
		ERR_PRINT("Recursive call to Sandbox::print() detected, ignoring.");
		return;
	}
	already_been_here = true;

	if (this->m_redirect_stdout.is_valid()) {
		// Redirect to a GDScript callback function
		this->m_redirect_stdout.call(v);
	} else {
		// Print to the console
		UtilityFunctions::print(v);
	}

	already_been_here = false;
}

bool Sandbox::is_sandbox_function(const StringName &p_function) const {
	// Only functions listed in sandbox.h and public:
	static const HashSet<StringName> sandbox_functions = {
		"vmcall",
		"vmcall_address",
		"vmcallable",
		"vmcallable_address",
		"get_program",
		"set_program",
		"has_function",
		"address_of",
		"lookup_address",
		"get_max_refs",
		"set_max_refs",
		"get_memory_max",
		"set_memory_max",
		"get_instructions_max",
		"set_instructions_max",
		"get_allocations_max",
		"set_allocations_max",
		"get_unboxed_arguments",
		"set_unboxed_arguments",
		"get_precise_simulation",
		"set_precise_simulation",
		"get_profiling",
		"set_profiling",
		"get_restrictions",
		"set_restrictions",
		"get_exceptions",
		"get_timeouts",
		"get_calls_made",
		"is_binary_translated",
		"get_global_calls_made",
		"get_global_exceptions",
		"get_global_timeouts",
		"get_accumulated_startup_time",
		"get_global_instance_count",

		"set_object_allowed_callback",
		"is_allowed_object",
		"set_class_allowed_callback",
		"is_allowed_class",
		"set_resource_allowed_callback",
		"is_allowed_resource",
		"set_method_allowed_callback",
		"is_allowed_method",
		"set_property_allowed_callback",
		"is_allowed_property",

		"share_byte_array",
		"share_float32_array",
		"share_float64_array",
		"share_int32_array",
		"share_int64_array",
		"share_vec2_array",
		"share_vec3_array",
		"share_vec4_array",
		"unshare_array",

		"get_hotspots",
		"clear_hotspots",
		"get_redirect_stdout",
		"set_redirect_stdout",

		"set_jit_enabled",
		"is_jit_enabled",
		"has_feature_jit",
	};

	return sandbox_functions.has(p_function);
}

```

`src/sandbox.h`:

```h
#pragma once
#include <algorithm>
#include <godot_cpp/classes/node.hpp>
#include <godot_cpp/core/binder_common.hpp>
#include <libriscv/machine.hpp>
#include <optional>

using namespace godot;
#define RISCV_ARCH riscv::RISCV64
using gaddr_t = riscv::address_type<RISCV_ARCH>;
using machine_t = riscv::Machine<RISCV_ARCH>;
#include "elf/script_elf.h"
#include "vmcallable.h"
#include "vmproperty.h"

/**
 * @brief The Sandbox class is a Godot node that provides a safe environment for running untrusted code.
 *
 * The sandbox is constructed with a program, which is a 64-bit RISC-V ELF executable file that contains functions and code to be executed.
 * Programs are loaded into the sandbox using the `set_program` method.
 * Upon setting a program, the sandbox will load the program into memory and initialize the RISC-V machine in several steps:
 * 1. Remove old machine instance, if any.
 * 2. Create a new machine instance with the given program.
 * 3. Set up system calls, native heap and native memory syscalls.
 * 4. Set up the Linux environment for the program.
 * 5. Run the program through to its main() function.
 * 6. Read the program's properties. These will be visible to the Godot editor.
 * 7. Pre-cache some public functions. These will be available to call from GDScript.
 **/
class Sandbox : public Node {
	GDCLASS(Sandbox, Node);

protected:
	static void _bind_methods();

	String _to_string() const;

public:
	static constexpr unsigned MAX_INSTRUCTIONS = 8000; // Millions
	static constexpr unsigned MAX_HEAP = 20ul; // MBs
	static constexpr unsigned MAX_VMEM = 20ul; // MBs
	static constexpr unsigned MAX_HEAP_ALLOCS = 4000; // Max guest heap allocations
	static constexpr unsigned MAX_LEVEL = 4; // Maximum call recursion depth
	static constexpr unsigned MAX_REFS = 100; // Default maximum number of references
	static constexpr unsigned EDITOR_THROTTLE = 8; // Throttle VM calls from the editor
	static constexpr unsigned MAX_PROPERTIES = 32; // Maximum number of sandboxed properties
	static constexpr unsigned MAX_PUBLIC_FUNCTIONS = 128; // Maximum number of public functions
	static constexpr gaddr_t SHM_BASE_ADDRESS = 0x400000000; // 16 GB

	struct CurrentState {
		std::vector<Variant> variants;
		std::vector<const Variant *> scoped_variants;
		std::vector<uintptr_t> scoped_objects;

		void append(Variant &&value);
		void initialize(unsigned level, unsigned max_refs);
		void reinitialize(unsigned level, unsigned max_refs);
		void reset();
		bool is_mutable_variant(const Variant &var) const;
	};
	struct LookupEntry {
		String name;
		gaddr_t address;
	};
	struct SharedMemoryRange {
		gaddr_t start;
		gaddr_t size;
		void *base_ptr;

		SharedMemoryRange(gaddr_t p_start, gaddr_t p_size, void *p_base_ptr)
			: start(p_start), size(p_size), base_ptr(p_base_ptr) {}
		bool contains(gaddr_t address) const {
			return address >= start && address < start + size;
		}
	};
	struct ProfilingState {
		std::unordered_map<gaddr_t, int> hotspots;
		std::vector<LookupEntry> lookup;
	};

	Sandbox();
	Sandbox(const PackedByteArray &buffer);
	Sandbox(Ref<ELFScript> program);
	~Sandbox();
	static void Initialize();

	static Sandbox *FromBuffer(const PackedByteArray &buffer) { return memnew(Sandbox(buffer)); }
	static Sandbox *FromProgram(Ref<ELFScript> program) { return memnew(Sandbox(std::move(program))); }

	// -= VM function calls =-

	/// @brief Make a function call to a function in the guest by its name.
	/// @param args The arguments to pass to the function, where the first argument is the name of the function.
	/// @param arg_count The number of arguments.
	/// @param error The error code, if any.
	/// @return The return value of the function call.
	Variant vmcall(const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error);
	/// @brief Make a function call to a function in the guest by its name. Always use Variant values for arguments.
	/// @param args The arguments to pass to the function, where the first argument is the name of the function.
	/// @param arg_count The number of arguments.
	/// @param error The error code, if any.
	/// @return The return value of the function call.
	Variant vmcallv(const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error);
	/// @brief Make a function call to a function in the guest by its name.
	/// @param function The name of the function to call.
	/// @param args The arguments to pass to the function.
	/// @param arg_count The number of arguments.
	/// @return The return value of the function call.
	Variant vmcall_fn(const StringName &function, const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error);
	/// @brief Make a function call to a function in the guest by its guest address.
	/// @param address The address of the function to call.
	/// @param args The arguments to pass to the function.
	/// @param arg_count The number of arguments.
	/// @param error The error code, if any.
	/// @return The return value of the function call.
	Variant vmcall_address(gaddr_t address, const Variant **args, GDExtensionInt arg_count, GDExtensionCallError &error);

	/// @brief Make a function call to a function in the guest by its name.
	/// @param function The name of the function to call.
	/// @param args The arguments to pass to the function.
	/// @return The return value of the function call.
	/// @note The extra arguments are saved in the callable object, and will be passed to the function when it is called
	/// in front of the arguments passed to the call() method. So, as an example, if you have a function that takes 3 arguments,
	/// and you call it with 2 arguments, you can later call the callable object with one argument, which turns into the 3rd argument.
	Variant vmcallable(String function, Array args);
	Variant vmcallable_address(uint64_t address, Array args);

	/// @brief Set whether to prefer register values for VM function calls.
	/// @param use_unboxed_arguments True to prefer register values, false to prefer Variant values.
	void set_unboxed_arguments(bool use_unboxed_arguments) { m_use_unboxed_arguments = use_unboxed_arguments; }
	/// @brief Get whether to prefer register values for VM function calls.
	/// @return True if register values are preferred, false if Variant values are preferred.
	bool get_unboxed_arguments() const { return m_use_unboxed_arguments; }

	/// @brief Set whether to use precise simulation for VM execution.
	/// @param use_precise_simulation True to use precise simulation, false to use fast simulation.
	void set_precise_simulation(bool use_precise_simulation) { m_precise_simulation = use_precise_simulation; }

	/// @brief Get whether to use precise simulation for VM execution.
	/// @return True if precise simulation is used, false otherwise.
	bool get_precise_simulation() const { return m_precise_simulation; }

	/// @brief Set whether or not to enable profiling of the guest program.
	/// @param enable True to enable profiling, false to disable it.
	void set_profiling(bool enable);

	/// @brief Get whether profiling of the guest program is enabled.
	/// @return True if profiling is enabled, false otherwise.
	bool get_profiling() const { return m_local_profiling_data != nullptr; }

	/// @brief  Check if the sandbox is currently initializing (running through main()).
	/// @return True if the sandbox is initializing, false otherwise.
	/// @note This is used to enforce or prevent certain operations from being performed during initialization.
	/// For example, it's only possible to add properties or public API functions to the sandbox during initialization.
	bool is_initializing() const { return m_is_initialization; }

	// -= Sandbox Properties =-

	uint32_t get_max_refs() const { return m_max_refs; }
	void set_max_refs(uint32_t max);
	void set_memory_max(uint32_t max);
	uint32_t get_memory_max() const { return m_memory_max; }
	void set_instructions_max(int64_t max) { m_insn_max = max; }
	int64_t get_instructions_max() const { return m_insn_max; }
	void set_allocations_max(int64_t max);
	int64_t get_allocations_max() const { return m_allocations_max; }
	int64_t get_heap_usage() const;
	int64_t get_heap_chunk_count() const;
	int64_t get_heap_allocation_counter() const;
	int64_t get_heap_deallocation_counter() const;
	void set_exceptions(unsigned exceptions) {} // Do nothing (it's a read-only property)
	unsigned get_exceptions() const { return m_exceptions; }
	void set_timeouts(unsigned budget) {} // Do nothing (it's a read-only property)
	unsigned get_timeouts() const { return m_timeouts; }
	void set_calls_made(unsigned calls) {} // Do nothing (it's a read-only property)
	unsigned get_calls_made() const { return m_calls_made; }

	static uint64_t get_global_timeouts() { return m_global_timeouts; }
	static uint64_t get_global_exceptions() { return m_global_exceptions; }
	static uint64_t get_global_calls_made() { return m_global_calls_made; }

	/// @brief Get the global instance count of all sandbox instances.
	/// @return The global instance count.
	static uint64_t get_global_instance_count() { return m_global_instances_current; }

	/// @brief Get the globally accumulated startup time of all sandbox instantiations.
	/// @return The accumulated startup time.
	static double get_accumulated_startup_time() { return m_accumulated_startup_time; }

	// -= Address Lookup =-

	gaddr_t address_of(const String &symbol) const;

	gaddr_t cached_address_of(int64_t hash, const String &name) const;

	String lookup_address(gaddr_t address) const;

	/// @brief Check if a function exists in the guest program.
	/// @param p_function The name of the function to check.
	/// @return True if the function exists, false otherwise.
	bool has_function(const StringName &p_function) const;

	/// @brief Add a hash to address mapping to the cache.
	/// @param name The name of the function or symbol.
	/// @param address The address of the function or symbol.
	void add_cached_address(const String &name, gaddr_t address) const;

	// -= Call State Management =-

	/// @brief Get the current call state.
	/// @return The current call state.
	/// @note The call state is a stack of states, with the current state stored in m_current_state.
	auto &state() const { return *m_current_state; }
	auto &state() { return *m_current_state; }

	/// @brief Set the current tree base, which is the node that the sandbox will use for accessing the node tree.
	/// @param tree_base The tree base node.
	/// @note The tree base is the owner node that the sandbox will use to access the node tree. When scripts
	/// try to access the node path ".", they will be accessing this node, and navigating relative to it.
	void set_tree_base(godot::Node *tree_base) { this->m_tree_base = tree_base; }
	godot::Node *get_tree_base() const { return this->m_tree_base; }

	// -= Scoped objects and variants =-

	/// @brief Add a scoped variant to the current state.
	/// @param var The variant to add.
	/// @return The index of the added variant, passed to and used by the guest.
	unsigned add_scoped_variant(const Variant *var) const;

	/// @brief Create a new scoped variant, storing it in the current state.
	/// @param var The variant to add.
	/// @return The index of the added variant, passed to and used by the guest.
	unsigned create_scoped_variant(Variant &&var) const;

	/// @brief Get a scoped variant by its index.
	/// @param idx The index of the variant to get.
	/// @return The variant, or an empty optional if the index is invalid.
	std::optional<const Variant *> get_scoped_variant(int32_t idx) const noexcept;

	/// @brief Get a mutable scoped variant by its index.
	/// @param idx The index of the variant to get.
	/// @return The variant.
	Variant &get_mutable_scoped_variant(int32_t idx);

	/// @brief Create a new permanent variant, storing it in the current state.
	/// @param idx The index of the variant to duplicate or move.
	/// @return The index of the new permanent variant, passed to and used by the guest.
	unsigned create_permanent_variant(unsigned idx);

	/// @brief Check if a variant index is a permanent variant.
	/// @param idx The index of the variant to check.
	/// @return True if the variant is permanent, false otherwise.
	static bool is_permanent_variant(int32_t idx) noexcept { return idx < 0 && idx != INT32_MIN; }

	/// @brief Assign a permanent variant index with a new variant.
	/// @param idx The index of the permanent variant to assign.
	/// @param var The new variant to move-assign.
	void assign_permanent_variant(int32_t idx, Variant &&var);

	/// @brief Try to reuse a variant index for a new variant.
	/// If the index is permanent, assign the new variant directly to it.
	/// If the index is scoped, check if it is mutable (local to the current state) and assign the new variant to it.
	/// If the index immutable, unknown or invalid, create a new scoped variant.
	/// @param idx The index of the variant to assign.
	/// @param var The new variant to move-assign.
	/// @return The index of the assigned variant, passed to and used by the guest.
	unsigned try_reuse_assign_variant(int32_t src_idx, const Variant &src_var, int32_t assign_to_idx, const Variant &var);

	/// @brief Add a scoped object to the current state.
	/// @param ptr The pointer to the object to add.
	void add_scoped_object(const void *ptr);

	/// @brief Remove a scoped object from the current state.
	/// @param ptr The pointer to the object to remove.
	void rem_scoped_object(const void *ptr) { state().scoped_objects.erase(std::remove(state().scoped_objects.begin(), state().scoped_objects.end(), reinterpret_cast<uintptr_t>(ptr)), state().scoped_objects.end()); }

	/// @brief Check if an object is scoped in the current state.
	/// @param ptr The pointer to the object to check.
	/// @return True if the object is scoped, false otherwise.
	bool is_scoped_object(const void *ptr) const noexcept { return state().scoped_objects.end() != std::find(state().scoped_objects.begin(), state().scoped_objects.end(), reinterpret_cast<uintptr_t>(ptr)); }

	// -= Sandbox Restrictions =-

	/// @brief Enable *all* restrictions on the sandbox, restricting access to
	/// external classes, objects, object methods, object properties, and resources.
	/// In effect, all external access is disabled.
	void set_restrictions(bool enabled);

	/// @brief Check if restrictions are enabled on the sandbox.
	/// @return True if *all* restrictions are enabled, false otherwise.
	bool get_restrictions() const;

	/// @brief Add an object to the list of allowed objects.
	/// @param obj The object to add.
	void add_allowed_object(godot::Object *obj);

	/// @brief Remove an object from the list of allowed objects.
	/// @param obj The object to remove.
	/// @note If the list becomes empty, all objects are allowed.
	void remove_allowed_object(godot::Object *obj);

	/// @brief Clear the list of allowed objects.
	void clear_allowed_objects();

	/// @brief Check if an object is allowed in the sandbox.
	bool is_allowed_object(godot::Object *obj) const;

	/// @brief Set a callback to check if an object is allowed in the sandbox.
	/// @param callback The callable to check if an object is allowed.
	void set_object_allowed_callback(const Callable &callback);

	/// @brief Check if a class name is allowed in the sandbox.
	bool is_allowed_class(const String &name) const;

	/// @brief Set a callback to check if a class is allowed in the sandbox.
	/// @param callback The callable to check if a class is allowed.
	void set_class_allowed_callback(const Callable &callback);

	/// @brief Check if a resource is allowed in the sandbox.
	bool is_allowed_resource(const String &path) const;

	/// @brief Set a callback to check if a resource is allowed in the sandbox.
	/// @param callback The callable to check if a resource is allowed.
	void set_resource_allowed_callback(const Callable &callback);

	/// @brief Check if accessing a method on an object is allowed in the sandbox.
	/// @param method The name of the method to check.
	/// @return True if the method is allowed, false otherwise.
	bool is_allowed_method(godot::Object *obj, const Variant &method) const;

	/// @brief Set a callback to check if a method is allowed in the sandbox.
	/// @param callback The callable to check if a method is allowed.
	void set_method_allowed_callback(const Callable &callback);

	/// @brief Check if accessing a property on an object is allowed in the sandbox.
	/// @param obj The object to check.
	/// @param property The name of the property to check.
	/// @return True if the property is allowed, false otherwise.
	bool is_allowed_property(godot::Object *obj, const Variant &property, bool is_set) const;

	/// @brief Set a callback to check if a property is allowed in the sandbox.
	/// @param callback The callable to check if a property is allowed.
	void set_property_allowed_callback(const Callable &callback);

	/// @brief A falsy function used when restrictions are enabled.
	/// @return Always returns false.
	static bool restrictive_callback_function(Variant) { return false; }

	// -= Sandboxed Properties =-
	// These are properties that are exposed to the Godot editor, provided by the guest program.

	/// @brief Add a property to the sandbox.
	/// @param name The name of the property.
	/// @param vtype The type of the property.
	/// @param setter The guest address of the setter function.
	/// @param getter The guest address of the getter function.
	/// @param def The default value of the property.
	void add_property(const String &name, Variant::Type vtype, gaddr_t setter, gaddr_t getter, const Variant &def = "") const;
	void add_property(const String &name, Variant::Type vtype, gaddr_t address, const Variant &def = "") const;

	/// @brief Set a property in the sandbox.
	/// @param name The name of the property.
	/// @param value The new value to set.
	bool set_property(const StringName &name, const Variant &value);

	/// @brief Get a property from the sandbox.
	/// @param name The name of the property.
	/// @param r_ret The current value of the property.
	bool get_property(const StringName &name, Variant &r_ret);

	/// @brief Get a property from the sandbox.
	/// @param name The name of the property.
	/// @return The current value of the property.
	Variant get(const StringName &name);

	/// @brief Set a property in the sandbox.
	/// @param name The name of the property.
	/// @param value The new value to set.
	void set(const StringName &name, const Variant &value);

	/// @brief Get a list of properties.
	/// @return The list of properties.
	Array get_property_list() const;

	/// @brief Find a property in the sandbox, or return null if it does not exist.
	/// @param name The name of the property.
	/// @return The property, or null if it does not exist.
	const SandboxProperty *find_property_or_null(const StringName &name) const;

	/// @brief Get all sandboxed properties.
	/// @return The array of sandboxed properties.
	const std::vector<SandboxProperty> &get_properties() const { return m_properties; }

	/// @brief Get the list of sandbox properties as a dictionary.
	/// @note These are unrelated to SandboxProperty objects. It's all the properties that are exposed to the Godot editor.
	/// @return The dictionary of sandbox properties.
	static std::vector<PropertyInfo> create_sandbox_property_list();

	// -= Program management & public functions =-

	/// @brief Check if a program has been loaded into the sandbox.
	/// @return True if a program has been loaded, false otherwise.
	bool has_program_loaded() const;
	/// @brief Set the program to run in the sandbox.
	/// @param program The program to load and run.
	void set_program(Ref<ELFScript> program);
	/// @brief Get the program loaded into the sandbox.
	/// @return The program loaded into the sandbox.
	Ref<ELFScript> get_program();

	/// @brief Load a program from a buffer into the sandbox.
	/// @param buffer The buffer containing the program.
	void load_buffer(const PackedByteArray &buffer);

	/// @brief Reset the sandbox, clearing all state and reloads the program.
	void reset(bool unload = false);

	struct BinaryInfo {
		String language;
		PackedStringArray functions;
		int version = 0;
	};
	/// @brief Get information about the program from the binary.
	/// @param binary The binary data.
	/// @return An array of public callable functions and programming language.
	static BinaryInfo get_program_info_from_binary(const PackedByteArray &binary);

	/// @brief Check if a function is Sandbox-specific (and public API).
	/// @param p_function The name of the function to check.
	/// @return True if the function is Sandbox-specific, false otherwise.
	bool is_sandbox_function(const StringName &p_function) const;

	// -= Shared Memory =-

	/// @brief Share a byte array with the guest program. Page-unaligned memory
	/// at the end is initialized to zero.
	/// @param allow_write Whether the guest program is allowed to write to the shared memory range.
	/// @param array The array to share.
	/// @return The guest address of the shared memory range.
	/// @warning Deallocating or resizing the underlying array will break the shared memory range.
	/// @warning The shared memory must be freed manually by calling unshare_array() when no longer needed.
	gaddr_t share_byte_array(bool allow_write, const PackedByteArray &array);
	gaddr_t share_float32_array(bool allow_write, const PackedFloat32Array &array);
	gaddr_t share_float64_array(bool allow_write, const PackedFloat64Array &array);
	gaddr_t share_int32_array(bool allow_write, const PackedInt32Array &array);
	gaddr_t share_int64_array(bool allow_write, const PackedInt64Array &array);
	gaddr_t share_vec2_array(bool allow_write, const PackedVector2Array &array);
	gaddr_t share_vec3_array(bool allow_write, const PackedVector3Array &array);
	gaddr_t share_vec4_array(bool allow_write, const PackedVector4Array &array);

	/// @brief Unshare an array of any type from the guest program.
	/// @param address The guest address of the shared memory range.
	/// @return True if the array was successfully unshared, false otherwise.
	/// @note This will not free the memory, but will remove the shared memory range from the sandbox.
	bool unshare_array(gaddr_t address);

	// -= Profiling & Hotspots =-

	/// @brief Generate the top N hotspots from profiling recorded so far.
	/// @param total The maximum number of hotspots to generate.
	/// @param callable A callback that must resolve an address of an unknown program, given elf_hint and an address as arguments.
	/// @return The top hotspots recorded globally so far, sorted by the number of hits.
	static Array get_hotspots(unsigned total = 10, const Callable &callable = {});

	/// @brief Clear all recorded hotspots.
	static void clear_hotspots();

	/// @brief Enable or disable profiling of the guest program.
	/// @param enable True to enable profiling, false to disable it.
	/// @param interval The interval in instructions between each profiling update. This interval
	/// is accumulated so that even if a function returns early, the interval is still counted.
	void enable_profiling(bool enable, uint32_t interval = 500);

	// -= Self-testing, inspection and internal functions =-

	/// @brief Get the current Callable set for redirecting stdout.
	/// @return The current Callable set for redirecting stdout.
	const Callable &get_redirect_stdout() const { return m_redirect_stdout; }

	/// @brief Set a Callable to redirect stdout from the guest program to.
	/// @param callback The callable to redirect stdout.
	void set_redirect_stdout(const Callable &callback) { m_redirect_stdout = callback; }

	/// @brief Get the 32 integer registers of the RISC-V machine.
	/// @return An array of 32 registers.
	Array get_general_registers() const;

	/// @brief Get the 32 floating-point registers of the RISC-V machine.
	/// @return An array of 32 registers.
	Array get_floating_point_registers() const;

	/// @brief Set the 8 argument registers of the RISC-V machine, A0-A7.
	/// @param args The arguments to set.
	void set_argument_registers(Array args);

	/// @brief Get the current instruction being executed, as a string.
	/// @return The current instruction.
	String get_current_instruction() const;

	/// @brief Enable resuming the program execution after a timeout.
	/// @note Must be called before the program is run. Not available for VM calls.
	void make_resumable();

	/// @brief Resume execution of the program. Loses the current call state.
	bool resume(uint64_t max_instructions);

	/// @brief Binary translate the program and produce embeddable code
	/// @param ignore_instruction_limit If true, ignore the instruction limit. Infinite loops are possible.
	/// @param automatic_nbit_as If true, use and-masking on all memory accesses based on the rounded-down Po2 arena size.
	/// @return The binary translation code.
	/// @note This is only available if the RISCV_BINARY_TRANSLATION flag is set.
	/// @warning Do *NOT* enable automatic_nbit_as unless you are sure the program is compatible with it.
	String emit_binary_translation(bool ignore_instruction_limit = false, bool automatic_nbit_as = false) const;

	/// @brief Open a shared library, which should self-register its functions.
	/// @param shared_library_path The path to the shared library.
	/// @param allow_insecure If true, allow loading shared libraries after other Sandbox instances have been created.
	/// @note This is not a general-purpose function for loading shared libraries. It is only a
	/// convenience helper function for loading shared libraries that self-register their functions.
	static bool load_binary_translation(const String &shared_library_path, bool allow_insecure = false);

	/// @brief Try to emit the binary translation code, and then compile it. Does not load the binary translation.
	/// @note For security reasons, the binary translation is not loaded automatically. A game restart is required,
	/// as binary translations can only be loaded before any Sandbox instances are created.
	/// @return True if the binary translation was emitted and compiled successfully, false otherwise.
	bool try_compile_binary_translation(String shared_library_path = "res://bintr", const String &cc = "cc", const String &extra_cflags = "", bool ignore_instruction_limit = false, bool automatic_nbit_as = false);

	/// @brief  Check if the program has found and loaded binary translation.
	/// @return True if binary translation is loaded, false otherwise.
	bool is_binary_translated() const;

	/// @brief Check if the program has a binary translation produced by a JIT compiler.
	/// @note is_binary_translated() will return true if the program has a binary translation,
	/// regardless of whether it was produced by a JIT- or a system-compiler.
	/// @return True if the program has a JIT-compiled binary translation, false otherwise.
	bool is_jit() const;

#ifdef RISCV_LIBTCC
	/// @brief Set whether to automatically use nbit-as for binary translation.
	/// @param automatic_nbit_as If true, use nbit-as for binary translation.
	/// @warning Do *NOT* enable this unless you are sure the program is compatible with it.
	void set_binary_translation_automatic_nbit_as(bool automatic_nbit_as) {
		this->m_bintr_automatic_nbit_as = automatic_nbit_as;
	}
	bool get_binary_translation_automatic_nbit_as() const {
		return this->m_bintr_automatic_nbit_as;
	}

	/// @brief Set whether to use register caching for binary translation.
	/// @param register_caching If true, use register caching for binary translation.
	void set_binary_translation_register_caching(bool register_caching) {
		this->m_bintr_register_caching = register_caching;
	}
	bool get_binary_translation_register_caching() const {
		return this->m_bintr_register_caching;
	}

	/// @brief Set whether to perform binary translation in the background.
	/// @param bg_compilation If true, perform binary translation in the background.
	void set_binary_translation_bg_compilation(bool bg_compilation) {
		this->m_bintr_bg_compilation = bg_compilation;
	}
	bool get_binary_translation_bg_compilation() const {
		return this->m_bintr_bg_compilation;
	}

	/// @brief Enable or disable the use of JIT-compilation.
	/// @param enable If true, enable JIT-compilation, false to disable it.
	static void set_jit_enabled(bool enable) { m_bintr_jit = enable; }

	/// @brief Check if JIT-compilation is enabled.
	/// @return True if JIT-compilation is enabled, false otherwise.
	static bool is_jit_enabled() { return m_bintr_jit; }
#else
	void set_binary_translation_automatic_nbit_as(bool) {}
	bool get_binary_translation_automatic_nbit_as() const { return false; }
	void set_binary_translation_register_caching(bool) {}
	bool get_binary_translation_register_caching() const { return false; }
	void set_binary_translation_bg_compilation(bool) {}
	bool get_binary_translation_bg_compilation() const { return false; }
	static void set_jit_enabled(bool) {}
	static bool is_jit_enabled() { return false; }
#endif

	static bool has_feature_jit() {
		return riscv::libtcc_enabled;
	}

	void assault(const String &test, int64_t iterations);
	Variant vmcall_internal(gaddr_t address, const Variant **args, int argc);
	machine_t &machine() { return *m_machine; }
	const machine_t &machine() const { return *m_machine; }
	void print(const Variant &v);

	/// @brief Generate the run-time API for the guest program, by iterating through all loaded classes.
	/// @param language The language to generate the API for.
	/// @param header_extra Extra header code to add to the generated API.
	/// @param use_argument_names If true, use argument names with default values in the generated API. Increases the size of the generated API and the compilation time.
	/// @return The generated API code as a string.
	static String generate_api(String language = "cpp", String header_extra = "", bool use_argument_names = false);

	/// @brief Create a MethodInfo dictionary for a public API function.
	/// @param name The name of the function.
	/// @param address The address of the function.
	/// @param description The description of the function.
	/// @param return_type The return type of the function.
	/// @param args The arguments of the function.
	/// @return The MethodInfo dictionary.
	static Dictionary create_public_api_function(std::string_view name, gaddr_t address, std::string_view description, std::string_view return_type, std::string_view args);

	/// @brief Download a named program from the Godot Sandbox programs repository.
	/// @param program_name The name of the program to download. Must be a program built in the Godot Sandbox programs repository.
	/// @return The downloaded program as a byte array.
	static PackedByteArray download_program(String program_name);

private:
	static void generate_runtime_cpp_api(bool use_argument_names = false);
	gaddr_t share_array_internal(void *data, size_t size, bool allow_write);
	bool is_in_vmcall() const noexcept { return m_current_state != &m_states[0]; }
	void constructor_initialize();
	void full_reset();
	void reset_machine();
	void set_program_data_internal(Ref<ELFScript> program);
	bool load(const PackedByteArray *vbuf, const std::vector<std::string> *argv = nullptr);
	static PackedStringArray get_public_functions(const machine_t &);
	void read_program_properties(bool editor) const;
	void handle_exception(gaddr_t);
	void handle_timeout(gaddr_t);
	void print_backtrace(gaddr_t);
	void initialize_syscalls_runtime();
	static void initialize_syscalls();
	static void initialize_syscalls_2d();
	static void initialize_syscalls_3d();
	GuestVariant *setup_arguments(gaddr_t &sp, const Variant **args, int argc);
	void setup_arguments_native(gaddr_t arrayDataPtr, GuestVariant *v, const Variant **args, int argc);

	machine_t *m_machine = nullptr;
	godot::Node *m_tree_base = nullptr;
	uint32_t m_max_refs = MAX_REFS;
	uint32_t m_memory_max = MAX_VMEM;
	int64_t m_insn_max = MAX_INSTRUCTIONS;
	uint32_t m_allocations_max = MAX_HEAP_ALLOCS;

	uint8_t m_throttled = 0;
	bool m_use_unboxed_arguments = false;
	bool m_resumable_mode = false; // If enabled, allow running startup in small increments
	bool m_precise_simulation = false; // Run simulation in the slower, precise mode
	bool m_is_initialization = false; // If true, the program is in the initialization phase
#ifdef RISCV_LIBTCC
	bool m_bintr_automatic_nbit_as = false; // Automatic n-bit address space for binary translation
	bool m_bintr_register_caching = true; // Use register caching for binary translation
	bool m_bintr_bg_compilation = true; // Perform binary translation in the background
#endif

	CurrentState *m_current_state = nullptr;
	// State stack, with the permanent (initial) state at index 0.
	// That means eg. static Variant values are held stored in the state at index 0,
	// so that they can be accessed by future VM calls, and not lost when a call ends.
	std::array<CurrentState, MAX_LEVEL> m_states;

	// Properties
	mutable std::vector<SandboxProperty> m_properties;
	mutable std::unordered_map<int64_t, LookupEntry> m_lookup;

	// Shared memory ranges
	std::vector<SharedMemoryRange> m_shared_memory_ranges;
	gaddr_t m_shared_memory_base = SHM_BASE_ADDRESS;

	// Restrictions
	std::unordered_set<godot::Object *> m_allowed_objects;
	// If an object is not in the allowed list, and a callable is set for the
	// just-in-time allowed objects, it will be called to check if the object is allowed.
	Callable m_just_in_time_allowed_objects;
	// If a class is not in the allowed list, and a callable is set for the
	// just-in-time allowed classes, it will be called to check if the class is allowed.
	Callable m_just_in_time_allowed_classes;
	// If a callable is set for the just-in-time allowed resources,
	// it will be called to check if access to a resource is allowed.
	Callable m_just_in_time_allowed_resources;
	// If a callable is set for allowed methods, it will be called when an object method
	// call is attemped, to check if the method is allowed.
	Callable m_just_in_time_allowed_methods;
	// If a callable is set for allowed properties, it will be called when an object property
	// access is attemped, to check if the property is allowed.
	Callable m_just_in_time_allowed_properties;

	// Redirections
	Callable m_redirect_stdout;

	Ref<ELFScript> m_program_data;
	PackedByteArray m_program_bytes;
	int m_source_version = -1;

	// Stats
	unsigned m_timeouts = 0;
	unsigned m_exceptions = 0;
	unsigned m_calls_made = 0;

	struct ProfilingData {
		// ELF path -> Address -> Count
		// Anonymous sandboxes are stored as ""
		std::unordered_map<std::string_view, ProfilingState> state;
	};
	static inline std::unique_ptr<ProfilingData> m_profiling_data = nullptr;
	struct LocalProfilingData {
		std::vector<gaddr_t> visited;
		uint32_t profiling_interval = 500;
		uint32_t profiler_icounter_accumulator = 0;
	};
	std::unique_ptr<LocalProfilingData> m_local_profiling_data = nullptr;
	static inline std::mutex profiling_mutex;
	static inline std::mutex generate_hotspots_mutex;

	// Global statistics
	static inline uint64_t m_global_timeouts = 0;
	static inline uint64_t m_global_exceptions = 0;
	static inline uint64_t m_global_calls_made = 0;
	static inline uint32_t m_global_instances_current = 0; // Counts the number of current instances
	static inline uint32_t m_global_instances_seen = 0; // Incremented for each instance created
	static inline double m_accumulated_startup_time = 0.0;
	static inline bool m_bintr_jit = riscv::libtcc_enabled; // JIT compilation enabled
};

inline void Sandbox::CurrentState::append(Variant &&value) {
	variants.push_back(std::move(value));
	scoped_variants.push_back(&variants.back());
}

inline void Sandbox::CurrentState::reset() {
	variants.clear();
	scoped_variants.clear();
	scoped_objects.clear();
}

inline bool Sandbox::is_allowed_object(godot::Object *obj) const {
	// If the allowed list is empty, and the allowed-object callback is not set, all objects are allowed
	if (m_allowed_objects.empty() && !m_just_in_time_allowed_objects.is_valid())
		return true;
	// Otherwise, check if the object is in the allowed list
	if (m_allowed_objects.find(obj) != m_allowed_objects.end())
		return true;

	// If the object-allowed callable is set, call it
	if (m_just_in_time_allowed_objects.is_valid())
		return m_just_in_time_allowed_objects.call(this, obj);
	return false;
}

```

`src/sandbox_bintr.cpp`:

```cpp
#include "sandbox.h"

#include <godot_cpp/classes/dir_access.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/os.hpp>
#include <godot_cpp/classes/project_settings.hpp>
#include <godot_cpp/variant/utility_functions.hpp>

#if defined(__linux__)
# include <dlfcn.h>
#elif defined(__MINGW32__) || defined(__MINGW64__) || defined(_MSC_VER)
# define YEP_IS_WINDOWS 1
# include <libriscv/win32/dlfcn.h>
# ifdef _MSC_VER
#  define access _access
#  define unlink _unlink
extern "C" int access(const char* path, int mode);
extern "C" int unlink(const char* path);
#  define R_OK   4       /* Test for read permission.  */
# else // _MSC_VER
#  include <unistd.h>
# endif
#elif defined(__APPLE__) && defined(__MACH__) // macOS OSX
# include <TargetConditionals.h>
# if TARGET_OS_MAC
#  include <dlfcn.h>
#  define YEP_IS_OSX 1
# endif
#endif
extern "C" void libriscv_register_translation8(...);

String Sandbox::emit_binary_translation(bool ignore_instruction_limit, bool automatic_nbit_as) const {
	const std::string_view &binary = machine().memory.binary();
	if (binary.empty()) {
		ERR_PRINT("Sandbox: No binary loaded.");
		return String();
	}
#ifdef RISCV_BINARY_TRANSLATION
	std::string code_output;
	// 1. Re-create the same options
	auto options = std::make_shared<riscv::MachineOptions<RISCV_ARCH>>(machine().options());
	options->use_shared_execute_segments = false;
	options->translate_enabled = false;
	options->translate_enable_embedded = false;
	options->translate_invoke_compiler = false;
	options->translate_ignore_instruction_limit = ignore_instruction_limit;
	options->translate_automatic_nbit_address_space = automatic_nbit_as;
	options->translate_use_register_caching = false;
	// Avoid any shenanigans with background compilation
	options->translate_background_callback = nullptr;
	// TODO: Make this configurable
	options->translate_instr_max = 75'000u;

	// 2. Enable binary translation output to a string
	options->cross_compile.push_back(riscv::MachineTranslationEmbeddableCodeOptions{
		.result_c99 = &code_output,
	});

	// 3. Emit the binary translation by constructing a new machine
	machine_t m{ binary, *options };

	// 4. Wait for any potential background compilation to finish
	if constexpr (riscv::libtcc_enabled) {
		m.cpu.current_execute_segment().wait_for_compilation_complete();
	}

	// 4. Verify that the translation was successful
	if (code_output.empty()) {
		ERR_PRINT("Sandbox: Binary translation failed.");
		return String();
	}
	// 5. Return the translated code
	return String::utf8(code_output.c_str(), code_output.size());
#else
	ERR_PRINT("Sandbox: Binary translation is not enabled.");
	return String();
#endif
}

bool Sandbox::load_binary_translation(const String &shared_library_path, bool allow_insecure) {
	if (m_global_instances_seen > 0 && !allow_insecure) {
		ERR_PRINT("Sandbox: Loading shared libraries after Sandbox instances have been created is a security risk."
			"Please load shared libraries before creating any Sandbox instances.");
		return false;
	}
#ifdef RISCV_BINARY_TRANSLATION
	// Load the shared library on platforms that support it
#  if defined(__linux__) || defined(YEP_IS_WINDOWS) || defined(YEP_IS_OSX)
	Ref<FileAccess> fa = FileAccess::open(shared_library_path, FileAccess::ModeFlags::READ);
	if (fa == nullptr || !fa->is_open()) {
		//ERR_PRINT("Sandbox: Failed to open shared library: " + shared_library_path);
		return false;
	}
	String path = fa->get_path_absolute();
	fa->close();
	void *handle = dlopen(path.utf8().ptr(), RTLD_LAZY);
	if (handle == nullptr) {
		ERR_PRINT("Sandbox: Failed to load shared library: " + shared_library_path);
		return false;
	}
	// If the shared library has a callback-based registration function, call it
	void *register_translation = dlsym(handle, "libriscv_init_with_callback8");
	if (register_translation != nullptr) {
		using CallbackFunction = void (*)(void(*)(...));
		((CallbackFunction)register_translation)(libriscv_register_translation8);
	}
#  else
	WARN_PRINT_ONCE("Sandbox: Loading shared libraries has not been implemented on this platform.");
#  endif
	// We don't need to do anything with the handle, as the shared library should self-register its functions
	return true;
#else
	WARN_PRINT_ONCE("Sandbox: Binary translation is not enabled.");
#endif
	return false;
}

bool Sandbox::try_compile_binary_translation(String shared_library_path, const String &cc, const String &extra_cflags, bool ignore_instruction_limit, bool automatic_nbit_as) {
	if (this->is_binary_translated() && !this->is_jit()) {
		return true;
	}
	if (this->is_in_vmcall()) {
		ERR_PRINT("Sandbox: Cannot produce binary translation while in a VM call. This is a security risk.");
		return false;
	}
	if (this->get_restrictions()) {
		ERR_PRINT("Sandbox: Cannot produce binary translation while restrictions are enabled.");
		return false;
	}
	if (shared_library_path.is_empty()) {
		ERR_PRINT("Sandbox: No shared library path specified.");
		return false;
	}
	if (!shared_library_path.begins_with("res://")) {
		ERR_PRINT("Sandbox: Shared library path must begin with 'res://'.");
		return false;
	}
	// Android, WebAssembly, Nintendo Switch, and iOS do not support direct
	// compilation of binary translations into shared libraries (on that platform).
#if defined(__ANDROID__) || defined(__wasm__) || defined(__SWITCH__) || defined(__EMSCRIPTEN__)
	ERR_PRINT("Sandbox: Directly compiling binary translation is not supported on this platform.");
	return false;
#elif defined(__APPLE__) && !defined(__MACH__) // iOS?
	// TODO: Check for iOS?
	ERR_PRINT("Sandbox: Directly compiling binary translation is not supported on this platform.");
	return false;
#endif

#ifdef __linux__
	shared_library_path += ".so";
#elif defined(YEP_IS_WINDOWS)
	shared_library_path += ".dll";
#elif defined(YEP_IS_OSX)
	shared_library_path += ".dylib";
#else
	WARN_PRINT_ONCE("Sandbox: Compiling binary translations has not been implemented on this platform.");
	return false;
#endif
	const String code = this->emit_binary_translation(ignore_instruction_limit, automatic_nbit_as);
	if (code.is_empty()) {
		ERR_PRINT("Sandbox: Failed to emit binary translation.");
		return false;
	}
	static const String c99_path = "user://temp_sandbox_generated.c";
	Ref<FileAccess> fa = FileAccess::open(c99_path, FileAccess::ModeFlags::WRITE);
	if (!fa->is_open()) {
		ERR_PRINT("Sandbox: Failed to open file for writing: " + c99_path);
		return false;
	}
	fa->store_string(code);
	fa->close();
	// Compile the generated code
	Array args;
	if (cc.ends_with("zig")) {
		// Zig cc - C compiler (faster than C++)
		args.push_back("cc");
	}
#if defined(__linux__) || defined(YEP_IS_OSX)
	args.push_back("-shared");
	args.push_back("-fPIC");
	args.push_back("-fvisibility=hidden");
	args.push_back("-O2");
	args.push_back("-w");
	args.push_back("-DCALLBACK_INIT");
	args.push_back("-o");
#elif defined(YEP_IS_WINDOWS)
	if (cc.ends_with("zig")) {
		// Zig cc - C compiler
		args.push_back("-shared");
		args.push_back("-fPIC");
		args.push_back("-fvisibility=hidden");
		args.push_back("-O2");
		args.push_back("-w");
		args.push_back("-DCALLBACK_INIT");
		args.push_back("-o");
	} else {
		args.push_back("/LD");
		args.push_back("/O2");
		args.push_back("/w");
		args.push_back("/DCALLBACK_INIT");
		args.push_back("/Fe");
	}
#endif
	args.push_back(shared_library_path.replace("res://", ""));
	if (!extra_cflags.is_empty())
		args.append_array(extra_cflags.split(" "));
	args.push_back(ProjectSettings::get_singleton()->globalize_path(c99_path));
	UtilityFunctions::print(cc, args);
	Array output;
	int ret = OS::get_singleton()->execute(cc, args, output, true);
	// Remove the generated C99 file
	Ref<DirAccess> dir = DirAccess::open("user://");
	dir->remove(c99_path);
	if (ret != 0) {
		ERR_PRINT("Sandbox: Failed to compile generated code: " + shared_library_path);
		UtilityFunctions::print(output);
		return false;
	}
	return true;
}

bool Sandbox::is_binary_translated() const {
	// Get main execute segment
	auto &main_seg = this->m_machine->memory.exec_segment_for(this->m_machine->memory.start_address());
	return main_seg->is_binary_translated();
}

bool Sandbox::is_jit() const {
#ifdef RISCV_BINARY_TRANSLATION
	auto &main_seg = this->m_machine->memory.exec_segment_for(this->m_machine->memory.start_address());
	return main_seg->is_libtcc() || main_seg->is_background_compiling();
#else
	return false;
#endif
}

```

`src/sandbox_debug.cpp`:

```cpp
#include "sandbox.h"

#include <godot_cpp/variant/utility_functions.hpp>

Array Sandbox::get_general_registers() const {
	Array ret;
	for (int i = 0; i < 32; i++) {
		ret.push_back(m_machine->cpu.reg(i));
	}
	return ret;
}

Array Sandbox::get_floating_point_registers() const {
	Array ret;
	for (int i = 0; i < 32; i++) {
		auto &freg = m_machine->cpu.registers().getfl(i);
		// We suspect that it's a 32-bit float if the upper 32 bits are zero
		if (freg.i32[1] == 0) {
			ret.push_back(freg.f32[0]);
		} else {
			ret.push_back(freg.f64);
		}
	}
	return ret;
}

void Sandbox::set_argument_registers(Array args) {
	if (args.size() > 8) {
		ERR_PRINT("set_argument_registers() can only set up to 8 arguments.");
		return;
	}
	for (int i = 0; i < args.size(); i++) {
		m_machine->cpu.reg(i + 10) = args[i].operator int64_t();
	}
}

String Sandbox::get_current_instruction() const {
	std::string instr = m_machine->cpu.current_instruction_to_string();
	return String(instr.c_str());
}

void Sandbox::make_resumable() {
	if (!m_machine->memory.binary().empty()) {
		ERR_PRINT("Sandbox: Cannot make resumable after initialization.");
		return;
	}
	this->m_resumable_mode = true;
}

bool Sandbox::resume(uint64_t max_instructions) {
	if (!this->m_resumable_mode) {
		ERR_PRINT("Sandbox: Cannot resume after initialization.");
		return false;
	}
	if (this->m_current_state != &this->m_states[0]) {
		ERR_PRINT("Sandbox: Cannot resume while in a call.");
		this->m_resumable_mode = false; // Disable resumable mode
		return false;
	}

	const gaddr_t address = m_machine->cpu.pc();
	try {
		const bool stopped = m_machine->resume(max_instructions);

		if (stopped) {
			// If the machine stopped, we are leaving resumable mode
			// It's not available for VM calls, only during startup
			this->m_resumable_mode = false;
		}

		return stopped;

	} catch (const std::exception &e) {
		this->m_resumable_mode = false;
		this->handle_exception(address);
		return true; // Can't (shouldn't) be resumed anymore
	}
}

```

`src/sandbox_exception.cpp`:

```cpp
#include "sandbox.h"

#include "cpp/script_cpp.h"
#include <charconv>
#ifdef __linux__
#include <libriscv/rsp_server.hpp>

#include <unistd.h>
static const uint16_t RSP_PORT = 2159;

static const char *getenv_with_default(const char *str, const char *defval) {
	const char *value = getenv(str);
	if (value)
		return value;
	return defval;
}
#endif

static constexpr bool VERBOSE_EXCEPTIONS = false;

static inline String to_hex(gaddr_t value) {
	char str[20] = { 0 };
	char *end = std::to_chars(std::begin(str), std::end(str), value, 16).ptr;
	return String::utf8(str, int64_t(end - str));
}

void Sandbox::handle_exception(gaddr_t address) {
	riscv::Memory<RISCV_ARCH>::Callsite callsite = machine().memory.lookup(address);
	// If the callsite is not found, try to use the cache to find the address
	if (callsite.address == 0x0) {
		callsite.address = address;
		auto it = m_lookup.find(address);
		if (it != m_lookup.end()) {
			const auto u8str = it->second.name.utf8();
			callsite = riscv::Memory<RISCV_ARCH>::Callsite{
				.name = std::string(u8str.ptr(), u8str.length()),
				.address = it->second.address,
				.offset = 0x0,
				.size = 0
			};
		}
	}
	UtilityFunctions::print(
			"[", get_name(), "] Exception when calling:\n  ", callsite.name.c_str(), " (0x",
			to_hex(callsite.address), ")\n", "Backtrace:");

	this->m_exceptions++;
	Sandbox::m_global_exceptions++;

	if (m_machine->memory.binary().empty()) {
		ERR_PRINT("No binary loaded. Remember to assign a program to the Sandbox!");
		return;
	}

	this->print_backtrace(address);

	try {
		throw; // re-throw
	} catch (const riscv::MachineTimeoutException &e) {
		this->handle_timeout(address);
		return; // NOTE: might wanna stay
	} catch (const riscv::MachineException &e) {
		const String instr(machine().cpu.current_instruction_to_string().c_str());
		const String regs(machine().cpu.registers().to_string().c_str());

		UtilityFunctions::print(
				"\nException: ", e.what(), "  (data: ", to_hex(e.data()), ")\n",
				">>> ", instr, "\n",
				">>> Machine registers:\n[PC\t", to_hex(machine().cpu.pc()),
				"] ", regs, "\n");
	} catch (const std::exception &e) {
		UtilityFunctions::print("\nMessage: ", e.what(), "\n\n");
		ERR_PRINT(("Exception: " + std::string(e.what())).c_str());
	}

	String elfpath = "";
#if defined(__linux__) || defined(__APPLE__)
	// Attempt to print the source code line using addr2line from the C++ Docker container
	// It's not unthinkable that this works for every ELF, regardless of the language
	Ref<ELFScript> script = this->get_program();
	if (!script.is_null()) {
		Array line_out;
		elfpath = get_program()->get_dockerized_program_path();
		CPPScript::DockerContainerExecute({ "/usr/api/build.sh", "--line", to_hex(address), elfpath }, line_out, false);
		if (line_out.size() > 0) {
			const String line = String(line_out[0]).replace("\n", "").replace("/usr/src/", "res://");
			UtilityFunctions::print("Exception in Sandbox calling function: ", line);
		}
		// Additional line for the current PC, if it's not the same as the call address
		if (machine().cpu.pc() != address) {
			CPPScript::DockerContainerExecute({ "/usr/api/build.sh", "--line", to_hex(machine().cpu.pc()), elfpath }, line_out, false);
			if (line_out.size() > 0) {
				const String line = String(line_out[0]).replace("\n", "").replace("/usr/src/", "res://");
				UtilityFunctions::print("Exception in Sandbox at PC: ", line);
			}
		}
	}
#endif

	if constexpr (VERBOSE_EXCEPTIONS) {
		UtilityFunctions::print(
				"Program page: ", machine().memory.get_page_info(machine().cpu.pc()).c_str());
		UtilityFunctions::print(
				"Stack page: ", machine().memory.get_page_info(machine().cpu.reg(2)).c_str());
	}

#ifdef __linux__
	if (getenv("GDB")) {
		const bool oneFrameUp = false;
		const uint16_t port = RSP_PORT;

		if (0 == fork()) {
			char scrname[64];
			strncpy(scrname, "/tmp/dbgscript-XXXXXX", sizeof(scrname));
			const int fd = mkstemp(scrname);
			if (fd < 0) {
				throw std::runtime_error("Unable to create script for debugging");
			}

			const std::string debugscript =
				// Delete the script file (after GDB closes it)
				"shell unlink " + std::string(scrname)
				+ "\n"
				// Load the original file used by the script
				"file "
				+ std::string(getenv("GDB"))
				+ "\n"
				// Connect remotely to the given port @port
				"target remote localhost:"
				+ std::to_string(port)
				+ "\n"
				// Enable the fancy TUI
				"layout next\nlayout next\n"
				// Disable pagination for the message
				"set pagination off\n"
				// Print the message given by the caller
				"echo Remote debugging session started\n"
				+ "\n"
				// Go up one step from the syscall wrapper (which can fail)
				+ std::string(oneFrameUp ? "up\n" : "");

			ssize_t len = write(fd, debugscript.c_str(), debugscript.size());
			if (len < (ssize_t)debugscript.size()) {
				throw std::runtime_error(
					"Unable to write script file for debugging");
			}
			close(fd);

			const char* argv[]
				= {getenv_with_default("GDBPATH", "/usr/bin/gdb-multiarch"), "-x",
				scrname, nullptr};
			// XXX: This is not kosher, but GDB is open-source, safe and let's not
			// pretend that anyone downloads gdb-multiarch from a website anyway.
			// There is a finite list of things we should pass to GDB to make it
			// behave well, but I haven't been able to find the right combination.
			extern char** environ;
			if (-1 == execve(argv[0], (char* const*)argv, environ)) {
				throw std::runtime_error(
					"Unable to start gdb-multiarch for debugging");
			}
		} // child

		riscv::RSP<RISCV_ARCH> server { this->machine(), port };
		auto client = server.accept();
		if (client != nullptr) {
			printf("GDB connected\n");
			// client->set_verbose(true);
			while (client->process_one())
				;
		}
	} // if getenv("GDB")
#endif
} // handle_exception()

void Sandbox::handle_timeout(gaddr_t address) {
	this->m_timeouts++;
	Sandbox::m_global_timeouts++;
	auto callsite = machine().memory.lookup(address);
	UtilityFunctions::print(
			"Sandbox: Timeout for '", callsite.name.c_str(),
			"' (Timeouts: ", m_timeouts, ")\n");
}

void Sandbox::print_backtrace(const gaddr_t addr) {
	machine().memory.print_backtrace(
			[](std::string_view line) {
				String line_str(std::string(line).c_str());
				UtilityFunctions::print("-> ", line_str);
			});
	auto origin = machine().memory.lookup(addr);
	String name(origin.name.c_str());
	UtilityFunctions::print(
			"-> [-] 0x", to_hex(origin.address), " + 0x", to_hex(origin.offset),
			": ", name);
}

```

`src/sandbox_functions.cpp`:

```cpp
#include "sandbox.h"

#include <unordered_set>

using namespace godot;
static const std::unordered_set<std::string_view> exclude_functions{
	"_Balloc",
	"_Bfree",
	"_calloc_r",
	"_cleanup_r",
	"_cleanup",
	"_close_r",
	"_close",
	"_conv_stat",
	"_dlerror_run",
	"_dlfo_process_initial",
	"_dlfo_sort_mappings.part.0",
	"_dlfo_sort_mappings",
	"_exit",
	"_Exit",
	"_fclose_r",
	"_fflush_r",
	"_findenv_r",
	"_findenv",
	"_fiprintf_r",
	"_fitoa_word",
	"_flushlbf",
	"_Fork",
	"_fprintf_r",
	"_fputc_r",
	"_fputs_r",
	"_fputwc_r",
	"_free_r",
	"_fstat_r",
	"_fstat",
	"_fwalk_reent",
	"_fwalk_sglue",
	"_fwalk",
	"_fwrite_r",
	"_getenv_r",
	"_getpid_r",
	"_getpid",
	"_i18n_number_rewrite",
	"_init_signal_r",
	"_init_signal",
	"_int_free_create_chunk",
	"_int_free_maybe_consolidate.part.0",
	"_int_free_merge_chunk",
	"_int_free",
	"_int_malloc",
	"_int_memalign",
	"_int_realloc",
	"_isatty_r",
	"_isatty",
	"_itoa_word",
	"_kill_r",
	"_kill",
	"_ldcheck",
	"_ldtoa_r",
	"_localeconv_r",
	"_longjmp_unwind",
	"_longjmp",
	"_lseek_r",
	"_lseek",
	"_malloc_r",
	"_malloc_trim_r",
	"_mbrtowc_r",
	"_mbtowc_r",
	"_mid_memalign.constprop.0",
	"_mid_memalign.isra.0",
	"_mprec_log10",
	"_pthread_cleanup_pop",
	"_pthread_cleanup_push",
	"_putc_r",
	"_putc_unlocked_r",
	"_quicksort",
	"_raise_r",
	"_read_r",
	"_read",
	"_realloc_r",
	"_reclaim_reent",
	"_res_hconf_init",
	"_res_hconf_reorder_addrs",
	"_res_hconf_trim_domain",
	"_res_hconf_trim_domains",
	"_sbrk_r",
	"_sbrk",
	"_setjmp",
	"_setlocale_r",
	"_sfread_r",
	"_signal_r",
	"_siscanf_r",
	"_sniprintf_r",
	"_sprintf_r",
	"_sscanf_r",
	"_start_c",
	"_start",
	"_strerror_r",
	"_strtod_l",
	"_strtod_r",
	"_strtodg_l",
	"_strtol_l.isra.0",
	"_strtol_r",
	"_strtold_r",
	"_strtoll_l.isra.0",
	"_strtoll_r",
	"_strtorx_l",
	"_strtoul_l.constprop.0",
	"_strtoul_l.isra.0",
	"_strtoul_r",
	"_strtoull_l.isra.0",
	"_strtoull_r",
	"_sungetc_r",
	"_svfiprintf_r",
	"_svfprintf_r",
	"_svfwprintf_r",
	"_swprintf_r",
	"_tzset_r",
	"_tzset_unlocked_r",
	"_tzset_unlocked",
	"_ungetc_r",
	"_user_strerror",
	"_vfiprintf_r",
	"_vfprintf_r",
	"_vsnprintf_r",
	"_wcrtomb_r",
	"_wcstoul_l",
	"_wcstoul_r",
	"_wctomb_r",
	"_wctype_r",
	"_write_r",
	"_write",
	"abort_message",
	"abort",
	"abs",
	"accept4",
	"acos",
	"acosf",
	"action_list_add__",
	"add_alias2.part.0",
	"add_fdes.isra.0",
	"add_fdes",
	"add_module",
	"add_name_to_object.isra.0",
	"add_path.constprop.0.isra.0",
	"add_prefixlist",
	"add_to_global_resize_failure.isra.0",
	"add_to_global_resize",
	"add_to_global_update",
	"adjust_wide_data",
	"alias_compare",
	"aligned_alloc",
	"alloc_new_heap",
	"alloc_perturb",
	"allzerop",
	"arc4random_buf",
	"arc4random",
	"arena_get_retry",
	"arena_get2",
	"arg_bool",
	"arg_trimdomain_list",
	"argz_add_sep",
	"argz_create_sep",
	"array_add__",
	"array_hash_map.ArrayHashMapUnmanaged(u64,dwarf.CommonInformationEntry,array_hash_map.AutoContext(u64),false).checkedHash__anon_8120",
	"array_hash_map.ArrayHashMapUnmanaged(u64,dwarf.CommonInformationEntry,array_hash_map.AutoContext(u64),false).getIndexAdapted__anon_6462",
	"array_hash_map.capacityIndexSize",
	"array_list.ArrayListAligned(dwarf.Abbrev,null).deinit",
	"array_list.ArrayListAligned(dwarf.Abbrev.Attr,null).deinit",
	"array_list.ArrayListAligned(dwarf.FileEntry,null).append",
	"array_list.ArrayListAligned(dwarf.FileEntry,null).deinit",
	"array_list.ArrayListAligned(dwarf.FileEntry,null).ensureTotalCapacity",
	"array_list.ArrayListAligned(dwarf.FileEntry,null).ensureUnusedCapacity",
	"array_list.ArrayListAlignedUnmanaged(dwarf.Func,null).append",
	"array_list.growCapacity",
	"asin",
	"asinf",
	"asprintf",
	"atan",
	"atan2",
	"atan2f",
	"atanf",
	"atexit",
	"base_from_object",
	"base_of_encoded_value",
	"bcmp",
	"binary_hnok",
	"bind",
	"brk",
	"bsd_signal",
	"btowc",
	"btree_allocate_node",
	"btree_destroy",
	"btree_handle_root_split.part.0",
	"btree_insert.isra.0",
	"btree_node_update_separator_after_split",
	"btree_release_tree_recursively",
	"btree_remove",
	"buffer_free",
	"buffered_vfprintf",
	"builtin.default_panic",
	"call_destructors",
	"call_dl_init",
	"call_dl_lookup",
	"call_fini",
	"call_init",
	"calloc",
	"canonicalize_file_name",
	"char_buffer_add_slow",
	"chdir",
	"check_match",
	"check_one_fd",
	"chmod",
	"chown",
	"chroot",
	"classify_object_over_fdes.constprop.0",
	"classify_object_over_fdes",
	"cleanup_glue",
	"cleanup_stdio",
	"cleanup",
	"clear_once_control",
	"clearenv",
	"clock_gettime",
	"clock_nanosleep",
	"clone",
	"clone3",
	"close_file",
	"close",
	"closedir",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).alignToByte",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).read__anon_8245",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).read__anon_8255",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).read__anon_8257",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).read__anon_8273",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).read__anon_8285",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).readF__anon_8289",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).readN__anon_8326",
	"compress.flate.bit_reader.BitReader(u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).shift",
	"compress.flate.CircularBuffer.writeMatch",
	"compress.flate.inflate.Inflate(.zlib,u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))).decodeDistance",
	"compress.zlib.decompressor__anon_5691",
	"conf_decrement.part.0",
	"connect",
	"context_reuse",
	"context_send_common",
	"convert_hostent_to_gaih_addrtuple",
	"copysignl",
	"cos",
	"cosf",
	"cosf32",
	"create_thread",
	"d_abi_tags",
	"d_add_substitution",
	"d_append_buffer",
	"d_append_char",
	"d_append_num",
	"d_append_string",
	"d_args_length",
	"d_array_type",
	"d_backtrack",
	"d_bare_function_type",
	"d_call_offset",
	"d_checkpoint",
	"d_class_enum_type",
	"d_clone_suffix",
	"d_compact_number",
	"d_count_templates_scopes",
	"d_ctor_dtor_name",
	"d_cv_qualifiers",
	"d_demangle_callback.constprop.0",
	"d_demangle_callback",
	"d_demangle",
	"d_discriminator",
	"d_encoding.part.0",
	"d_encoding",
	"d_expr_primary",
	"d_expression_1",
	"d_expression",
	"d_exprlist",
	"d_fill_ctor",
	"d_fill_dtor",
	"d_fill_extended_operator",
	"d_fill_name",
	"d_find_pack",
	"d_function_type",
	"d_get_saved_scope",
	"d_growable_string_append_buffer",
	"d_growable_string_callback_adapter",
	"d_growable_string_init",
	"d_growable_string_resize",
	"d_identifier",
	"d_index_template_argument.part.0",
	"d_index_template_argument",
	"d_init_info",
	"d_java_resource",
	"d_lambda",
	"d_last_char",
	"d_local_name",
	"d_lookup_template_argument",
	"d_make_builtin_type",
	"d_make_character",
	"d_make_comp",
	"d_make_ctor",
	"d_make_default_arg",
	"d_make_demangle_mangled_name",
	"d_make_dtor",
	"d_make_empty",
	"d_make_extended_builtin_type",
	"d_make_extended_operator",
	"d_make_function_param",
	"d_make_name",
	"d_make_operator",
	"d_make_sub",
	"d_make_template_param",
	"d_mangled_name",
	"d_maybe_constraints",
	"d_maybe_module_name",
	"d_maybe_print_designated_init",
	"d_maybe_print_fold_expression",
	"d_name",
	"d_nested_name",
	"d_number_component",
	"d_number",
	"d_operator_name",
	"d_pack_length",
	"d_parmlist",
	"d_pointer_to_member_type",
	"d_prefix",
	"d_print_array_type",
	"d_print_callback",
	"d_print_cast",
	"d_print_comp_inner",
	"d_print_comp",
	"d_print_conversion",
	"d_print_error",
	"d_print_expr_op",
	"d_print_flush",
	"d_print_function_type",
	"d_print_init",
	"d_print_java_identifier",
	"d_print_lambda_parm_name",
	"d_print_mod_list",
	"d_print_mod",
	"d_print_saw_error",
	"d_print_subexpr",
	"d_print",
	"d_ref_qualifier",
	"d_save_scope",
	"d_source_name",
	"d_special_name",
	"d_substitution",
	"d_template_arg",
	"d_template_args_1",
	"d_template_args",
	"d_template_head",
	"d_template_param",
	"d_template_parm",
	"d_type",
	"d_unnamed_type",
	"d_unqualified_name",
	"d_unresolved_name",
	"d_vector_type",
	"dcgettext",
	"debug.DebugInfo.lookupModuleDl__struct_5094.callback",
	"debug.DebugInfo.lookupModuleNameDl__struct_8137.callback",
	"debug.panic__anon_3459",
	"debug.panicExtra__anon_3473",
	"debug.panicImpl",
	"debug.printLineInfo__anon_6571",
	"debug.printSourceAtAddress__anon_4391",
	"debug.printUnknownSource__anon_6467",
	"debug.readElfDebugInfo",
	"debug.StackIterator.next_internal",
	"decide_maybe_mmap",
	"decompose_rpath",
	"decrement_at_index.part.0",
	"decrement",
	"deregister_tm_clones",
	"derivation_compare",
	"detach_arena.part.0",
	"dfs_traversal.part.0",
	"dirfd",
	"dl_iterate_phdr",
	"dl_open_worker_begin",
	"dl_open_worker",
	"dladdr",
	"dladdr1",
	"dlclose",
	"dlerror_run",
	"dlerror",
	"dlinfo_doit",
	"dlinfo",
	"dlmopen_doit",
	"dlmopen",
	"dlopen_doit",
	"dlopen",
	"dlsym_doit",
	"dlsym",
	"dlvsym_doit",
	"dlvsym",
	"dn_expand",
	"dn_skipname",
	"do_dlclose",
	"do_dlopen",
	"do_dlsym_private",
	"do_dlsym",
	"do_dlvsym",
	"do_init",
	"do_lookup_x",
	"do_read",
	"do_release_all",
	"do_release_shlib",
	"do_swap",
	"do_sym",
	"do_tunable_update_val",
	"dup2",
	"dwarf.Abbrev.deinit",
	"dwarf.Die.getAttr",
	"dwarf.Die.getAttrAddr",
	"dwarf.Die.getAttrRef",
	"dwarf.Die.getAttrString",
	"dwarf.DwarfInfo.DebugRangeIterator.init",
	"dwarf.DwarfInfo.DebugRangeIterator.next",
	"dwarf.DwarfInfo.getAbbrevTable",
	"dwarf.DwarfInfo.getLineString",
	"dwarf.DwarfInfo.getString",
	"dwarf.DwarfInfo.parseDie",
	"dwarf.DwarfInfo.readDebugAddr",
	"dwarf.DwarfInfo.section",
	"dwarf.DwarfInfo.sectionVirtualOffset",
	"dwarf.FixedBufferReader.readAddress",
	"dwarf.FixedBufferReader.readBytes",
	"dwarf.FixedBufferReader.readBytesTo__anon_6531",
	"dwarf.FixedBufferReader.readIleb128__anon_6026",
	"dwarf.FixedBufferReader.readInt__anon_5852",
	"dwarf.FixedBufferReader.readInt__anon_5853",
	"dwarf.FixedBufferReader.readInt__anon_5855",
	"dwarf.FixedBufferReader.readInt__anon_5856",
	"dwarf.FixedBufferReader.readInt__anon_6341",
	"dwarf.FixedBufferReader.readInt__anon_7985",
	"dwarf.FixedBufferReader.readUleb128__anon_5974",
	"dwarf.FixedBufferReader.readUleb128__anon_6340",
	"dwarf.FixedBufferReader.readUleb128__anon_6439",
	"dwarf.FixedBufferReader.readUleb128__anon_6441",
	"dwarf.FixedBufferReader.readUleb128__anon_6533",
	"dwarf.FormValue.getString",
	"dwarf.FormValue.getUInt__anon_6322",
	"dwarf.FormValue.getUInt__anon_6543",
	"dwarf.getStringGeneric",
	"dwarf.LineNumberProgram.checkLineMatch",
	"dwarf.openDwarfDebugInfo",
	"dwarf.parseFormValue",
	"dwarf.pcRelBase",
	"dwarf.readEhPointer",
	"dwarf.readUnitHeader",
	"dynamic_library.linkmap_iterator",
	"e113toe.isra.0",
	"ecmp",
	"ediv",
	"eiremain",
	"elf_machine_matches_host",
	"emdnorm",
	"emovi",
	"emovo.constprop.0",
	"emul",
	"enlarge_userbuf",
	"enormlz",
	"epoll_create1",
	"epoll_ctl",
	"epoll_pwait",
	"epoll_wait",
	"eshdn1",
	"eshift.part.0",
	"eshup1",
	"eventfd",
	"execute_cfa_program_generic",
	"execute_cfa_program_specialized",
	"execute_cfa_program",
	"execute_stack_op",
	"execve",
	"execvp",
	"execvpe",
	"exit",
	"expand_dynamic_string_token",
	"fabsl",
	"faccessat",
	"fast_exit",
	"fatal_error",
	"fchdir",
	"fchmod",
	"fchown",
	"fclose",
	"fcntl",
	"fcntl64",
	"fdatasync",
	"fde_mixed_encoding_compare",
	"fde_mixed_encoding_extract",
	"fde_radixsort",
	"fde_single_encoding_compare",
	"fde_single_encoding_extract",
	"fde_unencoded_compare",
	"fde_unencoded_extract",
	"fdopendir",
	"fflush",
	"fgetgrent_r",
	"fgetpos",
	"fgetpos64",
	"fgetpwent_r",
	"fgets_unlocked",
	"fileno_unlocked",
	"fileno",
	"fillin_rpath.isra.0",
	"find_derivation",
	"find_module_idx",
	"find_module.constprop.0",
	"fiprintf",
	"flockfile",
	"floor",
	"floorf32x",
	"floorf64",
	"flush_cleanup",
	"fmin",
	"fminf32x",
	"fminf64",
	"fmod",
	"fmodl",
	"fmt.formatBuf__anon_3840",
	"fmt.formatType__anon_7951",
	"fmt.formatType__anon_8140",
	"fopen",
	"fopen64",
	"fork",
	"fprintf",
	"fputc",
	"fputs",
	"fputwc",
	"frame_downheap",
	"frame_dummy",
	"frame_heapsort",
	"free_category",
	"free_derivation",
	"free_mem",
	"free_modules_db",
	"free_slotinfo",
	"free",
	"freeaddrinfo",
	"freeifaddrs",
	"frexp",
	"frexpl",
	"fs.Dir.openFile",
	"fs.Dir.openFileZ",
	"fs.File.read",
	"fs.File.write",
	"fs.path.join",
	"fseek",
	"fseeko",
	"fseeko64",
	"fsetpos",
	"fsetpos64",
	"fstat",
	"fstat64",
	"fstatat",
	"fstatat64",
	"fsync",
	"ftello",
	"ftello64",
	"ftruncate",
	"ftruncate64",
	"functions_allocate",
	"functions_deallocate",
	"funlockfile",
	"futimens",
	"fwide",
	"fwrite",
	"gai_strerror",
	"gaiconf_init",
	"gaih_getanswer_slice.isra.0",
	"gaih_inet_serv",
	"gconv_parse_code",
	"gen_negf",
	"get_avphys_pages",
	"get_cie_encoding",
	"get_fde_encoding",
	"get_locked_global",
	"get_next_alias",
	"get_nproc_stat",
	"get_nprocs_conf",
	"get_nprocs_cpu_online",
	"get_nprocs",
	"get_pc_range",
	"get_phys_pages",
	"get_scope",
	"getaddrinfo",
	"getanswer_r_store_alias",
	"getanswer_r.constprop.0",
	"getanswer_r",
	"getauxval",
	"getcwd",
	"getdelim",
	"getdents64",
	"getdtablesize",
	"getegid",
	"getentropy",
	"getenv",
	"geteuid",
	"getgid",
	"getgroups",
	"gethostbyname2_r",
	"gethostbyname3_context",
	"gethostbyname3_multi",
	"gethostname",
	"gethosts",
	"getifaddrs_internal",
	"getifaddrs",
	"getline",
	"getpagesize",
	"getpeername",
	"getpgid",
	"getpid",
	"getppid",
	"getpwuid_r",
	"getrlimit",
	"getrlimit64",
	"getservbyname_r",
	"getsockname",
	"getsockopt",
	"gettext",
	"getuid",
	"global_state_allocate",
	"global_stdio_init.part.0",
	"gnu_get_libc_release",
	"gnu_get_libc_version",
	"group_member",
	"group_number",
	"gsignal",
	"hack_digit",
	"has_return_type",
	"hash_map.getAutoHashFn__struct_7613.hash",
	"hash_map.HashMapUnmanaged(usize,*debug.ModuleDebugInfo__struct_4192,hash_map.AutoContext(usize),80).putAssumeCapacityNoClobberContext",
	"hash.wyhash.Wyhash.hash",
	"heap.arena_allocator.ArenaAllocator.alloc",
	"heap.arena_allocator.ArenaAllocator.createNode",
	"heap.arena_allocator.ArenaAllocator.free",
	"heap.arena_allocator.ArenaAllocator.resize",
	"heap.PageAllocator.alloc",
	"heap.PageAllocator.free",
	"heap.PageAllocator.resize",
	"hexfloat",
	"if_freenameindex",
	"if_indextoname",
	"if_nameindex",
	"if_nametoindex",
	"in6aicmp",
	"increment",
	"index",
	"indirect_msort_with_tmp",
	"inet_addr",
	"inet_aton_end",
	"inet_aton",
	"inet_makeaddr",
	"inet_network",
	"inet_pton",
	"inet_pton4",
	"inet_pton6",
	"init_dwarf_reg_size_table",
	"insert_module",
	"int_mallinfo",
	"internal_getent",
	"io.buffered_writer.BufferedWriter(4096,io.GenericWriter(fs.File,error{DiskQuota,FileTooBig,InputOutput,NoSpaceLeft,DeviceBusy,InvalidArgument,AccessDenied,BrokenPipe,SystemResources,OperationAborted,NotOpenForWriting,LockViolation,WouldBlock,ConnectionResetByPeer,Unexpected},(function 'write'))).flush",
	"io.GenericReader(*compress.flate.inflate.Inflate(.zlib,u32,io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read'))),error{EndOfStream,BadGzipHeader,BadZlibHeader,WrongGzipChecksum,WrongGzipSize,WrongZlibChecksum,InvalidCode,OversubscribedHuffmanTree,IncompleteHuffmanTree,MissingEndOfBlockCode,InvalidMatch,InvalidBlockType,WrongStoredBlockNlen,InvalidDynamicBlockHeader},(function 'read')).typeErasedReadFn",
	"io.GenericReader(*io.fixed_buffer_stream.FixedBufferStream([]const u8),error{},(function 'read')).typeErasedReadFn",
	"io.GenericWriter(*io.buffered_writer.BufferedWriter(4096,io.GenericWriter(fs.File,error{DiskQuota,FileTooBig,InputOutput,NoSpaceLeft,DeviceBusy,InvalidArgument,AccessDenied,BrokenPipe,SystemResources,OperationAborted,NotOpenForWriting,LockViolation,WouldBlock,ConnectionResetByPeer,Unexpected},(function 'write'))),error{DiskQuota,FileTooBig,InputOutput,NoSpaceLeft,DeviceBusy,InvalidArgument,AccessDenied,BrokenPipe,SystemResources,OperationAborted,NotOpenForWriting,LockViolation,WouldBlock,ConnectionResetByPeer,Unexpected},(function 'write')).typeErasedWriteFn",
	"io.GenericWriter(*io.fixed_buffer_stream.FixedBufferStream([]u8),error{NoSpaceLeft},(function 'write')).typeErasedWriteFn",
	"io.GenericWriter(fs.File,error{DiskQuota,FileTooBig,InputOutput,NoSpaceLeft,DeviceBusy,InvalidArgument,AccessDenied,BrokenPipe,SystemResources,OperationAborted,NotOpenForWriting,LockViolation,WouldBlock,ConnectionResetByPeer,Unexpected},(function 'write')).typeErasedWriteFn",
	"io.Reader.readAll",
	"io.Reader.readNoEof",
	"io.tty.Config.setColor__anon_7444",
	"io.Writer.writeAll",
	"io.Writer.writeBytesNTimes",
	"ioctl",
	"is_ctor_dtor_or_conversion",
	"is_designated_init",
	"is_dst",
	"is_fnqual_component_type",
	"is_trusted_path_normalize",
	"isatty",
	"iso_year_adjust.isra.0",
	"iswalnum_l",
	"iswalnum",
	"iswalpha_l",
	"iswalpha",
	"iswblank_l",
	"iswblank",
	"iswcntrl_l",
	"iswcntrl",
	"iswctype",
	"iswdigit",
	"iswgraph_l",
	"iswgraph",
	"iswlower_l",
	"iswlower",
	"iswprint_l",
	"iswprint",
	"iswpunct_l",
	"iswpunct",
	"iswspace_l",
	"iswspace",
	"iswupper_l",
	"iswupper",
	"iswxdigit",
	"kill",
	"known_compare",
	"labs",
	"lchown",
	"length_mismatch",
	"libc_exit_fini",
	"libc_start_init",
	"libc_start_main_stage2",
	"linear_search_fdes",
	"linkat",
	"listen",
	"localeconv",
	"localtime",
	"locked_vfxprintf",
	"locking_putc",
	"longjmp",
	"lseek",
	"lseek64",
	"lstat",
	"lstat64",
	"m16m",
	"madvise",
	"main",
	"mallinfo",
	"mallinfo2",
	"malloc_consolidate",
	"malloc_info",
	"malloc_printerr",
	"malloc_stats",
	"malloc_trim",
	"malloc_usable_size",
	"malloc",
	"mallopt",
	"match_prefix",
	"maybe_init",
	"maybe_script_execute",
	"maybe_split_for_insert.isra.0",
	"mbrlen",
	"mbrtowc",
	"mbsrtowcs",
	"mbstowcs",
	"mbtowc",
	"mem.Allocator.alignedAlloc__anon_6448",
	"mem.Allocator.alignedAlloc__anon_7981",
	"mem.Allocator.alignedAlloc__anon_7983",
	"mem.Allocator.alloc__anon_5692",
	"mem.Allocator.alloc__anon_6121",
	"mem.Allocator.allocBytesWithAlignment__anon_7926",
	"mem.Allocator.allocWithSizeAndAlignment__anon_7984",
	"mem.Allocator.allocWithSizeAndAlignment__anon_8110",
	"mem.Allocator.allocWithSizeAndAlignment__anon_8112",
	"mem.Allocator.destroy__anon_6398",
	"mem.Allocator.free__anon_5398",
	"mem.Allocator.free__anon_5836",
	"mem.Allocator.free__anon_6123",
	"mem.Allocator.free__anon_6449",
	"mem.Allocator.free__anon_7977",
	"mem.Allocator.free__anon_7978",
	"mem.Allocator.free__anon_8044",
	"mem.Allocator.resize__anon_7980",
	"mem.Allocator.resize__anon_7982",
	"mem.eql__anon_5097",
	"mem.indexOfScalar__anon_7449",
	"mem.indexOfScalarPos__anon_6542",
	"mem.indexOfSentinel__anon_8101",
	"mem.replaceScalar__anon_7450",
	"mem.sliceTo__anon_5096",
	"mem.sliceTo__anon_5399",
	"memalign",
	"memchr",
	"memcmp",
	"memcpy",
	"memmem",
	"memmove",
	"memrchr",
	"memset",
	"mkdir",
	"mktime",
	"mmap_remap_check",
	"mmap",
	"mmap64",
	"module_load_builtin",
	"module_load",
	"mprotect",
	"mremap",
	"msort_with_tmp.part.0",
	"multi_array_list.MultiArrayList(array_hash_map.ArrayHashMapUnmanaged(u64,dwarf.CommonInformationEntry,array_hash_map.AutoContext(u64),false).Data).ensureTotalCapacity",
	"multi_array_list.MultiArrayList(array_hash_map.ArrayHashMapUnmanaged(u64,dwarf.CommonInformationEntry,array_hash_map.AutoContext(u64),false).Data).slice",
	"munmap_chunk",
	"munmap",
	"name_to_database_index",
	"nameserver_list_emplace",
	"nan",
	"nanf",
	"nanosleep",
	"new_composite_name",
	"new_do_write",
	"new_heap",
	"next_is_type_qual.isra.0",
	"next_is_type_qual",
	"next_line",
	"ns_name_compress",
	"ns_name_ntop",
	"ns_name_pack",
	"ns_name_pton",
	"ns_name_skip",
	"ns_name_uncompress",
	"ns_name_unpack",
	"nscd_gethst_r",
	"nscd_getpw_r",
	"nscd_getserv_r",
	"nss_database_check_reload_and_get",
	"nss_files_global_allocate",
	"op_is_new_cast.isra.0",
	"op_is_new_cast",
	"open_path.isra.0",
	"open_socket",
	"open_verify.constprop.0",
	"open",
	"open64",
	"openat",
	"openat64",
	"openaux",
	"opendir_tail",
	"opendir",
	"os.linux.riscv64.restore_rt",
	"OUTLINED_FUNCTION_0",
	"OUTLINED_FUNCTION_1",
	"OUTLINED_FUNCTION_10",
	"OUTLINED_FUNCTION_11",
	"OUTLINED_FUNCTION_12",
	"OUTLINED_FUNCTION_13",
	"OUTLINED_FUNCTION_14",
	"OUTLINED_FUNCTION_15",
	"OUTLINED_FUNCTION_16",
	"OUTLINED_FUNCTION_17",
	"OUTLINED_FUNCTION_18",
	"OUTLINED_FUNCTION_19",
	"OUTLINED_FUNCTION_2",
	"OUTLINED_FUNCTION_20",
	"OUTLINED_FUNCTION_21",
	"OUTLINED_FUNCTION_22",
	"OUTLINED_FUNCTION_23",
	"OUTLINED_FUNCTION_24",
	"OUTLINED_FUNCTION_25",
	"OUTLINED_FUNCTION_26",
	"OUTLINED_FUNCTION_27",
	"OUTLINED_FUNCTION_28",
	"OUTLINED_FUNCTION_29",
	"OUTLINED_FUNCTION_3",
	"OUTLINED_FUNCTION_30",
	"OUTLINED_FUNCTION_31",
	"OUTLINED_FUNCTION_32",
	"OUTLINED_FUNCTION_33",
	"OUTLINED_FUNCTION_34",
	"OUTLINED_FUNCTION_35",
	"OUTLINED_FUNCTION_36",
	"OUTLINED_FUNCTION_37",
	"OUTLINED_FUNCTION_38",
	"OUTLINED_FUNCTION_39",
	"OUTLINED_FUNCTION_4",
	"OUTLINED_FUNCTION_40",
	"OUTLINED_FUNCTION_41",
	"OUTLINED_FUNCTION_42",
	"OUTLINED_FUNCTION_43",
	"OUTLINED_FUNCTION_44",
	"OUTLINED_FUNCTION_45",
	"OUTLINED_FUNCTION_46",
	"OUTLINED_FUNCTION_47",
	"OUTLINED_FUNCTION_48",
	"OUTLINED_FUNCTION_49",
	"OUTLINED_FUNCTION_5",
	"OUTLINED_FUNCTION_50",
	"OUTLINED_FUNCTION_51",
	"OUTLINED_FUNCTION_52",
	"OUTLINED_FUNCTION_53",
	"OUTLINED_FUNCTION_6",
	"OUTLINED_FUNCTION_7",
	"OUTLINED_FUNCTION_8",
	"OUTLINED_FUNCTION_9",
	"outstring_converted_wide_string",
	"outstring_func.part.0",
	"pad",
	"parse_tunables",
	"pause",
	"pipe2",
	"plural_eval",
	"poll",
	"pop_arg",
	"posix_memalign",
	"posix_spawn_file_actions_adddup2",
	"posix_spawn_file_actions_destroy",
	"posix_spawn_file_actions_init",
	"posix_spawnattr_destroy",
	"posix_spawnattr_init",
	"posix_spawnattr_setflags",
	"posix_spawnattr_setpgroup",
	"posix_spawnattr_setsigdefault",
	"posix_spawnp",
	"posix.abort",
	"posix.getenv",
	"posix.mmap",
	"posix.raise",
	"posix.realpath",
	"posix.sigaction",
	"pow",
	"powf",
	"powf32",
	"ppoll",
	"prctl",
	"pread",
	"pread64",
	"preadv",
	"preadv64",
	"prefixcmp",
	"printf_core",
	"printf_positional",
	"process.getBaseAddress",
	"profil",
	"pthread_testcancel",
	"ptmalloc_init.part.0",
	"ptrlist_add__",
	"putc_unlocked",
	"putc",
	"putchar",
	"pvalloc",
	"pwrite",
	"pwrite64",
	"pwritev",
	"pwritev64",
	"qsort_r",
	"qsort",
	"raise",
	"rand",
	"rawmemchr",
	"read_alias_file",
	"read_conf_file.isra.0",
	"read_encoded_value_with_base",
	"read_encoded_value",
	"read_int",
	"read_sleb128",
	"read_sysfs_file",
	"read_uleb128",
	"read",
	"readdir",
	"readdir64",
	"readlink",
	"readlinkat",
	"readv",
	"realloc",
	"realpath",
	"recv",
	"recvfrom",
	"recvmsg",
	"register_fini",
	"register_printf_function",
	"register_printf_modifier",
	"register_printf_specifier",
	"register_printf_type",
	"register_tm_clones",
	"release_registered_frames",
	"remove_slotinfo",
	"rename",
	"reopen",
	"res_dnok",
	"res_hnok",
	"res_mailok",
	"res_mkquery",
	"res_nmkquery",
	"res_nquery",
	"res_nquerydomain",
	"res_nsearch",
	"res_nsend",
	"res_ownok",
	"res_query",
	"res_querydomain",
	"res_search",
	"res_send",
	"res_setoptions",
	"resolv_conf_matches",
	"rewind",
	"rewinddir",
	"rfc3484_sort",
	"rindex",
	"rmdir",
	"round_and_return",
	"round_away",
	"rshift",
	"rust_begin_unwind",
	"rust_eh_personality",
	"rust_panic",
	"rvOK.constprop.0",
	"same_address",
	"save_for_backup",
	"save_for_wbackup",
	"sbrk",
	"scalbn",
	"scalbnl",
	"scanexp",
	"sccp",
	"sched_get_priority_max",
	"sched_get_priority_min",
	"sched_getaffinity",
	"sched_getparam",
	"sched_getscheduler",
	"sched_setparam",
	"sched_setscheduler",
	"sched_yield",
	"scopecmp",
	"search_cache",
	"search_list_add__",
	"search_object",
	"secure_getenv",
	"send_dg",
	"send_vc",
	"send",
	"sendfile",
	"sendfile64",
	"sendmmsg",
	"sendmsg",
	"sendto",
	"set_ones",
	"setenv",
	"setgid",
	"setgroups",
	"setitimer",
	"setjmp",
	"setlocale",
	"setpgid",
	"setsid",
	"setsockopt",
	"setuid",
	"setxid_error",
	"setxid_mark_thread.isra.0",
	"setxid_signal_thread",
	"setxid_unmark_thread.isra.0",
	"sgetsgent_r",
	"sgetspent_r",
	"shutdown",
	"sigaction",
	"sigaddset",
	"sigaltstack",
	"sigcancel_handler",
	"sigemptyset",
	"siglongjmp",
	"signal",
	"sigprocmask",
	"sin",
	"sincosf",
	"sincosf32",
	"sinf",
	"sinf32",
	"siscanf",
	"size_of_encoded_value",
	"sn_write",
	"sniprintf",
	"snprintf",
	"sock_eq",
	"socket",
	"socketpair",
	"sort.heap__anon_8281.Context.lessThan",
	"sort.heap__anon_8281",
	"sort.pdq.sort3__anon_8431",
	"sort.siftDown__anon_8429",
	"sort.siftDown__anon_8502",
	"splice",
	"sprintf",
	"sqrtf",
	"sscanf",
	"ssignal",
	"start_thread",
	"start.noopSigHandler",
	"start.posixCallMainAndExit",
	"stat",
	"stat64",
	"static_dl_iterate_phdr",
	"static_init_tls",
	"stdio_exit_handler",
	"stpcpy",
	"str_to_mpn.part.0.constprop.0",
	"strcasecmp_l",
	"strcasecmp",
	"strchr",
	"strchrnul",
	"strcmp",
	"strcoll",
	"strcpy",
	"strcspn",
	"strdup",
	"strerror_l",
	"strerror_r",
	"strerror",
	"strftime_l",
	"strftime",
	"strip_whitespace",
	"strlen",
	"strncasecmp_l",
	"strncasecmp",
	"strncmp",
	"strncpy",
	"strndup",
	"strnlen",
	"strpbrk",
	"strrchr",
	"strsep",
	"strspn",
	"strstr",
	"strtod_l",
	"strtod",
	"strtof_l",
	"strtof",
	"strtof128_l",
	"strtof128",
	"strtof32_l",
	"strtof32",
	"strtof32x_l",
	"strtof32x",
	"strtof64_l",
	"strtof64",
	"strtof64x_l",
	"strtof64x",
	"strtoimax",
	"strtok_r",
	"strtol_l",
	"strtol",
	"strtold_l",
	"strtold",
	"strtoll_l",
	"strtoll",
	"strtoq",
	"strtoul_l",
	"strtoul",
	"strtoull_l",
	"strtoull",
	"strtoumax",
	"strtouq",
	"strtox",
	"strxfrm",
	"stub_dladdr",
	"sulp",
	"sw_write",
	"swprintf",
	"symlink",
	"syscall",
	"sysconf",
	"sysinfo",
	"sysmalloc_mmap_fallback.constprop.0",
	"sysmalloc_mmap.constprop.0",
	"sysmalloc_mmap.isra.0",
	"sysmalloc",
	"systrim.constprop.0",
	"tan",
	"tanf",
	"tcache_init.part.0",
	"tcgetattr",
	"tcsetpgrp",
	"tdelete",
	"tdestroy_recurse",
	"tdestroy",
	"tfind",
	"Thread.Mutex.lock",
	"Thread.Mutex.unlock",
	"towctrans",
	"towlower",
	"towupper",
	"transcmp",
	"trecurse_r",
	"trecurse",
	"tsearch",
	"tunable_initialize",
	"twalk_r",
	"twalk",
	"two_way_long_needle",
	"tzset",
	"ULtox",
	"uname",
	"ungetc",
	"unlink_chunk.constprop.0",
	"unlink_chunk.isra.0",
	"unlink",
	"unlinkat",
	"unsetenv",
	"unwind_cleanup",
	"unwind_phase2_forced",
	"unwind_phase2",
	"unwind_stop",
	"utimensat",
	"uw_frame_state_for",
	"uw_init_context_1",
	"uw_install_context_1",
	"uw_update_context_1",
	"uw_update_context",
	"valloc",
	"vasprintf",
	"version_lock_lock_exclusive",
	"version_lock_unlock_exclusive",
	"vfiprintf",
	"vfprintf",
	"vfwprintf",
	"vsnprintf",
	"vsprintf",
	"vswprintf",
	"wait_on_socket",
	"wait4",
	"waitid",
	"waitpid",
	"wcrtomb",
	"wcschr",
	"wcschrnul",
	"wcscmp",
	"wcscoll",
	"wcscpy",
	"wcsftime_l",
	"wcsftime",
	"wcslcpy",
	"wcslen",
	"wcsnlen",
	"wcsrtombs",
	"wcstod",
	"wcstof",
	"wcstol",
	"wcstold",
	"wcstoll",
	"wcstoul_l",
	"wcstoul",
	"wcstoull",
	"wcstox",
	"wcsxfrm",
	"wctob",
	"wctomb",
	"wctrans",
	"wctype",
	"wcvt",
	"with_errnof",
	"wmemchr",
	"wmemcmp",
	"wmemcpy",
	"wmemmove",
	"wmempcpy",
	"wmemset",
	"wprintf_core",
	"write",
	"writev",
	"xflowf",
};

static bool is_excluded_function(const std::string_view function) {
	// API syscall wrappers: "sys_"
	if (function.size() >= 4 && function[0] == 's' && function[1] == 'y' && function[2] == 's' && function[3] == '_') {
		return true;
	}
	// Special cases for C/C++ runtime functions.
	// Begins with "_GLOBAL_"
	if (function.size() >= 8 && function[0] == '_' && function[1] == 'G' && function[2] == 'L' && function[3] == 'O' && function[4] == 'B' && function[5] == 'A' && function[6] == 'L' && function[7] == '_') {
		return true;
	}
	// Begins with "_IO_"
	if (function.size() >= 4 && function[0] == '_' && function[1] == 'I' && function[2] == 'O' && function[3] == '_') {
		return true;
	}
	// Begins with "_Unwind_"
	if (function.size() >= 8 && function[0] == '_' && function[1] == 'U' && function[2] == 'n' && function[3] == 'w' && function[4] == 'i' && function[5] == 'n' && function[6] == 'd' && function[7] == '_') {
		return true;
	}
	// Begins with "_dl_"
	if (function.size() >= 4 && function[0] == '_' && function[1] == 'd' && function[2] == 'l' && function[3] == '_') {
		return true;
	}
	// Begins with "_nl_"
	if (function.size() >= 4 && function[0] == '_' && function[1] == 'n' && function[2] == 'l' && function[3] == '_') {
		return true;
	}
	// Begins with "_nss_"
	if (function.size() >= 5 && function[0] == '_' && function[1] == 'n' && function[2] == 's' && function[3] == 's' && function[4] == '_') {
		return true;
	}
	// Begins with "pthread_"
	if (function.size() >= 8 && std::memcmp(function.data(), "pthread_", 8) == 0) {
		return true;
	}

	return false;
}

static Variant::Type convert_guest_type_to_variant(const String &type) {
	if (type == "void") {
		return Variant::NIL;
	} else if (type == "bool") {
		return Variant::BOOL;
	} else if (type == "int" || type == "int32_t" || type == "int64_t" || type == "uint32_t" || type == "uint64_t" || type == "long" || type == "unsigned") {
		return Variant::INT;
	} else if (type == "float" || type == "double") {
		return Variant::FLOAT;
	} else if (type == "String" || type == "StringName") {
		return Variant::STRING;
	} else if (type == "Vector2") {
		return Variant::VECTOR2;
	} else if (type == "Vector3") {
		return Variant::VECTOR3;
	} else if (type == "Vector4") {
		return Variant::VECTOR4;
	} else if (type == "Vector2i") {
		return Variant::VECTOR2I;
	} else if (type == "Vector3i") {
		return Variant::VECTOR3I;
	} else if (type == "Vector4i") {
		return Variant::VECTOR4I;
	} else if (type == "Rect2") {
		return Variant::RECT2;
	} else if (type == "Rect2i") {
		return Variant::RECT2I;
	} else if (type == "Transform2D") {
		return Variant::TRANSFORM2D;
	} else if (type == "Plane") {
		return Variant::PLANE;
	} else if (type == "Quaternion") {
		return Variant::QUATERNION;
	} else if (type == "AABB") {
		return Variant::AABB;
	} else if (type == "Basis") {
		return Variant::BASIS;
	} else if (type == "Transform3D") {
		return Variant::TRANSFORM3D;
	} else if (type == "Color") {
		return Variant::COLOR;
	} else if (type == "NodePath") {
		return Variant::NODE_PATH;
	} else if (type == "RID") {
		return Variant::RID;
	} else if (type == "Object" || type == "Node" || type == "Node2D" || type == "Node3D") {
		return Variant::OBJECT;
	} else if (type == "Dictionary") {
		return Variant::DICTIONARY;
	} else if (type == "Array") {
		return Variant::ARRAY;
	} else if (type == "Callable") {
		return Variant::CALLABLE;
	} else if (type == "Signal") {
		return Variant::SIGNAL;
	} else if (type == "PackedByteArray") {
		return Variant::PACKED_BYTE_ARRAY;
	} else if (type == "PackedInt32Array") {
		return Variant::PACKED_INT32_ARRAY;
	} else if (type == "PackedInt64Array") {
		return Variant::PACKED_INT64_ARRAY;
	} else if (type == "PackedFloat32Array") {
		return Variant::PACKED_FLOAT32_ARRAY;
	} else if (type == "PackedFloat64Array") {
		return Variant::PACKED_FLOAT64_ARRAY;
	} else if (type == "PackedStringArray") {
		return Variant::PACKED_STRING_ARRAY;
	} else if (type == "PackedVector2Array") {
		return Variant::PACKED_VECTOR2_ARRAY;
	} else if (type == "PackedVector3Array") {
		return Variant::PACKED_VECTOR3_ARRAY;
	} else if (type == "PackedVector4Array") {
		return Variant::PACKED_VECTOR4_ARRAY;
	} else if (type == "PackedColorArray") {
		return Variant::PACKED_COLOR_ARRAY;
	}
	return Variant::OBJECT;
}

Dictionary Sandbox::create_public_api_function(std::string_view name, gaddr_t address,
	std::string_view description, std::string_view return_type, std::string_view args)
{
	Dictionary func;
	if (name.empty() || name.size() > 64 || address == 0x0) {
		ERR_PRINT("Sandbox: Invalid public API function.");
		return func;
	}
	if (args.size() > 1024) {
		ERR_PRINT("Sandbox: Invalid public API function arguments.");
		return func;
	}

	String godot_name = String::utf8(name.data(), name.size());
	func["name"] = godot_name;
	func["address"] = address;
	func["flags"] = METHOD_FLAG_NORMAL;

	Dictionary return_value;
	return_value["type"] = convert_guest_type_to_variant(String::utf8(return_type.data(), return_type.size()));
	func["return"] = std::move(return_value);
	func["description"] = String::utf8(description.data(), description.size());

	TypedArray<Dictionary> args_array;
	PackedStringArray arg_names = String::utf8(args.data(), args.size()).split(", ");
	if (arg_names.is_empty()) {
		return func;
	}
	if (arg_names.size() > 16) {
		ERR_PRINT("Sandbox: Too many arguments for public API function.");
		return func;
	}
	PackedStringArray arg_name_and_type;
	for (const String &arg : arg_names) {
		arg_name_and_type.clear();
		arg_name_and_type = arg.split(" ");
		// Convert the argument name and type to a dictionary.
		String arg_name = arg_name_and_type[0];
		String arg_type = "Object";
		if (arg_name_and_type.size() > 1) {
			arg_type = arg_name_and_type[0];
			arg_name = arg_name_and_type[1];
		} else if (arg_name.is_empty()) {
			// An argument without type and name is invalid (or just an empty string).
			break;
		}

		Dictionary argument;
		argument["name"] = arg_name;
		argument["type"] = convert_guest_type_to_variant(arg_type);
		argument["class_name"] = arg_type;
		argument["usage"] = PROPERTY_USAGE_NIL_IS_VARIANT;

		args_array.append(std::move(argument));
	}

	func["args"] = std::move(args_array);
	return func;
}

PackedStringArray Sandbox::get_public_functions(const machine_t &machine) {
	PackedStringArray result;
	try {
		// Get all unmangled public functions from the guest program.
		// Exclude functions that belong to the C/C++ runtime, as well as compiler-generated functions.
		for (std::string_view function : machine.memory.all_unmangled_function_symbols()) {
			// Double underscore functions are compiler-generated functions.
			if (function.size() >= 2 && function[0] == '_' && function[1] == '_') {
				continue;
			}
			if (is_excluded_function(function)) {
				continue;
			}
			if (exclude_functions.count(function) == 0) {
				result.append(String::utf8(function.data(), function.size()));
			}
		}
	} catch (const std::exception &e) {
		ERR_PRINT("Sandbox: Failed to get functions: " + String(e.what()));
	}
	return result;
}

Sandbox::BinaryInfo Sandbox::get_program_info_from_binary(const PackedByteArray &binary) {
	BinaryInfo result;
	if (binary.is_empty()) {
		return result;
	}

	const std::string_view binary_view = std::string_view{ (const char *)binary.ptr(), static_cast<size_t>(binary.size()) };
	try {
		// Instantiate Machine without loading the ELF
		machine_t machine{ binary_view, riscv::MachineOptions<RISCV_ARCH>{
												.load_program = false, // Do not load the ELF program.
										} };
		std::vector<std::string_view> comments = machine.memory.elf_comments();
		// Detect language: C++, Rust, etc.
		result.language = "Unknown";
		result.version = 0;
		for (std::string_view comment : comments) {
			if (comment.find("Godot Rust") != std::string::npos) {
				// Rust: "Godot Rust API v1"
				result.language = "Rust";
				auto version = comment.find("API v");
				if (version != std::string::npos) {
					result.version = std::stoi(std::string(comment.substr(version + 5)));
				}
				break;
			} else if (comment.find("Godot C++") != std::string::npos) {
				// C++: "Godot C++ API v1"
				result.language = "C++";
				auto version = comment.find("API v");
				if (version != std::string::npos) {
					result.version = std::stoi(std::string(comment.substr(version + 5)));
				}
				break;
			} else if (comment.find("Godot Zig") != std::string::npos) {
				// Zig: "Godot Zig API v1"
				result.language = "Zig";
				auto version = comment.find("API v");
				if (version != std::string::npos) {
					result.version = std::stoi(std::string(comment.substr(version + 5)));
				}
				break;
			}
		}
		//printf("Detected language: %s, version: %d\n", result.language.utf8().ptr(), result.version);

		result.functions = Sandbox::get_public_functions(machine);

	} catch (const std::exception &e) {
		ERR_PRINT("Failed to get functions from binary. " + String(e.what()));
	}
	return result;
}

```

`src/sandbox_generated_api.cpp`:

```cpp
#include "sandbox.h"

#include "guest_datatypes.h"
#include "sandbox_project_settings.h"
#include <godot_cpp/classes/class_db_singleton.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/core/class_db.hpp>
#include <godot_cpp/variant/utility_functions.hpp>
namespace riscv {
extern std::unordered_map<std::string, std::function<uint64_t()>> allowed_globals;
}

static constexpr bool VERBOSE = false;
static String *current_generated_api = nullptr;

static const char *cpp_compatible_variant_type(int type) {
	switch (type) {
		case Variant::NIL:
			return "Variant";
		case Variant::BOOL:
			return "bool";
		case Variant::INT:
			return "int64_t";
		case Variant::FLOAT:
			return "double";
		case Variant::STRING:
		case Variant::NODE_PATH:
		case Variant::STRING_NAME:
			return "String";

		case Variant::VECTOR2:
			return "Vector2";
		case Variant::VECTOR2I:
			return "Vector2i";
		case Variant::RECT2:
			return "Rect2";
		case Variant::RECT2I:
			return "Rect2i";
		case Variant::VECTOR3:
			return "Vector3";
		case Variant::VECTOR3I:
			return "Vector3i";
		case Variant::VECTOR4:
			return "Vector4";
		case Variant::VECTOR4I:
			return "Vector4i";
		case Variant::COLOR:
			return "Color";

		case Variant::PLANE:
			return "Plane";
		case Variant::QUATERNION:
			return "Quaternion";
		case Variant::AABB:
			return "Variant";
		case Variant::TRANSFORM2D:
			return "Transform2D";
		case Variant::TRANSFORM3D:
			return "Transform3D";
		case Variant::BASIS:
			return "Basis";
		case Variant::PROJECTION:
			return "Variant";
		case Variant::RID:
			return "::RID";

		case Variant::OBJECT:
			return "Object";
		case Variant::DICTIONARY:
			return "Dictionary";
		case Variant::ARRAY:
			return "Array";
		case Variant::CALLABLE:
			return "Callable";
		case Variant::SIGNAL:
			return "Variant";

		case Variant::PACKED_BYTE_ARRAY:
			return "PackedArray<uint8_t>";
		case Variant::PACKED_INT32_ARRAY:
			return "PackedArray<int32_t>";
		case Variant::PACKED_INT64_ARRAY:
			return "PackedArray<int64_t>";
		case Variant::PACKED_FLOAT32_ARRAY:
			return "PackedArray<float>";
		case Variant::PACKED_FLOAT64_ARRAY:
			return "PackedArray<double>";
		case Variant::PACKED_STRING_ARRAY:
			return "PackedArray<std::string>";
		case Variant::PACKED_VECTOR2_ARRAY:
			return "PackedArray<Vector2>";
		case Variant::PACKED_VECTOR3_ARRAY:
			return "PackedArray<Vector3>";
		case Variant::PACKED_VECTOR4_ARRAY:
			return "PackedArray<Vector4>";
		case Variant::PACKED_COLOR_ARRAY:
			return "PackedArray<Color>";
		default:
			throw std::runtime_error("Unknown variant type.");
	}
}

// TODO: Invalidate the API if any classes change or new classes are registered.
String Sandbox::generate_api(String language, String header, bool use_argument_names) {
	if (current_generated_api == nullptr) {
		Sandbox::generate_runtime_cpp_api(use_argument_names);
	}
	if (current_generated_api == nullptr) {
		return String();
	}
	return header + *current_generated_api;
}

static String emit_class(ClassDBSingleton *class_db, const HashSet<String> &cpp_keywords, const HashSet<String> &singletons, const String &class_name, bool use_argument_names) {
	// Generate a simple API for each class using METHOD() and PROPERTY() macros to a string.
	if constexpr (VERBOSE) {
		UtilityFunctions::print("* Currently generating: " + class_name);
	}
	String parent_name = class_db->get_parent_class(class_name);

	String api = "struct " + class_name + " : public " + parent_name + " {\n";

	// Here we need to use an existing constructor, to inherit from the correct class.
	// eg. if it's a Node, we need to inherit from Node.
	// If it's a Node2D, we need to inherit from Node2D. etc.
	api += "    using " + parent_name + "::" + parent_name + ";\n";
	// We just need the names of the properties and methods.
	TypedArray<Dictionary> properties = class_db->class_get_property_list(class_name, true);
	for (int j = 0; j < properties.size(); j++) {
		Dictionary property = properties[j];
		String property_name = property["name"];
		const int type = int(property["type"]);
		// Properties that are likely just groups or categories.
		if (type == Variant::NIL) {
			continue;
		}
		// Skip properties with spaces in the name. Yes, this is a thing.
		if (property_name.is_empty() || property_name.contains(" ") || property_name.contains("/") || property_name.contains("-")) {
			continue;
		}
		// Yes, this is a thing too.
		if (property_name == class_name) {
			continue;
		}
		// If matching C++ keywords, capitalize the first letter.
		if (cpp_keywords.has(property_name.to_lower())) {
			property_name = property_name.capitalize();
		}

		String property_type = cpp_compatible_variant_type(type);
		if (property_type == "Variant") {
			api += String("    PROPERTY(") + property_name + ", Variant);\n";
		} else {
			api += String("    PROPERTY(") + property_name + ", " + property_type + ");\n";
		}
	}
	TypedArray<Dictionary> methods = class_db->class_get_method_list(class_name, true);
	for (int j = 0; j < methods.size(); j++) {
		Dictionary method = methods[j];
		String method_name = method["name"];
		Dictionary return_value = method["return"];
		const int type = int(return_value["type"]);
		// Skip methods that are empty, and methods with '/' and '-' in the name.
		if (method_name.is_empty() || method_name.contains("/") || method_name.contains("-")) {
			continue;
		}
		// If matching C++ keywords, capitalize the first letter.
		if (cpp_keywords.has(method_name.to_lower())) {
			method_name = method_name.capitalize();
		}

		const int flags = int(method["flags"]);
		//if (flags & METHOD_FLAG_STATIC) ...
		const bool is_const = flags & METHOD_FLAG_CONST;
		// Variant::NIL is a special case, as it's can be a void or Variant return type.
		const int return_flags = int(return_value["usage"]);
		const bool is_void = type == 0 && (return_flags & PROPERTY_USAGE_NIL_IS_VARIANT) == 0;

		if (use_argument_names) {
			// Example: { "name": "play_stream",
			// "args": [{
			//    "name": "stream", "class_name": &"AudioStream", "type": 24, "hint": 17, "hint_string": "AudioStream", "usage": 6
			// }, {
			//    "name": "from_offset", "class_name": &"", "type": 3, "hint": 0, "hint_string": "", "usage": 6
			// }, {
			//    "name": "volume_db", "class_name": &"", "type": 3, "hint": 0, "hint_string": "", "usage": 6
			// }, {
			//    "name": "pitch_scale", "class_name": &"", "type": 3, "hint": 0, "hint_string": "", "usage": 6
			// }, {
			//    "name": "playback_type", "class_name": &"AudioServer.PlaybackType", "type": 2, "hint": 0, "hint_string": "", "usage": 65542
			// }, {
			//    "name": "bus", "class_name": &"", "type": 21, "hint": 0, "hint_string": "", "usage": 6
			// }],
			//  "default_args": [0, 0, 1, 0, &"Master"],
			//  "flags": 1,
			//  "id": 11865,
			//  "return": { "name": "", "class_name": &"", "type": 2, "hint": 0, "hint_string": "", "usage": 6 } }
			api += "    ";
			// Return value:
			if (type != 0) {
				api += String(cpp_compatible_variant_type(type)) + " ";
			} else if (is_void) {
				api += "void ";
			} else {
				api += "Variant ";
			}
			// Method name:
			api += method_name + "(";
			// Arguments:
			const Array arguments = method["args"];
			Vector<String> argument_names;
			// Default arguments:
			const Array default_args = method["default_args"];
			const int default_args_size = default_args.size();
			const int first_default_arg = arguments.size() - default_args_size;

			for (int k = 0; k < arguments.size(); k++) {
				const Dictionary &argument = arguments[k];

				String arg_name = argument["name"];
				if (cpp_keywords.has(arg_name.to_lower())) {
					arg_name += "_";
				}
				const int arg_type = int(argument["type"]);

				api += String(cpp_compatible_variant_type(arg_type)) + " " + arg_name;

				// Default arguments.
				if (k >= first_default_arg) {
					api += " = ";
					const Variant &default_arg = default_args[k - first_default_arg];
					switch (arg_type) {
						case Variant::BOOL:
							api += bool(default_arg) ? "true" : "false";
							break;
						case Variant::INT:
							api += itos(int64_t(default_arg));
							break;
						case Variant::FLOAT:
							api += String::num(double(default_arg));
							break;
						case Variant::STRING:
							api += "\"" + (String)default_arg + "\"";
							break;
						case Variant::VECTOR2: {
							const Vector2 vec = default_arg.operator Vector2();
							api += "Vector2(" + String::num(vec.x) + ", " + String::num(vec.y) + ")";
							break;
						}
						case Variant::VECTOR2I: {
							const Vector2i vec = default_arg.operator Vector2i();
							api += "Vector2i(" + itos(vec.x) + ", " + itos(vec.y) + ")";
							break;
						}
						case Variant::RECT2: {
							const Rect2 rect = default_arg.operator Rect2();
							api += "Rect2(" + String::num(rect.position.x) + ", " + String::num(rect.position.y) + ", " + String::num(rect.size.x) + ", " + String::num(rect.size.y) + ")";
							break;
						}
						case Variant::RECT2I: {
							const Rect2i rect = default_arg.operator Rect2i();
							api += "Rect2i(" + itos(rect.position.x) + ", " + itos(rect.position.y) + ", " + itos(rect.size.x) + ", " + itos(rect.size.y) + ")";
							break;
						}
						case Variant::VECTOR3: {
							const Vector3 vec = default_arg.operator Vector3();
							api += "Vector3(" + String::num(vec.x) + ", " + String::num(vec.y) + ", " + String::num(vec.z) + ")";
							break;
						}
						case Variant::VECTOR3I: {
							const Vector3i vec = default_arg.operator Vector3i();
							api += "Vector3i(" + itos(vec.x) + ", " + itos(vec.y) + ", " + itos(vec.z) + ")";
							break;
						}
						case Variant::VECTOR4: {
							const Vector4 vec = default_arg.operator Vector4();
							api += "Vector4(" + String::num(vec.x) + ", " + String::num(vec.y) + ", " + String::num(vec.z) + ", " + String::num(vec.w) + ")";
							break;
						}
						case Variant::VECTOR4I: {
							const Vector4i vec = default_arg.operator Vector4i();
							api += "Vector4i(" + itos(vec.x) + ", " + itos(vec.y) + ", " + itos(vec.z) + ", " + itos(vec.w) + ")";
							break;
						}
						case Variant::COLOR: {
							const Color color = default_arg.operator Color();
							api += "Color(" + String::num(color.r) + ", " + String::num(color.g) + ", " + String::num(color.b) + ", " + String::num(color.a) + ")";
							break;
						}
						case Variant::PLANE: {
							const Plane plane = default_arg.operator Plane();
							api += "Plane(" + String::num(plane.normal.x) + ", " + String::num(plane.normal.y) + ", " + String::num(plane.normal.z) + ", " + String::num(plane.d) + ")";
							break;
						}
						case Variant::QUATERNION: {
							const Quaternion quat = default_arg.operator Quaternion();
							api += "Quaternion(" + String::num(quat.x) + ", " + String::num(quat.y) + ", " + String::num(quat.z) + ", " + String::num(quat.w) + ")";
							break;
						}
						case Variant::OBJECT: {
							api += "{0}";
							break;
						}
						default:
							api += "{}";
							break;
					}
				}

				if (k != arguments.size() - 1) {
					api += ", ";
				}

				argument_names.push_back(arg_name);
			}
			// TODO: Append const if the method is const.
			// Sadly, it breaks the call operator, so hold off on this for now.
			api += ") {\n";
			// Method body: return operator() (\"" + method_name + "\"", " + argument_list + ");\n";
			if (is_void) {
				// Void return type.
				api += "      voidcall(\"" + method_name + "\"";
			} else {
				// Typed return type.
				api += "      return operator() (\"" + method_name + "\"";
			}
			if (!arguments.is_empty()) {
				api += ", ";
			}
			for (int k = 0; k < argument_names.size(); k++) {
				const String &arg_name = argument_names[k];
				api += arg_name;
				if (k != arguments.size() - 1) {
					api += ", ";
				}
			}
			api += ");\n";
			api += "    }\n";
			// End of method.
			continue;
		}

		// Typed return type.
		if (is_void) {
			api += String("    METHOD(void, ") + method_name + ");\n";
		} else {
			api += String("    METHOD(") + cpp_compatible_variant_type(type) + ", " + method_name + ");\n";
		}
	}

	// Add integer constants.
	PackedStringArray integer_constants = class_db->class_get_integer_constant_list(class_name, true);
	for (int j = 0; j < integer_constants.size(); j++) {
		String constant_name = integer_constants[j];
		// If matching C++ keywords, capitalize the first letter.
		if (cpp_keywords.has(constant_name.to_lower())) {
			constant_name = constant_name.capitalize();
		}
		api += String("    static constexpr int64_t ") + constant_name + " = " + itos(class_db->class_get_integer_constant(class_name, constant_name)) + ";\n";
	}

	// Add singleton getter if the class is a singleton.
	if (singletons.has(class_name)) {
		api += "    static " + class_name + " get_singleton() { return " + class_name + "(Object(\"" + class_name + "\").address()); }\n";
	}

	api += "};\n";
	return api;
}

void Sandbox::generate_runtime_cpp_api(bool use_argument_names) {
	// 1. Get all classes currently registered with the engine.
	// 2. Get all methods and properties for each class.
	// 3. Generate a simple API for each class using METHOD() and PROPERTY() macros to a string.
	// 4. Print the generated API to the console.
	if constexpr (VERBOSE) {
		UtilityFunctions::print("* Generating C++ run-time API");
	}
	if (current_generated_api != nullptr) {
		delete current_generated_api;
	}
	current_generated_api = new String("#pragma once\n\n#include <api.hpp>\n#define GENERATED_API 1\n\n");

	HashSet<String> cpp_keywords;
	cpp_keywords.insert("class");
	cpp_keywords.insert("operator");
	cpp_keywords.insert("new");
	cpp_keywords.insert("delete");
	cpp_keywords.insert("this");
	cpp_keywords.insert("virtual");
	cpp_keywords.insert("override");
	cpp_keywords.insert("final");
	cpp_keywords.insert("public");
	cpp_keywords.insert("protected");
	cpp_keywords.insert("private");
	cpp_keywords.insert("static");
	cpp_keywords.insert("const");
	cpp_keywords.insert("constexpr");
	cpp_keywords.insert("inline");
	cpp_keywords.insert("friend");
	cpp_keywords.insert("template");
	cpp_keywords.insert("typename");
	cpp_keywords.insert("typedef");
	cpp_keywords.insert("using");
	cpp_keywords.insert("namespace");
	cpp_keywords.insert("return");
	cpp_keywords.insert("if");
	cpp_keywords.insert("else");
	cpp_keywords.insert("for");
	cpp_keywords.insert("while");
	cpp_keywords.insert("do");
	cpp_keywords.insert("switch");
	cpp_keywords.insert("case");
	cpp_keywords.insert("default");
	cpp_keywords.insert("break");
	cpp_keywords.insert("continue");
	cpp_keywords.insert("goto");
	cpp_keywords.insert("try");
	cpp_keywords.insert("catch");
	cpp_keywords.insert("throw");
	cpp_keywords.insert("static_assert");
	cpp_keywords.insert("sizeof");
	cpp_keywords.insert("alignof");
	cpp_keywords.insert("decltype");
	cpp_keywords.insert("noexcept");
	cpp_keywords.insert("nullptr");
	cpp_keywords.insert("true");
	cpp_keywords.insert("false");
	cpp_keywords.insert("and");
	cpp_keywords.insert("or");
	cpp_keywords.insert("not");
	cpp_keywords.insert("xor");
	cpp_keywords.insert("bitand");
	cpp_keywords.insert("bitor");
	cpp_keywords.insert("compl");
	cpp_keywords.insert("and_eq");
	cpp_keywords.insert("or_eq");
	cpp_keywords.insert("xor_eq");
	cpp_keywords.insert("not_eq");
	cpp_keywords.insert("bool");
	cpp_keywords.insert("char");
	cpp_keywords.insert("short");
	cpp_keywords.insert("int");
	cpp_keywords.insert("long");
	cpp_keywords.insert("float");
	cpp_keywords.insert("double");

	// 1. Get all classes currently registered with the engine.
	ClassDBSingleton *class_db = ClassDBSingleton::get_singleton();
	Array classes = class_db->get_class_list();

	HashSet<String> emitted_classes;
	HashMap<String, TypedArray<String>> waiting_classes;
	Array skipped_class_words = SandboxProjectSettings::generated_api_skipped_classes();
	int total_skipped_classes = 0;

	// 2. Insert all pre-existing classes into the emitted_classes set.
	emitted_classes.insert("Object");
	emitted_classes.insert("Node");
	emitted_classes.insert("CanvasItem");
	emitted_classes.insert("Node2D");
	emitted_classes.insert("Node3D");
	// Also skip some classes we simply don't want to expose.
	emitted_classes.insert("ClassDB");

	// Finally, add singleton getters to certain classes.
	HashSet<String> singletons;
	PackedStringArray singleton_list = Engine::get_singleton()->get_singleton_list();
	for (int i = 0; i < singleton_list.size(); i++) {
		singletons.insert(singleton_list[i]);
	}

	// 3. Get all methods and properties for each class.
	for (int i = 0; i < classes.size(); i++) {
		String class_name = classes[i];

		// 4. Emit classes
		// Check if the class is already emitted.
		if (emitted_classes.has(class_name)) {
			continue;
		}

		bool is_skipped = false;
		for (int j = 0; j < skipped_class_words.size(); j++) {
			if (class_name.contains(skipped_class_words[j])) {
				if constexpr (VERBOSE) {
					UtilityFunctions::print("* Skipping class: " + class_name);
				}
				total_skipped_classes++;
				is_skipped = true;
				break;
			}
		}
		if (is_skipped) {
			continue;
		}

		// Check if the parent class has been emitted, and if not, add it to the waiting_classes map.
		String parent_name = class_db->get_parent_class(class_name);
		if (!emitted_classes.find(parent_name)) { // Not emitted yet.
			TypedArray<String> *waiting = waiting_classes.getptr(parent_name);
			if (waiting == nullptr) {
				waiting_classes.insert(parent_name, TypedArray<String>());
				waiting = waiting_classes.getptr(parent_name);
			}
			waiting->push_back(class_name);
			continue;
		}
		// Emit the class.
		*current_generated_api += emit_class(class_db, cpp_keywords, singletons, class_name, use_argument_names);
		emitted_classes.insert(class_name);
	}

	// 5. Emit waiting classes.
	while (!waiting_classes.is_empty()) {
		const int initial_waiting_classes = waiting_classes.size();

		for (auto it = waiting_classes.begin(); it != waiting_classes.end(); ++it) {
			const String &parent_name = it->key;
			if (emitted_classes.has(parent_name)) {
				const TypedArray<String> &waiting = it->value;
				for (int i = 0; i < waiting.size(); i++) {
					String class_name = waiting[i];
					*current_generated_api += emit_class(class_db, cpp_keywords, singletons, class_name, use_argument_names);
					emitted_classes.insert(class_name);
				}
				waiting_classes.erase(parent_name);
				break;
			}
		}

		const int remaining_waiting_classes = waiting_classes.size();
		if (remaining_waiting_classes == initial_waiting_classes) {
			if (skipped_class_words.is_empty()) {
				// We have a circular dependency.
				// This is a bug in the engine, and should be reported.
				// We can't continue, so we'll just break out of the loop.
				ERR_PRINT("Circular dependency detected in class inheritance");
				for (auto it = waiting_classes.begin(); it != waiting_classes.end(); ++it) {
					const String &parent_name = it->key;
					const TypedArray<String> &waiting = it->value;
					for (int i = 0; i < waiting.size(); i++) {
						ERR_PRINT("* Waiting class " + String(waiting[i]) + " with parent " + parent_name);
					}
				}
			} else {
				// When we have skipped classes, we can't emit them, so we'll just skip them.
				total_skipped_classes += remaining_waiting_classes;
				WARN_PRINT("Skipped classes left in class inheritance: "
					+ itos(remaining_waiting_classes) + ", total skipped classes: " + itos(total_skipped_classes));
			}
			break;
		}
	}

	if constexpr (VERBOSE) {
		UtilityFunctions::print("* Finished generating " + itos(classes.size()) + " classes");
	}
}

```

`src/sandbox_globals.cpp`:

```cpp
#include "sandbox.h"

#include <godot_cpp/classes/audio_server.hpp>
#include <godot_cpp/classes/display_server.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/engine_debugger.hpp>
#include <godot_cpp/classes/gd_extension_manager.hpp>
#include <godot_cpp/classes/geometry2d.hpp>
#include <godot_cpp/classes/geometry3d.hpp>
#include <godot_cpp/classes/input.hpp>
#include <godot_cpp/classes/input_map.hpp>
#include <godot_cpp/classes/marshalls.hpp>
#include <godot_cpp/classes/native_menu.hpp>
#include <godot_cpp/classes/navigation_mesh_generator.hpp>
#include <godot_cpp/classes/navigation_server2d.hpp>
#include <godot_cpp/classes/navigation_server3d.hpp>
#include <godot_cpp/classes/performance.hpp>
#include <godot_cpp/classes/physics_server2d.hpp>
#include <godot_cpp/classes/physics_server2d_manager.hpp>
#include <godot_cpp/classes/physics_server3d.hpp>
#include <godot_cpp/classes/physics_server3d_manager.hpp>
#include <godot_cpp/classes/project_settings.hpp>
#include <godot_cpp/classes/rendering_server.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/resource_saver.hpp>
#include <godot_cpp/classes/resource_uid.hpp>
#include <godot_cpp/classes/text_server_manager.hpp>
#include <godot_cpp/classes/theme_db.hpp>
#include <godot_cpp/classes/time.hpp>
#include <godot_cpp/classes/translation_server.hpp>
#include <godot_cpp/classes/worker_thread_pool.hpp>
#include <godot_cpp/classes/xr_server.hpp>

namespace riscv {
std::unordered_map<std::string, std::function<uint64_t()>> global_singleton_list = {
	{ "AudioServer", [] { return uint64_t(uintptr_t(AudioServer::get_singleton())); } },
	{ "EditorInterface", [] { return uint64_t(uintptr_t(EditorInterface::get_singleton())); } },
	{ "DisplayServer", [] { return uint64_t(uintptr_t(DisplayServer::get_singleton())); } },
	{ "GDExtensionManager", [] { return uint64_t(uintptr_t(GDExtensionManager::get_singleton())); } },
	{ "Geometry2D", [] { return uint64_t(uintptr_t(Geometry2D::get_singleton())); } },
	{ "Geometry3D", [] { return uint64_t(uintptr_t(Geometry3D::get_singleton())); } },
	{ "EngineDebugger", [] { return uint64_t(uintptr_t(EngineDebugger::get_singleton())); } },
	{ "Engine", [] { return uint64_t(uintptr_t(Engine::get_singleton())); } },
	{ "Input", [] { return uint64_t(uintptr_t(Input::get_singleton())); } },
	{ "InputMap", [] { return uint64_t(uintptr_t(InputMap::get_singleton())); } },
	{ "Marshalls", [] { return uint64_t(uintptr_t(Marshalls::get_singleton())); } },
	{ "NativeMenu", [] { return uint64_t(uintptr_t(NativeMenu::get_singleton())); } },
	{ "NavigationMeshGenerator", [] { return uint64_t(uintptr_t(NavigationMeshGenerator::get_singleton())); } },
	{ "NavigationServer2D", [] { return uint64_t(uintptr_t(NavigationServer2D::get_singleton())); } },
	{ "NavigationServer3D", [] { return uint64_t(uintptr_t(NavigationServer3D::get_singleton())); } },
//	{ "OS", [] { return uint64_t(uintptr_t(OS::get_singleton())); } },
	{ "Performance", [] { return uint64_t(uintptr_t(Performance::get_singleton())); } },
	{ "PhysicsServer2D", [] { return uint64_t(uintptr_t(PhysicsServer2D::get_singleton())); } },
	{ "PhysicsServer3D", [] { return uint64_t(uintptr_t(PhysicsServer3D::get_singleton())); } },
	{ "PhysicsServer2DManager", [] { return uint64_t(uintptr_t(PhysicsServer2DManager::get_singleton())); } },
	{ "PhysicsServer3DManager", [] { return uint64_t(uintptr_t(PhysicsServer3DManager::get_singleton())); } },
	{ "ProjectSettings", [] { return uint64_t(uintptr_t(ProjectSettings::get_singleton())); } },
	{ "RenderingServer", [] { return uint64_t(uintptr_t(RenderingServer::get_singleton())); } },
	{ "ResourceLoader", [] { return uint64_t(uintptr_t(ResourceLoader::get_singleton())); } },
	{ "ResourceSaver", [] { return uint64_t(uintptr_t(ResourceSaver::get_singleton())); } },
	{ "ResourceUID", [] { return uint64_t(uintptr_t(ResourceUID::get_singleton())); } },
	{ "TextServerManager", [] { return uint64_t(uintptr_t(TextServerManager::get_singleton())); } },
	{ "ThemeDB", [] { return uint64_t(uintptr_t(ThemeDB::get_singleton())); } },
	{ "Time", [] { return uint64_t(uintptr_t(Time::get_singleton())); } },
	{ "TranslationServer", [] { return uint64_t(uintptr_t(TranslationServer::get_singleton())); } },
	{ "WorkerThreadPool", [] { return uint64_t(uintptr_t(WorkerThreadPool::get_singleton())); } },
	{ "XRServer", [] { return uint64_t(uintptr_t(XRServer::get_singleton())); } },
};

} // namespace riscv

```

`src/sandbox_profiling.cpp`:

```cpp
#include "sandbox.h"

#include <algorithm>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/variant/utility_functions.hpp>
static constexpr bool USE_ADDR2LINE = false;

struct ProfilingMachine {
	std::unique_ptr<riscv::Machine<RISCV_ARCH>> machine = nullptr;
	std::vector<uint8_t> binary;
};
static std::unordered_map<std::string, ProfilingMachine> lookup_machines;


void Sandbox::set_profiling(bool enable) {
	enable_profiling(enable);
}

void Sandbox::enable_profiling(bool enable, uint32_t interval) {
	if (enable) {
		if (!m_local_profiling_data) {
			m_local_profiling_data = std::make_unique<LocalProfilingData>();
		}
		m_local_profiling_data->profiling_interval = interval;

		std::scoped_lock lock(profiling_mutex);
		if (!m_profiling_data) {
			m_profiling_data = std::make_unique<ProfilingData>();
		}
	} else {
		if (this->is_in_vmcall()) {
			ERR_PRINT("Cannot disable profiling while a VM call is in progress.");
			return;
		}
		m_local_profiling_data.reset();
	}
}

struct Result {
	std::string elf;
	gaddr_t pc = 0;
	int64_t offset = 0;
	int count = 0;
	int line = 0;
	String function;
	String file;
};

static ProfilingMachine *requisition(const std::string &elf) {
	auto it = lookup_machines.find(elf);
	if (it == lookup_machines.end()) {
		ProfilingMachine pm;
		PackedByteArray array = FileAccess::get_file_as_bytes("res://" + String::utf8(elf.c_str(), elf.size()));
		pm.binary = std::vector<uint8_t>(array.ptr(), array.ptr() + array.size());
		if (pm.binary.empty()) {
			ERR_PRINT("Failed to load ELF file for profiling: " + String::utf8(elf.c_str(), elf.size()));
			return nullptr;
		}
		pm.machine = std::make_unique<riscv::Machine<RISCV_ARCH>>(pm.binary, riscv::MachineOptions<RISCV_ARCH>{
			.load_program = false,
			.use_memory_arena = false,
		});
		lookup_machines[elf] = std::move(pm);
		return &lookup_machines[elf];
	}
	return &it->second;
}

static void resolve(Result &res, const Callable &callback,
	const Sandbox::ProfilingState &gprofstate) {
	// Try to resolve the address using addr2line
#ifdef __linux__
	if (USE_ADDR2LINE && !res.elf.empty()) {
		// execute riscv64-linux-gnu-addr2line -e <binary> -f -C 0x<address>
		// using popen() and fgets() to read the output
		char buffer[4096];
		snprintf(buffer, sizeof(buffer),
			"riscv64-linux-gnu-addr2line -e %s -f -C 0x%lX", res.elf.c_str(), long(res.pc));

		FILE * f = popen(buffer, "r");
		if (f) {
			String output;
			while (fgets(buffer, sizeof(buffer), f) != nullptr) {
				output += String::utf8(buffer, strlen(buffer));
			}
			pclose(f);

			// Parse the output. addr2line returns two lines:
			// 1. The function name
			// _physics_process
			// 2. The path to the source file and line number
			// /home/gonzo/github/thp/scenes/objects/trees/trees.cpp:29
			PackedStringArray lines = output.split("\n");
			if (lines.size() >= 2) {
				res.function = lines[0];
				const String &line2 = lines[1];

				// Parse the function name and file/line number
				int idx = line2.rfind(":");
				if (idx != -1) {
					res.file = line2.substr(0, idx);
					res.line = line2.substr(idx + 1).to_int();
					if (res.file == "??") {
						res.file = String::utf8(res.elf.c_str(), res.elf.size());
					}
				}
			} else {
				res.function = output;
			}
			if (res.file.is_empty()) {
				res.file = String::utf8(res.elf.c_str(), res.elf.size());
			}
			//printf("Hotspot %zu: %.*s\n", results.size(), int(output.utf8().size()), output.utf8().ptr());
			return;
		}
	}
#endif
	// Fallback to the callback
	res.file = "(unknown)";
	res.function = "??";
	if (!res.elf.empty()) {
		// Prefer gprofstate lookup
		gaddr_t best = ~0ULL;
		res.offset = 0x0;
		for (const auto &entry : gprofstate.lookup) {
			if (res.pc < entry.address || entry.address >= best) {
				continue;
			}
			best = entry.address;
			res.offset = res.pc - entry.address;
			res.function = entry.name;
		}

		// Try to resolve the address using the ELF file, if the offset from lookup was too large
		if (best == ~0ULL || res.offset > 0x4000) {
			ProfilingMachine *pm = requisition(res.elf);
			if (pm) {
				riscv::Memory<RISCV_ARCH>::Callsite callsite = pm->machine->memory.lookup(res.pc);
				res.function = String::utf8(callsite.name.c_str(), callsite.name.size());
				res.offset = callsite.offset;
			}
		}
		res.file = String::utf8(res.elf.c_str(), res.elf.size());
	}
	// If a callback is set, use it to resolve the address
	else if (callback.is_null()) {
		res.function = callback.call(res.file, res.pc);
	}
}

Array Sandbox::get_hotspots(unsigned total, const Callable &callable) {
	std::unordered_map<std::string_view, ProfilingState> gprofstate;
	{
		std::scoped_lock lock(profiling_mutex);
		if (!m_profiling_data) {
			ERR_PRINT("Profiling is not currently enabled.");
			return Array();
		}
		ProfilingData &profdata = *m_profiling_data;
		// Copy the profiling data
		gprofstate = profdata.state;
	}
	// Prevent re-entrancy into the profiling data
	std::scoped_lock lock(generate_hotspots_mutex);

	// Gather information about the hotspots
	std::vector<Result> results;
	unsigned total_measurements = 0;

	for (const auto &path : gprofstate) {
		std::string_view elf_path = path.first;
		const auto &state = path.second;

		for (const auto &entry : state.hotspots) {
			Result res;
			res.elf = elf_path;
			res.pc = entry.first;
			res.count = entry.second;
			total_measurements += res.count;

			resolve(res, callable, state);

			results.push_back(std::move(res));
		}
	}

	// Deduplicate the results, now that we have function names
	HashMap<String, unsigned> dedup;
	for (auto &res : results) {
		const String key = res.function + res.file;
		if (dedup.has(key)) {
			const size_t index = dedup[key];
			results[index].count += res.count;
			res.count = 0;
			continue;
		} else {
			dedup.insert(key, &res - results.data());
		}
	}
	total = std::min(total, static_cast<unsigned>(results.size()));

	// Partial sort to find the top N hotspots
	std::partial_sort(results.begin(), results.begin() + total, results.end(), [](const Result &a, const Result &b) {
		return a.count > b.count;
	});

	// Cut off the results to the top N
	results.resize(total);

	// Trim off any zero-count results
	while (!results.empty() && results.back().count == 0) {
		results.pop_back();
	}

	Array result;
	unsigned measured = 0;
	for (const Result &res : results) {
		Dictionary hotspot;
		hotspot["function"] = res.function;
		hotspot["address"] = String::num_int64(res.pc, 16);
		hotspot["offset"] = String::num_int64(res.offset, 16);
		hotspot["file"] = res.file;
		hotspot["line"] = res.line;
		hotspot["samples"] = res.count;
		result.push_back(hotspot);
		measured += res.count;
	}
	Dictionary stats;
	stats["results"] = unsigned(results.size());
	stats["samples_shown"] = measured;
	stats["samples_total"] = total_measurements;
	stats["unique_functions"] = dedup.size();
	result.push_back(stats);
	return result;
}

void Sandbox::clear_hotspots() {
	std::scoped_lock lock(profiling_mutex);
	if (!m_profiling_data) {
		ERR_PRINT("Profiling is not currently enabled.");
		return;
	}
	m_profiling_data->state.clear();
	lookup_machines.clear();
}

```

`src/sandbox_programs.cpp`:

```cpp
#include "sandbox.h"

#include "sandbox_project_settings.h"
#include <godot_cpp/classes/dir_access.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/http_client.hpp>
#include <godot_cpp/classes/zip_reader.hpp>
#include <godot_cpp/variant/utility_functions.hpp>
using namespace godot;
static constexpr bool VERBOSE = false;

static PackedByteArray handle_request(HTTPClient *client, String url) {
	while (client->get_status() != HTTPClient::Status::STATUS_CONNECTED) {
		if (client->get_status() == HTTPClient::Status::STATUS_CANT_CONNECT
			|| client->get_status() == HTTPClient::Status::STATUS_CONNECTION_ERROR
			|| client->get_status() == HTTPClient::Status::STATUS_CANT_RESOLVE) {
			ERR_PRINT("Failed to connect to server");
			memdelete(client);
			return PackedByteArray();
		}
		client->poll();
	}
	Error err = client->request(HTTPClient::Method::METHOD_GET, url, {});
	if (err != OK) {
		memdelete(client);
		return PackedByteArray();
	}

	while (client->get_status() == HTTPClient::Status::STATUS_REQUESTING) {
		client->poll();
	}

	if (!client->has_response()) {
		memdelete(client);
		return PackedByteArray();
	}

	if (client->get_response_code() >= 300 && client->get_response_code() < 400) {
		String location = client->get_response_headers_as_dictionary()["Location"];
		if constexpr (VERBOSE) {
			ERR_PRINT("Redirected to: " + location);
		}

		client->close();
		// Find first / after :// to get the host and path
		int32_t host_end = location.find("/", 8);
		if (host_end == -1) {
			ERR_PRINT("Invalid redirect location");
			memdelete(client);
			return PackedByteArray();
		}
		String host = location.substr(0, host_end);
		String path = location.substr(host_end);
		client->connect_to_host(host);

		// Handle the redirect
		return handle_request(client, path);
	}

	if (client->get_response_code() != 200) {
		ERR_PRINT("Failed to download program: HTTP status " + itos(client->get_response_code()));
		return PackedByteArray();
	}

	// Save the downloaded program to a buffer
	PackedByteArray data;
	while (client->get_status() == HTTPClient::Status::STATUS_BODY) {
		client->poll();

		PackedByteArray chunk = client->read_response_body_chunk();
		if (chunk.size() == 0) {
			continue;
		}

		data.append_array(chunk);
	}
	return data;
}

PackedByteArray Sandbox::download_program(String program_name) {
	String url;

	// Check if the program is from another library
	const int separator = program_name.find("/");
	if (separator != -1) {
		String library = program_name.substr(0, separator);
		String program = program_name.substr(separator + 1);
		if (library.is_empty() || program.is_empty()) {
			ERR_PRINT("Invalid library or program name");
			return PackedByteArray();
		}

		Dictionary libraries = SandboxProjectSettings::get_program_libraries();
		if (!libraries.has(library)) {
			ERR_PRINT("Unknown library: " + library);
			return PackedByteArray();
		}
		// Get the URL for the program from the custom library
		program_name = program;
		url = String("/") + String(libraries[library]) + "/releases/latest/download/" + program + ".zip";
	} else {
		// Use the default URL for Sandbox programs
		url = "/libriscv/godot-sandbox-programs/releases/latest/download/" + program_name + ".zip";
	}

	// Download the program from the URL
	HTTPClient *client = memnew(HTTPClient);
	client->set_blocking_mode(true);
	client->connect_to_host("https://github.com", 443);

	PackedByteArray data = handle_request(client, url);
	//printf("Response code: %d\n", client->get_response_code());
	//UtilityFunctions::print(client->get_response_headers_as_dictionary());
	memdelete(client);

	if (data.is_empty()) {
		return data;
	}

	// Save the downloaded program to a temporary file
	Ref<FileAccess> file = FileAccess::open("user://temp.zip", FileAccess::ModeFlags::WRITE);
	if (file == nullptr || !file->is_open()) {
		ERR_PRINT("Failed to open temporary file for writing");
		return PackedByteArray();
	}
	file->store_buffer(data);
	file->close();

	// Read the temporary file into a byte array
	ZIPReader *zip = memnew(ZIPReader);
	Error err = zip->open("user://temp.zip");
	if (err != OK) {
		ERR_PRINT("Failed to open temporary file for reading");
		memdelete(zip);
		return PackedByteArray();
	}

	PackedByteArray program_data = zip->read_file(program_name + String(".elf"));
	memdelete(zip);

	// Remove the temporary file
	Ref<DirAccess> dir = DirAccess::open("user://");
	dir->remove("temp.zip");

	return program_data;
}

```

`src/sandbox_project_settings.cpp`:

```cpp
#include "sandbox_project_settings.h"

#include <godot_cpp/classes/project_settings.hpp>

using namespace godot;

static constexpr char USE_GLOBAL_NAMES[] = "editor/script/use_global_sandbox_names";
static constexpr char USE_GLOBAL_NAMES_HINT[] = "Use customized global names for Sandbox programs";

static constexpr char DOCKER_ENABLED[] = "editor/script/docker_enabled";
static constexpr char DOCKER_ENABLED_HINT[] = "Enable Docker for compilation";
static constexpr char DOCKER_PATH[] = "editor/script/docker";
static constexpr char DOCKER_PATH_HINT[] = "Path to the Docker executable";
static constexpr char ZIG_PATH[] = "editor/script/zig";
static constexpr char ZIG_PATH_HINT[] = "Path to the Zig executable";
static constexpr char CMAKE_PATH[] = "editor/script/cmake";
static constexpr char CMAKE_PATH_HINT[] = "Path to the CMake executable";
static constexpr char SCONS_PATH[] = "editor/script/sconstruct";
static constexpr char SCONS_PATH_HINT[] = "Path to the SConstruct executable";

static constexpr char ASYNC_COMPILATION[] = "editor/script/async_compilation";
static constexpr char ASYNC_COMPILATION_HINT[] = "Compile scripts asynchronously";
static constexpr char NATIVE_TYPES[] = "editor/script/unboxed_types_for_sandbox_arguments";
static constexpr char NATIVE_TYPES_HINT[] = "Use native types and classes instead of Variants in Sandbox functions where possible";
static constexpr char DEBUG_INFO[] = "editor/script/debug_info";
static constexpr char DEBUG_INFO_HINT[] = "Enable debug information when building ELF files";
static constexpr char GLOBAL_DEFINES[] = "editor/script/global_defines";
static constexpr char GLOBAL_DEFINES_HINT[] = "Global defines used when compiling Sandbox programs";

static constexpr char GENERATE_RUNTIME_API[] = "editor/script/generate_runtime_api";
static constexpr char GENERATE_RUNTIME_API_HINT[] = "Generate the run-time API for the Sandbox";
static constexpr char METHOD_ARGUMENTS[] = "editor/script/runtime_api_method_arguments";
static constexpr char METHOD_ARGUMENTS_HINT[] = "Generate method arguments for the run-time API";
static constexpr char GENAPI_SKIPPED_CLASSES[] = "editor/script/generated_api_skipped_classes";
static constexpr char GENAPI_SKIPPED_CLASSES_HINT[] = "Matching classes to skip when generating the run-time API";

static constexpr char PROGRAM_LIBRARIES[] = "editor/script/program_libraries";
static constexpr char PROGRAM_LIBRARIES_HINT[] = "Custom libraries for downloadable Sandbox programs";

static void register_setting(
		const String &p_name,
		const Variant &p_value,
		bool p_needs_restart,
		PropertyHint p_hint,
		const String &p_hint_string) {
	ProjectSettings *project_settings = ProjectSettings::get_singleton();

	if (!project_settings->has_setting(p_name)) {
		project_settings->set(p_name, p_value);
	}

	Dictionary property_info;
	property_info["name"] = p_name;
	property_info["type"] = p_value.get_type();
	property_info["hint"] = p_hint;
	property_info["hint_string"] = p_hint_string;

	project_settings->add_property_info(property_info);
	project_settings->set_initial_value(p_name, p_value);
	project_settings->set_restart_if_changed(p_name, p_needs_restart);

	// HACK(mihe): We want our settings to appear in the order we register them in, but if we start
	// the order at 0 we end up moving the entire `physics/` group to the top of the tree view, so
	// instead we give it a hefty starting order and increment from there, which seems to give us
	// the desired effect.
	static int32_t order = 1000000;

	project_settings->set_order(p_name, order++);
}

void register_setting_plain(
		const String &p_name,
		const Variant &p_value,
		const String &p_hint_string = "",
		bool p_needs_restart = false) {
	register_setting(p_name, p_value, p_needs_restart, PROPERTY_HINT_NONE, p_hint_string);
}

void SandboxProjectSettings::register_settings() {
	register_setting_plain(USE_GLOBAL_NAMES, true, USE_GLOBAL_NAMES_HINT, true);
	register_setting_plain(DOCKER_ENABLED, true, DOCKER_ENABLED_HINT, true);
#ifdef WIN32
	register_setting_plain(DOCKER_PATH, "C:\\Program Files\\Docker\\Docker\\bin\\", DOCKER_PATH_HINT, true);
#else
	register_setting_plain(DOCKER_PATH, "docker", DOCKER_PATH_HINT, true);
#endif
	register_setting_plain(ZIG_PATH, "zig", ZIG_PATH_HINT, true);
	register_setting_plain(SCONS_PATH, "scons", SCONS_PATH_HINT, true);
	register_setting_plain(CMAKE_PATH, "cmake", CMAKE_PATH_HINT, true);
	register_setting_plain(ASYNC_COMPILATION, true, ASYNC_COMPILATION_HINT, false);
	register_setting_plain(NATIVE_TYPES, true, NATIVE_TYPES_HINT, false);
	register_setting_plain(DEBUG_INFO, false, DEBUG_INFO_HINT, false);
	register_setting_plain(GLOBAL_DEFINES, Array(), GLOBAL_DEFINES_HINT, false);
	register_setting_plain(GENERATE_RUNTIME_API, true, GENERATE_RUNTIME_API_HINT, false);
	register_setting_plain(METHOD_ARGUMENTS, false, METHOD_ARGUMENTS_HINT, true);
	Array skipped_classes;
	skipped_classes.push_back("Editor");
	skipped_classes.push_back("Multiplayer");
	skipped_classes.push_back("Packet");
	skipped_classes.push_back("Peer");
	skipped_classes.push_back("Loader");
	skipped_classes.push_back("Saver");
	skipped_classes.push_back("OS");
	register_setting_plain(GENAPI_SKIPPED_CLASSES, skipped_classes, GENAPI_SKIPPED_CLASSES_HINT, false);

	Dictionary libraries;
	libraries["godot-sandbox-programs"] = "libriscv/godot-sandbox-programs";
	register_setting_plain(PROGRAM_LIBRARIES, libraries, PROGRAM_LIBRARIES_HINT, false);
}

template <typename TType>
static TType get_setting(const char *p_setting) {
	const ProjectSettings *project_settings = ProjectSettings::get_singleton();
	const Variant setting_value = project_settings->get_setting_with_override(p_setting);
	const Variant::Type setting_type = setting_value.get_type();
	const Variant::Type expected_type = Variant(TType()).get_type();

	ERR_FAIL_COND_V(setting_type != expected_type, Variant());

	return setting_value;
}

bool SandboxProjectSettings::use_global_sandbox_names() {
	return get_setting<bool>(USE_GLOBAL_NAMES);
}

bool SandboxProjectSettings::get_docker_enabled() {
	return get_setting<bool>(DOCKER_ENABLED);
}

String SandboxProjectSettings::get_docker_path() {
	return get_setting<String>(DOCKER_PATH);
}

String SandboxProjectSettings::get_cmake_path() {
	String cmake_path = get_setting<String>(CMAKE_PATH);
	if (cmake_path.begins_with("user://")) {
		cmake_path = ProjectSettings::get_singleton()->globalize_path(cmake_path);
	}
	return cmake_path;
}

String SandboxProjectSettings::get_scons_path() {
	return get_setting<String>(SCONS_PATH);
}

String SandboxProjectSettings::get_zig_path() {
	return get_setting<String>(ZIG_PATH);
}

bool SandboxProjectSettings::async_compilation() {
	return get_setting<bool>(ASYNC_COMPILATION);
}

bool SandboxProjectSettings::use_native_types() {
	return get_setting<bool>(NATIVE_TYPES);
}

bool SandboxProjectSettings::debug_info() {
	return get_setting<bool>(DEBUG_INFO);
}

Array SandboxProjectSettings::get_global_defines() {
	return get_setting<Array>(GLOBAL_DEFINES);
}

bool SandboxProjectSettings::generate_runtime_api() {
	return get_setting<bool>(GENERATE_RUNTIME_API);
}
bool SandboxProjectSettings::generate_method_arguments() {
	return get_setting<bool>(METHOD_ARGUMENTS);
}
Array SandboxProjectSettings::generated_api_skipped_classes() {
	return get_setting<Array>(GENAPI_SKIPPED_CLASSES);
}

Dictionary SandboxProjectSettings::get_program_libraries() {
	return get_setting<Dictionary>(PROGRAM_LIBRARIES);
}

```

`src/sandbox_project_settings.h`:

```h
#pragma once

#include <godot_cpp/variant/string.hpp>

using namespace godot;

class SandboxProjectSettings {
public:
	static void register_settings();

	static bool use_global_sandbox_names();

	static bool get_docker_enabled();

	static String get_docker_path();
	static String get_zig_path();
	static String get_cmake_path();
	static String get_scons_path();

	static bool async_compilation();

	static bool use_native_types();

	static bool debug_info();

	static Array get_global_defines();

	static bool generate_runtime_api();
	static bool generate_method_arguments();
	static Array generated_api_skipped_classes();

	static Dictionary get_program_libraries();
};

```

`src/sandbox_restrictions.cpp`:

```cpp
#include "sandbox.h"

void Sandbox::set_restrictions(bool enable) {
	// It is allowed to enable restrictions during a VM call, but not to disable them.
	if (enable) {
		if (!m_just_in_time_allowed_classes.is_valid()) {
			m_just_in_time_allowed_classes = Callable(this, "restrictive_callback_function");
		}
		if (!m_just_in_time_allowed_objects.is_valid()) {
			m_just_in_time_allowed_objects = Callable(this, "restrictive_callback_function");
		}
		if (!m_just_in_time_allowed_methods.is_valid()) {
			m_just_in_time_allowed_methods = Callable(this, "restrictive_callback_function");
		}
		if (!m_just_in_time_allowed_properties.is_valid()) {
			m_just_in_time_allowed_properties = Callable(this, "restrictive_callback_function");
		}
		if (!m_just_in_time_allowed_resources.is_valid()) {
			m_just_in_time_allowed_resources = Callable(this, "restrictive_callback_function");
		}
	} else {
		if (this->is_in_vmcall()) {
			// Somehow a VM call is being made to disable restrictions, directly or indirectly.
			// That is a security risk, so we will not allow it.
			ERR_PRINT("Cannot disable restrictions during a VM call.");
			return;
		}
		m_just_in_time_allowed_classes = Callable();
		m_just_in_time_allowed_objects = Callable();
		m_just_in_time_allowed_methods = Callable();
		m_just_in_time_allowed_properties = Callable();
		m_just_in_time_allowed_resources = Callable();
	}
}

// clang-format off
bool Sandbox::get_restrictions() const {
	return m_just_in_time_allowed_classes.is_valid()
		&& m_just_in_time_allowed_objects.is_valid()
		&& m_just_in_time_allowed_methods.is_valid()
		&& m_just_in_time_allowed_properties.is_valid()
		&& m_just_in_time_allowed_resources.is_valid();
}
// clang-format on

void Sandbox::add_allowed_object(godot::Object *obj) {
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot add allowed objects during a VM call.");
		return;
	}
	m_allowed_objects.insert(obj);
}

void Sandbox::remove_allowed_object(godot::Object *obj) {
	m_allowed_objects.erase(obj);
}

void Sandbox::clear_allowed_objects() {
	// Clearing all allowed objects effectively disables the allowed objects list.
	// This is not allowed during a VM call.
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot clear allowed objects during a VM call.");
		return;
	}
	m_allowed_objects.clear();
}

void Sandbox::set_object_allowed_callback(const Callable &callback) {
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot set object allowed callback during a VM call.");
		return;
	}
	m_just_in_time_allowed_objects = callback;
}

void Sandbox::set_class_allowed_callback(const Callable &callback) {
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot set class allowed callback during a VM call.");
		return;
	}
	m_just_in_time_allowed_classes = callback;
}

bool Sandbox::is_allowed_class(const String &name) const {
	// If the callable is valid, call it to allow the user to decide
	if (m_just_in_time_allowed_classes.is_valid()) {
		return m_just_in_time_allowed_classes.call(this, name);
	}
	// If the callable is not valid, allow all classes
	return true;
}

void Sandbox::set_resource_allowed_callback(const Callable &callback) {
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot set resource allowed callback during a VM call.");
		return;
	}
	this->m_just_in_time_allowed_resources = callback;
}

bool Sandbox::is_allowed_resource(const String &path) const {
	// If the callable is valid, call it to allow the user to decide
	if (this->m_just_in_time_allowed_resources.is_valid()) {
		return this->m_just_in_time_allowed_resources.call(this, path);
	}
	// If the callable is not valid, allow all resources
	return true;
}

bool Sandbox::is_allowed_method(godot::Object *obj, const Variant &method) const {
	// If the callable is valid, call it to allow the user to decide
	if (m_just_in_time_allowed_methods.is_valid()) {
		return m_just_in_time_allowed_methods.call(this, obj, method);
	}
	// If the callable is not valid, allow all methods
	return true;
}

void Sandbox::set_method_allowed_callback(const Callable &callback) {
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot set method allowed callback during a VM call.");
		return;
	}
	m_just_in_time_allowed_methods = callback;
}

bool Sandbox::is_allowed_property(godot::Object *obj, const Variant &property, bool is_set) const {
	// If the callable is valid, call it to allow the user to decide
	if (m_just_in_time_allowed_properties.is_valid()) {
		return m_just_in_time_allowed_properties.call(this, obj, property, is_set);
	}
	// If the callable is not valid, allow all properties
	return true;
}

void Sandbox::set_property_allowed_callback(const Callable &callback) {
	if (is_in_vmcall()) {
		ERR_PRINT("Cannot set property allowed callback during a VM call.");
		return;
	}
	m_just_in_time_allowed_properties = callback;
}

```

`src/sandbox_shm.cpp`:

```cpp
#include "sandbox.h"
static constexpr bool VERBOSE_SHM = false;

gaddr_t Sandbox::share_array_internal(void* data, size_t bytes, bool allow_write)
{
	if (this->is_in_vmcall()) {
		ERR_PRINT("Cannot share array while a VM call is in progress.");
		return 0;
	}
#ifdef RISCV_LIBTCC
		if (this->m_bintr_automatic_nbit_as) {
			ERR_PRINT("Cannot share array while the program is in automatic N-bit mode. Virtual memory is disabled.");
			return 0;
		}
#endif

	const gaddr_t vaddr = this->m_shared_memory_base;
	const size_t  vsize = (bytes + 0xFFFLL) & ~0xFFFLL; // Align to 4KB
	// The address space is practically endless, so we can just keep allocating
	this->m_shared_memory_base += vsize;

	// Figure out the page-sized portion of the data
	const size_t valignsize = bytes & ~0xFFFLL; // Align to 4KB

	try {
		// If the data is larger than a page, we can directly insert it as non-owned memory
		if (valignsize > 0) {
			if constexpr (VERBOSE_SHM) {
				printf("Inserting %zu bytes of data into shared memory at address 0x%lx\n", valignsize, long(vaddr));
			}
			machine().memory.insert_non_owned_memory(
				vaddr, data, valignsize, riscv::PageAttributes{
					.read = true,
					.write = allow_write,
					.exec = false,
					.is_cow = false,
				});
		}
		// The remaining bytes must be copied into the end of shared memory
		const size_t remaining = bytes - valignsize;
		if (remaining > 0) {
			if constexpr (VERBOSE_SHM) {
				printf("Copying remaining %zu bytes of data into shared memory at address 0x%lx\n", remaining, long(vaddr + valignsize));
			}
			machine().memory.memcpy(vaddr + valignsize, static_cast<const uint8_t *>(data) + valignsize, remaining);
			machine().memory.set_page_attr(
				vaddr + valignsize, riscv::Page::size(), riscv::PageAttributes{
					.read = true,
					.write = allow_write,
					.exec = false,
				}); // Set the attributes for the remaining bytes
			// And the remaining bytes internal to the page are already zeroed (or guest-owned).
		}

		// Add the new range to the shared memory ranges (we need the real bytes)
		this->m_shared_memory_ranges.emplace_back(vaddr, bytes, data);
		return vaddr;

	} catch (const std::exception &e) {
		ERR_PRINT(String("Failed to share array: ") + e.what());

		// If we failed to share the array, we need to reset the base address
		this->m_shared_memory_base -= vsize;
		return 0;
	}
}

bool Sandbox::unshare_array(gaddr_t address) {
	if (this->is_in_vmcall()) {
		ERR_PRINT("Cannot unshare array while a VM call is in progress.");
		return false;
	}

	auto it = std::find_if(this->m_shared_memory_ranges.begin(), this->m_shared_memory_ranges.end(),
		[address](const auto &range) { return range.contains(address); });

	if (it == this->m_shared_memory_ranges.end()) {
		ERR_PRINT("Address is not in a shared memory range.");
		return false;
	}

	// Copy back the remaining bytes (overflow on the last page) if any
	const size_t remaining = it->size & (riscv::Page::size() - 1);
	if (remaining > 0) {
		if constexpr (VERBOSE_SHM) {
			printf("Copying remaining %zu bytes from shared memory at address 0x%lx\n", remaining, long(it->start + it->size - remaining));
		}
		// Get the base pointer to the shared memory range by getting the page data at start
		uint8_t *base_ptr = (uint8_t *)it->base_ptr;

		const gaddr_t offset = it->size - remaining;
		machine().copy_from_guest(
			base_ptr + offset, it->start + offset, remaining);
	}

	// Remove the range from the shared memory ranges
	if constexpr (VERBOSE_SHM) {
		printf("Freeing pages from shared memory range: start=0x%lx, size=0x%lx\n", long(it->start), long(it->size));
	}
	// Align up the size to page size
	const size_t aligned_size = (it->size + riscv::Page::size() - 1) & ~(riscv::Page::size() - 1);
	// Free the pages in the range
	machine().memory.free_pages(it->start, aligned_size);

	this->m_shared_memory_ranges.erase(it);
	return true;
}


gaddr_t Sandbox::share_byte_array(bool allow_write, const PackedByteArray &array) {
	return this->share_array_internal((void *)array.ptr(), array.size(), allow_write);
}
gaddr_t Sandbox::share_float32_array(bool allow_write, const PackedFloat32Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(float), allow_write);
}
gaddr_t Sandbox::share_float64_array(bool allow_write, const PackedFloat64Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(double), allow_write);
}
gaddr_t Sandbox::share_int32_array(bool allow_write, const PackedInt32Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(int32_t), allow_write);
}
gaddr_t Sandbox::share_int64_array(bool allow_write, const PackedInt64Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(int64_t), allow_write);
}
gaddr_t Sandbox::share_vec2_array(bool allow_write, const PackedVector2Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(Vector2), allow_write);
}
gaddr_t Sandbox::share_vec3_array(bool allow_write, const PackedVector3Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(Vector3), allow_write);
}
gaddr_t Sandbox::share_vec4_array(bool allow_write, const PackedVector4Array &array) {
	return this->share_array_internal((void *)array.ptr(), array.size() * sizeof(Vector4), allow_write);
}

```

`src/sandbox_syscalls.cpp`:

```cpp
#include "guest_datatypes.h"
#include "syscalls.h"

#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/node2d.hpp>
#include <godot_cpp/classes/node3d.hpp>
#include <godot_cpp/classes/packed_scene.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/scene_tree.hpp>
#include <godot_cpp/classes/timer.hpp>
#include <godot_cpp/variant/utility_functions.hpp>
#include <godot_cpp/variant/variant.hpp>
//#define ENABLE_SYSCALL_TRACE 1
#include "syscalls_helpers.hpp"
#include <libriscv/rv32i_instr.hpp>

#define PENALIZE(x) \
	if (!emu.get_profiling()) { \
		machine.penalize(x); \
	}

namespace riscv {
extern std::unordered_map<std::string, std::function<uint64_t()>> global_singleton_list;

godot::Object *get_object_from_address(const Sandbox &emu, uint64_t addr) {
	SYS_TRACE("get_object_from_address", addr);
	godot::Object *obj = (godot::Object *)uintptr_t(addr);
	if (UNLIKELY(obj == nullptr)) {
		ERR_PRINT("Object is Null");
		throw std::runtime_error("Object is Null");
	} else if (UNLIKELY(!emu.is_scoped_object(obj))) {
		char buffer[256];
		const uintptr_t obj_uint = reinterpret_cast<uintptr_t>(obj);
		if (obj_uint < 0x1000) {
			snprintf(buffer, sizeof(buffer), "Object is not found, but likely a Variant with index: %lu", long(obj_uint));
			ERR_PRINT(buffer);
			throw std::runtime_error(buffer);
		}
		snprintf(buffer, sizeof(buffer), "Object is not scoped: %p", obj);
		ERR_PRINT(buffer);
		throw std::runtime_error(buffer);
	}
	return obj;
}
inline godot::Node *get_node_from_address(const Sandbox &emu, uint64_t addr) {
	SYS_TRACE("get_node_from_address", addr);
	godot::Object *obj = get_object_from_address(emu, addr);
	godot::Node *node = godot::Object::cast_to<godot::Node>(obj);
	if (UNLIKELY(node == nullptr)) {
		ERR_PRINT("Object is not a Node: " + obj->get_class());
		throw std::runtime_error("Object was not a Node");
	}
	return node;
}

static inline Variant object_callp(godot::Object *obj, const Variant **args, int argc) {
	static GDExtensionMethodBindPtr mtd = internal::gdextension_interface_classdb_get_method_bind(Object::get_class_static()._native_ptr(), StringName("call")._native_ptr(), 3400424181);
	GDExtensionCallError error;
	Variant ret;
	internal::gdextension_interface_object_method_bind_call(mtd, obj->_owner, reinterpret_cast<GDExtensionConstVariantPtr *>(args), argc, &ret, &error);
	return ret;
}

static inline Variant object_call(Sandbox &emu, godot::Object *obj, const Variant &method, const GuestVariant *args, int argc) {
	SYS_TRACE("object_call", method, argc);
	std::array<Variant, 8> vstorage;
	std::array<const Variant *, 9> vargs; // 8 is the maximum number of arguments we will accept.
	vargs[0] = &method;
	for (int i = 0; i < argc; i++) {
		if (args[i].is_scoped_variant()) {
			vargs[i + 1] = args[i].toVariantPtr(emu);
		} else {
			vstorage[i] = args[i].toVariant(emu);
			vargs[i + 1] = &vstorage[i];
		}
	}
	return object_callp(obj, vargs.data(), argc + 1);
}

APICALL(api_print) {
	auto [array, len] = machine.sysargs<gaddr_t, unsigned>();
	Sandbox &emu = riscv::emu(machine);

	if (len >= 64) {
		ERR_PRINT("print(): Too many Variants to print");
		throw std::runtime_error("print(): Too many Variants to print");
	}
	const GuestVariant *array_ptr = machine.memory.memarray<GuestVariant>(array, len);

	// We really want print_internal to be a public function.
	for (unsigned i = 0; i < len; i++) {
		const GuestVariant &var = array_ptr[i];
		if (var.is_scoped_variant())
			emu.print(*var.toVariantPtr(emu));
		else
			emu.print(var.toVariant(emu));
	}
}

APICALL(api_vcall) {
	auto [vp, method, mlen, args_ptr, args_size, vret_addr] = machine.sysargs<GuestVariant *, gaddr_t, unsigned, gaddr_t, gaddr_t, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	SYS_TRACE("vcall", method, mlen, args_ptr, args_size, vret_addr);

	if (args_size > 8) {
		ERR_PRINT("Variant::call(): Too many arguments");
		throw std::runtime_error("Variant::call(): Too many arguments");
	}

	const GuestVariant *args = machine.memory.memarray<GuestVariant>(args_ptr, args_size);
	StringName method_sn;
	std::string_view method_sv = machine.memory.memview(method, mlen + 1); // Include null terminator.
	if (method_sv.back() == '\0') {
		method_sn = StringName(method_sv.data());
	} else {
		method_sn = String::utf8(method_sv.data(), mlen);
	}

	Variant ret;

	if (vp->type == Variant::OBJECT) {
		godot::Object *obj = get_object_from_address(emu, vp->v.i);

		// Check if the method is allowed.
		if (!emu.is_allowed_method(obj, method_sn)) {
			ERR_PRINT("Variant::call(): Method not allowed: " + method_sn);
			throw std::runtime_error("Variant::call(): Method not allowed: " + std::string(method_sv));
		}

		ret = object_call(emu, obj, method_sn, args, args_size);
	} else {
		std::array<Variant, 8> vargs;
		std::array<const Variant *, 8> argptrs;
		for (size_t i = 0; i < args_size; i++) {
			if (args[i].is_scoped_variant()) {
				argptrs[i] = args[i].toVariantPtr(emu);
			} else {
				vargs[i] = args[i].toVariant(emu);
				argptrs[i] = &vargs[i];
			}
		}

		GDExtensionCallError error;
		if (vp->is_scoped_variant()) {
			Variant *vcall = const_cast<Variant *>(vp->toVariantPtr(emu));
			//internal::gdextension_interface_variant_call(vcall, &method_sn, reinterpret_cast<GDExtensionConstVariantPtr *>(&argptrs[0]), args_size, &ret, &error);
			vcall->callp(method_sn, argptrs.data(), args_size, ret, error);
		} else {
			Variant vcall = vp->toVariant(emu);
			//internal::gdextension_interface_variant_call(&vcall, &method_sn, reinterpret_cast<GDExtensionConstVariantPtr *>(&argptrs[0]), args_size, &ret, &error);
			vcall.callp(method_sn, argptrs.data(), args_size, ret, error);
		}
	}
	// Create a new Variant with the result, if any.
	if (vret_addr != 0) {
		GuestVariant *vret = machine.memory.memarray<GuestVariant>(vret_addr, 1);
		vret->create(emu, std::move(ret));
	}
}

APICALL(api_veval) {
	auto [op, ap, bp, retp] = machine.sysargs<int, GuestVariant *, GuestVariant *, GuestVariant *>();
	auto &emu = riscv::emu(machine);
	SYS_TRACE("veval", op, ap, bp, retp);

	// Special case for comparing objects.
	if (ap->type == Variant::OBJECT && bp->type == Variant::OBJECT) {
		// Special case for equality, allowing invalid objects to be compared.
		if (op == static_cast<int>(Variant::Operator::OP_EQUAL)) {
			machine.set_result(false);
			retp->set(emu, Variant(ap->v.i == bp->v.i));
			return;
		}
		godot::Object *a = get_object_from_address(emu, ap->v.i);
		godot::Object *b = get_object_from_address(emu, bp->v.i);
		bool valid = false;
		Variant ret;
		Variant::evaluate(static_cast<Variant::Operator>(op), a, b, ret, valid);

		machine.set_result(valid);
		retp->set(emu, ret, false);
		return;
	}

	bool valid = false;
	Variant ret;
	Variant::evaluate(static_cast<Variant::Operator>(op), ap->toVariant(emu), bp->toVariant(emu), ret, valid);
	//WARN_PRINT(String("veval: ") + String(ap->toVariant(emu)) + " " + itos(op) + " " + String(bp->toVariant(emu)) + " = " + String(ret));

	machine.set_result(valid);
	retp->create(emu, std::move(ret));
}

APICALL(api_vcreate) {
	auto [vp, type, method, gdata] = machine.sysargs<GuestVariant *, Variant::Type, int, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000);
	SYS_TRACE("vcreate", vp, type, method, gdata);

	switch (type) {
		case Variant::STRING:
		case Variant::STRING_NAME:
		case Variant::NODE_PATH: { // From std::string
			String godot_str;
			if (method == 0) {
				const CppString *str = machine.memory.memarray<const CppString>(gdata, 1);
				godot_str = to_godot_string(str, machine);
			} else if (method == 1) { // const char*, size_t
				const struct Buffer {
					gaddr_t data;
					gaddr_t size;
				} *buffer = machine.memory.memarray<const Buffer>(gdata, 1);
				// View the string from guest memory.
				std::string_view view = machine.memory.memview(buffer->data, buffer->size);
				godot_str = String::utf8(view.data(), view.size());
			} else if (method == 2) { // From std::u32string
				const GuestStdU32String *str = machine.memory.memarray<const GuestStdU32String>(gdata, 1);
				godot_str = str->to_godot_string(machine);
			} else if (method == 3) { // const int32_t*, size_t
				const struct Buffer {
					gaddr_t data;
					gaddr_t size;
				} *buffer = machine.memory.memarray<const Buffer>(gdata, 1);
				// View the string from guest memory.
				const int32_t* chars = machine.memory.memarray<const int32_t>(buffer->data, buffer->size);
				std::u32string str(chars, chars + buffer->size);
				godot_str = String(str.data());
			} else {
				ERR_PRINT("vcreate: Unsupported method for Variant::STRING");
				throw std::runtime_error("vcreate: Unsupported method for Variant::STRING: " + std::to_string(method));
			}
			// Create a new Variant with the string, modify vp.
			unsigned idx = emu.create_scoped_variant(Variant(std::move(godot_str)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::ARRAY: {
			// Create a new empty? array, assign to vp.
			Array a;
			if (gdata != 0x0) {
				if (method == -1) {
					// Copy std::vector<Variant> from guest memory.
					const CppVector<GuestVariant> *vec = machine.memory.memarray<const CppVector<GuestVariant>>(gdata, 1);
					for (size_t i = 0; i < vec->size(); i++) {
						const GuestVariant &v = vec->at(machine, i);
						a.push_back(std::move(v.toVariant(emu)));
					}
				} else if (method >= 0) {
					// Get elements from method argument.
					const unsigned size = method;
					// Copy array of Variants from guest memory.
					const GuestVariant *gvec = machine.memory.memarray<const GuestVariant>(gdata, size);
					for (int i = 0; i < size; i++) {
						a.push_back(gvec[i].toVariant(emu));
					}
				} else {
					// In order to support future methods, we shouldn't throw an error here.
					WARN_PRINT("vcreate: Unsupported method for Variant::ARRAY: " + itos(method));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::DICTIONARY: {
			// Create a new empty? dictionary, assign to vp.
			Dictionary d;
			const unsigned size = method;
			if (gdata == 0x0 && size > 0) {
				ERR_PRINT("vcreate: gdata is null for non-empty Dictionary");
				throw std::runtime_error("vcreate: gdata is null for non-empty Dictionary");
			} else if (size > 1024) {
				ERR_PRINT("vcreate: Dictionary size too large: " + itos(size));
				throw std::runtime_error("vcreate: Dictionary size too large: " + std::to_string(size));
			}
			const GuestVariant *gdata_ptr = machine.memory.memarray<const GuestVariant>(gdata, size);
			for (unsigned i = 0; i < size; i += 2) {
				const GuestVariant &gkey = gdata_ptr[i];
				const GuestVariant &gval = gdata_ptr[i + 1];
				d.set(gkey.toVariant(emu), gval.toVariant(emu));
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(d)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_BYTE_ARRAY: {
			PackedByteArray a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<uint8_t> from guest memory.
					const CppVector<uint8_t> *gvec = machine.memory.memarray<const CppVector<uint8_t>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const uint8_t *ptr = machine.memory.memarray<const uint8_t>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method);
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_FLOAT32_ARRAY: {
			PackedFloat32Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<float> from guest memory.
					const CppVector<float> *gvec = machine.memory.memarray<const CppVector<float>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const float *ptr = machine.memory.memarray<const float>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(float));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_FLOAT64_ARRAY: {
			PackedFloat64Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<double> from guest memory.
					const CppVector<double> *gvec = machine.memory.memarray<const CppVector<double>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const double *ptr = machine.memory.memarray<const double>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(double));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_INT32_ARRAY: {
			PackedInt32Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<int32_t> from guest memory.
					const CppVector<int32_t> *gvec = machine.memory.memarray<const CppVector<int32_t>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const int32_t *ptr = machine.memory.memarray<const int32_t>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(int32_t));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_INT64_ARRAY: {
			PackedInt64Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<int64_t> from guest memory.
					const CppVector<int64_t> *gvec = machine.memory.memarray<const CppVector<int64_t>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const int64_t *ptr = machine.memory.memarray<const int64_t>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(int64_t));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_VECTOR2_ARRAY: {
			PackedVector2Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<Vector2> from guest memory.
					const CppVector<Vector2> *gvec = machine.memory.memarray<const CppVector<Vector2>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const Vector2 *ptr = machine.memory.memarray<const Vector2>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(Vector2));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_VECTOR3_ARRAY: {
			PackedVector3Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<Vector3> from guest memory.
					const CppVector<Vector3> *gvec = machine.memory.memarray<const CppVector<Vector3>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const Vector3 *ptr = machine.memory.memarray<const Vector3>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(Vector3));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_VECTOR4_ARRAY: {
			PackedVector4Array a;
			if (gdata != 0x0) {
				if (method < 0) {
					// Copy std::vector<Vector4> from guest memory.
					const CppVector<Vector4> *gvec = machine.memory.memarray<const CppVector<Vector4>>(gdata, 1);
					a.resize(gvec->size());
					std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
				} else {
					// Method is the buffer length.
					a.resize(method);
					// Copy the buffer from guest memory.
					const Vector4 *ptr = machine.memory.memarray<const Vector4>(gdata, method);
					std::memcpy(a.ptrw(), ptr, method * sizeof(Vector4));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_COLOR_ARRAY: {
			PackedColorArray a;
			if (gdata != 0x0) {
				// Copy std::vector<Color> from guest memory.
				const CppVector<Color> *gvec = machine.memory.memarray<const CppVector<Color>>(gdata, 1);
				a.resize(gvec->size());
				std::memcpy(a.ptrw(), gvec->as_array(machine), gvec->size_bytes());
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		case Variant::PACKED_STRING_ARRAY: {
			PackedStringArray a;
			if (gdata != 0x0) {
				// Copy std::vector<String> from guest memory.
				if (method == -1) {
					const CppVector<CppString> *gvec = machine.memory.memarray<const CppVector<CppString>>(gdata, 1);
					const CppString *str_array = gvec->as_array(machine);
					for (size_t i = 0; i < gvec->size(); i++) {
						a.push_back(to_godot_string(&str_array[i], machine));
					}
				} else if (method == -2) {
					// libc++ std::string implementation.
					struct Buffer {
						gaddr_t ptr;
						gaddr_t size;
					};
					const CppVector<Buffer> *gvec = machine.memory.memarray<const CppVector<Buffer>>(gdata, 1);
					const Buffer *buffers = gvec->as_array(machine);
					for (size_t i = 0; i < gvec->size(); i++) {
						const Buffer &buf = buffers[i];
						std::string_view view = machine.memory.memview(buf.ptr, buf.size);
						a.push_back(String::utf8(view.data(), view.size()));
					}
				} else {
					ERR_PRINT("vcreate: Unsupported method for Variant::PACKED_STRING_ARRAY");
					throw std::runtime_error("vcreate: Unsupported method for Variant::PACKED_STRING_ARRAY: " + std::to_string(method));
				}
			}
			unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
			vp->type = type;
			vp->v.i = idx;
		} break;
		default:
			ERR_PRINT("Unsupported Variant type for Variant::create()");
			throw std::runtime_error("Unsupported Variant type for Variant::create(): " + std::string(GuestVariant::type_name(type)));
	}
}

APICALL(api_vfetch) {
	auto [index, gdata, method] = machine.sysargs<unsigned, gaddr_t, int>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000);
	SYS_TRACE("vfetch", index, gdata, method);

	// Find scoped Variant and copy data into gdata.
	std::optional<const Variant *> opt = emu.get_scoped_variant(index);
	if (opt.has_value()) {
		const godot::Variant &var = *opt.value();
		switch (var.get_type()) {
			case Variant::STRING:
			case Variant::STRING_NAME:
			case Variant::NODE_PATH: {
				if (method == 0) { // std::string
					auto u8str = var.operator String().utf8();
					CppString *gstr = machine.memory.memarray<CppString>(gdata, 1);
					gstr->set_string(machine, gdata, u8str.ptr(), u8str.length());
				} else if (method == 1) { // const char*, size_t struct
					auto u8str = var.operator String().utf8();
					struct Buffer {
						gaddr_t ptr;
						gaddr_t size;
					} *gstr = machine.memory.memarray<Buffer>(gdata, 1);
					gstr->ptr  = machine.arena().malloc(u8str.length());
					gstr->size = u8str.length();
					machine.memory.memcpy(gstr->ptr, u8str.ptr(), u8str.length());
				} else if (method == 2) { // std::u32string
					auto u32str = var.operator String();
					auto *gstr = machine.memory.memarray<GuestStdU32String>(gdata, 1);
					gstr->set_string(machine, gdata, u32str.ptr(), u32str.length());
				} else {
					ERR_PRINT("vfetch: Unsupported method for Variant::STRING");
					throw std::runtime_error("vfetch: Unsupported method for Variant::STRING");
				}
				break;
			}
			case Variant::PACKED_BYTE_ARRAY: {
				CppVector<uint8_t> *gvec = machine.memory.memarray<CppVector<uint8_t>>(gdata, 1);
				auto arr = var.operator PackedByteArray();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_FLOAT32_ARRAY: {
				CppVector<float> *gvec = machine.memory.memarray<CppVector<float>>(gdata, 1);
				auto arr = var.operator PackedFloat32Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_FLOAT64_ARRAY: {
				CppVector<double> *gvec = machine.memory.memarray<CppVector<double>>(gdata, 1);
				auto arr = var.operator PackedFloat64Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_INT32_ARRAY: {
				CppVector<int32_t> *gvec = machine.memory.memarray<CppVector<int32_t>>(gdata, 1);
				auto arr = var.operator PackedInt32Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_INT64_ARRAY: {
				CppVector<int64_t> *gvec = machine.memory.memarray<CppVector<int64_t>>(gdata, 1);
				auto arr = var.operator PackedInt64Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_VECTOR2_ARRAY: {
				CppVector<Vector2> *gvec = machine.memory.memarray<CppVector<Vector2>>(gdata, 1);
				auto arr = var.operator PackedVector2Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_VECTOR3_ARRAY: {
				CppVector<Vector3> *gvec = machine.memory.memarray<CppVector<Vector3>>(gdata, 1);
				auto arr = var.operator PackedVector3Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_VECTOR4_ARRAY: {
				CppVector<Vector4> *gvec = machine.memory.memarray<CppVector<Vector4>>(gdata, 1);
				auto arr = var.operator PackedVector4Array();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_COLOR_ARRAY: {
				CppVector<Color> *gvec = machine.memory.memarray<CppVector<Color>>(gdata, 1);
				auto arr = var.operator PackedColorArray();
				gvec->assign(machine, arr.ptr(), arr.size());
				break;
			}
			case Variant::PACKED_STRING_ARRAY: {
				auto arr = var.operator PackedStringArray();
				if (method == 0) {
					CppVector<CppString> *gvec = machine.memory.memarray<CppVector<CppString>>(gdata, 1);
					gvec->resize(machine, arr.size());
					for (unsigned i = 0; i < arr.size(); i++) {
						auto u8str = arr[i].utf8();
						const gaddr_t self = gvec->address_at(i);
						gvec->at(machine, i).set_string(machine, self, std::string_view(u8str.ptr(), u8str.length()));
					}
				} else if (method == 1) {
					// libc++ std::string implementation.
					struct Buffer {
						gaddr_t ptr;
						gaddr_t size;
					};
					CppVector<Buffer> *gvec = machine.memory.memarray<CppVector<Buffer>>(gdata, 1);
					gvec->reserve(machine, arr.size());
					for (unsigned i = 0; i < arr.size(); i++) {
						auto u8str = arr[i].utf8();
						Buffer gb;
						gb.ptr  = machine.arena().malloc(u8str.length());
						gb.size = u8str.length();
						machine.memory.memcpy(gb.ptr, u8str.ptr(), u8str.length());
						gvec->push_back(machine, gb);
					}
				} else {
					ERR_PRINT("vfetch: Unsupported method for Variant::PACKED_STRING_ARRAY");
					throw std::runtime_error("vfetch: Unsupported method for Variant::PACKED_STRING_ARRAY");
				}
				break;
			}
			default:
				ERR_PRINT("vfetch: Cannot fetch value into guest for Variant type");
				throw std::runtime_error("vfetch: Cannot fetch value into guest for Variant type");
		}
	} else {
		ERR_PRINT("vfetch: Variant is not scoped");
		throw std::runtime_error("vfetch: Variant is not scoped");
	}
}

APICALL(api_vclone) {
	auto [vp, vret_addr] = machine.sysargs<GuestVariant *, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000);
	SYS_TRACE("vclone", vp, vret);

	if (vret_addr != 0) {
		// Find scoped Variant and clone it.
		std::optional<const Variant *> var = emu.get_scoped_variant(vp->v.i);
		if (var.has_value()) {
			const unsigned index = emu.create_scoped_variant(var.value()->duplicate());
			// Duplicate the Variant and store the index in the guest memory.
			GuestVariant *vret = machine.memory.memarray<GuestVariant>(vret_addr, 1);
			vret->type = var.value()->get_type();
			vret->v.i = index;
		} else {
			ERR_PRINT("vclone: Variant is not scoped");
			throw std::runtime_error("vclone: Variant is not scoped");
		}
	} else {
		// Duplicate or move the Variant into permanent storage (m_level[0]).
		const unsigned idx = vp->v.i;
		unsigned new_idx = emu.create_permanent_variant(idx);
		// Update the Variant with the new index.
		vp->v.i = new_idx;
	}
}

APICALL(api_vstore) {
	auto [vidx, type, gdata, gsize] = machine.sysargs<unsigned *, Variant::Type, gaddr_t, gaddr_t>();
	auto &emu = riscv::emu(machine);
	PENALIZE(10'000);
	SYS_TRACE("vstore", vidx, type, gdata, gsize);
	if (gsize > 16'777'216) {
		ERR_PRINT("vstore: Array size is too large: " + itos(gsize));
		throw std::runtime_error("vstore: Array size is too large: " + std::to_string(gsize));
	}

	// Find scoped Variant and store data from guest memory.
	switch (type) {
		case Variant::PACKED_BYTE_ARRAY: {
			PackedByteArray arr;
			// Copy the array from guest memory into the Variant.
			uint8_t *data = machine.memory.memarray<uint8_t>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize);
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_FLOAT32_ARRAY: {
			PackedFloat32Array arr;
			// Copy the array from guest memory into the Variant.
			float *data = machine.memory.memarray<float>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(float));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_FLOAT64_ARRAY: {
			PackedFloat64Array arr;
			// Copy the array from guest memory into the Variant.
			double *data = machine.memory.memarray<double>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(double));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_INT32_ARRAY: {
			PackedInt32Array arr;
			// Copy the array from guest memory into the Variant.
			int32_t *data = machine.memory.memarray<int32_t>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(int32_t));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_INT64_ARRAY: {
			PackedInt64Array arr;
			// Copy the array from guest memory into the Variant.
			int64_t *data = machine.memory.memarray<int64_t>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(int64_t));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_VECTOR2_ARRAY: {
			PackedVector2Array arr;
			// Copy the array from guest memory into the Variant.
			auto *data = machine.memory.memarray<Vector2>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(Vector2));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_VECTOR3_ARRAY: {
			PackedVector3Array arr;
			// Copy the array from guest memory into the Variant.
			auto *data = machine.memory.memarray<Vector3>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(Vector3));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_VECTOR4_ARRAY: {
			PackedVector4Array arr;
			// Copy the array from guest memory into the Variant.
			auto *data = machine.memory.memarray<Vector4>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(Vector4));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_COLOR_ARRAY: {
			PackedColorArray arr;
			// Copy the array from guest memory into the Variant.
			auto *data = machine.memory.memarray<Color>(gdata, gsize);
			arr.resize(gsize);
			std::memcpy(arr.ptrw(), data, gsize * sizeof(Color));
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		case Variant::PACKED_STRING_ARRAY: {
			PackedStringArray arr;
			if (gsize & 0x80000000) {
				// Work-around for libc++ std::string implementation.
				struct Buffer {
					gaddr_t ptr;
					gaddr_t size;
				};
				gsize &= 0x7FFFFFFF;
				auto *buffers = machine.memory.memarray<Buffer>(gdata, gsize);
				arr.resize(gsize);
				for (unsigned i = 0; i < gsize; i++) {
					std::string_view view = machine.memory.memview(buffers[i].ptr, buffers[i].size);
					arr.set(i, String::utf8(view.data(), view.size()));
				}
			} else {
				// Copy the array from guest memory into the Variant.
				const CppString *data = machine.memory.memarray<CppString>(gdata, gsize);
				arr.resize(gsize);
				for (unsigned i = 0; i < gsize; i++) {
					arr.set(i, to_godot_string(&data[i], machine));
				}
			}
			*vidx = emu.create_scoped_variant(Variant(std::move(arr)));
			break;
		}
		default:
			ERR_PRINT("vstore: Cannot store value for Variant type");
			throw std::runtime_error("vstore: Cannot store value for Variant type " + std::to_string(type));
	}
}

APICALL(api_vassign) {
	auto [a_idx, b_idx] = machine.sysargs<unsigned, unsigned>();
	auto &emu = riscv::emu(machine);
	PENALIZE(150'000);
	SYS_TRACE("vassign", a_idx, b_idx);

	if (int32_t(a_idx) == INT32_MIN) {
		machine.set_result(b_idx); // Assign b to a directly when a is "empty".
		return;
	}

	// Find scoped Variants and assign the value of b to a.
	std::optional<const Variant *> a_opt = emu.get_scoped_variant(a_idx);
	std::optional<const Variant *> b_opt = emu.get_scoped_variant(b_idx);
	if (a_opt.has_value() && b_opt.has_value()) {
		const Variant *va = *a_opt;
		const Variant *vb = *b_opt;
		// XXX: This might be too strict. Assigning arbitrarily between different types is allowed in GDScript.
		if (va->get_type() != Variant::NIL && va->get_type() != vb->get_type()) {
			ERR_PRINT("vassign: Variant types do not match");
			throw std::runtime_error("vassign: Variant types do not match: " + std::to_string(va->get_type()) + " != " + std::to_string(vb->get_type()));
		}

		// Try assigning the value of b to a.
		unsigned res_idx = emu.try_reuse_assign_variant(b_idx, *va, a_idx, *vb);
		machine.set_result(res_idx);
	} else {
		ERR_PRINT("vassign: Variants were not scoped");
		throw std::runtime_error("vassign: Variants were not scoped");
	}
}

APICALL(api_get_obj) {
	auto [name] = machine.sysargs<std::string>();
	auto &emu = riscv::emu(machine);
	PENALIZE(150'000);
	SYS_TRACE("get_obj", String::utf8(name.c_str(), name.size()));

	// Objects retrieved by name are named globals, eg. "Engine", "Input", "Time",
	// which are also their class names. As such, we can restrict access using
	// the allowed_classes list in the Sandbox.
	if (!emu.is_allowed_class(String::utf8(name.c_str(), name.size()))) {
		ERR_PRINT("Class is not allowed");
		machine.set_result(0);
		return;
	}

	// Find allowed object by name and get its address from a lambda.
	auto it = global_singleton_list.find(name);
	if (it != global_singleton_list.end()) {
		auto obj = it->second();
		emu.add_scoped_object(reinterpret_cast<godot::Object *>(obj));
		machine.set_result(obj);
		return;
	}
	// Special case for SceneTree.
	if (name == "SceneTree") {
		// Get the current SceneTree.
		auto *owner_node = emu.get_tree_base();
		if (owner_node == nullptr) {
			ERR_PRINT("Sandbox has no parent Node");
			machine.set_result(0);
			return;
		}
		SceneTree *tree = owner_node->get_tree();
		emu.add_scoped_object(tree);
		machine.set_result(uint64_t(uintptr_t(tree)));
	} else {
		ERR_PRINT(("Unknown or inaccessible object: " + name).c_str());
		machine.set_result(0);
	}
}

APICALL(api_obj) {
	auto [op, addr, gvar] = machine.sysargs<int, uint64_t, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(250'000); // Costly Object operations.
	SYS_TRACE("obj_op", op, addr, gvar);

	godot::Object *obj = get_object_from_address(emu, addr);

	switch (Object_Op(op)) {
		case Object_Op::GET_METHOD_LIST: {
			CppVector<CppString> *vec = machine.memory.memarray<CppVector<CppString>>(gvar, 1);
			// XXX: vec->free(machine);
			auto methods = obj->get_method_list();
			vec->resize(machine, methods.size());
			for (size_t i = 0; i < methods.size(); i++) {
				Dictionary dict = methods[i].operator godot::Dictionary();
				auto name = String(dict["name"]).utf8();
				const gaddr_t self = vec->address_at(i);
				vec->at(machine, i).set_string(machine, self, name.ptr(), name.length());
			}
		} break;
		case Object_Op::GET: { // Get a property of the object.
			GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 2);
			String name = var[0].toVariant(emu).operator String();
			if (UNLIKELY(!emu.is_allowed_property(obj, name, false))) {
				ERR_PRINT("Banned property accessed: " + name);
				throw std::runtime_error("Banned property accessed");
			}
			var[1].create(emu, obj->get(name));
		} break;
		case Object_Op::SET: { // Set a property of the object.
			GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 2);
			String name = var[0].toVariant(emu).operator String();
			if (UNLIKELY(!emu.is_allowed_property(obj, name, true))) {
				ERR_PRINT("Banned property set: " + name);
				throw std::runtime_error("Banned property set");
			}
			obj->set(name, var[1].toVariant(emu));
		} break;
		case Object_Op::GET_PROPERTY_LIST: {
			CppVector<CppString> *vec = machine.memory.memarray<CppVector<CppString>>(gvar, 1);
			// XXX: vec->free(machine);
			TypedArray<Dictionary> properties = obj->get_property_list();
			vec->resize(machine, properties.size());
			for (size_t i = 0; i < properties.size(); i++) {
				Dictionary dict = properties[i].operator godot::Dictionary();
				auto name = String(dict["name"]).utf8();
				const gaddr_t self = vec->address_at(i);
				vec->at(machine, i).set_string(machine, self, name.ptr(), name.length());
			}
		} break;
		case Object_Op::CONNECT: {
			GuestVariant *vars = machine.memory.memarray<GuestVariant>(gvar, 3);
			godot::Object *target = get_object_from_address(emu, vars[0].v.i);
			Callable callable = Callable(target, vars[2].toVariant(emu).operator String());
			obj->connect(vars[1].toVariant(emu).operator String(), callable);
		} break;
		case Object_Op::DISCONNECT: {
			GuestVariant *vars = machine.memory.memarray<GuestVariant>(gvar, 3);
			godot::Object *target = get_object_from_address(emu, vars[0].v.i);
			auto callable = Callable(target, vars[2].toVariant(emu).operator String());
			obj->disconnect(vars[1].toVariant(emu).operator String(), callable);
		} break;
		case Object_Op::GET_SIGNAL_LIST: {
			CppVector<CppString> *vec = machine.memory.memarray<CppVector<CppString>>(gvar, 1);
			TypedArray<Dictionary> signals = obj->get_signal_list();
			vec->resize(machine, signals.size());
			for (size_t i = 0; i < signals.size(); i++) {
				Dictionary dict = signals[i].operator godot::Dictionary();
				auto name = String(dict["name"]).utf8();
				const gaddr_t self = vec->address_at(i);
				vec->at(machine, i).set_string(machine, self, std::string_view(name.ptr(), name.length()));
			}
		} break;
		default:
			throw std::runtime_error("Invalid Object operation: " + std::to_string(op));
	}
}

APICALL(api_obj_property_get) {
	auto [addr, method, vret] = machine.sysargs<uint64_t, std::string_view, GuestVariant *>();
	auto &emu = riscv::emu(machine);
	PENALIZE(150'000);
	SYS_TRACE("obj_property_get", addr, method, vret);

	godot::Object *obj = nullptr;
	if ((uint16_t)addr != addr) {
		obj = get_object_from_address(emu, addr);
	} else {
		// It's likely a Variant index
		std::optional<const Variant *> var = emu.get_scoped_variant(uint32_t(addr));
		if (var.has_value()) {
			if (var.value()->get_type() != Variant::OBJECT) {
				ERR_PRINT("api_obj_property_get: Variant is not an Object");
				throw std::runtime_error("api_obj_property_get: Variant is not an Object");
			}
			obj = var.value()->operator godot::Object *();
		} else {
			ERR_PRINT("api_obj_property_get: Variant is not scoped");
			throw std::runtime_error("api_obj_property_get: Variant is not scoped");
		}
	}
	String prop_name = String::utf8(method.data(), method.size());

	if (UNLIKELY(!emu.is_allowed_property(obj, prop_name, false))) {
		ERR_PRINT("Banned property accessed: " + prop_name);
		throw std::runtime_error("Banned property accessed: " + std::string(prop_name.utf8()));
	}

	vret->create(emu, obj->get(prop_name));
}

APICALL(api_obj_property_set) {
	auto [addr, method, g_value] = machine.sysargs<uint64_t, std::string_view, const GuestVariant *>();
	auto &emu = riscv::emu(machine);
	PENALIZE(150'000);
	SYS_TRACE("obj_property_set", addr, method, value);

	godot::Object *obj = nullptr;
	if ((uint16_t)addr != addr) {
		obj = get_object_from_address(emu, addr);
	} else {
		// It's likely a Variant index
		std::optional<const Variant *> var = emu.get_scoped_variant(uint32_t(addr));
		if (var.has_value()) {
			if (var.value()->get_type() != Variant::OBJECT) {
				ERR_PRINT("api_obj_property_get: Variant is not an Object");
				throw std::runtime_error("api_obj_property_get: Variant is not an Object");
			}
			obj = var.value()->operator godot::Object *();
		} else {
			ERR_PRINT("api_obj_property_get: Variant is not scoped");
			throw std::runtime_error("api_obj_property_get: Variant is not scoped");
		}
	}
	String prop_name = String::utf8(method.data(), method.size());

	if (UNLIKELY(!emu.is_allowed_property(obj, prop_name, true))) {
		ERR_PRINT("Banned property set: " + prop_name);
		throw std::runtime_error("Banned property set: " + std::string(prop_name.utf8()));
	}

	obj->set(prop_name, g_value->toVariant(emu));
}

APICALL(api_obj_callp) {
	auto [addr, g_method, g_method_len, deferred, vret_ptr, args_addr, args_size] = machine.sysargs<uint64_t, gaddr_t, unsigned, bool, gaddr_t, gaddr_t, unsigned>();
	auto &emu = riscv::emu(machine);
	PENALIZE(250'000); // Costly Object call operation.
	SYS_TRACE("obj_callp", addr, g_method, g_method_len, deferred, vret_ptr, args_addr, args_size);

	auto *obj = get_object_from_address(emu, addr);
	if (UNLIKELY(args_size > 8)) {
		ERR_PRINT("Too many arguments to obj_callp");
		throw std::runtime_error("Too many arguments to obj_callp");
	}
	const GuestVariant *g_args = machine.memory.memarray<GuestVariant>(args_addr, args_size);

	Variant method;
	std::string_view method_view = machine.memory.memview(g_method, g_method_len + 1);

	// Check if the method is null-terminated.
	if (method_view.back() == '\0') {
		method = StringName(method_view.data(), false);
	} else {
		method = String::utf8(method_view.data(), method_view.size() - 1);
	}

	// Check for banned methods.
	if (UNLIKELY(!emu.is_allowed_method(obj, method))) {
		ERR_PRINT("Banned method called: " + method.operator String());
		throw std::runtime_error("Banned method called: " + std::string(method_view));
	}

	if (!deferred) {
		Variant ret = object_call(emu, obj, method, g_args, args_size);
		if (vret_ptr != 0) {
			GuestVariant *vret = machine.memory.memarray<GuestVariant>(vret_ptr, 1);
			vret->create(emu, std::move(ret));
		}
	} else {
		// Call deferred unfortunately takes a parameter pack, so we have to manually
		// check the number of arguments, and call the correct function.
		if (args_size == 0) {
			obj->call_deferred(method);
		} else if (args_size == 1) {
			obj->call_deferred(method, g_args[0].toVariant(emu));
		} else if (args_size == 2) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu));
		} else if (args_size == 3) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu), g_args[2].toVariant(emu));
		} else if (args_size == 4) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu), g_args[2].toVariant(emu), g_args[3].toVariant(emu));
		} else if (args_size == 5) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu), g_args[2].toVariant(emu), g_args[3].toVariant(emu), g_args[4].toVariant(emu));
		} else if (args_size == 6) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu), g_args[2].toVariant(emu), g_args[3].toVariant(emu), g_args[4].toVariant(emu), g_args[5].toVariant(emu));
		} else if (args_size == 7) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu), g_args[2].toVariant(emu), g_args[3].toVariant(emu), g_args[4].toVariant(emu), g_args[5].toVariant(emu), g_args[6].toVariant(emu));
		} else if (args_size == 8) {
			obj->call_deferred(method, g_args[0].toVariant(emu), g_args[1].toVariant(emu), g_args[2].toVariant(emu), g_args[3].toVariant(emu), g_args[4].toVariant(emu), g_args[5].toVariant(emu), g_args[6].toVariant(emu), g_args[7].toVariant(emu));
		}
	}
}

APICALL(api_get_node) {
	auto [addr, name] = machine.sysargs<uint64_t, std::string_view>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(150'000);
	SYS_TRACE("get_node", addr, String::utf8(name.data(), name.size()));

	Node *node = nullptr;
	const std::string c_name(name);

	if (addr == 0) {
		auto *owner_node = emu.get_tree_base();
		if (owner_node == nullptr) {
			ERR_PRINT("Sandbox has no parent Node");
			machine.set_result(0);
			return;
		}
		node = owner_node->get_node<Node>(NodePath(c_name.c_str()));
	} else {
		Node *base_node = get_node_from_address(emu, addr);
		node = base_node->get_node<Node>(NodePath(c_name.c_str()));
	}
	if (node == nullptr) {
		ERR_PRINT(("Node not found: " + c_name).c_str());
		machine.set_result(0);
		return;
	}

	emu.add_scoped_object(node);
	machine.set_result(reinterpret_cast<uint64_t>(node));
}

APICALL(api_node_create) {
	auto [type, g_class_name, g_class_len, name] = machine.sysargs<Node_Create_Shortlist, gaddr_t, unsigned, std::string_view>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(150'000);
	Node *node = nullptr;

	switch (type) {
		case Node_Create_Shortlist::CREATE_CLASSDB: {
			// Get the class name from guest memory, including null terminator.
			std::string_view class_name = machine.memory.memview(g_class_name, g_class_len + 1);
			// Verify the class name is null-terminated.
			if (class_name[g_class_len] != '\0') {
				ERR_PRINT("Class name is not null-terminated");
				throw std::runtime_error("Class name is not null-terminated");
			}
			StringName class_name_sn(class_name.data());
			if (!emu.is_allowed_class(class_name_sn)) {
				ERR_PRINT("Class name is not allowed");
				throw std::runtime_error("Class name is not allowed");
			}
			// Now that it's null-terminated, we can use it for StringName.
			Variant result = ClassDBSingleton::get_singleton()->instantiate(class_name_sn);
			if (result.get_type() != Variant::OBJECT) {
				ERR_PRINT("Failed to create object from class name");
				throw std::runtime_error("Failed to create object from class name");
			}
			Object *obj = result.operator Object *();
			// Make sure the object held through the Variant has lifetime managed by the sandbox.
			emu.create_scoped_variant(std::move(result));

			node = Object::cast_to<Node>(obj);
			// If it's not a Node, just return the Object.
			if (node == nullptr) {
				emu.add_scoped_object(obj);
				machine.set_result(uint64_t(uintptr_t(obj)));
				return;
			}
			// It's a Node, so continue to set the name.
			break;
		}
		case Node_Create_Shortlist::CREATE_NODE: // Node
			if (!emu.is_allowed_class("Node")) {
				ERR_PRINT("Class name is not allowed");
				throw std::runtime_error("Class name is not allowed");
			}
			node = memnew(Node);
			break;
		case Node_Create_Shortlist::CREATE_NODE2D: // Node2D
			if (!emu.is_allowed_class("Node2D")) {
				ERR_PRINT("Class name is not allowed");
				throw std::runtime_error("Class name is not allowed");
			}
			node = memnew(Node2D);
			break;
		case Node_Create_Shortlist::CREATE_NODE3D: // Node3D
			if (!emu.is_allowed_class("Node3D")) {
				ERR_PRINT("Class name is not allowed");
				throw std::runtime_error("Class name is not allowed");
			}
			node = memnew(Node3D);
			break;
		default:
			ERR_PRINT("Unknown Node type");
			throw std::runtime_error("Unknown Node type");
	}

	if (node == nullptr) {
		ERR_PRINT("Failed to create Node");
		throw std::runtime_error("Failed to create Node");
	}
	if (!name.empty()) {
		node->set_name(String::utf8(name.data(), name.size()));
	}
	emu.add_scoped_object(node);
	machine.set_result(uint64_t(uintptr_t(node)));
}

APICALL(api_node) {
	auto [op, addr, gvar] = machine.sysargs<int, uint64_t, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(250'000); // Costly Node operations.
	SYS_TRACE("node_op", op, addr, gvar);

	// Get the Node object by its address.
	godot::Node *node = get_node_from_address(emu, addr);

	switch (Node_Op(op)) {
		case Node_Op::GET_NAME: {
			// Check if getting the name is allowed.
			if (UNLIKELY(!emu.is_allowed_property(node, "name", false))) {
				ERR_PRINT("Banned property accessed: name");
				throw std::runtime_error("Banned property accessed: name");
			}
			GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 1);
			var->create(emu, node->get_name());
		} break;
		case Node_Op::SET_NAME: {
			// Check if setting the name is allowed.
			if (UNLIKELY(!emu.is_allowed_property(node, "name", true))) {
				ERR_PRINT("Banned property set: name");
				throw std::runtime_error("Banned property set: name");
			}
			GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 1);
			node->set_name(var->toVariant(emu));
		} break;
		case Node_Op::GET_PATH: {
			// Check if getting the path is allowed.
			if (UNLIKELY(!emu.is_allowed_method(node, "path"))) {
				ERR_PRINT("Banned method accessed: path");
				throw std::runtime_error("Banned method accessed: path");
			}
			GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 1);
			var->create(emu, node->get_path());
		} break;
		case Node_Op::GET_PARENT: {
			// Check if getting the parent is allowed.
			if (UNLIKELY(!emu.is_allowed_method(node, "get_parent"))) {
				ERR_PRINT("Banned method accessed: get_parent");
				throw std::runtime_error("Banned method accessed: get_parent");
			}
			uint64_t *result = machine.memory.memarray<uint64_t>(gvar, 1);
			godot::Object *parent = node->get_parent();
			if (UNLIKELY(parent == nullptr)) {
				*result = 0;
			} else {
				// TODO: Parent nodes allow access higher up the tree, which could be a security issue.
				if (!emu.is_allowed_object(parent))
					throw std::runtime_error("Node::get_parent(): Parent is not allowed");
				emu.add_scoped_object(parent);
				*result = uint64_t(uintptr_t(parent));
			}
		} break;
		case Node_Op::QUEUE_FREE:
			if (UNLIKELY(node == &emu)) {
				ERR_PRINT("Cannot queue free the sandbox");
				throw std::runtime_error("Cannot queue free the sandbox");
			}
			// Check if queue_free is an allowed method.
			if (UNLIKELY(!emu.is_allowed_method(node, "queue_free"))) {
				ERR_PRINT("Banned method called: queue_free");
				throw std::runtime_error("Banned method called: queue_free");
			}
			//emu.rem_scoped_object(node);
			node->queue_free();
			break;
		case Node_Op::DUPLICATE: {
			// Check if creating a new node of this type is allowed.
			if (UNLIKELY(!emu.is_allowed_class(node->get_class()))) {
				throw std::runtime_error("Node::duplicate(): Creating a new node of this type is not allowed");
			}
			// Check if duplicate is an allowed method.
			if (UNLIKELY(!emu.is_allowed_method(node, "duplicate"))) {
				ERR_PRINT("Banned method called: duplicate");
				throw std::runtime_error("Banned method called: duplicate");
			}
			uint64_t *result = machine.memory.memarray<uint64_t>(gvar, 1);
			int flags = machine.cpu.reg(13); // Flags are passed in reg 13.
			auto *new_node = node->duplicate(flags);
			emu.add_scoped_object(new_node);
			*result = uint64_t(uintptr_t(new_node));
		} break;
		case Node_Op::GET_CHILD_COUNT: {
			int64_t *result = machine.memory.memarray<int64_t>(gvar, 1);
			*result = node->get_child_count();
		} break;
		case Node_Op::GET_CHILD: {
			GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 1);
			Node *child_node = node->get_child(var[0].v.i);
			if (UNLIKELY(child_node == nullptr)) {
				var[0].set(emu, Variant());
			} else {
				emu.add_scoped_object(child_node);
				var[0].set(emu, int64_t(uintptr_t(child_node)));
			}
		} break;
		case Node_Op::ADD_CHILD_DEFERRED:
		case Node_Op::ADD_CHILD: {
			// Check for banned methods.
			if (UNLIKELY(!emu.is_allowed_method(node, "add_child"))) {
				ERR_PRINT("Banned method called: add_child");
				throw std::runtime_error("Banned method called: add_child");
			}
			GuestVariant *child = machine.memory.memarray<GuestVariant>(gvar, 1);
			godot::Node *child_node = get_node_from_address(emu, child->v.i);
			if (Node_Op(op) == Node_Op::ADD_CHILD_DEFERRED)
				node->call_deferred("add_child", child_node);
			else
				node->add_child(child_node);
		} break;
		case Node_Op::ADD_SIBLING_DEFERRED:
		case Node_Op::ADD_SIBLING: {
			// Check for banned methods.
			if (UNLIKELY(!emu.is_allowed_method(node, "add_sibling"))) {
				ERR_PRINT("Banned method called: add_sibling");
				throw std::runtime_error("Banned method called: add_sibling");
			}
			GuestVariant *sibling = machine.memory.memarray<GuestVariant>(gvar, 1);
			godot::Node *sibling_node = get_node_from_address(emu, sibling->v.i);
			if (Node_Op(op) == Node_Op::ADD_SIBLING_DEFERRED)
				node->call_deferred("add_sibling", sibling_node);
			else
				node->add_sibling(sibling_node);
		} break;
		case Node_Op::MOVE_CHILD: {
			// Check for banned methods.
			if (UNLIKELY(!emu.is_allowed_method(node, "move_child"))) {
				ERR_PRINT("Banned method called: move_child");
				throw std::runtime_error("Banned method called: move_child");
			}
			GuestVariant *vars = machine.memory.memarray<GuestVariant>(gvar, 2);
			godot::Node *child_node = get_node_from_address(emu, vars[0].v.i);
			// TODO: Check if the child is actually a child of the node? Verify index?
			node->move_child(child_node, vars[1].v.i);
		} break;
		case Node_Op::REMOVE_CHILD_DEFERRED:
		case Node_Op::REMOVE_CHILD: {
			// Check for banned methods.
			if (UNLIKELY(!emu.is_allowed_method(node, "remove_child"))) {
				ERR_PRINT("Banned method called: remove_child");
				throw std::runtime_error("Banned method called: remove_child");
			}
			GuestVariant *child = machine.memory.memarray<GuestVariant>(gvar, 1);
			godot::Node *child_node = get_node_from_address(emu, child->v.i);
			if (Node_Op(op) == Node_Op::REMOVE_CHILD_DEFERRED)
				node->call_deferred("remove_child", child_node);
			else
				node->remove_child(child_node);
		} break;
		case Node_Op::GET_CHILDREN: {
			// Check if getting the children is allowed.
			if (UNLIKELY(!emu.is_allowed_method(node, "get_children"))) {
				ERR_PRINT("Banned method accessed: get_children");
				throw std::runtime_error("Banned method accessed: get_children");
			}
			// Get a GuestStdVector from guest to store the children.
			CppVector<uint64_t> *vec = machine.memory.memarray<CppVector<uint64_t>>(gvar, 1);
			// Get the children of the node.
			TypedArray<Node> children = node->get_children();
			// Allocate memory for the children in the guest vector.
			vec->reserve(machine, children.size());
			// Copy the children to the guest vector, and add them to the scoped objects.
			for (int i = 0; i < children.size(); i++) {
				godot::Node *child = godot::Object::cast_to<godot::Node>(children[i]);
				if (child) {
					emu.add_scoped_object(child);
					vec->push_back(machine, uint64_t(uintptr_t(child)));
				} else {
					vec->push_back(machine, 0);
				}
			}
			// No return value is needed.
		} break;
		case Node_Op::ADD_TO_GROUP: {
			// Reg 12: Group string pointer, Reg 13: Group string length.
			std::string_view group = machine.memory.memview(gvar, machine.cpu.reg(13));
			node->add_to_group(String::utf8(group.data(), group.size()));
		} break;
		case Node_Op::REMOVE_FROM_GROUP: {
			// Reg 12: Group string pointer, Reg 13: Group string length.
			std::string_view group = machine.memory.memview(gvar, machine.cpu.reg(13));
			node->remove_from_group(String::utf8(group.data(), group.size()));
		} break;
		case Node_Op::IS_IN_GROUP: {
			// Reg 12: Group string pointer, Reg 13: Group string length, Reg 14: Result bool pointer.
			std::string_view group = machine.memory.memview(gvar, machine.cpu.reg(13));
			bool *result = machine.memory.memarray<bool>(machine.cpu.reg(14), 1);
			*result = node->is_in_group(String::utf8(group.data(), group.size()));
		} break;
		case Node_Op::REPLACE_BY: {
			// Check for banned methods.
			if (UNLIKELY(!emu.is_allowed_method(node, "replace_by"))) {
				ERR_PRINT("Banned method called: replace_by");
				throw std::runtime_error("Banned method called: replace_by");
			}
			// Reg 12: Node address to replace with, Reg 13: Keep groups bool.
			godot::Node *replace_node = get_node_from_address(emu, gvar);
			bool keep_groups = machine.cpu.reg(13);
			node->replace_by(replace_node, keep_groups);
		} break;
		case Node_Op::REPARENT: {
			// Check for banned methods.
			if (UNLIKELY(!emu.is_allowed_method(node, "reparent"))) {
				ERR_PRINT("Banned method called: reparent");
				throw std::runtime_error("Banned method called: reparent");
			}
			// Reg 12: New parent node address, Reg 13: Keep transform bool.
			godot::Node *new_parent = get_node_from_address(emu, gvar);
			bool keep_transform = machine.cpu.reg(13);
			node->reparent(new_parent, keep_transform);
		} break;
		case Node_Op::IS_INSIDE_TREE: {
			// Reg 12: Result bool pointer.
			bool *result = machine.memory.memarray<bool>(gvar, 1);
			*result = node->is_inside_tree();
		} break;
		default:
			throw std::runtime_error("Invalid Node operation");
	}
}

APICALL(api_node2d) {
	// Node2D operation, Node2D address, and the variant to get/set the value.
	auto [op, addr, gvar] = machine.sysargs<int, uint64_t, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(100'000); // Costly Node2D operations.
	SYS_TRACE("node2d_op", op, addr, gvar);

	// Get the Node2D object by its address.
	godot::Node *node = get_node_from_address(emu, addr);

	// Cast the Node2D object to a Node2D object.
	godot::Node2D *node2d = godot::Object::cast_to<godot::Node2D>(node);
	if (node2d == nullptr) {
		ERR_PRINT("Node2D object is not a Node2D");
		throw std::runtime_error("Node2D object is not a Node2D");
	}

	// View the variant from the guest memory.
	GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 1);
	switch (Node2D_Op(op)) {
		case Node2D_Op::GET_POSITION:
			var->set(emu, node2d->get_position());
			break;
		case Node2D_Op::SET_POSITION:
			node2d->set_deferred("position", var->toVariant(emu));
			break;
		case Node2D_Op::GET_ROTATION:
			var->set(emu, node2d->get_rotation());
			break;
		case Node2D_Op::SET_ROTATION:
			node2d->set_rotation(var->toVariant(emu));
			break;
		case Node2D_Op::GET_SCALE:
			var->set(emu, node2d->get_scale());
			break;
		case Node2D_Op::SET_SCALE:
			node2d->set_scale(var->toVariant(emu));
			break;
		case Node2D_Op::GET_SKEW:
			var->set(emu, node2d->get_skew());
			break;
		case Node2D_Op::SET_SKEW:
			node2d->set_skew(var->toVariant(emu));
			break;
		case Node2D_Op::GET_TRANSFORM:
			var->create(emu, node2d->get_transform());
			break;
		case Node2D_Op::SET_TRANSFORM:
			node2d->set_transform(*var->toVariantPtr(emu));
			break;
		default:
			ERR_PRINT("Invalid Node2D operation");
			throw std::runtime_error("Invalid Node2D operation");
	}
}

APICALL(api_node3d) {
	// Node3D operation, Node3D address, and the variant to get/set the value.
	auto [op, addr, gvar] = machine.sysargs<int, uint64_t, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(100'000); // Costly Node3D operations.
	SYS_TRACE("node3d_op", op, addr, gvar);

	// Get the Node3D object by its address
	godot::Node *node = get_node_from_address(emu, addr);

	// Cast the Node3D object to a Node3D object.
	godot::Node3D *node3d = godot::Object::cast_to<godot::Node3D>(node);
	if (node3d == nullptr) {
		ERR_PRINT("Node3D object is not a Node3D");
		throw std::runtime_error("Node3D object is not a Node3D");
	}

	// View the variant from the guest memory.
	GuestVariant *var = machine.memory.memarray<GuestVariant>(gvar, 1);
	switch (Node3D_Op(op)) {
		case Node3D_Op::GET_POSITION:
			var->set(emu, node3d->get_position());
			break;
		case Node3D_Op::SET_POSITION:
			node3d->set_position(var->toVariant(emu));
			break;
		case Node3D_Op::GET_ROTATION:
			var->set(emu, node3d->get_rotation());
			break;
		case Node3D_Op::SET_ROTATION:
			node3d->set_rotation(var->toVariant(emu));
			break;
		case Node3D_Op::GET_SCALE:
			var->set(emu, node3d->get_scale());
			break;
		case Node3D_Op::SET_SCALE:
			node3d->set_scale(var->toVariant(emu));
			break;
		case Node3D_Op::GET_TRANSFORM:
			var->create(emu, node3d->get_transform());
			break;
		case Node3D_Op::SET_TRANSFORM:
			node3d->set_transform(*var->toVariantPtr(emu));
			break;
		case Node3D_Op::GET_QUATERNION:
			var->set(emu, node3d->get_quaternion());
			break;
		case Node3D_Op::SET_QUATERNION:
			node3d->set_quaternion(var->toVariant(emu));
			break;
		default:
			ERR_PRINT("Invalid Node3D operation");
			throw std::runtime_error("Invalid Node3D operation");
	}
}

APICALL(api_throw) {
	auto [type, msg, vaddr, vfunc] = machine.sysargs<std::string_view, std::string_view, gaddr_t, gaddr_t>();
	SYS_TRACE("throw", String::utf8(type.data(), type.size()), String::utf8(msg.data(), msg.size()), vaddr);

	if (vaddr != 0) {
		GuestVariant *var = machine.memory.memarray<GuestVariant>(vaddr, 1);
		String error_string = "Sandbox exception of type " + String::utf8(type.data(), type.size()) + ": " + String::utf8(msg.data(), msg.size()) + " for Variant of type " + itos(var->type);
		if (var->type >= 0 && var->type < Variant::VARIANT_MAX) {
			const char *type_hint = GuestVariant::type_name(var->type);
			error_string += " (" + String::utf8(type_hint) + ")";
		}
		if (vfunc != 0x0) {
			error_string += " in function " + String::utf8(machine.memory.memstring(vfunc).c_str());
		}
		ERR_PRINT(error_string);
		const std::string cpp_error = error_string.utf8().ptr();
		throw std::runtime_error(cpp_error);
	} else {
		String error_string = "Sandbox exception in " + String::utf8(type.data(), type.size()) + ": " + String::utf8(msg.data(), msg.size());
		if (vfunc != 0x0) {
			error_string += " in function " + String::utf8(machine.memory.memstring(vfunc).c_str());
		}
		ERR_PRINT(error_string);
		throw std::runtime_error(error_string.utf8().ptr());
	}
}

APICALL(api_array_ops) {
	auto [op, arr_idx, idx, vaddr] = machine.sysargs<Array_Op, unsigned, int, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(50'000); // Costly Array operations.
	SYS_TRACE("array_ops", int(op), arr_idx, idx, vaddr);

	if (op == Array_Op::CREATE) {
		// There is no scoped array, so we need to create one.
		Array a;
		a.resize(arr_idx); // Resize the array to the given size.
		const unsigned idx = emu.create_scoped_variant(Variant(std::move(a)));
		GuestVariant *vp = machine.memory.memarray<GuestVariant>(vaddr, 1);
		vp->type = Variant::ARRAY;
		vp->v.i = idx;
		return;
	}

	std::optional<const Variant *> opt_array = emu.get_scoped_variant(arr_idx);
	if (!opt_array.has_value() || opt_array.value()->get_type() != Variant::ARRAY) {
		ERR_PRINT("Invalid Array object");
		throw std::runtime_error("Invalid Array object, idx = " + std::to_string(arr_idx));
	}
	godot::Array array = opt_array.value()->operator Array();

	switch (op) {
		case Array_Op::PUSH_BACK:
			array.push_back(machine.memory.memarray<GuestVariant>(vaddr, 1)->toVariant(emu));
			break;
		case Array_Op::PUSH_FRONT:
			array.push_front(machine.memory.memarray<GuestVariant>(vaddr, 1)->toVariant(emu));
			break;
		case Array_Op::POP_AT:
			array.pop_at(idx);
			break;
		case Array_Op::POP_BACK:
			array.pop_back();
			break;
		case Array_Op::POP_FRONT:
			array.pop_front();
			break;
		case Array_Op::INSERT:
			array.insert(idx, machine.memory.memarray<GuestVariant>(vaddr, 1)->toVariant(emu));
			break;
		case Array_Op::ERASE:
			// TODO: Check if we can use pointer to Variant to avoid copying.
			array.erase(machine.memory.memarray<GuestVariant>(vaddr, 1)->toVariant(emu));
			break;
		case Array_Op::RESIZE:
			array.resize(idx);
			break;
		case Array_Op::CLEAR:
			array.clear();
			break;
		case Array_Op::SORT:
			array.sort();
			break;
		case Array_Op::FETCH_TO_VECTOR: {
			CppVector<GuestVariant> *vec = machine.memory.memarray<CppVector<GuestVariant>>(vaddr, 1);
			vec->resize(machine, array.size());
			for (int i = 0; i < array.size(); i++) {
				vec->at(machine, i).create(emu, array[i].duplicate(false));
			}
			break;
		}
		case Array_Op::HAS: {
			auto *vp = machine.memory.memarray<GuestVariant>(vaddr, 1);
			const bool result = array.has(vp->toVariant(emu));
			vp->set(emu, result);
			break;
		}
		default:
			ERR_PRINT("Invalid Array operation");
			throw std::runtime_error("Invalid Array operation");
	}
}

APICALL(api_array_at) {
	auto [arr_idx, idx, vret] = machine.sysargs<unsigned, int, GuestVariant *>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000); // Costly Array operations.
	SYS_TRACE("array_at", arr_idx, idx, vret);

	std::optional<const Variant *> opt_array = emu.get_scoped_variant(arr_idx);
	if (!opt_array.has_value() || opt_array.value()->get_type() != Variant::ARRAY) {
		ERR_PRINT("Invalid Array object");
		throw std::runtime_error("Invalid Array object, idx = " + std::to_string(arr_idx));
	}

	godot::Array array = opt_array.value()->operator Array();
	const bool set_mode = idx < 0;
	if (set_mode) {
		idx = -idx - 1;
	}
	if (idx >= array.size()) {
		ERR_PRINT("Array index out of bounds: " + itos(idx));
		throw std::runtime_error("Array index out of bounds: " + std::to_string(idx));
	}

	if (set_mode) {
		array[idx] = vret->toVariant(emu);
	} else {
		Variant ref = array[idx];
		vret->create(emu, std::move(ref));
	}
}

APICALL(api_array_size) {
	auto [arr_idx] = machine.sysargs<unsigned>();
	Sandbox &emu = riscv::emu(machine);

	std::optional<const Variant *> opt_array = emu.get_scoped_variant(arr_idx);
	if (!opt_array.has_value() || opt_array.value()->get_type() != Variant::ARRAY) {
		ERR_PRINT("Invalid Array object");
		throw std::runtime_error("Invalid Array object");
	}

	godot::Array array = opt_array.value()->operator Array();
	machine.set_result(array.size());
}

APICALL(api_dict_ops) {
	auto [op, dict_idx, vkey, vaddr] = machine.sysargs<Dictionary_Op, unsigned, gaddr_t, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(50'000); // Costly Dictionary operations.
	SYS_TRACE("dict_ops", int(op), dict_idx, vkey, vaddr);

	std::optional<const Variant *> opt_dict = emu.get_scoped_variant(dict_idx);
	if (!opt_dict.has_value() || opt_dict.value()->get_type() != Variant::DICTIONARY) {
		ERR_PRINT("Invalid Dictionary object");
		throw std::runtime_error("Invalid Dictionary object");
	}
	godot::Dictionary dict = opt_dict.value()->operator Dictionary();

	switch (op) {
		case Dictionary_Op::GET: {
			GuestVariant *key = machine.memory.memarray<GuestVariant>(vkey, 1);
			GuestVariant *vp = machine.memory.memarray<GuestVariant>(vaddr, 1);
			// TODO: Check if the value is already scoped?
			Variant v = dict[key->toVariant(emu)];
			vp->create(emu, std::move(v));
			break;
		}
		case Dictionary_Op::SET: {
			GuestVariant *key = machine.memory.memarray<GuestVariant>(vkey, 1);
			GuestVariant *value = machine.memory.memarray<GuestVariant>(vaddr, 1);
			dict[key->toVariant(emu)] = value->toVariant(emu);
			break;
		}
		case Dictionary_Op::ERASE: {
			GuestVariant *key = machine.memory.memarray<GuestVariant>(vkey, 1);
			dict.erase(key->toVariant(emu));
			break;
		}
		case Dictionary_Op::HAS: {
			GuestVariant *key = machine.memory.memarray<GuestVariant>(vkey, 1);
			machine.set_result(dict.has(key->toVariant(emu)));
			break;
		}
		case Dictionary_Op::GET_SIZE:
			machine.set_result(dict.size());
			break;
		case Dictionary_Op::CLEAR:
			dict.clear();
			break;
		case Dictionary_Op::MERGE: {
			GuestVariant *other_dict = machine.memory.memarray<GuestVariant>(vkey, 1);
			dict.merge(other_dict->toVariant(emu).operator Dictionary());
			break;
		}
		case Dictionary_Op::GET_OR_ADD: {
			GuestVariant *key = machine.memory.memarray<GuestVariant>(vkey, 1);
			GuestVariant *vp = machine.memory.memarray<GuestVariant>(vaddr, 1);
			Variant &v = dict[key->toVariant(emu)];
			if (v.get_type() == Variant::NIL) {
				const gaddr_t vdefaddr = machine.cpu.reg(14); // A4
				const GuestVariant *vdef = machine.memory.memarray<GuestVariant>(vdefaddr, 1);
				v = vdef->toVariant(emu);
			}
			vp->set(emu, v, true); // Implicit trust, as we are returning our own object.
			break;
		}
		default:
			ERR_PRINT("Invalid Dictionary operation");
			throw std::runtime_error("Invalid Dictionary operation");
	}
}

APICALL(api_string_create) {
	auto [strview] = machine.sysargs<std::string_view>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000);
	SYS_TRACE("string_create", String::utf8(strview.data(), strview.size()));

	String str = String::utf8(strview.data(), strview.size());
	const unsigned idx = emu.create_scoped_variant(Variant(std::move(str)));
	machine.set_result(idx);
}

APICALL(api_string_ops) {
	auto [op, str_idx, index, vaddr] = machine.sysargs<String_Op, unsigned, int, gaddr_t>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000); // Costly String operations.
	SYS_TRACE("string_ops", int(op), str_idx, index, vaddr);

	std::optional<const Variant *> opt_str = emu.get_scoped_variant(str_idx);
	if (!opt_str.has_value()) {
		ERR_PRINT("Invalid String object idx: " + itos(str_idx));
		throw std::runtime_error("Invalid String object: " + std::to_string(str_idx));
	}
	const Variant::Type type = opt_str.value()->get_type();
	if (type != Variant::STRING && type != Variant::STRING_NAME && type != Variant::NODE_PATH) {
		ERR_PRINT("Invalid String object type: " + itos(type));
		throw std::runtime_error("Invalid String object type: " + std::to_string(type));
	}
	godot::String str = opt_str.value()->operator String();

	switch (op) {
		case String_Op::APPEND: {
			GuestVariant *gvar = machine.memory.memarray<GuestVariant>(vaddr, 1);
			str += gvar->toVariant(emu).operator String();
			break;
		}
		case String_Op::GET_LENGTH:
			machine.set_result(str.length());
			break;
		case String_Op::TO_STD_STRING: {
			if (index == 0) { // Get the string as a std::string.
				CharString utf8 = str.utf8();
				CppString *gstr = machine.memory.memarray<CppString>(vaddr, 1);
				gstr->set_string(machine, vaddr, utf8.ptr(), utf8.length());
			} else if (index == 1) { // Get the string as a const char*, size_t struct.
				struct Buffer {
					gaddr_t ptr;
					gaddr_t size;
				} *buffer = machine.memory.memarray<Buffer>(vaddr, 1);
				CharString utf8 = str.utf8();
				const size_t size = utf8.length();
				// Allocate memory for the string in the guest memory.
				if (buffer->size < size) {
					buffer->size = size;
					if (buffer->ptr)
						machine.arena().free(buffer->ptr);
					buffer->ptr = machine.arena().malloc(buffer->size);
				}
				// Copy the string to the guest memory.
				machine.memory.memcpy(buffer->ptr, utf8.ptr(), buffer->size);
			} else if (index == 2) { // Get the string as a std::u32string.
				GuestStdU32String *gstr = machine.memory.memarray<GuestStdU32String>(vaddr, 1);
				gstr->set_string(machine, vaddr, str.ptr(), str.length());
			} else {
				ERR_PRINT("Invalid String conversion");
				throw std::runtime_error("Invalid String conversion");
			}
			break;
		}
		case String_Op::COMPARE: {
			unsigned *vother = machine.memory.memarray<unsigned>(vaddr, 1);
			const Variant *other = emu.get_scoped_variant(*vother).value();
			machine.set_result(str == other->operator String());
			break;
		}
		case String_Op::COMPARE_CSTR: {
			const std::string vother = machine.memory.memstring(vaddr);
			machine.set_result(str == String::utf8(vother.c_str(), vother.size()));
			break;
		}
		default:
			ERR_PRINT("Invalid String operation");
			throw std::runtime_error("Invalid String operation");
	}
}

APICALL(api_string_at) {
	auto [str_idx, index] = machine.sysargs<unsigned, int>();
	Sandbox &emu = riscv::emu(machine);
	SYS_TRACE("string_at", str_idx, index);

	std::optional<const Variant *> opt_str = emu.get_scoped_variant(str_idx);
	if (!opt_str.has_value() || opt_str.value()->get_type() != Variant::STRING) {
		ERR_PRINT("Invalid String object");
		throw std::runtime_error("Invalid String object");
	}
	godot::String str = opt_str.value()->operator String();

	if (index < 0 || index >= str.length()) {
		ERR_PRINT("String index out of bounds");
		throw std::runtime_error("String index out of bounds");
	}

	char32_t new_string = str[index];
	unsigned int new_varidx = emu.create_scoped_variant(Variant(std::move(new_string)));
	machine.set_result(new_varidx);
}

APICALL(api_string_size) {
	auto [str_idx] = machine.sysargs<unsigned>();
	Sandbox &emu = riscv::emu(machine);
	SYS_TRACE("string_size", str_idx);

	std::optional<const Variant *> opt_str = emu.get_scoped_variant(str_idx);
	if (!opt_str.has_value() || opt_str.value()->get_type() != Variant::STRING) {
		ERR_PRINT("Invalid String object");
		throw std::runtime_error("Invalid String object");
	}
	godot::String str = opt_str.value()->operator String();
	machine.set_result(str.length());
}

APICALL(api_string_append) {
	auto [str_idx, strview] = machine.sysargs<unsigned, std::string_view>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(10'000);
	SYS_TRACE("string_append", str_idx, String::utf8(strview.data(), strview.size()));

	Variant &var = emu.get_mutable_scoped_variant(str_idx);

	godot::String str = var.operator String();
	str += String::utf8(strview.data(), strview.size());
	var = Variant(std::move(str));
}

APICALL(api_timer_periodic) {
	auto [interval, oneshot, callback, capture, vret] = machine.sysargs<double, bool, gaddr_t, std::array<uint8_t, 32> *, GuestVariant *>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(100'000); // Costly Timer node creation.
	SYS_TRACE("timer_periodic", interval, oneshot, callback, capture, vret);

	Timer *timer = memnew(Timer);
	timer->set_wait_time(interval);
	timer->set_one_shot(oneshot);
	Node *topnode = emu.get_tree_base();
	// Add the timer to the top node, as long as the Sandbox is in a tree.
	if (topnode != nullptr) {
		topnode->add_child(timer);
		timer->set_owner(topnode);
		timer->start();
	} else {
		timer->set_autostart(true);
	}
	// Copy the callback capture storage to the timer timeout callback.
	PackedByteArray capture_data;
	capture_data.resize(capture->size());
	memcpy(capture_data.ptrw(), capture->data(), capture->size());
	// Connect the timer to the guest callback function.
	Array args;
	args.push_back(Variant(timer));
	args.push_back(Variant(std::move(capture_data)));
	timer->connect("timeout", emu.vmcallable_address(callback, std::move(args)));
	// Return the timer object to the guest.
	vret->set_object(emu, timer);
}

APICALL(api_timer_stop) {
	throw std::runtime_error("timer_stop: Not implemented");
}

APICALL(api_callable_create) {
	auto [address, vargs] = machine.sysargs<gaddr_t, GuestVariant *>();
	Sandbox &emu = riscv::emu(machine);
	SYS_TRACE("callable_create", address, vargs);

	// Create a new callable object, using emu.vmcallable_address() to get the callable function.
	Array arguments;
	if (vargs->type != Variant::NIL) {
		// The argument idx is a Variant of another type.
		arguments.push_back(vargs->toVariant(emu));
	}
	Callable callable = emu.vmcallable_address(address, std::move(arguments));

	// Return the callable object to the guest.
	auto idx = emu.create_scoped_variant(Variant(std::move(callable)));
	machine.set_result(idx);
}

APICALL(api_load) {
	auto [path, g_result] = machine.sysargs<std::string_view, GuestVariant *>();
	Sandbox &emu = riscv::emu(machine);
	const String godot_path = String::utf8(path.data(), path.size());
	SYS_TRACE("load", godot_path, g_result);

	// Check if the path is allowed.
	if (!emu.is_allowed_resource(godot_path)) {
		ERR_PRINT("Resource path is not allowed: " + godot_path);
		throw std::runtime_error("Resource path is not allowed: " + std::string(path));
	}

	// Preload the resource from the given path.
	ResourceLoader *loader = ResourceLoader::get_singleton();
	Ref<Resource> resource = loader->load(godot_path);
	if (resource.is_null()) {
		ERR_PRINT("Failed to preload resource");
		// TODO: Return a null object instead?
		throw std::runtime_error("Failed to preload resource");
	}

	Variant result(std::move(resource));
	godot::Object *obj = result.operator Object *();

	// Return the result to the guest.
	emu.create_scoped_variant(std::move(result));
	g_result->set_object(emu, obj);
}

APICALL(api_sandbox_add) {
	// Add a new sandboxed property or public API method to the sandbox.
	Sandbox &emu = riscv::emu(machine);
	if (!emu.is_initializing()) {
		ERR_PRINT("Sandbox add called outside of initialization");
		throw std::runtime_error("Sandbox add called outside of initialization");
	}
	PENALIZE(100'000); // Costly Sandbox operations.
	// Check which operation it is.
	int method = machine.cpu.reg(10); // A0
	switch (method) {
		case 0: {
			// Add a new sandboxed property.
			auto [method, name, type, setter, getter, defval] = machine.sysargs<int, std::string_view, Variant::Type, gaddr_t, gaddr_t, GuestVariant *>();
			String utf8_name = String::utf8(name.data(), name.size());
			SYS_TRACE("sandbox_add", "property", utf8_name, int(type), setter, getter, defval->toVariant(emu));
			if (type <= 0) {
				ERR_PRINT("Invalid property type for sandbox property" + itos(type));
				throw std::runtime_error("Invalid property type for sandbox property");
			}
			if (type >= Variant::VARIANT_MAX) {
				ERR_PRINT("Invalid property type for sandbox property: " + itos(type));
				throw std::runtime_error("Invalid property type for sandbox property: " + std::to_string(type));
			}
			if (getter == 0 && setter == 0) {
				// Treat as a guest-side variable, where the "default" value is
				// the address of the Variant, and the current value is the default.
				const gaddr_t address = machine.cpu.reg(REG_ARG6);
				emu.add_property(utf8_name, type, address, defval->toVariant(emu));
			} else {
				// If the setter is zero, it is a read-only property.
				emu.add_property(utf8_name, type, setter, getter, defval->toVariant(emu));
			}
			break;
		}
		case 1: {
			// Add a new sandboxed public API method. Name, address, description, return type and arguments.
			struct GuestFunctionExtra {
				gaddr_t desc;
				gaddr_t desc_len;
				gaddr_t ret;
				gaddr_t ret_len;
				gaddr_t args;
				gaddr_t args_len;
			};
			auto [method, name, address, g_extra] = machine.sysargs<int, std::string_view, gaddr_t, GuestFunctionExtra *>();
			SYS_TRACE("sandbox_add", "method", String::utf8(name.data(), name.size()));
			// Get the description, return type and arguments. We have a limited amount of registers,
			// so we will use zero-terminated strings for the description and return type.
			std::string_view description = machine.memory.memview(g_extra->desc, g_extra->desc_len);
			std::string_view return_type = machine.memory.memview(g_extra->ret, g_extra->ret_len);
			std::string_view arguments = machine.memory.memview(g_extra->args, g_extra->args_len);
			// Add the function to the ELFScript method list.
			if (Ref<ELFScript> program = emu.get_program(); program.is_valid()) {
				Dictionary func = Sandbox::create_public_api_function(name, address, description, return_type, arguments);
				if (func.size() > 0) {
					if (program->functions.size() >= Sandbox::MAX_PUBLIC_FUNCTIONS) {
						ERR_PRINT("Too many public functions in the Sandbox program");
						throw std::runtime_error("Too many public functions in the Sandbox program");
					}
					if (program->function_names.has(func["name"])) {
						// Remove the old function with the same name.
						for (int i = 0; i < program->functions.size(); i++) {
							Dictionary old_func = program->functions[i];
							if (old_func["name"].operator String() == func["name"].operator String()) {
								program->functions.remove_at(i);
								break;
							}
						}
					}
					program->functions.push_back(func);
				}
			}
			// Cache the function name hash with the address for faster lookup.
			emu.add_cached_address(String::utf8(name.data(), name.size()), address);
		} break;
		case 2: { // Set new exit address.
			SYS_TRACE("sandbox_add", "exit", machine.cpu.reg(11));
			const gaddr_t exit_address = machine.cpu.reg(11); // A1
			if (exit_address == 0 || (exit_address & 0x1) != 0) {
				ERR_PRINT("Invalid program exit address");
				throw std::runtime_error("Invalid program exit address");
			}
			const auto &exec = emu.machine().memory.exec_segment_for(exit_address);
			if (!exec->is_within(exit_address)) {
				ERR_PRINT("Invalid program exit address");
				throw std::runtime_error("Invalid program exit address");
			}
			emu.machine().memory.set_exit_address(exit_address);
			break;
		}
		default:
			WARN_PRINT("Unhandled sandbox add method: " + itos(method));
	}
}

template <typename T, typename PA>
static PA createPackedArrayFromGuestArray(Sandbox &emu, const Array& array)
{
	const size_t size = array.size();
	PA packed_array;
	packed_array.resize(size);
	for (int i = 0; i < size; i++) {
		if constexpr (std::is_same_v<T, godot::String>) {
			packed_array[i] = array[i].operator String();
		} else {
			packed_array[i] = static_cast<T>(array[i]);
		}
	}
	return packed_array;
}

APICALL(api_packed_array_ops)
{
	auto [op] = machine.sysargs<int>();
	Sandbox &emu = riscv::emu(machine);
	PENALIZE(50'000); // Costly PackedArray operations.
	SYS_TRACE("packed_array_ops", int(op), arr_idx, idx, vaddr);

	// CREATE_FROM_ARRAY (op="Any Packed*Array Variant type, starting at 29")
	switch (op) {
	case Variant::PACKED_BYTE_ARRAY:
	case Variant::PACKED_INT32_ARRAY:
	case Variant::PACKED_INT64_ARRAY:
	case Variant::PACKED_FLOAT32_ARRAY:
	case Variant::PACKED_FLOAT64_ARRAY:
	case Variant::PACKED_VECTOR2_ARRAY:
	case Variant::PACKED_VECTOR3_ARRAY:
	case Variant::PACKED_VECTOR4_ARRAY:
	case Variant::PACKED_COLOR_ARRAY:
	case Variant::PACKED_STRING_ARRAY:
	{
		// Create a Packed*Array from an Array.
		auto [unused_op, result_ptr, arr_ptr] = machine.sysargs<int, gaddr_t, int>();
		// This is a scoped Array type GuestVariant.
		GuestVariant *garray = machine.memory.memarray<GuestVariant>(arr_ptr, 1);
		if (garray->type != Variant::ARRAY) {
			ERR_PRINT("Invalid Array object for PackedArray creation");
			throw std::runtime_error("Invalid Array object for PackedArray creation");
		}
		godot::Array array = emu.get_scoped_variant(garray->v.i).value()->operator Array();
		GuestVariant *gres = machine.memory.memarray<GuestVariant>(result_ptr, 1);
		switch (op) {
			case Variant::PACKED_BYTE_ARRAY: {
				PackedByteArray packed_array = createPackedArrayFromGuestArray<uint8_t, PackedByteArray>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_INT32_ARRAY: {
				PackedInt32Array packed_array = createPackedArrayFromGuestArray<int32_t, PackedInt32Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_INT64_ARRAY: {
				PackedInt64Array packed_array = createPackedArrayFromGuestArray<int64_t, PackedInt64Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_FLOAT32_ARRAY: {
				PackedFloat32Array packed_array = createPackedArrayFromGuestArray<float, PackedFloat32Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_FLOAT64_ARRAY: {
				PackedFloat64Array packed_array = createPackedArrayFromGuestArray<double, PackedFloat64Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_VECTOR2_ARRAY: {
				PackedVector2Array packed_array = createPackedArrayFromGuestArray<godot::Vector2, PackedVector2Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_VECTOR3_ARRAY: {
				PackedVector3Array packed_array = createPackedArrayFromGuestArray<godot::Vector3, PackedVector3Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_VECTOR4_ARRAY: {
				PackedVector4Array packed_array = createPackedArrayFromGuestArray<godot::Vector4, PackedVector4Array>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_COLOR_ARRAY: {
				PackedColorArray packed_array = createPackedArrayFromGuestArray<godot::Color, PackedColorArray>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			case Variant::PACKED_STRING_ARRAY: {
				PackedStringArray packed_array = createPackedArrayFromGuestArray<godot::String, PackedStringArray>(emu, array);
				gres->create(emu, std::move(packed_array));
				break;
			}
			default:
				ERR_PRINT("Invalid PackedArray type for creation: " + itos(gres->type));
				throw std::runtime_error("Invalid PackedArray type for creation: " + std::to_string(gres->type));
		}
		return;
	}
	default:
		// Unknown operation
		ERR_PRINT("Invalid PackedArray operation");
		throw std::runtime_error("Invalid PackedArray operation");
	}
}

} //namespace riscv

void Sandbox::initialize_syscalls_runtime() {
	using namespace riscv;

	// Initialize common Linux system calls
	machine().setup_linux_syscalls(false, false);
	// Initialize POSIX threads
	machine().setup_posix_threads();

	machine().on_unhandled_syscall = [](machine_t &machine, size_t syscall) {
#if defined(__linux__) // We only want to print these kinds of warnings on Linux.
		WARN_PRINT(("Unhandled system call: " + std::to_string(syscall)).c_str());
		auto &emu = riscv::emu(machine);
		PENALIZE(100'000); // Add to the instruction counter due to I/O.
#endif
		machine.set_result(-ENOSYS);
	};
}

void Sandbox::initialize_syscalls() {
	using namespace riscv;

	// Add the Godot system calls.
	machine_t::install_syscall_handlers({
			{ ECALL_PRINT, api_print },
			{ ECALL_VCALL, api_vcall },
			{ ECALL_VEVAL, api_veval },
			{ ECALL_VASSIGN, api_vassign },
			{ ECALL_GET_OBJ, api_get_obj },
			{ ECALL_OBJ, api_obj },
			{ ECALL_OBJ_CALLP, api_obj_callp },
			{ ECALL_GET_NODE, api_get_node },
			{ ECALL_NODE, api_node },
			{ ECALL_NODE2D, api_node2d },
			{ ECALL_NODE3D, api_node3d },
			{ ECALL_THROW, api_throw },
			{ ECALL_IS_EDITOR, [](machine_t &machine) {
				 machine.set_result(godot::Engine::get_singleton()->is_editor_hint());
			 } },

			{ ECALL_VCREATE, api_vcreate },
			{ ECALL_VFETCH, api_vfetch },
			{ ECALL_VCLONE, api_vclone },
			{ ECALL_VSTORE, api_vstore },

			{ ECALL_ARRAY_OPS, api_array_ops },
			{ ECALL_ARRAY_AT, api_array_at },
			{ ECALL_ARRAY_SIZE, api_array_size },

			{ ECALL_DICTIONARY_OPS, api_dict_ops },

			{ ECALL_STRING_CREATE, api_string_create },
			{ ECALL_STRING_OPS, api_string_ops },
			{ ECALL_STRING_AT, api_string_at },
			{ ECALL_STRING_SIZE, api_string_size },
			{ ECALL_STRING_APPEND, api_string_append },

			{ ECALL_TIMER_PERIODIC, api_timer_periodic },
			{ ECALL_TIMER_STOP, api_timer_stop },

			{ ECALL_NODE_CREATE, api_node_create },

			{ ECALL_CALLABLE_CREATE, api_callable_create },

			{ ECALL_LOAD, api_load },

			{ ECALL_OBJ_PROP_GET, api_obj_property_get },
			{ ECALL_OBJ_PROP_SET, api_obj_property_set },

			{ ECALL_SANDBOX_ADD, api_sandbox_add },

			{ ECALL_PACKED_ARRAY_OPS, api_packed_array_ops },
	});

	// Add system calls from other modules.
	Sandbox::initialize_syscalls_2d();
	Sandbox::initialize_syscalls_3d();

	using namespace riscv;
	static const Instruction<RISCV_ARCH> validated_syscall_instruction {
		[](CPU<RISCV_ARCH>& cpu, rv32i_instruction instr) {
			Machine<RISCV_ARCH>::syscall_handlers[instr.Itype.imm](cpu.machine());
		},
		[](char* buffer, size_t len, const CPU<RISCV_ARCH>&, rv32i_instruction instr) -> int {
			return snprintf(buffer, len,
				"DYNCALL: 4-byte idx=0x%X (inline, 0x%X)",
				uint32_t(instr.Itype.imm),
				instr.whole
			);
		}};
	// Override the machines unimplemented instruction handling,
	// in order to use the custom instruction instead.
	CPU<RISCV_ARCH>::on_unimplemented_instruction
		= [](rv32i_instruction instr) -> const Instruction<RISCV_ARCH>& {
		if (instr.opcode() == 0b1011011 && instr.Itype.rs1 == 0 && instr.Itype.rd == 0) {
			if (instr.Itype.imm < Machine<RISCV_ARCH>::syscall_handlers.size()) {
				return validated_syscall_instruction;
			}
		}
		return CPU<RISCV_ARCH>::get_unimplemented_instruction();
	};
}

```

`src/sandbox_syscalls_2d.cpp`:

```cpp
#include "guest_datatypes.h"
#include "syscalls.h"

#include <godot_cpp/core/math.hpp>
#include <godot_cpp/variant/transform2d.hpp>
#include <godot_cpp/variant/variant.hpp>
//#define ENABLE_SYSCALL_TRACE 1
#include "syscalls_helpers.hpp"

namespace riscv {

APICALL(api_vector2_length) {
	auto [dx, dy] = machine.sysargs<float, float>();
	const float length = std::sqrt(dx * dx + dy * dy);
	machine.set_result(length);
}

APICALL(api_vector2_normalize) {
	auto [dx, dy] = machine.sysargs<float, float>();
	const float length = std::sqrt(dx * dx + dy * dy);
	if (length > 0.0001f) // FLT_EPSILON?
	{
		dx /= length;
		dy /= length;
	}
	machine.set_result(dx, dy);
}

APICALL(api_vector2_rotated) {
	auto [dx, dy, angle] = machine.sysargs<float, float, float>();
	const float x = cos(angle) * dx - sin(angle) * dy;
	const float y = sin(angle) * dx + cos(angle) * dy;
	machine.set_result(x, y);
}

APICALL(api_vec2_ops) {
	auto [op, vec2] = machine.sysargs<Vec2_Op, Vector2 *>();
	Sandbox &emu = riscv::emu(machine);

	// Integer arguments start from A2, and float arguments start from FA0.
	switch (op) {
		case Vec2_Op::NORMALIZE:
			vec2->normalize();
			break;
		case Vec2_Op::LENGTH: {
			double *result = machine.memory.memarray<double>(machine.cpu.reg(12), 1); // A2
			*result = vec2->length();
			break;
		}
		case Vec2_Op::LENGTH_SQ: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			double *result = machine.memory.memarray<double>(vaddr, 1);
			*result = vec2->length_squared();
			break;
		}
		case Vec2_Op::ANGLE: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			double *result = machine.memory.memarray<double>(vaddr, 1);
			*result = vec2->angle();
			break;
		}
		case Vec2_Op::ANGLE_TO: {
			const double angle = machine.cpu.registers().getfl(10).get<double>(); // FA0
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			double *result = machine.memory.memarray<double>(vaddr, 1);
			*result = vec2->angle_to(Vector2(cos(angle), sin(angle)));
			break;
		}
		case Vec2_Op::ANGLE_TO_POINT: {
			const double x = machine.cpu.registers().getfl(10).get<double>(); // FA0
			const double y = machine.cpu.registers().getfl(11).get<double>(); // FA1
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			double *result = machine.memory.memarray<double>(vaddr, 1);
			*result = vec2->angle_to(Vector2(x, y));
			break;
		}
		case Vec2_Op::PROJECT: {
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			*vec2 = vec2->project(*vec);
			break;
		}
		case Vec2_Op::DIRECTION_TO: {
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			*vec2 = vec2->direction_to(*vec);
			break;
		}
		case Vec2_Op::SLIDE: {
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			*vec2 = vec2->slide(*vec);
			break;
		}
		case Vec2_Op::BOUNCE: {
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			*vec2 = vec2->bounce(*vec);
			break;
		}
		case Vec2_Op::REFLECT: {
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			*vec2 = vec2->reflect(*vec);
			break;
		}
		case Vec2_Op::LIMIT_LENGTH: {
			const double length = machine.cpu.registers().getfl(10).get<double>(); // FA0
			*vec2 = vec2->limit_length(length);
			break;
		}
		case Vec2_Op::LERP: {
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // FA0
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			*vec2 = vec2->lerp(*vec, weight);
			break;
		}
		case Vec2_Op::CUBIC_INTERPOLATE: {
			Vector2 *v_b = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			Vector2 *vpre_a = machine.memory.memarray<Vector2>(machine.cpu.reg(13), 1); // A3
			Vector2 *vpost_b = machine.memory.memarray<Vector2>(machine.cpu.reg(14), 1); // A4
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // FA0
			*vec2 = vec2->cubic_interpolate(*v_b, *vpre_a, *vpost_b, weight);
			break;
		}
		case Vec2_Op::MOVE_TOWARD: {
			Vector2 *vec = machine.memory.memarray<Vector2>(machine.cpu.reg(12), 1); // A2
			const double delta = machine.cpu.registers().getfl(10).get<double>(); // FA0
			*vec2 = vec2->move_toward(*vec, delta);
			break;
		}
		default:
			ERR_PRINT("Invalid Vector2 operation");
			throw std::runtime_error("Invalid Vector2 operation");
	}
}

APICALL(api_transform2d_ops) {
	auto [idx, op] = machine.sysargs<unsigned, Transform2D_Op>();
	SYS_TRACE("transform2d_ops", idx, int(op), vres);
	Sandbox &emu = riscv::emu(machine);

	if (op == Transform2D_Op::IDENTITY) {
		const gaddr_t vaddr = machine.cpu.reg(12); // A2
		GuestVariant *vres = machine.memory.memarray<GuestVariant>(vaddr, 1);
		vres->create(emu, Transform2D());
		return;
	}

	std::optional<const Variant *> opt_t = emu.get_scoped_variant(idx);
	if (!opt_t.has_value() || opt_t.value()->get_type() != Variant::TRANSFORM2D) {
		ERR_PRINT("Invalid Transform2D object");
		throw std::runtime_error("Invalid Transform2D object");
	}
	const Variant *t_variant = *opt_t;
	godot::Transform2D t = t_variant->operator Transform2D();

	// Additional integers start at A2 (12), and floats start at FA0 (10).
	switch (op) {
		case Transform2D_Op::GET_COLUMN: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			Vector2 *v = machine.memory.memarray<Vector2>(vaddr, 1);
			const int column = machine.cpu.reg(13); // A3
			if (column < 0 || column >= 3) {
				ERR_PRINT("Invalid Transform2D column");
				throw std::runtime_error("Invalid Transform2D column");
			}

			*v = t.columns[column];
			break;
		}
		case Transform2D_Op::SET_COLUMN: {
			unsigned *vres = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const int column = machine.cpu.reg(13); // A3
			const gaddr_t vaddr = machine.cpu.reg(14); // A4
			const Vector2 *v = machine.memory.memarray<Vector2>(vaddr, 1);
			if (column < 0 || column >= 3) {
				ERR_PRINT("Invalid Transform2D column");
				throw std::runtime_error("Invalid Transform2D column");
			}

			t.columns[column] = *v;
			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t));
			break;
		}
		case Transform2D_Op::ROTATED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vres = machine.memory.memarray<unsigned>(vaddr, 1);
			const double angle = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Rotate the transform by the given angle, return a new transform.
			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.rotated(angle)));
			break;
		}
		case Transform2D_Op::SCALED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vres = machine.memory.memarray<unsigned>(vaddr, 1);
			const gaddr_t v2addr = machine.cpu.reg(13); // A3
			const Vector2 *scale = machine.memory.memarray<Vector2>(v2addr, 1);

			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.scaled(*scale)));
			break;
		}
		case Transform2D_Op::TRANSLATED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vres = machine.memory.memarray<unsigned>(vaddr, 1);
			const gaddr_t v2addr = machine.cpu.reg(13); // A3
			const Vector2 *offset = machine.memory.memarray<Vector2>(v2addr, 1);

			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.translated(*offset)));
			break;
		}
		case Transform2D_Op::INVERTED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vres = machine.memory.memarray<unsigned>(vaddr, 1);

			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.inverse()));
			break;
		}
		case Transform2D_Op::AFFINE_INVERTED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vres = machine.memory.memarray<unsigned>(vaddr, 1);

			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.affine_inverse()));
			break;
		}
		case Transform2D_Op::ORTHONORMALIZED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vres = machine.memory.memarray<unsigned>(vaddr, 1);

			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.orthonormalized()));
			break;
		}
		case Transform2D_Op::INTERPOLATE_WITH: {
			unsigned *vres = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned t2_idx = machine.cpu.reg(13); // A3
			const Transform2D to = emu.get_scoped_variant(t2_idx).value()->operator Transform2D();
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // fa0

			*vres = emu.try_reuse_assign_variant(idx, *t_variant, *vres, Variant(t.interpolate_with(to, weight)));
			break;
		}
		default:
			ERR_PRINT("Invalid Transform2D operation");
			throw std::runtime_error("Invalid Transform2D operation");
	}
}

template <typename Float>
static void api_math_op(machine_t &machine) {
	auto [op, arg1] = machine.sysargs<Math_Op, Float>();
	SYS_TRACE("math_op", int(op), arg1);

	switch (op) {
		case Math_Op::SIN:
			machine.set_result(Float(sin(arg1)));
			break;
		case Math_Op::COS:
			machine.set_result(Float(cos(arg1)));
			break;
		case Math_Op::TAN:
			machine.set_result(Float(tan(arg1)));
			break;
		case Math_Op::ASIN:
			machine.set_result(Float(asin(arg1)));
			break;
		case Math_Op::ACOS:
			machine.set_result(Float(acos(arg1)));
			break;
		case Math_Op::ATAN:
			machine.set_result(Float(atan(arg1)));
			break;
		case Math_Op::ATAN2: {
			Float arg2 = machine.cpu.registers().getfl(11).get<Float>(); // fa1
			machine.set_result(Float(atan2(arg1, arg2)));
			break;
		}
		case Math_Op::POW: {
			Float arg2 = machine.cpu.registers().getfl(11).get<Float>(); // fa1
			machine.set_result(Float(pow(arg1, arg2)));
			break;
		}
		default:
			ERR_PRINT("Invalid Math operation");
			throw std::runtime_error("Invalid Math operation");
	}
}

template <typename Float>
static void api_lerp_op(machine_t &machine) {
	auto [op, arg1, arg2, arg3] = machine.sysargs<Lerp_Op, Float, Float, Float>();
	SYS_TRACE("lerp_op", int(op), arg1, arg2, arg3);

	switch (op) {
		case Lerp_Op::LERP: {
			const Float t = arg3; // t is the interpolation factor.
			machine.set_result(arg1 * (Float(1.0) - t) + arg2 * t);
			break;
		}
		case Lerp_Op::SMOOTHSTEP: {
			const Float a = arg1; // a is the start value.
			const Float b = arg2; // b is the end value.
			const Float t = CLAMP<Float>((arg3 - a) / (b - a), Float(0.0), Float(1.0));
			machine.set_result(t * t * (Float(3.0) - Float(2.0) * t));
			break;
		}
		case Lerp_Op::CLAMP:
			machine.set_result(CLAMP<Float>(arg1, arg2, arg3));
			break;
		case Lerp_Op::SLERP: { // Spherical linear interpolation
			const Float a = arg1; // a is the start value.
			const Float b = arg2; // b is the end value.
			const Float t = arg3; // t is the interpolation factor.
			const Float dot = a * b + Float(1.0);
			if (dot > Float(0.9995)) {
				machine.set_result(a);
			} else {
				const Float theta = acos(CLAMP<Float>(dot, Float(-1.0), Float(1.0)));
				const Float sin_theta = sin(theta);
				machine.set_result((a * sin((Float(1.0) - t) * theta) + b * sin(t * theta)) / sin_theta);
			}
			break;
		}
		default:
			ERR_PRINT("Invalid Lerp operation");
			throw std::runtime_error("Invalid Lerp operation");
	}
} // api_lerp_op

} // namespace riscv

void Sandbox::initialize_syscalls_2d() {
	using namespace riscv;

	// Add the Godot system calls.
	machine_t::install_syscall_handlers({
			{ ECALL_SINCOS, [](machine_t &machine) {
				 float angle = machine.cpu.registers().getfl(10).get<float>(); // fa0
				 machine.set_result(sin(angle), cos(angle));
			 } },
			{ ECALL_VEC2_LENGTH, api_vector2_length },
			{ ECALL_VEC2_NORMALIZED, api_vector2_normalize },
			{ ECALL_VEC2_ROTATED, api_vector2_rotated },
			{ ECALL_VEC2_OPS, api_vec2_ops },
			{ ECALL_TRANSFORM_2D_OPS, api_transform2d_ops },
			{ ECALL_MATH_OP32, api_math_op<float> },
			{ ECALL_MATH_OP64, api_math_op<double> },
			{ ECALL_LERP_OP32, api_lerp_op<float> },
			{ ECALL_LERP_OP64, api_lerp_op<double> },
	});
}

```

`src/sandbox_syscalls_3d.cpp`:

```cpp
#include "guest_datatypes.h" // includes sandbox.h
#include "syscalls.h"

#include <godot_cpp/variant/basis.hpp>
#include <godot_cpp/variant/quaternion.hpp>
#include <godot_cpp/variant/transform3d.hpp>
#include <godot_cpp/variant/variant.hpp>
#include <godot_cpp/variant/vector3.hpp>
//#define ENABLE_SYSCALL_TRACE 1
#include "syscalls_helpers.hpp"
#include <cmath>
#include <functional> // std::hash

namespace riscv {

APICALL(api_vec3_ops) {
	auto [v, v2addr, op] = machine.sysargs<Vector3 *, gaddr_t, Vec3_Op>();
	SYS_TRACE("vec3_ops", v, v2addr, int(op));

	switch (op) {
		case Vec3_Op::HASH: {
			gaddr_t seed = 0;
			hash_combine(seed, std::hash<float>{}(v->x));
			hash_combine(seed, std::hash<float>{}(v->y));
			hash_combine(seed, std::hash<float>{}(v->z));
			machine.set_result(seed);
			break;
		}
		case Vec3_Op::LENGTH: {
			machine.set_result(sqrt(v->x * v->x + v->y * v->y + v->z * v->z));
			break;
		}
		case Vec3_Op::NORMALIZE: {
			const float length = sqrt(v->x * v->x + v->y * v->y + v->z * v->z);
			if (length > 0.0001f) // FLT_EPSILON?
			{
				v->x /= length;
				v->y /= length;
				v->z /= length;
			}
			break;
		}
		case Vec3_Op::CROSS: {
			Vector3 *v2 = machine.memory.memarray<Vector3>(v2addr, 1);
			const gaddr_t resaddr = machine.cpu.reg(13); // a3
			Vector3 *res = machine.memory.memarray<Vector3>(resaddr, 1);
			res->x = v->y * v2->z - v->z * v2->y;
			res->y = v->z * v2->x - v->x * v2->z;
			res->z = v->x * v2->y - v->y * v2->x;
			break;
		}
		case Vec3_Op::DOT: {
			Vector3 *v2 = machine.memory.memarray<Vector3>(v2addr, 1);
			machine.set_result(v->x * v2->x + v->y * v2->y + v->z * v2->z);
			break;
		}
		case Vec3_Op::ANGLE_TO: {
			Vector3 *v2 = machine.memory.memarray<Vector3>(v2addr, 1);
			machine.set_result(float(v->angle_to(*v2)));
			break;
		}
		case Vec3_Op::DISTANCE_TO: {
			Vector3 *v2 = machine.memory.memarray<Vector3>(v2addr, 1);
			const float dx = v->x - v2->x;
			const float dy = v->y - v2->y;
			const float dz = v->z - v2->z;
			machine.set_result(sqrt(dx * dx + dy * dy + dz * dz));
			break;
		}
		case Vec3_Op::DISTANCE_SQ_TO: {
			Vector3 *v2 = machine.memory.memarray<Vector3>(v2addr, 1);
			const float dx = v->x - v2->x;
			const float dy = v->y - v2->y;
			const float dz = v->z - v2->z;
			machine.set_result(float(dx * dx + dy * dy + dz * dz));
			break;
		}
		case Vec3_Op::FLOOR: {
			machine.set_result(floorf(v->x), floorf(v->y), floorf(v->z));
			break;
		}
		default:
			ERR_PRINT("Invalid Vec3 operation");
			throw std::runtime_error("Invalid Vec3 operation");
	}
}

APICALL(api_transform3d_ops) {
	auto [idx, op] = machine.sysargs<unsigned, Transform3D_Op>();
	SYS_TRACE("transform3d_ops", idx, int(op));
	Sandbox &emu = riscv::emu(machine);

	if (op == Transform3D_Op::CREATE) {
		const gaddr_t vaddr = machine.cpu.reg(12); // A2 (Result index)
		unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);
		const Vector3 *v3 = machine.memory.memarray<Vector3>(machine.cpu.reg(13), 1); // A3
		unsigned b_idx = machine.cpu.reg(14); // A4 (Basis index)

		// Get the basis from the given index.
		const Basis basis = emu.get_scoped_variant(b_idx).value()->operator Basis();

		// Create a new scoped Variant with the transform.
		*vidx = emu.create_scoped_variant(Variant(Transform3D(basis, *v3)));
		return;
	} else if (op == Transform3D_Op::IDENTITY) {
		const gaddr_t vaddr = machine.cpu.reg(12); // A2
		unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

		// Create a new scoped Variant with the identity transform.
		*vidx = emu.create_scoped_variant(Variant(Transform3D()));
		return;
	}

	std::optional<const Variant *> opt_t = emu.get_scoped_variant(idx);
	if (!opt_t.has_value() || (*opt_t)->get_type() != Variant::TRANSFORM3D) {
		ERR_PRINT("Invalid Transform3D object");
		throw std::runtime_error("Invalid Transform3D object: " + std::to_string(int32_t(idx)));
	}
	const Variant *t_variant = *opt_t;
	godot::Transform3D t = t_variant->operator Transform3D();

	// Additional integers start at A2 (12), and floats start at FA0 (10).
	switch (op) {
		case Transform3D_Op::ASSIGN: {
			unsigned *new_idx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned t2_idx = machine.cpu.reg(13); // A3
			const Variant *t2 = emu.get_scoped_variant(t2_idx).value();

			// Smart-assign the given transform to the current Variant.
			*new_idx = emu.try_reuse_assign_variant(idx, *t_variant, *new_idx, *t2);
			break;
		}
		case Transform3D_Op::GET_BASIS: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);
			const Basis &basis = t.basis;

			// Create a new scoped Variant with the basis.
			*vidx = emu.create_scoped_variant(Variant(basis));
			break;
		}
		case Transform3D_Op::SET_BASIS: {
			unsigned *new_idx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned b_idx = machine.cpu.reg(13); // A3
			const Variant *vbasis = emu.get_scoped_variant(b_idx).value();

			// Set the basis of the current transform.
			t.basis = vbasis->operator Basis();
			*new_idx = emu.try_reuse_assign_variant(idx, *t_variant, *new_idx, Variant(t));
			break;
		}
		case Transform3D_Op::GET_ORIGIN: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			Vector3 *vres = machine.memory.memarray<Vector3>(vaddr, 1);

			*vres = t.origin;
			break;
		}
		case Transform3D_Op::SET_ORIGIN: {
			unsigned *new_idx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *origin = machine.memory.memarray<Vector3>(v3addr, 1);

			// Set the origin of the current transform.
			t.origin = *origin;
			*new_idx = emu.try_reuse_assign_variant(idx, *t_variant, *new_idx, Variant(t));
			break;
		}
		case Transform3D_Op::ROTATED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *axis = machine.memory.memarray<Vector3>(v3addr, 1);
			const double angle = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Rotate the transform by the given axis and angle, return a new transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.rotated(*axis, angle)));
			break;
		}
		case Transform3D_Op::ROTATED_LOCAL: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *axis = machine.memory.memarray<Vector3>(v3addr, 1);
			const double angle = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Rotate the transform by the given axis and angle, return a new transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.rotated_local(*axis, angle)));
			break;
		}
		case Transform3D_Op::SCALED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *scale = machine.memory.memarray<Vector3>(v3addr, 1);

			// Scale the transform by the given scale, return a new transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.scaled(*scale)));
			break;
		}
		case Transform3D_Op::SCALED_LOCAL: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *scale = machine.memory.memarray<Vector3>(v3addr, 1);

			// Scale the transform by the given scale in local space, return a new transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.scaled_local(*scale)));
			break;
		}
		case Transform3D_Op::TRANSLATED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *offset = machine.memory.memarray<Vector3>(v3addr, 1);

			// Translate the transform by the given offset, return a new transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.translated(*offset)));
			break;
		}
		case Transform3D_Op::TRANSLATED_LOCAL: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *offset = machine.memory.memarray<Vector3>(v3addr, 1);

			// Translate the transform by the given offset in local space, return a new transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.translated_local(*offset)));
			break;
		}
		case Transform3D_Op::INVERTED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Return the inverse of the current transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.inverse()));
			break;
		}
		case Transform3D_Op::ORTHONORMALIZED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Return the orthonormalized version of the current transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.orthonormalized()));
			break;
		}
		case Transform3D_Op::LOOKING_AT: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);
			const Vector3 *target = machine.memory.memarray<Vector3>(machine.cpu.reg(13), 1); // A3
			const Vector3 *up = machine.memory.memarray<Vector3>(machine.cpu.reg(14), 1); // A4

			// Return the transform looking at the target with the given up vector.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t.looking_at(*target, *up)));
			break;
		}
		case Transform3D_Op::INTERPOLATE_WITH: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const unsigned t2_idx = machine.cpu.reg(13); // A3
			const Transform3D to = emu.get_scoped_variant(t2_idx).value()->operator Transform3D();
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // fa0

			t = t.interpolate_with(to, weight);
			// Return the interpolated transform between the current and the given transform.
			*vidx = emu.try_reuse_assign_variant(idx, *t_variant, *vidx, Variant(t));
			break;
		}
		default:
			ERR_PRINT("Invalid Transform3D operation");
			throw std::runtime_error("Invalid Transform3D operation");
	}
}

APICALL(api_basis_ops) {
	auto [idx, op] = machine.sysargs<unsigned, Basis_Op>();
	SYS_TRACE("basis_ops", idx, int(op));
	Sandbox &emu = riscv::emu(machine);

	if (op == Basis_Op::IDENTITY) {
		const gaddr_t vaddr = machine.cpu.reg(12); // A2
		unsigned *tres = machine.memory.memarray<unsigned>(vaddr, 1);

		*tres = emu.create_scoped_variant(Variant(Basis()));
		return;
	} else if (op == Basis_Op::CREATE) {
		const gaddr_t vaddr = machine.cpu.reg(12); // A2
		unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);
		const Vector3 *v1 = machine.memory.memarray<Vector3>(machine.cpu.reg(13), 1); // A3
		const Vector3 *v2 = machine.memory.memarray<Vector3>(machine.cpu.reg(14), 1); // A4
		const Vector3 *v3 = machine.memory.memarray<Vector3>(machine.cpu.reg(15), 1); // A5

		// Create a new scoped Variant with the given vectors.
		*vidx = emu.create_scoped_variant(Variant(Basis(*v1, *v2, *v3)));
		return;
	}

	std::optional<const Variant *> opt_b = emu.get_scoped_variant(idx);
	if (!opt_b.has_value() || opt_b.value()->get_type() != Variant::BASIS) {
		ERR_PRINT("Invalid Basis object");
		throw std::runtime_error("Invalid Basis object");
	}
	const Variant *b_variant = *opt_b;
	godot::Basis b = b_variant->operator Basis();

	// Additional integers start at A2 (12), and floats start at FA0 (10).
	switch (op) {
		case Basis_Op::ASSIGN: {
			unsigned *new_idx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned b_idx = machine.cpu.reg(13); // A3
			const Variant *new_value = emu.get_scoped_variant(b_idx).value();

			// Smart-assign the given basis to the current Variant.
			*new_idx = emu.try_reuse_assign_variant(idx, *b_variant, *new_idx, *new_value);
			break;
		}
		case Basis_Op::GET_ROW: {
			const unsigned row = machine.cpu.reg(12); // A2
			if (row < 0 || row >= 3) {
				ERR_PRINT("Invalid Basis row");
				throw std::runtime_error("Invalid Basis row " + std::to_string(row));
			}
			Vector3 *vres = machine.memory.memarray<Vector3>(machine.cpu.reg(13), 1); // A3

			*vres = b[row];
			break;
		}
		case Basis_Op::SET_ROW: {
			unsigned *vidx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned row = machine.cpu.reg(13); // A3
			if (row < 0 || row >= 3) {
				ERR_PRINT("Invalid Basis row");
				throw std::runtime_error("Invalid Basis row " + std::to_string(row));
			}

			const gaddr_t v3addr = machine.cpu.reg(14); // A4
			const Vector3 *v = machine.memory.memarray<Vector3>(v3addr, 1);

			// Set the row of the current basis.
			b[row] = *v;
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b));
			break;
		}
		case Basis_Op::GET_COLUMN: {
			const unsigned column = machine.cpu.reg(12); // A2
			if (column < 0 || column >= 3) {
				ERR_PRINT("Invalid Basis column");
				throw std::runtime_error("Invalid Basis column " + std::to_string(column));
			}
			Vector3 *vres = machine.memory.memarray<Vector3>(machine.cpu.reg(13), 1); // A3

			*vres = b.get_column(column);
			break;
		}
		case Basis_Op::SET_COLUMN: {
			unsigned *vidx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned column = machine.cpu.reg(13); // A3
			if (column < 0 || column >= 3) {
				ERR_PRINT("Invalid Basis column");
				throw std::runtime_error("Invalid Basis column " + std::to_string(column));
			}
			const Vector3 *v = machine.memory.memarray<Vector3>(machine.cpu.reg(14), 1); // A4

			// Set the column of the current basis.
			b.set_column(column, *v);
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b));
			break;
		}
		case Basis_Op::TRANSPOSED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Return the transposed version of the current basis.
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b.transposed()));
			break;
		}
		case Basis_Op::INVERTED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Return the inverse of the current basis.
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b.inverse()));
			break;
		}
		case Basis_Op::DETERMINANT: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			double *res = machine.memory.memarray<double>(vaddr, 1);

			// Return the determinant of the current basis.
			*res = b.determinant();
			break;
		}
		case Basis_Op::ROTATED: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			const gaddr_t v3addr = machine.cpu.reg(13); // A3
			const Vector3 *axis = machine.memory.memarray<Vector3>(v3addr, 1);
			const double angle = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Rotate the basis by the given axis and angle, return a new basis.
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b.rotated(*axis, angle)));
			break;
		}
		case Basis_Op::LERP: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Get the second basis (from scoped Variant index) to interpolate with.
			const unsigned b_idx = machine.cpu.reg(13); // A3
			const Basis b2 = emu.get_scoped_variant(b_idx).value()->operator Basis();
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Linearly interpolate between the two bases, return a new basis.
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b.lerp(b2, weight)));
			break;
		}
		case Basis_Op::SLERP: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Get the second basis (from scoped Variant index) to interpolate with.
			const unsigned b_idx = machine.cpu.reg(13); // A3
			const Basis b2 = emu.get_scoped_variant(b_idx).value()->operator Basis();
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Spherically interpolate between the two bases, return a new basis.
			*vidx = emu.try_reuse_assign_variant(idx, *b_variant, *vidx, Variant(b.slerp(b2, weight)));
			break;
		}
		default:
			ERR_PRINT("Invalid Basis operation");
			throw std::runtime_error("Invalid Basis operation: " + std::to_string(int(op)));
	}
}

APICALL(api_quat_ops) {
	auto [idx, op] = machine.sysargs<unsigned, Quaternion_Op>();
	SYS_TRACE("quat_ops", idx, int(op));
	Sandbox &emu = riscv::emu(machine);
	SYS_TRACE("quat_ops", idx, int(op));
	printf("Quaternion operation %d %d\n", idx, int(op));

	if (op == Quaternion_Op::CREATE) {
		switch (idx) {
			case 0: { // IDENTITY
				const gaddr_t vaddr = machine.cpu.reg(12); // A2
				GuestVariant *vres = machine.memory.memarray<GuestVariant>(vaddr, 1);

				vres->create(emu, Quaternion());
				return;
			}
			case 1: { // FROM_AXIS_ANGLE
				const gaddr_t vaddr = machine.cpu.reg(12); // A2
				unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);
				const Vector3 *axis = machine.memory.memarray<Vector3>(machine.cpu.reg(13), 1); // A3
				const double angle = machine.cpu.registers().getfl(10).get<double>(); // fa0

				// Create a new scoped Variant with the given axis and angle.
				*vidx = emu.create_scoped_variant(Variant(Quaternion(*axis, angle)));
				return;
			}
			default:
				ERR_PRINT("Invalid Quaternion constructor");
				throw std::runtime_error("Invalid Quaternion constructor: " + std::to_string(idx));
		}
		__builtin_unreachable();
	}

	// Outside of CREATE (constructor) operations, idx is the scoped Variant index for the Quaternion.
	std::optional<const Variant *> opt_q = emu.get_scoped_variant(idx);
	if (!opt_q.has_value() || opt_q.value()->get_type() != Variant::QUATERNION) {
		ERR_PRINT("Invalid Quaternion object");
		throw std::runtime_error("Invalid Quaternion object");
	}
	const Variant *q_variant = *opt_q;
	godot::Quaternion q = q_variant->operator Quaternion();

	// Additional integers start at A2 (12), and floats start at FA0 (10).
	switch (op) {
		case Quaternion_Op::ASSIGN: {
			unsigned *new_idx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2
			const unsigned q_idx = machine.cpu.reg(13); // A3
			const Variant *new_value = emu.get_scoped_variant(q_idx).value();
			printf("Quaternion assign %d %d\n", idx, q_idx);

			// Smart-assign the given quaternion to the current Variant.
			*new_idx = emu.try_reuse_assign_variant(idx, *q_variant, *new_idx, *new_value);
			return;
		}
		case Quaternion_Op::DOT: {
			const unsigned q2_idx = machine.cpu.reg(12); // A2
			const Quaternion q2 = emu.get_scoped_variant(q2_idx).value()->operator Quaternion();
			double *res = machine.memory.memarray<double>(machine.cpu.reg(13), 1); // A3

			// Return the dot product of the two quaternions.
			*res = q.dot(q2);
			return;
		}
		case Quaternion_Op::LENGTH_SQUARED: {
			double *res = machine.memory.memarray<double>(machine.cpu.reg(12), 1); // A2

			// Return the squared length of the quaternion.
			*res = q.length_squared();
			return;
		}
		case Quaternion_Op::LENGTH: {
			double *res = machine.memory.memarray<double>(machine.cpu.reg(12), 1); // A2

			// Return the length of the quaternion.
			*res = q.length();
			return;
		}
		case Quaternion_Op::NORMALIZE: {
			unsigned *vidx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2

			// Create a new normalized quaternion and store it in the destination Variant.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q.normalized()));
			return;
		}
		case Quaternion_Op::INVERSE: {
			unsigned *vidx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2

			// Create a new inverse quaternion and store it in the destination Variant.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q.inverse()));
			return;
		}
		case Quaternion_Op::LOG: {
			unsigned *vidx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2

			// Create a new logarithmic quaternion and store it in the destination Variant.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q.log()));
			return;
		}
		case Quaternion_Op::EXP: {
			unsigned *vidx = machine.memory.memarray<unsigned>(machine.cpu.reg(12), 1); // A2

			// Create a new exponential quaternion and store it in the destination Variant.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q.exp()));
			return;
		}
		case Quaternion_Op::AT: {
			const unsigned idx = machine.cpu.reg(12); // A2
			if (idx < 0 || idx >= 4) {
				ERR_PRINT("Invalid Quaternion index");
				throw std::runtime_error("Invalid Quaternion index: " + std::to_string(idx));
			}
			double *res = machine.memory.memarray<double>(machine.cpu.reg(13), 1); // A3

			*res = q[idx];
			return;
		}
		case Quaternion_Op::GET_AXIS: {
			Vector3 *vres = machine.memory.memarray<Vector3>(machine.cpu.reg(12), 1); // A2

			*vres = q.get_axis();
			return;
		}
		case Quaternion_Op::GET_ANGLE: {
			double *res = machine.memory.memarray<double>(machine.cpu.reg(12), 1); // A2

			// Return the angle of the quaternion.
			*res = q.get_angle();
			return;
		}
		case Quaternion_Op::MUL: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);
			const unsigned q2_idx = machine.cpu.reg(13); // A3
			const Quaternion q2 = emu.get_scoped_variant(q2_idx).value()->operator Quaternion();

			// Multiply the two quaternions, return a new quaternion.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q * q2));
			return;
		}
		case Quaternion_Op::SLERP: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Get the second quaternion (from scoped Variant index) to interpolate with.
			const unsigned q2_idx = machine.cpu.reg(13); // A3
			const Quaternion q2 = emu.get_scoped_variant(q2_idx).value()->operator Quaternion();
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Spherically interpolate between the two quaternions, return a new quaternion.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q.slerp(q2, weight)));
			return;
		}
		case Quaternion_Op::SLERPNI: {
			const gaddr_t vaddr = machine.cpu.reg(12); // A2
			unsigned *vidx = machine.memory.memarray<unsigned>(vaddr, 1);

			// Get the second quaternion (from scoped Variant index) to interpolate with.
			const unsigned q2_idx = machine.cpu.reg(13); // A3
			const Quaternion q2 = emu.get_scoped_variant(q2_idx).value()->operator Quaternion();
			const double weight = machine.cpu.registers().getfl(10).get<double>(); // fa0

			// Spherically interpolate between the two quaternions, return a new quaternion.
			*vidx = emu.try_reuse_assign_variant(idx, *q_variant, *vidx, Variant(q.slerpni(q2, weight)));
			return;
		}
		default:
			ERR_PRINT("Invalid Quaternion operation");
			throw std::runtime_error("Invalid Quaternion operation: " + std::to_string(int(op)));
	}
}

} // namespace riscv

void Sandbox::initialize_syscalls_3d() {
	using namespace riscv;

	// Add the Godot system calls.
	machine_t::install_syscall_handlers({
			{ ECALL_VEC3_OPS, api_vec3_ops },
			{ ECALL_TRANSFORM_3D_OPS, api_transform3d_ops },
			{ ECALL_BASIS_OPS, api_basis_ops },
			{ ECALL_QUAT_OPS, api_quat_ops },
	});
}

```

`src/scoped_tree_base.h`:

```h
#pragma once

#include "sandbox.h"
#include <godot_cpp/classes/node.hpp>

struct ScopedTreeBase {
	Sandbox *sandbox = nullptr;
	godot::Node *old_tree_base = nullptr;

	ScopedTreeBase(Sandbox *sandbox, godot::Node *old_tree_base) :
			sandbox(sandbox),
			old_tree_base(sandbox->get_tree_base()) {
		sandbox->set_tree_base(old_tree_base);
	}

	~ScopedTreeBase() {
		sandbox->set_tree_base(old_tree_base);
	}
};

```

`src/script_language_common.h`:

```h
#pragma once

static constexpr bool register_language_icons = false;

```

`src/syscalls.h`:

```h
#pragma once
#define GAME_API_BASE 5
```

`src/syscalls_helpers.hpp`:

```hpp
#pragma once
#include <libriscv/machine.hpp>

#define APICALL(func) static void func(machine_t &machine [[maybe_unused]])

#ifdef ENABLE_SYSCALL_TRACE
#define SYS_TRACE(name, result, ...) sys_trace(name, result, ##__VA_ARGS__)
#else
#define SYS_TRACE(name, result, ...)
#endif

namespace riscv {

inline Sandbox &emu(machine_t &m) {
	return *m.get_userdata<Sandbox>();
}

// clang-format off
template <typename Result, typename... Args>
static inline void sys_trace(const String &name, Result result, Args &&...args) {
	char buffer[512];
	char *ptr = buffer;
	ptr += snprintf(ptr, sizeof(buffer), "[TRACE] %s (", name.utf8().ptr());
	([&] {
		if constexpr (std::is_same_v<Args, const char *>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%s", args);
		} else if constexpr (std::is_same_v<Args, String>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%s", args.utf8().ptr());
		} else if constexpr (std::is_same_v<Args, StringName>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%s", String(args).utf8().ptr());
		} else if constexpr (std::is_same_v<Args, GuestVariant *>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "Variant(type=%d %s)", args->type, GuestVariant::type_name(args->type));
		} else if constexpr (std::is_pointer_v<Args>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%p", args);
		} else if constexpr (std::is_floating_point_v<Args>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%f", args);
		} else if constexpr (std::is_same_v<Args, gaddr_t>) {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "0x%lX", long(args));
		} else {
			ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%ld", long(args));
		}
	}(), ...);
	ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), ") -> ");
	if constexpr (std::is_pointer_v<Result>) {
		ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%p", result);
	} else if constexpr (std::is_same_v<Result, String>) {
		ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%s", result.utf8().ptr());
	} else if constexpr (std::is_same_v<Result, Variant>) {
		ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "Variant(type=%d %s)", result.get_type(), GuestVariant::type_name(result.get_type()));
	} else if constexpr (std::is_floating_point_v<Result>) {
		ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%f", result);
	} else if constexpr (std::is_same_v<Result, gaddr_t>) {
		ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "0x%lX", long(result));
	} else {
		ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "%ld", long(result));
	}
	ptr += snprintf(ptr, sizeof(buffer) - (ptr - buffer), "\n");
	if (ptr >= buffer + sizeof(buffer)) {
		ptr = buffer + sizeof(buffer) - 1;
	}
	fwrite(buffer, 1, ptr - buffer, stderr);
	fflush(stderr);
}
// clang-format on

	template <typename T>
	using CppVector = riscv::GuestStdVector<RISCV_ARCH, T>;

	using CppString = riscv::GuestStdString<RISCV_ARCH>;

} // namespace riscv

```

`src/tests/assault.cpp`:

```cpp
#include "../guest_datatypes.h"

#include <random>

/**
 * @brief Assault the sandbox with random GuestVariants.
 *
 * @param test An unused string. TBD.
 * @param iterations The number of GuestVariants to create.
 */
void Sandbox::assault(const String &test, int64_t iterations) {
	Sandbox sandbox;
	Sandbox::CurrentState state;
	sandbox.m_current_state = &state;

	// Create a random number generator.
	std::random_device rd;
	std::uniform_int_distribution<int> rand(0, 256);
	std::uniform_int_distribution<int> type_rand(0, Variant::VARIANT_MAX);

	for (size_t i = 0; i < iterations; i++) {
		std::array<uint8_t, sizeof(GuestVariant)> data;
		std::generate(data.begin(), data.end(), [&]() { return rand(rd); });
		// Create a random GuestVariant
		GuestVariant v;
		std::memcpy(&v, data.data(), data.size());
		// Make the type valid
		v.type = static_cast<Variant::Type>(type_rand(rd));

		try {
			// Try to use the GuestVariant
			v.toVariant(sandbox);
		} catch (const std::exception &e) {
			// If an exception is thrown, the test will just continue
			// We are only interested in knowing if the guest crashes
		}
	}
}
```

`src/tests/dummy_assault.cpp`:

```cpp
#include "../sandbox.h"

void Sandbox::assault(const String &test, int64_t iterations) {
	// Do nothing on actual platforms. This is a test function.
}

```

`src/vmcallable.h`:

```h
#pragma once
#include <godot_cpp/variant/variant.hpp>
using namespace godot;

class Sandbox;
struct GuestVariant;

class RiscvCallable : public CallableCustom {
public:
	uint32_t hash() const override {
		return address;
	}

	String get_as_text() const override {
		return "<RiscvCallable>";
	}

	CompareEqualFunc get_compare_equal_func() const override {
		return [](const CallableCustom *p_a, const CallableCustom *p_b) {
			return p_a == p_b;
		};
	}

	CompareLessFunc get_compare_less_func() const override {
		return [](const CallableCustom *p_a, const CallableCustom *p_b) {
			return p_a < p_b;
		};
	}

	bool is_valid() const override {
		return self != nullptr;
	}

	ObjectID get_object() const override {
		return ObjectID();
	}

	void call(const Variant **p_arguments, int p_argcount, Variant &r_return_value, GDExtensionCallError &r_call_error) const override;

	void init(Sandbox *self, gaddr_t address, Array args) {
		this->self = self;
		this->address = address;

		for (int i = 0; i < args.size(); i++) {
			m_varargs[i] = args[i];
			m_varargs_ptrs[i] = &m_varargs[i];
		}
		this->m_varargs_base_count = args.size();
	}

private:
	Sandbox *self = nullptr;
	gaddr_t address = 0x0;

	std::array<Variant, 8> m_varargs;
	mutable std::array<const Variant *, 8> m_varargs_ptrs;
	int m_varargs_base_count = 0;
};

```

`src/vmproperty.h`:

```h
#pragma once
#include <godot_cpp/variant/variant.hpp>
using namespace godot;

class Sandbox;

// This class is used to represent a property in the guest.
class SandboxProperty {
	StringName m_name;
	Variant::Type m_type = Variant::Type::NIL;
	uint64_t m_setter_address = 0;
	uint64_t m_getter_address = 0;
	uint64_t m_address = 0;
	Variant m_def_val;

public:
	SandboxProperty(const StringName &name, Variant::Type type, uint64_t setter, uint64_t getter, const Variant &def = "") :
			m_name(name), m_type(type), m_setter_address(setter), m_getter_address(getter), m_def_val(def) {}
	SandboxProperty(const StringName &name, Variant::Type type, uint64_t address, const Variant &def = "") :
			m_name(name), m_type(type), m_address(address), m_def_val(def) {}

	// Get the name of the property.
	const StringName &name() const { return m_name; }

	// Get the type of the property.
	Variant::Type type() const { return m_type; }

	// Check if the property is read-only.
	bool is_read_only() const { return m_setter_address == 0 && m_address == 0; }

	// Get the address of the setter function.
	uint64_t setter_address() const { return m_setter_address; }
	// Get the address of the getter function.
	uint64_t getter_address() const { return m_getter_address; }

	// Some properties may be represented directly as guest variants.
	bool is_guest_variant() const { return m_address != 0; }
	uint64_t guest_variant_address() const { return m_address; }

	// Get the default value of the property.
	const Variant &default_value() const { return m_def_val; }

	// Call the setter function.
	void set(Sandbox &sandbox, const Variant &value);
	// Call the getter function.
	Variant get(const Sandbox &sandbox) const;
};

```

`src/zig/resource_loader_zig.cpp`:

```cpp
#include "resource_loader_zig.h"
#include "script_zig.h"
#include <godot_cpp/classes/file_access.hpp>

static Ref<ResourceFormatLoaderZig> zig_loader;

void ResourceFormatLoaderZig::init() {
	zig_loader.instantiate();
	ResourceLoader::get_singleton()->add_resource_format_loader(zig_loader);
}

void ResourceFormatLoaderZig::deinit() {
	ResourceLoader::get_singleton()->remove_resource_format_loader(zig_loader);
	zig_loader.unref();
}

Variant ResourceFormatLoaderZig::_load(const String &p_path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const {
	Ref<ZigScript> model = memnew(ZigScript);
	model->_set_source_code(FileAccess::get_file_as_string(p_path));
	return model;
}
PackedStringArray ResourceFormatLoaderZig::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("zig");
	return array;
}
bool ResourceFormatLoaderZig::_handles_type(const StringName &type) const {
	String type_str = type;
	return type_str == "ZigScript" || type_str == "Script";
}
String ResourceFormatLoaderZig::_get_resource_type(const String &p_path) const {
	if (p_path.get_extension() == "zig") {
		return "ZigScript";
	}
	return "";
}

```

`src/zig/resource_loader_zig.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_loader.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

using namespace godot;

class ResourceFormatLoaderZig : public ResourceFormatLoader {
	GDCLASS(ResourceFormatLoaderZig, ResourceFormatLoader);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Variant _load(const String &path, const String &original_path, bool use_sub_threads, int32_t cache_mode) const override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual bool _handles_type(const StringName &type) const override;
	virtual String _get_resource_type(const String &p_path) const override;
};

```

`src/zig/resource_saver_zig.cpp`:

```cpp
#include "resource_saver_zig.h"
#include "../elf/script_elf.h"
#include "../elf/script_language_elf.h"
#include "../register_types.h"
#include "../sandbox_project_settings.h"
#include "script_zig.h"
#include <godot_cpp/classes/editor_file_system.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/editor_settings.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/os.hpp>
#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_editor.hpp>
#include <godot_cpp/classes/script_editor_base.hpp>
#include <godot_cpp/variant/utility_functions.hpp>

static Ref<ResourceFormatSaverZig> zig_saver;
static constexpr bool VERBOSE_CMD = false;

void ResourceFormatSaverZig::init() {
	zig_saver.instantiate();
	ResourceSaver::get_singleton()->add_resource_format_saver(zig_saver);
}

void ResourceFormatSaverZig::deinit() {
	ResourceSaver::get_singleton()->remove_resource_format_saver(zig_saver);
	zig_saver.unref();
}

Error ResourceFormatSaverZig::_save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) {
	ZigScript *script = Object::cast_to<ZigScript>(p_resource.ptr());
	if (script != nullptr) {
		Ref<FileAccess> handle = FileAccess::open(p_path, FileAccess::ModeFlags::WRITE);
		if (handle.is_valid()) {
			handle->store_string(script->_get_source_code());
			handle->close();
			// Get the absolute path without the file name
			String path = handle->get_path().get_base_dir().replace("res://", "") + "/";
			String inpname = path + "*.zig";
			String foldername = Docker::GetFolderName(handle->get_path().get_base_dir());
			String outname = path + foldername + String(".elf");

			// Lazily start the docker container
			ZigScript::DockerContainerStart();

			auto builder = [inpname = std::move(inpname), outname = std::move(outname)] {
				// Invoke docker to compile the file
				Array output;
				ZigScript::DockerContainerExecute({ "/usr/api/build.sh", "-o", outname, inpname }, output);
				if (!output.is_empty() && !output[0].operator String().is_empty()) {
					for (int i = 0; i < output.size(); i++) {
						String line = output[i].operator String();
						if constexpr (VERBOSE_CMD)
							ERR_PRINT(line);
						WARN_PRINT(line);
					}
				}
			};
			builder();
			// EditorInterface::get_singleton()->get_editor_settings()->set("text_editor/behavior/files/auto_reload_scripts_on_external_change", true);
			EditorInterface::get_singleton()->get_resource_filesystem()->scan();
			TypedArray<Script> open_scripts = EditorInterface::get_singleton()->get_script_editor()->get_open_scripts();
			for (int i = 0; i < open_scripts.size(); i++) {
				ELFScript *elf_script = Object::cast_to<ELFScript>(open_scripts[i]);
				if (elf_script) {
					elf_script->reload(false);
					elf_script->emit_changed();
				}
			}
			return Error::OK;
		} else {
			return Error::ERR_FILE_CANT_OPEN;
		}
	}
	return Error::ERR_SCRIPT_FAILED;
}
Error ResourceFormatSaverZig::_set_uid(const String &p_path, int64_t p_uid) {
	return Error::OK;
}
bool ResourceFormatSaverZig::_recognize(const Ref<Resource> &p_resource) const {
	return Object::cast_to<ZigScript>(p_resource.ptr()) != nullptr;
}
PackedStringArray ResourceFormatSaverZig::_get_recognized_extensions(const Ref<Resource> &p_resource) const {
	PackedStringArray array;
	if (Object::cast_to<ZigScript>(p_resource.ptr()) == nullptr)
		return array;
	array.push_back("zig");
	return array;
}
bool ResourceFormatSaverZig::_recognize_path(const Ref<Resource> &p_resource, const String &p_path) const {
	return Object::cast_to<ZigScript>(p_resource.ptr()) != nullptr;
}

```

`src/zig/resource_saver_zig.h`:

```h
#pragma once

#include <godot_cpp/classes/resource_format_saver.hpp>
#include <godot_cpp/classes/resource_saver.hpp>

using namespace godot;

class ResourceFormatSaverZig : public ResourceFormatSaver {
	GDCLASS(ResourceFormatSaverZig, ResourceFormatSaver);

protected:
	static void _bind_methods() {}

public:
	static void init();
	static void deinit();
	virtual Error _save(const Ref<Resource> &p_resource, const String &p_path, uint32_t p_flags) override;
	virtual Error _set_uid(const String &p_path, int64_t p_uid) override;
	virtual bool _recognize(const Ref<Resource> &p_resource) const override;
	virtual PackedStringArray _get_recognized_extensions(const Ref<Resource> &p_resource) const override;
	virtual bool _recognize_path(const Ref<Resource> &p_resource, const String &p_path) const override;
};

```

`src/zig/script_language_zig.cpp`:

```cpp
#include "script_language_zig.h"
#include "../script_language_common.h"
#include "script_zig.h"
#include <godot_cpp/classes/control.hpp>
#include <godot_cpp/classes/editor_interface.hpp>
#include <godot_cpp/classes/engine.hpp>
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>
#include <godot_cpp/classes/texture2d.hpp>
#include <godot_cpp/classes/theme.hpp>
#include <string>
#include <unordered_set>
static constexpr const char *icon_path = "res://addons/godot_sandbox/ZigScript.svg";

static ZigScriptLanguage *zig_language;

void ZigScriptLanguage::init() {
	zig_language = memnew(ZigScriptLanguage);
	Engine::get_singleton()->register_script_language(zig_language);
}
void ZigScriptLanguage::deinit() {
	if (zig_language) {
		Engine::get_singleton()->unregister_script_language(zig_language);
		memdelete(zig_language);
		zig_language = nullptr;
	}
}

ZigScriptLanguage *ZigScriptLanguage::get_singleton() {
	return zig_language;
}

String ZigScriptLanguage::_get_name() const {
	return "ZigScript";
}
void ZigScriptLanguage::_init() {}
String ZigScriptLanguage::_get_type() const {
	return "ZigScript";
}
String ZigScriptLanguage::_get_extension() const {
	return "zig";
}
void ZigScriptLanguage::_finish() {}
PackedStringArray ZigScriptLanguage::_get_reserved_words() const {
	static const PackedStringArray reserved_words{
		"addrspace", "align", "and", "asm", "async", "await", "break", "catch", "comptime", "const", "continue", "defer", "else", "enum", "errdefer", "error", "export", "extern", "for", "if", "inline", "noalias", "noinline", "nosuspend", "opaque", "or", "orelse", "packed", "anyframe", "pub", "resume", "return", "linksection", "callconv", "struct", "suspend", "switch", "test", "threadlocal", "try", "union", "unreachable", "usingnamespace", "var", "volatile", "allowzero", "while", "anytype", "fn"
	};
	return reserved_words;
}
bool ZigScriptLanguage::_is_control_flow_keyword(const String &p_keyword) const {
	static const std::unordered_set<std::string> control_flow_keywords{
		"if", "else", "switch", "case", "default", "while", "loop", "for", "break", "continue", "return", "goto", "resume", "suspend", "defer", "errdefer", "try", "catch", "async", "await"
	};
	return control_flow_keywords.find(p_keyword.utf8().get_data()) != control_flow_keywords.end();
}
PackedStringArray ZigScriptLanguage::_get_comment_delimiters() const {
	PackedStringArray comment_delimiters;
	comment_delimiters.push_back("/* */");
	comment_delimiters.push_back("//");
	return comment_delimiters;
}
PackedStringArray ZigScriptLanguage::_get_doc_comment_delimiters() const {
	PackedStringArray doc_comment_delimiters;
	doc_comment_delimiters.push_back("///");
	doc_comment_delimiters.push_back("/** */");
	return doc_comment_delimiters;
}
PackedStringArray ZigScriptLanguage::_get_string_delimiters() const {
	PackedStringArray string_delimiters;
	string_delimiters.push_back("' '");
	string_delimiters.push_back("\" \"");
	return string_delimiters;
}
Ref<Script> ZigScriptLanguage::_make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const {
	ZigScript *script = memnew(ZigScript);
	return Ref<Script>(script);
}
TypedArray<Dictionary> ZigScriptLanguage::_get_built_in_templates(const StringName &p_object) const {
	return TypedArray<Dictionary>();
}
bool ZigScriptLanguage::_is_using_templates() {
	return false;
}
Dictionary ZigScriptLanguage::_validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const {
	return Dictionary();
}
String ZigScriptLanguage::_validate_path(const String &p_path) const {
	return String();
}
Object *ZigScriptLanguage::_create_script() const {
	ZigScript *script = memnew(ZigScript);
	return script;
}
bool ZigScriptLanguage::_has_named_classes() const {
	return false;
}
bool ZigScriptLanguage::_supports_builtin_mode() const {
	return false;
}
bool ZigScriptLanguage::_supports_documentation() const {
	return false;
}
bool ZigScriptLanguage::_can_inherit_from_file() const {
	return false;
}
int32_t ZigScriptLanguage::_find_function(const String &p_function, const String &p_code) const {
	return -1;
}
String ZigScriptLanguage::_make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const {
	return String();
}
Error ZigScriptLanguage::_open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) {
	return Error::OK;
}
bool ZigScriptLanguage::_overrides_external_editor() {
	return false;
}
Dictionary ZigScriptLanguage::_complete_code(const String &p_code, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
Dictionary ZigScriptLanguage::_lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const {
	return Dictionary();
}
String ZigScriptLanguage::_auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const {
	return String();
}
void ZigScriptLanguage::_add_global_constant(const StringName &p_name, const Variant &p_value) {}
void ZigScriptLanguage::_add_named_global_constant(const StringName &p_name, const Variant &p_value) {}
void ZigScriptLanguage::_remove_named_global_constant(const StringName &p_name) {}
void ZigScriptLanguage::_thread_enter() {}
void ZigScriptLanguage::_thread_exit() {}
String ZigScriptLanguage::_debug_get_error() const {
	return String();
}
int32_t ZigScriptLanguage::_debug_get_stack_level_count() const {
	return 0;
}
int32_t ZigScriptLanguage::_debug_get_stack_level_line(int32_t p_level) const {
	return 0;
}
String ZigScriptLanguage::_debug_get_stack_level_function(int32_t p_level) const {
	return String();
}
Dictionary ZigScriptLanguage::_debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
Dictionary ZigScriptLanguage::_debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
void *ZigScriptLanguage::_debug_get_stack_level_instance(int32_t p_level) {
	return nullptr;
}
Dictionary ZigScriptLanguage::_debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) {
	return Dictionary();
}
String ZigScriptLanguage::_debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) {
	return String();
}
TypedArray<Dictionary> ZigScriptLanguage::_debug_get_current_stack_info() {
	return TypedArray<Dictionary>();
}
void ZigScriptLanguage::_reload_all_scripts() {}
void ZigScriptLanguage::_reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) {}
PackedStringArray ZigScriptLanguage::_get_recognized_extensions() const {
	PackedStringArray array;
	array.push_back("zig");
	return array;
}
TypedArray<Dictionary> ZigScriptLanguage::_get_public_functions() const {
	return TypedArray<Dictionary>();
}
Dictionary ZigScriptLanguage::_get_public_constants() const {
	return Dictionary();
}
TypedArray<Dictionary> ZigScriptLanguage::_get_public_annotations() const {
	return TypedArray<Dictionary>();
}
void ZigScriptLanguage::_profiling_start() {}
void ZigScriptLanguage::_profiling_stop() {}
int32_t ZigScriptLanguage::_profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
int32_t ZigScriptLanguage::_profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) {
	return 0;
}
void ZigScriptLanguage::_frame() {
	static bool icon_registered = register_language_icons;
	if (!icon_registered && Engine::get_singleton()->is_editor_hint()) {
		icon_registered = true;
		// Manually register language icon
		load_icon();
		// Register theme callback
		EditorInterface::get_singleton()->get_base_control()->connect("theme_changed", callable_mp(this, &ZigScriptLanguage::load_icon));
	}
}
void ZigScriptLanguage::load_icon() {
	static bool reenter = false;
	if (reenter)
		return;
	reenter = true;
	if (Engine::get_singleton()->is_editor_hint() && FileAccess::file_exists(icon_path)) {
		Ref<Theme> editor_theme = EditorInterface::get_singleton()->get_editor_theme();
		if (editor_theme.is_valid() && !editor_theme->has_icon("ZigScript", "EditorIcons")) {
			ResourceLoader *resource_loader = ResourceLoader::get_singleton();
			Ref<Texture2D> tex = resource_loader->load(icon_path);
			editor_theme->set_icon("ZigScript", "EditorIcons", tex);
		}
	}
	reenter = false;
}
bool ZigScriptLanguage::_handles_global_class_type(const String &p_type) const {
	return p_type == "ZigScript";
}
Dictionary ZigScriptLanguage::_get_global_class_name(const String &p_path) const {
	return Dictionary();
}

```

`src/zig/script_language_zig.h`:

```h
#pragma once

#include <godot_cpp/classes/script.hpp>
#include <godot_cpp/classes/script_language_extension.hpp>

using namespace godot;

class ZigScriptLanguage : public ScriptLanguageExtension {
	GDCLASS(ZigScriptLanguage, ScriptLanguageExtension);

protected:
	static void _bind_methods() {}
	String file;

public:
	static void init();
	static void deinit();
	static ZigScriptLanguage *get_singleton();

	virtual String _get_name() const override;
	virtual void _init() override;
	virtual String _get_type() const override;
	virtual String _get_extension() const override;
	virtual void _finish() override;
	virtual PackedStringArray _get_reserved_words() const override;
	virtual bool _is_control_flow_keyword(const String &p_keyword) const override;
	virtual PackedStringArray _get_comment_delimiters() const override;
	virtual PackedStringArray _get_doc_comment_delimiters() const override;
	virtual PackedStringArray _get_string_delimiters() const override;
	virtual Ref<Script> _make_template(const String &p_template, const String &p_class_name, const String &p_base_class_name) const override;
	virtual TypedArray<Dictionary> _get_built_in_templates(const StringName &p_object) const override;
	virtual bool _is_using_templates() override;
	virtual Dictionary _validate(const String &p_script, const String &p_path, bool p_validate_functions, bool p_validate_errors, bool p_validate_warnings, bool p_validate_safe_lines) const override;
	virtual String _validate_path(const String &p_path) const override;
	virtual Object *_create_script() const override;
	virtual bool _has_named_classes() const override;
	virtual bool _supports_builtin_mode() const override;
	virtual bool _supports_documentation() const override;
	virtual bool _can_inherit_from_file() const override;
	virtual int32_t _find_function(const String &p_function, const String &p_code) const override;
	virtual String _make_function(const String &p_class_name, const String &p_function_name, const PackedStringArray &p_function_args) const override;
	virtual Error _open_in_external_editor(const Ref<Script> &p_script, int32_t p_line, int32_t p_column) override;
	virtual bool _overrides_external_editor() override;
	virtual Dictionary _complete_code(const String &p_code, const String &p_path, Object *p_owner) const override;
	virtual Dictionary _lookup_code(const String &p_code, const String &p_symbol, const String &p_path, Object *p_owner) const override;
	virtual String _auto_indent_code(const String &p_code, int32_t p_from_line, int32_t p_to_line) const override;
	virtual void _add_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _add_named_global_constant(const StringName &p_name, const Variant &p_value) override;
	virtual void _remove_named_global_constant(const StringName &p_name) override;
	virtual void _thread_enter() override;
	virtual void _thread_exit() override;
	virtual String _debug_get_error() const override;
	virtual int32_t _debug_get_stack_level_count() const override;
	virtual int32_t _debug_get_stack_level_line(int32_t p_level) const override;
	virtual String _debug_get_stack_level_function(int32_t p_level) const override;
	virtual Dictionary _debug_get_stack_level_locals(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual Dictionary _debug_get_stack_level_members(int32_t p_level, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual void *_debug_get_stack_level_instance(int32_t p_level) override;
	virtual Dictionary _debug_get_globals(int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual String _debug_parse_stack_level_expression(int32_t p_level, const String &p_expression, int32_t p_max_subitems, int32_t p_max_depth) override;
	virtual TypedArray<Dictionary> _debug_get_current_stack_info() override;
	virtual void _reload_all_scripts() override;
	virtual void _reload_tool_script(const Ref<Script> &p_script, bool p_soft_reload) override;
	virtual PackedStringArray _get_recognized_extensions() const override;
	virtual TypedArray<Dictionary> _get_public_functions() const override;
	virtual Dictionary _get_public_constants() const override;
	virtual TypedArray<Dictionary> _get_public_annotations() const override;
	virtual void _profiling_start() override;
	virtual void _profiling_stop() override;
	virtual int32_t _profiling_get_accumulated_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual int32_t _profiling_get_frame_data(ScriptLanguageExtensionProfilingInfo *p_info_array, int32_t p_info_max) override;
	virtual void _frame() override;
	virtual bool _handles_global_class_type(const String &p_type) const override;
	virtual Dictionary _get_global_class_name(const String &p_path) const override;
	void load_icon();

	ZigScriptLanguage() {}
	~ZigScriptLanguage() {}
};

```

`src/zig/script_zig.cpp`:

```cpp
#include "script_zig.h"

#include "script_language_zig.h"
#include <godot_cpp/classes/file_access.hpp>
#include <godot_cpp/classes/resource_loader.hpp>

bool ZigScript::_editor_can_reload_from_file() {
	return true;
}
void ZigScript::_placeholder_erased(void *p_placeholder) {}
bool ZigScript::_can_instantiate() const {
	return false;
}
Ref<Script> ZigScript::_get_base_script() const {
	return Ref<Script>();
}
StringName ZigScript::_get_global_name() const {
	return StringName();
}
bool ZigScript::_inherits_script(const Ref<Script> &p_script) const {
	return false;
}
StringName ZigScript::_get_instance_base_type() const {
	return StringName();
}
void *ZigScript::_instance_create(Object *p_for_object) const {
	return nullptr;
}
void *ZigScript::_placeholder_instance_create(Object *p_for_object) const {
	return nullptr;
}
bool ZigScript::_instance_has(Object *p_object) const {
	return false;
}
bool ZigScript::_has_source_code() const {
	return true;
}
String ZigScript::_get_source_code() const {
	return source_code;
}
void ZigScript::_set_source_code(const String &p_code) {
	source_code = p_code;
}
Error ZigScript::_reload(bool p_keep_state) {
	return Error::OK;
}
TypedArray<Dictionary> ZigScript::_get_documentation() const {
	return TypedArray<Dictionary>();
}
String ZigScript::_get_class_icon_path() const {
	return String("res://addons/godot_sandbox/ZigScript.svg");
}
bool ZigScript::_has_method(const StringName &p_method) const {
	return false;
}
bool ZigScript::_has_static_method(const StringName &p_method) const {
	return false;
}
Dictionary ZigScript::_get_method_info(const StringName &p_method) const {
	return Dictionary();
}
bool ZigScript::_is_tool() const {
	return true;
}
bool ZigScript::_is_valid() const {
	return true;
}
bool ZigScript::_is_abstract() const {
	return true;
}
ScriptLanguage *ZigScript::_get_language() const {
	return ZigScriptLanguage::get_singleton();
}
bool ZigScript::_has_script_signal(const StringName &p_signal) const {
	return false;
}
TypedArray<Dictionary> ZigScript::_get_script_signal_list() const {
	return TypedArray<Dictionary>();
}
bool ZigScript::_has_property_default_value(const StringName &p_property) const {
	return false;
}
Variant ZigScript::_get_property_default_value(const StringName &p_property) const {
	return Variant();
}
void ZigScript::_update_exports() {}
TypedArray<Dictionary> ZigScript::_get_script_method_list() const {
	return TypedArray<Dictionary>();
}
TypedArray<Dictionary> ZigScript::_get_script_property_list() const {
	return TypedArray<Dictionary>();
}
int32_t ZigScript::_get_member_line(const StringName &p_member) const {
	return 0;
}
Dictionary ZigScript::_get_constants() const {
	return Dictionary();
}
TypedArray<StringName> ZigScript::_get_members() const {
	return TypedArray<StringName>();
}
bool ZigScript::_is_placeholder_fallback_enabled() const {
	return false;
}
Variant ZigScript::_get_rpc_config() const {
	return Variant();
}

ZigScript::ZigScript() {
	source_code = R"C0D3(
// TODO: Implement me.
)C0D3";
}

```

`src/zig/script_zig.h`:

```h
#pragma once

#include "../docker.h"
#include <godot_cpp/classes/script_extension.hpp>
#include <godot_cpp/classes/script_language.hpp>

using namespace godot;

class ZigScript : public ScriptExtension {
	GDCLASS(ZigScript, ScriptExtension);

protected:
	static void _bind_methods() {}
	String source_code;

public:
	virtual bool _editor_can_reload_from_file() override;
	virtual void _placeholder_erased(void *p_placeholder) override;
	virtual bool _can_instantiate() const override;
	virtual Ref<Script> _get_base_script() const override;
	virtual StringName _get_global_name() const override;
	virtual bool _inherits_script(const Ref<Script> &p_script) const override;
	virtual StringName _get_instance_base_type() const override;
	virtual void *_instance_create(Object *p_for_object) const override;
	virtual void *_placeholder_instance_create(Object *p_for_object) const override;
	virtual bool _instance_has(Object *p_object) const override;
	virtual bool _has_source_code() const override;
	virtual String _get_source_code() const override;
	virtual void _set_source_code(const String &p_code) override;
	virtual Error _reload(bool p_keep_state) override;
	virtual TypedArray<Dictionary> _get_documentation() const override;
	virtual String _get_class_icon_path() const override;
	virtual bool _has_method(const StringName &p_method) const override;
	virtual bool _has_static_method(const StringName &p_method) const override;
	virtual Dictionary _get_method_info(const StringName &p_method) const override;
	virtual bool _is_tool() const override;
	virtual bool _is_valid() const override;
	virtual bool _is_abstract() const override;
	virtual ScriptLanguage *_get_language() const override;
	virtual bool _has_script_signal(const StringName &p_signal) const override;
	virtual TypedArray<Dictionary> _get_script_signal_list() const override;
	virtual bool _has_property_default_value(const StringName &p_property) const override;
	virtual Variant _get_property_default_value(const StringName &p_property) const override;
	virtual void _update_exports() override;
	virtual TypedArray<Dictionary> _get_script_method_list() const override;
	virtual TypedArray<Dictionary> _get_script_property_list() const override;
	virtual int32_t _get_member_line(const StringName &p_member) const override;
	virtual Dictionary _get_constants() const override;
	virtual TypedArray<StringName> _get_members() const override;
	virtual bool _is_placeholder_fallback_enabled() const override;
	virtual Variant _get_rpc_config() const override;

	static void DockerContainerStart() {
		if (!docker_container_started) {
			Array output;
			if (Docker::ContainerStart(docker_container_name, docker_image_name, output))
				docker_container_started = true;
			else {
				UtilityFunctions::print(output);
				ERR_PRINT("Failed to start Docker container");
			}
		}
	}
	static void DockerContainerStop() {
		if (docker_container_started) {
			Docker::ContainerStop(docker_container_name);
			docker_container_started = false;
		}
	}
	static int DockerContainerVersion() {
		DockerContainerStart();
		if (docker_container_version == 0)
			docker_container_version =
					Docker::ContainerVersion(docker_container_name, { "/usr/api/build.sh", "--version" });
		return docker_container_version;
	}
	static bool DockerContainerExecute(const PackedStringArray &p_arguments, Array &output) {
		return Docker::ContainerExecute(docker_container_name, p_arguments, output);
	}

	ZigScript();
	~ZigScript() {}

private:
	static inline bool docker_container_started = false;
	static inline int docker_container_version = 0;
	static inline const char *docker_container_name = "godot-zig-compiler";
	static inline const char *docker_image_name = "ghcr.io/libriscv/zig_compiler";
};

```

`tests/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(unittests LANGUAGES C CXX)

add_subdirectory(../program/cpp/cmake sandbox_api)
add_subdirectory(../src/gdscript/compiler gdscript_compiler)

add_sandbox_program(unittests
	"tests/test_basic.cpp"
	"tests/test_math.cpp"
	"tests/test_properties.cpp"
	"tests/test_shm.cpp"
	"tests/test_gdscript_compiler.cpp"
)
target_link_libraries(unittests PRIVATE sandbox_api gdscript_compiler)

```

`tests/debug.sh`:

```sh
GDB=tests/tests.elf bash run_unittests.sh -gprefix=test_bas

```

`tests/extensions/libgodot-riscv.gdextension`:

```gdextension
[configuration]

entry_symbol = "riscv_library_init"
compatibility_minimum = "4.3"

[icons]


[libraries]

macos.debug = "bin/libgodot-riscv.macos.debug.framework"
macos.release = "bin/libgodot-riscv.macos.release.framework"
windows.debug.x86_64 = "bin/libgodot-riscv.windows.debug.x86_64.dll"
windows.release.x86_64 = "bin/libgodot-riscv.windows.release.x86_64.dll"
linux.debug.x86_64 = "bin/libgodot-riscv.linux.debug.x86_64.so"
linux.release.x86_64 = "bin/libgodot-riscv.linux.release.x86_64.so"
web.debug.wasm32 = "bin/libgodot_riscv.web.template_debug.wasm32.wasm"
web.release.wasm32 = "bin/libgodot_riscv.web.template_release.wasm32.wasm"

```

`tests/icon.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><rect width="124" height="124" x="2" y="2" fill="#363d52" stroke="#212532" stroke-width="4" rx="14"/><g fill="#fff" transform="translate(12.322 12.322)scale(.101)"><path d="M105 673v33q407 354 814 0v-33z"/><path fill="#478cbf" d="m105 673 152 14q12 1 15 14l4 67 132 10 8-61q2-11 15-15h162q13 4 15 15l8 61 132-10 4-67q3-13 15-14l152-14V427q30-39 56-81-35-59-83-108-43 20-82 47-40-37-88-64 7-51 8-102-59-28-123-42-26 43-46 89-49-7-98 0-20-46-46-89-64 14-123 42 1 51 8 102-48 27-88 64-39-27-82-47-48 49-83 108 26 42 56 81zm0 33v39c0 276 813 276 814 0v-39l-134 12-5 69q-2 10-14 13l-162 11q-12 0-16-11l-10-65H446l-10 65q-4 11-16 11l-162-11q-12-3-14-13l-5-69z"/><path d="M483 600c0 34 58 34 58 0v-86c0-34-58-34-58 0z"/><circle cx="725" cy="526" r="90"/><circle cx="299" cy="526" r="90"/></g><g fill="#414042" transform="translate(12.322 12.322)scale(.101)"><circle cx="307" cy="532" r="60"/><circle cx="717" cy="532" r="60"/></g></svg>
```

`tests/icon.svg.import`:

```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://6xqmeymr5t3"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false

```

`tests/project.godot`:

```godot
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="tests"
config/features=PackedStringArray("4.3", "Forward Plus")
config/icon="res://icon.svg"

[editor]

script/native_types=true
script/docker_enabled=false

[editor_plugins]

enabled=PackedStringArray("res://addons/gut/plugin.cfg")

```

`tests/run_unittests.sh`:

```sh
set -e
GODOT_VERSION=4.4.1

# Check if unit tests are run from Github Actions
if [ -n "$CI" ]; then
	GODOT=./Godot_v4.4.1-stable_linux.x86_64
	# Use the --import flag to properly initialize the project
	$GODOT --path "$PWD" --headless --import
else
	# Use a local Godot binary
	if [ -z "$GODOT" ]; then
		GODOT=~/Godot_v4.4.1-stable_linux.x86_64
	fi
fi

export CXX="riscv64-linux-gnu-g++-14"
#export CXX="riscv64-unknown-elf-g++"

# Build the unit test ELF file
mkdir -p .build
pushd .build
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake -DSTRIPPED=OFF -DFLTO=ON
make -j4
popd

# Create a symbolic link to the unit test ELF file
ln -fs ../.build/unittests tests/tests.elf

# Import again for CI
if [ -n "$CI" ]; then
	$GODOT --path "$PWD" --headless --import
fi

# Run the unit tests using the GUT addon
$GODOT --path "$PWD" --headless -s addons/gut/gut_cmdln.gd $@

```

`tests/tests/test_basic.cpp`:

```cpp
#include "api.hpp"

struct MyException : public std::exception {
	using std::exception::exception;
	const char *what() const noexcept override {
		return "This is a test exception";
	}
};

PUBLIC Variant test_exceptions() {
#ifdef ZIG_COMPILER
#warning "Zig does not support exceptions (yet)"
	return "This is a test exception";
#else
	try {
		throw MyException();
	} catch (const std::exception &e) {
		return e.what();
	}
	return "";
#endif
}

// This works: it's being created during initialization
static Dictionary d = Dictionary::Create();

PUBLIC Variant test_static_storage(Variant key, Variant val) {
	d[key] = val;
	return d;
}
PUBLIC Variant test_failing_static_storage(Variant key, Variant val) {
	// This works only once: it's being created after initialization
	static Dictionary fd = Dictionary::Create();
	fd[key] = val;
	return fd;
}
static Dictionary fd = Dictionary::Create();
PUBLIC Variant test_permanent_storage(Variant key, Variant val) {
	fd[key] = val;
	fd = Variant(fd).make_permanent();
	return fd;
}

static String ps = "Hello this is a permanent string";
PUBLIC Variant test_permanent_string(String input) {
	ps = input;
	return ps;
}

static Array pa = Array::Create();
PUBLIC Variant test_permanent_array(Array input) {
	pa = input;
	return pa;
}

static Dictionary pd = Dictionary::Create();
PUBLIC Variant test_permanent_dict(Dictionary input) {
	pd = input;
	return pd;
}

PUBLIC Variant test_check_if_permanent(String test) {
	if (test == "string") {
		printf("Checking if string %d is permanent\n", ps.get_variant_index());
		return ps.is_permanent();
	} else if (test == "array") {
		printf("Checking if array %d is permanent\n", pa.get_variant_index());
		return pa.is_permanent();
	} else if (test == "dict") {
		printf("Checking if dictionary %d is permanent\n", pd.get_variant_index());
		return pd.is_permanent();
	}
	return false;
}

PUBLIC Variant test_infinite_loop() {
	while (true)
		;
}

PUBLIC Variant test_recursive_calls(Node sandbox) {
	sandbox("vmcall", "test_recursive_calls", sandbox);
	return {};
}

PUBLIC Variant public_function() {
	return "Hello from the other side";
}

PUBLIC Variant test_ping_pong(Variant arg) {
	return arg;
}

PUBLIC Variant test_ping_move_pong(Variant arg) {
	Variant v = std::move(arg);
	return v;
}

PUBLIC Variant test_variant_eq(Variant arg1, Variant arg2) {
	return arg1 == arg2;
}

PUBLIC Variant test_variant_neq(Variant arg1, Variant arg2) {
	return (arg1 != arg2) == false;
}

PUBLIC Variant test_variant_lt(Variant arg1, Variant arg2) {
	return arg1 < arg2;
}

PUBLIC Variant test_bool(bool arg) {
	return arg;
}

PUBLIC Variant test_int(long arg) {
	return arg;
}

PUBLIC Variant test_float(double arg) {
	return arg;
}

PUBLIC Variant test_string(String arg) {
	return arg;
}

PUBLIC Variant test_fetch_string(String arg) {
	return std::string(arg.utf8());
}

PUBLIC Variant test_u32string(String arg) {
	std::u32string u32 = arg.utf32();
	return u32;
}

PUBLIC Variant test_nodepath(NodePath arg) {
	return arg;
}

PUBLIC Variant test_vec2(Vector2 arg) {
	Vector2 result = arg;
	return result;
}
PUBLIC Variant test_vec2i(Vector2i arg) {
	Vector2i result = arg;
	return result;
}

PUBLIC Variant test_vec3(Vector3 arg) {
	Vector3 result = arg;
	return result;
}
PUBLIC Variant test_vec3i(Vector3i arg) {
	Vector3i result = arg;
	return result;
}

PUBLIC Variant test_vec4(Vector4 arg) {
	Vector4 result = arg;
	return result;
}
PUBLIC Variant test_vec4i(Vector4i arg) {
	Vector4i result = arg;
	return result;
}

PUBLIC Variant test_color(Color arg) {
	Color result = arg;
	return result;
}

PUBLIC Variant test_plane(Plane arg) {
	Plane result = arg;
	return result;
}

PUBLIC Variant test_array(Array array) {
	array.push_back(2);
	array.push_back("4");
	array.push_back(6.0);
	if (array[0] != 2 || array[1] != "4" || array[2] != 6.0) {
		return "Fail";
	}
	if (!(array[0] == 2 && array[1] == "4" && array[2] == 6.0)) {
		return "Fail";
	}
	array[0] = 1;
	array[1] = "2";
	array[2] = 3.0;
	if (int(array[0]) != 1 || String(array[1]) != "2" || double(array[2]) != 3.0) {
		return "Fail";
	}
	if (int(array[0]) == 1 && String(array[1]) == "2" || double(array[2]) == 3.0) {
		return array;
	}
	return "Fail";
}

PUBLIC Variant test_array_assign(Array arr) {
	arr[0] = 42;
	arr[1] = "Hello";
	arr[2] = PackedArray<double> ({ 3.14, 2.71 });
	if (arr[0] != 42 || arr[1] != "Hello" || arr[2].get().get_type() != Variant::Type::PACKED_FLOAT64_ARRAY) {
		return "Fail";
	}

	Array arr2 = Array::Create();
	arr2.push_back(PackedArray<double> ({ 1.0, 2.0, 3.0 }));
	arr.push_back(arr2);
	arr[3] = arr2;

	PackedArray<double> pa = arr[2];
	if (pa.size() != 2 || pa.is_empty()) {
		return "Fail";
	}
	std::vector<double> vec = pa.fetch();
	if (vec[0] != 3.14 || vec[1] != 2.71 || vec.size() != 2) {
		return "Fail";
	}

	return arr;
}

PUBLIC Variant test_array_assign2(Array arr, const size_t idx) {

	std::vector<size_t> indices = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };

	arr.resize(indices.size());
	for (size_t i = 0; i < indices.size(); i++) {
		arr[i] = indices[i];
	}

	return arr;
}

PUBLIC Variant test_dict(Dictionary arg) {
	return arg;
}

PUBLIC Variant test_sub_dictionary(Dictionary dict) {
	return Dictionary(dict["1"].value());
}

PUBLIC Variant test_rid(RID rid) {
	return rid;
}

PUBLIC Variant test_object(Object arg) {
	Object result = arg;
	return result;
}

PUBLIC Variant test_basis(Basis basis) {
	Basis b = basis;
	return b;
}

PUBLIC Variant test_transform2d(Transform2D transform2d) {
	Transform2D t2d = transform2d;
	return t2d;
}

PUBLIC Variant test_transform3d(Transform3D transform3d) {
	Transform3D t3d = transform3d;
	return t3d;
}

PUBLIC Variant test_quaternion(Quaternion quaternion) {
	Quaternion q2 = quaternion;
	return q2;
}

PUBLIC Variant test_callable(Callable callable) {
	return callable.call(1, 2, "3");
}

// clang-format off
PUBLIC Variant test_create_callable() {
	Array array = Array::Create();
	array.push_back(1);
	array.push_back(2);
	array.push_back("3");
	return Callable::Create<Variant(Array, int, int, String)>([](Array array, int a, int b, String c) -> Variant {
		return a + b + std::stoi(c.utf8()) + int(array.at(0)) + int(array.at(1)) + std::stoi(array.at(2).as_string().utf8());
	}, array);
}
// clang-format on

PUBLIC Variant test_pa_u8(PackedByteArray arr) {
	return PackedByteArray (arr.fetch());
}
PUBLIC Variant test_pa_f32(PackedArray<float> arr) {
	return PackedArray<float> (arr.fetch());
}
PUBLIC Variant test_pa_f64(PackedArray<double> arr) {
	return PackedArray<double> (arr.fetch());
}
PUBLIC Variant test_pa_i32(PackedArray<int32_t> arr) {
	return PackedArray<int32_t> (arr.fetch());
}
PUBLIC Variant test_pa_i64(PackedArray<int64_t> arr) {
	return PackedArray<int64_t> (arr.fetch());
}
PUBLIC Variant test_pa_vec2(PackedArray<Vector2> arr) {
	return PackedArray<Vector2> (arr.fetch());
}
PUBLIC Variant test_pa_vec3(PackedArray<Vector3> arr) {
	return PackedArray<Vector3> (arr.fetch());
}
PUBLIC Variant test_pa_vec4(PackedArray<Vector4> arr) {
	return PackedArray<Vector4> (arr.fetch());
}
PUBLIC Variant test_pa_color(PackedArray<Color> arr) {
	return PackedArray<Color> (arr.fetch());
}
PUBLIC Variant test_pa_string(PackedArray<std::string> arr) {
	return PackedArray<std::string> (arr.fetch());
}

PUBLIC Variant test_create_pa_u8() {
	PackedByteArray arr({ 1, 2, 3, 4 });
	return arr;
}
static const uint8_t pa_u8_data[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
PUBLIC Variant test_create_pa_u8_ptr() {
	return PackedByteArray(pa_u8_data, sizeof(pa_u8_data) / sizeof(uint8_t));
}
PUBLIC Variant test_create_pa_f32() {
	PackedArray<float> arr({ 1, 2, 3, 4 });
	return arr;
}
PUBLIC Variant test_create_pa_f64() {
	PackedArray<double> arr({ 1, 2, 3, 4 });
	return arr;
}
PUBLIC Variant test_create_pa_i32() {
	PackedArray<int32_t> arr({ 1, 2, 3, 4 });
	return arr;
}
PUBLIC Variant test_create_pa_i64() {
	PackedArray<int64_t> arr({ 1, 2, 3, 4 });
	return arr;
}
PUBLIC Variant test_create_pa_vec2() {
	PackedArray<Vector2> arr({ { 1, 1 }, { 2, 2 }, { 3, 3 } });
	return arr;
}
PUBLIC Variant test_create_pa_vec3() {
	PackedArray<Vector3> arr({ { 1, 1, 1 }, { 2, 2, 2 }, { 3, 3, 3 } });
	return arr;
}
PUBLIC Variant test_create_pa_vec4() {
	PackedArray<Vector4> arr({ { 1, 1, 1, 1 }, { 2, 2, 2, 2 }, { 3, 3, 3, 3 } });
	return arr;
}
PUBLIC Variant test_create_pa_color() {
	PackedArray<Color> arr({ { 0, 0, 0, 0 }, { 1, 1, 1, 1 } });
	return arr;
}
PUBLIC Variant test_create_pa_string() {
	PackedArray<std::string> arr({ "Hello", "from", "the", "other", "side" });
	return arr;
}

PUBLIC Variant test_assign_pa_to_array(PackedArray<int64_t> pa) {
	Array arr = Array::Create();
	arr.push_back(pa);
	arr.push_back(pa);
	return arr;
}

PUBLIC Variant test_assign_pa_to_dict(PackedArray<int64_t> arr) {
	Dictionary d = Dictionary::Create();
	d["a1"] = arr;
	d["a2"] = arr;
	return d;
}

PUBLIC Variant test_construct_pa_from_array_at(Array arr, int idx) {
	PackedArray<int64_t> pa(arr.at(idx));
	return pa;
}

PUBLIC Variant test_exception() {
	asm volatile("unimp");
	return "This should not be reached";
}

static bool timer_got_called = false;
PUBLIC Variant test_timers() {
	long val1 = 11;
	float val2 = 22.0f;
	return CallbackTimer::periodic(0.01, [=](Node timer) -> Variant {
		print("Timer with values: ", val1, val2);
		timer.queue_free();
		timer_got_called = true;
		return {};
	});
}
PUBLIC Variant verify_timers() {
	return timer_got_called;
}

PUBLIC Variant call_method(Variant v, Variant vmethod, Variant vargs) {
	std::string method = vmethod.as_std_string();
	Array args_array = vargs.as_array();
	std::vector<Variant> args = args_array.to_vector();
	Variant ret;
	v.callp(method, args.data(), args.size(), ret);
	return ret;
}

PUBLIC Variant voidcall_method(Variant v, Variant vmethod, Variant vargs) {
	std::string method = vmethod.as_std_string();
	Array args_array = vargs.as_array();
	std::vector<Variant> args = args_array.to_vector();
	v.voidcallp(method, args.data(), args.size());
	return Nil;
}

PUBLIC Variant access_a_parent(Node n) {
	Node p = n.get_parent();
	return p;
}

PUBLIC Variant creates_a_node() {
	return Node::Create("test");
}

PUBLIC Variant free_self() {
	get_node()("free");
	return Nil;
}

PUBLIC Variant access_an_invalid_child_node() {
	Node n = Node::Create("test");
	Node c = Node::Create("child");
	n.add_child(c);
	c("free");
	c.set_name("child2");
	return c;
}

PUBLIC Variant access_an_invalid_child_resource(String path) {
	Variant resource = loadv(path.utf8());
	return resource.method_call("instantiate");
}

PUBLIC Variant disable_restrictions() {
	get_node().call("disable_restrictions");
	return Nil;
}

PUBLIC Variant test_property_proxy() {
	Node node = Node::Create("Fail 1");
	node.name() = "Fail 1.5";
	node.set_name("Fail 2");
	if (node.get_name() == "Fail 2") {
		node.set("name", "Fail 3");
		if (node.get("name") == "Fail 3") {
			node.name() = "TestOK";
			if (node.name() != "TestOK") {
				return "Fail 4";
			}
		}
	}
	return node.get_name();
}

// This tests the higher limit for boxed arguments with up to 16 arguments
// We will pass in 10 integers and 6 strings, which we add up and return
PUBLIC Variant test_many_arguments(Variant a1, Variant a2, Variant a3, Variant a4, Variant a5, Variant a6, Variant a7, Variant a8, Variant a9, Variant a10, Variant a11, Variant a12, Variant a13, Variant a14, Variant a15, Variant a16) {
	return int(a1) + int(a2) + int(a3) + int(a4) + int(a5) + int(a6) + int(a7) + int(a8) + int(a9) + int(a10) + a11.as_string().to_int() + a12.as_string().to_int() + a13.as_string().to_int() + a14.as_string().to_int() + a15.as_string().to_int() + a16.as_string().to_int();
}

PUBLIC Variant test_many_arguments2(Variant a1, Variant a2, Variant a3, Variant a4, Variant a5, Variant a6, Variant a7, Variant a8) {
	return int(a1) + int(a2) + int(a3) + int(a4) + int(a5) + int(a6) + int(a7) + a8.as_string().to_int();
}

PUBLIC Variant test_many_unboxed_arguments(int a1, int a2, int a3, int a4, int a5, int a6, int a7, double f1, double f2, double f3, double f4) {
	return int(a1) + int(a2) + int(a3) + int(a4) + int(a5) + int(a6) + int(a7) + int(f1) + int(f2) + int(f3) + int(f4);
}

PUBLIC Variant test_many_unboxed_arguments2(int a1, int a2, int a3, int a4, int a5, int a6, int a7, Vector2 v1, Vector2 v2, Vector2 v3, Vector2 v4) {
	return int(a1) + int(a2) + int(a3) + int(a4) + int(a5) + int(a6) + int(a7) + int(v1.x) + int(v1.y) + int(v2.x) + int(v2.y) + int(v3.x) + int(v3.y) + int(v4.x) + int(v4.y);
}

PUBLIC Variant get_tree_base_parent() {
	return get_parent();
}

```

`tests/tests/test_basic.gd`:

```gd
extends GutTest

var callable_was_called = false
var Sandbox_TestsTests = load("res://tests/tests.elf")
var holder = Sandbox.new()

func test_instantiation():
	holder.set_program(Sandbox_TestsTests)
	# Create a new sandbox
	var s = Sandbox.new()
	var m = s.get_method_list()
	var ma : Array
	for i in m:
		ma.append(i.name)
	print(ma)
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	# Verify some basic stats
	assert_eq(s.get_calls_made(), 0)
	assert_eq(s.get_exceptions(), 0)
	assert_eq(s.get_timeouts(), 0)

	# Verify execution timeout
	s.set_instructions_max(10)
	s.vmcall("test_infinite_loop")

	# Verify that the execution timeout counter is increased
	assert_eq(s.get_timeouts(), 1)
	assert_eq(s.get_exceptions(), 1)

	# Verify that the sandbox can be reset
	s.free()
	s = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	# Verify that the counters are reset
	assert_eq(s.get_timeouts(), 0)
	assert_eq(s.get_exceptions(), 0)

	# Verify that too many VM call recursion levels are prevented
	s.vmcall("test_recursive_calls", s)

	assert_eq(s.get_timeouts(), 0)
	assert_eq(s.get_exceptions(), 1)
	assert_eq(s.get_global_exceptions(), 2)

	# Verify that the sandbox program can be set to another program
	s.set_program(Sandbox_TestsTests)
	assert_eq(s.has_function("test_ping_pong"), true, "Program has test_ping_pong function")

	s.queue_free()

	# Create a new sandbox from a buffer
	var buffer : PackedByteArray = Sandbox_TestsTests.get_content()
	for i in 10:
		var s2 = Sandbox.FromBuffer(buffer)
		assert_true(s2.has_program_loaded(), "Program loaded from buffer")
		s2.free()
	for i in 10:
		var s2 = Sandbox.FromProgram(Sandbox_TestsTests)
		assert_true(s2.has_program_loaded(), "Program loaded from program")
		s2.free()

	# Test resetting the sandbox
	var s3 = Sandbox.FromProgram(Sandbox_TestsTests)
	for i in 10:
		s3.reset()
		assert_true(s3.has_program_loaded(), "Program still loaded after reset")
		assert_true(s3.has_function("test_ping_pong"), "Function still exists after reset")
		assert_eq(s.vmcall("test_int", 1234), 1234) # test that the sandbox is still working
	# Test unloading many times (only the first unload should do anything)
	for i in 10:
		s3.reset(true)
		assert_false(s3.has_program_loaded(), "Program still unloaded after reset")
		assert_false(s3.has_function("test_ping_pong"), "Function does not exist after reset")
	s3.free()

func test_script_instantiation():
	var n = Node.new()
	n.set_script(Sandbox_TestsTests)

	var e = n.get_script()
	var s = e.get_sandbox_for(n)
	assert_true(s.has_program_loaded(), "Program loaded for script")
	assert_true(s.has_function("test_ping_pong"), "Sandbox has test_ping_pong function")

	# Get all objects for the ELFScript
	var objects : Array = e.get_sandbox_objects()
	assert_eq(objects.size(), 1, "One object associated with the ELFScript")
	assert_eq_deep(objects, [n])

	# Verify that the sandbox can be used from the top-level object
	# In this mode we can call functions directly on the object
	assert_eq(n.test_int(1234), 1234, "Can call test_int function directly")
	assert_eq(n.test_string("1234"), "1234", "Can call test_string function directly")

	n.free()

func test_environment():
	var s = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	# Verify that fast_exit is visible
	# It accelerates the speed of VM calls in general, stopping the VM faster
	assert_eq(s.has_function("fast_exit"), true)

	# Verify that C++ exceptions are caught
	assert_eq(s.has_function("test_exceptions"), true)
	for i in 1:
		assert_eq(s.vmcall("test_exceptions"), "This is a test exception")

	s.queue_free()


func test_binary_translation():
	# Create a new sandbox
	var s = Sandbox.new()

	var str : String = s.emit_binary_translation()
	assert_true(str.is_empty(), "Binary translation is empty")

	# Set the test program
	s.set_program(Sandbox_TestsTests)

	str = s.emit_binary_translation()
	assert_false(str.is_empty(), "Binary translation is not empty")
	#print(str)

	s.queue_free()


func test_types():
	# Create a new sandbox
	var s = Sandbox.new()
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	# Verify public functions
	assert_eq(s.has_function("test_ping_pong"), true)
	assert_eq(s.has_function("test_bool"), true)
	assert_eq(s.has_function("test_int"), true)
	assert_eq(s.has_function("test_float"), true)
	assert_eq(s.has_function("test_string"), true)
	assert_eq(s.has_function("test_object"), true)
	assert_eq(s.has_function("test_nodepath"), true)
	assert_eq(s.has_function("test_vec2"), true)
	assert_eq(s.has_function("test_vec2i"), true)
	assert_eq(s.has_function("test_vec3"), true)
	assert_eq(s.has_function("test_vec3i"), true)
	assert_eq(s.has_function("test_vec4"), true)
	assert_eq(s.has_function("test_vec4i"), true)
	assert_eq(s.has_function("test_color"), true)
	assert_eq(s.has_function("test_basis"), true)
	assert_eq(s.has_function("test_transform2d"), true)
	assert_eq(s.has_function("test_transform3d"), true)
	assert_eq(s.has_function("test_quaternion"), true)
	assert_eq(s.has_function("test_array"), true)
	assert_eq(s.has_function("test_dict"), true)

	# Verify all basic types can be ping-ponged
	var nil : Variant
	assert_eq(s.vmcall("test_ping_pong", nil), nil) # Nil
	assert_eq(s.vmcall("test_bool", true), true) # Bool
	assert_eq(s.vmcall("test_bool", false), false) # Bool
	assert_eq(s.vmcall("test_int", 1234), 1234) # Int
	assert_eq(s.vmcall("test_int", -1234), -1234) # Int
	assert_eq(s.vmcall("test_float", 9876.0), 9876.0) # Float
	assert_same(s.vmcall("test_string", "9876.0"), "9876.0") # SSO String
	assert_same(s.vmcall("test_string", "123456789.123456"), "123456789.123456") # Heap String
	assert_same(s.vmcall("test_fetch_string", "9876.0"), "9876.0") # SSO String
	assert_same(s.vmcall("test_fetch_string", "123456789.123456"), "123456789.123456") # Heap String
	assert_same(s.vmcall("test_u32string", "19876.1"), "19876.1") # std::u32string
	assert_same(s.vmcall("test_nodepath", NodePath("Node")), NodePath("Node")) # NodePath
	assert_eq(s.vmcall("test_vec2", Vector2(1, 2)), Vector2(1, 2)) # Vector2
	assert_eq(s.vmcall("test_vec2i", Vector2i(1, 2)), Vector2i(1, 2)) # Vector2i
	assert_eq(s.vmcall("test_vec3", Vector3(1, 2, 3)), Vector3(1, 2, 3)) # Vector3
	assert_eq(s.vmcall("test_vec3i", Vector3i(1, 2, 3)), Vector3i(1, 2, 3)) # Vector3i
	assert_eq(s.vmcall("test_vec4", Vector4(1, 2, 3, 4)), Vector4(1, 2, 3, 4)) # Vector4
	assert_eq(s.vmcall("test_vec4i", Vector4i(1, 2, 3, 4)), Vector4i(1, 2, 3, 4)) # Vector4i
	assert_eq(s.vmcall("test_color", Color(1, 2, 3, 4)), Color(1, 2, 3, 4)) # Color
	assert_eq(s.vmcall("test_ping_pong", Rect2(Vector2(1, 2), Vector2(3, 4))), Rect2(Vector2(1, 2), Vector2(3, 4))) # Rect2
	assert_eq(s.vmcall("test_ping_pong", Rect2i(Vector2i(1, 2), Vector2i(3, 4))), Rect2i(Vector2i(1, 2), Vector2i(3, 4))) # Rect2i
	assert_eq(s.vmcall("test_transform2d", Transform2D(Vector2(1, 2), Vector2(3, 4), Vector2(5, 6))), Transform2D(Vector2(1, 2), Vector2(3, 4), Vector2(5, 6))) # Transform2D
	assert_eq(s.vmcall("test_transform3d", Transform3D(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9), Vector3(10, 11, 12))), Transform3D(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9), Vector3(10, 11, 12))) # Transform3D
	assert_eq(s.vmcall("test_ping_pong", AABB(Vector3(1, 2, 3), Vector3(4, 5, 6))), AABB(Vector3(1, 2, 3), Vector3(4, 5, 6))) # AABB
	assert_eq(s.vmcall("test_plane", Plane(Vector3(1, 2, 3), 4)), Plane(Vector3(1, 2, 3), 4)) # Plane
	assert_eq(s.vmcall("test_quaternion", Quaternion(1, 2, 3, 4)), Quaternion(1, 2, 3, 4)) # Quaternion
	assert_eq(s.vmcall("test_basis", Basis(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9))), Basis(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9))) # Basis
	# RID - gets converted to an integer
	var rid : RID = Sandbox_TestsTests.get_rid()
	assert_same(s.vmcall("test_rid", rid), rid) # RID

	# Nodes
	var n : Node = Node.new()
	n.name = "Node"
	assert_eq(s.vmcall("test_object", n), n)
	n.queue_free()

	var n2d : Node2D = Node2D.new()
	n2d.name = "Node2D"
	assert_eq(s.vmcall("test_object", n2d), n2d)
	n2d.queue_free()

	var n3d : Node3D = Node3D.new()
	n3d.name = "Node3D"
	assert_eq(s.vmcall("test_object", n3d), n3d)
	n3d.queue_free()

	# Array, Dictionary and String as references
	var a_pp : Array
	assert_same(s.vmcall("test_array", a_pp), a_pp)
	assert_eq_deep(a_pp, [1, "2", 3.0])
	var assigned_array : Array = [42, "Hello", PackedFloat64Array([3.14, 2.71]), Array([PackedFloat64Array([1.0, 2.0, 3.0])])]
	assert_eq_deep(s.vmcall("test_array_assign", a_pp), assigned_array)
	a_pp.clear()
	assigned_array = [0, 1, 2, 3, 4, 5, 6, 7, 8]
	assert_eq_deep(s.vmcall("test_array_assign2", a_pp), assigned_array)
	var d_pp : Dictionary
	assert_same(s.vmcall("test_dict", d_pp), d_pp)
	var s_pp : String = "12345"
	assert_same(s.vmcall("test_string", s_pp), s_pp)
	assert_same(s.vmcall("test_u32string", s_pp), s_pp)
	assert_eq(s_pp, "12345")
	# Packed arrays
	var pba_pp : PackedByteArray = [1, 2, 3, 4]
	assert_eq_deep(s.vmcall("test_pa_u8", pba_pp), pba_pp)
	var pfa32_pp : PackedFloat32Array = [1.0, 2.0, 3.0, 4.0]
	assert_eq_deep(s.vmcall("test_pa_f32", pfa32_pp), pfa32_pp)
	var pfa64_pp : PackedFloat64Array = [1.0, 2.0, 3.0, 4.0]
	assert_eq_deep(s.vmcall("test_pa_f64", pfa64_pp), pfa64_pp)
	var pia32_pp : PackedInt32Array = [1, 2, 3, 4]
	assert_eq_deep(s.vmcall("test_pa_i32", pia32_pp), pia32_pp)
	var pia64_pp : PackedInt64Array = [1, 2, 3, 4]
	assert_eq_deep(s.vmcall("test_pa_i64", pia64_pp), pia64_pp)
	var pa_vec2_pp : PackedVector2Array = [Vector2(1, 1), Vector2(2, 2), Vector2(3, 3)]
	assert_eq_deep(s.vmcall("test_pa_vec2", pa_vec2_pp), pa_vec2_pp)
	var pa_vec3_pp : PackedVector3Array = [Vector3(1, 1, 1), Vector3(2, 2, 2), Vector3(3, 3, 3)]
	assert_eq_deep(s.vmcall("test_pa_vec3", pa_vec3_pp), pa_vec3_pp)
	var pa_vec4_pp : PackedVector4Array = [Vector4(1, 1, 1, 1), Vector4(2, 2, 2, 2), Vector4(3, 3, 3, 3)]
	assert_eq_deep(s.vmcall("test_pa_vec4", pa_vec4_pp), pa_vec4_pp)
	var pa_color_pp : PackedColorArray = [Color(0, 0, 0, 0), Color(1, 1, 1, 1)]
	assert_eq_deep(s.vmcall("test_pa_color", pa_color_pp), pa_color_pp)
	var pa_string_pp : PackedStringArray = ["Hello", "from", "the", "other", "side"]
	assert_eq_deep(s.vmcall("test_pa_string", pa_string_pp), pa_string_pp)
	# Packed arrays created in the guest
	assert_eq(s.vmcall("test_create_pa_u8"), PackedByteArray([1, 2, 3, 4]))
	assert_eq_deep(s.vmcall("test_create_pa_u8_ptr"), PackedByteArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
	assert_eq(s.vmcall("test_create_pa_f32"), PackedFloat32Array([1, 2, 3, 4]))
	assert_eq(s.vmcall("test_create_pa_f64"), PackedFloat64Array([1, 2, 3, 4]))
	assert_eq(s.vmcall("test_create_pa_i32"), PackedInt32Array([1, 2, 3, 4]))
	assert_eq(s.vmcall("test_create_pa_i64"), PackedInt64Array([1, 2, 3, 4]))
	assert_eq(s.vmcall("test_create_pa_vec2"), PackedVector2Array([Vector2(1, 1), Vector2(2, 2), Vector2(3, 3)]))
	assert_eq(s.vmcall("test_create_pa_vec3"), PackedVector3Array([Vector3(1, 1, 1), Vector3(2, 2, 2), Vector3(3, 3, 3)]))
	assert_eq(s.vmcall("test_create_pa_vec4"), PackedVector4Array([Vector4(1, 1, 1, 1), Vector4(2, 2, 2, 2), Vector4(3, 3, 3, 3)]))
	assert_eq(s.vmcall("test_create_pa_color"), PackedColorArray([Color(0, 0, 0, 0), Color(1, 1, 1, 1)]))
	assert_eq(s.vmcall("test_create_pa_string"), PackedStringArray(["Hello", "from", "the", "other", "side"]))

	# Assign packed array to Array
	assert_eq_deep(s.vmcall("test_assign_pa_to_array", PackedInt64Array([1, 2, 3, 4])),
		[PackedInt64Array([1, 2, 3, 4]), PackedInt64Array([1, 2, 3, 4])])

	# Assign packed array to Dictionary
	assert_eq_deep(s.vmcall("test_assign_pa_to_dict", PackedInt64Array([1, 2, 3, 4])),
		{"a1": PackedInt64Array([1, 2, 3, 4]), "a2": PackedInt64Array([1, 2, 3, 4])})

	# Construct packed array from Array index containing packed array
	assert_eq_deep(s.vmcall("test_construct_pa_from_array_at", Array([PackedInt64Array([1, 2, 3, 4])]), 0),
		PackedInt64Array([1, 2, 3, 4]))

	# Callables
	var cb : Callable = Callable(callable_function)
	s.vmcall("test_callable", Callable(callable_callee))
	assert_eq(callable_was_called, true, "Callable was called")
	cb = s.vmcall("test_create_callable")
	# 1 + 2 + stoi("3") + 1 + 2 + stoi("3") = 12
	assert_eq(cb.call(1, 2, "3"), 12, "Callable() invocation evaluates correctly")

	# Verify that a basic function that returns a String works
	assert_eq(s.has_function("public_function"), true)
	assert_eq(s.vmcall("public_function"), "Hello from the other side")

	# Verify that the sandbox can receive a Dictionary and return an element
	var d : Dictionary
	d["1"] = Dictionary()
	d["1"]["2"] = "3"

	assert_eq(s.has_function("test_sub_dictionary"), true)
	assert_eq(s.vmcall("test_sub_dictionary", d), d["1"])

	s.queue_free()

func execute_vmcallv_with(s : Sandbox, vmfunc : String):
	# Verify that the vmcallv function works
	# vmcallv always uses Variants for both arguments and the return value
	assert_same(s.vmcallv(vmfunc, null), null)
	assert_same(s.vmcallv(vmfunc, true), true)
	assert_same(s.vmcallv(vmfunc, false), false)
	assert_same(s.vmcallv(vmfunc, 1234), 1234)
	assert_same(s.vmcallv(vmfunc, -1234), -1234)
	assert_same(s.vmcallv(vmfunc, 9876.0), 9876.0)
	assert_same(s.vmcallv(vmfunc, "9876.0"), "9876.0")
	assert_eq(s.vmcallv(vmfunc, NodePath("Node")), NodePath("Node"))
	assert_same(s.vmcallv(vmfunc, Vector2(1, 2)), Vector2(1, 2))
	assert_same(s.vmcallv(vmfunc, Vector2i(1, 2)), Vector2i(1, 2))
	assert_same(s.vmcallv(vmfunc, Vector3(1, 2, 3)), Vector3(1, 2, 3))
	assert_same(s.vmcallv(vmfunc, Vector3i(1, 2, 3)), Vector3i(1, 2, 3))
	assert_same(s.vmcallv(vmfunc, Vector4(1, 2, 3, 4)), Vector4(1, 2, 3, 4))
	assert_same(s.vmcallv(vmfunc, Vector4i(1, 2, 3, 4)), Vector4i(1, 2, 3, 4))
	assert_same(s.vmcallv(vmfunc, Color(1, 2, 3, 4)), Color(1, 2, 3, 4))
	assert_same(s.vmcallv(vmfunc, Rect2(Vector2(1, 2), Vector2(3, 4))), Rect2(Vector2(1, 2), Vector2(3, 4))) # Rect2
	assert_same(s.vmcallv(vmfunc, Rect2i(Vector2i(1, 2), Vector2i(3, 4))), Rect2i(Vector2i(1, 2), Vector2i(3, 4))) # Rect2i
	assert_same(s.vmcallv(vmfunc, Transform2D(Vector2(1, 2), Vector2(3, 4), Vector2(5, 6))), Transform2D(Vector2(1, 2), Vector2(3, 4), Vector2(5, 6))) # Transform2D
	assert_same(s.vmcallv(vmfunc, AABB(Vector3(1, 2, 3), Vector3(4, 5, 6))), AABB(Vector3(1, 2, 3), Vector3(4, 5, 6))) # AABB
	assert_same(s.vmcallv(vmfunc, Plane(Vector3(1, 2, 3), 4)), Plane(Vector3(1, 2, 3), 4)) # Plane
	assert_same(s.vmcallv(vmfunc, Quaternion(1, 2, 3, 4)), Quaternion(1, 2, 3, 4)) # Quat
	assert_same(s.vmcallv(vmfunc, Basis(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9))), Basis(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9))) # Basis
	assert_same(s.vmcallv(vmfunc, RID()), RID()) # RID
	var cb : Callable = Callable(callable_function)
	assert_same(s.vmcallv(vmfunc, cb), cb, "Returned Callable was same")

	# Nodes
	var n : Node = Node.new()
	n.name = "Node"
	assert_same(s.vmcallv(vmfunc, n), n)
	n.queue_free()

	var n2d : Node2D = Node2D.new()
	n2d.name = "Node2D"
	assert_same(s.vmcallv(vmfunc, n2d), n2d)
	n2d.queue_free()

	var n3d : Node3D = Node3D.new()
	n3d.name = "Node3D"
	assert_same(s.vmcallv(vmfunc, n3d), n3d)
	n3d.queue_free()

	# Packed arrays
	var pba_pp : PackedByteArray = [1, 2, 3, 4]
	assert_same(s.vmcallv(vmfunc, pba_pp), pba_pp)
	var pfa32_pp : PackedFloat32Array = [1.0, 2.0, 3.0, 4.0]
	assert_same(s.vmcallv(vmfunc, pfa32_pp), pfa32_pp)
	var pfa64_pp : PackedFloat64Array = [1.0, 2.0, 3.0, 4.0]
	assert_same(s.vmcallv(vmfunc, pfa64_pp), pfa64_pp)
	var pia32_pp : PackedInt32Array = [1, 2, 3, 4]
	assert_same(s.vmcallv(vmfunc, pia32_pp), pia32_pp)
	var pia64_pp : PackedInt64Array = [1, 2, 3, 4]
	assert_same(s.vmcallv(vmfunc, pia64_pp), pia64_pp)
	var pa_vec2_pp : PackedVector2Array = [Vector2(0, 0), Vector2(1, 1), Vector2(2, 2)]
	assert_same(s.vmcallv(vmfunc, pa_vec2_pp), pa_vec2_pp)
	var pa_vec3_pp : PackedVector3Array = [Vector3(0, 0, 0), Vector3(1, 1, 1), Vector3(2, 2, 2)]
	assert_same(s.vmcallv(vmfunc, pa_vec3_pp), pa_vec3_pp)
	var pa_vec4_pp : PackedVector4Array = [Vector4(0, 0, 0, 0), Vector4(1, 1, 1, 1), Vector4(2, 2, 2, 2)]
	assert_same(s.vmcallv(vmfunc, pa_vec4_pp), pa_vec4_pp)
	var pca_pp : PackedColorArray = [Color(0, 0, 0, 0), Color(1, 1, 1, 1)]
	assert_same(s.vmcallv(vmfunc, pca_pp), pca_pp)
	var pa_string_pp : PackedStringArray = ["Hello", "from", "the", "other", "side"]
	assert_same(s.vmcallv(vmfunc, pa_string_pp), pa_string_pp)

func test_vmcallv():
	# Create a new sandbox
	var s = Sandbox.new()
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	assert_eq(s.has_function("test_ping_pong"), true)
	execute_vmcallv_with(s, "test_ping_pong")

	assert_eq(s.has_function("test_ping_move_pong"), true)
	execute_vmcallv_with(s, "test_ping_move_pong")

	assert_eq(s.has_function("test_many_arguments"), true)
	assert_same(s.vmcallv("test_many_arguments", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "11", "12", "13", "14", "15", "16"), 136)

	assert_eq(s.has_function("test_many_arguments2"), true)
	assert_same(s.vmcallv("test_many_arguments2", 1, 2, 3, 4, 5, 6, 7, "8"), 36)

	assert_eq(s.has_function("test_many_unboxed_arguments"), true)
	assert_same(s.vmcall("test_many_unboxed_arguments", 1, 2, 3, 4, 5, 6, 7, 8.0, 9.0, 10.0, 11.0), 66)

	assert_eq(s.has_function("test_many_unboxed_arguments2"), true)
	assert_same(s.vmcall("test_many_unboxed_arguments2", 1, 2, 3, 4, 5, 6, 7, Vector2(8.0, 9.0), Vector2(10.0, 11.0), Vector2(12.0, 13.0), Vector2(14.0, 15.0)), 120)

	s.queue_free()

func execute_vmcallv_comparison(s : Sandbox, vmfunc : String):
	# Verify that the vmcallv function works
	# vmcallv always uses Variants for both arguments and the return value
	assert_true(s.vmcallv(vmfunc, null, null), "null == null")
	assert_true(s.vmcallv(vmfunc, true, true), "true == true")
	assert_true(s.vmcallv(vmfunc, false, false), "false == false")
	assert_true(s.vmcallv(vmfunc, 1234, 1234), "1234 == 1234")
	assert_true(s.vmcallv(vmfunc, -1234, -1234), "-1234 == -1234")
	assert_true(s.vmcallv(vmfunc, 9876.0, 9876.0), "9876.0 == 9876.0")
	assert_true(s.vmcallv(vmfunc, "9876.0", "9876.0"), "9876.0 == 9876.0")
	assert_true(s.vmcallv(vmfunc, NodePath("Node"), NodePath("Node")), "NodePath == NodePath")
	assert_true(s.vmcallv(vmfunc, Vector2(1, 2), Vector2(1, 2)), "Vector2 == Vector2")
	assert_true(s.vmcallv(vmfunc, Vector2i(1, 2), Vector2i(1, 2)), "Vector2i == Vector2i")
	assert_true(s.vmcallv(vmfunc, Vector3(1, 2, 3), Vector3(1, 2, 3)), "Vector3 == Vector3")
	assert_true(s.vmcallv(vmfunc, Vector3i(1, 2, 3), Vector3i(1, 2, 3)), "Vector3i == Vector3i")
	assert_true(s.vmcallv(vmfunc, Vector4(1, 2, 3, 4), Vector4(1, 2, 3, 4)), "Vector4 == Vector4")
	assert_true(s.vmcallv(vmfunc, Vector4i(1, 2, 3, 4), Vector4i(1, 2, 3, 4)), "Vector4i == Vector4i")
	assert_true(s.vmcallv(vmfunc, Color(1, 2, 3, 4), Color(1, 2, 3, 4)), "Color == Color")
	assert_true(s.vmcallv(vmfunc, Rect2(Vector2(1, 2), Vector2(3, 4)), Rect2(Vector2(1, 2), Vector2(3, 4))), "Rect2 == Rect2")
	assert_true(s.vmcallv(vmfunc, Rect2i(Vector2i(1, 2), Vector2i(3, 4)), Rect2i(Vector2i(1, 2), Vector2i(3, 4))), "Rect2i == Rect2i")
	assert_true(s.vmcallv(vmfunc, Transform2D(Vector2(1, 2), Vector2(3, 4), Vector2(5, 6)), Transform2D(Vector2(1, 2), Vector2(3, 4), Vector2(5, 6))), "Transform2D == Transform2D")
	assert_true(s.vmcallv(vmfunc, AABB(Vector3(1, 2, 3), Vector3(4, 5, 6)), AABB(Vector3(1, 2, 3), Vector3(4, 5, 6))), "AABB == AABB")
	assert_true(s.vmcallv(vmfunc, Plane(Vector3(1, 2, 3), 4), Plane(Vector3(1, 2, 3), 4)), "Plane == Plane")
	assert_true(s.vmcallv(vmfunc, Quaternion(1, 2, 3, 4), Quaternion(1, 2, 3, 4)), "Quat == Quat")
	assert_true(s.vmcallv(vmfunc, Basis(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9)), Basis(Vector3(1, 2, 3), Vector3(4, 5, 6), Vector3(7, 8, 9))), "Basis == Basis")
	assert_true(s.vmcallv(vmfunc, RID(), RID()), "RID == RID")
	var cb : Callable = Callable(callable_function)
	assert_true(s.vmcallv(vmfunc, cb, cb), "Callable == Callable")

	# Nodes
	var n : Node = Node.new()
	n.name = "Node"
	assert_true(s.vmcallv(vmfunc, n, n), "Node == Node")
	n.queue_free()

	var n2d : Node2D = Node2D.new()
	n2d.name = "Node2D"
	assert_true(s.vmcallv(vmfunc, n2d, n2d), "Node2D == Node2D")
	n2d.queue_free()

	var n3d : Node3D = Node3D.new()
	n3d.name = "Node3D"
	assert_true(s.vmcallv(vmfunc, n3d, n3d), "Node3D == Node3D")
	n3d.queue_free()

	# Packed arrays
	var pba_pp : PackedByteArray = [1, 2, 3, 4]
	assert_true(s.vmcallv(vmfunc, pba_pp, pba_pp), "PackedByteArray == PackedByteArray")
	var pfa32_pp : PackedFloat32Array = [1.0, 2.0, 3.0, 4.0]
	assert_true(s.vmcallv(vmfunc, pfa32_pp, pfa32_pp), "PackedFloat32Array == PackedFloat32Array")
	var pfa64_pp : PackedFloat64Array = [1.0, 2.0, 3.0, 4.0]
	assert_true(s.vmcallv(vmfunc, pfa64_pp, pfa64_pp), "PackedFloat64Array == PackedFloat64Array")
	var pia32_pp : PackedInt32Array = [1, 2, 3, 4]
	assert_true(s.vmcallv(vmfunc, pia32_pp, pia32_pp), "PackedInt32Array == PackedInt32Array")
	var pia64_pp : PackedInt64Array = [1, 2, 3, 4]
	assert_true(s.vmcallv(vmfunc, pia64_pp, pia64_pp), "PackedInt64Array == PackedInt64Array")
	var pa_vec2_pp : PackedVector2Array = [Vector2(0, 0), Vector2(1, 1), Vector2(2, 2)]
	assert_true(s.vmcallv(vmfunc, pa_vec2_pp, pa_vec2_pp), "PackedVector2Array == PackedVector2Array")
	var pa_vec3_pp : PackedVector3Array = [Vector3(0, 0, 0), Vector3(1, 1, 1), Vector3(2, 2, 2)]
	assert_true(s.vmcallv(vmfunc, pa_vec3_pp, pa_vec3_pp), "PackedVector3Array == PackedVector3Array")
	var pa_vec4_pp : PackedVector4Array = [Vector4(0, 0, 0, 0), Vector4(1, 1, 1, 1), Vector4(2, 2, 2, 2)]
	assert_true(s.vmcallv(vmfunc, pa_vec4_pp, pa_vec4_pp), "PackedVector4Array == PackedVector4Array")
	var pca_pp : PackedColorArray = [Color(0, 0, 0, 0), Color(1, 1, 1, 1)]
	assert_true(s.vmcallv(vmfunc, pca_pp, pca_pp), "PackedColorArray == PackedColorArray")
	var pa_string_pp : PackedStringArray = ["Hello", "from", "the", "other", "side"]
	assert_true(s.vmcallv(vmfunc, pa_string_pp, pa_string_pp), "PackedStringArray == PackedStringArray")

func test_variant_comparisons():
	# Create a new sandbox
	var s = Sandbox.new()
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	assert_eq(s.has_function("test_variant_eq"), true)
	execute_vmcallv_comparison(s, "test_variant_eq")

	assert_eq(s.has_function("test_variant_neq"), true)
	execute_vmcallv_comparison(s, "test_variant_neq")

	assert_eq(s.has_function("test_variant_lt"), true)
	assert_true(s.vmcallv("test_variant_lt", 1, 2), "1 < 2")
	assert_false(s.vmcallv("test_variant_lt", 2, 1), "2 < 1")
	assert_false(s.vmcallv("test_variant_lt", 2, 2), "2 < 2")
	assert_true(s.vmcallv("test_variant_lt", 1.0, 2.0), "1.0 < 2.0")
	assert_false(s.vmcallv("test_variant_lt", 2.0, 1.0), "2.0 < 1.0")
	assert_false(s.vmcallv("test_variant_lt", 2.0, 2.0), "2.0 < 2.0")

	s.queue_free()


func test_objects():
	# Create a new sandbox
	var s = Sandbox.new()
	# Set the test program
	s.set_program(Sandbox_TestsTests)
	assert_eq(s.has_function("test_object"), true)

	# Pass a node to the sandbox
	var n = Node.new()
	n.name = "Node"
	assert_same(s.vmcall("test_object", n), n)

	var n2d = Node2D.new()
	n2d.name = "Node2D"
	assert_same(s.vmcall("test_object", n2d), n2d)

	var n3d = Node3D.new()
	n3d.name = "Node3D"
	assert_same(s.vmcall("test_object", n3d), n3d)
	s.queue_free()


func test_timers():
	# Create a new sandbox
	var s = Sandbox.new()
	var current_exceptions = s.get_global_exceptions()
	# Set the test program
	s.set_program(Sandbox_TestsTests)
	assert_eq(s.has_function("test_timers"), true)
	assert_eq(s.has_function("verify_timers"), true)

	# Create a timer and verify that it works
	var timer = s.vmcall("test_timers")
	assert_typeof(timer, TYPE_OBJECT)
	await get_tree().create_timer(0.25).timeout
	assert_eq(s.get_global_exceptions(), current_exceptions)
	#assert_true(s.vmcall("verify_timers"), "Timers did not work")
	s.queue_free()


func test_exceptions():
	# Create a new sandbox
	var s = Sandbox.new()
	var current_exceptions = s.get_global_exceptions()
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	# Verify that an exception is thrown
	assert_eq(s.has_function("test_exception"), true)
	assert_eq(s.get_timeouts(), 0)
	assert_eq(s.get_exceptions(), 0)
	assert_eq(s.get_global_exceptions(), current_exceptions)
	s.vmcall("test_exception")
	assert_eq(s.get_timeouts(), 0)
	assert_eq(s.get_exceptions(), 1)
	assert_eq(s.get_global_exceptions(), current_exceptions + 1)
	s.queue_free()

func test_indirect_methods():
	# Create a new sandbox
	var s = Sandbox.new()
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	# It's possible to call a method on any Variant, which is an easy
	# way to expand the API without having to add custom system functions
	# call_method() takes a Variant, a method name, and an array of arguments
	assert_eq(s.has_function("call_method"), true)

	# Call a method on a String
	var str : String = "Hello from the other side"
	var expected : PackedStringArray = ["Hello", "from", "the", "other", "side"]
	assert_eq(s.vmcallv("call_method", str, "split", [" "]), expected)

	# Calls that don't return a value
	var d : Dictionary
	d["1"] = "1"
	d["2"] = "2"
	d["3"] = "3"
	var d_expected : Dictionary
	# Clear the dictionary using voidcall "clear" on the dictionary
	s.vmcallv("voidcall_method", d, "clear", [])
	assert_eq_deep(d, d_expected)

	s.queue_free()


func test_static_storage():
	var s : Sandbox = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	# Test that static storage works
	assert_eq(s.has_function("test_static_storage"), true)

	# Call the function that uses static storage
	# It takes a key and a value, stores it in a
	# static Dictionary, and returns the dictionary
	assert_eq_deep(s.vmcallv("test_static_storage", "key", "value"), {"key": "value"})
	assert_eq_deep(s.vmcallv("test_static_storage", "key2", "value2"), {"key": "value", "key2": "value2"})

	# This function tries to create a Dictionary after initialization
	assert_eq(s.has_function("test_failing_static_storage"), true)
	# The first time it will initialize the Dictionary on first-use
	# So, no exception should be thrown
	var exceptions = s.get_exceptions()
	var result = s.vmcallv("test_failing_static_storage", "key", "value")
	assert_eq_deep(result, {"key": "value"})
	assert_eq(s.get_exceptions(), exceptions)

	# The second time it will not initialize the Dictionary
	# as it's stored in a static variable, which was not created
	# during the initialization of the sandbox
	# So, an exception should be thrown
	exceptions = s.get_exceptions()
	result = s.vmcallv("test_failing_static_storage", "key2", "value2")
	assert_eq(s.get_exceptions(), exceptions + 1)
	assert_eq(result, null)

	# This function creates a Dictionary after initialization but makes it permanent
	assert_true(s.has_function("test_permanent_storage"), "Function test_permanent_storage found")
	exceptions = s.get_exceptions()

	result = s.vmcallv("test_permanent_storage", "key", "value")
	assert_eq_deep(result, {"key": "value"})
	assert_eq(s.get_exceptions(), exceptions, "No exceptions thrown")
	# And again, the second time it will not create a new Dictionary
	# but since the old one was made permanent, it will return the stored value nevertheless
	result = s.vmcallv("test_permanent_storage", "key", "value")
	assert_eq_deep(result, {"key": "value"})
	assert_eq(s.get_exceptions(), exceptions, "No exceptions thrown")

	var ps : String = s.vmcall("test_permanent_string", "Hello")
	assert_eq(ps, "Hello", "Permanent string returned")
	assert_true(s.vmcall("test_check_if_permanent", "string"), "Permanent string is permanent")

	var pa : Array = s.vmcall("test_permanent_array", [1, 2, 3])
	assert_eq_deep(pa, [1, 2, 3])
	assert_true(s.vmcall("test_check_if_permanent", "array"), "Permanent array is permanent")

	var pd : Dictionary = s.vmcall("test_permanent_dict", {"key": "value"})
	assert_eq_deep(pd, {"key": "value"})
	assert_true(s.vmcall("test_check_if_permanent", "dict"), "Permanent dictionary is permanent")

	s.queue_free()

func callable_function():
	return

func callable_callee(a1, a2, a3):
	assert(a1 == 1)
	assert(a2 == 2)
	assert(a3 == "3")
	callable_was_called = true

func test_object_properties():
	var s : Sandbox = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	# Test PropertyProxy
	assert_eq(s.has_function("test_property_proxy"), true)
	assert_eq(s.vmcall("test_property_proxy"), "TestOK", "PropertyProxy works")

	s.queue_free()

```

`tests/tests/test_cppscript.gd`:

```gd
extends GutTest

var Sandbox_TestsTests = load("res://tests/tests.elf")
var cpp = load("res://tests/tests.cpp")

func test_set_script():
	var n = Node.new()
	n.set_script(cpp)
	# Create an ELFScript instance
	var nn = Sandbox.new()
	nn.set_script(Sandbox_TestsTests)
	# Sanity check that we can use the ELFScript
	assert_true(nn.execution_timeout > 0, "Can use property execution_timeout from ELFScript")
	assert_true(nn.is_allowed_object(n), "Can use is_allowed_object function from Node with ELFScript")
	# Attach n under nn
	nn.add_child(n)

	# Verify that we can call methods from the ELF program
	n.associated_script = Sandbox_TestsTests
	assert_eq(n.test_int(1234), 1234, "Can call test_int function directly")
	assert_eq(n.get_tree_base_parent(), nn, "Verify node hierarchy is correct")

	# Verify that we also can call Sandbox-related functions through the Node
	assert_true(n.execution_timeout > 0, "Can use property execution_timeout from Node")
	assert_true(n.is_allowed_object(n), "Can use is_allowed_object function from Node")

	# Cleanup
	nn.queue_free()
	n.queue_free()

func test_associated_script():
	var n = Node.new()
	n.set_script(cpp)
	# Create an ELFScript instance
	var nn = Sandbox.new()
	nn.set_script(Sandbox_TestsTests)
	# Attach n under nn
	nn.add_child(n)

	n.associated_script = Sandbox_TestsTests
	assert_eq(n.associated_script, Sandbox_TestsTests, "Verify associated_script is set correctly")
	assert_eq(n.get_associated_script(), Sandbox_TestsTests, "Verify get_associated_script returns the correct script")
	n.set_associated_script(null)
	n.set_associated_script(Sandbox_TestsTests)
	assert_eq(n.associated_script, Sandbox_TestsTests, "Verify associated_script can be set again")

	# Verify that we can call methods from the ELF program
	assert_eq(n.test_int(1234), 1234, "Can call test_int function directly")
	assert_eq(n.get_tree_base_parent(), nn, "Verify node hierarchy is correct")

	# Verify that we also can call Sandbox-related functions through the Node
	assert_true(n.execution_timeout > 0, "Can use property execution_timeout from Node")
	assert_true(n.is_allowed_object(n), "Can use is_allowed_object function from Node")

	# Cleanup
	nn.queue_free()
	n.queue_free()

func test_associated_elf_resource():
	var n = Node.new()
	n.set_script(cpp)
	# Attach n under nn
	var nn = Node.new()
	nn.add_child(n)

	assert_eq(n.associated_script, Sandbox_TestsTests, "Verify associated_script is set correctly")
	assert_eq(n.get_associated_script(), Sandbox_TestsTests, "Verify get_associated_script returns the correct script")

	# Verify that we can call methods from the ELF program
	assert_eq(n.test_int(1234), 1234, "Can call test_int function directly")
	#assert_eq(n.call("test_int", 1234), 1234, "Can call test_int function through call()")
	assert_eq(n.get_tree_base_parent(), nn, "Verify node hierarchy is correct")
	var found_test_int = false
	for i in n.get_method_list():
		#if i.name.begins_with("test_"):
		#	print(i)
		if i.name == "test_int":
			assert_eq(n.test_int(1234), 1234, "Can call test_int function directly")
			found_test_int = true
			break
	assert_true(found_test_int, "test_int method is listed in get_method_list()")

	# Verify that we also can call Sandbox-related functions through the Node
	assert_true(n.execution_timeout > 0, "Can use property execution_timeout from Node")
	assert_true(n.is_allowed_object(n), "Can use is_allowed_object function from Node")
	assert_true(n.monitor_calls_made > 0, "We have made some calls in the Sandbox")

	# Cleanup
	nn.queue_free()
	n.queue_free()

```

`tests/tests/test_gdscript_compiler.cpp`:

```cpp
#include "api.hpp"

#include <compiler.h>
#include <string>
using namespace gdscript;

static String last_error = "";

PUBLIC Variant compile_to_elf(String code)
{
	print("Compiling GDScript code to RISC-V ELF:", code);
	// Compile with all debug output
	CompilerOptions options;
	options.dump_tokens = false;
	options.dump_ast = false;
	options.dump_ir = false;
	options.output_elf = true;

	Compiler compiler;
	auto elf_data = compiler.compile(code.utf8(), options);

	if (elf_data.empty()) {
		print("ERROR: Compilation failed: ", compiler.get_error());
		print("ERROR DETAILS: ", String(compiler.get_error()));
		last_error = String(compiler.get_error());
		return PackedByteArray(std::vector<uint8_t>{}); // Return empty array on failure
	}

	return PackedByteArray(elf_data);
}

PUBLIC Variant compile(String code)
{
	CompilerOptions options;
	options.dump_tokens = false;
	options.dump_ast = false;
	options.dump_ir = false;
	options.output_elf = true;

	Compiler compiler;
	auto elf_data = compiler.compile(code.utf8(), options);

	if (elf_data.empty()) {
		print("ERROR: Compilation failed: ", compiler.get_error());
		print("ERROR DETAILS: ", String(compiler.get_error()));
		last_error = String(compiler.get_error());
		return PackedByteArray(std::vector<uint8_t>{}); // Return empty array on failure
	}

	return PackedByteArray(elf_data);
}

PUBLIC Variant get_compiler_error(Compiler* compiler)
{
	return last_error;
}

```

`tests/tests/test_gdscript_compiler.gd`:

```gd
extends GutTest

var Sandbox_TestsTests = load("res://tests/tests.elf")
var holder = Sandbox.new()

# Compile GDScript using an embedded compiler and test the output

func test_compile_and_run():
	var gdscript_code = """
func truthy():
	return true
func falsy():
	return false

func add(x, y):
	return x + y

func typed_add(x : int, y : int):
	return x + y

func typed_sub(x : int, y : int):
	return x - y

func typed_float_add(x : float, y : float):
	return x + y

func typed_float_mul(x : float, y : float):
	return x * y

func typed_vec3_add(a : Vector3, b : Vector3):
	return a + b

func typed_vec3_mul(a : Vector3, b : Vector3):
	return a * b

func sum1(n):
	var total = 0
	for i in range(n):
		total += i
	return total

func sum2(n):
	var total : int = 0
	var i : int = 0
	while i < n:
		total += i
		i += 1
	return total
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(600)
	assert_true(s.has_function("truthy"), "Compiled ELF should have function 'truthy'")
	assert_true(s.has_function("falsy"), "Compiled ELF should have function 'falsy'")
	assert_true(s.has_function("add"), "Compiled ELF should have function 'add'")
	assert_true(s.has_function("typed_add"), "Compiled ELF should have function 'typed_add'")
	assert_true(s.has_function("typed_sub"), "Compiled ELF should have function 'typed_sub'")

	assert_true(s.has_function("sum1"), "Compiled ELF should have function 'sum1'")
	assert_true(s.has_function("sum2"), "Compiled ELF should have function 'sum2'")

	# Test the compiled functions
	assert_eq(s.vmcallv("truthy"), true, "truthy() should return true")
	assert_eq(s.vmcallv("falsy"), false, "falsy() should return false")
	assert_eq(s.vmcallv("add", 7, 21), 28, "add(7, 21) = 28")
	assert_eq(s.vmcallv("typed_add", 10, 15), 25, "typed_add(10, 15) = 25")
	assert_eq(s.vmcallv("typed_sub", 10, 15), -5, "typed_sub(10, 15) = -5")

	# Test typed float operations (optimized with double-precision FP)
	var f_result = s.vmcallv("typed_float_add", 3.5, 2.5)
	assert_almost_eq(f_result, 6.0, 0.0001, "typed_float_add(3.5, 2.5) = 6.0")
	f_result = s.vmcallv("typed_float_mul", 2.5, 4.0)
	assert_almost_eq(f_result, 10.0, 0.0001, "typed_float_mul(2.5, 4.0) = 10.0")

	# Test typed Vector3 operations (optimized with single-precision FP)
	var v3_result = s.vmcallv("typed_vec3_add", Vector3(6.0, 8.0, 10.0), Vector3(2.0, 2.0, 5.0))
	assert_almost_eq(v3_result.x, 8.0, 0.0001, "vec3_add.x = 8.0")
	assert_almost_eq(v3_result.y, 10.0, 0.0001, "vec3_add.y = 10.0")
	assert_almost_eq(v3_result.z, 15.0, 0.0001, "vec3_add.z = 15.0")
	v3_result = s.vmcallv("typed_vec3_mul", Vector3(3.0, 4.0, 5.0), Vector3(2.0, 2.0, 2.0))
	assert_almost_eq(v3_result.x, 6.0, 0.0001, "vec3_mul.x = 6.0")
	assert_almost_eq(v3_result.y, 8.0, 0.0001, "vec3_mul.y = 8.0")
	assert_almost_eq(v3_result.z, 10.0, 0.0001, "vec3_mul.z = 10.0")

	assert_eq(s.vmcallv("sum1", 10), 45, "sum1(10) should return 45")
	assert_eq(s.vmcallv("sum2", 10), 45, "sum2(10) should return 45")

	s.queue_free()
	ts.queue_free()


func test_many_variables():
	# Test register allocation with 15+ local variables
	var gdscript_code = """
func many_variables():
	var a = 1
	var b = 2
	var c = 3
	var d = 4
	var e = 5
	var f = 6
	var g = 7
	var h = 8
	var i = 9
	var j = 10
	var k = 11
	var l = 12
	var m = 13
	var n = 14
	var o = 15
	return a + b + c + d + e + f + g + h + i + j + k + l + m + n + o
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	assert_true(s.has_function("many_variables"), "Compiled ELF should have function 'many_variables'")

	# Test the compiled function
	var result = s.vmcallv("many_variables")
	assert_eq(result, 120, "many_variables() should return 120 (sum of 1-15)")

	s.queue_free()
	ts.queue_free()

func test_complex_expression():
	# Test register allocation with deeply nested expressions
	var gdscript_code = """
func complex_expr(x, y, z):
	return (x + y) * (y + z) * (z + x) + (x * y) + (y * z) + (z * x)
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	assert_true(s.has_function("complex_expr"), "Compiled ELF should have function 'complex_expr'")

	# Test the compiled function
	var result = s.vmcallv("complex_expr", 2, 3, 4)
	# (2+3)*(3+4)*(4+2) + (2*3) + (3*4) + (4*2)
	# = 5*7*6 + 6 + 12 + 8
	# = 210 + 6 + 12 + 8
	# = 236
	assert_eq(result, 236, "complex_expr(2, 3, 4) should return 236")

	s.queue_free()
	ts.queue_free()

func test_ir_verification():
	# Verify that register allocation avoids unnecessary stack spilling
	# by checking max_registers in the IR
	var gdscript_code = """
func test_func():
	var a = 1
	var b = 2
	var c = 3
	var d = 4
	var e = 5
	return a + b + c + d + e
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true

	# Enable IR dumping to verify register usage
	# Note: This requires access to compiler internals, so we'll just test that it compiles
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	assert_true(s.has_function("test_func"), "Compiled ELF should have function 'test_func'")

	# Test the compiled function
	var result = s.vmcallv("test_func")
	assert_eq(result, 15, "test_func() should return 15")

	# Note: IR verification would check max_registers <= 25
	# This would require compiler internals access, so we verify functionality instead
	s.queue_free()
	ts.queue_free()

func test_vcall_method_calls():
	# Test VCALL - calling methods on Variants
	# Start with a simple test that just returns a constant
	var gdscript_code = """
func test_simple(str):
	str = str.to_upper()
	return str

func test_literal():
	return "Hello, World!"

func test_assign_literal():
	var str = "Hello, Assigned World!"
	return str

func test_chain():
	var str = "Hello, World!"
	str = str.to_upper().to_lower()
	return str

func test_args1(str):
	return str.split_floats(",")
func test_args2(str):
	return str.split_floats("-")
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(6000)
	assert_true(s.has_function("test_simple"), "Compiled ELF should have function 'test_simple'")

	# Test the compiled function
	var result = s.vmcallv("test_simple", "Hello, World!")
	assert_eq(result, "HELLO, WORLD!", "test_simple should convert string to uppercase")

	result = s.vmcallv("test_literal")
	assert_eq(result, "Hello, World!", "test_literal should return the literal string")
	result = s.vmcallv("test_assign_literal")
	assert_eq(result, "Hello, Assigned World!", "test_assign_literal should return the assigned literal string")

	result = s.vmcallv("test_chain")
	assert_eq(result, "hello, world!", "test_chain should convert string to uppercase then lowercase")

	var array : PackedFloat64Array = [1.5, 2.5, 3.5]
	result = s.vmcallv("test_args1", "1.5,2.5,3.5", ",")
	assert_eq_deep(result, array)
	result = s.vmcallv("test_args2", "1.5-2.5-3.5", "-")
	assert_eq_deep(result, array)

	s.queue_free()
	ts.queue_free()


func test_local_function_calls():
	var gdscript_code = """
func test_to_upper(str):
	str = str.to_upper()
	return str

func test_call():
	return test_to_upper("Hello, World!")

func test_call2():
	return test_call()

func test_call3():
	return test_call2()

func test_call_with_shuffling(a0, a1):
	return test_to_upper(a1)

func untyped_fibonacci(n):
	if n <= 1:
		return n
	return untyped_fibonacci(n - 1) + untyped_fibonacci(n - 2)

func typed_fibonacci(n : int):
	if n <= 1:
		return n
	return typed_fibonacci(n - 1) + typed_fibonacci(n - 2)
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(6000)
	assert_true(s.has_function("test_to_upper"), "Compiled ELF should have function 'test_to_upper'")
	assert_true(s.has_function("test_call"), "Compiled ELF should have function 'test_call'")

	# Test the compiled function
	var result = s.vmcallv("test_to_upper", "Hello, World!")
	assert_eq(result, "HELLO, WORLD!", "test_to_upper should convert string to uppercase")

	# Indirectly test via test_call
	result = s.vmcallv("test_call")
	assert_eq(result, "HELLO, WORLD!", "test_call should return uppercase string via test_to_upper")

	result = s.vmcallv("test_call2")
	assert_eq(result, "HELLO, WORLD!", "test_call2 should return uppercase string via test_call")

	result = s.vmcallv("test_call3")
	assert_eq(result, "HELLO, WORLD!", "test_call3 should return uppercase string via test_call2")

	result = s.vmcallv("test_call_with_shuffling", "first", "second")
	assert_eq(result, "SECOND", "test_call_with_shuffling should return uppercase of second argument")

	# Test typed/untyped fibonacci
	result = s.vmcallv("typed_fibonacci", 20)
	assert_eq(result, 6765, "typed_fibonacci(20) should return 6765")

	result = s.vmcallv("untyped_fibonacci", 20)
	assert_eq(result, 6765, "untyped_fibonacci(20) should return 6765")

	s.queue_free()
	ts.queue_free()

func test_range_loop_bounds():
	# Test that for i in range(n) doesn't execute n+1 iterations
	var gdscript_code = """
func test_range_count(n):
	var count = 0
	for i in range(n):
		count += 1
	return count

func test_range_new_var():
	var unused = 42
	for i in range(5):
		var nvar = i
	return unused

func test_range_no_var():
	var unused = 42
	for i in range(5):
		continue
	return unused

func test_range_last_value():
	var last = -1
	for i in range(5):
		last = i
	return last

func countup_loop():
	var sum = 0
	for i in range(1, 10, 1):
		sum = sum + i
	return sum

func countdown_loop():
	var sum = 0
	for i in range(10, 0, -1):
		sum = sum + i
	return sum

func test_loopy_ints():
	var a = 0
	const b = 1
	for i in range(10):
		a = a + b
	return a
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(1)
	assert_true(s.has_function("test_range_count"), "Compiled ELF should have function 'test_range_count'")
	assert_true(s.has_function("test_range_last_value"), "Compiled ELF should have function 'test_range_last_value'")
	assert_true(s.has_function("test_range_no_var"), "Compiled ELF should have function 'test_range_no_var'")
	assert_true(s.has_function("test_range_new_var"), "Compiled ELF should have function 'test_range_new_var'")

	# Test iteration count
	assert_eq(s.vmcallv("test_range_count", 10), 10, "range(10) should iterate exactly 10 times")
	assert_eq(s.vmcallv("test_range_count", 5), 5, "range(5) should iterate exactly 5 times")
	assert_eq(s.vmcallv("test_range_count", 0), 0, "range(0) should iterate 0 times")

	# Test last value (should be 4 for range(5))
	assert_eq(s.vmcallv("test_range_last_value"), 4, "range(5) last value should be 4")

	# Test no variable inside loop
	assert_eq(s.vmcallv("test_range_no_var"), 42, "test_range_no_var should return 42")

	# Test new variable inside loop
	assert_eq(s.vmcallv("test_range_new_var"), 42, "test_range_new_var should return 42")

	# Test countup loop
	var result = s.vmcallv("countup_loop")
	# sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
	assert_eq(result, 45, "countup_loop should sum 1..9 = 45")

	# Test countdown loop with negative step
	result = s.vmcallv("countdown_loop")
	# sum = 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 55
	assert_eq(result, 55, "countdown_loop should sum 10..1 = 55")

	# Test loopy ints
	result = s.vmcallv("test_loopy_ints")
	assert_eq(result, 10, "test_loopy_ints should return 10")

	s.queue_free()
	ts.queue_free()

func test_subscript_operations():
	# Test array and dictionary subscript operations using [] operator
	var gdscript_code = """
func test_array_get(arr, idx):
	return arr[idx]

func test_array_set(arr, idx, value):
	arr[idx] = value
	return arr

func test_dict_get(dict, key):
	return dict[key]

func test_dict_set(dict, key, value):
	dict[key] = value
	return dict

func test_chained_get(arr):
	var first = arr[0]
	var second = arr[1]
	return first + second
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(6000)

	# Test array get
	var test_array = [10, 20, 30, 40, 50]
	var result = s.vmcallv("test_array_get", test_array, 2)
	assert_eq(result, 30, "arr[2] should return 30")

	result = s.vmcallv("test_array_get", test_array, 0)
	assert_eq(result, 10, "arr[0] should return 10")

	# Test array set
	var arr = [1, 2, 3]
	result = s.vmcallv("test_array_set", arr, 1, 99)
	assert_eq(result[1], 99, "arr[1] should be set to 99")

	# Test dictionary get
	var test_dict = {"name": "Alice", "age": 30}
	result = s.vmcallv("test_dict_get", test_dict, "name")
	assert_eq(result, "Alice", "dict['name'] should return 'Alice'")

	result = s.vmcallv("test_dict_get", test_dict, "age")
	assert_eq(result, 30, "dict['age'] should return 30")

	# Test dictionary set
	var dict = {"x": 1, "y": 2}
	result = s.vmcallv("test_dict_set", dict, "x", 42)
	assert_eq(result["x"], 42, "dict['x'] should be set to 42")

	# Test chained subscript operations
	var arr2 = [5, 15]
	result = s.vmcallv("test_chained_get", arr2)
	assert_eq(result, 20, "chained subscripts should return 5 + 15 = 20")

	s.queue_free()
	ts.queue_free()

func test_inline_vector_primitives():
	# Test inline construction and member access for Vector2/3/4 without syscalls
	var gdscript_code = """
func test_vector2():
	var v = Vector2(3.0, 4.0)
	return v.x + v.y

func test_vector2_int():
	var v = Vector2(3, 4)
	return v.x + v.y

func test_vector3():
	var v = Vector3(1.0, 2.0, 3.0)
	return v.x + v.y + v.z

func test_vector3_int():
	var v = Vector3(1, 2, 3)
	return v.x + v.y + v.z

func test_vector4():
	var v = Vector4(10.0, 20.0, 30.0, 40.0)
	return v.x + v.y + v.z + v.w

func test_vector4_int():
	var v = Vector4(10, 20, 30, 40)
	return v.x + v.y + v.z + v.w

func test_vector2i():
	var v = Vector2i(5, 7)
	return v.x + v.y

func test_vector3i():
	var v = Vector3i(1, 2, 3)
	return v.x * v.y * v.z

func test_vector4i():
	var v = Vector4i(2, 3, 5, 7)
	return v.x + v.y + v.z + v.w

func test_color():
	var c = Color(0.5, 0.25, 0.75, 1.0)
	return c.r + c.g + c.b + c.a

func test_color_int():
	var c = Color(0, 128, 255, 255)
	return c.r + c.g + c.b + c.a

func test_chained_vectors():
	var v1 = Vector2(10.0, 20.0)
	var v2 = Vector2(v1.x, v1.y)
	return v2.x + v2.y

func test_loopy_vector():
	var v = Vector2(0.0, 0.0)
	const v2 = Vector2(1.0, 1.0)
	for i in range(10):
		v = v + v2
	return v
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	# Write the ELF to a file for debugging
	var file = FileAccess.open("res://tests/vec.elf", FileAccess.WRITE)
	if file:
		file.store_buffer(compiled_elf)
		file.close()

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(1000)

	# Test Vector2
	var result = s.vmcallv("test_vector2")
	assert_almost_eq(result, 7.0, 0.001, "Vector2(3.0, 4.0).x + .y should be 7.0")

	# Test Vector2 with integer args
	result = s.vmcallv("test_vector2_int")
	assert_almost_eq(result, 7.0, 0.001, "Vector2(3, 4).x + .y should be 7.0")

	# Test Vector3
	result = s.vmcallv("test_vector3")
	assert_almost_eq(result, 6.0, 0.001, "Vector3(1.0, 2.0, 3.0) sum should be 6.0")

	# Test Vector3 with integer args
	result = s.vmcallv("test_vector3_int")
	assert_almost_eq(result, 6.0, 0.001, "Vector3(1, 2, 3) sum should be 6.0")

	# Test Vector4
	result = s.vmcallv("test_vector4")
	assert_almost_eq(result, 100.0, 0.001, "Vector4(10.0, 20.0, 30.0, 40.0) sum should be 100.0")

	# Test Vector4 with integer args
	result = s.vmcallv("test_vector4_int")
	assert_almost_eq(result, 100.0, 0.001, "Vector4(10, 20, 30, 40) sum should be 100.0")

	# Test Vector2i
	result = s.vmcallv("test_vector2i")
	assert_eq(result, 12, "Vector2i(5, 7).x + .y should be 12")

	# Test Vector3i
	result = s.vmcallv("test_vector3i")
	assert_eq(result, 6, "Vector3i(1, 2, 3) product should be 6")

	# Test Vector4i
	result = s.vmcallv("test_vector4i")
	assert_eq(result, 17, "Vector4i(2, 3, 5, 7) sum should be 17")

	# Test Color
	result = s.vmcallv("test_color")
	assert_almost_eq(result, 2.5, 0.001, "Color components sum should be 2.5")

	# Test Color with integer args (0, 128, 255, 255 = 0.0, 0.502, 1.0, 1.0)
	result = s.vmcallv("test_color_int")
	var expected = 0.0 + (128.0 / 255.0) + 1.0 + 1.0
	assert_almost_eq(result, expected, 0.01, "Color with int args should work")

	# Test chained operations
	result = s.vmcallv("test_chained_vectors")
	assert_almost_eq(result, 30.0, 0.001, "Chained vector operations should work")

	# Test loopy vector addition
	result = s.vmcallv("test_loopy_vector")
	assert_eq(result, Vector2(10.0, 10.0), "Loopy vector addition should result in Vector2(10.0, 10.0)")

	s.queue_free()
	ts.queue_free()

func test_float_constant_folding():
	var gdscript_code = """
func test_float_add():
	return 1.5 + 2.5

func test_float_mul():
	return 2.5 * 4.0

func test_float_sub():
	return 5.5 - 2.5

func test_float_div():
	return 10.0 / 2.0

func test_int_float_promotion():
	return 1 + 2.5

func test_float_comparison_lt():
	return 1.5 < 2.5

func test_float_comparison_gte():
	return 3.5 >= 2.5

func test_complex_fold():
	return 1.5 + 2.5 * 2.0

func test_int_neg():
	return -42

func test_float_neg():
	return -3.14
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(1000)

	# Test float addition
	var result = s.vmcallv("test_float_add")
	assert_almost_eq(result, 4.0, 0.001, "Float constant folding: 1.5 + 2.5 should be 4.0")

	# Test float multiplication
	result = s.vmcallv("test_float_mul")
	assert_almost_eq(result, 10.0, 0.001, "Float constant folding: 2.5 * 4.0 should be 10.0")

	# Test float subtraction
	result = s.vmcallv("test_float_sub")
	assert_almost_eq(result, 3.0, 0.001, "Float constant folding: 5.5 - 2.5 should be 3.0")

	# Test float division
	result = s.vmcallv("test_float_div")
	assert_almost_eq(result, 5.0, 0.001, "Float constant folding: 10.0 / 2.0 should be 5.0")

	# Test int + float promotion
	result = s.vmcallv("test_int_float_promotion")
	assert_almost_eq(result, 3.5, 0.001, "Int + float: 1 + 2.5 should be 3.5")

	# Test float comparison
	result = s.vmcallv("test_float_comparison_lt")
	assert_eq(result, true, "Float comparison: 1.5 < 2.5 should be true")

	result = s.vmcallv("test_float_comparison_gte")
	assert_eq(result, true, "Float comparison: 3.5 >= 2.5 should be true")

	# Test complex expression folding
	result = s.vmcallv("test_complex_fold")
	assert_almost_eq(result, 6.5, 0.001, "Complex folding: 1.5 + 2.5 * 2.0 should be 6.5")

	# Test integer negation
	result = s.vmcallv("test_int_neg")
	assert_eq(result, -42, "Int negation: -42 should be -42")

	# Test float negation
	result = s.vmcallv("test_float_neg")
	assert_almost_eq(result, -3.14, 0.001, "Float negation: -3.14 should be -3.14")

	s.queue_free()
	ts.queue_free()

func test_array_dictionary_constructors():
	# Test Array() and Dictionary() constructor support
	var gdscript_code = """
func make_empty_array():
	return Array()

func make_empty_dictionary():
	return Dictionary()

func make_array_and_add():
	var arr = Array()
	arr.append(42)
	arr.append(100)
	return arr

func make_dict():
	var dict = Dictionary()
	dict["key1"] = "value1"
	dict["key2"] = 42
	return dict

func dict_literal():
	var dict = {key1: "value", key2: 42}
	return dict

func nested_dict_literal():
	var dict = {key1: "value", key2: 42, key3: {nested_key: "nested_value", number: 99}}
	return dict

func array_size():
	var arr = Array()
	arr.append(1)
	arr.append(2)
	arr.append(3)
	return arr.size()

func dict_size():
	var dict = Dictionary()
	dict["a"] = 1
	dict["b"] = 2
	dict["c"] = 3
	return dict.size()

func make_array_single():
	return Array(42)

func make_array_two():
	return Array(1, 2)

func make_array_with_values():
	return Array(1, 2, 3, 4, 5)

func make_array_with_strings():
	return Array("hello", "world", "test")
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(1000)

	# Test empty array
	var arr = s.vmcallv("make_empty_array")
	assert_eq(arr.size(), 0, "Empty Array() should have size 0")

	# Test empty dictionary
	var dict = s.vmcallv("make_empty_dictionary")
	assert_eq(dict.size(), 0, "Empty Dictionary() should have size 0")

	# Test array with append
	arr = s.vmcallv("make_array_and_add")
	assert_eq(arr.size(), 2, "Array with 2 appends should have size 2")
	assert_eq(arr[0], 42, "First element should be 42")
	assert_eq(arr[1], 100, "Second element should be 100")

	# Test dictionary with set
	dict = s.vmcallv("make_dict")
	assert_eq(dict.size(), 2, "Dictionary with 2 keys should have size 2")
	assert_eq(dict["key1"], "value1", "key1 should have value 'value1'")
	assert_eq(dict["key2"], 42, "key2 should have value 42")
	# Test dictionary literal
	var dict2 = s.vmcallv("dict_literal")
	assert_eq(dict2.size(), 2, "Dictionary literal should have size 2")
	assert_eq(dict2["key1"], "value", "key1 should have value 'value'")
	assert_eq(dict2["key2"], 42, "key2 should have value 42")
	# Test nested dictionary literal
	var dict3 = s.vmcallv("nested_dict_literal")
	assert_eq(dict3.size(), 3, "Nested dictionary literal should have size 3")
	assert_eq(dict3["key1"], "value", "key1 should have value 'value'")
	assert_eq(dict3["key2"], 42, "key2 should have value 42")
	var nested = dict3["key3"]
	assert_eq(nested.size(), 2, "Nested dictionary should have size 2")
	assert_eq(nested["nested_key"], "nested_value", "nested_key should have value 'nested_value'")
	assert_eq(nested["number"], 99, "number should have value 99")

	# Test array size
	assert_eq(s.vmcallv("array_size"), 3, "array_size() should return 3")

	# Test dictionary size
	assert_eq(s.vmcallv("dict_size"), 3, "dict_size() should return 3")

	# Test Array with single element
	arr = s.vmcallv("make_array_single")
	assert_eq(arr.size(), 1, "Array(42) should have size 1")
	assert_eq(arr[0], 42, "First element should be 42")

	# Test Array with two elements
	arr = s.vmcallv("make_array_two")
	assert_eq(arr.size(), 2, "Array(1,2) should have size 2")
	assert_eq(arr[0], 1, "First element should be 1")
	assert_eq(arr[1], 2, "Second element should be 2")

	# Test Array with initial integer values
	arr = s.vmcallv("make_array_with_values")
	assert_eq(arr.size(), 5, "Array(1,2,3,4,5) should have size 5")
	assert_eq(arr[0], 1, "First element should be 1")
	assert_eq(arr[1], 2, "Second element should be 2")
	assert_eq(arr[2], 3, "Third element should be 3")
	assert_eq(arr[3], 4, "Fourth element should be 4")
	assert_eq(arr[4], 5, "Fifth element should be 5")

	# Test Array with initial string values
	arr = s.vmcallv("make_array_with_strings")
	assert_eq(arr.size(), 3, "Array with 3 strings should have size 3")
	assert_eq(arr[0], "hello", "First string should be 'hello'")
	assert_eq(arr[1], "world", "Second string should be 'world'")
	assert_eq(arr[2], "test", "Third string should be 'test'")

	s.queue_free()
	ts.queue_free()

func test_comprehensive_compiler_readiness():
	# A comprehensive test that progressively tests more complex features
	# Each function tests more features together to uncover integration bugs
	# NOTE: Temporarily using minimal test to identify compilation issues
	var gdscript_code = """
# LEVEL 1: Basic types and literals
func level1_literals():
	var int_val = 42
	var float_val = 3.14
	var string_val = "Hello"
	var bool_val = true
	return int_val + float_val + string_val.length()

# LEVEL 2: Arithmetic operations
func level2_arithmetic(a, b):
	var sum = a + b
	var diff = a - b
	var prod = a * b
	var div = a / b
	var mod = a % b
	return sum + diff + prod + div + mod

# LEVEL 3: String operations and method chaining
func level3_strings(name):
	var greeting = "Hello, " + name + "!"
	var upper = greeting.to_upper()
	var lower = upper.to_lower()
	var trimmed = lower.strip_edges()
	return trimmed.length()

# LEVEL 4: Array operations
func level4_arrays():
	var arr = Array()
	arr.append(10)
	arr.append(20)
	arr.append(30)
	var first = arr[0]
	var last = arr[arr.size() - 1]
	arr.sort()
	return arr[0] + arr[1] + arr[2]

# LEVEL 5: Dictionary operations
func level5_dictionaries():
	var dict = Dictionary()
	dict["count"] = 0
	for i in range(5):
		dict["count"] = dict["count"] + 1
	dict["doubled"] = dict["count"] * 2
	return dict["count"] + dict["doubled"]

# LEVEL 6: Control flow - if/else
func level6_ifelse(x, y):
	if x > y:
		return x * 2
	elif x < y:
		return y * 2
	else:
		return x + y

# LEVEL 7: Nested loops with arrays
func level7_nested_loops():
	var matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
	var sum = 0
	for i in range(3):
		for j in range(3):
			sum = sum + matrix[i][j]
	return sum

# LEVEL 8: Function calls and recursion
func level8_recursive(n):
	if n <= 1:
		return 1
	return n * level8_recursive(n - 1)

func level8_helper(x):
	return x * x

func level8_call_chain(n):
	var squared = level8_helper(n)
	var doubled = squared * 2
	return level8_recursive(doubled % 5 + 1)

# LEVEL 9: Vector types and math
func level9_vectors():
	var v2 = Vector2(3.0, 4.0)
	var v3 = Vector3(1.0, 2.0, 3.0)
	var v2i = Vector2i(10, 20)
	var v3i = Vector3i(2, 3, 4)
	var v2_len = v2.x + v2.y
	var v3_len = v3.x + v3.y + v3.z
	var v2i_len = v2i.x + v2i.y
	var v3i_len = v3i.x * v3i.y * v3i.z
	return v2_len + v3_len + v2i_len + v3i_len

# LEVEL 10: Mixed complex operations
func level10_complex(data):
	var result = 0
	for i in range(data.size()):
		var val = data[i]
		if val > 0:
			result = result + val
		elif val < 0:
			result = result - val
		else:
			result = result + 10
	return result
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(100000)

	# LEVEL 1: Basic types
	var result = s.vmcallv("level1_literals")
	# 42 + 3.14 + 5 (length of "Hello") = 50.14
	assert_eq(result, 50.14, "Level 1: Basic literals should work")

	# LEVEL 2: Arithmetic
	result = s.vmcallv("level2_arithmetic", 10, 3)
	# sum=13, diff=7, prod=30, div=3, mod=1 => 13+7+30+3+1 = 54
	assert_eq(result, 54, "Level 2: Arithmetic operations")

	# LEVEL 3: String operations
	result = s.vmcallv("level3_strings", "Claude")
	# "Hello, Claude!" -> uppercase -> lowercase -> trim -> length = 14
	assert_eq(result, 14, "Level 3: String operations")

	# LEVEL 4: Array operations
	result = s.vmcallv("level4_arrays")
	# [10, 20, 30] sorted -> [10, 20, 30] -> sum = 60
	assert_eq(result, 60, "Level 4: Array operations")

	# LEVEL 5: Dictionary operations
	result = s.vmcallv("level5_dictionaries")
	# count = 5, doubled = 10 -> 15
	assert_eq(result, 15, "Level 5: Dictionary operations")

	# LEVEL 6: Control flow
	result = s.vmcallv("level6_ifelse", 10, 5)
	assert_eq(result, 20, "Level 6: If/else (x > y)")
	result = s.vmcallv("level6_ifelse", 5, 10)
	assert_eq(result, 20, "Level 6: If/else (x < y)")
	result = s.vmcallv("level6_ifelse", 5, 5)
	assert_eq(result, 10, "Level 6: If/else (x == y)")

	# LEVEL 7: Nested loops
	result = s.vmcallv("level7_nested_loops")
	# 1+2+3+4+5+6+7+8+9 = 45
	assert_eq(result, 45, "Level 7: Nested loops")

	# LEVEL 8: Recursion
	result = s.vmcallv("level8_recursive", 5)
	# 5! = 120
	assert_eq(result, 120, "Level 8: Recursive factorial")
	result = s.vmcallv("level8_call_chain", 3)
	# squared=9, doubled=18, 18%5+1=4, 4! = 24
	assert_eq(result, 24, "Level 8: Call chain")

	# LEVEL 9: Vectors
	result = s.vmcallv("level9_vectors")
	# v2: 7.0, v3: 6.0, v2i: 30, v3i: 24 -> 67.0
	assert_eq(result, 67.0, "Level 9: Vector operations")

	# LEVEL 10: Complex with mixed data
	var test_data = [1, -2, 3, -4, 0, 5]
	result = s.vmcallv("level10_complex", test_data)
	# 1 + 2 + 3 + 4 + 10 + 5 = 25
	assert_eq(result, 25, "Level 10: Mixed complex operations")

	s.queue_free()
	ts.queue_free()

func test_global_class_access():
	# Test accessing global classes like Time
	var gdscript_code = """
func test_time_get_ticks_usec():
	var time_obj = Time
	return time_obj.get_ticks_usec()

func test_chained_call():
	return Time.get_ticks_usec()
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true

	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.restrictions = true
	s.set_class_allowed_callback(func(sandbox, name): return name == "Time")
	s.set_method_allowed_callback(func(sandbox, obj, method):
		return obj.get_class() == "Time" and method == "get_ticks_usec")
	s.load_buffer(compiled_elf)
	s.set_instructions_max(5000)

	# Test direct global class access and method call
	var result = s.vmcallv("test_time_get_ticks_usec")
	assert_true(result >= 0, "Time.get_ticks_usec() should return a non-negative value")

	# Test chained call
	result = s.vmcallv("test_chained_call")
	assert_true(result >= 0, "Time.get_ticks_usec() chained should return a non-negative value")

	s.queue_free()
	ts.queue_free()

func test_array_iteration():
	# Test for item in array iteration
	var gdscript_code = """
func test_simple_array_iteration():
	var arr = [1, 2, 3, 4, 5]
	var sum = 0
	for item in arr:
		sum = sum + item
	return sum

func test_array_string_iteration():
	var arr = ["hello", "world", "test"]
	var result = ""
	for item in arr:
		result = result + item
	return result

func test_empty_array():
	var arr = []
	var count = 0
	for item in arr:
		count = count + 1
	return count

func test_nested_array_iteration():
	var matrix = [[1, 2], [3, 4]]
	var sum = 0
	for row in matrix:
		for item in row:
			sum = sum + item
	return sum
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	# Write ELF for objdump inspection
	var file = FileAccess.open("res://tests/array.elf", FileAccess.WRITE)
	if file:
		file.store_buffer(compiled_elf)
		file.close()

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test simple array iteration
	var result = s.vmcallv("test_simple_array_iteration")
	assert_eq(result, 15, "Sum of [1,2,3,4,5] should be 15")

	# Test array with string elements
	result = s.vmcallv("test_array_string_iteration")
	assert_eq(result, "helloworldtest", "Concatenated strings should be 'helloworldtest'")

	# Test empty array
	result = s.vmcallv("test_empty_array")
	assert_eq(result, 0, "Empty array should iterate 0 times")

	# Test nested array iteration
	result = s.vmcallv("test_nested_array_iteration")
	assert_eq(result, 10, "Sum of [[1,2],[3,4]] should be 10")

	s.queue_free()
	ts.queue_free()

# Comprehensive FP arithmetic tests to stress FP register allocation and AUIPC+ADDI patching
func test_fp_register_allocation_stress():
	var gdscript_code = """
func many_float_vars():
	var f1 = 1.1
	var f2 = 2.2
	var f3 = 3.3
	var f4 = 4.4
	var f5 = 5.5
	var f6 = 6.6
	var f7 = 7.7
	var f8 = 8.8
	var f9 = 9.9
	var f10 = 10.10
	var f11 = 11.11
	var f12 = 12.12
	var f13 = 13.13
	var f14 = 14.14
	var f15 = 15.15
	var sum = f1 + f2 + f3 + f4 + f5
	return sum
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("many_float_vars")
	# 1.1 + 2.2 + 3.3 + 4.4 + 5.5 = 16.5
	assert_almost_eq(result, 16.5, 0.01, "Sum of 5 floats should be 16.5")

	s.queue_free()
	ts.queue_free()

func test_large_float_constants():
	var gdscript_code = """
func large_constants():
	const f1 = 123456.789
	const f2 = 987654.321
	const f3 = 111111.222
	const f4 = 999999.999
	var sum = f1 + f2 + f3 + f4
	return sum
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("large_constants")
	assert_almost_eq(result, 2222222.331, 0.01, "Sum of large floats should be correct")

	s.queue_free()
	ts.queue_free()

func test_complex_float_arithmetic():
	var gdscript_code = """
func complex_arithmetic():
	var a = 1.5
	var b = 2.5
	var c = 3.0
	var d = 4.0
	var sum1 = a + b
	var sum2 = c + d
	var product = sum1 * sum2
	var quotient = product / a
	return quotient
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("complex_arithmetic")
	# (1.5 + 2.5) * (3.0 + 4.0) / 1.5 = 4.0 * 7.0 / 1.5 = 28.0 / 1.5 = 18.666...
	assert_almost_eq(result, 18.666, 0.001, "Complex arithmetic should work")

	s.queue_free()
	ts.queue_free()

func test_vector_fp_arithmetic():
	var gdscript_code = """
func vector_arithmetic():
	var v1 = Vector2(1.5, 2.5)
	var v2 = Vector2(3.0, 4.0)
	# Add components: v1.x + v2.x, v1.y + v2.y
	var x_sum = v1.x + v2.x
	var y_sum = v1.y + v2.y
	var total = x_sum + y_sum
	return total
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("vector_arithmetic")
	# (1.5 + 3.0) + (2.5 + 4.0) = 4.5 + 6.5 = 11.0
	assert_almost_eq(result, 11.0, 0.001, "Vector FP arithmetic should work")

	s.queue_free()
	ts.queue_free()

func test_vector3_operations():
	var gdscript_code = """
func vector3_ops():
	var v = Vector3(1.0, 2.0, 3.0)
	var x = v.x
	var y = v.y
	var z = v.z
	# Test each component access and arithmetic
	var x2 = x * 2.0
	var y2 = y * 3.0
	var z2 = z * 4.0
	return x2 + y2 + z2
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("vector3_ops")
	# 1.0 * 2 + 2.0 * 3 + 3.0 * 4 = 2 + 6 + 12 = 20
	assert_almost_eq(result, 20.0, 0.001, "Vector3 operations should work")

	s.queue_free()
	ts.queue_free()

func test_vector4_operations():
	var gdscript_code = """
func vector4_ops():
	var v = Vector4(1.0, 2.0, 3.0, 4.0)
	var w = v.w
	var z = v.z
	var y = v.y
	var x = v.x
	# Test component order and arithmetic
	var sum = w + z + y + x
	return sum
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("vector4_ops")
	assert_almost_eq(result, 10.0, 0.001, "Vector4 component access should work")

	s.queue_free()

func test_float_vector_chaining():
	var gdscript_code = """
func chain_vector_ops():
	var v1 = Vector2(1.0, 2.0)
	var v2 = Vector2(v1.x + 1.0, v1.y + 2.0)
	var v3 = Vector2(v2.x * 2.0, v2.y * 3.0)
	return v3.x + v3.y
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("chain_vector_ops")
	# v1 = (1.0, 2.0), v2 = (2.0, 4.0), v3 = (4.0, 12.0)
	# 4.0 + 12.0 = 16.0
	assert_almost_eq(result, 16.0, 0.001, "Chained vector operations should work")

	s.queue_free()
	ts.queue_free()

func test_mixed_int_float_arithmetic():
	var gdscript_code = """
func mixed_arithmetic():
	var f = 10.5
	var i = 5
	var sum1 = f + i
	var sum2 = i + f
	var product = f * i
	return sum1 + sum2 + product
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("mixed_arithmetic")
	# 10.5 + 5 + 5 + 10.5 + 10.5 * 5 = 15.5 + 15.5 + 52.5 = 83.5
	assert_almost_eq(result, 83.5, 0.001, "Mixed int/float arithmetic should work")

	s.queue_free()

func test_float_division_edge_cases():
	var gdscript_code = """
func float_division():
	var a = 100.0
	var b = 4.0
	var c = 3.0
	var result = a / b / c
	return result
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	var result = s.vmcallv("float_division")
	# 100.0 / 4.0 / 3.0 = 25.0 / 3.0 = 8.333...
	assert_almost_eq(result, 8.333, 0.001, "Float division chain should work")

	s.queue_free()
	ts.queue_free()

# Logical operator tests (and, or, not)
func test_logical_operators():
	var gdscript_code = """
func test_and():
	var a = true
	var b = false
	return a and b

func test_or():
	var a = true
	var b = false
	return a or b

func test_not():
	var a = true
	return not a

func test_complex_logical():
	var x = 5
	var y = 10
	var z = 15
	return (x < y) and (y < z)

func test_short_circuit_and():
	if false and expensive_call():
		return true
	return false

func test_short_circuit_or():
	if true or expensive_call():
		return true
	return false

func expensive_call():
	# This should never be called in short-circuit eval
	return "ERROR"

func test_and_with_result():
	var a = 42
	var b = 100
	return (a > 0) and (b < 200)

func test_or_with_result():
	var a = -5
	var b = 10
	return (a > 0) or (b > 0)
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test basic AND
	var result = s.vmcallv("test_and")
	assert_eq(result, false, "true and false should be false")

	# Test basic OR
	result = s.vmcallv("test_or")
	assert_eq(result, true, "true or false should be true")

	# Test NOT
	result = s.vmcallv("test_not")
	assert_eq(result, false, "not true should be false")

	# Test complex logical
	result = s.vmcallv("test_complex_logical")
	assert_eq(result, true, "(5 < 10) and (10 < 15) should be true")

	# NOTE: Short-circuit evaluation is NOT supported - GDScript evaluates all arguments
	# before applying operators. The following tests are disabled:
	# result = s.vmcallv("test_short_circuit_and")
	# assert_eq(result, false, "Short-circuit AND should skip expensive call")
	# result = s.vmcallv("test_short_circuit_or")
	# assert_eq(result, true, "Short-circuit OR should skip expensive call")

	# Test AND with comparison result
	result = s.vmcallv("test_and_with_result")
	assert_eq(result, true, "(42 > 0) and (100 < 200) should be true")

	# Test OR with comparison result
	result = s.vmcallv("test_or_with_result")
	assert_eq(result, true, "(-5 > 0) or (10 > 0) should be true")

	s.queue_free()
	ts.queue_free()

# String concatenation tests - NOT SUPPORTED (string + operator)
# func test_string_concatenation():
# 	var gdscript_code = """
# func test_basic_concat():
# 	var a = "Hello"
# 	var b = " World"
# 	return a + b
#
# func test_concat_literal():
# 	return "Hello" + " " + "World!"
#
# func test_concat_with_number():
# 	var name = "Count"
# 	var num = 42
# 	return name + str(num)
#
# func test_concat_chain():
# 	var a = "A"
# 	var b = "B"
# 	var c = "C"
# 	return a + b + c
#
# func test_concat_in_expression():
# 	var prefix = "Result: "
# 	var value = 123
# 	return prefix + str(value)
# """
#
# 	var ts : Sandbox = Sandbox.new()
# 	ts.set_program(Sandbox_TestsTests)
# 	ts.restrictions = true
# 	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
# 	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")
#
# 	var s = Sandbox.new()
# 	s.load_buffer(compiled_elf)
# 	s.set_instructions_max(10000)
#
# 	# Test basic concatenation
# 	var result = s.vmcallv("test_basic_concat")
# 	assert_eq(result, "Hello World", "Basic string concat should work")
#
# 	# Test literal concatenation
# 	result = s.vmcallv("test_concat_literal")
# 	assert_eq(result, "Hello World!", "Literal concat should work")
#
# 	# Test concat with str()
# 	result = s.vmcallv("test_concat_with_number")
# 	assert_eq(result, "Count42", "Concat with str() should work")
#
# 	# Test concat chain
# 	result = s.vmcallv("test_concat_chain")
# 	assert_eq(result, "ABC", "Chain concat should work")
#
# 	# Test concat in expression
# 	result = s.vmcallv("test_concat_in_expression")
# 	assert_eq(result, "Result: 123", "Concat with str() in expression should work")
#
# 	s.queue_free()

# Modulo operator edge cases
func test_modulo_operator():
	var gdscript_code = """
func test_basic_mod():
	return 17 % 5

func test_mod_negative():
	return -17 % 5

func test_mod_float():
	return 17.5 % 3.0

func test_mod_zero_divisor():
	var a = 10
	var b = 0
	# Division by zero should produce inf or error at runtime
	# We'll just test the compiler accepts it
	return a % 1

func test_mod_chain():
	var a = 100
	var b = a % 7
	var c = b % 3
	return c

func test_mod_with_vars():
	var x = 25
	var y = 4
	var result = x % y
	return result
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test basic modulo
	var result = s.vmcallv("test_basic_mod")
	assert_eq(result, 2, "17 % 5 should be 2")

	# Test modulo with negative
	result = s.vmcallv("test_mod_negative")
	# Godot's modulo behavior: -17 % 5 = -2
	assert_eq(result, -2, "-17 % 5 should be -2")

	# Test modulo with floats
	result = s.vmcallv("test_mod_float")
	# 17.5 % 3.0 = 2.5
	assert_almost_eq(result, 2.5, 0.01, "Float modulo should work")

	# Test modulo chain
	result = s.vmcallv("test_mod_chain")
	# 100 % 7 = 2, 2 % 3 = 2
	assert_eq(result, 2, "Chained modulo should work")

	# Test modulo with variables
	result = s.vmcallv("test_mod_with_vars")
	assert_eq(result, 1, "25 % 4 should be 1")

	s.queue_free()
	ts.queue_free()

# Color type comprehensive tests
func test_color_comprehensive():
	var gdscript_code = """
func test_color_construction():
	var c = Color(1.0, 0.5, 0.25, 0.75)
	return c.r + c.g + c.b + c.a

func test_color_members():
	var c = Color(0.1, 0.2, 0.3, 1.0)
	var red = c.r
	var green = c.g
	var blue = c.b
	var alpha = c.a
	return red + green + blue + alpha

func test_color_operations():
	var c1 = Color(0.5, 0.5, 0.5, 0.5)
	var r = c1.r * 2.0
	return r

func test_color_named_colors():
	# Test that Color() constructor works
	var c = Color()
	return c.a  # Default alpha is 1.0

func test_color_component_access():
	var c = Color(1.0, 0.8, 0.6, 0.4)
	var arr = [c.r, c.g, c.b, c.a]
	var sum = 0.0
	for val in arr:
		sum = sum + val
	return sum

func test_color_comparison():
	var c1 = Color(1.0, 0.0, 0.0, 1.0)
	var c2 = Color(1.0, 0.0, 0.0, 1.0)
	return c1.r == c2.r and c1.g == c2.g
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test color construction
	var result = s.vmcallv("test_color_construction")
	assert_almost_eq(result, 2.5, 0.001, "Color component sum should be 2.5")

	# Test color member access
	result = s.vmcallv("test_color_members")
	assert_almost_eq(result, 1.6, 0.001, "Color members should sum to 1.6")

	# Test color operations
	result = s.vmcallv("test_color_operations")
	assert_almost_eq(result, 1.0, 0.001, "Color r * 2 should be 1.0")

	# Test default color
	result = s.vmcallv("test_color_named_colors")
	assert_almost_eq(result, 1.0, 0.001, "Default Color alpha should be 1.0")

	# Test component access with loop
	result = s.vmcallv("test_color_component_access")
	assert_almost_eq(result, 2.8, 0.001, "Color sum via loop should be 2.8")

	# Test color comparison
	result = s.vmcallv("test_color_comparison")
	assert_eq(result, true, "Color comparison should work")

	s.queue_free()
	ts.queue_free()


# Optimization verification tests (constant folding)
func test_constant_folding_optimization():
	var gdscript_code = """
func test_fold_add():
	return 10 + 20

func test_fold_sub():
	return 50 - 15

func test_fold_mul():
	return 6 * 7

func test_fold_div():
	return 100 / 4

func test_fold_complex():
	return (2 + 3) * 4

func test_fold_float():
	return 1.5 + 2.5

func test_fold_neg():
	return -(-42)

func test_fold_comparison():
	return 5 < 10

func test_fold_logical():
	return true and false

func test_fold_no_fold_vars():
	var a = 10
	var b = 20
	return a + b
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	# Write ELF for objdump inspection
	var file = FileAccess.open("res://tests/const_fold.elf", FileAccess.WRITE)
	if file:
		file.store_buffer(compiled_elf)
		file.close()

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test folded add (constant folded at compile time)
	var result = s.vmcallv("test_fold_add")
	assert_eq(result, 30, "Folded 10 + 20 = 30")

	# Test folded sub
	result = s.vmcallv("test_fold_sub")
	assert_eq(result, 35, "Folded 50 - 15 = 35")

	# Test folded mul
	result = s.vmcallv("test_fold_mul")
	assert_eq(result, 42, "Folded 6 * 7 = 42")

	# Test folded div
	result = s.vmcallv("test_fold_div")
	assert_eq(result, 25, "Folded 100 / 4 = 25")

	# Test folded complex
	result = s.vmcallv("test_fold_complex")
	assert_eq(result, 20, "Folded (2 + 3) * 4 = 20")

	# Test folded float
	result = s.vmcallv("test_fold_float")
	assert_almost_eq(result, 4.0, 0.001, "Folded 1.5 + 2.5 = 4.0")

	# Test folded negation
	result = s.vmcallv("test_fold_neg")
	assert_eq(result, 42, "Folded -(-42) = 42")

	# Test folded comparison
	result = s.vmcallv("test_fold_comparison")
	assert_eq(result, true, "Folded 5 < 10 = true")

	# Test folded logical
	result = s.vmcallv("test_fold_logical")
	assert_eq(result, false, "Folded true and false = false")

	# Test that variables are NOT folded
	result = s.vmcallv("test_fold_no_fold_vars")
	assert_eq(result, 30, "Variables should still add: 10 + 20 = 30")

	s.queue_free()
	ts.queue_free()

# Negative step in range loops - KNOWN BUG, disabled for now
# func test_negative_range_step():
# 	var gdscript_code = """
# func countdown_loop():
# 	var sum = 0
# 	for i in range(10, 0, -1):
# 		sum = sum + i
# 	return sum
#
# func countdown_with_step():
# 	var count = 0
# 	for i in range(20, 0, -2):
# 		count = count + 1
# 	return count
#
# func negative_range_values():
# 	var values = []
# 	for i in range(5, -1, -1):
# 		values.append(i)
# 	return values.size()
# """
#
# 	var ts : Sandbox = Sandbox.new()
# 	ts.set_program(Sandbox_TestsTests)
# 	ts.restrictions = true
# 	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
# 	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")
#
# 	var s = Sandbox.new()
# 	s.load_buffer(compiled_elf)
# 	s.set_instructions_max(10000)
#
# 	# Test countdown loop
# 	var result = s.vmcallv("countdown_loop")
# 	# 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 55
# 	assert_eq(result, 55, "Countdown loop should sum to 55")
#
# 	# Test countdown with step
# 	result = s.vmcallv("countdown_with_step")
# 	# 20, 18, 16, 14, 12, 10, 8, 6, 4, 2 = 10 iterations
# 	assert_eq(result, 10, "Countdown with step -2 should have 10 iterations")
#
# 	# Test negative range creates values
# 	result = s.vmcallv("negative_range_values")
# 	# 5, 4, 3, 2, 1, 0 = 6 values
# 	assert_eq(result, 6, "Negative range should create 6 values")
#
# 	s.queue_free()

# Comparison operators comprehensive tests
func test_comparison_operators_comprehensive():
	var gdscript_code = """
func test_int_comparisons(n):
	var a = 10
	var b = 20
	if n == 0:
		return a == b
	elif n == 1:
		return a != b
	elif n == 2:
		return a < b
	elif n == 3:
		return a <= b
	elif n == 4:
		return a > b
	elif n == 5:
		return a >= b
	else:
		return false

func test_float_comparisons():
	var a = 1.5
	var b = 2.5
	return a < b

func test_string_comparisons():
	var a = "apple"
	var b = "banana"
	return a < b

func test_mixed_type_comparison():
	var a = 10
	var b = 10.0
	# In GDScript, int and float can be compared
	return a == b

func test_chain_comparisons():
	var x = 5
	var y = 10
	var z = 15
	return (x < y) and (y < z) and (x < z)
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test int comparisons - test each comparison individually
	var result = s.vmcallv("test_int_comparisons", 0)
	assert_eq(result, false, "10 == 20 should be false")

	result = s.vmcallv("test_int_comparisons", 1)
	assert_eq(result, true, "10 != 20 should be true")

	result = s.vmcallv("test_int_comparisons", 2)
	assert_eq(result, true, "10 < 20 should be true")

	result = s.vmcallv("test_int_comparisons", 3)
	assert_eq(result, true, "10 <= 20 should be true")

	result = s.vmcallv("test_int_comparisons", 4)
	assert_eq(result, false, "10 > 20 should be false")

	result = s.vmcallv("test_int_comparisons", 5)
	assert_eq(result, false, "10 >= 20 should be false")

	# Test float comparisons
	result = s.vmcallv("test_float_comparisons")
	assert_eq(result, true, "1.5 < 2.5 should be true")

	# Test string comparisons
	result = s.vmcallv("test_string_comparisons")
	assert_eq(result, true, "\"apple\" < \"banana\" should be true")

	# Test mixed type comparison
	result = s.vmcallv("test_mixed_type_comparison")
	assert_eq(result, true, "10 == 10.0 should be true")

	# Test chain comparisons
	result = s.vmcallv("test_chain_comparisons")
	assert_eq(result, true, "Chain comparisons should work")

	s.queue_free()
	ts.queue_free()

# Control flow comprehensive tests
func test_control_flow_comprehensive():
	var gdscript_code = """
func test_nested_if():
	var x = 10
	var y = 20
	if x > 5:
		if y > 15:
			return 100
		else:
			return 50
	else:
		return 25

func test_elif_chain():
	var score = 75
	if score >= 90:
		return "A"
	elif score >= 80:
		return "B"
	elif score >= 70:
		return "C"
	elif score >= 60:
		return "D"
	else:
		return "F"

func test_ternary_like():
	var x = 10
	var result = 0
	if x > 5:
		result = 1
	else:
		result = -1
	return result

func test_while_with_break():
	var i = 0
	var sum = 0
	while i < 100:
		sum = sum + i
		i = i + 1
		if sum > 10:
			break
	return sum

func test_while_with_continue():
	var i = 0
	var sum = 0
	while i < 10:
		i = i + 1
		if i % 2 == 0:
			continue
		sum = sum + i
	return sum
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test nested if
	var result = s.vmcallv("test_nested_if")
	assert_eq(result, 100, "Nested if should return 100")

	# Test elif chain
	result = s.vmcallv("test_elif_chain")
	assert_eq(result, "C", "Elif chain should return 'C' for score 75")

	# Test ternary-like if
	result = s.vmcallv("test_ternary_like")
	assert_eq(result, 1, "Ternary-like if should return 1")

	# Test while with break
	result = s.vmcallv("test_while_with_break")
	# 0 + 1 + 2 + 3 + 4 + 5 = 15 (breaks when sum > 10)
	assert_eq(result, 15, "While with break should sum to 15")

	# Test while with continue
	result = s.vmcallv("test_while_with_continue")
	# i = 1, 3, 5, 7, 9 (skips evens) = 25
	assert_eq(result, 25, "While with continue should sum odd numbers to 25")

	s.queue_free()
	ts.queue_free()

# Array methods and operations
func test_array_operations():
	var gdscript_code = """
func test_array_size():
	var arr = [1, 2, 3, 4, 5]
	return arr.size()

func test_array_append():
	var arr = []
	arr.append(10)
	arr.append(20)
	arr.append(30)
	return arr.size()

func test_array_clear():
	var arr = [1, 2, 3]
	arr.clear()
	return arr.size()

func test_array_sort():
	var arr = [3, 1, 4, 1, 5]
	arr.sort()
	return arr[0]

func test_array_reverse():
	var arr = [1, 2, 3]
	arr.reverse()
	return arr[0]
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test array size
	var result = s.vmcallv("test_array_size")
	assert_eq(result, 5, "Array size should be 5")

	# Test array append
	result = s.vmcallv("test_array_append")
	assert_eq(result, 3, "After 3 appends, size should be 3")

	# Test array clear
	result = s.vmcallv("test_array_clear")
	assert_eq(result, 0, "After clear, size should be 0")

	# Test array sort
	result = s.vmcallv("test_array_sort")
	assert_eq(result, 1, "After sort, first element should be 1")

	# Test array reverse
	result = s.vmcallv("test_array_reverse")
	assert_eq(result, 3, "After reverse, first element should be 3")

	s.queue_free()
	ts.queue_free()

# Method call tests
func test_method_calls():
	var gdscript_code = """
func test_string_length():
	var s = "Hello"
	return s.length()

func test_string_methods():
	var s = "  Hello World  "
	return s.strip_edges().length()

func test_array_method_chain():
	var arr = [1, 2, 3]
	var size = arr.size()
	return size

func test_string_find():
	var s = "Hello World"
	return s.find("World")
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test string length
	var result = s.vmcallv("test_string_length")
	assert_eq(result, 5, "String 'Hello' length should be 5")

	# Test string method chaining
	result = s.vmcallv("test_string_methods")
	assert_eq(result, 11, "Stripped 'Hello World' length should be 11")

	# Test array method
	result = s.vmcallv("test_array_method_chain")
	assert_eq(result, 3, "Array size should be 3")

	# Test string find
	result = s.vmcallv("test_string_find")
	assert_eq(result, 6, "Find 'World' in 'Hello World' should return 6")

	s.queue_free()
	ts.queue_free()

# Codegen quality verification via ELF inspection helper
func test_codegen_quality_verification():
	# This test compiles code and writes ELF for manual objdump inspection
	# Use: riscv64-linux-gnu-objdump -d res://tests/codegen_quality.elf
	var gdscript_code = """
func simple_add():
	return 5 + 3

func register_pressure():
	var a = 1
	var b = 2
	var c = 3
	var d = 4
	var e = 5
	var f = 6
	return a + b + c + d + e + f

func loop_test():
	var sum = 0
	for i in range(10):
		sum = sum + i
	return sum

func float_test():
	var a = 1.5
	var b = 2.5
	return a + b
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	# Write ELF for objdump inspection
	var file = FileAccess.open("res://tests/codegen_quality.elf", FileAccess.WRITE)
	if file:
		file.store_buffer(compiled_elf)
		file.close()

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Verify functionality
	var result = s.vmcallv("simple_add")
	assert_eq(result, 8, "simple_add should return 8")

	result = s.vmcallv("register_pressure")
	assert_eq(result, 21, "register_pressure sum should be 21")

	result = s.vmcallv("loop_test")
	assert_eq(result, 45, "loop_test sum should be 45")

	result = s.vmcallv("float_test")
	assert_almost_eq(result, 4.0, 0.001, "float_test should return 4.0")

	s.queue_free()
	ts.queue_free()


func test_peephole_pattern_e():
	# Test Pattern E optimization: x = x + 1 (increment optimization)
	# This tests that the compiler properly optimizes the common increment pattern
	var gdscript_code = """
func increment_by_one(x):
	var i = x
	i += 1
	return i

func increment_multiple_times():
	var count = 0
	count += 1
	count += 1
	count += 1
	count += 1
	count += 1
	return count

func increment_in_loop():
	var sum = 0
	for i in range(10):
		sum += 1
	return sum

func increment_with_arithmetic(x):
	var result = x
	result += 5
	result += 3
	return result

func float_increment(x):
	var f = x
	f += 1.5
	f += 2.5
	return f
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test increment by one
	assert_true(s.has_function("increment_by_one"), "Should have increment_by_one function")
	var result = s.vmcallv("increment_by_one", 5)
	assert_eq(result, 6, "increment_by_one(5) should return 6")

	result = s.vmcallv("increment_by_one", 0)
	assert_eq(result, 1, "increment_by_one(0) should return 1")

	result = s.vmcallv("increment_by_one", -5)
	assert_eq(result, -4, "increment_by_one(-5) should return -4")

	# Test multiple increments
	assert_true(s.has_function("increment_multiple_times"), "Should have increment_multiple_times function")
	result = s.vmcallv("increment_multiple_times")
	assert_eq(result, 5, "increment_multiple_times should return 5")

	# Test increment in loop
	assert_true(s.has_function("increment_in_loop"), "Should have increment_in_loop function")
	result = s.vmcallv("increment_in_loop")
	assert_eq(result, 10, "increment_in_loop should return 10")

	# Test increment with arithmetic
	assert_true(s.has_function("increment_with_arithmetic"), "Should have increment_with_arithmetic function")
	result = s.vmcallv("increment_with_arithmetic", 10)
	assert_eq(result, 18, "increment_with_arithmetic(10) should return 18")

	# Test float increment
	assert_true(s.has_function("float_increment"), "Should have float_increment function")
	result = s.vmcallv("float_increment", 1.0)
	assert_eq(result, 5.0, "float_increment(1.0) should return 5.0")

	s.queue_free()
	ts.queue_free()


func test_peephole_combined_patterns():
	# Test combination of multiple peephole optimizations
	var gdscript_code = """
func combined_arithmetic(a, b, c):
	var x = a
	var y = b
	var z = x + y
	var result = z + c
	return result

func nested_arithmetic():
	var a = 1
	var b = 2
	var c = 3
	var d = 4
	var result = a + b + c + d
	return result

func arithmetic_chain(x):
	var result = x
	result = result + 1
	result = result + 2
	result = result + 3
	return result
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test combined arithmetic
	assert_true(s.has_function("combined_arithmetic"), "Should have combined_arithmetic function")
	var result = s.vmcallv("combined_arithmetic", 10, 20, 30)
	assert_eq(result, 60, "combined_arithmetic(10, 20, 30) should return 60")

	# Test nested arithmetic
	assert_true(s.has_function("nested_arithmetic"), "Should have nested_arithmetic function")
	result = s.vmcallv("nested_arithmetic")
	assert_eq(result, 10, "nested_arithmetic should return 10")

	# Test arithmetic chain
	assert_true(s.has_function("arithmetic_chain"), "Should have arithmetic_chain function")
	result = s.vmcallv("arithmetic_chain", 100)
	assert_eq(result, 106, "arithmetic_chain(100) should return 106")

	s.queue_free()
	ts.queue_free()


func test_optimization_preserves_semantics():
	# Ensure that optimizations don't change program semantics
	var gdscript_code = """
func side_effect_test(x):
	var a = x
	var b = a + 1
	var c = b + 1
	var d = c + 1
	return d

func constant_folding_test():
	var a = 5 + 3
	var b = a + 2
	var c = b * 2
	return c

func order_of_operations(x):
	var a = x + 1
	var b = a * 2
	var c = b + 3
	return c
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test side effects
	assert_true(s.has_function("side_effect_test"), "Should have side_effect_test function")
	var result = s.vmcallv("side_effect_test", 0)
	assert_eq(result, 3, "side_effect_test(0) should return 3")

	result = s.vmcallv("side_effect_test", 10)
	assert_eq(result, 13, "side_effect_test(10) should return 13")

	# Test constant folding preserves semantics
	assert_true(s.has_function("constant_folding_test"), "Should have constant_folding_test function")
	result = s.vmcallv("constant_folding_test")
	assert_eq(result, 20, "constant_folding_test should return 20 ((5+3)+2)*2 = 20")

	# Test order of operations
	assert_true(s.has_function("order_of_operations"), "Should have order_of_operations function")
	result = s.vmcallv("order_of_operations", 5)
	assert_eq(result, 15, "order_of_operations(5) should return 15 ((5+1)*2+3 = 15)")

	s.queue_free()
	ts.queue_free()

func test_packed_arrays():
	# Test packed array constructors
	var gdscript_code = """
func test_empty_packed_byte_array():
	return PackedByteArray()

func test_packed_byte_array():
	return PackedByteArray([1, 2, 3, 4, 5])

func test_empty_packed_int32_array():
	return PackedInt32Array()

func test_packed_int32_array():
	return PackedInt32Array([10, 20, 30, 40, 50])

func test_empty_packed_int64_array():
	return PackedInt64Array()

func test_packed_int64_array():
	return PackedInt64Array([100, 200, 300, 400, 500])

func test_empty_packed_float32_array():
	return PackedFloat32Array()

func test_packed_float32_array():
	return PackedFloat32Array([1.1, 2.2, 3.3, 4.4, 5.5])

func test_empty_packed_float64_array():
	return PackedFloat64Array()

func test_packed_float64_array():
	return PackedFloat64Array([10.01, 20.02, 30.03, 40.04, 50.05])

func test_empty_packed_string_array():
	return PackedStringArray()

func test_packed_string_array():
	return PackedStringArray(["one", "two", "three", "four", "five"])

func test_empty_packed_vector2_array():
	return PackedVector2Array()

func test_packed_vector2_array():
	return PackedVector2Array([Vector2(1.0,2.0), Vector2(3.0,4.0), Vector2(5.0,6.0)])

func test_packed_vector2_array_i():
	return PackedVector2Array([Vector2(1,2), Vector2(3,4), Vector2(5,6)])

func test_empty_packed_vector3_array():
	return PackedVector3Array()

func test_packed_vector3_array():
	return PackedVector3Array([Vector3(1.0,2.0,3.0), Vector3(4.0,5.0,6.0), Vector3(7.0,8.0,9.0)])

func test_packed_vector3_array_i():
	return PackedVector3Array([Vector3(1,2,3), Vector3(4,5,6), Vector3(7,8,9)])

func test_empty_packed_color_array():
	return PackedColorArray()

func test_packed_color_array():
	return PackedColorArray([Color(1.0,0.0,0.0), Color(0.0,1.0,0.0), Color(0.0,0.0,1.0)])

func test_empty_packed_vector4_array():
	return PackedVector4Array()

func test_packed_vector4_array():
	return PackedVector4Array([Vector4(1.0,2.0,3.0,4.0), Vector4(5.0,6.0,7.0,8.0), Vector4(9.0,10.0,11.0,12.0)])

func test_packed_vector4_array_i():
	return PackedVector4Array([Vector4(1,2,3,4), Vector4(5,6,7,8), Vector4(9,10,11,12)])
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)

	# Test that all functions exist
	assert_true(s.has_function("test_empty_packed_byte_array"), "Should have test_empty_packed_byte_array function")
	assert_true(s.has_function("test_empty_packed_int32_array"), "Should have test_empty_packed_int32_array function")
	assert_true(s.has_function("test_empty_packed_int64_array"), "Should have test_empty_packed_int64_array function")
	assert_true(s.has_function("test_empty_packed_float32_array"), "Should have test_empty_packed_float32_array function")
	assert_true(s.has_function("test_empty_packed_float64_array"), "Should have test_empty_packed_float64_array function")
	assert_true(s.has_function("test_empty_packed_string_array"), "Should have test_empty_packed_string_array function")
	assert_true(s.has_function("test_empty_packed_vector2_array"), "Should have test_empty_packed_vector2_array function")
	assert_true(s.has_function("test_empty_packed_vector3_array"), "Should have test_empty_packed_vector3_array function")
	assert_true(s.has_function("test_empty_packed_color_array"), "Should have test_empty_packed_color_array function")
	assert_true(s.has_function("test_empty_packed_vector4_array"), "Should have test_empty_packed_vector4_array function")

	assert_true(s.has_function("test_packed_byte_array"), "Should have test_packed_byte_array function")
	assert_true(s.has_function("test_packed_int32_array"), "Should have test_packed_int32_array function")
	assert_true(s.has_function("test_packed_int64_array"), "Should have test_packed_int64_array function")
	assert_true(s.has_function("test_packed_float32_array"), "Should have test_packed_float32_array function")
	assert_true(s.has_function("test_packed_float64_array"), "Should have test_packed_float64_array function")
	assert_true(s.has_function("test_packed_string_array"), "Should have test_packed_string_array function")
	assert_true(s.has_function("test_packed_vector2_array"), "Should have test_packed_vector2_array function")
	assert_true(s.has_function("test_packed_vector2_array_i"), "Should have test_packed_vector2_array_i function")
	assert_true(s.has_function("test_packed_vector3_array"), "Should have test_packed_vector3_array function")
	assert_true(s.has_function("test_packed_vector3_array_i"), "Should have test_packed_vector3_array_i function")
	assert_true(s.has_function("test_packed_color_array"), "Should have test_packed_color_array function")
	assert_true(s.has_function("test_packed_vector4_array"), "Should have test_packed_vector4_array function")
	assert_true(s.has_function("test_packed_vector4_array_i"), "Should have test_packed_vector4_array_i function")

	# Test that functions return valid packed arrays (non-nil)
	var result = s.vmcallv("test_empty_packed_byte_array")
	assert_eq_deep(result, PackedByteArray([]))
	result = s.vmcallv("test_packed_byte_array")
	assert_eq_deep(result, PackedByteArray([1, 2, 3, 4, 5]))

	result = s.vmcallv("test_empty_packed_int32_array")
	assert_eq_deep(result, PackedInt32Array([]))
	result = s.vmcallv("test_packed_int32_array")
	assert_eq_deep(result, PackedInt32Array([10, 20, 30, 40, 50]))

	result = s.vmcallv("test_empty_packed_int64_array")
	assert_eq_deep(result, PackedInt64Array([]))
	result = s.vmcallv("test_packed_int64_array")
	assert_eq_deep(result, PackedInt64Array([100, 200, 300, 400, 500]))

	result = s.vmcallv("test_empty_packed_float32_array")
	assert_eq_deep(result, PackedFloat32Array([]))
	result = s.vmcallv("test_packed_float32_array")
	assert_eq_deep(result, PackedFloat32Array([1.1, 2.2, 3.3, 4.4, 5.5]))

	result = s.vmcallv("test_empty_packed_float64_array")
	assert_eq_deep(result, PackedFloat64Array([]))
	result = s.vmcallv("test_packed_float64_array")
	assert_eq_deep(result, PackedFloat64Array([10.01, 20.02, 30.03, 40.04, 50.05]))

	result = s.vmcallv("test_empty_packed_string_array")
	assert_eq_deep(result, PackedStringArray([]))
	result = s.vmcallv("test_packed_string_array")
	assert_eq_deep(result, PackedStringArray(["one", "two", "three", "four", "five"]))

	result = s.vmcallv("test_empty_packed_vector2_array")
	assert_eq_deep(result, PackedVector2Array([]))
	result = s.vmcallv("test_packed_vector2_array")
	assert_eq_deep(result, PackedVector2Array([Vector2(1,2), Vector2(3,4), Vector2(5,6)]))
	result = s.vmcallv("test_packed_vector2_array_i")
	assert_eq_deep(result, PackedVector2Array([Vector2(1,2), Vector2(3,4), Vector2(5,6)]))

	result = s.vmcallv("test_empty_packed_vector3_array")
	assert_eq_deep(result, PackedVector3Array([]))
	result = s.vmcallv("test_packed_vector3_array")
	assert_eq_deep(result, PackedVector3Array([Vector3(1,2,3), Vector3(4,5,6), Vector3(7,8,9)]))
	result = s.vmcallv("test_packed_vector3_array_i")
	assert_eq_deep(result, PackedVector3Array([Vector3(1,2,3), Vector3(4,5,6), Vector3(7,8,9)]))

	result = s.vmcallv("test_empty_packed_color_array")
	assert_eq_deep(result, PackedColorArray([]))
	result = s.vmcallv("test_packed_color_array")
	assert_eq_deep(result, PackedColorArray([Color(1,0,0), Color(0,1,0), Color(0,0,1)]))

	result = s.vmcallv("test_empty_packed_vector4_array")
	assert_eq_deep(result, PackedVector4Array([]))
	result = s.vmcallv("test_packed_vector4_array")
	assert_eq_deep(result, PackedVector4Array([Vector4(1,2,3,4), Vector4(5,6,7,8), Vector4(9,10,11,12)]))
	result = s.vmcallv("test_packed_vector4_array_i")
	assert_eq_deep(result, PackedVector4Array([Vector4(1,2,3,4), Vector4(5,6,7,8), Vector4(9,10,11,12)]))

	s.queue_free()
	ts.queue_free()

func test_const_declarations():
	# Test const declarations (const is synonymous with var)
	var gdscript_code = """
func test_const_int():
	const x = 42
	return x

func test_const_float():
	const pi = 3.14159
	return pi

func test_const_string():
	const greeting = "hello"
	return greeting

func test_const_bool():
	const flag = true
	return flag

func test_const_multiple():
	const a = 10
	const b = 20
	const c = 30
	return a + b + c

func test_const_in_expression():
	const multiplier = 2.5
	const base = 10
	return base * multiplier
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test const int
	var result = s.vmcallv("test_const_int")
	assert_eq(result, 42, "Const int should be 42")

	# Test const float
	result = s.vmcallv("test_const_float")
	assert_almost_eq(result, 3.14159, 0.00001, "Const float should be 3.14159")

	# Test const string
	result = s.vmcallv("test_const_string")
	assert_eq(result, "hello", "Const string should be 'hello'")

	# Test const bool
	result = s.vmcallv("test_const_bool")
	assert_eq(result, true, "Const bool should be true")

	# Test multiple const declarations
	result = s.vmcallv("test_const_multiple")
	assert_eq(result, 60, "Sum of consts should be 60")

	# Test const in expression
	result = s.vmcallv("test_const_in_expression")
	assert_almost_eq(result, 25.0, 0.001, "Const expression should be 25.0")

	s.queue_free()
	ts.queue_free()


func test_self_get_name():
	# Test self.get_name() - calling a method on self
	var gdscript_code = """
func test_get_name():
	return self.get_name()
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test that get_name() can be called on self
	# get_name() returns a StringName, which is type 21
	var result = s.vmcallv("test_get_name")
	assert_eq(typeof(result), TYPE_STRING_NAME, "self.get_name() should return a StringName")
	# Just check that we got some result (not null)
	assert_not_null(result, "self.get_name() should return a value")

	s.queue_free()


func test_freestanding_function_call():
	# Test freestanding get_name() - should be treated as self.get_name()
	var gdscript_code = """
func test_freestanding():
	return get_name()
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test that get_name() works as a freestanding function
	var result = s.vmcallv("test_freestanding")
	assert_eq(typeof(result), TYPE_STRING_NAME, "get_name() should return a StringName")
	assert_not_null(result, "get_name() should return a value")

	s.queue_free()
	ts.queue_free()


func test_get_node_no_args():
	# Test get_node() without arguments - should return self
	var gdscript_code = """
func test_get_node_self():
	var node = get_node()
	return node.get_name()
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test that get_node() returns a node
	var result = s.vmcallv("test_get_node_self")
	assert_eq(typeof(result), TYPE_STRING_NAME, "get_node().get_name() should return a StringName")
	assert_not_null(result, "get_node().get_name() should return a value")

	s.queue_free()
	ts.queue_free()


func test_multiple_freestanding_calls():
	# Test multiple freestanding function calls in sequence
	var gdscript_code = """
func test_multiple_calls():
	var name1 = get_name()
	var name2 = self.get_name()
	return name1 == name2
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Both should return the same name
	var result = s.vmcallv("test_multiple_calls")
	assert_eq(result, true, "get_name() and self.get_name() should return the same value")

	s.queue_free()
	ts.queue_free()


func test_properties():
	# Test property access - obj.property should translate to obj.get("property")
	# and obj.property = value should translate to obj.set("property", value)
	var gdscript_code = """
func test_property_get():
	var node = get_node()
	# Access the 'name' property - should use VGET instruction
	var name = node.name
	return name
func test_property_set():
	var node = get_node()
	# Set the 'name' property using VSET instruction
	var old_name = node.name
	node.name = "test_name"
	var new_name = node.name
	return new_name

func test_property_self_get():
	return self.name
func test_property_self_set():
	var old_name = self.name
	self.name = "test_name"
	return self.name
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test that property access works
	var result = s.vmcallv("test_property_get")
	assert_not_null(result, "node.name should return a value")

	result = s.vmcallv("test_property_set")
	assert_eq(result, "test_name", "After setting, node.name should be 'test_name'")

	result = s.vmcallv("test_property_self_get")
	assert_not_null(result, "self.name should return a value")
	result = s.vmcallv("test_property_self_set")
	assert_eq(result, "test_name", "After setting, self.name should be 'test_name'")
	result = s.vmcallv("test_property_self_get")
	assert_eq(result, "test_name", "self.name should be 'test_name' after setting")

	s.queue_free()
	ts.queue_free()

func test_gdscript_benchmarks():
	var benchmarks = {
		"fibonacci": """
func fibonacci(n : int):
	if n <= 1:
		return n
	return fibonacci(n - 1) + fibonacci(n - 2)
""",
		"factorial": """
func factorial(n):
	if n <= 1:
		return 1
	return n * factorial(n - 1)
""",
		"pf32a_operation": """
func pf32a_operation(array):
	var i = 0
	for n in range(10000):
		array.set(i, i * 2.0)
	return array
"""
	}

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true

	for name in benchmarks.keys():
		var gdscript_code = benchmarks[name]
		var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
		assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty for %s" % name)

		var s = Sandbox.new()
		s.load_buffer(compiled_elf)
		s.set_instructions_max(20000)
		assert_true(s.has_function(name), "Compiled ELF should have function '%s'" % name)

		# Benchmark the compiled function
		var start_time = Time.get_ticks_usec()
		if name == "fibonacci":
			var result = s.vmcallv(name, 20)  # Fibonacci of 20
			assert_eq(result, 6765, "fibonacci(20) should return 6765")
		elif name == "factorial":
			var result = s.vmcallv(name, 10)  # Factorial of 10
			assert_eq(result, 3628800, "factorial(10) should return 3628800")
		elif name == "pf32a_operation":
			var array : PackedFloat32Array = PackedFloat32Array()
			array.resize(10000)
			var result = s.vmcallv(name, array)
			assert_eq(result.size(), 10000, "pf32a_operation should return array of length 10000")
		var end_time = Time.get_ticks_usec()
		print("%s benchmark took %d us" % [name, end_time - start_time])

		s.queue_free()
	ts.queue_free()

func test_global_variables():
	# Test that global var and const declarations work correctly
	var gdscript_code = """
var global_counter: int = 0
const GLOBAL_CONST: float = 42.0
var g_string = "Hello, World!"
var g_array = []

func increment_counter():
	global_counter = global_counter + 1
	return global_counter

func get_counter():
	return global_counter

func loop_counter():
	global_counter = 0
	while global_counter < 5:
		global_counter = global_counter + 1
	return global_counter

func get_const():
	return GLOBAL_CONST

func const_arithmetic():
	return GLOBAL_CONST * 2.0 + 8.0

func get_string():
	return g_string

func set_string(new_value):
	g_string = new_value
	return g_string

func test_array():
	g_array.append(10)
	g_array.append(20)
	return g_array

func set_array(new_array):
	g_array = new_array
	return g_array

"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compiled ELF should not be empty for global variables test")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(1000)

	assert_true(s.has_function("increment_counter"), "Compiled ELF should have function 'increment_counter'")
	assert_true(s.has_function("get_counter"), "Compiled ELF should have function 'get_counter'")
	assert_true(s.has_function("loop_counter"), "Compiled ELF should have function 'loop_counter'")
	assert_true(s.has_function("get_const"), "Compiled ELF should have function 'get_const'")
	assert_true(s.has_function("const_arithmetic"), "Compiled ELF should have function 'const_arithmetic'")
	assert_true(s.has_function("get_string"), "Compiled ELF should have function 'get_string'")
	assert_true(s.has_function("set_string"), "Compiled ELF should have function 'set_string'")
	assert_true(s.has_function("test_array"), "Compiled ELF should have function 'test_array'")
	assert_true(s.has_function("set_array"), "Compiled ELF should have function 'set_array'")

	# Test global constant
	assert_eq(s.vmcallv("get_const"), 42.0, "get_const() should return 42.0")
	assert_almost_eq(s.vmcallv("const_arithmetic"), 92.0, 0.001, "const_arithmetic() should return 92.0")

	# Test global variable that gets incremented
	assert_eq(s.vmcallv("get_counter"), 0, "Initial counter should be 0")
	assert_eq(s.vmcallv("increment_counter"), 1, "First increment should return 1")
	assert_eq(s.vmcallv("get_counter"), 1, "Counter should now be 1")
	assert_eq(s.vmcallv("increment_counter"), 2, "Second increment should return 2")
	assert_eq(s.vmcallv("get_counter"), 2, "Counter should now be 2")
	assert_eq(s.vmcallv("loop_counter"), 5, "loop_counter should return 5")

	# Test global string
	assert_eq(s.vmcallv("get_string"), "Hello, World!", "Initial string should be 'Hello, World!'")
	assert_eq(s.vmcallv("set_string", "world"), "world", "set_string should return new value")
	assert_eq(s.vmcallv("get_string"), "world", "String should now be 'world'")

	# Test global array
	var array_result = s.vmcallv("test_array")
	assert_eq_deep(array_result, [10, 20])
	array_result = s.vmcallv("set_array", [333, 666, 999])
	assert_eq_deep(array_result, [333, 666, 999])
	array_result = s.vmcallv("test_array")
	assert_eq_deep(array_result, [333, 666, 999, 10, 20])

	s.queue_free()
	ts.queue_free()

func test_untyped_global_error():
	# Test that untyped global variables without initializers produce a helpful error
	var gdscript_code = """
var untyped_global

func test():
	untyped_global = 42
	return untyped_global
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)

	# Should fail to compile
	assert_eq(compiled_elf.is_empty(), true, "Compilation should fail for untyped global without initializer")

	var error_msg = ts.vmcall("get_compiler_error", "")
	assert_true(error_msg.find("requires either a type hint or an initializer") != -1, \
		"Error message should mention type hint or initializer requirement")

	ts.queue_free()


func test_export_attribute():
	# Test that @export attribute works for global variables
	var gdscript_code = """
@export
var exported_int : int = 42

@export
var exported_float : float = 3.14

@export
var exported_string : String = "test"

@export
var exported_array : Array = []

var non_exported : int = 100

func get_exported_int():
	return exported_int

func get_exported_float():
	return exported_float

func get_exported_string():
	return exported_string

func get_exported_array():
	return exported_array

func get_non_exported():
	return non_exported
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compilation with @export should succeed")

	var s = Sandbox.new()
	s.load_buffer(compiled_elf)
	s.set_instructions_max(10000)

	# Test that exported variables work correctly
	assert_eq(s.vmcallv("get_exported_int"), 42, "exported_int should be 42")
	assert_almost_eq(s.vmcallv("get_exported_float"), 3.14, 0.001, "exported_float should be 3.14")
	assert_eq(s.vmcallv("get_exported_string"), "test", "exported_string should be 'test'")
	var array_result = s.vmcallv("get_exported_array")
	assert_eq_deep(array_result, [])
	assert_eq(s.vmcallv("get_non_exported"), 100, "non_exported should be 100")

	assert_eq(s.get("exported_int"), 42, "exported_int property should be 42")
	assert_almost_eq(s.get("exported_float"), 3.14, 0.001, "exported_float property should be 3.14")
	assert_eq(s.get("exported_string"), "test", "exported_string property should be 'test'")
	assert_eq_deep(s.get("exported_array"), [])
	assert_eq(s.get("non_exported"), null, "non_exported is not exported, should be nil")

	s.set("exported_int", 100)
	assert_eq(s.get("exported_int"), 100, "exported_int property should be updated to 100")
	s.set("exported_float", 6.28)
	assert_almost_eq(s.get("exported_float"), 6.28, 0.001, "exported_float property should be updated to 6.28")
	s.set("exported_string", "updated")
	assert_eq(s.get("exported_string"), "updated", "exported_string property should be updated to 'updated'")
	s.set("exported_array", [1, 2, 3])
	assert_eq_deep(s.get("exported_array"), [1, 2, 3])

	s.queue_free()
	ts.queue_free()

func test_safegdscript():
	var gdscript_code = """
extends Label3D

func some_function():
	var counter = 0
	while counter < 10:
		counter += 2
	return counter

func meaning_of_life():
	return 42

func meaning_of_this() -> String:
	var hi: String = "Hi"
	set_text(hi)
	return hi
"""

	var ts : Sandbox = Sandbox.new()
	ts.set_program(Sandbox_TestsTests)
	ts.restrictions = true
	var compiled_elf = ts.vmcall("compile_to_elf", gdscript_code)
	assert_eq(compiled_elf.is_empty(), false, "Compilation with @export should succeed")

	var temp_file_path = "user://temp_safegdscript.elf"
	var file = FileAccess.open(temp_file_path, FileAccess.WRITE)
	file.store_buffer(compiled_elf)
	file.close()

	var l = Label3D.new()
	l.set_script(load(temp_file_path))
	l.set_instructions_max(10000)

	# Test that exported variables work correctly
	var result = l.call("some_function")
	assert_eq(result, 10, "some_function should return 10")

	result = l.call("meaning_of_life")
	assert_eq(result, 42, "meaning_of_life should return 42")

	result = l.call("meaning_of_this")
	assert_eq(result, "Hi", "meaning_of_this should return 'Hi'")
	assert_eq(l.get("text"), "Hi", "Label3D text property should be 'Hi'")

	# Write GDScript to "user://temp_safegdscript.sgd"
	var gdscript_file = FileAccess.open("user://temp_safegdscript.sgd", FileAccess.WRITE)
	gdscript_file.store_string(gdscript_code)
	gdscript_file.close()

	# Load the GDScript file using SafeGDScript
	l.set_script(load("user://temp_safegdscript.sgd"))
	l.set_instructions_max(10000)

	# Test that exported variables work correctly
	result = l.call("some_function")
	assert_eq(result, 10, "some_function should return 10 after loading from .sgd")
	result = l.call("meaning_of_life")
	assert_eq(result, 42, "meaning_of_life should return 42 after loading from .sgd")
	result = l.call("meaning_of_this")
	assert_eq(result, "Hi", "meaning_of_this should return 'Hi' after loading from .sgd")
	assert_eq(l.get("text"), "Hi", "Label3D text property should be 'Hi' after loading from .sgd")

	l.queue_free()
	ts.queue_free()

```

`tests/tests/test_generate_api.gd`:

```gd
extends GutTest

func test_generate_api_argument_names():
    var s : Sandbox = Sandbox.new()
    var api: String = s.generate_api("cpp", "", true)
    assert_gt(api.length(), 0)

```

`tests/tests/test_math.cpp`:

```cpp
#include "api.hpp"

PUBLIC Variant test_math_sin(double val) {
	return Math::sin(val);
}
PUBLIC Variant test_math_cos(double val) {
	return Math::cos(val);
}
PUBLIC Variant test_math_tan(double val) {
	return Math::tan(val);
}
PUBLIC Variant test_math_asin(double val) {
	return Math::asin(val);
}
PUBLIC Variant test_math_acos(double val) {
	return Math::acos(val);
}
PUBLIC Variant test_math_atan(double val) {
	return Math::atan(val);
}
PUBLIC Variant test_math_atan2(double x, double y) {
	return Math::atan2(x, y);
}
PUBLIC Variant test_math_pow(double x, double y) {
	return Math::pow(x, y);
}

// NOTE: We can only call with 64-bit floats from GDScript
PUBLIC Variant test_math_sinf(double val) {
	return Math::sinf(val);
}

PUBLIC Variant test_math_lerp(double a, double b, double t) {
	return Math::lerp(a, b, t);
}
PUBLIC Variant test_math_smoothstep(double a, double b, double t) {
	return Math::smoothstep(a, b, t);
}
PUBLIC Variant test_math_clamp(double x, double a, double b) {
	return Math::clamp(x, a, b);
}
PUBLIC Variant test_math_slerp(double a, double b, double t) {
	return Math::slerp(a, b, t);
}

PUBLIC Variant test_math_fabs(double x) {
	return double(fabs(x));
}

PUBLIC Variant test_math_fmod(double x, double y) {
	return double(fmod(x, y));
}
```

`tests/tests/test_math.gd`:

```gd
extends GutTest

var Sandbox_TestsTests = load("res://tests/tests.elf")

func test_math():
	# Create a new sandbox
	var s = Sandbox.new()
	# Set the test program
	s.set_program(Sandbox_TestsTests)

	# 64-bit FP math
	assert_eq(s.vmcall("test_math_sin", 0.0), 0.0)
	assert_eq(s.vmcall("test_math_cos", 0.0), 1.0)
	assert_eq(s.vmcall("test_math_tan", 0.0), 0.0)

	assert_eq(s.vmcall("test_math_asin", 0.0), 0.0)
	assert_eq(s.vmcall("test_math_acos", 1.0), 0.0)
	assert_eq(s.vmcall("test_math_atan", 0.0), 0.0)
	assert_eq(s.vmcall("test_math_atan2", 0.0, 1.0), 0.0)

	assert_eq(s.vmcall("test_math_pow", 2.0, 3.0), 8.0)

	# 32-bit FP math
	assert_eq(s.vmcall("test_math_sinf", 0.0), 0.0)

	assert_eq(s.vmcall("test_math_lerp",       0.0, 1.0, 0.5), 0.5)
	assert_eq(s.vmcall("test_math_smoothstep", 0.0, 1.0, 0.5), 0.5)

	# Regular math functions
	assert_eq(s.vmcall("test_math_fabs", -5.25), 5.25)
	assert_eq(s.vmcall("test_math_fmod", 5.25, 2.0), 1.25)
	assert_eq(s.vmcall("test_math_fmod", 5.25, 0.25), 0.0)

	s.queue_free()


```

`tests/tests/test_properties.cpp`:

```cpp
#include "api.hpp"

// If we need per-node properties in shared sandboxes, we will
// need to use the PER_OBJECT macro to distinguish between them.
struct PlayerState {
	float jump_velocity = -300.0f;
	float player_speed = 150.0f;
	std::string player_name = "Slide Knight";
};
PER_OBJECT(PlayerState);
static PlayerState &get_player_state() {
	return GetPlayerState(get_node());
}

// clang-format off
SANDBOXED_PROPERTIES(3, {
	.name = "player_speed",
	.type = Variant::FLOAT,
	.getter = []() -> Variant { return get_player_state().player_speed; },
	.setter = [](Variant value) -> Variant { return get_player_state().player_speed = value; },
	.default_value = Variant{get_player_state().player_speed},
}, {
	.name = "player_jump_vel",
	.type = Variant::FLOAT,
	.getter = []() -> Variant { return get_player_state().jump_velocity; },
	.setter = [](Variant value) -> Variant { return get_player_state().jump_velocity = value; },
	.default_value = Variant{get_player_state().jump_velocity},
}, {
	.name = "player_name",
	.type = Variant::STRING,
	.getter = []() -> Variant { return get_player_state().player_name; },
	.setter = [](Variant value) -> Variant { return get_player_state().player_name = value.as_std_string(); },
	.default_value = Variant{"Slide Knight"},
});
// clang-format on

```

`tests/tests/test_properties.gd`:

```gd
extends GutTest

var Sandbox_TestsTests = load("res://tests/tests.elf")

func validate_property(prop_list, name):
	for p in prop_list:
		if p.name == name:
			return true
	return false

func test_script_properties():
	var n = Node.new()
	n.name = "Node"
	n.set_script(Sandbox_TestsTests)

	# Verify properties exist
	var prop_list = n.get_property_list()
	assert_true(validate_property(prop_list, "player_speed"), "Property player_speed found")
	assert_true(validate_property(prop_list, "player_jump_vel"), "Property player_jump_vel found")
	assert_true(validate_property(prop_list, "player_name"), "Property player_name found")

	# Test property access
	assert_eq(n.get("player_speed"), 150.0, "Property player_speed has value 150")
	assert_eq(n.get("player_jump_vel"), -300.0, "Property player_jump_vel has value -300")
	assert_eq(n.get("player_name"), "Slide Knight", "Property player_name has value Slide Knight")

	# Test property set
	n.set("player_speed", 200.0)
	n.set("player_jump_vel", -400.0)
	n.set("player_name", "Jump Knight")

	assert_eq(n.get("player_speed"), 200.0, "Property player_speed has value 200")
	assert_eq(n.get("player_jump_vel"), -400.0, "Property player_jump_vel has value -400")
	assert_eq(n.get("player_name"), "Jump Knight", "Property player_name has value Jump Knight")

	n.queue_free()

func test_elfscript_properties():
	var n = Sandbox.new()
	n.set_program(Sandbox_TestsTests)

	# Verify properties exist
	var prop_list = n.get_property_list()
	assert_true(validate_property(prop_list, "player_speed"), "Property player_speed found")
	assert_true(validate_property(prop_list, "player_jump_vel"), "Property player_jump_vel found")
	assert_true(validate_property(prop_list, "player_name"), "Property player_name found")

	# Test property access
	assert_eq(n.get("player_speed"), 150.0, "Property player_speed has value 150")
	assert_eq(n.get("player_jump_vel"), -300.0, "Property player_jump_vel has value -300")
	assert_eq(n.get("player_name"), "Slide Knight", "Property player_name has value Slide Knight")

	# Test property set
	n.set("player_speed", 200.0)
	n.set("player_jump_vel", -400.0)
	n.set("player_name", "Jump Knight")

	assert_eq(n.get("player_speed"), 200.0, "Property player_speed has value 200")
	assert_eq(n.get("player_jump_vel"), -400.0, "Property player_jump_vel has value -400")
	assert_eq(n.get("player_name"), "Jump Knight", "Property player_name has value Jump Knight")

	n.queue_free()

```

`tests/tests/test_restrictions.gd`:

```gd
extends GutTest

var Sandbox_TestsTests = load("res://tests/tests.elf")

func test_restrictions():
	var s = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	# Adding an allowed object changes the Sandbox from unrestricted to restricted
	# access_a_parent
	assert_eq(s.has_function("access_a_parent"), true)
	# Create a new node
	var n = Node.new()
	n.name = "Node"
	# Set the sandbox as the parent of the node, so it can be accessed
	s.add_child(n)
	# Add an allowed object
	s.add_allowed_object(n)
	# Now restrictions are in place
	var exceptions = s.get_exceptions()
	s.vmcall("access_a_parent", n)
	# The function should have thrown an exception, as we didn't allow the parent object
	assert_eq(s.get_exceptions(), exceptions + 1)

	# Allow the parent object
	s.add_allowed_object(n.get_parent())
	# Now restrictions are in place
	exceptions = s.get_exceptions()
	s.vmcall("access_a_parent", n)
	# The function should *NOT* have thrown an exception, as we allowed the parent object
	assert_eq(s.get_exceptions(), exceptions)

	# Allow the parent object using a callback
	s.remove_allowed_object(n.get_parent())
	s.set_object_allowed_callback(func(sandbox, obj): return obj == n.get_parent())
	# Now restrictions are in place
	exceptions = s.get_exceptions()
	s.vmcall("access_a_parent", n)
	# The function should *NOT* have thrown an exception, as we allowed the parent object
	assert_eq(s.get_exceptions(), exceptions)

	# Setting a callback for allowed classes changes ClassDB instantiation from unrestricted to restricted
	# creates_a_node
	assert_eq(s.has_function("creates_a_node"), true)
	# Add an allowed class (Node)
	s.set_class_allowed_callback(func(sandbox, name): return name == "Node")
	# Now restrictions are in place
	assert_true(s.is_allowed_class("Node"), "Node should be allowed")
	exceptions = s.get_exceptions()
	s.vmcall("creates_a_node")
	# The function should *NOT* have thrown an exception, as we allowed the Node class
	assert_eq(s.get_exceptions(), exceptions)

	# Now only allow the class Node2D
	s.set_class_allowed_callback(func(sandbox, name): return name == "Node2D")
	# Now restrictions are in place
	assert_true(s.is_allowed_class("Node2D"), "Node2D should be allowed")
	assert_false(s.is_allowed_class("Node"), "Node should not be allowed")
	exceptions = s.get_exceptions()
	s.vmcall("creates_a_node")
	# The function should have thrown an exception, as we only allowed the Node2D class
	assert_eq(s.get_exceptions(), exceptions + 1)

	# Disable all restrictions
	s.restrictions = false
	# Now restrictions are disabled
	exceptions = s.get_exceptions()
	s.vmcall("creates_a_node")
	# The function should *NOT* have thrown an exception, as we disabled all restrictions

	# Enable restrictions (by adding dummy values to allowed_classes and allowed_objects)
	s.restrictions = true
	# Now restrictions are enabled
	exceptions = s.get_exceptions()
	s.vmcall("creates_a_node")
	# The function should have thrown an exception, as we enabled restrictions
	assert_eq(s.get_exceptions(), exceptions + 1, "Should have thrown an exception")

	s.queue_free()

func test_restriction_callbacks():
	var s = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	s.set_object_allowed_callback(func(sandbox, obj): return obj.get_name() == "Test")
	var n = Node.new()
	n.name = "Test"
	assert_true(s.is_allowed_object(n), "Test node should be allowed")

	s.set_method_allowed_callback(func(sandbox, obj, method): return method != "free")
	assert_true(s.is_allowed_method(n, "queue_free"), "Node.queue_free() should be allowed")
	assert_false(s.is_allowed_method(n, "free"), "Node.free() should *NOT* be allowed")

	s.set_property_allowed_callback(func(sandbox, obj, property, is_set): return property != "owner")
	assert_true(s.is_allowed_property(n, "name"), "Node.get/set_name should be allowed")
	assert_false(s.is_allowed_property(n, "owner"), "Node.get/set_owner should *NOT* be allowed")

	s.set_class_allowed_callback(func(sandbox, name): return name == "Node")
	assert_true(s.is_allowed_class("Node"), "Node creation should be allowed")
	assert_false(s.is_allowed_class("Node2D"), "Node2D creation should *NOT* be allowed")

	s.set_resource_allowed_callback(func(sandbox, name): return name == "res://test.tscn")
	assert_true(s.is_allowed_resource("res://test.tscn"), "Resource should be allowed")
	assert_false(s.is_allowed_resource("res://other.tscn"), "Resource should *NOT* be allowed")

	s.queue_free()


func test_insanity():
	var s = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	assert_true(s.has_function("access_an_invalid_child_node"), "access_an_invalid_child_node should exist")

	s.restrictions = true
	s.set_class_allowed_callback(func(sandbox, name): return name == "Node")
	assert_true(s.is_allowed_class("Node"), "Node should be allowed")

	#s.set_object_allowed_callback(func(sandbox, obj): return obj.get_name() == "Node")
	#s.set_method_allowed_callback(func(sandbox, obj, method): return method == "get_name")

	var exceptions = s.get_exceptions()
	s.vmcall("access_an_invalid_child_node")

	assert_eq(s.get_exceptions(), exceptions + 1)


	# access_an_invalid_child_resource
	assert_true(s.has_function("access_an_invalid_child_resource"), "access_an_invalid_child_resource should exist")
	# allow instantiate method
	s.set_method_allowed_callback(func(sandbox, obj, method): return method == "instantiate")

	# allow a resource that can be loaded and instantiated
	s.set_resource_allowed_callback(func(sandbox, name): return name == "res://tests/test.elf")
	assert_true(s.is_allowed_resource("res://tests/test.elf"), "Resource should be allowed")

	exceptions = s.get_exceptions()
	var inst = s.vmcall("access_an_invalid_child_resource", "res://tests/test.elf")
	# The function should *NOT* have thrown an exception, as we allowed the resource
	assert_eq(s.get_exceptions(), exceptions)

	s.vmcall("access_an_invalid_child_resource", "res://other.tscn")
	# The function should have thrown an exception, as we didn't allow the resource
	assert_eq(s.get_exceptions(), exceptions + 1)

	if inst is Node:
		inst.queue_free()

	# disable_restrictions
	assert_true(s.has_function("disable_restrictions"), "disable_restrictions should exist")

	s.restrictions = true
	s.vmcall("disable_restrictions")
	# The function should have denied disabling restrictions, as it is forbidden
	# to disable restrictions from within the sandbox
	assert_eq(s.restrictions, true)

	s.queue_free()

```

`tests/tests/test_shm.cpp`:

```cpp
#include "api.hpp"

PUBLIC Variant test_shm(float *array, size_t size) {
	// This function is a placeholder for shared memory operations.
	// It assumes that the array is already allocated in shared memory.
	if (array == nullptr || size == 0) {
		return Nil;
	}

	for (size_t i = 0; i < size; ++i) {
		array[i] *= 2.0f; // Example operation: double each element
	}

	return PackedArray<float>(array, size);
}

PUBLIC Variant test_shm2(float *array, size_t size) {
	if (array == nullptr || size == 0) {
		return Nil;
	}

	for (size_t i = 0; i < 5; ++i) {
		array[i] = (1.0f + i) * 2.0f; // Example operation: double each element
	}

	return Nil;
}

PUBLIC Variant verify_shm2(float *array, size_t size) {
	if (array == nullptr || size < 5) {
		return false;
	}

	for (size_t i = 0; i < 5; ++i) {
		if (array[i] != (1.0f + i) * 2.0f) {
			return false; // Verification failed
		}
	}

	return true; // Verification succeeded
}

```

`tests/tests/test_shm.gd`:

```gd
extends GutTest

var Sandbox_TestsTests = load("res://tests/tests.elf")

func test_shared_memory():
	var s = Sandbox.new()
	s.set_program(Sandbox_TestsTests)

	assert(s.has_function("test_shm"))

	# Create a packed array of floats
	var array = PackedFloat32Array([1.0, 2.0, 3.0, 4.0, 5.0])

	# Share the array with the node read+write
	var vaddr = s.share_float32_array(true, array)
	var result = s.vmcall("test_shm", vaddr, array.size())

	# The function should double the values in the array
	assert_eq_deep(result, PackedFloat32Array([2.0, 4.0, 6.0, 8.0, 10.0]))

	# After unsharing, the original array should also reflect the changes
	assert_true(s.unshare_array(vaddr), "Unsharing the array should succeed")
	assert_eq_deep(array, PackedFloat32Array([2.0, 4.0, 6.0, 8.0, 10.0]))

	s.queue_free()

func test_sharing_sandboxes():
	var s1 = Sandbox.new()
	s1.set_program(Sandbox_TestsTests)
	s1.restrictions = true # Enable full sandboxing
	var s2 = Sandbox.new()
	s2.set_program(Sandbox_TestsTests)
	s2.restrictions = true # Enable full sandboxing
	assert_true(s1.has_function("test_shm2"), "Sandbox 1 should have the test_shm2 function")
	assert_true(s1.has_function("verify_shm2"), "Sandbox 1 should have the verify_shm2 function")

	# Create a packed array of 100k floats
	var array = PackedFloat32Array()
	array.resize(100000)

	# Perform the test multiple times to ensure stability
	for i in range(10):
		# Share the array with the both sandboxes read+write
		var vaddr1 = s1.share_float32_array(true, array)
		var vaddr2 = s2.share_float32_array(true, array)

		# Call the test function in the first sandbox
		# The function should double the values in the array
		var result = s1.vmcall("test_shm2", vaddr1, array.size())
		# The function should already have modified the first 5 elements of the array
		# because the array is larger than a single page, and all elements within
		# those fully shared pages should be accessible without unsharing.
		for j in range(5):
			assert_eq(array[j], 2.0 * (j + 1), "First 5 elements should be doubled")
		# Call the verification function in the second sandbox
		assert_true(s2.vmcall("verify_shm2", vaddr2, array.size()), "Verification should succeed")

		# After unsharing, the original array should also reflect the changes
		assert_true(s1.unshare_array(vaddr1), "Unsharing the array should succeed")
		assert_true(s2.unshare_array(vaddr2), "Unsharing the array should succeed")

	s1.queue_free()
	s2.queue_free()

func test_sharing_sandboxes_after_mutation():
	var s1 = Sandbox.new()
	s1.set_program(Sandbox_TestsTests)
	s1.restrictions = true # Enable full sandboxing
	var s2 = Sandbox.new()
	s2.set_program(Sandbox_TestsTests)
	s2.restrictions = true # Enable full sandboxing
	assert_true(s1.has_function("test_shm2"), "Sandbox 1 should have the test_shm2 function")
	assert_true(s1.has_function("verify_shm2"), "Sandbox 1 should have the verify_shm2 function")

	# Create a packed array of 100k floats
	var array = PackedFloat32Array()
	array.resize(100000)

	# Pre-share the array with both sandboxes read+write
	var vaddr1 = s1.share_float32_array(true, array)
	var vaddr2 = s2.share_float32_array(true, array)

	# Duplicate and destroy the original array to find dragons
	var array2 = array.duplicate()
	array = null

	await Engine.get_main_loop().process_frame

	# Perform the test multiple times to ensure stability
	for i in range(10):
		# Call the test function in the first sandbox
		var result = s1.vmcall("test_shm2", vaddr1, array2.size())
		# Call the verification function in the second sandbox
		assert_true(s2.vmcall("verify_shm2", vaddr2, array2.size()), "Verification should succeed")

	# Unshare the arrays after the tests
	assert_true(s1.unshare_array(vaddr1), "Unsharing the array should succeed")
	assert_true(s2.unshare_array(vaddr2), "Unsharing the array should succeed")

	s1.queue_free()
	s2.queue_free()

```

`tests/toolchain.cmake`:

```cmake
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMA
```

`tests/zig_unittests.sh`:

```sh
set -e
GODOT_VERSION=4.4.1

# Check if unit tests are run from Github Actions
if [ -n "$CI" ]; then
	GODOT=./Godot_v4.4.1-stable_linux.x86_64
	# Use the --import flag to properly initialize the project
	$GODOT --path "$PWD" --headless --import
else
	# Use a local Godot binary
	if [ -z "$GODOT" ]; then
		GODOT=~/Godot_v4.4.1-stable_linux.x86_64
	fi
fi

export CC="zig;cc;-target riscv64-linux-musl"
export CXX="zig;c++;-target riscv64-linux-musl"

# Build the unit test ELF file
mkdir -p .zig
pushd .zig
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER="$CC" -DCMAKE_CXX_COMPILER="$CXX" -DFLTO=ON
make -j4
popd

# Create a symbolic link to the unit test ELF file
ln -fs ../.zig/unittests tests/tests.elf

# Import again for CI
if [ -n "$CI" ]; then
	$GODOT --path "$PWD" --headless --import
fi

# Run the unit tests using the GUT addon
$GODOT --path "$PWD" --headless -s addons/gut/gut_cmdln.gd $@

```