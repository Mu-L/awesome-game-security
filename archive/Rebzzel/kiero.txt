Project Path: arc_Rebzzel_kiero_542vnxax

Source Tree:

```txt
arc_Rebzzel_kiero_542vnxax
├── LICENSE
├── METHODSTABLE.txt
├── README.md
├── examples
│   └── imgui
│       ├── README.md
│       ├── imgui
│       ├── impl
│       │   ├── d3d10_impl.cpp
│       │   ├── d3d10_impl.h
│       │   ├── d3d11_impl.cpp
│       │   ├── d3d11_impl.h
│       │   ├── d3d9_impl.cpp
│       │   ├── d3d9_impl.h
│       │   ├── shared.cpp
│       │   ├── shared.h
│       │   ├── win32_impl.cpp
│       │   └── win32_impl.h
│       └── main.cpp
├── kiero.cpp
├── kiero.h
└── minhook

```

`LICENSE`:

```
MIT License

Copyright (c) 2014-2021 Rebzzel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`METHODSTABLE.txt`:

```txt
D3D9 Methods Table:
[0]   QueryInterface
[1]   AddRef
[2]   Release
[3]   TestCooperativeLevel
[4]   GetAvailableTextureMem
[5]   EvictManagedResources
[6]   GetDirect3D
[7]   GetDeviceCaps
[8]   GetDisplayMode
[9]   GetCreationParameters
[10]  SetCursorProperties
[11]  SetCursorPosition
[12]  ShowCursor
[13]  CreateAdditionalSwapChain
[14]  GetSwapChain
[15]  GetNumberOfSwapChains
[16]  Reset
[17]  Present
[18]  GetBackBuffer
[19]  GetRasterStatus
[20]  SetDialogBoxMode
[21]  SetGammaRamp
[22]  GetGammaRamp
[23]  CreateTexture
[24]  CreateVolumeTexture
[25]  CreateCubeTexture
[26]  CreateVertexBuffer
[27]  CreateIndexBuffer
[28]  CreateRenderTarget
[29]  CreateDepthStencilSurface
[30]  UpdateSurface
[31]  UpdateTexture
[32]  GetRenderTargetData
[33]  GetFrontBufferData
[34]  StretchRect
[35]  ColorFill
[36]  CreateOffscreenPlainSurface
[37]  SetRenderTarget
[38]  GetRenderTarget
[39]  SetDepthStencilSurface
[40]  GetDepthStencilSurface
[41]  BeginScene
[42]  EndScene
[43]  Clear
[44]  SetTransform
[45]  GetTransform
[46]  MultiplyTransform
[47]  SetViewport
[48]  GetViewport
[49]  SetMaterial
[50]  GetMaterial
[51]  SetLight
[52]  GetLight
[53]  LightEnable
[54]  GetLightEnable
[55]  SetClipPlane
[56]  GetClipPlane
[57]  SetRenderState
[58]  GetRenderState
[59]  CreateStateBlock
[60]  BeginStateBlock
[61]  EndStateBlock
[62]  SetClipStatus
[63]  GetClipStatus
[64]  GetTexture
[65]  SetTexture
[66]  GetTextureStageState
[67]  SetTextureStageState
[68]  GetSamplerState
[69]  SetSamplerState
[70]  ValidateDevice
[71]  SetPaletteEntries
[72]  GetPaletteEntries
[73]  SetCurrentTexturePalette
[74]  GetCurrentTexturePalette
[75]  SetScissorRect
[76]  GetScissorRect
[77]  SetSoftwareVertexProcessing
[78]  GetSoftwareVertexProcessing
[79]  SetNPatchMode
[80]  GetNPatchMode
[81]  DrawPrimitive
[82]  DrawIndexedPrimitive
[83]  DrawPrimitiveUP
[84]  DrawIndexedPrimitiveUP
[85]  ProcessVertices
[86]  CreateVertexDeclaration
[87]  SetVertexDeclaration
[88]  GetVertexDeclaration
[89]  SetFVF
[90]  GetFVF
[91]  CreateVertexShader
[92]  SetVertexShader
[93]  GetVertexShader
[94]  SetVertexShaderConstantF
[95]  GetVertexShaderConstantF
[96]  SetVertexShaderConstantI
[97]  GetVertexShaderConstantI
[98]  SetVertexShaderConstantB
[99]  GetVertexShaderConstantB
[100] SetStreamSource
[101] GetStreamSource
[102] SetStreamSourceFreq
[103] GetStreamSourceFreq
[104] SetIndices
[105] GetIndices
[106] CreatePixelShader
[107] SetPixelShader
[108] GetPixelShader
[109] SetPixelShaderConstantF
[110] GetPixelShaderConstantF
[111] SetPixelShaderConstantI
[112] GetPixelShaderConstantI
[113] SetPixelShaderConstantB
[114] GetPixelShaderConstantB
[115] DrawRectPatch
[116] DrawTriPatch
[117] DeletePatch
[118] CreateQuery

D3D10 Methods Table:
[0]   QueryInterface
[1]   AddRef
[2]   Release
[3]   SetPrivateData
[4]   SetPrivateDataInterface
[5]   GetPrivateData
[6]   GetParent
[7]   GetDevice
[8]   Present
[9]   GetBuffer
[10]  SetFullscreenState
[11]  GetFullscreenState
[12]  GetDesc
[13]  ResizeBuffers
[14]  ResizeTarget
[15]  GetContainingOutput
[16]  GetFrameStatistics
[17]  GetLastPresentCount
[18]  QueryInterface
[19]  AddRef
[20]  Release
[21]  VSSetConstantBuffers
[22]  PSSetShaderResources
[23]  PSSetShader
[24]  PSSetSamplers
[25]  VSSetShader
[26]  DrawIndexed
[27]  Draw
[28]  PSSetConstantBuffers
[29]  IASetInputLayout
[30]  IASetVertexBuffers
[31]  IASetIndexBuffer
[32]  DrawIndexedInstanced
[33]  DrawInstanced
[34]  GSSetConstantBuffers
[35]  GSSetShader
[36]  IASetPrimitiveTopology
[37]  VSSetShaderResources
[38]  VSSetSamplers
[39]  SetPredication
[40]  GSSetShaderResources
[41]  GSSetSamplers
[42]  OMSetRenderTargets
[43]  OMSetBlendState
[44]  OMSetDepthStencilState
[45]  SOSetTargets
[46]  DrawAuto
[47]  RSSetState
[48]  RSSetViewports
[49]  RSSetScissorRects
[50]  CopySubresourceRegion
[51]  CopyResource
[52]  UpdateSubresource
[53]  ClearRenderTargetView
[54]  ClearDepthStencilView
[55]  GenerateMips
[56]  ResolveSubresource
[57]  VSGetConstantBuffers
[58]  PSGetShaderResources
[59]  PSGetShader
[60]  PSGetSamplers
[61]  VSGetShader
[62]  PSGetConstantBuffers
[63]  IAGetInputLayout
[64]  IAGetVertexBuffers
[65]  IAGetIndexBuffer
[66]  GSGetConstantBuffers
[67]  GSGetShader
[68]  IAGetPrimitiveTopology
[69]  VSGetShaderResources
[70]  VSGetSamplers
[71]  GetPredication
[72]  GSGetShaderResources
[73]  GSGetSamplers
[74]  OMGetRenderTargets
[75]  OMGetBlendState
[76]  OMGetDepthStencilState
[77]  SOGetTargets
[78]  RSGetState
[79]  RSGetViewports
[80]  RSGetScissorRects
[81]  GetDeviceRemovedReason
[82]  SetExceptionMode
[83]  GetExceptionMode
[84]  GetPrivateData
[85]  SetPrivateData
[86]  SetPrivateDataInterface
[87]  ClearState
[88]  Flush
[89]  CreateBuffer
[90]  CreateTexture1D
[91]  CreateTexture2D
[92]  CreateTexture3D
[93]  CreateShaderResourceView
[94]  CreateRenderTargetView
[95]  CreateDepthStencilView
[96]  CreateInputLayout
[97]  CreateVertexShader
[98]  CreateGeometryShader
[99]  CreateGemoetryShaderWithStreamOutput
[100] CreatePixelShader
[101] CreateBlendState
[102] CreateDepthStencilState
[103] CreateRasterizerState
[104] CreateSamplerState
[105] CreateQuery
[106] CreatePredicate
[107] CreateCounter
[108] CheckFormatSupport
[109] CheckMultisampleQualityLevels
[110] CheckCounterInfo
[111] CheckCounter
[112] GetCreationFlags
[113] OpenSharedResource
[114] SetTextFilterSize
[115] GetTextFilterSize

D3D11 Methods Table:
[0]   QueryInterface
[1]   AddRef
[2]   Release
[3]   SetPrivateData
[4]   SetPrivateDataInterface
[5]   GetPrivateData
[6]   GetParent
[7]   GetDevice
[8]   Present
[9]   GetBuffer
[10]  SetFullscreenState
[11]  GetFullscreenState
[12]  GetDesc
[13]  ResizeBuffers
[14]  ResizeTarget
[15]  GetContainingOutput
[16]  GetFrameStatistics
[17]  GetLastPresentCount
[18]  QueryInterface
[19]  AddRef
[20]  Release
[21]  CreateBuffer
[22]  CreateTexture1D
[23]  CreateTexture2D
[24]  CreateTexture3D
[25]  CreateShaderResourceView
[26]  CreateUnorderedAccessView
[27]  CreateRenderTargetView
[28]  CreateDepthStencilView
[29]  CreateInputLayout
[30]  CreateVertexShader
[31]  CreateGeometryShader
[32]  CreateGeometryShaderWithStreamOutput
[33]  CreatePixelShader
[34]  CreateHullShader
[35]  CreateDomainShader
[36]  CreateComputeShader
[37]  CreateClassLinkage
[38]  CreateBlendState
[39]  CreateDepthStencilState
[40]  CreateRasterizerState
[41]  CreateSamplerState
[42]  CreateQuery
[43]  CreatePredicate
[44]  CreateCounter
[45]  CreateDeferredContext
[46]  OpenSharedResource
[47]  CheckFormatSupport
[48]  CheckMultisampleQualityLevels
[49]  CheckCounterInfo
[50]  CheckCounter
[51]  CheckFeatureSupport
[52]  GetPrivateData
[53]  SetPrivateData
[54]  SetPrivateDataInterface
[55]  GetFeatureLevel
[56]  GetCreationFlags
[57]  GetDeviceRemovedReason
[58]  GetImmediateContext
[59]  SetExceptionMode
[60]  GetExceptionMode
[61]  QueryInterface
[62]  AddRef
[63]  Release
[64]  GetDevice
[65]  GetPrivateData
[66]  SetPrivateData
[67]  SetPrivateDataInterface
[68]  SetConstantBuffers
[69]  SetShaderResources
[70]  SetShader
[71]  SetSamplers
[72]  SetShader
[73]  DrawIndexed
[74]  Draw
[75]  Map
[76]  Unmap
[77]  SetConstantBuffers
[78]  IASetInputLayout
[79]  IASetVertexBuffers
[80]  IASetIndexBuffer
[81]  DrawIndexedInstanced
[82]  DrawInstanced
[83]  SetConstantBuffers
[84]  SetShader
[85]  IASetPrimitiveTopology
[86]  SetShaderResources
[87]  SetSamplers
[88]  Begin
[89]  End
[90]  GetData
[91]  SetPredication
[92]  SetShaderResources
[93]  SetSamplers
[94]  OMSetRenderTargets
[95]  OMSetRenderTargetsAndUnorderedAccessViews
[96]  OMSetBlendState
[97]  OMSetDepthStencilState
[98]  SOSetTargets
[99]  DrawAuto
[100] DrawIndexedInstancedIndirect
[101] DrawInstancedIndirect
[102] Dispatch
[103] DispatchIndirect
[104] RSSetState
[105] RSSetViewports
[106] RSSetScissorRects
[107] CopySubresourceRegion
[108] CopyResource
[109] UpdateSubresource
[110] CopyStructureCount
[111] ClearRenderTargetView
[112] ClearUnorderedAccessViewUint
[113] ClearUnorderedAccessViewFloat
[114] ClearDepthStencilView
[115] GenerateMips
[116] SetResourceMinLOD
[117] GetResourceMinLOD
[118] ResolveSubresource
[119] ExecuteCommandList
[120] SetShaderResources
[121] SetShader
[122] SetSamplers
[123] SetConstantBuffers
[124] SetShaderResources
[125] SetShader
[126] SetSamplers
[127] SetConstantBuffers
[128] SetShaderResources
[129] CSSetUnorderedAccessViews
[130] SetShader
[131] SetSamplers
[132] SetConstantBuffers
[133] VSGetConstantBuffers
[134] PSGetShaderResources
[135] PSGetShader
[136] PSGetSamplers
[137] VSGetShader
[138] PSGetConstantBuffers
[139] IAGetInputLayout
[140] IAGetVertexBuffers
[141] IAGetIndexBuffer
[142] GSGetConstantBuffers
[143] GSGetShader
[144] IAGetPrimitiveTopology
[145] VSGetShaderResources
[146] VSGetSamplers
[147] GetPredication
[148] GSGetShaderResources
[149] GSGetSamplers
[150] OMGetRenderTargets
[151] OMGetRenderTargetsAndUnorderedAccessViews
[152] OMGetBlendState
[153] OMGetDepthStencilState
[154] SOGetTargets
[155] RSGetState
[156] RSGetViewports
[157] RSGetScissorRects
[158] HSGetShaderResources
[159] HSGetShader
[160] HSGetSamplers
[161] HSGetConstantBuffers
[162] DSGetShaderResources
[163] DSGetShader
[164] DSGetSamplers
[165] DSGetConstantBuffers
[166] CSGetShaderResources
[167] CSGetUnorderedAccessViews
[168] CSGetShader
[169] CSGetSamplers
[170] CSGetConstantBuffers
[171] ClearState
[172] Flush
[173] GetType
[174] GetContextFlags
[175] FinishCommandList
[176] CopySubresourceRegion1
[177] UpdateSubresource1
[178] DiscardResource
[179] DiscardView
[180] SetConstantBuffers1
[181] SetConstantBuffers1
[182] SetConstantBuffers1
[183] SetConstantBuffers1
[184] SetConstantBuffers1
[185] SetConstantBuffers1
[186] VSGetConstantBuffers1
[187] HSGetConstantBuffers1
[188] DSGetConstantBuffers1
[189] GSGetConstantBuffers1
[190] PSGetConstantBuffers1
[191] CSGetConstantBuffers1
[192] SwapDeviceContextState
[193] ClearView
[194] DiscardView1
[195] UpdateTileMappings
[196] CopyTileMappings
[197] CopyTiles
[198] UpdateTiles
[199] ResizeTilePool
[200] TiledResourceBarrier
[201] IsAnnotationEnabled
[202] SetMarkerInt
[203] BeginEventInt
[204] EndEvent

D3D12 Methods Table:
[0]   QueryInterface
[1]   AddRef
[2]   Release
[3]   GetPrivateData
[4]   SetPrivateData
[5]   SetPrivateDataInterface
[6]   SetName
[7]   GetNodeCount
[8]   CreateCommandQueue
[9]   CreateCommandAllocator
[10]  CreateGraphicsPipelineState
[11]  CreateComputePipelineState
[12]  CreateCommandList
[13]  CheckFeatureSupport
[14]  CreateDescriptorHeap
[15]  GetDescriptorHandleIncrementSize
[16]  CreateRootSignature
[17]  CreateConstantBufferView
[18]  CreateShaderResourceView
[19]  CreateUnorderedAccessView
[20]  CreateRenderTargetView
[21]  CreateDepthStencilView
[22]  CreateSampler
[23]  CopyDescriptors
[24]  CopyDescriptorsSimple
[25]  GetResourceAllocationInfo
[26]  GetCustomHeapProperties
[27]  CreateCommittedResource
[28]  CreateHeap
[29]  CreatePlacedResource
[30]  CreateReservedResource
[31]  CreateSharedHandle
[32]  OpenSharedHandle
[33]  OpenSharedHandleByName
[34]  MakeResident
[35]  Evict
[36]  CreateFence
[37]  GetDeviceRemovedReason
[38]  GetCopyableFootprints
[39]  CreateQueryHeap
[40]  SetStablePowerState
[41]  CreateCommandSignature
[42]  GetResourceTiling
[43]  GetAdapterLuid
[44]  QueryInterface
[45]  AddRef
[46]  Release
[47]  GetPrivateData
[48]  SetPrivateData
[49]  SetPrivateDataInterface
[50]  SetName
[51]  GetDevice
[52]  UpdateTileMappings
[53]  CopyTileMappings
[54]  ExecuteCommandLists
[55]  SetMarker
[56]  BeginEvent
[57]  EndEvent
[58]  Signal
[59]  Wait
[60]  GetTimestampFrequency
[61]  GetClockCalibration
[62]  GetDesc
[63]  QueryInterface
[64]  AddRef
[65]  Release
[66]  GetPrivateData
[67]  SetPrivateData
[68]  SetPrivateDataInterface
[69]  SetName
[70]  GetDevice
[71]  Reset
[72]  QueryInterface
[73]  AddRef
[74]  Release
[75]  GetPrivateData
[76]  SetPrivateData
[77]  SetPrivateDataInterface
[78]  SetName
[79]  GetDevice
[80]  GetType
[81]  Close
[82]  Reset
[83]  ClearState
[84]  DrawInstanced
[85]  DrawIndexedInstanced
[86]  Dispatch
[87]  CopyBufferRegion
[88]  CopyTextureRegion
[89]  CopyResource
[90]  CopyTiles
[91]  ResolveSubresource
[92]  IASetPrimitiveTopology
[93]  RSSetViewports
[94]  RSSetScissorRects
[95]  OMSetBlendFactor
[96]  OMSetStencilRef
[97]  SetPipelineState
[98]  ResourceBarrier
[99]  ExecuteBundle
[100] SetDescriptorHeaps
[101] SetComputeRootSignature
[102] SetGraphicsRootSignature
[103] SetComputeRootDescriptorTable
[104] SetGraphicsRootDescriptorTable
[105] SetComputeRoot32BitConstant
[106] SetGraphicsRoot32BitConstant
[107] SetComputeRoot32BitConstants
[108] SetGraphicsRoot32BitConstants
[109] SetComputeRootConstantBufferView
[110] SetGraphicsRootConstantBufferView
[111] SetComputeRootShaderResourceView
[112] SetGraphicsRootShaderResourceView
[113] SetComputeRootUnorderedAccessView
[114] SetGraphicsRootUnorderedAccessView
[115] IASetIndexBuffer
[116] IASetVertexBuffers
[117] SOSetTargets
[118] OMSetRenderTargets
[119] ClearDepthStencilView
[120] ClearRenderTargetView
[121] ClearUnorderedAccessViewUint
[122] ClearUnorderedAccessViewFloat
[123] DiscardResource
[124] BeginQuery
[125] EndQuery
[126] ResolveQueryData
[127] SetPredication
[128] SetMarker
[129] BeginEvent
[130] EndEvent
[131] ExecuteIndirect
[132] QueryInterface
[133] AddRef
[134] Release
[135] SetPrivateData
[136] SetPrivateDataInterface
[137] GetPrivateData
[138] GetParent
[139] GetDevice
[140] Present
[141] GetBuffer
[142] SetFullscreenState
[143] GetFullscreenState
[144] GetDesc
[145] ResizeBuffers
[146] ResizeTarget
[147] GetContainingOutput
[148] GetFrameStatistics
[149] GetLastPresentCount

OpenGL Methods Table:
[0]   glAccum
[1]   glAlphaFunc
[2]   glAreTexturesResident
[3]   glArrayElement
[4]   glBegin
[5]   glBindTexture
[6]   glBitmap
[7]   glBlendFunc
[8]   glCallList
[9]   glCallLists
[10]  glClear
[11]  glClearAccum
[12]  glClearColor
[13]  glClearDepth
[14]  glClearIndex
[15]  glClearStencil
[16]  glClipPlane
[17]  glColor3b
[18]  glColor3bv
[19]  glColor3d
[20]  glColor3dv
[21]  glColor3f
[22]  glColor3fv
[23]  glColor3i
[24]  glColor3iv
[25]  glColor3s
[26]  glColor3sv
[27]  glColor3ub
[28]  glColor3ubv
[29]  glColor3ui
[30]  glColor3uiv
[31]  glColor3us
[32]  glColor3usv
[33]  glColor4b
[34]  glColor4bv
[35]  glColor4d
[36]  glColor4dv
[37]  glColor4f
[38]  glColor4fv
[39]  glColor4i
[40]  glColor4iv
[41]  glColor4s
[42]  glColor4sv
[43]  glColor4ub
[44]  glColor4ubv
[45]  glColor4ui
[46]  glColor4uiv
[47]  glColor4us
[48]  glColor4usv
[49]  glColorMask
[50]  glColorMaterial
[51]  glColorPointer
[52]  glCopyPixels
[53]  glCopyTexImage1D
[54]  glCopyTexImage2D
[55]  glCopyTexSubImage1D
[56]  glCopyTexSubImage2D
[57]  glCullFaceglCullFace
[58]  glDeleteLists
[59]  glDeleteTextures
[60]  glDepthFunc
[61]  glDepthMask
[62]  glDepthRange
[63]  glDisable
[64]  glDisableClientState
[65]  glDrawArrays
[66]  glDrawBuffer
[67]  glDrawElements
[68]  glDrawPixels
[69]  glEdgeFlag
[70]  glEdgeFlagPointer
[71]  glEdgeFlagv
[72]  glEnable
[73]  glEnableClientState
[74]  glEnd
[75]  glEndList
[76]  glEvalCoord1d
[77]  glEvalCoord1dv
[78]  glEvalCoord1f
[79]  glEvalCoord1fv
[80]  glEvalCoord2d
[81]  glEvalCoord2dv
[82]  glEvalCoord2f
[83]  glEvalCoord2fv
[84]  glEvalMesh1
[85]  glEvalMesh2
[86]  glEvalPoint1
[87]  glEvalPoint2
[88]  glFeedbackBuffer
[89]  glFinish
[90]  glFlush
[91]  glFogf
[92]  glFogfv
[93]  glFogi
[94]  glFogiv
[95]  glFrontFace
[96]  glFrustum
[97]  glGenLists
[98]  glGenTextures
[99]  glGetBooleanv
[100] glGetClipPlane
[101] glGetDoublev
[102] glGetError
[103] glGetFloatv
[104] glGetIntegerv
[105] glGetLightfv
[106] glGetLightiv
[107] glGetMapdv
[108] glGetMapfv
[109] glGetMapiv
[110] glGetMaterialfv
[111] glGetMaterialiv
[112] glGetPixelMapfv
[113] glGetPixelMapuiv
[114] glGetPixelMapusv
[115] glGetPointerv
[116] glGetPolygonStipple
[117] glGetString
[118] glGetTexEnvfv
[119] glGetTexEnviv
[120] glGetTexGendv
[121] glGetTexGenfv
[122] glGetTexGeniv
[123] glGetTexImage
[124] glGetTexLevelParameterfv
[125] glGetTexLevelParameteriv
[126] glGetTexParameterfv
[127] glGetTexParameteriv
[128] glHint
[129] glIndexMask
[130] glIndexPointer
[131] glIndexd
[132] glIndexdv
[133] glIndexf
[134] glIndexfv
[135] glIndexi
[136] glIndexiv
[137] glIndexs
[138] glIndexsv
[139] glIndexub
[140] glIndexubv
[141] glInitNames
[142] glInterleavedArrays
[143] glIsEnabled
[144] glIsList
[145] glIsTexture
[146] glLightModelf
[147] glLightModelfv
[148] glLightModeli
[149] glLightModeliv
[150] glLightf
[151] glLightfv
[152] glLighti
[153] glLightiv
[154] glLineStipple
[155] glLineWidth
[156] glListBase
[157] glLoadIdentity
[158] glLoadMatrixd
[159] glLoadMatrixf
[160] glLoadName
[161] glLogicOp
[162] glMap1d
[163] glMap1f
[164] glMap2d
[165] glMap2f
[166] glMapGrid1d
[167] glMapGrid1f
[168] glMapGrid2d
[169] glMapGrid2f
[170] glMaterialf
[171] glMaterialfv
[172] glMateriali
[173] glMaterialiv
[174] glMatrixMode
[175] glMultMatrixd
[176] glMultMatrixf
[177] glNewList
[178] glNormal3b
[179] glNormal3bv
[180] glNormal3d
[181] glNormal3dv
[182] glNormal3f
[183] glNormal3fv
[184] glNormal3i
[185] glNormal3iv
[186] glNormal3s
[187] glNormal3sv
[188] glNormalPointer
[189] glOrtho
[190] glPassThrough
[191] glPixelMapfv
[192] glPixelMapuiv
[193] glPixelMapusv
[194] glPixelStoref
[195] glPixelStorei
[196] glPixelTransferf
[197] glPixelTransferi
[198] glPixelZoom
[199] glPointSize
[200] glPolygonMode
[201] glPolygonOffset
[202] glPolygonStipple
[203] glPopAttrib
[204] glPopClientAttrib
[205] glPopMatrix
[206] glPopName
[207] glPrioritizeTextures
[208] glPushAttrib
[209] glPushClientAttrib
[210] glPushMatrix
[211] glPushName
[212] glRasterPos2d
[213] glRasterPos2dv
[214] glRasterPos2f
[215] glRasterPos2fv
[216] glRasterPos2i
[217] glRasterPos2iv
[218] glRasterPos2s
[219] glRasterPos2sv
[220] glRasterPos3d
[221] glRasterPos3dv
[222] glRasterPos3f
[223] glRasterPos3fv
[224] glRasterPos3i
[225] glRasterPos3iv
[226] glRasterPos3s
[227] glRasterPos3sv
[228] glRasterPos4d
[229] glRasterPos4dv
[230] glRasterPos4f
[231] glRasterPos4fv
[232] glRasterPos4i
[233] glRasterPos4iv
[234] glRasterPos4s
[235] glRasterPos4sv
[236] glReadBuffer
[237] glReadPixels
[238] glRectd
[239] glRectdv
[240] glRectf
[241] glRectfv
[242] glRecti
[243] glRectiv
[244] glRects
[245] glRectsv
[246] glRenderMode
[247] glRotated
[248] glRotatef
[249] glScaled
[250] glScalef
[251] glScissor
[252] glSelectBuffer
[253] glShadeModel
[254] glStencilFunc
[255] glStencilMask
[256] glStencilOp
[257] glTexCoord1d
[258] glTexCoord1dv
[259] glTexCoord1f
[260] glTexCoord1fv
[261] glTexCoord1i
[262] glTexCoord1iv
[263] glTexCoord1s
[264] glTexCoord1sv
[265] glTexCoord2d
[266] glTexCoord2dv
[267] glTexCoord2f
[268] glTexCoord2fv
[269] glTexCoord2i
[270] glTexCoord2iv
[271] glTexCoord2s
[272] glTexCoord2sv
[273] glTexCoord3d
[274] glTexCoord3dv
[275] glTexCoord3f
[276] glTexCoord3fv
[277] glTexCoord3i
[278] glTexCoord3iv
[279] glTexCoord3s
[280] glTexCoord3sv
[281] glTexCoord4d
[282] glTexCoord4dv
[283] glTexCoord4f
[284] glTexCoord4fv
[285] glTexCoord4i
[286] glTexCoord4iv
[287] glTexCoord4s
[288] glTexCoord4sv
[289] glTexCoordPointer
[290] glTexEnvf
[291] glTexEnvfv
[292] glTexEnvi
[293] glTexEnviv
[294] glTexGend
[295] glTexGendv
[296] glTexGenf
[297] glTexGenfv
[298] glTexGeni
[299] glTexGeniv
[300] glTexImage1D
[301] glTexImage2D
[302] glTexParameterf
[303] glTexParameterfv
[304] glTexParameteri
[305] glTexParameteriv
[306] glTexSubImage1D
[307] glTexSubImage2D
[308] glTranslated
[309] glTranslatef
[310] glVertex2d
[311] glVertex2dv
[312] glVertex2f
[313] glVertex2fv
[314] glVertex2i
[315] glVertex2iv
[316] glVertex2s
[317] glVertex2sv
[318] glVertex3d
[319] glVertex3dv
[320] glVertex3f
[321] glVertex3fv
[322] glVertex3i
[323] glVertex3iv
[324] glVertex3s
[325] glVertex3sv
[326] glVertex4d
[327] glVertex4dv
[328] glVertex4f
[329] glVertex4fv
[330] glVertex4i
[331] glVertex4iv
[332] glVertex4s
[333] glVertex4sv
[334] glVertexPointer
[335] glViewport

Vulkan Methods Table:
[0]   vkCreateInstance
[1]   vkDestroyInstance
[2]   vkEnumeratePhysicalDevices
[3]   vkGetPhysicalDeviceFeatures
[4]   vkGetPhysicalDeviceFormatProperties
[5]   vkGetPhysicalDeviceImageFormatProperties
[6]   vkGetPhysicalDeviceProperties
[7]   vkGetPhysicalDeviceQueueFamilyProperties
[8]   vkGetPhysicalDeviceMemoryProperties
[9]   vkGetInstanceProcAddr
[10]  vkGetDeviceProcAddr
[11]  vkCreateDevice
[12]  vkDestroyDevice
[13]  vkEnumerateInstanceExtensionProperties
[14]  vkEnumerateDeviceExtensionProperties
[15]  vkEnumerateDeviceLayerProperties
[16]  vkGetDeviceQueue
[17]  vkQueueSubmit
[18]  vkQueueWaitIdle
[19]  vkDeviceWaitIdle
[20]  vkAllocateMemory
[21]  vkFreeMemory
[22]  vkMapMemory
[23]  vkUnmapMemory
[24]  vkFlushMappedMemoryRanges
[25]  vkInvalidateMappedMemoryRanges
[26]  vkGetDeviceMemoryCommitment
[27]  vkBindBufferMemory
[28]  vkBindImageMemory
[29]  vkGetBufferMemoryRequirements
[30]  vkGetImageMemoryRequirements
[31]  vkGetImageSparseMemoryRequirements
[32]  vkGetPhysicalDeviceSparseImageFormatProperties
[33]  vkQueueBindSparse
[34]  vkCreateFence
[35]  vkDestroyFence
[36]  vkResetFences
[37]  vkGetFenceStatus
[38]  vkWaitForFences
[39]  vkCreateSemaphore
[40]  vkDestroySemaphore
[41]  vkCreateEvent
[42]  vkDestroyEvent
[43]  vkGetEventStatus
[44]  vkSetEvent
[45]  vkResetEvent
[46]  vkCreateQueryPool
[47]  vkDestroyQueryPool
[48]  vkGetQueryPoolResults
[49]  vkCreateBuffer
[50]  vkDestroyBuffer
[51]  vkCreateBufferView
[52]  vkDestroyBufferView
[53]  vkCreateImage
[54]  vkDestroyImage
[55]  vkGetImageSubresourceLayout
[56]  vkCreateImageView
[57]  vkDestroyImageView
[58]  vkCreateShaderModule
[59]  vkDestroyShaderModule
[60]  vkCreatePipelineCache
[61]  vkDestroyPipelineCache
[62]  vkGetPipelineCacheData
[63]  vkMergePipelineCaches
[64]  vkCreateGraphicsPipelines
[65]  vkCreateComputePipelines
[66]  vkDestroyPipeline
[67]  vkCreatePipelineLayout
[68]  vkDestroyPipelineLayout
[69]  vkCreateSampler
[70]  vkDestroySampler
[71]  vkCreateDescriptorSetLayout
[72]  vkDestroyDescriptorSetLayout
[73]  vkCreateDescriptorPool
[74]  vkDestroyDescriptorPool
[75]  vkResetDescriptorPool
[76]  vkAllocateDescriptorSets
[77]  vkFreeDescriptorSets
[78]  vkUpdateDescriptorSets
[79]  vkCreateFramebuffer
[80]  vkDestroyFramebuffer
[81]  vkCreateRenderPass
[82]  vkDestroyRenderPass
[83]  vkGetRenderAreaGranularity
[84]  vkCreateCommandPool
[85]  vkDestroyCommandPool
[86]  vkResetCommandPool
[87]  vkAllocateCommandBuffers
[88]  vkFreeCommandBuffers
[89]  vkBeginCommandBuffer
[90]  vkEndCommandBuffer
[91]  vkResetCommandBuffer
[92]  vkCmdBindPipeline
[93]  vkCmdSetViewport
[94]  vkCmdSetScissor
[95]  vkCmdSetLineWidth
[96]  vkCmdSetDepthBias
[97]  vkCmdSetBlendConstants
[98]  vkCmdSetDepthBounds
[99]  vkCmdSetStencilCompareMask
[100] vkCmdSetStencilWriteMask
[101] vkCmdSetStencilReference
[102] vkCmdBindDescriptorSets
[103] vkCmdBindIndexBuffer
[104] vkCmdBindVertexBuffers
[105] vkCmdDraw
[106] vkCmdDrawIndexed
[107] vkCmdDrawIndirect
[108] vkCmdDrawIndexedIndirect
[109] vkCmdDispatch
[110] vkCmdDispatchIndirect
[111] vkCmdCopyBuffer
[112] vkCmdCopyImage
[113] vkCmdBlitImage
[114] vkCmdCopyBufferToImage
[115] vkCmdCopyImageToBuffer
[116] vkCmdUpdateBuffer
[117] vkCmdFillBuffer
[118] vkCmdClearColorImage
[119] vkCmdClearDepthStencilImage
[120] vkCmdClearAttachments
[121] vkCmdResolveImage
[122] vkCmdSetEvent
[123] vkCmdResetEvent
[124] vkCmdWaitEvents
[125] vkCmdPipelineBarrier
[126] vkCmdBeginQuery
[127] vkCmdEndQuery
[128] vkCmdResetQueryPool
[129] vkCmdWriteTimestamp
[130] vkCmdCopyQueryPoolResults
[131] vkCmdPushConstants
[132] vkCmdBeginRenderPass
[133] vkCmdNextSubpass
[134] vkCmdEndRenderPass
[135] vkCmdExecuteCommands
```

`README.md`:

```md
<h1 align="center">kiero</h1>
<p align="center">
  <a href="https://github.com/Rebzzel/kiero/blob/master/LICENSE">
    <img src="https://img.shields.io/github/license/Rebzzel/kiero.svg?style=flat-square"/>
  </a>
  <a href="https://github.com/Rebzzel/kiero/stargazers">
    <img src="https://img.shields.io/github/stars/Rebzzel/kiero.svg?style=flat-square"/>
  </a>
  <br>
  Universal graphical hook for a D3D9-D3D12, OpenGL and Vulkan based games
</p>

### Requirement
[Windows SDK](https://www.microsoft.com/en-us/download/details.aspx?id=8279) (For D3D9/D3D10/D3D11/OpenGL hook)

[DirectX SDK](https://www.microsoft.com/en-us/download/details.aspx?id=4064) (For D3D9/D3D10/D3D11 hook)

[Vulkan SDK](https://www.lunarg.com/vulkan-sdk) (For Vulkan hook)

[MinHook](https://github.com/TsudaKageyu/minhook) (For kiero::bind function)

### Example
To start, go to the kiero.h and select the desired hooks
```C++
// Example for D3D9 hook
#define KIERO_INCLUDE_D3D9   1 // 1 if you need D3D9 hook
#define KIERO_INCLUDE_D3D10  0 // 1 if you need D3D10 hook
#define KIERO_INCLUDE_D3D11  0 // 1 if you need D3D11 hook
#define KIERO_INCLUDE_D3D12  0 // 1 if you need D3D12 hook
#define KIERO_INCLUDE_OPENGL 0 // 1 if you need OpenGL hook
#define KIERO_INCLUDE_VULKAN 0 // 1 if you need Vulkan hook
```

Then proceed to the main work
```C++
// Example for D3D9 hook

// Include required libraries
#include "kiero.h"
#include <d3d9.h>
#include <Windows.h>

// Create the type of function that we will hook
typedef long(__stdcall* EndScene)(LPDIRECT3DDEVICE9);
static EndScene oEndScene = NULL;

// Declare the detour function
long __stdcall hkEndScene(LPDIRECT3DDEVICE9 pDevice)
{
  // ... Your magic here ...
  
  // static bool init = false;
  // if (!init)
  // {
  //  MessageBox(0, "Boom! It's works!", "Kiero", MB_OK);
  //  init = true;
  // }
  
  return oEndScene(pDevice);
}

int kieroExampleThread()
{
  if (kiero::init(kiero::RenderType::D3D9) == kiero::Status::Success)
  // or
  if (kiero::init(kiero::RenderType::Auto) == kiero::Status::Success)
  {
    // define KIERO_USE_MINHOOK must be 1
    // the index of the required function can be found in the METHODSTABLE.txt
    kiero::bind(42, (void**)&oEndScene, hkEndScene);
    
    // If you just need to get the function address you can use the kiero::getMethodsTable function
    oEndScene = (EndScene)kiero::getMethodsTable()[42];
  }

  return 0;
}

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID)
{
  DisableThreadLibraryCalls(hInstance);

  switch (fdwReason)
  {
    case DLL_PROCESS_ATTACH:
      CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)kieroExampleThread, NULL, 0, NULL);
      break;
  }

  return TRUE;
}

```

### License
```
MIT License

Copyright (c) 2014-2021 Rebzzel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

```

`examples/imgui/README.md`:

```md
## Kiero ImGui Universal Example
### TODO:
- [x] D3D9
- [x] D3D10
- [x] D3D11
- [ ] D3D12
- [ ] OpenGL
- [ ] Vulkan

Author(s): [Rebzzel](https://github.com/Rebzzel)
```

`examples/imgui/impl/d3d10_impl.cpp`:

```cpp
#include "../../../kiero.h"

#if KIERO_INCLUDE_D3D10

#include "d3d10_impl.h"
#include <d3d10.h>
#include <assert.h>

#include "win32_impl.h"

#include "../imgui/imgui.h"
#include "../imgui/examples/imgui_impl_win32.h"
#include "../imgui/examples/imgui_impl_dx10.h"

typedef long(__stdcall* Present)(IDXGISwapChain*, UINT, UINT);
static Present oPresent = NULL;

long __stdcall hkPresent10(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	static bool init = false;

	if (!init)
	{
		DXGI_SWAP_CHAIN_DESC desc;
		pSwapChain->GetDesc(&desc);

		ID3D10Device* device;
		pSwapChain->GetDevice(__uuidof(ID3D10Device), (void**)&device);

		impl::win32::init(desc.OutputWindow);

		ImGui::CreateContext();
		ImGui_ImplWin32_Init(desc.OutputWindow);
		ImGui_ImplDX10_Init(device);

		init = true;
	}

	ImGui_ImplDX10_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	impl::showExampleWindow("D3D10");

	ImGui::EndFrame();
	ImGui::Render();
	ImGui_ImplDX10_RenderDrawData(ImGui::GetDrawData());

	return oPresent(pSwapChain, SyncInterval, Flags);
}

void impl::d3d10::init()
{
	assert(kiero::bind(8, (void**)&oPresent, hkPresent10) == kiero::Status::Success);
}

#endif // KIERO_INCLUDE_D3D10
```

`examples/imgui/impl/d3d10_impl.h`:

```h
#ifndef __D3D10_IMPL_H__
#define __D3D10_IMPL_H__

#include "shared.h"

namespace impl
{
	namespace d3d10
	{
		void init();
	}
}

#endif // __D3D10_IMPL_H__
```

`examples/imgui/impl/d3d11_impl.cpp`:

```cpp
#include "../../../kiero.h"

#if KIERO_INCLUDE_D3D11

#include "d3d11_impl.h"
#include <d3d11.h>
#include <assert.h>

#include "win32_impl.h"

#include "../imgui/imgui.h"
#include "../imgui/examples/imgui_impl_win32.h"
#include "../imgui/examples/imgui_impl_dx11.h"

typedef long(__stdcall* Present)(IDXGISwapChain*, UINT, UINT);
static Present oPresent = NULL;

long __stdcall hkPresent11(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	static bool init = false;

	if (!init)
	{
		DXGI_SWAP_CHAIN_DESC desc;
		pSwapChain->GetDesc(&desc);

		ID3D11Device* device;
		pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&device);

		ID3D11DeviceContext* context;
		device->GetImmediateContext(&context);

		impl::win32::init(desc.OutputWindow);

		ImGui::CreateContext();
		ImGui_ImplWin32_Init(desc.OutputWindow);
		ImGui_ImplDX11_Init(device, context);

		init = true;
	}

	ImGui_ImplDX11_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	impl::showExampleWindow("D3D11");

	ImGui::EndFrame();
	ImGui::Render();
	ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	return oPresent(pSwapChain, SyncInterval, Flags);
}

void impl::d3d11::init()
{
	assert(kiero::bind(8, (void**)&oPresent, hkPresent11) == kiero::Status::Success);
}

#endif // KIERO_INCLUDE_D3D11
```

`examples/imgui/impl/d3d11_impl.h`:

```h
#ifndef __D3D11_IMPL_H__
#define __D3D11_IMPL_H__

#include "shared.h"

namespace impl
{
	namespace d3d11
	{
		void init();
	}
}

#endif // __D3D11_IMPL_H__
```

`examples/imgui/impl/d3d9_impl.cpp`:

```cpp
#include "../../../kiero.h"

#if KIERO_INCLUDE_D3D9

#include "d3d9_impl.h"
#include <d3d9.h>
#include <assert.h>

#include "win32_impl.h"

#include "../imgui/imgui.h"
#include "../imgui/examples/imgui_impl_win32.h"
#include "../imgui/examples/imgui_impl_dx9.h"

typedef long(__stdcall* Reset)(LPDIRECT3DDEVICE9, D3DPRESENT_PARAMETERS*);
static Reset oReset = NULL;

typedef long(__stdcall* EndScene)(LPDIRECT3DDEVICE9);
static EndScene oEndScene = NULL;

long __stdcall hkReset(LPDIRECT3DDEVICE9 pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters)
{
	ImGui_ImplDX9_InvalidateDeviceObjects();
	long result = oReset(pDevice, pPresentationParameters);
	ImGui_ImplDX9_CreateDeviceObjects();

	return result;
}

long __stdcall hkEndScene(LPDIRECT3DDEVICE9 pDevice)
{
	static bool init = false;

	if (!init)
	{
		D3DDEVICE_CREATION_PARAMETERS params;
		pDevice->GetCreationParameters(&params);

		impl::win32::init(params.hFocusWindow);

		ImGui::CreateContext();
		ImGui_ImplWin32_Init(params.hFocusWindow);
		ImGui_ImplDX9_Init(pDevice);

		init = true;
	}

	ImGui_ImplDX9_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	impl::showExampleWindow("D3D9");

	ImGui::EndFrame();
	ImGui::Render();
	ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());

	return oEndScene(pDevice);
}

void impl::d3d9::init()
{
	assert(kiero::bind(16, (void**)&oReset, hkReset) == kiero::Status::Success);
	assert(kiero::bind(42, (void**)&oEndScene, hkEndScene) == kiero::Status::Success);
}

#endif // KIERO_INCLUDE_D3D9
```

`examples/imgui/impl/d3d9_impl.h`:

```h
#ifndef __D3D9_IMPL_H__
#define __D3D9_IMPL_H__

#include "shared.h"

namespace impl
{
	namespace d3d9
	{
		void init();
	}
}

#endif // __D3D9_IMPL_H__
```

`examples/imgui/impl/shared.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS

#include "shared.h"
#include <stdio.h>
#include "../imgui/imgui.h"

void impl::showExampleWindow(const char* comment)
{
	char buffer[128];
	::memset(buffer, 0, 128);
	::sprintf(buffer, "Kiero Dear ImGui Example (%s)", comment);

	ImGui::Begin(buffer);

	ImGui::Text("Hello");
	ImGui::Button("World!");

	ImGui::End();
}
```

`examples/imgui/impl/shared.h`:

```h
#pragma once

namespace impl
{
	void showExampleWindow(const char* comment);
}
```

`examples/imgui/impl/win32_impl.cpp`:

```cpp
#include "../../../kiero.h"

#include "win32_impl.h"
#include <Windows.h>

#include "../imgui/imgui.h"
#include "../imgui/examples/imgui_impl_win32.h"

static WNDPROC oWndProc = NULL;

extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

LRESULT CALLBACK hkWindowProc(
	_In_ HWND   hwnd,
	_In_ UINT   uMsg,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
)
{
	if (ImGui_ImplWin32_WndProcHandler(hwnd, uMsg, wParam, lParam) > 0)
		return 1L;	
	return ::CallWindowProcA(oWndProc, hwnd, uMsg, wParam, lParam);
}

void impl::win32::init(void* hwnd)
{
	oWndProc = (WNDPROC)::SetWindowLongPtr((HWND)hwnd, GWLP_WNDPROC, (LONG)hkWindowProc);
}
```

`examples/imgui/impl/win32_impl.h`:

```h
#ifndef __WIN32_IMPL_H__
#define __WIN32_IMPL_H__

#include "shared.h"

namespace impl
{
	namespace win32
	{
		void init(void* hwnd);
	}
}

#endif // __WIN32_IMPL_H__
```

`examples/imgui/main.cpp`:

```cpp
#include "../../kiero.h"

#if KIERO_INCLUDE_D3D9
# include "impl/d3d9_impl.h"
#endif

#if KIERO_INCLUDE_D3D10
# include "impl/d3d10_impl.h"
#endif

#if KIERO_INCLUDE_D3D11
# include "impl/d3d11_impl.h"
#endif

#if KIERO_INCLUDE_D3D12
#endif

#if KIERO_INCLUDE_OPENGL
#endif

#if KIERO_INCLUDE_VULKAN
#endif

#if !KIERO_USE_MINHOOK
# error "The example requires that minhook be enabled!"
#endif

#include <Windows.h>

int kieroExampleThread()
{
    if (kiero::init(kiero::RenderType::Auto) == kiero::Status::Success)
    {
        switch (kiero::getRenderType())
        {
#if KIERO_INCLUDE_D3D9
        case kiero::RenderType::D3D9:
            impl::d3d9::init();
            break;
#endif
#if KIERO_INCLUDE_D3D10
        case kiero::RenderType::D3D10:
            impl::d3d10::init();
            break;
#endif
#if KIERO_INCLUDE_D3D11
        case kiero::RenderType::D3D11:
            impl::d3d11::init();
            break;
#endif
        case kiero::RenderType::D3D12:
            // TODO: D3D12 implementation?
            break;
        case kiero::RenderType::OpenGL:
            // TODO: OpenGL implementation?
            break;
        case kiero::RenderType::Vulkan:
            // TODO: Vulkan implementation?
            break;
        }

        return 1;
    }

	return 0;
}

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID)
{
    DisableThreadLibraryCalls(hInstance);

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)kieroExampleThread, NULL, 0, NULL);
        break;
    }

    return TRUE;
}
```

`kiero.cpp`:

```cpp
#include "kiero.h"
#include <Windows.h>
#include <assert.h>

#if KIERO_INCLUDE_D3D9
# include <d3d9.h>
#endif

#if KIERO_INCLUDE_D3D10
# include <dxgi.h>
# include <d3d10_1.h>
# include <d3d10.h>
#endif

#if KIERO_INCLUDE_D3D11
# include <dxgi.h>
# include <d3d11.h>
#endif

#if KIERO_INCLUDE_D3D12
# include <dxgi.h>
# include <d3d12.h>
#endif

#if KIERO_INCLUDE_OPENGL
# include <gl/GL.h>
#endif

#if KIERO_INCLUDE_VULKAN
# include <vulkan/vulkan.h>
#endif

#if KIERO_USE_MINHOOK
# include "minhook/include/MinHook.h"
#endif

#ifdef _UNICODE
# define KIERO_TEXT(text) L##text
#else
# define KIERO_TEXT(text) text
#endif

#define KIERO_ARRAY_SIZE(arr) ((size_t)(sizeof(arr)/sizeof(arr[0])))

static kiero::RenderType::Enum g_renderType = kiero::RenderType::None;
static uint150_t* g_methodsTable = NULL;

kiero::Status::Enum kiero::init(RenderType::Enum _renderType)
{
	if (g_renderType != RenderType::None)
	{
		return Status::AlreadyInitializedError;
	}

	if (_renderType != RenderType::None)
	{
		if (_renderType >= RenderType::D3D9 && _renderType <= RenderType::D3D12)
		{
			WNDCLASSEX windowClass;
			windowClass.cbSize = sizeof(WNDCLASSEX);
			windowClass.style = CS_HREDRAW | CS_VREDRAW;
			windowClass.lpfnWndProc = DefWindowProc;
			windowClass.cbClsExtra = 0;
			windowClass.cbWndExtra = 0;
			windowClass.hInstance = GetModuleHandle(NULL);
			windowClass.hIcon = NULL;
			windowClass.hCursor = NULL;
			windowClass.hbrBackground = NULL;
			windowClass.lpszMenuName = NULL;
			windowClass.lpszClassName = KIERO_TEXT("Kiero");
			windowClass.hIconSm = NULL;

			::RegisterClassEx(&windowClass);

			HWND window = ::CreateWindow(windowClass.lpszClassName, KIERO_TEXT("Kiero DirectX Window"), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, NULL, NULL, windowClass.hInstance, NULL);

			if (_renderType == RenderType::D3D9)
			{
#if KIERO_INCLUDE_D3D9
				HMODULE libD3D9;
				if ((libD3D9 = ::GetModuleHandle(KIERO_TEXT("d3d9.dll"))) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::ModuleNotFoundError;
				}

				void* Direct3DCreate9;
				if ((Direct3DCreate9 = ::GetProcAddress(libD3D9, "Direct3DCreate9")) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				LPDIRECT3D9 direct3D9;
				if ((direct3D9 = ((LPDIRECT3D9(__stdcall*)(uint32_t))(Direct3DCreate9))(D3D_SDK_VERSION)) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				D3DPRESENT_PARAMETERS params;
				params.BackBufferWidth = 0;
				params.BackBufferHeight = 0;
				params.BackBufferFormat = D3DFMT_UNKNOWN;
				params.BackBufferCount = 0;
				params.MultiSampleType = D3DMULTISAMPLE_NONE;
				params.MultiSampleQuality = NULL;
				params.SwapEffect = D3DSWAPEFFECT_DISCARD;
				params.hDeviceWindow = window;
				params.Windowed = 1;
				params.EnableAutoDepthStencil = 0;
				params.AutoDepthStencilFormat = D3DFMT_UNKNOWN;
				params.Flags = NULL;
				params.FullScreen_RefreshRateInHz = 0;
				params.PresentationInterval = 0;

				LPDIRECT3DDEVICE9 device;
				if (direct3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_NULLREF, window, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &params, &device) < 0)
				{
					direct3D9->Release();
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				g_methodsTable = (uint150_t*)::calloc(119, sizeof(uint150_t));
				::memcpy(g_methodsTable, *(uint150_t**)device, 119 * sizeof(uint150_t));

#if KIERO_USE_MINHOOK
				MH_Initialize();
#endif

				device->Release();
				device = NULL;

				direct3D9->Release();
				direct3D9 = NULL;

				g_renderType = RenderType::D3D9;

				::DestroyWindow(window);
				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

				return Status::Success;
#endif
			}
			else if (_renderType == RenderType::D3D10)
			{
#if KIERO_INCLUDE_D3D10
				HMODULE libDXGI;
				HMODULE libD3D10;
				if ((libDXGI = ::GetModuleHandle(KIERO_TEXT("dxgi.dll"))) == NULL || (libD3D10 = ::GetModuleHandle(KIERO_TEXT("d3d10.dll"))) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::ModuleNotFoundError;
				}

				void* CreateDXGIFactory;
				if ((CreateDXGIFactory = ::GetProcAddress(libDXGI, "CreateDXGIFactory")) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				IDXGIFactory* factory;
				if (((long(__stdcall*)(const IID&, void**))(CreateDXGIFactory))(__uuidof(IDXGIFactory), (void**)&factory) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				IDXGIAdapter* adapter;
				if (factory->EnumAdapters(0, &adapter) == DXGI_ERROR_NOT_FOUND)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				void* D3D10CreateDeviceAndSwapChain;
				if ((D3D10CreateDeviceAndSwapChain = ::GetProcAddress(libD3D10, "D3D10CreateDeviceAndSwapChain")) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				DXGI_RATIONAL refreshRate;
				refreshRate.Numerator = 60;
				refreshRate.Denominator = 1;

				DXGI_MODE_DESC bufferDesc;
				bufferDesc.Width = 100;
				bufferDesc.Height = 100;
				bufferDesc.RefreshRate = refreshRate;
				bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
				bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

				DXGI_SAMPLE_DESC sampleDesc;
				sampleDesc.Count = 1;
				sampleDesc.Quality = 0;

				DXGI_SWAP_CHAIN_DESC swapChainDesc;
				swapChainDesc.BufferDesc = bufferDesc;
				swapChainDesc.SampleDesc = sampleDesc;
				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainDesc.BufferCount = 1;
				swapChainDesc.OutputWindow = window;
				swapChainDesc.Windowed = 1;
				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

				IDXGISwapChain* swapChain;
				ID3D10Device* device;

				if (((long(__stdcall*)(
					IDXGIAdapter*,
					D3D10_DRIVER_TYPE,
					HMODULE,
					UINT,
					UINT,
					DXGI_SWAP_CHAIN_DESC*,
					IDXGISwapChain**,
					ID3D10Device**))(D3D10CreateDeviceAndSwapChain))(adapter, D3D10_DRIVER_TYPE_HARDWARE, NULL, 0, D3D10_SDK_VERSION, &swapChainDesc, &swapChain, &device) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				g_methodsTable = (uint150_t*)::calloc(116, sizeof(uint150_t));
				::memcpy(g_methodsTable, *(uint150_t**)swapChain, 18 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 18, *(uint150_t**)device, 98 * sizeof(uint150_t));

#if KIERO_USE_MINHOOK
				MH_Initialize();
#endif

				swapChain->Release();
				swapChain = NULL;

				device->Release();
				device = NULL;

				::DestroyWindow(window);
				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

				g_renderType = RenderType::D3D10;

				return Status::Success;
#endif
			}
			else if (_renderType == RenderType::D3D11)
			{
#if KIERO_INCLUDE_D3D11
				HMODULE libD3D11;
				if ((libD3D11 = ::GetModuleHandle(KIERO_TEXT("d3d11.dll"))) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::ModuleNotFoundError;
				}

				void* D3D11CreateDeviceAndSwapChain;
				if ((D3D11CreateDeviceAndSwapChain = ::GetProcAddress(libD3D11, "D3D11CreateDeviceAndSwapChain")) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				D3D_FEATURE_LEVEL featureLevel;
				const D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };

				DXGI_RATIONAL refreshRate;
				refreshRate.Numerator = 60;
				refreshRate.Denominator = 1;

				DXGI_MODE_DESC bufferDesc;
				bufferDesc.Width = 100;
				bufferDesc.Height = 100;
				bufferDesc.RefreshRate = refreshRate;
				bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
				bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

				DXGI_SAMPLE_DESC sampleDesc;
				sampleDesc.Count = 1;
				sampleDesc.Quality = 0;

				DXGI_SWAP_CHAIN_DESC swapChainDesc;
				swapChainDesc.BufferDesc = bufferDesc;
				swapChainDesc.SampleDesc = sampleDesc;
				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainDesc.BufferCount = 1;
				swapChainDesc.OutputWindow = window;
				swapChainDesc.Windowed = 1;
				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

				IDXGISwapChain* swapChain;
				ID3D11Device* device;
				ID3D11DeviceContext* context;

				if (((long(__stdcall*)(
					IDXGIAdapter*,
					D3D_DRIVER_TYPE,
					HMODULE,
					UINT,
					const D3D_FEATURE_LEVEL*,
					UINT,
					UINT,
					const DXGI_SWAP_CHAIN_DESC*,
					IDXGISwapChain**,
					ID3D11Device**,
					D3D_FEATURE_LEVEL*,
					ID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				g_methodsTable = (uint150_t*)::calloc(205, sizeof(uint150_t));
				::memcpy(g_methodsTable, *(uint150_t**)swapChain, 18 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 18, *(uint150_t**)device, 43 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 18 + 43, *(uint150_t**)context, 144 * sizeof(uint150_t));

#if KIERO_USE_MINHOOK
				MH_Initialize();
#endif

				swapChain->Release();
				swapChain = NULL;

				device->Release();
				device = NULL;

				context->Release();
				context = NULL;

				::DestroyWindow(window);
				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

				g_renderType = RenderType::D3D11;

				return Status::Success;
#endif
			}
			else if (_renderType == RenderType::D3D12)
			{
#if KIERO_INCLUDE_D3D12
				HMODULE libDXGI;
				HMODULE libD3D12;
				if ((libDXGI = ::GetModuleHandle(KIERO_TEXT("dxgi.dll"))) == NULL || (libD3D12 = ::GetModuleHandle(KIERO_TEXT("d3d12.dll"))) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::ModuleNotFoundError;
				}

				void* CreateDXGIFactory;
				if ((CreateDXGIFactory = ::GetProcAddress(libDXGI, "CreateDXGIFactory")) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				IDXGIFactory* factory;
				if (((long(__stdcall*)(const IID&, void**))(CreateDXGIFactory))(__uuidof(IDXGIFactory), (void**)&factory) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				IDXGIAdapter* adapter;
				if (factory->EnumAdapters(0, &adapter) == DXGI_ERROR_NOT_FOUND)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				void* D3D12CreateDevice;
				if ((D3D12CreateDevice = ::GetProcAddress(libD3D12, "D3D12CreateDevice")) == NULL)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				ID3D12Device* device;
				if (((long(__stdcall*)(IUnknown*, D3D_FEATURE_LEVEL, const IID&, void**))(D3D12CreateDevice))(adapter, D3D_FEATURE_LEVEL_11_0, __uuidof(ID3D12Device), (void**)&device) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				D3D12_COMMAND_QUEUE_DESC queueDesc;
				queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
				queueDesc.Priority = 0;
				queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
				queueDesc.NodeMask = 0;

				ID3D12CommandQueue* commandQueue;
				if (device->CreateCommandQueue(&queueDesc, __uuidof(ID3D12CommandQueue), (void**)&commandQueue) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				ID3D12CommandAllocator* commandAllocator;
				if (device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, __uuidof(ID3D12CommandAllocator), (void**)&commandAllocator) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				ID3D12GraphicsCommandList* commandList;
				if (device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, NULL, __uuidof(ID3D12GraphicsCommandList), (void**)&commandList) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				DXGI_RATIONAL refreshRate;
				refreshRate.Numerator = 60;
				refreshRate.Denominator = 1;

				DXGI_MODE_DESC bufferDesc;
				bufferDesc.Width = 100;
				bufferDesc.Height = 100;
				bufferDesc.RefreshRate = refreshRate;
				bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
				bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

				DXGI_SAMPLE_DESC sampleDesc;
				sampleDesc.Count = 1;
				sampleDesc.Quality = 0;

				DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
				swapChainDesc.BufferDesc = bufferDesc;
				swapChainDesc.SampleDesc = sampleDesc;
				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainDesc.BufferCount = 2;
				swapChainDesc.OutputWindow = window;
				swapChainDesc.Windowed = 1;
				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

				IDXGISwapChain* swapChain;
				if (factory->CreateSwapChain(commandQueue, &swapChainDesc, &swapChain) < 0)
				{
					::DestroyWindow(window);
					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
					return Status::UnknownError;
				}

				g_methodsTable = (uint150_t*)::calloc(150, sizeof(uint150_t));
				::memcpy(g_methodsTable, *(uint150_t**)device, 44 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 44, *(uint150_t**)commandQueue, 19 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 44 + 19, *(uint150_t**)commandAllocator, 9 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 44 + 19 + 9, *(uint150_t**)commandList, 60 * sizeof(uint150_t));
				::memcpy(g_methodsTable + 44 + 19 + 9 + 60, *(uint150_t**)swapChain, 18 * sizeof(uint150_t));

#if KIERO_USE_MINHOOK
				MH_Initialize();
#endif

				device->Release();
				device = NULL;

				commandQueue->Release();
				commandQueue = NULL;

				commandAllocator->Release();
				commandAllocator = NULL;

				commandList->Release();
				commandList = NULL;

				swapChain->Release();
				swapChain = NULL;

				::DestroyWindow(window);
				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

				g_renderType = RenderType::D3D12;

				return Status::Success;
#endif
			}

			::DestroyWindow(window);
			::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

			return Status::NotSupportedError;
		}
		else if (_renderType != RenderType::Auto)
		{
			if (_renderType == RenderType::OpenGL)
			{
#if KIERO_INCLUDE_OPENGL
				HMODULE libOpenGL32;
				if ((libOpenGL32 = ::GetModuleHandle(KIERO_TEXT("opengl32.dll"))) == NULL)
				{
					return Status::ModuleNotFoundError;
				}

				const char* const methodsNames[] = {
					"glAccum", "glAlphaFunc", "glAreTexturesResident", "glArrayElement", "glBegin", "glBindTexture", "glBitmap", "glBlendFunc", "glCallList", "glCallLists", "glClear", "glClearAccum",
					"glClearColor", "glClearDepth", "glClearIndex", "glClearStencil", "glClipPlane", "glColor3b", "glColor3bv", "glColor3d", "glColor3dv", "glColor3f", "glColor3fv", "glColor3i", "glColor3iv",
					"glColor3s", "glColor3sv", "glColor3ub", "glColor3ubv", "glColor3ui", "glColor3uiv", "glColor3us", "glColor3usv", "glColor4b", "glColor4bv", "glColor4d", "glColor4dv", "glColor4f",
					"glColor4fv", "glColor4i", "glColor4iv", "glColor4s", "glColor4sv", "glColor4ub", "glColor4ubv", "glColor4ui", "glColor4uiv", "glColor4us", "glColor4usv", "glColorMask", "glColorMaterial",
					"glColorPointer", "glCopyPixels", "glCopyTexImage1D", "glCopyTexImage2D", "glCopyTexSubImage1D", "glCopyTexSubImage2D", "glCullFaceglCullFace", "glDeleteLists", "glDeleteTextures",
					"glDepthFunc", "glDepthMask", "glDepthRange", "glDisable", "glDisableClientState", "glDrawArrays", "glDrawBuffer", "glDrawElements", "glDrawPixels", "glEdgeFlag", "glEdgeFlagPointer",
					"glEdgeFlagv", "glEnable", "glEnableClientState", "glEnd", "glEndList", "glEvalCoord1d", "glEvalCoord1dv", "glEvalCoord1f", "glEvalCoord1fv", "glEvalCoord2d", "glEvalCoord2dv",
					"glEvalCoord2f", "glEvalCoord2fv", "glEvalMesh1", "glEvalMesh2", "glEvalPoint1", "glEvalPoint2", "glFeedbackBuffer", "glFinish", "glFlush", "glFogf", "glFogfv", "glFogi", "glFogiv",
					"glFrontFace", "glFrustum", "glGenLists", "glGenTextures", "glGetBooleanv", "glGetClipPlane", "glGetDoublev", "glGetError", "glGetFloatv", "glGetIntegerv", "glGetLightfv", "glGetLightiv",
					"glGetMapdv", "glGetMapfv", "glGetMapiv", "glGetMaterialfv", "glGetMaterialiv", "glGetPixelMapfv", "glGetPixelMapuiv", "glGetPixelMapusv", "glGetPointerv", "glGetPolygonStipple",
					"glGetString", "glGetTexEnvfv", "glGetTexEnviv", "glGetTexGendv", "glGetTexGenfv", "glGetTexGeniv", "glGetTexImage", "glGetTexLevelParameterfv", "glGetTexLevelParameteriv",
					"glGetTexParameterfv", "glGetTexParameteriv", "glHint", "glIndexMask", "glIndexPointer", "glIndexd", "glIndexdv", "glIndexf", "glIndexfv", "glIndexi", "glIndexiv", "glIndexs", "glIndexsv",
					"glIndexub", "glIndexubv", "glInitNames", "glInterleavedArrays", "glIsEnabled", "glIsList", "glIsTexture", "glLightModelf", "glLightModelfv", "glLightModeli", "glLightModeliv", "glLightf",
					"glLightfv", "glLighti", "glLightiv", "glLineStipple", "glLineWidth", "glListBase", "glLoadIdentity", "glLoadMatrixd", "glLoadMatrixf", "glLoadName", "glLogicOp", "glMap1d", "glMap1f",
					"glMap2d", "glMap2f", "glMapGrid1d", "glMapGrid1f", "glMapGrid2d", "glMapGrid2f", "glMaterialf", "glMaterialfv", "glMateriali", "glMaterialiv", "glMatrixMode", "glMultMatrixd",
					"glMultMatrixf", "glNewList", "glNormal3b", "glNormal3bv", "glNormal3d", "glNormal3dv", "glNormal3f", "glNormal3fv", "glNormal3i", "glNormal3iv", "glNormal3s", "glNormal3sv",
					"glNormalPointer", "glOrtho", "glPassThrough", "glPixelMapfv", "glPixelMapuiv", "glPixelMapusv", "glPixelStoref", "glPixelStorei", "glPixelTransferf", "glPixelTransferi", "glPixelZoom",
					"glPointSize", "glPolygonMode", "glPolygonOffset", "glPolygonStipple", "glPopAttrib", "glPopClientAttrib", "glPopMatrix", "glPopName", "glPrioritizeTextures", "glPushAttrib",
					"glPushClientAttrib", "glPushMatrix", "glPushName", "glRasterPos2d", "glRasterPos2dv", "glRasterPos2f", "glRasterPos2fv", "glRasterPos2i", "glRasterPos2iv", "glRasterPos2s",
					"glRasterPos2sv", "glRasterPos3d", "glRasterPos3dv", "glRasterPos3f", "glRasterPos3fv", "glRasterPos3i", "glRasterPos3iv", "glRasterPos3s", "glRasterPos3sv", "glRasterPos4d",
					"glRasterPos4dv", "glRasterPos4f", "glRasterPos4fv", "glRasterPos4i", "glRasterPos4iv", "glRasterPos4s", "glRasterPos4sv", "glReadBuffer", "glReadPixels", "glRectd", "glRectdv", "glRectf",
					"glRectfv", "glRecti", "glRectiv", "glRects", "glRectsv", "glRenderMode", "glRotated", "glRotatef", "glScaled", "glScalef", "glScissor", "glSelectBuffer", "glShadeModel", "glStencilFunc",
					"glStencilMask", "glStencilOp", "glTexCoord1d", "glTexCoord1dv", "glTexCoord1f", "glTexCoord1fv", "glTexCoord1i", "glTexCoord1iv", "glTexCoord1s", "glTexCoord1sv", "glTexCoord2d",
					"glTexCoord2dv", "glTexCoord2f", "glTexCoord2fv", "glTexCoord2i", "glTexCoord2iv", "glTexCoord2s", "glTexCoord2sv", "glTexCoord3d", "glTexCoord3dv", "glTexCoord3f", "glTexCoord3fv",
					"glTexCoord3i", "glTexCoord3iv", "glTexCoord3s", "glTexCoord3sv", "glTexCoord4d", "glTexCoord4dv", "glTexCoord4f", "glTexCoord4fv", "glTexCoord4i", "glTexCoord4iv", "glTexCoord4s",
					"glTexCoord4sv", "glTexCoordPointer", "glTexEnvf", "glTexEnvfv", "glTexEnvi", "glTexEnviv", "glTexGend", "glTexGendv", "glTexGenf", "glTexGenfv", "glTexGeni", "glTexGeniv", "glTexImage1D",
					"glTexImage2D", "glTexParameterf", "glTexParameterfv", "glTexParameteri", "glTexParameteriv", "glTexSubImage1D", "glTexSubImage2D", "glTranslated", "glTranslatef", "glVertex2d",
					"glVertex2dv", "glVertex2f", "glVertex2fv", "glVertex2i", "glVertex2iv", "glVertex2s", "glVertex2sv", "glVertex3d", "glVertex3dv", "glVertex3f", "glVertex3fv", "glVertex3i", "glVertex3iv",
					"glVertex3s", "glVertex3sv", "glVertex4d", "glVertex4dv", "glVertex4f", "glVertex4fv", "glVertex4i", "glVertex4iv", "glVertex4s", "glVertex4sv", "glVertexPointer", "glViewport"
				};

				size_t size = KIERO_ARRAY_SIZE(methodsNames);

				g_methodsTable = (uint150_t*)::calloc(size, sizeof(uint150_t));

				for (int i = 0; i < size; i++)
				{
					g_methodsTable[i] = (uint150_t)::GetProcAddress(libOpenGL32, methodsNames[i]);
				}

#if KIERO_USE_MINHOOK
				MH_Initialize();
#endif

				g_renderType = RenderType::OpenGL;

				return Status::Success;
#endif
			}
			else if (_renderType == RenderType::Vulkan)
			{
#if KIERO_INCLUDE_VULKAN
				HMODULE libVulkan;
				if ((libVulkan = GetModuleHandle(KIERO_TEXT("vulkan-1.dll"))) == NULL)
				{
					return Status::ModuleNotFoundError;
				}

				const char* const methodsNames[] = {
					"vkCreateInstance", "vkDestroyInstance", "vkEnumeratePhysicalDevices", "vkGetPhysicalDeviceFeatures", "vkGetPhysicalDeviceFormatProperties", "vkGetPhysicalDeviceImageFormatProperties",
					"vkGetPhysicalDeviceProperties", "vkGetPhysicalDeviceQueueFamilyProperties", "vkGetPhysicalDeviceMemoryProperties", "vkGetInstanceProcAddr", "vkGetDeviceProcAddr", "vkCreateDevice",
					"vkDestroyDevice", "vkEnumerateInstanceExtensionProperties", "vkEnumerateDeviceExtensionProperties", "vkEnumerateDeviceLayerProperties", "vkGetDeviceQueue", "vkQueueSubmit", "vkQueueWaitIdle",
					"vkDeviceWaitIdle", "vkAllocateMemory", "vkFreeMemory", "vkMapMemory", "vkUnmapMemory", "vkFlushMappedMemoryRanges", "vkInvalidateMappedMemoryRanges", "vkGetDeviceMemoryCommitment",
					"vkBindBufferMemory", "vkBindImageMemory", "vkGetBufferMemoryRequirements", "vkGetImageMemoryRequirements", "vkGetImageSparseMemoryRequirements", "vkGetPhysicalDeviceSparseImageFormatProperties",
					"vkQueueBindSparse", "vkCreateFence", "vkDestroyFence", "vkResetFences", "vkGetFenceStatus", "vkWaitForFences", "vkCreateSemaphore", "vkDestroySemaphore", "vkCreateEvent", "vkDestroyEvent",
					"vkGetEventStatus", "vkSetEvent", "vkResetEvent", "vkCreateQueryPool", "vkDestroyQueryPool", "vkGetQueryPoolResults", "vkCreateBuffer", "vkDestroyBuffer", "vkCreateBufferView", "vkDestroyBufferView",
					"vkCreateImage", "vkDestroyImage", "vkGetImageSubresourceLayout", "vkCreateImageView", "vkDestroyImageView", "vkCreateShaderModule", "vkDestroyShaderModule", "vkCreatePipelineCache",
					"vkDestroyPipelineCache", "vkGetPipelineCacheData", "vkMergePipelineCaches", "vkCreateGraphicsPipelines", "vkCreateComputePipelines", "vkDestroyPipeline", "vkCreatePipelineLayout",
					"vkDestroyPipelineLayout", "vkCreateSampler", "vkDestroySampler", "vkCreateDescriptorSetLayout", "vkDestroyDescriptorSetLayout", "vkCreateDescriptorPool", "vkDestroyDescriptorPool",
					"vkResetDescriptorPool", "vkAllocateDescriptorSets", "vkFreeDescriptorSets", "vkUpdateDescriptorSets", "vkCreateFramebuffer", "vkDestroyFramebuffer", "vkCreateRenderPass", "vkDestroyRenderPass",
					"vkGetRenderAreaGranularity", "vkCreateCommandPool", "vkDestroyCommandPool", "vkResetCommandPool", "vkAllocateCommandBuffers", "vkFreeCommandBuffers", "vkBeginCommandBuffer", "vkEndCommandBuffer",
					"vkResetCommandBuffer", "vkCmdBindPipeline", "vkCmdSetViewport", "vkCmdSetScissor", "vkCmdSetLineWidth", "vkCmdSetDepthBias", "vkCmdSetBlendConstants", "vkCmdSetDepthBounds",
					"vkCmdSetStencilCompareMask", "vkCmdSetStencilWriteMask", "vkCmdSetStencilReference", "vkCmdBindDescriptorSets", "vkCmdBindIndexBuffer", "vkCmdBindVertexBuffers", "vkCmdDraw", "vkCmdDrawIndexed",
					"vkCmdDrawIndirect", "vkCmdDrawIndexedIndirect", "vkCmdDispatch", "vkCmdDispatchIndirect", "vkCmdCopyBuffer", "vkCmdCopyImage", "vkCmdBlitImage", "vkCmdCopyBufferToImage", "vkCmdCopyImageToBuffer",
					"vkCmdUpdateBuffer", "vkCmdFillBuffer", "vkCmdClearColorImage", "vkCmdClearDepthStencilImage", "vkCmdClearAttachments", "vkCmdResolveImage", "vkCmdSetEvent", "vkCmdResetEvent", "vkCmdWaitEvents",
					"vkCmdPipelineBarrier", "vkCmdBeginQuery", "vkCmdEndQuery", "vkCmdResetQueryPool", "vkCmdWriteTimestamp", "vkCmdCopyQueryPoolResults", "vkCmdPushConstants", "vkCmdBeginRenderPass", "vkCmdNextSubpass",
					"vkCmdEndRenderPass", "vkCmdExecuteCommands"
				};

				size_t size = KIERO_ARRAY_SIZE(methodsNames);

				g_methodsTable = (uint150_t*)::calloc(size, sizeof(uint150_t));

				for (int i = 0; i < size; i++)
				{
					g_methodsTable[i] = (uint150_t)::GetProcAddress(libVulkan, methodsNames[i]);
				}

#if KIERO_USE_MINHOOK
				MH_Initialize();
#endif

				g_renderType = RenderType::Vulkan;

				return Status::Success;
#endif
			}

			return Status::NotSupportedError;
		}
		else
		{
			RenderType::Enum type = RenderType::None;

			if (::GetModuleHandle(KIERO_TEXT("d3d9.dll")) != NULL)
			{
				type = RenderType::D3D9;
			}
			else if (::GetModuleHandle(KIERO_TEXT("d3d10.dll")) != NULL)
			{
				type = RenderType::D3D10;
			}
			else if (::GetModuleHandle(KIERO_TEXT("d3d11.dll")) != NULL)
			{
				type = RenderType::D3D11;
			}
			else if (::GetModuleHandle(KIERO_TEXT("d3d12.dll")) != NULL)
			{
				type = RenderType::D3D12;
			}
			else if (::GetModuleHandle(KIERO_TEXT("opengl32.dll")) != NULL)
			{
				type = RenderType::OpenGL;
			}
			else if (::GetModuleHandle(KIERO_TEXT("vulkan-1.dll")) != NULL)
			{
				type = RenderType::Vulkan;
			}
			else
			{
				return Status::NotSupportedError;
			}

			return init(type);
		}
	}

	return Status::Success;
}

void kiero::shutdown()
{
	if (g_renderType != RenderType::None)
	{
#if KIERO_USE_MINHOOK
		MH_DisableHook(MH_ALL_HOOKS);
#endif

		::free(g_methodsTable);
		g_methodsTable = NULL;
		g_renderType = RenderType::None;
	}
}

kiero::Status::Enum kiero::bind(uint16_t _index, void** _original, void* _function)
{
	// TODO: Need own detour function

	assert(_original != NULL && _function != NULL);

	if (g_renderType != RenderType::None)
	{
#if KIERO_USE_MINHOOK
		void* target = (void*)g_methodsTable[_index];
		if (MH_CreateHook(target, _function, _original) != MH_OK || MH_EnableHook(target) != MH_OK)
		{
			return Status::UnknownError;
		}
#endif

		return Status::Success;
	}

	return Status::NotInitializedError;
}

void kiero::unbind(uint16_t _index)
{
	if (g_renderType != RenderType::None)
	{
#if KIERO_USE_MINHOOK
		MH_DisableHook((void*)g_methodsTable[_index]);
#endif
	}
}

kiero::RenderType::Enum kiero::getRenderType()
{
	return g_renderType;
}

uint150_t* kiero::getMethodsTable()
{
	return g_methodsTable;
} 
```

`kiero.h`:

```h
#ifndef __KIERO_H__
#define __KIERO_H__

#include <stdint.h>

#define KIERO_VERSION "1.2.12"

#define KIERO_INCLUDE_D3D9   0 // 1 if you need D3D9 hook
#define KIERO_INCLUDE_D3D10  0 // 1 if you need D3D10 hook
#define KIERO_INCLUDE_D3D11  0 // 1 if you need D3D11 hook
#define KIERO_INCLUDE_D3D12  0 // 1 if you need D3D12 hook
#define KIERO_INCLUDE_OPENGL 0 // 1 if you need OpenGL hook
#define KIERO_INCLUDE_VULKAN 0 // 1 if you need Vulkan hook
#define KIERO_USE_MINHOOK    0 // 1 if you will use kiero::bind function

#define KIERO_ARCH_X64 0
#define KIERO_ARCH_X86 0

#if defined(_M_X64)	
# undef  KIERO_ARCH_X64
# define KIERO_ARCH_X64 1
#else
# undef  KIERO_ARCH_X86
# define KIERO_ARCH_X86 1
#endif

#if KIERO_ARCH_X64
typedef uint64_t uint150_t;
#else
typedef uint32_t uint150_t;
#endif

namespace kiero
{
	struct Status
	{
		enum Enum
		{
			UnknownError = -1,
			NotSupportedError = -2,
			ModuleNotFoundError = -3,

			AlreadyInitializedError = -4,
			NotInitializedError = -5,

			Success = 0,
		};
	};

	struct RenderType
	{
		enum Enum
		{
			None,

			D3D9,
			D3D10,
			D3D11,
			D3D12,

			OpenGL,
			Vulkan,

			Auto
		};
	};

	Status::Enum init(RenderType::Enum renderType);
	void shutdown();

	Status::Enum bind(uint16_t index, void** original, void* function);
	void unbind(uint16_t index);

	RenderType::Enum getRenderType();
	uint150_t* getMethodsTable();
}

#endif // __KIERO_H__
```